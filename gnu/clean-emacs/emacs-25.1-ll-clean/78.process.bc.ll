; ModuleID = './src/process.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.fd_callback_data = type { void (i32, i8*)*, i8*, i32 }
%struct.fd_set = type { [16 x i64] }
%struct.sockaddr_and_len = type { %struct.sockaddr*, i32 }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.emacs_globals = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.buffer = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.buffer_text, %struct.buffer_text*, %struct.buffer*, i64, i64, i64, i64, i64, i64, %struct.buffer*, i32, i32, [50 x i8], %struct.timespec, i64, i64, i64, i64, i64, %struct.region_cache*, %struct.region_cache*, %struct.region_cache*, i8, %struct.Lisp_Overlay*, %struct.Lisp_Overlay*, i64, i64 }
%struct.vectorlike_header = type { i64 }
%struct.buffer_text = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.interval*, %struct.Lisp_Marker*, i8 }
%struct.interval = type opaque
%struct.Lisp_Marker = type { i32, %struct.buffer*, %struct.Lisp_Marker*, i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.region_cache = type opaque
%struct.Lisp_Overlay = type { i32, %struct.Lisp_Overlay*, i64, i64, i64 }
%union.specbinding = type { %struct.anon.3 }
%struct.anon.3 = type { i8, i64, i64, i64 }
%struct.coding_system = type { i64, i32, i32, %union.anon.6, i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8*, i64, i64, i64, i64, i8*, i32*, i32, i32, [64 x i8], i32, i32, i1 (%struct.coding_system*, %struct.coding_detection_info*)*, void (%struct.coding_system*)*, i1 (%struct.coding_system*)* }
%union.anon.6 = type { %struct.ccl_spec*, [328 x i8] }
%struct.ccl_spec = type opaque
%struct.coding_detection_info = type { i32, i32, i32 }
%struct.Lisp_Boolfwd = type { i32, i8* }
%struct.Lisp_Objfwd = type { i32, i64* }
%struct.Lisp_Subr = type { %struct.vectorlike_header, %union.anon.16, i16, i16, i8*, i8*, i8* }
%union.anon.16 = type { i64 ()* }
%struct.socket_options = type { i8*, i32, i32, i32, i32 }
%struct.ifflag_def = type { i32, i8* }
%struct.Lisp_Process = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i32, [6 x i32], i64, i64, i32, i32, i8, i32, i32, %struct.gnutls_session_int*, %struct.gnutls_certificate_credentials_st*, %struct.gnutls_anon_client_credentials_st*, %struct.gnutls_x509_crt_int*, i32, i32, i32, i32, i8 }
%struct.gnutls_session_int = type opaque
%struct.gnutls_certificate_credentials_st = type opaque
%struct.gnutls_anon_client_credentials_st = type opaque
%struct.gnutls_x509_crt_int = type opaque
%struct.Lisp_Cons = type { i64, %union.anon }
%union.anon = type { i64 }
%struct.Lisp_Vector = type { %struct.vectorlike_header, [0 x i64] }
%union.Aligned_String = type { %struct.Lisp_String }
%struct.Lisp_String = type { i64, i64, %struct.interval*, i8* }
%struct.__sigset_t = type { [16 x i64] }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon.5 }
%union.anon.5 = type { [4 x i32] }
%struct.sockaddr_un = type { i16, [108 x i8] }
%struct.linger = type { i32, i32 }
%struct.addrinfo = type { i32, i32, i32, i32, i32, %struct.sockaddr*, i8*, %struct.addrinfo* }
%struct.servent = type { i8*, i8**, i32, i8* }
%union.__CONST_SOCKADDR_ARG = type { %struct.sockaddr* }
%union.__SOCKADDR_ARG = type { %struct.sockaddr* }
%struct.ifconf = type { i32, %union.anon.25 }
%union.anon.25 = type { i8* }
%struct.ifreq = type { %union.anon.26, %union.anon.27 }
%union.anon.26 = type { [16 x i8] }
%union.anon.27 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%union.u_sockaddr = type { %struct.sockaddr_in6, [84 x i8] }
%struct.Lisp_Hash_Table = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.hash_table_test, %struct.Lisp_Hash_Table* }
%struct.hash_table_test = type { i64, i64, i64, i1 (%struct.hash_table_test*, i64, i64)*, i64 (%struct.hash_table_test*, i64)* }
%struct.termios = type { i32, i32, i32, i32, i8, [32 x i8], i32, i32 }
%struct.sigaction = type { %union.anon.7, %struct.__sigset_t, i32, void ()* }
%union.anon.7 = type { void (i32)* }
%struct._GSource = type { i8*, %struct._GSourceCallbackFuncs*, %struct._GSourceFuncs*, i32, %struct._GMainContext*, i32, i32, i32, %struct._GSList*, %struct._GSource*, %struct._GSource*, i8*, %struct._GSourcePrivate* }
%struct._GSourceCallbackFuncs = type { void (i8*)*, void (i8*)*, void (i8*, %struct._GSource*, i32 (i8*)**, i8**)* }
%struct._GSourceFuncs = type { i32 (%struct._GSource*, i32*)*, i32 (%struct._GSource*)*, i32 (%struct._GSource*, i32 (i8*)*, i8*)*, {}*, i32 (i8*)*, void ()* }
%struct._GMainContext = type opaque
%struct._GSList = type { i8*, %struct._GSList* }
%struct._GSourcePrivate = type opaque
%union.anon.17 = type { i32 }
%union.anon.18 = type { i32 }
%union.anon.19 = type { i32 }
%union.anon.20 = type { i32 }
%union.anon.21 = type { i32 }
%union.anon.22 = type { i32 }
%union.anon.23 = type { i32 }
%union.anon.24 = type { i32 }
%union.anon.28 = type { i32 }
%union.anon.29 = type { i32 }

@fd_callback_info = internal global [1024 x %struct.fd_callback_data] zeroinitializer, align 16
@write_mask = internal global %struct.fd_set zeroinitializer, align 8
@max_input_desc = internal global i32 0, align 4
@Vprocess_alist = internal global i64 0, align 8
@deleted_pid_list = internal global i64 0, align 8
@process_tick = internal global i64 0, align 8
@input_wait_mask = internal global %struct.fd_set zeroinitializer, align 8
@non_keyboard_wait_mask = internal global %struct.fd_set zeroinitializer, align 8
@datagram_address = internal global [1024 x %struct.sockaddr_and_len] zeroinitializer, align 16
@.str = private unnamed_addr constant [12 x i8] c"%d.%d.%d.%d\00", align 1
@.str.1 = private unnamed_addr constant [15 x i8] c"%d.%d.%d.%d:%d\00", align 1
@.str.2 = private unnamed_addr constant [24 x i8] c"%x:%x:%x:%x:%x:%x:%x:%x\00", align 1
@.str.3 = private unnamed_addr constant [29 x i8] c"[%x:%x:%x:%x:%x:%x:%x:%x]:%d\00", align 1
@.str.4 = private unnamed_addr constant [12 x i8] c"<Family %d>\00", align 1
@.str.5 = private unnamed_addr constant [30 x i8] c"Process is not a pipe process\00", align 1
@.str.6 = private unnamed_addr constant [8 x i8] c" stderr\00", align 1
@globals = external global %struct.emacs_globals, align 8
@.str.7 = private unnamed_addr constant [24 x i8] c"Unknown connection type\00", align 1
@current_buffer = external global %struct.buffer*, align 8
@empty_unibyte_string = external global i64, align 8
@.str.8 = private unnamed_addr constant [22 x i8] c"Searching for program\00", align 1
@.str.9 = private unnamed_addr constant [49 x i8] c"Specified program for new process is a directory\00", align 1
@.str.10 = private unnamed_addr constant [14 x i8] c"Creating pipe\00", align 1
@chan_process = internal global [1024 x i64] zeroinitializer, align 16
@max_process_desc = internal global i32 0, align 4
@buffer_defaults = external global %struct.buffer, align 8
@specpdl = external global %union.specbinding*, align 8
@specpdl_ptr = external global %union.specbinding*, align 8
@.str.11 = private unnamed_addr constant [33 x i8] c"Process is not a network process\00", align 1
@.str.12 = private unnamed_addr constant [23 x i8] c"Process is not running\00", align 1
@.str.13 = private unnamed_addr constant [30 x i8] c"Unknown or unsupported option\00", align 1
@.str.14 = private unnamed_addr constant [21 x i8] c"Not a serial process\00", align 1
@.str.15 = private unnamed_addr constant [18 x i8] c"No port specified\00", align 1
@.str.16 = private unnamed_addr constant [21 x i8] c":speed not specified\00", align 1
@.str.17 = private unnamed_addr constant [28 x i8] c"Unsupported connection type\00", align 1
@.str.18 = private unnamed_addr constant [19 x i8] c"Malformed :address\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"Unknown address family\00", align 1
@.str.20 = private unnamed_addr constant [10 x i8] c"127.0.0.1\00", align 1
@.str.21 = private unnamed_addr constant [41 x i8] c":family local ignores the :host property\00", align 1
@.str.22 = private unnamed_addr constant [22 x i8] c"Service name too long\00", align 1
@.str.23 = private unnamed_addr constant [2 x i8] c"0\00", align 1
@.str.24 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@immediate_quit = external global i8, align 1
@pending_signals = external global i8, align 1
@.str.25 = private unnamed_addr constant [9 x i8] c"%s/%s %s\00", align 1
@.str.26 = private unnamed_addr constant [4 x i8] c"udp\00", align 1
@.str.27 = private unnamed_addr constant [4 x i8] c"tcp\00", align 1
@.str.28 = private unnamed_addr constant [20 x i8] c"Unknown service: %s\00", align 1
@.str.29 = private unnamed_addr constant [41 x i8] c"Cannot set reuse option on server socket\00", align 1
@.str.30 = private unnamed_addr constant [26 x i8] c"Cannot bind server socket\00", align 1
@.str.31 = private unnamed_addr constant [31 x i8] c"Cannot listen on server socket\00", align 1
@.str.32 = private unnamed_addr constant [14 x i8] c"Failed select\00", align 1
@.str.33 = private unnamed_addr constant [18 x i8] c"Failed getsockopt\00", align 1
@.str.34 = private unnamed_addr constant [15 x i8] c"Failed connect\00", align 1
@.str.35 = private unnamed_addr constant [27 x i8] c"make server process failed\00", align 1
@.str.36 = private unnamed_addr constant [27 x i8] c"make client process failed\00", align 1
@connect_wait_mask = internal global %struct.fd_set zeroinitializer, align 8
@num_pending_connects = internal global i32 0, align 4
@.str.37 = private unnamed_addr constant [61 x i8] c"Blocking call to accept-process-output with quit inhibited!!\00", align 1
@waiting_for_user_input_p = internal global i32 0, align 4
@timers_run = external global i32, align 4
@selected_window = external global i64, align 8
@update_tick = internal global i64 0, align 8
@non_process_wait_mask = internal global %struct.fd_set zeroinitializer, align 8
@process_output_delay_count = internal global i32 0, align 4
@frame_garbaged = external global i8, align 1
@process_output_skip = internal global i8 0, align 1
@interrupt_input = external global i8, align 1
@noninteractive = external global i8, align 1
@.str.38 = private unnamed_addr constant [6 x i8] c"open\0A\00", align 1
@update_mode_lines = external global i32, align 4
@.str.39 = private unnamed_addr constant [31 x i8] c"Process %s is not a subprocess\00", align 1
@.str.40 = private unnamed_addr constant [25 x i8] c"Process %s is not active\00", align 1
@.str.41 = private unnamed_addr constant [25 x i8] c"Cannot signal process %s\00", align 1
@.str.42 = private unnamed_addr constant [25 x i8] c"Undefined signal name %s\00", align 1
@proc_encode_coding_system = internal global [1024 x %struct.coding_system*] zeroinitializer, align 16
@.str.43 = private unnamed_addr constant [23 x i8] c"Process %s not running\00", align 1
@.str.44 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.45 = private unnamed_addr constant [2 x i8] c"\04\00", align 1
@.str.46 = private unnamed_addr constant [15 x i8] c"Failed tcdrain\00", align 1
@.str.47 = private unnamed_addr constant [10 x i8] c"/dev/null\00", align 1
@.str.48 = private unnamed_addr constant [20 x i8] c"Opening null device\00", align 1
@.str.49 = private unnamed_addr constant [10 x i8] c"\0AProcess \00", align 1
@.str.50 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.51 = private unnamed_addr constant [35 x i8] c"Input file descriptor of %s closed\00", align 1
@.str.52 = private unnamed_addr constant [36 x i8] c"Output file descriptor of %s closed\00", align 1
@proc_decode_coding_system = internal global [1024 x %struct.coding_system*] zeroinitializer, align 16
@kbd_is_on_hold = internal global i8 0, align 1
@lib_child_handler = internal global void (i32)* null, align 8
@inhibit_sentinels = common global i8 0, align 1
@initialized = external global i8, align 1
@proc_buffered_char = internal global [1024 x i32] zeroinitializer, align 16
@syms_of_process.b_fwd = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.53 = private unnamed_addr constant [24 x i8] c"delete-exited-processes\00", align 1
@syms_of_process.o_fwd = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.54 = private unnamed_addr constant [24 x i8] c"process-connection-type\00", align 1
@syms_of_process.o_fwd.55 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.56 = private unnamed_addr constant [32 x i8] c"process-adaptive-read-buffering\00", align 1
@Sprocess_list = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.16 { i64 ()* @Fprocess_list }, i16 0, i16 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.131, i32 0, i32 0), i8* null, i8* null }, align 8
@Snetwork_interface_list = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.16 { i64 ()* @Fnetwork_interface_list }, i16 0, i16 0, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.138, i32 0, i32 0), i8* null, i8* null }, align 8
@Swaiting_for_user_input_p = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.16 { i64 ()* @Fwaiting_for_user_input_p }, i16 0, i16 0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.154, i32 0, i32 0), i8* null, i8* null }, align 8
@socket_options = internal constant [9 x %struct.socket_options] [%struct.socket_options { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.162, i32 0, i32 0), i32 1, i32 25, i32 3, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.163, i32 0, i32 0), i32 1, i32 6, i32 1, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.164, i32 0, i32 0), i32 1, i32 5, i32 1, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.165, i32 0, i32 0), i32 1, i32 9, i32 1, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.166, i32 0, i32 0), i32 1, i32 13, i32 4, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.167, i32 0, i32 0), i32 1, i32 10, i32 1, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.168, i32 0, i32 0), i32 1, i32 12, i32 2, i32 1 }, %struct.socket_options { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.169, i32 0, i32 0), i32 1, i32 2, i32 1, i32 2 }, %struct.socket_options zeroinitializer], align 16
@.str.57 = private unnamed_addr constant [21 x i8] c"make-network-process\00", align 1
@Slist_system_processes = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.16 { i64 ()* @Flist_system_processes }, i16 0, i16 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.172, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.58 = private unnamed_addr constant [26 x i8] c"Process %s does not exist\00", align 1
@.str.59 = private unnamed_addr constant [41 x i8] c"Attempt to get process for a dead buffer\00", align 1
@.str.60 = private unnamed_addr constant [25 x i8] c"Buffer %s has no process\00", align 1
@.str.61 = private unnamed_addr constant [6 x i8] c"<%ld>\00", align 1
@.str.62 = private unnamed_addr constant [9 x i8] c"/dev/tty\00", align 1
@.str.63 = private unnamed_addr constant [12 x i8] c"Doing vfork\00", align 1
@.str.64 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.65 = private unnamed_addr constant [24 x i8] c"Bad option value for %s\00", align 1
@.str.66 = private unnamed_addr constant [26 x i8] c"Cannot set network option\00", align 1
@.str.67 = private unnamed_addr constant [24 x i8] c"interface name too long\00", align 1
@ifflag_table = internal constant [17 x %struct.ifflag_def] [%struct.ifflag_def { i32 1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.68, i32 0, i32 0) }, %struct.ifflag_def { i32 2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.69, i32 0, i32 0) }, %struct.ifflag_def { i32 4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.70, i32 0, i32 0) }, %struct.ifflag_def { i32 8, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.71, i32 0, i32 0) }, %struct.ifflag_def { i32 16, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.72, i32 0, i32 0) }, %struct.ifflag_def { i32 64, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.73, i32 0, i32 0) }, %struct.ifflag_def { i32 128, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.74, i32 0, i32 0) }, %struct.ifflag_def { i32 256, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.75, i32 0, i32 0) }, %struct.ifflag_def { i32 32, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.76, i32 0, i32 0) }, %struct.ifflag_def { i32 512, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.77, i32 0, i32 0) }, %struct.ifflag_def { i32 1024, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.78, i32 0, i32 0) }, %struct.ifflag_def { i32 2048, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.79, i32 0, i32 0) }, %struct.ifflag_def { i32 4096, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.80, i32 0, i32 0) }, %struct.ifflag_def { i32 8192, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.81, i32 0, i32 0) }, %struct.ifflag_def { i32 16384, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.82, i32 0, i32 0) }, %struct.ifflag_def { i32 32768, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.83, i32 0, i32 0) }, %struct.ifflag_def zeroinitializer], align 16
@.str.68 = private unnamed_addr constant [3 x i8] c"up\00", align 1
@.str.69 = private unnamed_addr constant [10 x i8] c"broadcast\00", align 1
@.str.70 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.71 = private unnamed_addr constant [9 x i8] c"loopback\00", align 1
@.str.72 = private unnamed_addr constant [12 x i8] c"pointopoint\00", align 1
@.str.73 = private unnamed_addr constant [8 x i8] c"running\00", align 1
@.str.74 = private unnamed_addr constant [6 x i8] c"noarp\00", align 1
@.str.75 = private unnamed_addr constant [8 x i8] c"promisc\00", align 1
@.str.76 = private unnamed_addr constant [11 x i8] c"notrailers\00", align 1
@.str.77 = private unnamed_addr constant [9 x i8] c"allmulti\00", align 1
@.str.78 = private unnamed_addr constant [7 x i8] c"master\00", align 1
@.str.79 = private unnamed_addr constant [6 x i8] c"slave\00", align 1
@.str.80 = private unnamed_addr constant [10 x i8] c"multicast\00", align 1
@.str.81 = private unnamed_addr constant [8 x i8] c"portsel\00", align 1
@.str.82 = private unnamed_addr constant [10 x i8] c"automedia\00", align 1
@.str.83 = private unnamed_addr constant [8 x i8] c"dynamic\00", align 1
@.str.84 = private unnamed_addr constant [24 x i8] c"accept failed with code\00", align 1
@.str.85 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@connect_counter = internal global i64 0, align 8
@.str.86 = private unnamed_addr constant [9 x i8] c" <%s:%d>\00", align 1
@.str.87 = private unnamed_addr constant [11 x i8] c" <[%s]:%d>\00", align 1
@.str.88 = private unnamed_addr constant [3 x i8] c" <\00", align 1
@.str.89 = private unnamed_addr constant [2 x i8] c">\00", align 1
@.str.90 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.91 = private unnamed_addr constant [13 x i8] c"accept from \00", align 1
@.str.92 = private unnamed_addr constant [11 x i8] c"open from \00", align 1
@running_asynch_code = external global i8, align 1
@Vcoding_system_hash_table = external global i64, align 8
@.str.93 = private unnamed_addr constant [26 x i8] c"error in process filter: \00", align 1
@.str.94 = private unnamed_addr constant [39 x i8] c"Output file descriptor of %s is closed\00", align 1
@.str.95 = private unnamed_addr constant [17 x i8] c"Sending datagram\00", align 1
@.str.96 = private unnamed_addr constant [50 x i8] c"process %s no longer connected to pipe; closed it\00", align 1
@.str.97 = private unnamed_addr constant [19 x i8] c"Writing to process\00", align 1
@.str.98 = private unnamed_addr constant [4 x i8] c"SIG\00", align 1
@.str.99 = private unnamed_addr constant [4 x i8] c"sig\00", align 1
@.str.100 = private unnamed_addr constant [28 x i8] c"error in process sentinel: \00", align 1
@.str.101 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str.102 = private unnamed_addr constant [16 x i8] c" (core dumped)\0A\00", align 1
@.str.103 = private unnamed_addr constant [9 x i8] c"deleted\0A\00", align 1
@.str.104 = private unnamed_addr constant [34 x i8] c"connection broken by remote peer\0A\00", align 1
@.str.105 = private unnamed_addr constant [10 x i8] c"finished\0A\00", align 1
@.str.106 = private unnamed_addr constant [29 x i8] c"exited abnormally with code \00", align 1
@.str.107 = private unnamed_addr constant [18 x i8] c"failed with code \00", align 1
@.str.108 = private unnamed_addr constant [9 x i8] c"processp\00", align 1
@Sprocessp = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocessp }, i16 1, i16 1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.108, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.109 = private unnamed_addr constant [12 x i8] c"get-process\00", align 1
@Sget_process = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fget_process }, i16 1, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.109, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.110 = private unnamed_addr constant [15 x i8] c"delete-process\00", align 1
@Sdelete_process = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fdelete_process }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.110, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.111 = private unnamed_addr constant [15 x i8] c"process-status\00", align 1
@Sprocess_status = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_status }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.111, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.112 = private unnamed_addr constant [20 x i8] c"process-exit-status\00", align 1
@Sprocess_exit_status = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_exit_status }, i16 1, i16 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.112, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.113 = private unnamed_addr constant [11 x i8] c"process-id\00", align 1
@Sprocess_id = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_id }, i16 1, i16 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.113, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.114 = private unnamed_addr constant [13 x i8] c"process-name\00", align 1
@Sprocess_name = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_name }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.114, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.115 = private unnamed_addr constant [17 x i8] c"process-tty-name\00", align 1
@Sprocess_tty_name = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_tty_name }, i16 1, i16 1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.115, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.116 = private unnamed_addr constant [16 x i8] c"process-command\00", align 1
@Sprocess_command = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_command }, i16 1, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.116, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.117 = private unnamed_addr constant [19 x i8] c"set-process-buffer\00", align 1
@Sset_process_buffer = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_buffer }, i16 2, i16 2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.117, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.118 = private unnamed_addr constant [15 x i8] c"process-buffer\00", align 1
@Sprocess_buffer = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_buffer }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.118, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.119 = private unnamed_addr constant [13 x i8] c"process-mark\00", align 1
@Sprocess_mark = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_mark }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.119, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.120 = private unnamed_addr constant [19 x i8] c"set-process-filter\00", align 1
@Sset_process_filter = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_filter }, i16 2, i16 2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.120, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.121 = private unnamed_addr constant [15 x i8] c"process-filter\00", align 1
@Sprocess_filter = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_filter }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.121, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.122 = private unnamed_addr constant [21 x i8] c"set-process-sentinel\00", align 1
@Sset_process_sentinel = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_sentinel }, i16 2, i16 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.122, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.123 = private unnamed_addr constant [17 x i8] c"process-sentinel\00", align 1
@Sprocess_sentinel = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_sentinel }, i16 1, i16 1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.123, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.124 = private unnamed_addr constant [24 x i8] c"set-process-window-size\00", align 1
@Sset_process_window_size = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fset_process_window_size }, i16 3, i16 3, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.124, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.125 = private unnamed_addr constant [39 x i8] c"set-process-inherit-coding-system-flag\00", align 1
@Sset_process_inherit_coding_system_flag = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_inherit_coding_system_flag }, i16 2, i16 2, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.125, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.126 = private unnamed_addr constant [31 x i8] c"set-process-query-on-exit-flag\00", align 1
@Sset_process_query_on_exit_flag = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_query_on_exit_flag }, i16 2, i16 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.126, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.127 = private unnamed_addr constant [27 x i8] c"process-query-on-exit-flag\00", align 1
@Sprocess_query_on_exit_flag = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_query_on_exit_flag }, i16 1, i16 1, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.127, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.128 = private unnamed_addr constant [16 x i8] c"process-contact\00", align 1
@Sprocess_contact = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fprocess_contact }, i16 1, i16 2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.128, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.129 = private unnamed_addr constant [14 x i8] c"process-plist\00", align 1
@Sprocess_plist = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_plist }, i16 1, i16 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.129, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.130 = private unnamed_addr constant [18 x i8] c"set-process-plist\00", align 1
@Sset_process_plist = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_plist }, i16 2, i16 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.130, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.131 = private unnamed_addr constant [13 x i8] c"process-list\00", align 1
@.str.132 = private unnamed_addr constant [13 x i8] c"make-process\00", align 1
@Smake_process = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmake_process }, i16 0, i16 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.132, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.133 = private unnamed_addr constant [18 x i8] c"make-pipe-process\00", align 1
@Smake_pipe_process = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmake_pipe_process }, i16 0, i16 -2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.133, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.134 = private unnamed_addr constant [25 x i8] c"serial-process-configure\00", align 1
@Sserial_process_configure = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fserial_process_configure }, i16 0, i16 -2, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.134, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.135 = private unnamed_addr constant [20 x i8] c"make-serial-process\00", align 1
@Smake_serial_process = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmake_serial_process }, i16 0, i16 -2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.135, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.136 = private unnamed_addr constant [27 x i8] c"set-network-process-option\00", align 1
@Sset_network_process_option = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Fset_network_process_option }, i16 3, i16 4, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.136, i32 0, i32 0), i8* null, i8* null }, align 8
@Smake_network_process = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmake_network_process }, i16 0, i16 -2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.57, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.137 = private unnamed_addr constant [23 x i8] c"format-network-address\00", align 1
@Sformat_network_address = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fformat_network_address }, i16 1, i16 2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.137, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.138 = private unnamed_addr constant [23 x i8] c"network-interface-list\00", align 1
@.str.139 = private unnamed_addr constant [23 x i8] c"network-interface-info\00", align 1
@Snetwork_interface_info = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fnetwork_interface_info }, i16 1, i16 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.139, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.140 = private unnamed_addr constant [25 x i8] c"process-datagram-address\00", align 1
@Sprocess_datagram_address = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_datagram_address }, i16 1, i16 1, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.140, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.141 = private unnamed_addr constant [29 x i8] c"set-process-datagram-address\00", align 1
@Sset_process_datagram_address = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_datagram_address }, i16 2, i16 2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.141, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.142 = private unnamed_addr constant [22 x i8] c"accept-process-output\00", align 1
@Saccept_process_output = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Faccept_process_output }, i16 0, i16 4, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.142, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.143 = private unnamed_addr constant [20 x i8] c"process-send-region\00", align 1
@Sprocess_send_region = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fprocess_send_region }, i16 3, i16 3, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.143, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.144 = private unnamed_addr constant [20 x i8] c"process-send-string\00", align 1
@Sprocess_send_string = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fprocess_send_string }, i16 2, i16 2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.144, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.145 = private unnamed_addr constant [18 x i8] c"interrupt-process\00", align 1
@Sinterrupt_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Finterrupt_process }, i16 0, i16 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.145, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.146 = private unnamed_addr constant [13 x i8] c"kill-process\00", align 1
@Skill_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fkill_process }, i16 0, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.146, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.147 = private unnamed_addr constant [13 x i8] c"quit-process\00", align 1
@Squit_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fquit_process }, i16 0, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.147, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.148 = private unnamed_addr constant [13 x i8] c"stop-process\00", align 1
@Sstop_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fstop_process }, i16 0, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.148, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.149 = private unnamed_addr constant [17 x i8] c"continue-process\00", align 1
@Scontinue_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fcontinue_process }, i16 0, i16 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.149, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.150 = private unnamed_addr constant [24 x i8] c"process-running-child-p\00", align 1
@Sprocess_running_child_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_running_child_p }, i16 0, i16 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.150, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.151 = private unnamed_addr constant [17 x i8] c"process-send-eof\00", align 1
@Sprocess_send_eof = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_send_eof }, i16 0, i16 1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.151, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.152 = private unnamed_addr constant [15 x i8] c"signal-process\00", align 1
@.str.153 = private unnamed_addr constant [43 x i8] c"sProcess (name or number): \0AnSignal code: \00", align 1
@Ssignal_process = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fsignal_process }, i16 2, i16 2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.152, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.153, i32 0, i32 0), i8* null }, align 8
@.str.154 = private unnamed_addr constant [25 x i8] c"waiting-for-user-input-p\00", align 1
@.str.155 = private unnamed_addr constant [13 x i8] c"process-type\00", align 1
@Sprocess_type = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_type }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.155, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.156 = private unnamed_addr constant [34 x i8] c"internal-default-process-sentinel\00", align 1
@Sinternal_default_process_sentinel = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Finternal_default_process_sentinel }, i16 2, i16 2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.156, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.157 = private unnamed_addr constant [32 x i8] c"internal-default-process-filter\00", align 1
@Sinternal_default_process_filter = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Finternal_default_process_filter }, i16 2, i16 2, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.157, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.158 = private unnamed_addr constant [26 x i8] c"set-process-coding-system\00", align 1
@Sset_process_coding_system = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fset_process_coding_system }, i16 1, i16 3, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.158, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.159 = private unnamed_addr constant [22 x i8] c"process-coding-system\00", align 1
@Sprocess_coding_system = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_coding_system }, i16 1, i16 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.159, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.160 = private unnamed_addr constant [29 x i8] c"set-process-filter-multibyte\00", align 1
@Sset_process_filter_multibyte = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_process_filter_multibyte }, i16 2, i16 2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.160, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.161 = private unnamed_addr constant [27 x i8] c"process-filter-multibyte-p\00", align 1
@Sprocess_filter_multibyte_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_filter_multibyte_p }, i16 1, i16 1, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.161, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.162 = private unnamed_addr constant [14 x i8] c":bindtodevice\00", align 1
@.str.163 = private unnamed_addr constant [11 x i8] c":broadcast\00", align 1
@.str.164 = private unnamed_addr constant [11 x i8] c":dontroute\00", align 1
@.str.165 = private unnamed_addr constant [11 x i8] c":keepalive\00", align 1
@.str.166 = private unnamed_addr constant [8 x i8] c":linger\00", align 1
@.str.167 = private unnamed_addr constant [11 x i8] c":oobinline\00", align 1
@.str.168 = private unnamed_addr constant [10 x i8] c":priority\00", align 1
@.str.169 = private unnamed_addr constant [11 x i8] c":reuseaddr\00", align 1
@.str.170 = private unnamed_addr constant [19 x i8] c"get-buffer-process\00", align 1
@Sget_buffer_process = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fget_buffer_process }, i16 1, i16 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.170, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.171 = private unnamed_addr constant [35 x i8] c"process-inherit-coding-system-flag\00", align 1
@Sprocess_inherit_coding_system_flag = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_inherit_coding_system_flag }, i16 1, i16 1, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.171, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.172 = private unnamed_addr constant [22 x i8] c"list-system-processes\00", align 1
@.str.173 = private unnamed_addr constant [19 x i8] c"process-attributes\00", align 1
@Sprocess_attributes = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprocess_attributes }, i16 1, i16 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.173, i32 0, i32 0), i8* null, i8* null }, align 8

; Function Attrs: nounwind uwtable
define void @add_read_fd(i32 %fd, void (i32, i8*)* %func, i8* %data) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %func.addr = alloca void (i32, i8*)*, align 8
  %data.addr = alloca i8*, align 8
  store i32 %fd, i32* %fd.addr, align 4
  store void (i32, i8*)* %func, void (i32, i8*)** %func.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load i32, i32* %fd.addr, align 4
  call void @add_keyboard_wait_descriptor(i32 %0)
  %1 = load void (i32, i8*)*, void (i32, i8*)** %func.addr, align 8
  %2 = load i32, i32* %fd.addr, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom
  %func1 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx, i32 0, i32 0
  store void (i32, i8*)* %1, void (i32, i8*)** %func1, align 8
  %3 = load i8*, i8** %data.addr, align 8
  %4 = load i32, i32* %fd.addr, align 4
  %idxprom2 = sext i32 %4 to i64
  %arrayidx3 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom2
  %data4 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx3, i32 0, i32 1
  store i8* %3, i8** %data4, align 8
  %5 = load i32, i32* %fd.addr, align 4
  %idxprom5 = sext i32 %5 to i64
  %arrayidx6 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom5
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx6, i32 0, i32 2
  %6 = load i32, i32* %condition, align 4
  %or = or i32 %6, 1
  store i32 %or, i32* %condition, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @add_keyboard_wait_descriptor(i32 %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, i32* %desc.addr, align 4
  %0 = load i32, i32* %desc.addr, align 4
  call void @fd_SET(i32 %0, %struct.fd_set* @input_wait_mask)
  %1 = load i32, i32* %desc.addr, align 4
  call void @fd_SET(i32 %1, %struct.fd_set* @non_process_wait_mask)
  %2 = load i32, i32* %desc.addr, align 4
  %3 = load i32, i32* @max_input_desc, align 4
  %cmp = icmp sgt i32 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32, i32* %desc.addr, align 4
  store i32 %4, i32* @max_input_desc, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @delete_read_fd(i32 %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  call void @delete_keyboard_wait_descriptor(i32 %0)
  %1 = load i32, i32* %fd.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx, i32 0, i32 2
  %2 = load i32, i32* %condition, align 4
  %and = and i32 %2, -2
  store i32 %and, i32* %condition, align 4
  %3 = load i32, i32* %fd.addr, align 4
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom1
  %condition3 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx2, i32 0, i32 2
  %4 = load i32, i32* %condition3, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %fd.addr, align 4
  %idxprom4 = sext i32 %5 to i64
  %arrayidx5 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom4
  %func = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx5, i32 0, i32 0
  store void (i32, i8*)* null, void (i32, i8*)** %func, align 8
  %6 = load i32, i32* %fd.addr, align 4
  %idxprom6 = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom6
  %data = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx7, i32 0, i32 1
  store i8* null, i8** %data, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @delete_keyboard_wait_descriptor(i32 %desc) #0 {
entry:
  %desc.addr = alloca i32, align 4
  store i32 %desc, i32* %desc.addr, align 4
  %0 = load i32, i32* %desc.addr, align 4
  call void @fd_CLR(i32 %0, %struct.fd_set* @input_wait_mask)
  %1 = load i32, i32* %desc.addr, align 4
  call void @fd_CLR(i32 %1, %struct.fd_set* @non_process_wait_mask)
  %2 = load i32, i32* %desc.addr, align 4
  call void @delete_input_desc(i32 %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @add_write_fd(i32 %fd, void (i32, i8*)* %func, i8* %data) #0 {
entry:
  %fd.addr = alloca i32, align 4
  %func.addr = alloca void (i32, i8*)*, align 8
  %data.addr = alloca i8*, align 8
  store i32 %fd, i32* %fd.addr, align 4
  store void (i32, i8*)* %func, void (i32, i8*)** %func.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load i32, i32* %fd.addr, align 4
  call void @fd_SET(i32 %0, %struct.fd_set* @write_mask)
  %1 = load i32, i32* %fd.addr, align 4
  %2 = load i32, i32* @max_input_desc, align 4
  %cmp = icmp sgt i32 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %fd.addr, align 4
  store i32 %3, i32* @max_input_desc, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load void (i32, i8*)*, void (i32, i8*)** %func.addr, align 8
  %5 = load i32, i32* %fd.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom
  %func1 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx, i32 0, i32 0
  store void (i32, i8*)* %4, void (i32, i8*)** %func1, align 8
  %6 = load i8*, i8** %data.addr, align 8
  %7 = load i32, i32* %fd.addr, align 4
  %idxprom2 = sext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom2
  %data4 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx3, i32 0, i32 1
  store i8* %6, i8** %data4, align 8
  %8 = load i32, i32* %fd.addr, align 4
  %idxprom5 = sext i32 %8 to i64
  %arrayidx6 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom5
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx6, i32 0, i32 2
  %9 = load i32, i32* %condition, align 4
  %or = or i32 %9, 2
  store i32 %or, i32* %condition, align 4
  ret void
}

declare void @fd_SET(i32, %struct.fd_set*) #1

; Function Attrs: nounwind uwtable
define void @delete_write_fd(i32 %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  call void @fd_CLR(i32 %0, %struct.fd_set* @write_mask)
  %1 = load i32, i32* %fd.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx, i32 0, i32 2
  %2 = load i32, i32* %condition, align 4
  %and = and i32 %2, -3
  store i32 %and, i32* %condition, align 4
  %3 = load i32, i32* %fd.addr, align 4
  %idxprom1 = sext i32 %3 to i64
  %arrayidx2 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom1
  %condition3 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx2, i32 0, i32 2
  %4 = load i32, i32* %condition3, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %fd.addr, align 4
  %idxprom4 = sext i32 %5 to i64
  %arrayidx5 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom4
  %func = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx5, i32 0, i32 0
  store void (i32, i8*)* null, void (i32, i8*)** %func, align 8
  %6 = load i32, i32* %fd.addr, align 4
  %idxprom6 = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom6
  %data = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx7, i32 0, i32 1
  store i8* null, i8** %data, align 8
  %7 = load i32, i32* %fd.addr, align 4
  call void @delete_input_desc(i32 %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @fd_CLR(i32, %struct.fd_set*) #1

; Function Attrs: nounwind uwtable
define internal void @delete_input_desc(i32 %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %1 = load i32, i32* @max_input_desc, align 4
  %cmp = icmp eq i32 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then
  %2 = load i32, i32* %fd.addr, align 4
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %fd.addr, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %3 = load i32, i32* %fd.addr, align 4
  %cmp1 = icmp sle i32 0, %3
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %4 = load i32, i32* %fd.addr, align 4
  %call = call zeroext i1 @fd_ISSET(i32 %4, %struct.fd_set* @input_wait_mask)
  br i1 %call, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %5 = load i32, i32* %fd.addr, align 4
  %call2 = call zeroext i1 @fd_ISSET(i32 %5, %struct.fd_set* @write_mask)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %6 = phi i1 [ true, %land.rhs ], [ %call2, %lor.rhs ]
  %lnot = xor i1 %6, true
  br label %land.end

land.end:                                         ; preds = %lor.end, %do.cond
  %7 = phi i1 [ false, %do.cond ], [ %lnot, %lor.end ]
  br i1 %7, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %8 = load i32, i32* %fd.addr, align 4
  store i32 %8, i32* @max_input_desc, align 4
  br label %if.end

if.end:                                           ; preds = %do.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocessp(i64 %object) #0 {
entry:
  %object.addr = alloca i64, align 8
  store i64 %object, i64* %object.addr, align 8
  %0 = load i64, i64* %object.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  ret i64 %cond
}

declare zeroext i1 @PROCESSP(i64) #1

declare i64 @builtin_lisp_symbol(i32) #1

; Function Attrs: nounwind uwtable
define i64 @Fget_process(i64 %name) #0 {
entry:
  %retval = alloca i64, align 8
  %name.addr = alloca i64, align 8
  store i64 %name, i64* %name.addr, align 8
  %0 = load i64, i64* %name.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %name.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %name.addr, align 8
  call void @CHECK_STRING(i64 %2)
  %3 = load i64, i64* %name.addr, align 8
  %4 = load i64, i64* @Vprocess_alist, align 8
  %call1 = call i64 @Fassoc(i64 %3, i64 %4)
  %call2 = call i64 @Fcdr(i64 %call1)
  store i64 %call2, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i64, i64* %retval
  ret i64 %5
}

declare void @CHECK_STRING(i64) #1

declare i64 @Fcdr(i64) #1

declare i64 @Fassoc(i64, i64) #1

; Function Attrs: nounwind uwtable
define void @record_deleted_pid(i32 %pid, i64 %filename) #0 {
entry:
  %pid.addr = alloca i32, align 4
  %filename.addr = alloca i64, align 8
  store i32 %pid, i32* %pid.addr, align 4
  store i64 %filename, i64* %filename.addr, align 8
  %0 = load i32, i32* %pid.addr, align 4
  %cmp = icmp sle i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %pid.addr, align 4
  %conv = sext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %pid.addr, align 4
  %conv3 = sext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %pid.addr, align 4
  %conv6 = sitofp i32 %3 to double
  %call = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %pid.addr, align 4
  %conv7 = sext i32 %4 to i64
  %shl = shl i64 %conv7, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %add, %cond.false ]
  %5 = load i64, i64* %filename.addr, align 8
  %call8 = call i64 @Fcons(i64 %cond, i64 %5)
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %6 = load i64, i64* @deleted_pid_list, align 8
  %call10 = call i64 @Fdelq(i64 %call9, i64 %6)
  %call11 = call i64 @Fcons(i64 %call8, i64 %call10)
  store i64 %call11, i64* @deleted_pid_list, align 8
  ret void
}

declare i64 @Fcons(i64, i64) #1

declare i64 @make_float(double) #1

declare i64 @Fdelq(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdelete_process(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %symbol = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %0)
  store i64 %call, i64* %process.addr, align 8
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call1, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.clear = and i8 %bf.load, 127
  store i8 %bf.clear, i8* %raw_status_new, align 8
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 10
  %4 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp = icmp eq i64 %4, %call2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type3 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 10
  %6 = load i64, i64* %type3, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp5 = icmp eq i64 %6, %call4
  br i1 %cmp5, label %if.then, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type7 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 10
  %8 = load i64, i64* %type7, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp9 = icmp eq i64 %8, %call8
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false.6, %lor.lhs.false, %entry
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 387)
  %call11 = call i64 @list2(i64 %call10, i64 2)
  call void @pset_status(%struct.Lisp_Process* %9, i64 %call11)
  %10 = load i64, i64* @process_tick, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, i64* @process_tick, align 8
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 24
  store i64 %inc, i64* %tick, align 8
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call12 = call i32 @status_notify(%struct.Lisp_Process* %12, %struct.Lisp_Process* null)
  call void @redisplay_preserve_echo_area(i32 13)
  br label %if.end.44

if.else:                                          ; preds = %lor.lhs.false.6
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %alive = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %13, i32 0, i32 28
  %bf.load13 = load i8, i8* %alive, align 8
  %bf.lshr = lshr i8 %bf.load13, 6
  %bf.clear14 = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear14 to i1
  br i1 %bf.cast, label %if.then.15, label %if.end

if.then.15:                                       ; preds = %if.else
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  call void @record_kill_process(%struct.Lisp_Process* %14, i64 %call16)
  br label %if.end

if.end:                                           ; preds = %if.then.15, %if.else
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 21
  %16 = load i32, i32* %infd, align 4
  %cmp17 = icmp sge i32 %16, 0
  br i1 %cmp17, label %if.then.18, label %if.end.43

if.then.18:                                       ; preds = %if.end
  %17 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new19 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %17, i32 0, i32 28
  %bf.load20 = load i8, i8* %raw_status_new19, align 8
  %bf.lshr21 = lshr i8 %bf.load20, 7
  %bf.cast22 = trunc i8 %bf.lshr21 to i1
  br i1 %bf.cast22, label %if.then.23, label %if.end.24

if.then.23:                                       ; preds = %if.then.18
  %18 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  call void @update_status(%struct.Lisp_Process* %18)
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.23, %if.then.18
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 12
  %20 = load i64, i64* %status, align 8
  %and = and i64 %20, 7
  %conv = trunc i64 %and to i32
  %cmp25 = icmp eq i32 %conv, 3
  br i1 %cmp25, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.24
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status27 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 12
  %22 = load i64, i64* %status27, align 8
  %sub = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.24
  %26 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status28 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %26, i32 0, i32 12
  %27 = load i64, i64* %status28, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %25, %cond.true ], [ %27, %cond.false ]
  store i64 %cond, i64* %symbol, align 8
  %28 = load i64, i64* %symbol, align 8
  %call29 = call i64 @builtin_lisp_symbol(i32 862)
  %cmp30 = icmp eq i64 %28, %call29
  br i1 %cmp30, label %if.end.39, label %lor.lhs.false.32

lor.lhs.false.32:                                 ; preds = %cond.end
  %29 = load i64, i64* %symbol, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 387)
  %cmp34 = icmp eq i64 %29, %call33
  br i1 %cmp34, label %if.end.39, label %if.then.36

if.then.36:                                       ; preds = %lor.lhs.false.32
  %30 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 862)
  %call38 = call i64 @list2(i64 %call37, i64 38)
  call void @pset_status(%struct.Lisp_Process* %30, i64 %call38)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.36, %lor.lhs.false.32, %cond.end
  %31 = load i64, i64* @process_tick, align 8
  %inc40 = add nsw i64 %31, 1
  store i64 %inc40, i64* @process_tick, align 8
  %32 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick41 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %32, i32 0, i32 24
  store i64 %inc40, i64* %tick41, align 8
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call42 = call i32 @status_notify(%struct.Lisp_Process* %33, %struct.Lisp_Process* null)
  call void @redisplay_preserve_echo_area(i32 13)
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.39, %if.end
  br label %if.end.44

if.end.44:                                        ; preds = %if.end.43, %if.then
  %34 = load i64, i64* %process.addr, align 8
  call void @remove_process(i64 %34)
  %call45 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call45
}

; Function Attrs: nounwind uwtable
define internal i64 @get_process(i64 %name) #0 {
entry:
  %name.addr = alloca i64, align 8
  %proc = alloca i64, align 8
  %obj = alloca i64, align 8
  store i64 %name, i64* %name.addr, align 8
  %0 = load i64, i64* %name.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %name.addr, align 8
  %call1 = call i64 @Fget_process(i64 %1)
  store i64 %call1, i64* %obj, align 8
  %2 = load i64, i64* %obj, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  %3 = load i64, i64* %name.addr, align 8
  %call4 = call i64 @Fget_buffer(i64 %3)
  store i64 %call4, i64* %obj, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  %4 = load i64, i64* %obj, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.then.7, label %if.end.9

if.then.7:                                        ; preds = %if.end
  %5 = load i64, i64* %name.addr, align 8
  %call8 = call i8* @SDATA(i64 %5)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.58, i32 0, i32 0), i8* %call8) #8
  unreachable

if.end.9:                                         ; preds = %if.end
  br label %if.end.16

if.else:                                          ; preds = %entry
  %6 = load i64, i64* %name.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %6, %call10
  br i1 %cmp11, label %if.then.12, label %if.else.14

if.then.12:                                       ; preds = %if.else
  %call13 = call i64 @Fcurrent_buffer()
  store i64 %call13, i64* %obj, align 8
  br label %if.end.15

if.else.14:                                       ; preds = %if.else
  %7 = load i64, i64* %name.addr, align 8
  store i64 %7, i64* %obj, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.else.14, %if.then.12
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %if.end.9
  %8 = load i64, i64* %obj, align 8
  %call17 = call zeroext i1 @BUFFERP(i64 %8)
  br i1 %call17, label %if.then.18, label %if.else.32

if.then.18:                                       ; preds = %if.end.16
  %9 = load i64, i64* %obj, align 8
  %call19 = call %struct.buffer* @XBUFFER(i64 %9)
  %name_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call19, i32 0, i32 1
  %10 = load i64, i64* %name_, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %10, %call20
  br i1 %cmp21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %if.then.18
  call void (i8*, ...) @error(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.59, i32 0, i32 0)) #8
  unreachable

if.end.23:                                        ; preds = %if.then.18
  %11 = load i64, i64* %obj, align 8
  %call24 = call i64 @Fget_buffer_process(i64 %11)
  store i64 %call24, i64* %proc, align 8
  %12 = load i64, i64* %proc, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %12, %call25
  br i1 %cmp26, label %if.then.27, label %if.end.31

if.then.27:                                       ; preds = %if.end.23
  %13 = load i64, i64* %obj, align 8
  %call28 = call %struct.buffer* @XBUFFER(i64 %13)
  %name_29 = getelementptr inbounds %struct.buffer, %struct.buffer* %call28, i32 0, i32 1
  %14 = load i64, i64* %name_29, align 8
  %call30 = call i8* @SDATA(i64 %14)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.60, i32 0, i32 0), i8* %call30) #8
  unreachable

if.end.31:                                        ; preds = %if.end.23
  br label %if.end.33

if.else.32:                                       ; preds = %if.end.16
  %15 = load i64, i64* %obj, align 8
  call void @CHECK_PROCESS(i64 %15)
  %16 = load i64, i64* %obj, align 8
  store i64 %16, i64* %proc, align 8
  br label %if.end.33

if.end.33:                                        ; preds = %if.else.32, %if.end.31
  %17 = load i64, i64* %proc, align 8
  ret i64 %17
}

declare %struct.Lisp_Process* @XPROCESS(i64) #1

; Function Attrs: nounwind uwtable
define internal void @pset_status(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 12
  store i64 %0, i64* %status, align 8
  ret void
}

declare i64 @list2(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @status_notify(%struct.Lisp_Process* %deleting_process, %struct.Lisp_Process* %wait_proc) #0 {
entry:
  %deleting_process.addr = alloca %struct.Lisp_Process*, align 8
  %wait_proc.addr = alloca %struct.Lisp_Process*, align 8
  %proc = alloca i64, align 8
  %tail = alloca i64, align 8
  %msg = alloca i64, align 8
  %got_some_output = alloca i32, align 4
  %symbol = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %nread = alloca i32, align 4
  store %struct.Lisp_Process* %deleting_process, %struct.Lisp_Process** %deleting_process.addr, align 8
  store %struct.Lisp_Process* %wait_proc, %struct.Lisp_Process** %wait_proc.addr, align 8
  store i32 -1, i32* %got_some_output, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %tail, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %msg, align 8
  %0 = load i64, i64* @process_tick, align 8
  store i64 %0, i64* @update_tick, align 8
  %1 = load i64, i64* @Vprocess_alist, align 8
  store i64 %1, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i64, i64* %tail, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %3, 3
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %5, i32 0, i32 0
  %6 = load i64, i64* %car, align 8
  %sub3 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub3 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %proc, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %10 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %10, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %11 = load i64, i64* %proc, align 8
  %call4 = call %struct.Lisp_Process* @XPROCESS(i64 %11)
  store %struct.Lisp_Process* %call4, %struct.Lisp_Process** %p, align 8
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 24
  %13 = load i64, i64* %tick, align 8
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %update_tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 25
  %15 = load i64, i64* %update_tick, align 8
  %cmp5 = icmp ne i64 %13, %15
  br i1 %cmp5, label %if.then, label %if.end.81

if.then:                                          ; preds = %for.body
  %16 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick7 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %16, i32 0, i32 24
  %17 = load i64, i64* %tick7, align 8
  %18 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %update_tick8 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %18, i32 0, i32 25
  store i64 %17, i64* %update_tick8, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.43, %if.then
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 4
  %20 = load i64, i64* %filter, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp10 = icmp eq i64 %20, %call9
  br i1 %cmp10, label %land.end.30, label %land.lhs.true

land.lhs.true:                                    ; preds = %while.cond
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 12
  %22 = load i64, i64* %status, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 293)
  %cmp13 = icmp eq i64 %22, %call12
  br i1 %cmp13, label %land.end.30, label %land.lhs.true.15

land.lhs.true.15:                                 ; preds = %land.lhs.true
  %23 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status16 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %23, i32 0, i32 12
  %24 = load i64, i64* %status16, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 625)
  %cmp18 = icmp eq i64 %24, %call17
  br i1 %cmp18, label %land.end.30, label %land.lhs.true.20

land.lhs.true.20:                                 ; preds = %land.lhs.true.15
  %25 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %25, i32 0, i32 3
  %26 = load i64, i64* %command, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp22 = icmp eq i64 %26, %call21
  br i1 %cmp22, label %land.end.30, label %land.lhs.true.24

land.lhs.true.24:                                 ; preds = %land.lhs.true.20
  %27 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %27, i32 0, i32 21
  %28 = load i32, i32* %infd, align 4
  %cmp25 = icmp sge i32 %28, 0
  br i1 %cmp25, label %land.rhs.27, label %land.end.30

land.rhs.27:                                      ; preds = %land.lhs.true.24
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %30 = load %struct.Lisp_Process*, %struct.Lisp_Process** %deleting_process.addr, align 8
  %cmp28 = icmp ne %struct.Lisp_Process* %29, %30
  br label %land.end.30

land.end.30:                                      ; preds = %land.rhs.27, %land.lhs.true.24, %land.lhs.true.20, %land.lhs.true.15, %land.lhs.true, %while.cond
  %31 = phi i1 [ false, %land.lhs.true.24 ], [ false, %land.lhs.true.20 ], [ false, %land.lhs.true.15 ], [ false, %land.lhs.true ], [ false, %while.cond ], [ %cmp28, %land.rhs.27 ]
  br i1 %31, label %while.body, label %while.end

while.body:                                       ; preds = %land.end.30
  %32 = load i64, i64* %proc, align 8
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd31 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %33, i32 0, i32 21
  %34 = load i32, i32* %infd31, align 4
  %call32 = call i32 @read_process_output(i64 %32, i32 %34)
  store i32 %call32, i32* %nread, align 4
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool = icmp ne %struct.Lisp_Process* %35, null
  br i1 %tobool, label %lor.lhs.false, label %land.lhs.true.36

lor.lhs.false:                                    ; preds = %while.body
  %36 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %37 = load i64, i64* %proc, align 8
  %call33 = call %struct.Lisp_Process* @XPROCESS(i64 %37)
  %cmp34 = icmp eq %struct.Lisp_Process* %36, %call33
  br i1 %cmp34, label %land.lhs.true.36, label %if.end

land.lhs.true.36:                                 ; preds = %lor.lhs.false, %while.body
  %38 = load i32, i32* %got_some_output, align 4
  %39 = load i32, i32* %nread, align 4
  %cmp37 = icmp slt i32 %38, %39
  br i1 %cmp37, label %if.then.39, label %if.end

if.then.39:                                       ; preds = %land.lhs.true.36
  %40 = load i32, i32* %nread, align 4
  store i32 %40, i32* %got_some_output, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.39, %land.lhs.true.36, %lor.lhs.false
  %41 = load i32, i32* %nread, align 4
  %cmp40 = icmp sle i32 %41, 0
  br i1 %cmp40, label %if.then.42, label %if.end.43

if.then.42:                                       ; preds = %if.end
  br label %while.end

if.end.43:                                        ; preds = %if.end
  br label %while.cond

while.end:                                        ; preds = %if.then.42, %land.end.30
  %42 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %42, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %while.end
  %43 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  call void @update_status(%struct.Lisp_Process* %43)
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.44, %while.end
  %44 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call46 = call i64 @status_message(%struct.Lisp_Process* %44)
  store i64 %call46, i64* %msg, align 8
  %45 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status47 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %45, i32 0, i32 12
  %46 = load i64, i64* %status47, align 8
  store i64 %46, i64* %symbol, align 8
  %47 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status48 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %47, i32 0, i32 12
  %48 = load i64, i64* %status48, align 8
  %and49 = and i64 %48, 7
  %conv50 = trunc i64 %and49 to i32
  %cmp51 = icmp eq i32 %conv50, 3
  br i1 %cmp51, label %if.then.53, label %if.end.57

if.then.53:                                       ; preds = %if.end.45
  %49 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status54 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %49, i32 0, i32 12
  %50 = load i64, i64* %status54, align 8
  %sub55 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub55 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %car56 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 0
  %53 = load i64, i64* %car56, align 8
  store i64 %53, i64* %symbol, align 8
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.53, %if.end.45
  %54 = load i64, i64* %symbol, align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 862)
  %cmp59 = icmp eq i64 %54, %call58
  br i1 %cmp59, label %if.then.69, label %lor.lhs.false.61

lor.lhs.false.61:                                 ; preds = %if.end.57
  %55 = load i64, i64* %symbol, align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 387)
  %cmp63 = icmp eq i64 %55, %call62
  br i1 %cmp63, label %if.then.69, label %lor.lhs.false.65

lor.lhs.false.65:                                 ; preds = %lor.lhs.false.61
  %56 = load i64, i64* %symbol, align 8
  %call66 = call i64 @builtin_lisp_symbol(i32 270)
  %cmp67 = icmp eq i64 %56, %call66
  br i1 %cmp67, label %if.then.69, label %if.end.73

if.then.69:                                       ; preds = %lor.lhs.false.65, %lor.lhs.false.61, %if.end.57
  %57 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 436), align 1
  %tobool70 = trunc i8 %57 to i1
  br i1 %tobool70, label %if.then.71, label %if.else

if.then.71:                                       ; preds = %if.then.69
  %58 = load i64, i64* %proc, align 8
  call void @remove_process(i64 %58)
  br label %if.end.72

if.else:                                          ; preds = %if.then.69
  %59 = load i64, i64* %proc, align 8
  call void @deactivate_process(i64 %59)
  br label %if.end.72

if.end.72:                                        ; preds = %if.else, %if.then.71
  br label %if.end.73

if.end.73:                                        ; preds = %if.end.72, %lor.lhs.false.65
  %60 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick74 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %60, i32 0, i32 24
  %61 = load i64, i64* %tick74, align 8
  %62 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %update_tick75 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %62, i32 0, i32 25
  store i64 %61, i64* %update_tick75, align 8
  %63 = load i64, i64* %proc, align 8
  %64 = load i64, i64* %msg, align 8
  call void @exec_sentinel(i64 %63, i64 %64)
  %65 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %65, i32 0, i32 7
  %66 = load i64, i64* %buffer, align 8
  %call76 = call zeroext i1 @BUFFERP(i64 %66)
  br i1 %call76, label %if.then.77, label %if.end.80

if.then.77:                                       ; preds = %if.end.73
  %67 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer78 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %67, i32 0, i32 7
  %68 = load i64, i64* %buffer78, align 8
  %call79 = call %struct.buffer* @XBUFFER(i64 %68)
  call void @bset_update_mode_line(%struct.buffer* %call79)
  br label %if.end.80

if.end.80:                                        ; preds = %if.then.77, %if.end.73
  br label %if.end.81

if.end.81:                                        ; preds = %if.end.80, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.81
  %69 = load i64, i64* %tail, align 8
  %sub82 = sub nsw i64 %69, 3
  %70 = inttoptr i64 %sub82 to i8*
  %71 = bitcast i8* %70 to %struct.Lisp_Cons*
  %u83 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %71, i32 0, i32 1
  %cdr84 = bitcast %union.anon* %u83 to i64*
  %72 = load i64, i64* %cdr84, align 8
  store i64 %72, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %73 = load i32, i32* %got_some_output, align 4
  ret i32 %73
}

declare void @redisplay_preserve_echo_area(i32) #1

declare void @record_kill_process(%struct.Lisp_Process*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @update_status(%struct.Lisp_Process* %p) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %raw_status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 29
  %2 = load i32, i32* %raw_status, align 4
  %call = call i64 @status_convert(i32 %2)
  call void @pset_status(%struct.Lisp_Process* %0, i64 %call)
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.clear = and i8 %bf.load, 127
  store i8 %bf.clear, i8* %raw_status_new, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @remove_process(i64 %proc) #0 {
entry:
  %proc.addr = alloca i64, align 8
  %pair = alloca i64, align 8
  store i64 %proc, i64* %proc.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  %1 = load i64, i64* @Vprocess_alist, align 8
  %call = call i64 @Frassq(i64 %0, i64 %1)
  store i64 %call, i64* %pair, align 8
  %2 = load i64, i64* %pair, align 8
  %3 = load i64, i64* @Vprocess_alist, align 8
  %call1 = call i64 @Fdelq(i64 %2, i64 %3)
  store i64 %call1, i64* @Vprocess_alist, align 8
  %4 = load i64, i64* %proc.addr, align 8
  call void @deactivate_process(i64 %4)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_status(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %status = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call i64 @Fget_process(i64 %1)
  store i64 %call1, i64* %process.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %process.addr, align 8
  %call2 = call i64 @get_process(i64 %2)
  store i64 %call2, i64* %process.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load i64, i64* %process.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call3
  br i1 %cmp, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  %4 = load i64, i64* %process.addr, align 8
  store i64 %4, i64* %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load i64, i64* %process.addr, align 8
  %call6 = call %struct.Lisp_Process* @XPROCESS(i64 %5)
  store %struct.Lisp_Process* %call6, %struct.Lisp_Process** %p, align 8
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.5
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  call void @update_status(%struct.Lisp_Process* %7)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %if.end.5
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 12
  %9 = load i64, i64* %status9, align 8
  store i64 %9, i64* %status, align 8
  %10 = load i64, i64* %status, align 8
  %and = and i64 %10, 7
  %conv = trunc i64 %and to i32
  %cmp10 = icmp eq i32 %conv, 3
  br i1 %cmp10, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end.8
  %11 = load i64, i64* %status, align 8
  %sub = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car, align 8
  store i64 %14, i64* %status, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end.8
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 10
  %16 = load i64, i64* %type, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp15 = icmp eq i64 %16, %call14
  br i1 %cmp15, label %if.then.26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.13
  %17 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type17 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %17, i32 0, i32 10
  %18 = load i64, i64* %type17, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp19 = icmp eq i64 %18, %call18
  br i1 %cmp19, label %if.then.26, label %lor.lhs.false.21

lor.lhs.false.21:                                 ; preds = %lor.lhs.false
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type22 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 10
  %20 = load i64, i64* %type22, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp24 = icmp eq i64 %20, %call23
  br i1 %cmp24, label %if.then.26, label %if.end.47

if.then.26:                                       ; preds = %lor.lhs.false.21, %lor.lhs.false, %if.end.13
  %21 = load i64, i64* %status, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 387)
  %cmp28 = icmp eq i64 %21, %call27
  br i1 %cmp28, label %if.then.30, label %if.else.32

if.then.30:                                       ; preds = %if.then.26
  %call31 = call i64 @builtin_lisp_symbol(i32 270)
  store i64 %call31, i64* %status, align 8
  br label %if.end.46

if.else.32:                                       ; preds = %if.then.26
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %22, i32 0, i32 3
  %23 = load i64, i64* %command, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp34 = icmp eq i64 %23, %call33
  br i1 %cmp34, label %if.then.36, label %if.else.38

if.then.36:                                       ; preds = %if.else.32
  %call37 = call i64 @builtin_lisp_symbol(i32 880)
  store i64 %call37, i64* %status, align 8
  br label %if.end.45

if.else.38:                                       ; preds = %if.else.32
  %24 = load i64, i64* %status, align 8
  %call39 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp40 = icmp eq i64 %24, %call39
  br i1 %cmp40, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %if.else.38
  %call43 = call i64 @builtin_lisp_symbol(i32 719)
  store i64 %call43, i64* %status, align 8
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.42, %if.else.38
  br label %if.end.45

if.end.45:                                        ; preds = %if.end.44, %if.then.36
  br label %if.end.46

if.end.46:                                        ; preds = %if.end.45, %if.then.30
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.46, %lor.lhs.false.21
  %25 = load i64, i64* %status, align 8
  store i64 %25, i64* %retval
  br label %return

return:                                           ; preds = %if.end.47, %if.then.4
  %26 = load i64, i64* %retval
  ret i64 %26
}

declare zeroext i1 @STRINGP(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_exit_status(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  call void @update_status(%struct.Lisp_Process* %call1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, i64* %process.addr, align 8
  %call2 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call2, i32 0, i32 12
  %4 = load i64, i64* %status, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then.4, label %if.end.8

if.then.4:                                        ; preds = %if.end
  %5 = load i64, i64* %process.addr, align 8
  %call5 = call %struct.Lisp_Process* @XPROCESS(i64 %5)
  %status6 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call5, i32 0, i32 12
  %6 = load i64, i64* %status6, align 8
  %sub = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  %sub7 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub7 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car, align 8
  store i64 %12, i64* %retval
  br label %return

if.end.8:                                         ; preds = %if.end
  store i64 2, i64* %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.4
  %13 = load i64, i64* %retval
  ret i64 %13
}

declare void @CHECK_PROCESS(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_id(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  %pid = alloca i32, align 4
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %pid1 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 20
  %2 = load i32, i32* %pid1, align 4
  store i32 %2, i32* %pid, align 4
  %3 = load i32, i32* %pid, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %cond.true, label %cond.false.11

cond.true:                                        ; preds = %entry
  %4 = load i32, i32* %pid, align 4
  %cmp = icmp sle i32 0, %4
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.true
  %5 = load i32, i32* %pid, align 4
  %conv = sext i32 %5 to i64
  %cmp2 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp2, label %land.lhs.true, label %cond.true.7

land.lhs.true:                                    ; preds = %lor.lhs.false, %cond.true
  %6 = load i32, i32* %pid, align 4
  %conv4 = sext i32 %6 to i64
  %cmp5 = icmp sle i64 %conv4, 2305843009213693951
  br i1 %cmp5, label %cond.false, label %cond.true.7

cond.true.7:                                      ; preds = %land.lhs.true, %lor.lhs.false
  %7 = load i32, i32* %pid, align 4
  %conv8 = sitofp i32 %7 to double
  %call9 = call i64 @make_float(double %conv8)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %8 = load i32, i32* %pid, align 4
  %conv10 = sext i32 %8 to i64
  %shl = shl i64 %conv10, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.7
  %cond = phi i64 [ %call9, %cond.true.7 ], [ %add, %cond.false ]
  br label %cond.end.13

cond.false.11:                                    ; preds = %entry
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.13

cond.end.13:                                      ; preds = %cond.false.11, %cond.end
  %cond14 = phi i64 [ %cond, %cond.end ], [ %call12, %cond.false.11 ]
  ret i64 %cond14
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_name(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 2
  %2 = load i64, i64* %name, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_command(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 3
  %2 = load i64, i64* %command, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_tty_name(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %tty_name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 1
  %2 = load i64, i64* %tty_name, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_buffer(i64 %process, i64 %buffer) #0 {
entry:
  %process.addr = alloca i64, align 8
  %buffer.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %buffer.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %buffer.addr, align 8
  call void @CHECK_BUFFER(i64 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  store %struct.Lisp_Process* %call1, %struct.Lisp_Process** %p, align 8
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %5 = load i64, i64* %buffer.addr, align 8
  call void @pset_buffer(%struct.Lisp_Process* %4, i64 %5)
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 10
  %7 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp3 = icmp eq i64 %7, %call2
  br i1 %cmp3, label %if.then.11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 10
  %9 = load i64, i64* %type4, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp6 = icmp eq i64 %9, %call5
  br i1 %cmp6, label %if.then.11, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %lor.lhs.false
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type8 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 10
  %11 = load i64, i64* %type8, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp10 = icmp eq i64 %11, %call9
  br i1 %cmp10, label %if.then.11, label %if.end.14

if.then.11:                                       ; preds = %lor.lhs.false.7, %lor.lhs.false, %if.end
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %13, i32 0, i32 8
  %14 = load i64, i64* %childp, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 16)
  %15 = load i64, i64* %buffer.addr, align 8
  %call13 = call i64 @Fplist_put(i64 %14, i64 %call12, i64 %15)
  call void @pset_childp(%struct.Lisp_Process* %12, i64 %call13)
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.11, %lor.lhs.false.7
  %16 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %16)
  %17 = load i64, i64* %buffer.addr, align 8
  ret i64 %17
}

declare void @CHECK_BUFFER(i64) #1

; Function Attrs: nounwind uwtable
define internal void @pset_buffer(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %buffer = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 7
  store i64 %0, i64* %buffer, align 8
  ret void
}

declare void @pset_childp(%struct.Lisp_Process*, i64) #1

declare i64 @Fplist_put(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define void @setup_process_coding_systems(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %inch = alloca i32, align 4
  %outch = alloca i32, align 4
  %coding_system = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 21
  %2 = load i32, i32* %infd, align 4
  store i32 %2, i32* %inch, align 4
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 22
  %4 = load i32, i32* %outfd, align 4
  store i32 %4, i32* %outch, align 4
  %5 = load i32, i32* %inch, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32, i32* %outch, align 4
  %cmp1 = icmp slt i32 %6, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load i32, i32* %inch, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_decode_coding_system, i32 0, i64 %idxprom
  %8 = load %struct.coding_system*, %struct.coding_system** %arrayidx, align 8
  %tobool = icmp ne %struct.coding_system* %8, null
  br i1 %tobool, label %if.end.6, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %call3 = call noalias i8* @xmalloc(i64 616)
  %9 = bitcast i8* %call3 to %struct.coding_system*
  %10 = load i32, i32* %inch, align 4
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_decode_coding_system, i32 0, i64 %idxprom4
  store %struct.coding_system* %9, %struct.coding_system** %arrayidx5, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.2, %if.end
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 13
  %12 = load i64, i64* %decode_coding_system, align 8
  store i64 %12, i64* %coding_system, align 8
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %13, i32 0, i32 4
  %14 = load i64, i64* %filter, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 564)
  %cmp8 = icmp eq i64 %14, %call7
  br i1 %cmp8, label %land.lhs.true, label %if.end.18

land.lhs.true:                                    ; preds = %if.end.6
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 7
  %16 = load i64, i64* %buffer, align 8
  %call9 = call zeroext i1 @BUFFERP(i64 %16)
  br i1 %call9, label %if.then.10, label %if.end.18

if.then.10:                                       ; preds = %land.lhs.true
  %17 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer11 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %17, i32 0, i32 7
  %18 = load i64, i64* %buffer11, align 8
  %call12 = call %struct.buffer* @XBUFFER(i64 %18)
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call12, i32 0, i32 39
  %19 = load i64, i64* %enable_multibyte_characters_, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %19, %call13
  br i1 %cmp14, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.then.10
  %20 = load i64, i64* %coding_system, align 8
  %call16 = call i64 @raw_text_coding_system(i64 %20)
  store i64 %call16, i64* %coding_system, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.15, %if.then.10
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %land.lhs.true, %if.end.6
  %21 = load i64, i64* %coding_system, align 8
  %22 = load i32, i32* %inch, align 4
  %idxprom19 = sext i32 %22 to i64
  %arrayidx20 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_decode_coding_system, i32 0, i64 %idxprom19
  %23 = load %struct.coding_system*, %struct.coding_system** %arrayidx20, align 8
  call void @setup_coding_system(i64 %21, %struct.coding_system* %23)
  %24 = load i32, i32* %outch, align 4
  %idxprom21 = sext i32 %24 to i64
  %arrayidx22 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom21
  %25 = load %struct.coding_system*, %struct.coding_system** %arrayidx22, align 8
  %tobool23 = icmp ne %struct.coding_system* %25, null
  br i1 %tobool23, label %if.end.28, label %if.then.24

if.then.24:                                       ; preds = %if.end.18
  %call25 = call noalias i8* @xmalloc(i64 616)
  %26 = bitcast i8* %call25 to %struct.coding_system*
  %27 = load i32, i32* %outch, align 4
  %idxprom26 = sext i32 %27 to i64
  %arrayidx27 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom26
  store %struct.coding_system* %26, %struct.coding_system** %arrayidx27, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.24, %if.end.18
  %28 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %28, i32 0, i32 15
  %29 = load i64, i64* %encode_coding_system, align 8
  %30 = load i32, i32* %outch, align 4
  %idxprom29 = sext i32 %30 to i64
  %arrayidx30 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom29
  %31 = load %struct.coding_system*, %struct.coding_system** %arrayidx30, align 8
  call void @setup_coding_system(i64 %29, %struct.coding_system* %31)
  br label %return

return:                                           ; preds = %if.end.28, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_buffer(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %buffer = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 7
  %2 = load i64, i64* %buffer, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_mark(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 11
  %2 = load i64, i64* %mark, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_filter(i64 %process, i64 %filter) #0 {
entry:
  %process.addr = alloca i64, align 8
  %filter.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %filter, i64* %filter.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load i64, i64* %filter.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 564)
  store i64 %call2, i64* %filter.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 21
  %4 = load i32, i32* %infd, align 4
  %cmp3 = icmp sge i32 %4, 0
  br i1 %cmp3, label %if.then.4, label %if.end.23

if.then.4:                                        ; preds = %if.end
  %5 = load i64, i64* %filter.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp6 = icmp eq i64 %5, %call5
  br i1 %cmp6, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then.4
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 12
  %7 = load i64, i64* %status, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 625)
  %cmp8 = icmp eq i64 %7, %call7
  br i1 %cmp8, label %if.else, label %if.then.9

if.then.9:                                        ; preds = %land.lhs.true
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd10 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 21
  %9 = load i32, i32* %infd10, align 4
  call void @fd_CLR(i32 %9, %struct.fd_set* @input_wait_mask)
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd11 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 21
  %11 = load i32, i32* %infd11, align 4
  call void @fd_CLR(i32 %11, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.22

if.else:                                          ; preds = %land.lhs.true, %if.then.4
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter12 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 4
  %13 = load i64, i64* %filter12, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp14 = icmp eq i64 %13, %call13
  br i1 %cmp14, label %land.lhs.true.15, label %if.end.21

land.lhs.true.15:                                 ; preds = %if.else
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 3
  %15 = load i64, i64* %command, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp17 = icmp eq i64 %15, %call16
  br i1 %cmp17, label %if.end.21, label %if.then.18

if.then.18:                                       ; preds = %land.lhs.true.15
  %16 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd19 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %16, i32 0, i32 21
  %17 = load i32, i32* %infd19, align 4
  call void @fd_SET(i32 %17, %struct.fd_set* @input_wait_mask)
  %18 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd20 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %18, i32 0, i32 21
  %19 = load i32, i32* %infd20, align 4
  call void @fd_SET(i32 %19, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.18, %land.lhs.true.15, %if.else
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %if.then.9
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.22, %if.end
  %20 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %21 = load i64, i64* %filter.addr, align 8
  call void @pset_filter(%struct.Lisp_Process* %20, i64 %21)
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %22, i32 0, i32 10
  %23 = load i64, i64* %type, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp25 = icmp eq i64 %23, %call24
  br i1 %cmp25, label %if.then.33, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.23
  %24 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type26 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %24, i32 0, i32 10
  %25 = load i64, i64* %type26, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp28 = icmp eq i64 %25, %call27
  br i1 %cmp28, label %if.then.33, label %lor.lhs.false.29

lor.lhs.false.29:                                 ; preds = %lor.lhs.false
  %26 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type30 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %26, i32 0, i32 10
  %27 = load i64, i64* %type30, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp32 = icmp eq i64 %27, %call31
  br i1 %cmp32, label %if.then.33, label %if.end.36

if.then.33:                                       ; preds = %lor.lhs.false.29, %lor.lhs.false, %if.end.23
  %28 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %29, i32 0, i32 8
  %30 = load i64, i64* %childp, align 8
  %call34 = call i64 @builtin_lisp_symbol(i32 42)
  %31 = load i64, i64* %filter.addr, align 8
  %call35 = call i64 @Fplist_put(i64 %30, i64 %call34, i64 %31)
  call void @pset_childp(%struct.Lisp_Process* %28, i64 %call35)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.33, %lor.lhs.false.29
  %32 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %32)
  %33 = load i64, i64* %filter.addr, align 8
  ret i64 %33
}

; Function Attrs: nounwind uwtable
define internal void @pset_filter(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 564)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, i64* %val.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %1, %cond.false ]
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 4
  store i64 %cond, i64* %filter, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_filter(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 4
  %2 = load i64, i64* %filter, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_sentinel(i64 %process, i64 %sentinel) #0 {
entry:
  %process.addr = alloca i64, align 8
  %sentinel.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %sentinel, i64* %sentinel.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load i64, i64* %sentinel.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 565)
  store i64 %call2, i64* %sentinel.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %4 = load i64, i64* %sentinel.addr, align 8
  call void @pset_sentinel(%struct.Lisp_Process* %3, i64 %4)
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 10
  %6 = load i64, i64* %type, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp4 = icmp eq i64 %6, %call3
  br i1 %cmp4, label %if.then.12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type5 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 10
  %8 = load i64, i64* %type5, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp7 = icmp eq i64 %8, %call6
  br i1 %cmp7, label %if.then.12, label %lor.lhs.false.8

lor.lhs.false.8:                                  ; preds = %lor.lhs.false
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 10
  %10 = load i64, i64* %type9, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp11 = icmp eq i64 %10, %call10
  br i1 %cmp11, label %if.then.12, label %if.end.15

if.then.12:                                       ; preds = %lor.lhs.false.8, %lor.lhs.false, %if.end
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 8
  %13 = load i64, i64* %childp, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 115)
  %14 = load i64, i64* %sentinel.addr, align 8
  %call14 = call i64 @Fplist_put(i64 %13, i64 %call13, i64 %14)
  call void @pset_childp(%struct.Lisp_Process* %11, i64 %call14)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.12, %lor.lhs.false.8
  %15 = load i64, i64* %sentinel.addr, align 8
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define internal void @pset_sentinel(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 565)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, i64* %val.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %1, %cond.false ]
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %sentinel = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 5
  store i64 %cond, i64* %sentinel, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_sentinel(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %sentinel = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 5
  %2 = load i64, i64* %sentinel, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_window_size(i64 %process, i64 %height, i64 %width) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %height.addr = alloca i64, align 8
  %width.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %height, i64* %height.addr, align 8
  store i64 %width, i64* %width.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i64, i64* %height.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body
  br label %cond.end

cond.false:                                       ; preds = %do.body
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %2 = load i64, i64* %height.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call, i64 %2) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i64, i64* %height.addr, align 8
  %shr = ashr i64 %5, 2
  %cmp3 = icmp sle i64 0, %shr
  br i1 %cmp3, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %cond.end
  %6 = load i64, i64* %height.addr, align 8
  %shr5 = ashr i64 %6, 2
  %cmp6 = icmp sle i64 %shr5, 65535
  br i1 %cmp6, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %cond.end
  %7 = load i64, i64* %height.addr, align 8
  call void @args_out_of_range_3(i64 %7, i64 2, i64 262142) #8
  unreachable

if.end:                                           ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body.8

do.body.8:                                        ; preds = %do.end
  %8 = load i64, i64* %width.addr, align 8
  %and9 = and i64 %8, 7
  %conv10 = trunc i64 %and9 to i32
  %and11 = and i32 %conv10, -5
  %cmp12 = icmp eq i32 %and11, 2
  br i1 %cmp12, label %cond.true.14, label %cond.false.15

cond.true.14:                                     ; preds = %do.body.8
  br label %cond.end.17

cond.false.15:                                    ; preds = %do.body.8
  %call16 = call i64 @builtin_lisp_symbol(i32 559)
  %9 = load i64, i64* %width.addr, align 8
  %10 = call i64 @wrong_type_argument(i64 %call16, i64 %9) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.17

cond.end.17:                                      ; preds = %11, %cond.true.14
  %12 = load i64, i64* %width.addr, align 8
  %shr18 = ashr i64 %12, 2
  %cmp19 = icmp sle i64 0, %shr18
  br i1 %cmp19, label %land.lhs.true.21, label %if.then.25

land.lhs.true.21:                                 ; preds = %cond.end.17
  %13 = load i64, i64* %width.addr, align 8
  %shr22 = ashr i64 %13, 2
  %cmp23 = icmp sle i64 %shr22, 65535
  br i1 %cmp23, label %if.end.26, label %if.then.25

if.then.25:                                       ; preds = %land.lhs.true.21, %cond.end.17
  %14 = load i64, i64* %width.addr, align 8
  call void @args_out_of_range_3(i64 %14, i64 2, i64 262142) #8
  unreachable

if.end.26:                                        ; preds = %land.lhs.true.21
  br label %do.end.27

do.end.27:                                        ; preds = %if.end.26
  %15 = load i64, i64* %process.addr, align 8
  %call28 = call %struct.Lisp_Process* @XPROCESS(i64 %15)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call28, i32 0, i32 21
  %16 = load i32, i32* %infd, align 4
  %cmp29 = icmp slt i32 %16, 0
  br i1 %cmp29, label %if.then.40, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end.27
  %17 = load i64, i64* %process.addr, align 8
  %call31 = call %struct.Lisp_Process* @XPROCESS(i64 %17)
  %infd32 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call31, i32 0, i32 21
  %18 = load i32, i32* %infd32, align 4
  %19 = load i64, i64* %height.addr, align 8
  %shr33 = ashr i64 %19, 2
  %conv34 = trunc i64 %shr33 to i32
  %20 = load i64, i64* %width.addr, align 8
  %shr35 = ashr i64 %20, 2
  %conv36 = trunc i64 %shr35 to i32
  %call37 = call i32 @set_window_size(i32 %18, i32 %conv34, i32 %conv36)
  %cmp38 = icmp slt i32 %call37, 0
  br i1 %cmp38, label %if.then.40, label %if.else

if.then.40:                                       ; preds = %lor.lhs.false, %do.end.27
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call41, i64* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %call42 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call42, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.40
  %21 = load i64, i64* %retval
  ret i64 %21
}

; Function Attrs: noreturn
declare i64 @wrong_type_argument(i64, i64) #2

; Function Attrs: noreturn
declare void @args_out_of_range_3(i64, i64, i64) #2

declare i32 @set_window_size(i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_process_inherit_coding_system_flag(i64 %process, i64 %flag) #0 {
entry:
  %process.addr = alloca i64, align 8
  %flag.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %flag, i64* %flag.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %flag.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  %lnot = xor i1 %cmp, true
  %2 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 28
  %3 = zext i1 %lnot to i8
  %bf.load = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.shl = shl i8 %3, 5
  %bf.clear = and i8 %bf.load, -33
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %inherit_coding_system_flag, align 8
  %tobool = trunc i8 %3 to i1
  %4 = load i64, i64* %flag.addr, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_query_on_exit_flag(i64 %process, i64 %flag) #0 {
entry:
  %process.addr = alloca i64, align 8
  %flag.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %flag, i64* %flag.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %flag.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  %2 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 28
  %3 = zext i1 %cmp to i8
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.shl = shl i8 %3, 3
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, %bf.shl
  store i8 %bf.set, i8* %kill_without_query, align 8
  %tobool = trunc i8 %3 to i1
  %4 = load i64, i64* %flag.addr, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_query_on_exit_flag(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 28
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.lshr = lshr i8 %bf.load, 3
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_contact(i64 %process, i64 %key) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %key.addr = alloca i64, align 8
  %contact = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 8
  %2 = load i64, i64* %childp, align 8
  store i64 %2, i64* %contact, align 8
  %3 = load i64, i64* %process.addr, align 8
  %call1 = call zeroext i1 @PROCESSP(i64 %3)
  br i1 %call1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load i64, i64* %process.addr, align 8
  %call2 = call %struct.Lisp_Process* @XPROCESS(i64 %4)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call2, i32 0, i32 21
  %5 = load i32, i32* %infd, align 4
  %cmp = icmp sge i32 %5, 0
  br i1 %cmp, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %6 = load i64, i64* %process.addr, align 8
  %call4 = call %struct.Lisp_Process* @XPROCESS(i64 %6)
  %infd5 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call4, i32 0, i32 21
  %7 = load i32, i32* %infd5, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx, i32 0, i32 0
  %8 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp6 = icmp ne %struct.sockaddr* %8, null
  br i1 %cmp6, label %land.lhs.true.7, label %if.end

land.lhs.true.7:                                  ; preds = %land.lhs.true.3
  %9 = load i64, i64* %key.addr, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp9 = icmp eq i64 %9, %call8
  br i1 %cmp9, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.7
  %10 = load i64, i64* %key.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 108)
  %cmp11 = icmp eq i64 %10, %call10
  br i1 %cmp11, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true.7
  %11 = load i64, i64* %contact, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 108)
  %12 = load i64, i64* %process.addr, align 8
  %call13 = call i64 @Fprocess_datagram_address(i64 %12)
  %call14 = call i64 @Fplist_put(i64 %11, i64 %call12, i64 %call13)
  store i64 %call14, i64* %contact, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %land.lhs.true.3, %land.lhs.true, %entry
  %13 = load i64, i64* %process.addr, align 8
  %call15 = call %struct.Lisp_Process* @XPROCESS(i64 %13)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call15, i32 0, i32 10
  %14 = load i64, i64* %type, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp17 = icmp eq i64 %14, %call16
  br i1 %cmp17, label %lor.lhs.false.28, label %land.lhs.true.18

land.lhs.true.18:                                 ; preds = %if.end
  %15 = load i64, i64* %process.addr, align 8
  %call19 = call %struct.Lisp_Process* @XPROCESS(i64 %15)
  %type20 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call19, i32 0, i32 10
  %16 = load i64, i64* %type20, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp22 = icmp eq i64 %16, %call21
  br i1 %cmp22, label %lor.lhs.false.28, label %land.lhs.true.23

land.lhs.true.23:                                 ; preds = %land.lhs.true.18
  %17 = load i64, i64* %process.addr, align 8
  %call24 = call %struct.Lisp_Process* @XPROCESS(i64 %17)
  %type25 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call24, i32 0, i32 10
  %18 = load i64, i64* %type25, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp27 = icmp eq i64 %18, %call26
  br i1 %cmp27, label %lor.lhs.false.28, label %if.then.31

lor.lhs.false.28:                                 ; preds = %land.lhs.true.23, %land.lhs.true.18, %if.end
  %19 = load i64, i64* %key.addr, align 8
  %call29 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp30 = icmp eq i64 %19, %call29
  br i1 %cmp30, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %lor.lhs.false.28, %land.lhs.true.23
  %20 = load i64, i64* %contact, align 8
  store i64 %20, i64* %retval
  br label %return

if.end.32:                                        ; preds = %lor.lhs.false.28
  %21 = load i64, i64* %key.addr, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp34 = icmp eq i64 %21, %call33
  br i1 %cmp34, label %land.lhs.true.35, label %if.end.46

land.lhs.true.35:                                 ; preds = %if.end.32
  %22 = load i64, i64* %process.addr, align 8
  %call36 = call %struct.Lisp_Process* @XPROCESS(i64 %22)
  %type37 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call36, i32 0, i32 10
  %23 = load i64, i64* %type37, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp39 = icmp eq i64 %23, %call38
  br i1 %cmp39, label %if.then.40, label %if.end.46

if.then.40:                                       ; preds = %land.lhs.true.35
  %24 = load i64, i64* %contact, align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 63)
  %call42 = call i64 @Fplist_get(i64 %24, i64 %call41)
  %25 = load i64, i64* %contact, align 8
  %call43 = call i64 @builtin_lisp_symbol(i32 117)
  %call44 = call i64 @Fplist_get(i64 %25, i64 %call43)
  %call45 = call i64 @list2(i64 %call42, i64 %call44)
  store i64 %call45, i64* %retval
  br label %return

if.end.46:                                        ; preds = %land.lhs.true.35, %if.end.32
  %26 = load i64, i64* %key.addr, align 8
  %call47 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp48 = icmp eq i64 %26, %call47
  br i1 %cmp48, label %land.lhs.true.49, label %if.end.60

land.lhs.true.49:                                 ; preds = %if.end.46
  %27 = load i64, i64* %process.addr, align 8
  %call50 = call %struct.Lisp_Process* @XPROCESS(i64 %27)
  %type51 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call50, i32 0, i32 10
  %28 = load i64, i64* %type51, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp53 = icmp eq i64 %28, %call52
  br i1 %cmp53, label %if.then.54, label %if.end.60

if.then.54:                                       ; preds = %land.lhs.true.49
  %29 = load i64, i64* %contact, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 94)
  %call56 = call i64 @Fplist_get(i64 %29, i64 %call55)
  %30 = load i64, i64* %contact, align 8
  %call57 = call i64 @builtin_lisp_symbol(i32 121)
  %call58 = call i64 @Fplist_get(i64 %30, i64 %call57)
  %call59 = call i64 @list2(i64 %call56, i64 %call58)
  store i64 %call59, i64* %retval
  br label %return

if.end.60:                                        ; preds = %land.lhs.true.49, %if.end.46
  %31 = load i64, i64* %key.addr, align 8
  %call61 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp62 = icmp eq i64 %31, %call61
  br i1 %cmp62, label %land.lhs.true.63, label %if.end.70

land.lhs.true.63:                                 ; preds = %if.end.60
  %32 = load i64, i64* %process.addr, align 8
  %call64 = call %struct.Lisp_Process* @XPROCESS(i64 %32)
  %type65 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call64, i32 0, i32 10
  %33 = load i64, i64* %type65, align 8
  %call66 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp67 = icmp eq i64 %33, %call66
  br i1 %cmp67, label %if.then.68, label %if.end.70

if.then.68:                                       ; preds = %land.lhs.true.63
  %call69 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call69, i64* %retval
  br label %return

if.end.70:                                        ; preds = %land.lhs.true.63, %if.end.60
  %34 = load i64, i64* %contact, align 8
  %35 = load i64, i64* %key.addr, align 8
  %call71 = call i64 @Fplist_get(i64 %34, i64 %35)
  store i64 %call71, i64* %retval
  br label %return

return:                                           ; preds = %if.end.70, %if.then.68, %if.then.54, %if.then.40, %if.then.31
  %36 = load i64, i64* %retval
  ret i64 %36
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_datagram_address(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %channel = alloca i32, align 4
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %1)
  br i1 %call, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 21
  %3 = load i32, i32* %infd, align 4
  %cmp = icmp sge i32 %3, 0
  br i1 %cmp, label %land.lhs.true.2, label %if.then

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %4 = load i64, i64* %process.addr, align 8
  %call3 = call %struct.Lisp_Process* @XPROCESS(i64 %4)
  %infd4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call3, i32 0, i32 21
  %5 = load i32, i32* %infd4, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx, i32 0, i32 0
  %6 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp5 = icmp ne %struct.sockaddr* %6, null
  br i1 %cmp5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.2, %land.lhs.true, %entry
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.2
  %7 = load i64, i64* %process.addr, align 8
  %call7 = call %struct.Lisp_Process* @XPROCESS(i64 %7)
  %infd8 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call7, i32 0, i32 21
  %8 = load i32, i32* %infd8, align 4
  store i32 %8, i32* %channel, align 4
  %9 = load i32, i32* %channel, align 4
  %idxprom9 = sext i32 %9 to i64
  %arrayidx10 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom9
  %sa11 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx10, i32 0, i32 0
  %10 = load %struct.sockaddr*, %struct.sockaddr** %sa11, align 8
  %11 = load i32, i32* %channel, align 4
  %idxprom12 = sext i32 %11 to i64
  %arrayidx13 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom12
  %len = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx13, i32 0, i32 1
  %12 = load i32, i32* %len, align 4
  %call14 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %10, i32 %12)
  store i64 %call14, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load i64, i64* %retval
  ret i64 %13
}

declare i64 @Fplist_get(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_plist(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %plist = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 9
  %2 = load i64, i64* %plist, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_plist(i64 %process, i64 %plist) #0 {
entry:
  %process.addr = alloca i64, align 8
  %plist.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %plist, i64* %plist.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %plist.addr, align 8
  call void @CHECK_LIST(i64 %1)
  %2 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  %3 = load i64, i64* %plist.addr, align 8
  call void @pset_plist(%struct.Lisp_Process* %call, i64 %3)
  %4 = load i64, i64* %plist.addr, align 8
  ret i64 %4
}

declare void @CHECK_LIST(i64) #1

; Function Attrs: nounwind uwtable
define internal void @pset_plist(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %plist = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 9
  store i64 %0, i64* %plist, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_type(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  %proc = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %0)
  store i64 %call, i64* %proc, align 8
  %1 = load i64, i64* %proc, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 10
  %2 = load i64, i64* %type, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fformat_network_address(i64 %address, i64 %omit_port) #0 {
entry:
  %retval = alloca i64, align 8
  %address.addr = alloca i64, align 8
  %omit_port.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Vector*, align 8
  %size = alloca i64, align 8
  %args = alloca [10 x i64], align 16
  %nargs = alloca i32, align 4
  %i = alloca i32, align 4
  %format = alloca i8*, align 8
  %format_obj = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %format66 = alloca i64, align 8
  %.compoundliteral67 = alloca %union.Aligned_String, align 8
  %.compoundliteral75 = alloca [2 x i64], align 8
  store i64 %address, i64* %address.addr, align 8
  store i64 %omit_port, i64* %omit_port.addr, align 8
  %0 = load i64, i64* %address.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %address.addr, align 8
  %call2 = call zeroext i1 @STRINGP(i64 %1)
  br i1 %call2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  %2 = load i64, i64* %address.addr, align 8
  store i64 %2, i64* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* %address.addr, align 8
  %call5 = call zeroext i1 @VECTORP(i64 %3)
  br i1 %call5, label %if.then.6, label %if.end.61

if.then.6:                                        ; preds = %if.end.4
  %4 = load i64, i64* %address.addr, align 8
  %call7 = call %struct.Lisp_Vector* @XVECTOR(i64 %4)
  store %struct.Lisp_Vector* %call7, %struct.Lisp_Vector** %p, align 8
  %5 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %header = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %5, i32 0, i32 0
  %size8 = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header, i32 0, i32 0
  %6 = load i64, i64* %size8, align 8
  store i64 %6, i64* %size, align 8
  %7 = load i64, i64* %size, align 8
  %cmp9 = icmp eq i64 %7, 4
  br i1 %cmp9, label %if.then.13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.6
  %8 = load i64, i64* %size, align 8
  %cmp10 = icmp eq i64 %8, 5
  br i1 %cmp10, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %9 = load i64, i64* %omit_port.addr, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %9, %call11
  br i1 %cmp12, label %if.else, label %if.then.13

if.then.13:                                       ; preds = %land.lhs.true, %if.then.6
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i8** %format, align 8
  store i32 4, i32* %nargs, align 4
  br label %if.end.32

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %10 = load i64, i64* %size, align 8
  %cmp14 = icmp eq i64 %10, 5
  br i1 %cmp14, label %if.then.15, label %if.else.16

if.then.15:                                       ; preds = %if.else
  store i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.1, i32 0, i32 0), i8** %format, align 8
  store i32 5, i32* %nargs, align 4
  br label %if.end.31

if.else.16:                                       ; preds = %if.else
  %11 = load i64, i64* %size, align 8
  %cmp17 = icmp eq i64 %11, 8
  br i1 %cmp17, label %if.then.23, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %if.else.16
  %12 = load i64, i64* %size, align 8
  %cmp19 = icmp eq i64 %12, 9
  br i1 %cmp19, label %land.lhs.true.20, label %if.else.24

land.lhs.true.20:                                 ; preds = %lor.lhs.false.18
  %13 = load i64, i64* %omit_port.addr, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %13, %call21
  br i1 %cmp22, label %if.else.24, label %if.then.23

if.then.23:                                       ; preds = %land.lhs.true.20, %if.else.16
  store i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2, i32 0, i32 0), i8** %format, align 8
  store i32 8, i32* %nargs, align 4
  br label %if.end.30

if.else.24:                                       ; preds = %land.lhs.true.20, %lor.lhs.false.18
  %14 = load i64, i64* %size, align 8
  %cmp25 = icmp eq i64 %14, 9
  br i1 %cmp25, label %if.then.26, label %if.else.27

if.then.26:                                       ; preds = %if.else.24
  store i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.3, i32 0, i32 0), i8** %format, align 8
  store i32 9, i32* %nargs, align 4
  br label %if.end.29

if.else.27:                                       ; preds = %if.else.24
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call28, i64* %retval
  br label %return

if.end.29:                                        ; preds = %if.then.26
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %if.then.23
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %if.then.15
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.13
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size33 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  %15 = load i8*, i8** %format, align 8
  %call34 = call i64 @strlen(i8* %15) #9
  store i64 %call34, i64* %size33, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  %16 = load i8*, i8** %format, align 8
  store i8* %16, i8** %data, align 8
  %s35 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %17 = bitcast %struct.Lisp_String* %s35 to i8*
  %call36 = call i64 @make_lisp_ptr(i8* %17, i32 4)
  store i64 %call36, i64* %format_obj, align 8
  %18 = load i64, i64* %format_obj, align 8
  %arrayidx = getelementptr inbounds [10 x i64], [10 x i64]* %args, i32 0, i64 0
  store i64 %18, i64* %arrayidx, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.32
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* %nargs, align 4
  %cmp37 = icmp slt i32 %19, %20
  br i1 %cmp37, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i32, i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %22 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %22, i32 0, i32 1
  %arrayidx38 = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i64 %idxprom
  %23 = load i64, i64* %arrayidx38, align 8
  %call39 = call zeroext i1 @RANGED_INTEGERP(i64 0, i64 %23, i64 65535)
  br i1 %call39, label %if.end.42, label %if.then.40

if.then.40:                                       ; preds = %for.body
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call41, i64* %retval
  br label %return

if.end.42:                                        ; preds = %for.body
  %24 = load i32, i32* %nargs, align 4
  %cmp43 = icmp sle i32 %24, 5
  br i1 %cmp43, label %land.lhs.true.44, label %if.end.53

land.lhs.true.44:                                 ; preds = %if.end.42
  %25 = load i32, i32* %i, align 4
  %cmp45 = icmp slt i32 %25, 4
  br i1 %cmp45, label %land.lhs.true.46, label %if.end.53

land.lhs.true.46:                                 ; preds = %land.lhs.true.44
  %26 = load i32, i32* %i, align 4
  %idxprom47 = sext i32 %26 to i64
  %27 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents48 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %27, i32 0, i32 1
  %arrayidx49 = getelementptr inbounds [0 x i64], [0 x i64]* %contents48, i32 0, i64 %idxprom47
  %28 = load i64, i64* %arrayidx49, align 8
  %shr = ashr i64 %28, 2
  %cmp50 = icmp sgt i64 %shr, 255
  br i1 %cmp50, label %if.then.51, label %if.end.53

if.then.51:                                       ; preds = %land.lhs.true.46
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call52, i64* %retval
  br label %return

if.end.53:                                        ; preds = %land.lhs.true.46, %land.lhs.true.44, %if.end.42
  %29 = load i32, i32* %i, align 4
  %idxprom54 = sext i32 %29 to i64
  %30 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents55 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %30, i32 0, i32 1
  %arrayidx56 = getelementptr inbounds [0 x i64], [0 x i64]* %contents55, i32 0, i64 %idxprom54
  %31 = load i64, i64* %arrayidx56, align 8
  %32 = load i32, i32* %i, align 4
  %add = add nsw i32 %32, 1
  %idxprom57 = sext i32 %add to i64
  %arrayidx58 = getelementptr inbounds [10 x i64], [10 x i64]* %args, i32 0, i64 %idxprom57
  store i64 %31, i64* %arrayidx58, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.53
  %33 = load i32, i32* %i, align 4
  %inc = add nsw i32 %33, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load i32, i32* %nargs, align 4
  %add59 = add nsw i32 %34, 1
  %conv = sext i32 %add59 to i64
  %arraydecay = getelementptr inbounds [10 x i64], [10 x i64]* %args, i32 0, i32 0
  %call60 = call i64 @Fformat(i64 %conv, i64* %arraydecay)
  store i64 %call60, i64* %retval
  br label %return

if.end.61:                                        ; preds = %if.end.4
  %35 = load i64, i64* %address.addr, align 8
  %and = and i64 %35, 7
  %conv62 = trunc i64 %and to i32
  %cmp63 = icmp eq i32 %conv62, 3
  br i1 %cmp63, label %if.then.65, label %if.end.79

if.then.65:                                       ; preds = %if.end.61
  %s68 = bitcast %union.Aligned_String* %.compoundliteral67 to %struct.Lisp_String*
  %size69 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s68, i32 0, i32 0
  store i64 11, i64* %size69, align 8
  %size_byte70 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s68, i32 0, i32 1
  store i64 -1, i64* %size_byte70, align 8
  %intervals71 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s68, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals71, align 8
  %data72 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s68, i32 0, i32 3
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.4, i32 0, i32 0), i8** %data72, align 8
  %s73 = bitcast %union.Aligned_String* %.compoundliteral67 to %struct.Lisp_String*
  %36 = bitcast %struct.Lisp_String* %s73 to i8*
  %call74 = call i64 @make_lisp_ptr(i8* %36, i32 4)
  store i64 %call74, i64* %format66, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral75, i64 0, i64 0
  %37 = load i64, i64* %format66, align 8
  store i64 %37, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %38 = load i64, i64* %address.addr, align 8
  %call76 = call i64 @Fcar(i64 %38)
  store i64 %call76, i64* %arrayinit.element
  %arraydecay77 = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral75, i32 0, i32 0
  %call78 = call i64 @Fformat(i64 2, i64* %arraydecay77)
  store i64 %call78, i64* %retval
  br label %return

if.end.79:                                        ; preds = %if.end.61
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call80, i64* %retval
  br label %return

return:                                           ; preds = %if.end.79, %if.then.65, %for.end, %if.then.51, %if.then.40, %if.else.27, %if.then.3, %if.then
  %39 = load i64, i64* %retval
  ret i64 %39
}

declare zeroext i1 @VECTORP(i64) #1

declare %struct.Lisp_Vector* @XVECTOR(i64) #1

declare i64 @make_lisp_ptr(i8*, i32) #1

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #3

declare zeroext i1 @RANGED_INTEGERP(i64, i64, i64) #1

declare i64 @Fformat(i64, i64*) #1

declare i64 @Fcar(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_list() #0 {
entry:
  %call = call i64 @builtin_lisp_symbol(i32 249)
  %0 = load i64, i64* @Vprocess_alist, align 8
  %call1 = call i64 @Fmapcar(i64 %call, i64 %0)
  ret i64 %call1
}

declare i64 @Fmapcar(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fmake_process(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %buffer = alloca i64, align 8
  %name = alloca i64, align 8
  %command = alloca i64, align 8
  %program = alloca i64, align 8
  %proc = alloca i64, align 8
  %contact = alloca i64, align 8
  %current_dir = alloca i64, align 8
  %tem = alloca i64, align 8
  %xstderr = alloca i64, align 8
  %stderrproc = alloca i64, align 8
  %count = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %.compoundliteral = alloca [4 x i64], align 8
  %coding_systems = alloca i64, align 8
  %val = alloca i64, align 8
  %args2 = alloca i64*, align 8
  %nargs2 = alloca i64, align 8
  %tem2 = alloca i64, align 8
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %i = alloca i64, align 8
  %nargs22458 = alloca i64, align 8
  %tem22462 = alloca i64, align 8
  %alloca_nbytes2464 = alloca i64, align 8
  %arg_4648 = alloca i64, align 8
  %i4654 = alloca i64, align 8
  %program_args = alloca i64, align 8
  %arg_encoding = alloca i64, align 8
  %new_argc = alloca i64, align 8
  %tem24758 = alloca i64, align 8
  %arg = alloca i64, align 8
  %new_argv = alloca i8**, align 8
  %i4803 = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %call3 = call i64 @Flist(i64 %1, i64* %2)
  store i64 %call3, i64* %contact, align 8
  %3 = load i64, i64* %contact, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 16)
  %call5 = call i64 @Fplist_get(i64 %3, i64 %call4)
  store i64 %call5, i64* %buffer, align 8
  %4 = load i64, i64* %buffer, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %4, %call6
  br i1 %cmp7, label %if.end.10, label %if.then.8

if.then.8:                                        ; preds = %if.end
  %5 = load i64, i64* %buffer, align 8
  %call9 = call i64 @Fget_buffer_create(i64 %5)
  store i64 %call9, i64* %buffer, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.8, %if.end
  %call11 = call i64 @encode_current_directory()
  store i64 %call11, i64* %current_dir, align 8
  %6 = load i64, i64* %contact, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 86)
  %call13 = call i64 @Fplist_get(i64 %6, i64 %call12)
  store i64 %call13, i64* %name, align 8
  %7 = load i64, i64* %name, align 8
  call void @CHECK_STRING(i64 %7)
  %8 = load i64, i64* %contact, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 25)
  %call15 = call i64 @Fplist_get(i64 %8, i64 %call14)
  store i64 %call15, i64* %command, align 8
  %9 = load i64, i64* %command, align 8
  %and = and i64 %9, 7
  %conv = trunc i64 %and to i32
  %cmp16 = icmp eq i32 %conv, 3
  br i1 %cmp16, label %if.then.18, label %if.else

if.then.18:                                       ; preds = %if.end.10
  %10 = load i64, i64* %command, align 8
  %sub = sub nsw i64 %10, 3
  %11 = inttoptr i64 %sub to i8*
  %12 = bitcast i8* %11 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %12, i32 0, i32 0
  %13 = load i64, i64* %car, align 8
  store i64 %13, i64* %program, align 8
  br label %if.end.20

if.else:                                          ; preds = %if.end.10
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call19, i64* %program, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.else, %if.then.18
  %14 = load i64, i64* %program, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %14, %call21
  br i1 %cmp22, label %if.end.25, label %if.then.24

if.then.24:                                       ; preds = %if.end.20
  %15 = load i64, i64* %program, align 8
  call void @CHECK_STRING(i64 %15)
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.24, %if.end.20
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call26, i64* %stderrproc, align 8
  %16 = load i64, i64* %contact, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 122)
  %call28 = call i64 @Fplist_get(i64 %16, i64 %call27)
  store i64 %call28, i64* %xstderr, align 8
  %17 = load i64, i64* %xstderr, align 8
  %call29 = call zeroext i1 @PROCESSP(i64 %17)
  br i1 %call29, label %if.then.30, label %if.else.37

if.then.30:                                       ; preds = %if.end.25
  %18 = load i64, i64* %xstderr, align 8
  %call31 = call %struct.Lisp_Process* @XPROCESS(i64 %18)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call31, i32 0, i32 10
  %19 = load i64, i64* %type, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp33 = icmp eq i64 %19, %call32
  br i1 %cmp33, label %if.end.36, label %if.then.35

if.then.35:                                       ; preds = %if.then.30
  call void (i8*, ...) @error(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.5, i32 0, i32 0)) #8
  unreachable

if.end.36:                                        ; preds = %if.then.30
  %20 = load i64, i64* %xstderr, align 8
  store i64 %20, i64* %stderrproc, align 8
  br label %if.end.51

if.else.37:                                       ; preds = %if.end.25
  %21 = load i64, i64* %xstderr, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp39 = icmp eq i64 %21, %call38
  br i1 %cmp39, label %if.end.50, label %if.then.41

if.then.41:                                       ; preds = %if.else.37
  %22 = load i64, i64* %program, align 8
  call void @CHECK_STRING(i64 %22)
  %arrayinit.begin = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i64 0, i64 0
  %call42 = call i64 @builtin_lisp_symbol(i32 86)
  store i64 %call42, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %23 = load i64, i64* %name, align 8
  %call43 = call i64 @build_string(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0))
  %call44 = call i64 @concat2(i64 %23, i64 %call43)
  store i64 %call44, i64* %arrayinit.element
  %arrayinit.element45 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %call46 = call i64 @builtin_lisp_symbol(i32 16)
  store i64 %call46, i64* %arrayinit.element45
  %arrayinit.element47 = getelementptr inbounds i64, i64* %arrayinit.element45, i64 1
  %24 = load i64, i64* %xstderr, align 8
  %call48 = call i64 @Fget_buffer_create(i64 %24)
  store i64 %call48, i64* %arrayinit.element47
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i32 0, i32 0
  %call49 = call i64 @Fmake_pipe_process(i64 4, i64* %arraydecay)
  store i64 %call49, i64* %stderrproc, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.41, %if.else.37
  br label %if.end.51

if.end.51:                                        ; preds = %if.end.50, %if.end.36
  %25 = load i64, i64* %name, align 8
  %call52 = call i64 @make_process(i64 %25)
  store i64 %call52, i64* %proc, align 8
  %26 = load i64, i64* %proc, align 8
  call void @record_unwind_protect(void (i64)* @start_process_unwind, i64 %26)
  %27 = load i64, i64* %proc, align 8
  %call53 = call %struct.Lisp_Process* @XPROCESS(i64 %27)
  %call54 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_childp(%struct.Lisp_Process* %call53, i64 %call54)
  %28 = load i64, i64* %proc, align 8
  %call55 = call %struct.Lisp_Process* @XPROCESS(i64 %28)
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_plist(%struct.Lisp_Process* %call55, i64 %call56)
  %29 = load i64, i64* %proc, align 8
  %call57 = call %struct.Lisp_Process* @XPROCESS(i64 %29)
  %call58 = call i64 @builtin_lisp_symbol(i32 793)
  call void @pset_type(%struct.Lisp_Process* %call57, i64 %call58)
  %30 = load i64, i64* %proc, align 8
  %call59 = call %struct.Lisp_Process* @XPROCESS(i64 %30)
  %31 = load i64, i64* %buffer, align 8
  call void @pset_buffer(%struct.Lisp_Process* %call59, i64 %31)
  %32 = load i64, i64* %proc, align 8
  %call60 = call %struct.Lisp_Process* @XPROCESS(i64 %32)
  %33 = load i64, i64* %contact, align 8
  %call61 = call i64 @builtin_lisp_symbol(i32 115)
  %call62 = call i64 @Fplist_get(i64 %33, i64 %call61)
  call void @pset_sentinel(%struct.Lisp_Process* %call60, i64 %call62)
  %34 = load i64, i64* %proc, align 8
  %call63 = call %struct.Lisp_Process* @XPROCESS(i64 %34)
  %35 = load i64, i64* %contact, align 8
  %call64 = call i64 @builtin_lisp_symbol(i32 42)
  %call65 = call i64 @Fplist_get(i64 %35, i64 %call64)
  call void @pset_filter(%struct.Lisp_Process* %call63, i64 %call65)
  %36 = load i64, i64* %proc, align 8
  %call66 = call %struct.Lisp_Process* @XPROCESS(i64 %36)
  %37 = load i64, i64* %command, align 8
  %call67 = call i64 @Fcopy_sequence(i64 %37)
  call void @pset_command(%struct.Lisp_Process* %call66, i64 %call67)
  %38 = load i64, i64* %contact, align 8
  %call68 = call i64 @builtin_lisp_symbol(i32 87)
  %call69 = call i64 @Fplist_get(i64 %38, i64 %call68)
  store i64 %call69, i64* %tem, align 8
  %39 = load i64, i64* %tem, align 8
  %call70 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp71 = icmp eq i64 %39, %call70
  %lnot = xor i1 %cmp71, true
  br i1 %lnot, label %if.then.73, label %if.end.75

if.then.73:                                       ; preds = %if.end.51
  %40 = load i64, i64* %proc, align 8
  %call74 = call %struct.Lisp_Process* @XPROCESS(i64 %40)
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call74, i32 0, i32 28
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %kill_without_query, align 8
  br label %if.end.75

if.end.75:                                        ; preds = %if.then.73, %if.end.51
  %41 = load i64, i64* %contact, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 124)
  %call77 = call i64 @Fplist_get(i64 %41, i64 %call76)
  store i64 %call77, i64* %tem, align 8
  %42 = load i64, i64* %tem, align 8
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp79 = icmp eq i64 %42, %call78
  %lnot81 = xor i1 %cmp79, true
  br i1 %lnot81, label %if.then.82, label %if.end.85

if.then.82:                                       ; preds = %if.end.75
  %43 = load i64, i64* %proc, align 8
  %call83 = call %struct.Lisp_Process* @XPROCESS(i64 %43)
  %call84 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_command(%struct.Lisp_Process* %call83, i64 %call84)
  br label %if.end.85

if.end.85:                                        ; preds = %if.then.82, %if.end.75
  %44 = load i64, i64* %contact, align 8
  %call86 = call i64 @builtin_lisp_symbol(i32 26)
  %call87 = call i64 @Fplist_get(i64 %44, i64 %call86)
  store i64 %call87, i64* %tem, align 8
  %45 = load i64, i64* %tem, align 8
  %call88 = call i64 @builtin_lisp_symbol(i32 780)
  %cmp89 = icmp eq i64 %45, %call88
  br i1 %cmp89, label %if.then.91, label %if.else.96

if.then.91:                                       ; preds = %if.end.85
  %46 = load i64, i64* %proc, align 8
  %call92 = call %struct.Lisp_Process* @XPROCESS(i64 %46)
  %pty_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call92, i32 0, i32 28
  %bf.load93 = load i8, i8* %pty_flag, align 8
  %bf.clear94 = and i8 %bf.load93, -17
  %bf.set95 = or i8 %bf.clear94, 16
  store i8 %bf.set95, i8* %pty_flag, align 8
  br label %if.end.122

if.else.96:                                       ; preds = %if.end.85
  %47 = load i64, i64* %tem, align 8
  %call97 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp98 = icmp eq i64 %47, %call97
  br i1 %cmp98, label %if.then.100, label %if.else.105

if.then.100:                                      ; preds = %if.else.96
  %48 = load i64, i64* %proc, align 8
  %call101 = call %struct.Lisp_Process* @XPROCESS(i64 %48)
  %pty_flag102 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call101, i32 0, i32 28
  %bf.load103 = load i8, i8* %pty_flag102, align 8
  %bf.clear104 = and i8 %bf.load103, -17
  store i8 %bf.clear104, i8* %pty_flag102, align 8
  br label %if.end.121

if.else.105:                                      ; preds = %if.else.96
  %49 = load i64, i64* %tem, align 8
  %call106 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp107 = icmp eq i64 %49, %call106
  br i1 %cmp107, label %if.then.109, label %if.else.119

if.then.109:                                      ; preds = %if.else.105
  %50 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 238), align 8
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp111 = icmp eq i64 %50, %call110
  %lnot113 = xor i1 %cmp111, true
  %51 = load i64, i64* %proc, align 8
  %call114 = call %struct.Lisp_Process* @XPROCESS(i64 %51)
  %pty_flag115 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call114, i32 0, i32 28
  %52 = zext i1 %lnot113 to i8
  %bf.load116 = load i8, i8* %pty_flag115, align 8
  %bf.shl = shl i8 %52, 4
  %bf.clear117 = and i8 %bf.load116, -17
  %bf.set118 = or i8 %bf.clear117, %bf.shl
  store i8 %bf.set118, i8* %pty_flag115, align 8
  %tobool = trunc i8 %52 to i1
  br label %if.end.120

if.else.119:                                      ; preds = %if.else.105
  %53 = load i64, i64* %tem, align 8
  call void @report_file_error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.7, i32 0, i32 0), i64 %53) #8
  unreachable

if.end.120:                                       ; preds = %if.then.109
  br label %if.end.121

if.end.121:                                       ; preds = %if.end.120, %if.then.100
  br label %if.end.122

if.end.122:                                       ; preds = %if.end.121, %if.then.91
  %54 = load i64, i64* %stderrproc, align 8
  %call123 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp124 = icmp eq i64 %54, %call123
  br i1 %cmp124, label %if.end.132, label %if.then.126

if.then.126:                                      ; preds = %if.end.122
  %55 = load i64, i64* %proc, align 8
  %call127 = call %struct.Lisp_Process* @XPROCESS(i64 %55)
  %56 = load i64, i64* %stderrproc, align 8
  call void @pset_stderrproc(%struct.Lisp_Process* %call127, i64 %56)
  %57 = load i64, i64* %proc, align 8
  %call128 = call %struct.Lisp_Process* @XPROCESS(i64 %57)
  %pty_flag129 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call128, i32 0, i32 28
  %bf.load130 = load i8, i8* %pty_flag129, align 8
  %bf.clear131 = and i8 %bf.load130, -17
  store i8 %bf.clear131, i8* %pty_flag129, align 8
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.126, %if.end.122
  %58 = load i64, i64* %proc, align 8
  %call133 = call %struct.Lisp_Process* @XPROCESS(i64 %58)
  %gnutls_initstage = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call133, i32 0, i32 30
  store i32 0, i32* %gnutls_initstage, align 4
  %59 = load i64, i64* %proc, align 8
  %call134 = call %struct.Lisp_Process* @XPROCESS(i64 %59)
  %call135 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_gnutls_cred_type(%struct.Lisp_Process* %call134, i64 %call135)
  %60 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236), align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp137 = icmp eq i64 %60, %call136
  br i1 %cmp137, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.132
  br label %cond.end

cond.false:                                       ; preds = %if.end.132
  %61 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236), align 8
  %call139 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp140 = icmp eq i64 %61, %call139
  %cond = select i1 %cmp140, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond142 = phi i32 [ 0, %cond.true ], [ %cond, %cond.false ]
  %62 = load i64, i64* %proc, align 8
  %call143 = call %struct.Lisp_Process* @XPROCESS(i64 %62)
  %adaptive_read_buffering = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call143, i32 0, i32 28
  %63 = trunc i32 %cond142 to i8
  %bf.load144 = load i8, i8* %adaptive_read_buffering, align 8
  %bf.value = and i8 %63, 3
  %bf.clear145 = and i8 %bf.load144, -4
  %bf.set146 = or i8 %bf.clear145, %bf.value
  store i8 %bf.set146, i8* %adaptive_read_buffering, align 8
  %bf.result.cast = zext i8 %bf.value to i32
  %64 = load i64, i64* %buffer, align 8
  %call147 = call zeroext i1 @BUFFERP(i64 %64)
  br i1 %call147, label %if.then.148, label %if.end.192

if.then.148:                                      ; preds = %cond.end
  %65 = load i64, i64* %proc, align 8
  %call149 = call %struct.Lisp_Process* @XPROCESS(i64 %65)
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call149, i32 0, i32 11
  %66 = load i64, i64* %mark, align 8
  %67 = load i64, i64* %buffer, align 8
  %68 = load i64, i64* %buffer, align 8
  %call150 = call %struct.buffer* @XBUFFER(i64 %68)
  %69 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp151 = icmp eq %struct.buffer* %call150, %69
  br i1 %cmp151, label %cond.true.153, label %cond.false.154

cond.true.153:                                    ; preds = %if.then.148
  %70 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %70, i32 0, i32 79
  %71 = load i64, i64* %zv, align 8
  br label %cond.end.168

cond.false.154:                                   ; preds = %if.then.148
  %72 = load i64, i64* %buffer, align 8
  %call155 = call %struct.buffer* @XBUFFER(i64 %72)
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call155, i32 0, i32 47
  %73 = load i64, i64* %zv_marker_, align 8
  %call156 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp157 = icmp eq i64 %73, %call156
  br i1 %cmp157, label %cond.true.159, label %cond.false.162

cond.true.159:                                    ; preds = %cond.false.154
  %74 = load i64, i64* %buffer, align 8
  %call160 = call %struct.buffer* @XBUFFER(i64 %74)
  %zv161 = getelementptr inbounds %struct.buffer, %struct.buffer* %call160, i32 0, i32 79
  %75 = load i64, i64* %zv161, align 8
  br label %cond.end.166

cond.false.162:                                   ; preds = %cond.false.154
  %76 = load i64, i64* %buffer, align 8
  %call163 = call %struct.buffer* @XBUFFER(i64 %76)
  %zv_marker_164 = getelementptr inbounds %struct.buffer, %struct.buffer* %call163, i32 0, i32 47
  %77 = load i64, i64* %zv_marker_164, align 8
  %call165 = call i64 @marker_position(i64 %77)
  br label %cond.end.166

cond.end.166:                                     ; preds = %cond.false.162, %cond.true.159
  %cond167 = phi i64 [ %75, %cond.true.159 ], [ %call165, %cond.false.162 ]
  br label %cond.end.168

cond.end.168:                                     ; preds = %cond.end.166, %cond.true.153
  %cond169 = phi i64 [ %71, %cond.true.153 ], [ %cond167, %cond.end.166 ]
  %78 = load i64, i64* %buffer, align 8
  %call170 = call %struct.buffer* @XBUFFER(i64 %78)
  %79 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp171 = icmp eq %struct.buffer* %call170, %79
  br i1 %cmp171, label %cond.true.173, label %cond.false.174

cond.true.173:                                    ; preds = %cond.end.168
  %80 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %80, i32 0, i32 80
  %81 = load i64, i64* %zv_byte, align 8
  br label %cond.end.189

cond.false.174:                                   ; preds = %cond.end.168
  %82 = load i64, i64* %buffer, align 8
  %call175 = call %struct.buffer* @XBUFFER(i64 %82)
  %zv_marker_176 = getelementptr inbounds %struct.buffer, %struct.buffer* %call175, i32 0, i32 47
  %83 = load i64, i64* %zv_marker_176, align 8
  %call177 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp178 = icmp eq i64 %83, %call177
  br i1 %cmp178, label %cond.true.180, label %cond.false.183

cond.true.180:                                    ; preds = %cond.false.174
  %84 = load i64, i64* %buffer, align 8
  %call181 = call %struct.buffer* @XBUFFER(i64 %84)
  %zv_byte182 = getelementptr inbounds %struct.buffer, %struct.buffer* %call181, i32 0, i32 80
  %85 = load i64, i64* %zv_byte182, align 8
  br label %cond.end.187

cond.false.183:                                   ; preds = %cond.false.174
  %86 = load i64, i64* %buffer, align 8
  %call184 = call %struct.buffer* @XBUFFER(i64 %86)
  %zv_marker_185 = getelementptr inbounds %struct.buffer, %struct.buffer* %call184, i32 0, i32 47
  %87 = load i64, i64* %zv_marker_185, align 8
  %call186 = call i64 @marker_byte_position(i64 %87)
  br label %cond.end.187

cond.end.187:                                     ; preds = %cond.false.183, %cond.true.180
  %cond188 = phi i64 [ %85, %cond.true.180 ], [ %call186, %cond.false.183 ]
  br label %cond.end.189

cond.end.189:                                     ; preds = %cond.end.187, %cond.true.173
  %cond190 = phi i64 [ %81, %cond.true.173 ], [ %cond188, %cond.end.187 ]
  %call191 = call i64 @set_marker_both(i64 %66, i64 %67, i64 %cond169, i64 %cond190)
  br label %if.end.192

if.end.192:                                       ; preds = %cond.end.189, %cond.end
  %call193 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call193, i64* %coding_systems, align 8
  %88 = load i64, i64* %contact, align 8
  %call194 = call i64 @builtin_lisp_symbol(i32 20)
  %call195 = call i64 @Fplist_get(i64 %88, i64 %call194)
  store i64 %call195, i64* %tem, align 8
  %89 = load i64, i64* %tem, align 8
  %call196 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp197 = icmp eq i64 %89, %call196
  br i1 %cmp197, label %if.else.208, label %if.then.199

if.then.199:                                      ; preds = %if.end.192
  %90 = load i64, i64* %tem, align 8
  store i64 %90, i64* %val, align 8
  %91 = load i64, i64* %val, align 8
  %and200 = and i64 %91, 7
  %conv201 = trunc i64 %and200 to i32
  %cmp202 = icmp eq i32 %conv201, 3
  br i1 %cmp202, label %if.then.204, label %if.end.207

if.then.204:                                      ; preds = %if.then.199
  %92 = load i64, i64* %val, align 8
  %sub205 = sub nsw i64 %92, 3
  %93 = inttoptr i64 %sub205 to i8*
  %94 = bitcast i8* %93 to %struct.Lisp_Cons*
  %car206 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %94, i32 0, i32 0
  %95 = load i64, i64* %car206, align 8
  store i64 %95, i64* %val, align 8
  br label %if.end.207

if.end.207:                                       ; preds = %if.then.204, %if.then.199
  br label %if.end.209

if.else.208:                                      ; preds = %if.end.192
  %96 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  store i64 %96, i64* %val, align 8
  br label %if.end.209

if.end.209:                                       ; preds = %if.else.208, %if.end.207
  %97 = load i64, i64* %val, align 8
  %call210 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp211 = icmp eq i64 %97, %call210
  br i1 %cmp211, label %if.then.213, label %if.end.2433

if.then.213:                                      ; preds = %if.end.209
  %98 = load i64, i64* %command, align 8
  %call214 = call i64 @Flength(i64 %98)
  %shr = ashr i64 %call214, 2
  %add = add nsw i64 3, %shr
  store i64 %add, i64* %nargs2, align 8
  br label %do.body

do.body:                                          ; preds = %if.then.213
  br i1 false, label %cond.true.215, label %cond.false.693

cond.true.215:                                    ; preds = %do.body
  br i1 false, label %cond.true.216, label %cond.false.478

cond.true.216:                                    ; preds = %cond.true.215
  %99 = load i64, i64* %nargs2, align 8
  %conv217 = trunc i64 %99 to i8
  %conv218 = sext i8 %conv217 to i32
  %add219 = add nsw i32 0, %conv218
  %mul = mul nsw i32 0, %add219
  %sub220 = sub nsw i32 %mul, 1
  %cmp221 = icmp slt i32 %sub220, 0
  br i1 %cmp221, label %cond.true.223, label %cond.false.241

cond.true.223:                                    ; preds = %cond.true.216
  %100 = load i64, i64* %nargs2, align 8
  %conv224 = trunc i64 %100 to i8
  %conv225 = sext i8 %conv224 to i32
  %add226 = add nsw i32 0, %conv225
  %mul227 = mul nsw i32 0, %add226
  %add228 = add nsw i32 %mul227, 0
  %neg = xor i32 %add228, -1
  %cmp229 = icmp eq i32 %neg, -1
  %conv230 = zext i1 %cmp229 to i32
  %sub231 = sub nsw i32 0, %conv230
  %101 = load i64, i64* %nargs2, align 8
  %conv232 = trunc i64 %101 to i8
  %conv233 = sext i8 %conv232 to i32
  %add234 = add nsw i32 0, %conv233
  %mul235 = mul nsw i32 0, %add234
  %add236 = add nsw i32 %mul235, 1
  %shl = shl i32 %add236, 30
  %sub237 = sub nsw i32 %shl, 1
  %mul238 = mul nsw i32 %sub237, 2
  %add239 = add nsw i32 %mul238, 1
  %sub240 = sub nsw i32 %sub231, %add239
  br label %cond.end.247

cond.false.241:                                   ; preds = %cond.true.216
  %102 = load i64, i64* %nargs2, align 8
  %conv242 = trunc i64 %102 to i8
  %conv243 = sext i8 %conv242 to i32
  %add244 = add nsw i32 0, %conv243
  %mul245 = mul nsw i32 0, %add244
  %add246 = add nsw i32 %mul245, 0
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.false.241, %cond.true.223
  %cond248 = phi i32 [ %sub240, %cond.true.223 ], [ %add246, %cond.false.241 ]
  %cmp249 = icmp eq i32 %cond248, 0
  br i1 %cmp249, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end.247
  %103 = load i64, i64* %nargs2, align 8
  %conv251 = trunc i64 %103 to i8
  %conv252 = sext i8 %conv251 to i32
  %cmp253 = icmp slt i32 %conv252, 0
  br i1 %cmp253, label %cond.true.432, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end.247
  br i1 false, label %cond.true.255, label %cond.false.333

cond.true.255:                                    ; preds = %lor.lhs.false
  %104 = load i64, i64* %nargs2, align 8
  %conv256 = trunc i64 %104 to i8
  %conv257 = sext i8 %conv256 to i32
  %cmp258 = icmp slt i32 %conv257, 0
  br i1 %cmp258, label %cond.true.260, label %cond.false.290

cond.true.260:                                    ; preds = %cond.true.255
  %105 = load i64, i64* %nargs2, align 8
  %conv261 = trunc i64 %105 to i8
  %conv262 = sext i8 %conv261 to i32
  %106 = load i64, i64* %nargs2, align 8
  %conv263 = trunc i64 %106 to i8
  %conv264 = sext i8 %conv263 to i32
  %add265 = add nsw i32 0, %conv264
  %mul266 = mul nsw i32 0, %add265
  %sub267 = sub nsw i32 %mul266, 1
  %cmp268 = icmp slt i32 %sub267, 0
  br i1 %cmp268, label %cond.true.270, label %cond.false.280

cond.true.270:                                    ; preds = %cond.true.260
  %107 = load i64, i64* %nargs2, align 8
  %conv271 = trunc i64 %107 to i8
  %conv272 = sext i8 %conv271 to i32
  %add273 = add nsw i32 0, %conv272
  %mul274 = mul nsw i32 0, %add273
  %add275 = add nsw i32 %mul274, 1
  %shl276 = shl i32 %add275, 30
  %sub277 = sub nsw i32 %shl276, 1
  %mul278 = mul nsw i32 %sub277, 2
  %add279 = add nsw i32 %mul278, 1
  br label %cond.end.286

cond.false.280:                                   ; preds = %cond.true.260
  %108 = load i64, i64* %nargs2, align 8
  %conv281 = trunc i64 %108 to i8
  %conv282 = sext i8 %conv281 to i32
  %add283 = add nsw i32 0, %conv282
  %mul284 = mul nsw i32 0, %add283
  %sub285 = sub nsw i32 %mul284, 1
  br label %cond.end.286

cond.end.286:                                     ; preds = %cond.false.280, %cond.true.270
  %cond287 = phi i32 [ %add279, %cond.true.270 ], [ %sub285, %cond.false.280 ]
  %div = sdiv i32 %cond287, 8
  %cmp288 = icmp slt i32 %conv262, %div
  br i1 %cmp288, label %cond.true.432, label %lor.lhs.false.412

cond.false.290:                                   ; preds = %cond.true.255
  br i1 false, label %cond.true.291, label %cond.false.292

cond.true.291:                                    ; preds = %cond.false.290
  br i1 false, label %cond.true.432, label %lor.lhs.false.412

cond.false.292:                                   ; preds = %cond.false.290
  %109 = load i64, i64* %nargs2, align 8
  %conv293 = trunc i64 %109 to i8
  %conv294 = sext i8 %conv293 to i32
  %add295 = add nsw i32 0, %conv294
  %mul296 = mul nsw i32 0, %add295
  %sub297 = sub nsw i32 %mul296, 1
  %cmp298 = icmp slt i32 %sub297, 0
  br i1 %cmp298, label %cond.true.300, label %cond.false.320

cond.true.300:                                    ; preds = %cond.false.292
  %110 = load i64, i64* %nargs2, align 8
  %conv301 = trunc i64 %110 to i8
  %conv302 = sext i8 %conv301 to i32
  %add303 = add nsw i32 0, %conv302
  %mul304 = mul nsw i32 0, %add303
  %add305 = add nsw i32 %mul304, 0
  %neg306 = xor i32 %add305, -1
  %cmp307 = icmp eq i32 %neg306, -1
  %conv308 = zext i1 %cmp307 to i32
  %sub309 = sub nsw i32 0, %conv308
  %111 = load i64, i64* %nargs2, align 8
  %conv310 = trunc i64 %111 to i8
  %conv311 = sext i8 %conv310 to i32
  %add312 = add nsw i32 0, %conv311
  %mul313 = mul nsw i32 0, %add312
  %add314 = add nsw i32 %mul313, 1
  %shl315 = shl i32 %add314, 30
  %sub316 = sub nsw i32 %shl315, 1
  %mul317 = mul nsw i32 %sub316, 2
  %add318 = add nsw i32 %mul317, 1
  %sub319 = sub nsw i32 %sub309, %add318
  br label %cond.end.326

cond.false.320:                                   ; preds = %cond.false.292
  %112 = load i64, i64* %nargs2, align 8
  %conv321 = trunc i64 %112 to i8
  %conv322 = sext i8 %conv321 to i32
  %add323 = add nsw i32 0, %conv322
  %mul324 = mul nsw i32 0, %add323
  %add325 = add nsw i32 %mul324, 0
  br label %cond.end.326

cond.end.326:                                     ; preds = %cond.false.320, %cond.true.300
  %cond327 = phi i32 [ %sub319, %cond.true.300 ], [ %add325, %cond.false.320 ]
  %div328 = sdiv i32 %cond327, 8
  %113 = load i64, i64* %nargs2, align 8
  %conv329 = trunc i64 %113 to i8
  %conv330 = sext i8 %conv329 to i32
  %cmp331 = icmp slt i32 %div328, %conv330
  br i1 %cmp331, label %cond.true.432, label %lor.lhs.false.412

cond.false.333:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.334, label %cond.false.335

cond.true.334:                                    ; preds = %cond.false.333
  br i1 false, label %cond.true.432, label %lor.lhs.false.412

cond.false.335:                                   ; preds = %cond.false.333
  %114 = load i64, i64* %nargs2, align 8
  %conv336 = trunc i64 %114 to i8
  %conv337 = sext i8 %conv336 to i32
  %cmp338 = icmp slt i32 %conv337, 0
  br i1 %cmp338, label %cond.true.340, label %cond.false.381

cond.true.340:                                    ; preds = %cond.false.335
  %115 = load i64, i64* %nargs2, align 8
  %conv341 = trunc i64 %115 to i8
  %conv342 = sext i8 %conv341 to i32
  %116 = load i64, i64* %nargs2, align 8
  %conv343 = trunc i64 %116 to i8
  %conv344 = sext i8 %conv343 to i32
  %add345 = add nsw i32 0, %conv344
  %mul346 = mul nsw i32 0, %add345
  %sub347 = sub nsw i32 %mul346, 1
  %cmp348 = icmp slt i32 %sub347, 0
  br i1 %cmp348, label %cond.true.350, label %cond.false.370

cond.true.350:                                    ; preds = %cond.true.340
  %117 = load i64, i64* %nargs2, align 8
  %conv351 = trunc i64 %117 to i8
  %conv352 = sext i8 %conv351 to i32
  %add353 = add nsw i32 0, %conv352
  %mul354 = mul nsw i32 0, %add353
  %add355 = add nsw i32 %mul354, 0
  %neg356 = xor i32 %add355, -1
  %cmp357 = icmp eq i32 %neg356, -1
  %conv358 = zext i1 %cmp357 to i32
  %sub359 = sub nsw i32 0, %conv358
  %118 = load i64, i64* %nargs2, align 8
  %conv360 = trunc i64 %118 to i8
  %conv361 = sext i8 %conv360 to i32
  %add362 = add nsw i32 0, %conv361
  %mul363 = mul nsw i32 0, %add362
  %add364 = add nsw i32 %mul363, 1
  %shl365 = shl i32 %add364, 30
  %sub366 = sub nsw i32 %shl365, 1
  %mul367 = mul nsw i32 %sub366, 2
  %add368 = add nsw i32 %mul367, 1
  %sub369 = sub nsw i32 %sub359, %add368
  br label %cond.end.376

cond.false.370:                                   ; preds = %cond.true.340
  %119 = load i64, i64* %nargs2, align 8
  %conv371 = trunc i64 %119 to i8
  %conv372 = sext i8 %conv371 to i32
  %add373 = add nsw i32 0, %conv372
  %mul374 = mul nsw i32 0, %add373
  %add375 = add nsw i32 %mul374, 0
  br label %cond.end.376

cond.end.376:                                     ; preds = %cond.false.370, %cond.true.350
  %cond377 = phi i32 [ %sub369, %cond.true.350 ], [ %add375, %cond.false.370 ]
  %div378 = sdiv i32 %cond377, 8
  %cmp379 = icmp slt i32 %conv342, %div378
  br i1 %cmp379, label %cond.true.432, label %lor.lhs.false.412

cond.false.381:                                   ; preds = %cond.false.335
  %120 = load i64, i64* %nargs2, align 8
  %conv382 = trunc i64 %120 to i8
  %conv383 = sext i8 %conv382 to i32
  %add384 = add nsw i32 0, %conv383
  %mul385 = mul nsw i32 0, %add384
  %sub386 = sub nsw i32 %mul385, 1
  %cmp387 = icmp slt i32 %sub386, 0
  br i1 %cmp387, label %cond.true.389, label %cond.false.399

cond.true.389:                                    ; preds = %cond.false.381
  %121 = load i64, i64* %nargs2, align 8
  %conv390 = trunc i64 %121 to i8
  %conv391 = sext i8 %conv390 to i32
  %add392 = add nsw i32 0, %conv391
  %mul393 = mul nsw i32 0, %add392
  %add394 = add nsw i32 %mul393, 1
  %shl395 = shl i32 %add394, 30
  %sub396 = sub nsw i32 %shl395, 1
  %mul397 = mul nsw i32 %sub396, 2
  %add398 = add nsw i32 %mul397, 1
  br label %cond.end.405

cond.false.399:                                   ; preds = %cond.false.381
  %122 = load i64, i64* %nargs2, align 8
  %conv400 = trunc i64 %122 to i8
  %conv401 = sext i8 %conv400 to i32
  %add402 = add nsw i32 0, %conv401
  %mul403 = mul nsw i32 0, %add402
  %sub404 = sub nsw i32 %mul403, 1
  br label %cond.end.405

cond.end.405:                                     ; preds = %cond.false.399, %cond.true.389
  %cond406 = phi i32 [ %add398, %cond.true.389 ], [ %sub404, %cond.false.399 ]
  %div407 = sdiv i32 %cond406, 8
  %123 = load i64, i64* %nargs2, align 8
  %conv408 = trunc i64 %123 to i8
  %conv409 = sext i8 %conv408 to i32
  %cmp410 = icmp slt i32 %div407, %conv409
  br i1 %cmp410, label %cond.true.432, label %lor.lhs.false.412

lor.lhs.false.412:                                ; preds = %cond.end.405, %cond.end.376, %cond.true.334, %cond.end.326, %cond.true.291, %cond.end.286
  %124 = load i64, i64* %nargs2, align 8
  %conv413 = trunc i64 %124 to i8
  %conv414 = sext i8 %conv413 to i32
  %mul415 = mul nsw i32 %conv414, 8
  %mul416 = mul nsw i32 0, %mul415
  %sub417 = sub nsw i32 %mul416, 1
  %cmp418 = icmp slt i32 %sub417, 0
  br i1 %cmp418, label %land.lhs.true.420, label %lor.lhs.false.426

land.lhs.true.420:                                ; preds = %lor.lhs.false.412
  %125 = load i64, i64* %nargs2, align 8
  %conv421 = trunc i64 %125 to i8
  %conv422 = sext i8 %conv421 to i32
  %mul423 = mul nsw i32 %conv422, 8
  %cmp424 = icmp slt i32 %mul423, -128
  br i1 %cmp424, label %cond.true.432, label %lor.lhs.false.426

lor.lhs.false.426:                                ; preds = %land.lhs.true.420, %lor.lhs.false.412
  %126 = load i64, i64* %nargs2, align 8
  %conv427 = trunc i64 %126 to i8
  %conv428 = sext i8 %conv427 to i32
  %mul429 = mul nsw i32 %conv428, 8
  %cmp430 = icmp slt i32 127, %mul429
  br i1 %cmp430, label %cond.true.432, label %cond.false.455

cond.true.432:                                    ; preds = %lor.lhs.false.426, %land.lhs.true.420, %cond.end.405, %cond.end.376, %cond.true.334, %cond.end.326, %cond.true.291, %cond.end.286, %land.lhs.true
  %127 = load i64, i64* %nargs2, align 8
  %conv433 = trunc i64 %127 to i8
  %conv434 = zext i8 %conv433 to i32
  %mul435 = mul nsw i32 %conv434, 8
  %cmp436 = icmp sle i32 %mul435, 127
  br i1 %cmp436, label %cond.true.438, label %cond.false.444

cond.true.438:                                    ; preds = %cond.true.432
  %128 = load i64, i64* %nargs2, align 8
  %conv439 = trunc i64 %128 to i8
  %conv440 = zext i8 %conv439 to i32
  %mul441 = mul nsw i32 %conv440, 8
  %conv442 = trunc i32 %mul441 to i8
  %conv443 = sext i8 %conv442 to i32
  br label %cond.end.452

cond.false.444:                                   ; preds = %cond.true.432
  %129 = load i64, i64* %nargs2, align 8
  %conv445 = trunc i64 %129 to i8
  %conv446 = zext i8 %conv445 to i32
  %mul447 = mul nsw i32 %conv446, 8
  %sub448 = sub nsw i32 %mul447, -128
  %conv449 = trunc i32 %sub448 to i8
  %conv450 = sext i8 %conv449 to i32
  %add451 = add nsw i32 %conv450, -128
  br label %cond.end.452

cond.end.452:                                     ; preds = %cond.false.444, %cond.true.438
  %cond453 = phi i32 [ %conv443, %cond.true.438 ], [ %add451, %cond.false.444 ]
  %conv454 = sext i32 %cond453 to i64
  store i64 %conv454, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.455:                                   ; preds = %lor.lhs.false.426
  %130 = load i64, i64* %nargs2, align 8
  %conv456 = trunc i64 %130 to i8
  %conv457 = zext i8 %conv456 to i32
  %mul458 = mul nsw i32 %conv457, 8
  %cmp459 = icmp sle i32 %mul458, 127
  br i1 %cmp459, label %cond.true.461, label %cond.false.467

cond.true.461:                                    ; preds = %cond.false.455
  %131 = load i64, i64* %nargs2, align 8
  %conv462 = trunc i64 %131 to i8
  %conv463 = zext i8 %conv462 to i32
  %mul464 = mul nsw i32 %conv463, 8
  %conv465 = trunc i32 %mul464 to i8
  %conv466 = sext i8 %conv465 to i32
  br label %cond.end.475

cond.false.467:                                   ; preds = %cond.false.455
  %132 = load i64, i64* %nargs2, align 8
  %conv468 = trunc i64 %132 to i8
  %conv469 = zext i8 %conv468 to i32
  %mul470 = mul nsw i32 %conv469, 8
  %sub471 = sub nsw i32 %mul470, -128
  %conv472 = trunc i32 %sub471 to i8
  %conv473 = sext i8 %conv472 to i32
  %add474 = add nsw i32 %conv473, -128
  br label %cond.end.475

cond.end.475:                                     ; preds = %cond.false.467, %cond.true.461
  %cond476 = phi i32 [ %conv466, %cond.true.461 ], [ %add474, %cond.false.467 ]
  %conv477 = sext i32 %cond476 to i64
  store i64 %conv477, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.478:                                   ; preds = %cond.true.215
  %133 = load i64, i64* %nargs2, align 8
  %add479 = add nsw i64 0, %133
  %mul480 = mul nsw i64 0, %add479
  %sub481 = sub nsw i64 %mul480, 1
  %cmp482 = icmp slt i64 %sub481, 0
  br i1 %cmp482, label %cond.true.484, label %cond.false.501

cond.true.484:                                    ; preds = %cond.false.478
  %134 = load i64, i64* %nargs2, align 8
  %add485 = add nsw i64 0, %134
  %mul486 = mul nsw i64 0, %add485
  %add487 = add nsw i64 %mul486, 0
  %neg488 = xor i64 %add487, -1
  %cmp489 = icmp eq i64 %neg488, -1
  %conv490 = zext i1 %cmp489 to i32
  %sub491 = sub nsw i32 0, %conv490
  %conv492 = sext i32 %sub491 to i64
  %135 = load i64, i64* %nargs2, align 8
  %add493 = add nsw i64 0, %135
  %mul494 = mul nsw i64 0, %add493
  %add495 = add nsw i64 %mul494, 1
  %shl496 = shl i64 %add495, 62
  %sub497 = sub nsw i64 %shl496, 1
  %mul498 = mul nsw i64 %sub497, 2
  %add499 = add nsw i64 %mul498, 1
  %sub500 = sub nsw i64 %conv492, %add499
  br label %cond.end.505

cond.false.501:                                   ; preds = %cond.false.478
  %136 = load i64, i64* %nargs2, align 8
  %add502 = add nsw i64 0, %136
  %mul503 = mul nsw i64 0, %add502
  %add504 = add nsw i64 %mul503, 0
  br label %cond.end.505

cond.end.505:                                     ; preds = %cond.false.501, %cond.true.484
  %cond506 = phi i64 [ %sub500, %cond.true.484 ], [ %add504, %cond.false.501 ]
  %cmp507 = icmp eq i64 %cond506, 0
  br i1 %cmp507, label %land.lhs.true.509, label %lor.lhs.false.512

land.lhs.true.509:                                ; preds = %cond.end.505
  %137 = load i64, i64* %nargs2, align 8
  %cmp510 = icmp slt i64 %137, 0
  br i1 %cmp510, label %cond.true.647, label %lor.lhs.false.512

lor.lhs.false.512:                                ; preds = %land.lhs.true.509, %cond.end.505
  br i1 false, label %cond.true.513, label %cond.false.573

cond.true.513:                                    ; preds = %lor.lhs.false.512
  %138 = load i64, i64* %nargs2, align 8
  %cmp514 = icmp slt i64 %138, 0
  br i1 %cmp514, label %cond.true.516, label %cond.false.539

cond.true.516:                                    ; preds = %cond.true.513
  %139 = load i64, i64* %nargs2, align 8
  %140 = load i64, i64* %nargs2, align 8
  %add517 = add nsw i64 0, %140
  %mul518 = mul nsw i64 0, %add517
  %sub519 = sub nsw i64 %mul518, 1
  %cmp520 = icmp slt i64 %sub519, 0
  br i1 %cmp520, label %cond.true.522, label %cond.false.530

cond.true.522:                                    ; preds = %cond.true.516
  %141 = load i64, i64* %nargs2, align 8
  %add523 = add nsw i64 0, %141
  %mul524 = mul nsw i64 0, %add523
  %add525 = add nsw i64 %mul524, 1
  %shl526 = shl i64 %add525, 62
  %sub527 = sub nsw i64 %shl526, 1
  %mul528 = mul nsw i64 %sub527, 2
  %add529 = add nsw i64 %mul528, 1
  br label %cond.end.534

cond.false.530:                                   ; preds = %cond.true.516
  %142 = load i64, i64* %nargs2, align 8
  %add531 = add nsw i64 0, %142
  %mul532 = mul nsw i64 0, %add531
  %sub533 = sub nsw i64 %mul532, 1
  br label %cond.end.534

cond.end.534:                                     ; preds = %cond.false.530, %cond.true.522
  %cond535 = phi i64 [ %add529, %cond.true.522 ], [ %sub533, %cond.false.530 ]
  %div536 = sdiv i64 %cond535, 8
  %cmp537 = icmp slt i64 %139, %div536
  br i1 %cmp537, label %cond.true.647, label %lor.lhs.false.633

cond.false.539:                                   ; preds = %cond.true.513
  br i1 false, label %cond.true.540, label %cond.false.541

cond.true.540:                                    ; preds = %cond.false.539
  br i1 false, label %cond.true.647, label %lor.lhs.false.633

cond.false.541:                                   ; preds = %cond.false.539
  %143 = load i64, i64* %nargs2, align 8
  %add542 = add nsw i64 0, %143
  %mul543 = mul nsw i64 0, %add542
  %sub544 = sub nsw i64 %mul543, 1
  %cmp545 = icmp slt i64 %sub544, 0
  br i1 %cmp545, label %cond.true.547, label %cond.false.564

cond.true.547:                                    ; preds = %cond.false.541
  %144 = load i64, i64* %nargs2, align 8
  %add548 = add nsw i64 0, %144
  %mul549 = mul nsw i64 0, %add548
  %add550 = add nsw i64 %mul549, 0
  %neg551 = xor i64 %add550, -1
  %cmp552 = icmp eq i64 %neg551, -1
  %conv553 = zext i1 %cmp552 to i32
  %sub554 = sub nsw i32 0, %conv553
  %conv555 = sext i32 %sub554 to i64
  %145 = load i64, i64* %nargs2, align 8
  %add556 = add nsw i64 0, %145
  %mul557 = mul nsw i64 0, %add556
  %add558 = add nsw i64 %mul557, 1
  %shl559 = shl i64 %add558, 62
  %sub560 = sub nsw i64 %shl559, 1
  %mul561 = mul nsw i64 %sub560, 2
  %add562 = add nsw i64 %mul561, 1
  %sub563 = sub nsw i64 %conv555, %add562
  br label %cond.end.568

cond.false.564:                                   ; preds = %cond.false.541
  %146 = load i64, i64* %nargs2, align 8
  %add565 = add nsw i64 0, %146
  %mul566 = mul nsw i64 0, %add565
  %add567 = add nsw i64 %mul566, 0
  br label %cond.end.568

cond.end.568:                                     ; preds = %cond.false.564, %cond.true.547
  %cond569 = phi i64 [ %sub563, %cond.true.547 ], [ %add567, %cond.false.564 ]
  %div570 = sdiv i64 %cond569, 8
  %147 = load i64, i64* %nargs2, align 8
  %cmp571 = icmp slt i64 %div570, %147
  br i1 %cmp571, label %cond.true.647, label %lor.lhs.false.633

cond.false.573:                                   ; preds = %lor.lhs.false.512
  br i1 false, label %cond.true.574, label %cond.false.575

cond.true.574:                                    ; preds = %cond.false.573
  br i1 false, label %cond.true.647, label %lor.lhs.false.633

cond.false.575:                                   ; preds = %cond.false.573
  %148 = load i64, i64* %nargs2, align 8
  %cmp576 = icmp slt i64 %148, 0
  br i1 %cmp576, label %cond.true.578, label %cond.false.610

cond.true.578:                                    ; preds = %cond.false.575
  %149 = load i64, i64* %nargs2, align 8
  %150 = load i64, i64* %nargs2, align 8
  %add579 = add nsw i64 0, %150
  %mul580 = mul nsw i64 0, %add579
  %sub581 = sub nsw i64 %mul580, 1
  %cmp582 = icmp slt i64 %sub581, 0
  br i1 %cmp582, label %cond.true.584, label %cond.false.601

cond.true.584:                                    ; preds = %cond.true.578
  %151 = load i64, i64* %nargs2, align 8
  %add585 = add nsw i64 0, %151
  %mul586 = mul nsw i64 0, %add585
  %add587 = add nsw i64 %mul586, 0
  %neg588 = xor i64 %add587, -1
  %cmp589 = icmp eq i64 %neg588, -1
  %conv590 = zext i1 %cmp589 to i32
  %sub591 = sub nsw i32 0, %conv590
  %conv592 = sext i32 %sub591 to i64
  %152 = load i64, i64* %nargs2, align 8
  %add593 = add nsw i64 0, %152
  %mul594 = mul nsw i64 0, %add593
  %add595 = add nsw i64 %mul594, 1
  %shl596 = shl i64 %add595, 62
  %sub597 = sub nsw i64 %shl596, 1
  %mul598 = mul nsw i64 %sub597, 2
  %add599 = add nsw i64 %mul598, 1
  %sub600 = sub nsw i64 %conv592, %add599
  br label %cond.end.605

cond.false.601:                                   ; preds = %cond.true.578
  %153 = load i64, i64* %nargs2, align 8
  %add602 = add nsw i64 0, %153
  %mul603 = mul nsw i64 0, %add602
  %add604 = add nsw i64 %mul603, 0
  br label %cond.end.605

cond.end.605:                                     ; preds = %cond.false.601, %cond.true.584
  %cond606 = phi i64 [ %sub600, %cond.true.584 ], [ %add604, %cond.false.601 ]
  %div607 = sdiv i64 %cond606, 8
  %cmp608 = icmp slt i64 %149, %div607
  br i1 %cmp608, label %cond.true.647, label %lor.lhs.false.633

cond.false.610:                                   ; preds = %cond.false.575
  %154 = load i64, i64* %nargs2, align 8
  %add611 = add nsw i64 0, %154
  %mul612 = mul nsw i64 0, %add611
  %sub613 = sub nsw i64 %mul612, 1
  %cmp614 = icmp slt i64 %sub613, 0
  br i1 %cmp614, label %cond.true.616, label %cond.false.624

cond.true.616:                                    ; preds = %cond.false.610
  %155 = load i64, i64* %nargs2, align 8
  %add617 = add nsw i64 0, %155
  %mul618 = mul nsw i64 0, %add617
  %add619 = add nsw i64 %mul618, 1
  %shl620 = shl i64 %add619, 62
  %sub621 = sub nsw i64 %shl620, 1
  %mul622 = mul nsw i64 %sub621, 2
  %add623 = add nsw i64 %mul622, 1
  br label %cond.end.628

cond.false.624:                                   ; preds = %cond.false.610
  %156 = load i64, i64* %nargs2, align 8
  %add625 = add nsw i64 0, %156
  %mul626 = mul nsw i64 0, %add625
  %sub627 = sub nsw i64 %mul626, 1
  br label %cond.end.628

cond.end.628:                                     ; preds = %cond.false.624, %cond.true.616
  %cond629 = phi i64 [ %add623, %cond.true.616 ], [ %sub627, %cond.false.624 ]
  %div630 = sdiv i64 %cond629, 8
  %157 = load i64, i64* %nargs2, align 8
  %cmp631 = icmp slt i64 %div630, %157
  br i1 %cmp631, label %cond.true.647, label %lor.lhs.false.633

lor.lhs.false.633:                                ; preds = %cond.end.628, %cond.end.605, %cond.true.574, %cond.end.568, %cond.true.540, %cond.end.534
  %158 = load i64, i64* %nargs2, align 8
  %mul634 = mul nsw i64 %158, 8
  %mul635 = mul nsw i64 0, %mul634
  %sub636 = sub nsw i64 %mul635, 1
  %cmp637 = icmp slt i64 %sub636, 0
  br i1 %cmp637, label %land.lhs.true.639, label %lor.lhs.false.643

land.lhs.true.639:                                ; preds = %lor.lhs.false.633
  %159 = load i64, i64* %nargs2, align 8
  %mul640 = mul nsw i64 %159, 8
  %cmp641 = icmp slt i64 %mul640, -128
  br i1 %cmp641, label %cond.true.647, label %lor.lhs.false.643

lor.lhs.false.643:                                ; preds = %land.lhs.true.639, %lor.lhs.false.633
  %160 = load i64, i64* %nargs2, align 8
  %mul644 = mul nsw i64 %160, 8
  %cmp645 = icmp slt i64 127, %mul644
  br i1 %cmp645, label %cond.true.647, label %cond.false.670

cond.true.647:                                    ; preds = %lor.lhs.false.643, %land.lhs.true.639, %cond.end.628, %cond.end.605, %cond.true.574, %cond.end.568, %cond.true.540, %cond.end.534, %land.lhs.true.509
  %161 = load i64, i64* %nargs2, align 8
  %conv648 = trunc i64 %161 to i8
  %conv649 = zext i8 %conv648 to i32
  %mul650 = mul nsw i32 %conv649, 8
  %cmp651 = icmp sle i32 %mul650, 127
  br i1 %cmp651, label %cond.true.653, label %cond.false.659

cond.true.653:                                    ; preds = %cond.true.647
  %162 = load i64, i64* %nargs2, align 8
  %conv654 = trunc i64 %162 to i8
  %conv655 = zext i8 %conv654 to i32
  %mul656 = mul nsw i32 %conv655, 8
  %conv657 = trunc i32 %mul656 to i8
  %conv658 = sext i8 %conv657 to i32
  br label %cond.end.667

cond.false.659:                                   ; preds = %cond.true.647
  %163 = load i64, i64* %nargs2, align 8
  %conv660 = trunc i64 %163 to i8
  %conv661 = zext i8 %conv660 to i32
  %mul662 = mul nsw i32 %conv661, 8
  %sub663 = sub nsw i32 %mul662, -128
  %conv664 = trunc i32 %sub663 to i8
  %conv665 = sext i8 %conv664 to i32
  %add666 = add nsw i32 %conv665, -128
  br label %cond.end.667

cond.end.667:                                     ; preds = %cond.false.659, %cond.true.653
  %cond668 = phi i32 [ %conv658, %cond.true.653 ], [ %add666, %cond.false.659 ]
  %conv669 = sext i32 %cond668 to i64
  store i64 %conv669, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.670:                                   ; preds = %lor.lhs.false.643
  %164 = load i64, i64* %nargs2, align 8
  %conv671 = trunc i64 %164 to i8
  %conv672 = zext i8 %conv671 to i32
  %mul673 = mul nsw i32 %conv672, 8
  %cmp674 = icmp sle i32 %mul673, 127
  br i1 %cmp674, label %cond.true.676, label %cond.false.682

cond.true.676:                                    ; preds = %cond.false.670
  %165 = load i64, i64* %nargs2, align 8
  %conv677 = trunc i64 %165 to i8
  %conv678 = zext i8 %conv677 to i32
  %mul679 = mul nsw i32 %conv678, 8
  %conv680 = trunc i32 %mul679 to i8
  %conv681 = sext i8 %conv680 to i32
  br label %cond.end.690

cond.false.682:                                   ; preds = %cond.false.670
  %166 = load i64, i64* %nargs2, align 8
  %conv683 = trunc i64 %166 to i8
  %conv684 = zext i8 %conv683 to i32
  %mul685 = mul nsw i32 %conv684, 8
  %sub686 = sub nsw i32 %mul685, -128
  %conv687 = trunc i32 %sub686 to i8
  %conv688 = sext i8 %conv687 to i32
  %add689 = add nsw i32 %conv688, -128
  br label %cond.end.690

cond.end.690:                                     ; preds = %cond.false.682, %cond.true.676
  %cond691 = phi i32 [ %conv681, %cond.true.676 ], [ %add689, %cond.false.682 ]
  %conv692 = sext i32 %cond691 to i64
  store i64 %conv692, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.693:                                   ; preds = %do.body
  br i1 false, label %cond.true.694, label %cond.false.1178

cond.true.694:                                    ; preds = %cond.false.693
  br i1 false, label %cond.true.695, label %cond.false.963

cond.true.695:                                    ; preds = %cond.true.694
  %167 = load i64, i64* %nargs2, align 8
  %conv696 = trunc i64 %167 to i16
  %conv697 = sext i16 %conv696 to i32
  %add698 = add nsw i32 0, %conv697
  %mul699 = mul nsw i32 0, %add698
  %sub700 = sub nsw i32 %mul699, 1
  %cmp701 = icmp slt i32 %sub700, 0
  br i1 %cmp701, label %cond.true.703, label %cond.false.723

cond.true.703:                                    ; preds = %cond.true.695
  %168 = load i64, i64* %nargs2, align 8
  %conv704 = trunc i64 %168 to i16
  %conv705 = sext i16 %conv704 to i32
  %add706 = add nsw i32 0, %conv705
  %mul707 = mul nsw i32 0, %add706
  %add708 = add nsw i32 %mul707, 0
  %neg709 = xor i32 %add708, -1
  %cmp710 = icmp eq i32 %neg709, -1
  %conv711 = zext i1 %cmp710 to i32
  %sub712 = sub nsw i32 0, %conv711
  %169 = load i64, i64* %nargs2, align 8
  %conv713 = trunc i64 %169 to i16
  %conv714 = sext i16 %conv713 to i32
  %add715 = add nsw i32 0, %conv714
  %mul716 = mul nsw i32 0, %add715
  %add717 = add nsw i32 %mul716, 1
  %shl718 = shl i32 %add717, 30
  %sub719 = sub nsw i32 %shl718, 1
  %mul720 = mul nsw i32 %sub719, 2
  %add721 = add nsw i32 %mul720, 1
  %sub722 = sub nsw i32 %sub712, %add721
  br label %cond.end.729

cond.false.723:                                   ; preds = %cond.true.695
  %170 = load i64, i64* %nargs2, align 8
  %conv724 = trunc i64 %170 to i16
  %conv725 = sext i16 %conv724 to i32
  %add726 = add nsw i32 0, %conv725
  %mul727 = mul nsw i32 0, %add726
  %add728 = add nsw i32 %mul727, 0
  br label %cond.end.729

cond.end.729:                                     ; preds = %cond.false.723, %cond.true.703
  %cond730 = phi i32 [ %sub722, %cond.true.703 ], [ %add728, %cond.false.723 ]
  %cmp731 = icmp eq i32 %cond730, 0
  br i1 %cmp731, label %land.lhs.true.733, label %lor.lhs.false.738

land.lhs.true.733:                                ; preds = %cond.end.729
  %171 = load i64, i64* %nargs2, align 8
  %conv734 = trunc i64 %171 to i16
  %conv735 = sext i16 %conv734 to i32
  %cmp736 = icmp slt i32 %conv735, 0
  br i1 %cmp736, label %cond.true.917, label %lor.lhs.false.738

lor.lhs.false.738:                                ; preds = %land.lhs.true.733, %cond.end.729
  br i1 false, label %cond.true.739, label %cond.false.818

cond.true.739:                                    ; preds = %lor.lhs.false.738
  %172 = load i64, i64* %nargs2, align 8
  %conv740 = trunc i64 %172 to i16
  %conv741 = sext i16 %conv740 to i32
  %cmp742 = icmp slt i32 %conv741, 0
  br i1 %cmp742, label %cond.true.744, label %cond.false.775

cond.true.744:                                    ; preds = %cond.true.739
  %173 = load i64, i64* %nargs2, align 8
  %conv745 = trunc i64 %173 to i16
  %conv746 = sext i16 %conv745 to i32
  %174 = load i64, i64* %nargs2, align 8
  %conv747 = trunc i64 %174 to i16
  %conv748 = sext i16 %conv747 to i32
  %add749 = add nsw i32 0, %conv748
  %mul750 = mul nsw i32 0, %add749
  %sub751 = sub nsw i32 %mul750, 1
  %cmp752 = icmp slt i32 %sub751, 0
  br i1 %cmp752, label %cond.true.754, label %cond.false.764

cond.true.754:                                    ; preds = %cond.true.744
  %175 = load i64, i64* %nargs2, align 8
  %conv755 = trunc i64 %175 to i16
  %conv756 = sext i16 %conv755 to i32
  %add757 = add nsw i32 0, %conv756
  %mul758 = mul nsw i32 0, %add757
  %add759 = add nsw i32 %mul758, 1
  %shl760 = shl i32 %add759, 30
  %sub761 = sub nsw i32 %shl760, 1
  %mul762 = mul nsw i32 %sub761, 2
  %add763 = add nsw i32 %mul762, 1
  br label %cond.end.770

cond.false.764:                                   ; preds = %cond.true.744
  %176 = load i64, i64* %nargs2, align 8
  %conv765 = trunc i64 %176 to i16
  %conv766 = sext i16 %conv765 to i32
  %add767 = add nsw i32 0, %conv766
  %mul768 = mul nsw i32 0, %add767
  %sub769 = sub nsw i32 %mul768, 1
  br label %cond.end.770

cond.end.770:                                     ; preds = %cond.false.764, %cond.true.754
  %cond771 = phi i32 [ %add763, %cond.true.754 ], [ %sub769, %cond.false.764 ]
  %div772 = sdiv i32 %cond771, 8
  %cmp773 = icmp slt i32 %conv746, %div772
  br i1 %cmp773, label %cond.true.917, label %lor.lhs.false.897

cond.false.775:                                   ; preds = %cond.true.739
  br i1 false, label %cond.true.776, label %cond.false.777

cond.true.776:                                    ; preds = %cond.false.775
  br i1 false, label %cond.true.917, label %lor.lhs.false.897

cond.false.777:                                   ; preds = %cond.false.775
  %177 = load i64, i64* %nargs2, align 8
  %conv778 = trunc i64 %177 to i16
  %conv779 = sext i16 %conv778 to i32
  %add780 = add nsw i32 0, %conv779
  %mul781 = mul nsw i32 0, %add780
  %sub782 = sub nsw i32 %mul781, 1
  %cmp783 = icmp slt i32 %sub782, 0
  br i1 %cmp783, label %cond.true.785, label %cond.false.805

cond.true.785:                                    ; preds = %cond.false.777
  %178 = load i64, i64* %nargs2, align 8
  %conv786 = trunc i64 %178 to i16
  %conv787 = sext i16 %conv786 to i32
  %add788 = add nsw i32 0, %conv787
  %mul789 = mul nsw i32 0, %add788
  %add790 = add nsw i32 %mul789, 0
  %neg791 = xor i32 %add790, -1
  %cmp792 = icmp eq i32 %neg791, -1
  %conv793 = zext i1 %cmp792 to i32
  %sub794 = sub nsw i32 0, %conv793
  %179 = load i64, i64* %nargs2, align 8
  %conv795 = trunc i64 %179 to i16
  %conv796 = sext i16 %conv795 to i32
  %add797 = add nsw i32 0, %conv796
  %mul798 = mul nsw i32 0, %add797
  %add799 = add nsw i32 %mul798, 1
  %shl800 = shl i32 %add799, 30
  %sub801 = sub nsw i32 %shl800, 1
  %mul802 = mul nsw i32 %sub801, 2
  %add803 = add nsw i32 %mul802, 1
  %sub804 = sub nsw i32 %sub794, %add803
  br label %cond.end.811

cond.false.805:                                   ; preds = %cond.false.777
  %180 = load i64, i64* %nargs2, align 8
  %conv806 = trunc i64 %180 to i16
  %conv807 = sext i16 %conv806 to i32
  %add808 = add nsw i32 0, %conv807
  %mul809 = mul nsw i32 0, %add808
  %add810 = add nsw i32 %mul809, 0
  br label %cond.end.811

cond.end.811:                                     ; preds = %cond.false.805, %cond.true.785
  %cond812 = phi i32 [ %sub804, %cond.true.785 ], [ %add810, %cond.false.805 ]
  %div813 = sdiv i32 %cond812, 8
  %181 = load i64, i64* %nargs2, align 8
  %conv814 = trunc i64 %181 to i16
  %conv815 = sext i16 %conv814 to i32
  %cmp816 = icmp slt i32 %div813, %conv815
  br i1 %cmp816, label %cond.true.917, label %lor.lhs.false.897

cond.false.818:                                   ; preds = %lor.lhs.false.738
  br i1 false, label %cond.true.819, label %cond.false.820

cond.true.819:                                    ; preds = %cond.false.818
  br i1 false, label %cond.true.917, label %lor.lhs.false.897

cond.false.820:                                   ; preds = %cond.false.818
  %182 = load i64, i64* %nargs2, align 8
  %conv821 = trunc i64 %182 to i16
  %conv822 = sext i16 %conv821 to i32
  %cmp823 = icmp slt i32 %conv822, 0
  br i1 %cmp823, label %cond.true.825, label %cond.false.866

cond.true.825:                                    ; preds = %cond.false.820
  %183 = load i64, i64* %nargs2, align 8
  %conv826 = trunc i64 %183 to i16
  %conv827 = sext i16 %conv826 to i32
  %184 = load i64, i64* %nargs2, align 8
  %conv828 = trunc i64 %184 to i16
  %conv829 = sext i16 %conv828 to i32
  %add830 = add nsw i32 0, %conv829
  %mul831 = mul nsw i32 0, %add830
  %sub832 = sub nsw i32 %mul831, 1
  %cmp833 = icmp slt i32 %sub832, 0
  br i1 %cmp833, label %cond.true.835, label %cond.false.855

cond.true.835:                                    ; preds = %cond.true.825
  %185 = load i64, i64* %nargs2, align 8
  %conv836 = trunc i64 %185 to i16
  %conv837 = sext i16 %conv836 to i32
  %add838 = add nsw i32 0, %conv837
  %mul839 = mul nsw i32 0, %add838
  %add840 = add nsw i32 %mul839, 0
  %neg841 = xor i32 %add840, -1
  %cmp842 = icmp eq i32 %neg841, -1
  %conv843 = zext i1 %cmp842 to i32
  %sub844 = sub nsw i32 0, %conv843
  %186 = load i64, i64* %nargs2, align 8
  %conv845 = trunc i64 %186 to i16
  %conv846 = sext i16 %conv845 to i32
  %add847 = add nsw i32 0, %conv846
  %mul848 = mul nsw i32 0, %add847
  %add849 = add nsw i32 %mul848, 1
  %shl850 = shl i32 %add849, 30
  %sub851 = sub nsw i32 %shl850, 1
  %mul852 = mul nsw i32 %sub851, 2
  %add853 = add nsw i32 %mul852, 1
  %sub854 = sub nsw i32 %sub844, %add853
  br label %cond.end.861

cond.false.855:                                   ; preds = %cond.true.825
  %187 = load i64, i64* %nargs2, align 8
  %conv856 = trunc i64 %187 to i16
  %conv857 = sext i16 %conv856 to i32
  %add858 = add nsw i32 0, %conv857
  %mul859 = mul nsw i32 0, %add858
  %add860 = add nsw i32 %mul859, 0
  br label %cond.end.861

cond.end.861:                                     ; preds = %cond.false.855, %cond.true.835
  %cond862 = phi i32 [ %sub854, %cond.true.835 ], [ %add860, %cond.false.855 ]
  %div863 = sdiv i32 %cond862, 8
  %cmp864 = icmp slt i32 %conv827, %div863
  br i1 %cmp864, label %cond.true.917, label %lor.lhs.false.897

cond.false.866:                                   ; preds = %cond.false.820
  %188 = load i64, i64* %nargs2, align 8
  %conv867 = trunc i64 %188 to i16
  %conv868 = sext i16 %conv867 to i32
  %add869 = add nsw i32 0, %conv868
  %mul870 = mul nsw i32 0, %add869
  %sub871 = sub nsw i32 %mul870, 1
  %cmp872 = icmp slt i32 %sub871, 0
  br i1 %cmp872, label %cond.true.874, label %cond.false.884

cond.true.874:                                    ; preds = %cond.false.866
  %189 = load i64, i64* %nargs2, align 8
  %conv875 = trunc i64 %189 to i16
  %conv876 = sext i16 %conv875 to i32
  %add877 = add nsw i32 0, %conv876
  %mul878 = mul nsw i32 0, %add877
  %add879 = add nsw i32 %mul878, 1
  %shl880 = shl i32 %add879, 30
  %sub881 = sub nsw i32 %shl880, 1
  %mul882 = mul nsw i32 %sub881, 2
  %add883 = add nsw i32 %mul882, 1
  br label %cond.end.890

cond.false.884:                                   ; preds = %cond.false.866
  %190 = load i64, i64* %nargs2, align 8
  %conv885 = trunc i64 %190 to i16
  %conv886 = sext i16 %conv885 to i32
  %add887 = add nsw i32 0, %conv886
  %mul888 = mul nsw i32 0, %add887
  %sub889 = sub nsw i32 %mul888, 1
  br label %cond.end.890

cond.end.890:                                     ; preds = %cond.false.884, %cond.true.874
  %cond891 = phi i32 [ %add883, %cond.true.874 ], [ %sub889, %cond.false.884 ]
  %div892 = sdiv i32 %cond891, 8
  %191 = load i64, i64* %nargs2, align 8
  %conv893 = trunc i64 %191 to i16
  %conv894 = sext i16 %conv893 to i32
  %cmp895 = icmp slt i32 %div892, %conv894
  br i1 %cmp895, label %cond.true.917, label %lor.lhs.false.897

lor.lhs.false.897:                                ; preds = %cond.end.890, %cond.end.861, %cond.true.819, %cond.end.811, %cond.true.776, %cond.end.770
  %192 = load i64, i64* %nargs2, align 8
  %conv898 = trunc i64 %192 to i16
  %conv899 = sext i16 %conv898 to i32
  %mul900 = mul nsw i32 %conv899, 8
  %mul901 = mul nsw i32 0, %mul900
  %sub902 = sub nsw i32 %mul901, 1
  %cmp903 = icmp slt i32 %sub902, 0
  br i1 %cmp903, label %land.lhs.true.905, label %lor.lhs.false.911

land.lhs.true.905:                                ; preds = %lor.lhs.false.897
  %193 = load i64, i64* %nargs2, align 8
  %conv906 = trunc i64 %193 to i16
  %conv907 = sext i16 %conv906 to i32
  %mul908 = mul nsw i32 %conv907, 8
  %cmp909 = icmp slt i32 %mul908, -32768
  br i1 %cmp909, label %cond.true.917, label %lor.lhs.false.911

lor.lhs.false.911:                                ; preds = %land.lhs.true.905, %lor.lhs.false.897
  %194 = load i64, i64* %nargs2, align 8
  %conv912 = trunc i64 %194 to i16
  %conv913 = sext i16 %conv912 to i32
  %mul914 = mul nsw i32 %conv913, 8
  %cmp915 = icmp slt i32 32767, %mul914
  br i1 %cmp915, label %cond.true.917, label %cond.false.940

cond.true.917:                                    ; preds = %lor.lhs.false.911, %land.lhs.true.905, %cond.end.890, %cond.end.861, %cond.true.819, %cond.end.811, %cond.true.776, %cond.end.770, %land.lhs.true.733
  %195 = load i64, i64* %nargs2, align 8
  %conv918 = trunc i64 %195 to i16
  %conv919 = zext i16 %conv918 to i32
  %mul920 = mul nsw i32 %conv919, 8
  %cmp921 = icmp sle i32 %mul920, 32767
  br i1 %cmp921, label %cond.true.923, label %cond.false.929

cond.true.923:                                    ; preds = %cond.true.917
  %196 = load i64, i64* %nargs2, align 8
  %conv924 = trunc i64 %196 to i16
  %conv925 = zext i16 %conv924 to i32
  %mul926 = mul nsw i32 %conv925, 8
  %conv927 = trunc i32 %mul926 to i16
  %conv928 = sext i16 %conv927 to i32
  br label %cond.end.937

cond.false.929:                                   ; preds = %cond.true.917
  %197 = load i64, i64* %nargs2, align 8
  %conv930 = trunc i64 %197 to i16
  %conv931 = zext i16 %conv930 to i32
  %mul932 = mul nsw i32 %conv931, 8
  %sub933 = sub nsw i32 %mul932, -32768
  %conv934 = trunc i32 %sub933 to i16
  %conv935 = sext i16 %conv934 to i32
  %add936 = add nsw i32 %conv935, -32768
  br label %cond.end.937

cond.end.937:                                     ; preds = %cond.false.929, %cond.true.923
  %cond938 = phi i32 [ %conv928, %cond.true.923 ], [ %add936, %cond.false.929 ]
  %conv939 = sext i32 %cond938 to i64
  store i64 %conv939, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.940:                                   ; preds = %lor.lhs.false.911
  %198 = load i64, i64* %nargs2, align 8
  %conv941 = trunc i64 %198 to i16
  %conv942 = zext i16 %conv941 to i32
  %mul943 = mul nsw i32 %conv942, 8
  %cmp944 = icmp sle i32 %mul943, 32767
  br i1 %cmp944, label %cond.true.946, label %cond.false.952

cond.true.946:                                    ; preds = %cond.false.940
  %199 = load i64, i64* %nargs2, align 8
  %conv947 = trunc i64 %199 to i16
  %conv948 = zext i16 %conv947 to i32
  %mul949 = mul nsw i32 %conv948, 8
  %conv950 = trunc i32 %mul949 to i16
  %conv951 = sext i16 %conv950 to i32
  br label %cond.end.960

cond.false.952:                                   ; preds = %cond.false.940
  %200 = load i64, i64* %nargs2, align 8
  %conv953 = trunc i64 %200 to i16
  %conv954 = zext i16 %conv953 to i32
  %mul955 = mul nsw i32 %conv954, 8
  %sub956 = sub nsw i32 %mul955, -32768
  %conv957 = trunc i32 %sub956 to i16
  %conv958 = sext i16 %conv957 to i32
  %add959 = add nsw i32 %conv958, -32768
  br label %cond.end.960

cond.end.960:                                     ; preds = %cond.false.952, %cond.true.946
  %cond961 = phi i32 [ %conv951, %cond.true.946 ], [ %add959, %cond.false.952 ]
  %conv962 = sext i32 %cond961 to i64
  store i64 %conv962, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.963:                                   ; preds = %cond.true.694
  %201 = load i64, i64* %nargs2, align 8
  %add964 = add nsw i64 0, %201
  %mul965 = mul nsw i64 0, %add964
  %sub966 = sub nsw i64 %mul965, 1
  %cmp967 = icmp slt i64 %sub966, 0
  br i1 %cmp967, label %cond.true.969, label %cond.false.986

cond.true.969:                                    ; preds = %cond.false.963
  %202 = load i64, i64* %nargs2, align 8
  %add970 = add nsw i64 0, %202
  %mul971 = mul nsw i64 0, %add970
  %add972 = add nsw i64 %mul971, 0
  %neg973 = xor i64 %add972, -1
  %cmp974 = icmp eq i64 %neg973, -1
  %conv975 = zext i1 %cmp974 to i32
  %sub976 = sub nsw i32 0, %conv975
  %conv977 = sext i32 %sub976 to i64
  %203 = load i64, i64* %nargs2, align 8
  %add978 = add nsw i64 0, %203
  %mul979 = mul nsw i64 0, %add978
  %add980 = add nsw i64 %mul979, 1
  %shl981 = shl i64 %add980, 62
  %sub982 = sub nsw i64 %shl981, 1
  %mul983 = mul nsw i64 %sub982, 2
  %add984 = add nsw i64 %mul983, 1
  %sub985 = sub nsw i64 %conv977, %add984
  br label %cond.end.990

cond.false.986:                                   ; preds = %cond.false.963
  %204 = load i64, i64* %nargs2, align 8
  %add987 = add nsw i64 0, %204
  %mul988 = mul nsw i64 0, %add987
  %add989 = add nsw i64 %mul988, 0
  br label %cond.end.990

cond.end.990:                                     ; preds = %cond.false.986, %cond.true.969
  %cond991 = phi i64 [ %sub985, %cond.true.969 ], [ %add989, %cond.false.986 ]
  %cmp992 = icmp eq i64 %cond991, 0
  br i1 %cmp992, label %land.lhs.true.994, label %lor.lhs.false.997

land.lhs.true.994:                                ; preds = %cond.end.990
  %205 = load i64, i64* %nargs2, align 8
  %cmp995 = icmp slt i64 %205, 0
  br i1 %cmp995, label %cond.true.1132, label %lor.lhs.false.997

lor.lhs.false.997:                                ; preds = %land.lhs.true.994, %cond.end.990
  br i1 false, label %cond.true.998, label %cond.false.1058

cond.true.998:                                    ; preds = %lor.lhs.false.997
  %206 = load i64, i64* %nargs2, align 8
  %cmp999 = icmp slt i64 %206, 0
  br i1 %cmp999, label %cond.true.1001, label %cond.false.1024

cond.true.1001:                                   ; preds = %cond.true.998
  %207 = load i64, i64* %nargs2, align 8
  %208 = load i64, i64* %nargs2, align 8
  %add1002 = add nsw i64 0, %208
  %mul1003 = mul nsw i64 0, %add1002
  %sub1004 = sub nsw i64 %mul1003, 1
  %cmp1005 = icmp slt i64 %sub1004, 0
  br i1 %cmp1005, label %cond.true.1007, label %cond.false.1015

cond.true.1007:                                   ; preds = %cond.true.1001
  %209 = load i64, i64* %nargs2, align 8
  %add1008 = add nsw i64 0, %209
  %mul1009 = mul nsw i64 0, %add1008
  %add1010 = add nsw i64 %mul1009, 1
  %shl1011 = shl i64 %add1010, 62
  %sub1012 = sub nsw i64 %shl1011, 1
  %mul1013 = mul nsw i64 %sub1012, 2
  %add1014 = add nsw i64 %mul1013, 1
  br label %cond.end.1019

cond.false.1015:                                  ; preds = %cond.true.1001
  %210 = load i64, i64* %nargs2, align 8
  %add1016 = add nsw i64 0, %210
  %mul1017 = mul nsw i64 0, %add1016
  %sub1018 = sub nsw i64 %mul1017, 1
  br label %cond.end.1019

cond.end.1019:                                    ; preds = %cond.false.1015, %cond.true.1007
  %cond1020 = phi i64 [ %add1014, %cond.true.1007 ], [ %sub1018, %cond.false.1015 ]
  %div1021 = sdiv i64 %cond1020, 8
  %cmp1022 = icmp slt i64 %207, %div1021
  br i1 %cmp1022, label %cond.true.1132, label %lor.lhs.false.1118

cond.false.1024:                                  ; preds = %cond.true.998
  br i1 false, label %cond.true.1025, label %cond.false.1026

cond.true.1025:                                   ; preds = %cond.false.1024
  br i1 false, label %cond.true.1132, label %lor.lhs.false.1118

cond.false.1026:                                  ; preds = %cond.false.1024
  %211 = load i64, i64* %nargs2, align 8
  %add1027 = add nsw i64 0, %211
  %mul1028 = mul nsw i64 0, %add1027
  %sub1029 = sub nsw i64 %mul1028, 1
  %cmp1030 = icmp slt i64 %sub1029, 0
  br i1 %cmp1030, label %cond.true.1032, label %cond.false.1049

cond.true.1032:                                   ; preds = %cond.false.1026
  %212 = load i64, i64* %nargs2, align 8
  %add1033 = add nsw i64 0, %212
  %mul1034 = mul nsw i64 0, %add1033
  %add1035 = add nsw i64 %mul1034, 0
  %neg1036 = xor i64 %add1035, -1
  %cmp1037 = icmp eq i64 %neg1036, -1
  %conv1038 = zext i1 %cmp1037 to i32
  %sub1039 = sub nsw i32 0, %conv1038
  %conv1040 = sext i32 %sub1039 to i64
  %213 = load i64, i64* %nargs2, align 8
  %add1041 = add nsw i64 0, %213
  %mul1042 = mul nsw i64 0, %add1041
  %add1043 = add nsw i64 %mul1042, 1
  %shl1044 = shl i64 %add1043, 62
  %sub1045 = sub nsw i64 %shl1044, 1
  %mul1046 = mul nsw i64 %sub1045, 2
  %add1047 = add nsw i64 %mul1046, 1
  %sub1048 = sub nsw i64 %conv1040, %add1047
  br label %cond.end.1053

cond.false.1049:                                  ; preds = %cond.false.1026
  %214 = load i64, i64* %nargs2, align 8
  %add1050 = add nsw i64 0, %214
  %mul1051 = mul nsw i64 0, %add1050
  %add1052 = add nsw i64 %mul1051, 0
  br label %cond.end.1053

cond.end.1053:                                    ; preds = %cond.false.1049, %cond.true.1032
  %cond1054 = phi i64 [ %sub1048, %cond.true.1032 ], [ %add1052, %cond.false.1049 ]
  %div1055 = sdiv i64 %cond1054, 8
  %215 = load i64, i64* %nargs2, align 8
  %cmp1056 = icmp slt i64 %div1055, %215
  br i1 %cmp1056, label %cond.true.1132, label %lor.lhs.false.1118

cond.false.1058:                                  ; preds = %lor.lhs.false.997
  br i1 false, label %cond.true.1059, label %cond.false.1060

cond.true.1059:                                   ; preds = %cond.false.1058
  br i1 false, label %cond.true.1132, label %lor.lhs.false.1118

cond.false.1060:                                  ; preds = %cond.false.1058
  %216 = load i64, i64* %nargs2, align 8
  %cmp1061 = icmp slt i64 %216, 0
  br i1 %cmp1061, label %cond.true.1063, label %cond.false.1095

cond.true.1063:                                   ; preds = %cond.false.1060
  %217 = load i64, i64* %nargs2, align 8
  %218 = load i64, i64* %nargs2, align 8
  %add1064 = add nsw i64 0, %218
  %mul1065 = mul nsw i64 0, %add1064
  %sub1066 = sub nsw i64 %mul1065, 1
  %cmp1067 = icmp slt i64 %sub1066, 0
  br i1 %cmp1067, label %cond.true.1069, label %cond.false.1086

cond.true.1069:                                   ; preds = %cond.true.1063
  %219 = load i64, i64* %nargs2, align 8
  %add1070 = add nsw i64 0, %219
  %mul1071 = mul nsw i64 0, %add1070
  %add1072 = add nsw i64 %mul1071, 0
  %neg1073 = xor i64 %add1072, -1
  %cmp1074 = icmp eq i64 %neg1073, -1
  %conv1075 = zext i1 %cmp1074 to i32
  %sub1076 = sub nsw i32 0, %conv1075
  %conv1077 = sext i32 %sub1076 to i64
  %220 = load i64, i64* %nargs2, align 8
  %add1078 = add nsw i64 0, %220
  %mul1079 = mul nsw i64 0, %add1078
  %add1080 = add nsw i64 %mul1079, 1
  %shl1081 = shl i64 %add1080, 62
  %sub1082 = sub nsw i64 %shl1081, 1
  %mul1083 = mul nsw i64 %sub1082, 2
  %add1084 = add nsw i64 %mul1083, 1
  %sub1085 = sub nsw i64 %conv1077, %add1084
  br label %cond.end.1090

cond.false.1086:                                  ; preds = %cond.true.1063
  %221 = load i64, i64* %nargs2, align 8
  %add1087 = add nsw i64 0, %221
  %mul1088 = mul nsw i64 0, %add1087
  %add1089 = add nsw i64 %mul1088, 0
  br label %cond.end.1090

cond.end.1090:                                    ; preds = %cond.false.1086, %cond.true.1069
  %cond1091 = phi i64 [ %sub1085, %cond.true.1069 ], [ %add1089, %cond.false.1086 ]
  %div1092 = sdiv i64 %cond1091, 8
  %cmp1093 = icmp slt i64 %217, %div1092
  br i1 %cmp1093, label %cond.true.1132, label %lor.lhs.false.1118

cond.false.1095:                                  ; preds = %cond.false.1060
  %222 = load i64, i64* %nargs2, align 8
  %add1096 = add nsw i64 0, %222
  %mul1097 = mul nsw i64 0, %add1096
  %sub1098 = sub nsw i64 %mul1097, 1
  %cmp1099 = icmp slt i64 %sub1098, 0
  br i1 %cmp1099, label %cond.true.1101, label %cond.false.1109

cond.true.1101:                                   ; preds = %cond.false.1095
  %223 = load i64, i64* %nargs2, align 8
  %add1102 = add nsw i64 0, %223
  %mul1103 = mul nsw i64 0, %add1102
  %add1104 = add nsw i64 %mul1103, 1
  %shl1105 = shl i64 %add1104, 62
  %sub1106 = sub nsw i64 %shl1105, 1
  %mul1107 = mul nsw i64 %sub1106, 2
  %add1108 = add nsw i64 %mul1107, 1
  br label %cond.end.1113

cond.false.1109:                                  ; preds = %cond.false.1095
  %224 = load i64, i64* %nargs2, align 8
  %add1110 = add nsw i64 0, %224
  %mul1111 = mul nsw i64 0, %add1110
  %sub1112 = sub nsw i64 %mul1111, 1
  br label %cond.end.1113

cond.end.1113:                                    ; preds = %cond.false.1109, %cond.true.1101
  %cond1114 = phi i64 [ %add1108, %cond.true.1101 ], [ %sub1112, %cond.false.1109 ]
  %div1115 = sdiv i64 %cond1114, 8
  %225 = load i64, i64* %nargs2, align 8
  %cmp1116 = icmp slt i64 %div1115, %225
  br i1 %cmp1116, label %cond.true.1132, label %lor.lhs.false.1118

lor.lhs.false.1118:                               ; preds = %cond.end.1113, %cond.end.1090, %cond.true.1059, %cond.end.1053, %cond.true.1025, %cond.end.1019
  %226 = load i64, i64* %nargs2, align 8
  %mul1119 = mul nsw i64 %226, 8
  %mul1120 = mul nsw i64 0, %mul1119
  %sub1121 = sub nsw i64 %mul1120, 1
  %cmp1122 = icmp slt i64 %sub1121, 0
  br i1 %cmp1122, label %land.lhs.true.1124, label %lor.lhs.false.1128

land.lhs.true.1124:                               ; preds = %lor.lhs.false.1118
  %227 = load i64, i64* %nargs2, align 8
  %mul1125 = mul nsw i64 %227, 8
  %cmp1126 = icmp slt i64 %mul1125, -32768
  br i1 %cmp1126, label %cond.true.1132, label %lor.lhs.false.1128

lor.lhs.false.1128:                               ; preds = %land.lhs.true.1124, %lor.lhs.false.1118
  %228 = load i64, i64* %nargs2, align 8
  %mul1129 = mul nsw i64 %228, 8
  %cmp1130 = icmp slt i64 32767, %mul1129
  br i1 %cmp1130, label %cond.true.1132, label %cond.false.1155

cond.true.1132:                                   ; preds = %lor.lhs.false.1128, %land.lhs.true.1124, %cond.end.1113, %cond.end.1090, %cond.true.1059, %cond.end.1053, %cond.true.1025, %cond.end.1019, %land.lhs.true.994
  %229 = load i64, i64* %nargs2, align 8
  %conv1133 = trunc i64 %229 to i16
  %conv1134 = zext i16 %conv1133 to i32
  %mul1135 = mul nsw i32 %conv1134, 8
  %cmp1136 = icmp sle i32 %mul1135, 32767
  br i1 %cmp1136, label %cond.true.1138, label %cond.false.1144

cond.true.1138:                                   ; preds = %cond.true.1132
  %230 = load i64, i64* %nargs2, align 8
  %conv1139 = trunc i64 %230 to i16
  %conv1140 = zext i16 %conv1139 to i32
  %mul1141 = mul nsw i32 %conv1140, 8
  %conv1142 = trunc i32 %mul1141 to i16
  %conv1143 = sext i16 %conv1142 to i32
  br label %cond.end.1152

cond.false.1144:                                  ; preds = %cond.true.1132
  %231 = load i64, i64* %nargs2, align 8
  %conv1145 = trunc i64 %231 to i16
  %conv1146 = zext i16 %conv1145 to i32
  %mul1147 = mul nsw i32 %conv1146, 8
  %sub1148 = sub nsw i32 %mul1147, -32768
  %conv1149 = trunc i32 %sub1148 to i16
  %conv1150 = sext i16 %conv1149 to i32
  %add1151 = add nsw i32 %conv1150, -32768
  br label %cond.end.1152

cond.end.1152:                                    ; preds = %cond.false.1144, %cond.true.1138
  %cond1153 = phi i32 [ %conv1143, %cond.true.1138 ], [ %add1151, %cond.false.1144 ]
  %conv1154 = sext i32 %cond1153 to i64
  store i64 %conv1154, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1155:                                  ; preds = %lor.lhs.false.1128
  %232 = load i64, i64* %nargs2, align 8
  %conv1156 = trunc i64 %232 to i16
  %conv1157 = zext i16 %conv1156 to i32
  %mul1158 = mul nsw i32 %conv1157, 8
  %cmp1159 = icmp sle i32 %mul1158, 32767
  br i1 %cmp1159, label %cond.true.1161, label %cond.false.1167

cond.true.1161:                                   ; preds = %cond.false.1155
  %233 = load i64, i64* %nargs2, align 8
  %conv1162 = trunc i64 %233 to i16
  %conv1163 = zext i16 %conv1162 to i32
  %mul1164 = mul nsw i32 %conv1163, 8
  %conv1165 = trunc i32 %mul1164 to i16
  %conv1166 = sext i16 %conv1165 to i32
  br label %cond.end.1175

cond.false.1167:                                  ; preds = %cond.false.1155
  %234 = load i64, i64* %nargs2, align 8
  %conv1168 = trunc i64 %234 to i16
  %conv1169 = zext i16 %conv1168 to i32
  %mul1170 = mul nsw i32 %conv1169, 8
  %sub1171 = sub nsw i32 %mul1170, -32768
  %conv1172 = trunc i32 %sub1171 to i16
  %conv1173 = sext i16 %conv1172 to i32
  %add1174 = add nsw i32 %conv1173, -32768
  br label %cond.end.1175

cond.end.1175:                                    ; preds = %cond.false.1167, %cond.true.1161
  %cond1176 = phi i32 [ %conv1166, %cond.true.1161 ], [ %add1174, %cond.false.1167 ]
  %conv1177 = sext i32 %cond1176 to i64
  store i64 %conv1177, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1178:                                  ; preds = %cond.false.693
  br i1 false, label %cond.true.1179, label %cond.false.1607

cond.true.1179:                                   ; preds = %cond.false.1178
  br i1 false, label %cond.true.1180, label %cond.false.1406

cond.true.1180:                                   ; preds = %cond.true.1179
  %235 = load i64, i64* %nargs2, align 8
  %conv1181 = trunc i64 %235 to i32
  %add1182 = add nsw i32 0, %conv1181
  %mul1183 = mul nsw i32 0, %add1182
  %sub1184 = sub nsw i32 %mul1183, 1
  %cmp1185 = icmp slt i32 %sub1184, 0
  br i1 %cmp1185, label %cond.true.1187, label %cond.false.1205

cond.true.1187:                                   ; preds = %cond.true.1180
  %236 = load i64, i64* %nargs2, align 8
  %conv1188 = trunc i64 %236 to i32
  %add1189 = add nsw i32 0, %conv1188
  %mul1190 = mul nsw i32 0, %add1189
  %add1191 = add nsw i32 %mul1190, 0
  %neg1192 = xor i32 %add1191, -1
  %cmp1193 = icmp eq i32 %neg1192, -1
  %conv1194 = zext i1 %cmp1193 to i32
  %sub1195 = sub nsw i32 0, %conv1194
  %237 = load i64, i64* %nargs2, align 8
  %conv1196 = trunc i64 %237 to i32
  %add1197 = add nsw i32 0, %conv1196
  %mul1198 = mul nsw i32 0, %add1197
  %add1199 = add nsw i32 %mul1198, 1
  %shl1200 = shl i32 %add1199, 30
  %sub1201 = sub nsw i32 %shl1200, 1
  %mul1202 = mul nsw i32 %sub1201, 2
  %add1203 = add nsw i32 %mul1202, 1
  %sub1204 = sub nsw i32 %sub1195, %add1203
  br label %cond.end.1210

cond.false.1205:                                  ; preds = %cond.true.1180
  %238 = load i64, i64* %nargs2, align 8
  %conv1206 = trunc i64 %238 to i32
  %add1207 = add nsw i32 0, %conv1206
  %mul1208 = mul nsw i32 0, %add1207
  %add1209 = add nsw i32 %mul1208, 0
  br label %cond.end.1210

cond.end.1210:                                    ; preds = %cond.false.1205, %cond.true.1187
  %cond1211 = phi i32 [ %sub1204, %cond.true.1187 ], [ %add1209, %cond.false.1205 ]
  %cmp1212 = icmp eq i32 %cond1211, 0
  br i1 %cmp1212, label %land.lhs.true.1214, label %lor.lhs.false.1218

land.lhs.true.1214:                               ; preds = %cond.end.1210
  %239 = load i64, i64* %nargs2, align 8
  %conv1215 = trunc i64 %239 to i32
  %cmp1216 = icmp slt i32 %conv1215, 0
  br i1 %cmp1216, label %cond.true.1374, label %lor.lhs.false.1218

lor.lhs.false.1218:                               ; preds = %land.lhs.true.1214, %cond.end.1210
  br i1 false, label %cond.true.1219, label %cond.false.1288

cond.true.1219:                                   ; preds = %lor.lhs.false.1218
  %240 = load i64, i64* %nargs2, align 8
  %conv1220 = trunc i64 %240 to i32
  %cmp1221 = icmp slt i32 %conv1220, 0
  br i1 %cmp1221, label %cond.true.1223, label %cond.false.1250

cond.true.1223:                                   ; preds = %cond.true.1219
  %241 = load i64, i64* %nargs2, align 8
  %conv1224 = trunc i64 %241 to i32
  %242 = load i64, i64* %nargs2, align 8
  %conv1225 = trunc i64 %242 to i32
  %add1226 = add nsw i32 0, %conv1225
  %mul1227 = mul nsw i32 0, %add1226
  %sub1228 = sub nsw i32 %mul1227, 1
  %cmp1229 = icmp slt i32 %sub1228, 0
  br i1 %cmp1229, label %cond.true.1231, label %cond.false.1240

cond.true.1231:                                   ; preds = %cond.true.1223
  %243 = load i64, i64* %nargs2, align 8
  %conv1232 = trunc i64 %243 to i32
  %add1233 = add nsw i32 0, %conv1232
  %mul1234 = mul nsw i32 0, %add1233
  %add1235 = add nsw i32 %mul1234, 1
  %shl1236 = shl i32 %add1235, 30
  %sub1237 = sub nsw i32 %shl1236, 1
  %mul1238 = mul nsw i32 %sub1237, 2
  %add1239 = add nsw i32 %mul1238, 1
  br label %cond.end.1245

cond.false.1240:                                  ; preds = %cond.true.1223
  %244 = load i64, i64* %nargs2, align 8
  %conv1241 = trunc i64 %244 to i32
  %add1242 = add nsw i32 0, %conv1241
  %mul1243 = mul nsw i32 0, %add1242
  %sub1244 = sub nsw i32 %mul1243, 1
  br label %cond.end.1245

cond.end.1245:                                    ; preds = %cond.false.1240, %cond.true.1231
  %cond1246 = phi i32 [ %add1239, %cond.true.1231 ], [ %sub1244, %cond.false.1240 ]
  %div1247 = sdiv i32 %cond1246, 8
  %cmp1248 = icmp slt i32 %conv1224, %div1247
  br i1 %cmp1248, label %cond.true.1374, label %lor.lhs.false.1357

cond.false.1250:                                  ; preds = %cond.true.1219
  br i1 false, label %cond.true.1251, label %cond.false.1252

cond.true.1251:                                   ; preds = %cond.false.1250
  br i1 false, label %cond.true.1374, label %lor.lhs.false.1357

cond.false.1252:                                  ; preds = %cond.false.1250
  %245 = load i64, i64* %nargs2, align 8
  %conv1253 = trunc i64 %245 to i32
  %add1254 = add nsw i32 0, %conv1253
  %mul1255 = mul nsw i32 0, %add1254
  %sub1256 = sub nsw i32 %mul1255, 1
  %cmp1257 = icmp slt i32 %sub1256, 0
  br i1 %cmp1257, label %cond.true.1259, label %cond.false.1277

cond.true.1259:                                   ; preds = %cond.false.1252
  %246 = load i64, i64* %nargs2, align 8
  %conv1260 = trunc i64 %246 to i32
  %add1261 = add nsw i32 0, %conv1260
  %mul1262 = mul nsw i32 0, %add1261
  %add1263 = add nsw i32 %mul1262, 0
  %neg1264 = xor i32 %add1263, -1
  %cmp1265 = icmp eq i32 %neg1264, -1
  %conv1266 = zext i1 %cmp1265 to i32
  %sub1267 = sub nsw i32 0, %conv1266
  %247 = load i64, i64* %nargs2, align 8
  %conv1268 = trunc i64 %247 to i32
  %add1269 = add nsw i32 0, %conv1268
  %mul1270 = mul nsw i32 0, %add1269
  %add1271 = add nsw i32 %mul1270, 1
  %shl1272 = shl i32 %add1271, 30
  %sub1273 = sub nsw i32 %shl1272, 1
  %mul1274 = mul nsw i32 %sub1273, 2
  %add1275 = add nsw i32 %mul1274, 1
  %sub1276 = sub nsw i32 %sub1267, %add1275
  br label %cond.end.1282

cond.false.1277:                                  ; preds = %cond.false.1252
  %248 = load i64, i64* %nargs2, align 8
  %conv1278 = trunc i64 %248 to i32
  %add1279 = add nsw i32 0, %conv1278
  %mul1280 = mul nsw i32 0, %add1279
  %add1281 = add nsw i32 %mul1280, 0
  br label %cond.end.1282

cond.end.1282:                                    ; preds = %cond.false.1277, %cond.true.1259
  %cond1283 = phi i32 [ %sub1276, %cond.true.1259 ], [ %add1281, %cond.false.1277 ]
  %div1284 = sdiv i32 %cond1283, 8
  %249 = load i64, i64* %nargs2, align 8
  %conv1285 = trunc i64 %249 to i32
  %cmp1286 = icmp slt i32 %div1284, %conv1285
  br i1 %cmp1286, label %cond.true.1374, label %lor.lhs.false.1357

cond.false.1288:                                  ; preds = %lor.lhs.false.1218
  br i1 false, label %cond.true.1289, label %cond.false.1290

cond.true.1289:                                   ; preds = %cond.false.1288
  br i1 false, label %cond.true.1374, label %lor.lhs.false.1357

cond.false.1290:                                  ; preds = %cond.false.1288
  %250 = load i64, i64* %nargs2, align 8
  %conv1291 = trunc i64 %250 to i32
  %cmp1292 = icmp slt i32 %conv1291, 0
  br i1 %cmp1292, label %cond.true.1294, label %cond.false.1330

cond.true.1294:                                   ; preds = %cond.false.1290
  %251 = load i64, i64* %nargs2, align 8
  %conv1295 = trunc i64 %251 to i32
  %252 = load i64, i64* %nargs2, align 8
  %conv1296 = trunc i64 %252 to i32
  %add1297 = add nsw i32 0, %conv1296
  %mul1298 = mul nsw i32 0, %add1297
  %sub1299 = sub nsw i32 %mul1298, 1
  %cmp1300 = icmp slt i32 %sub1299, 0
  br i1 %cmp1300, label %cond.true.1302, label %cond.false.1320

cond.true.1302:                                   ; preds = %cond.true.1294
  %253 = load i64, i64* %nargs2, align 8
  %conv1303 = trunc i64 %253 to i32
  %add1304 = add nsw i32 0, %conv1303
  %mul1305 = mul nsw i32 0, %add1304
  %add1306 = add nsw i32 %mul1305, 0
  %neg1307 = xor i32 %add1306, -1
  %cmp1308 = icmp eq i32 %neg1307, -1
  %conv1309 = zext i1 %cmp1308 to i32
  %sub1310 = sub nsw i32 0, %conv1309
  %254 = load i64, i64* %nargs2, align 8
  %conv1311 = trunc i64 %254 to i32
  %add1312 = add nsw i32 0, %conv1311
  %mul1313 = mul nsw i32 0, %add1312
  %add1314 = add nsw i32 %mul1313, 1
  %shl1315 = shl i32 %add1314, 30
  %sub1316 = sub nsw i32 %shl1315, 1
  %mul1317 = mul nsw i32 %sub1316, 2
  %add1318 = add nsw i32 %mul1317, 1
  %sub1319 = sub nsw i32 %sub1310, %add1318
  br label %cond.end.1325

cond.false.1320:                                  ; preds = %cond.true.1294
  %255 = load i64, i64* %nargs2, align 8
  %conv1321 = trunc i64 %255 to i32
  %add1322 = add nsw i32 0, %conv1321
  %mul1323 = mul nsw i32 0, %add1322
  %add1324 = add nsw i32 %mul1323, 0
  br label %cond.end.1325

cond.end.1325:                                    ; preds = %cond.false.1320, %cond.true.1302
  %cond1326 = phi i32 [ %sub1319, %cond.true.1302 ], [ %add1324, %cond.false.1320 ]
  %div1327 = sdiv i32 %cond1326, 8
  %cmp1328 = icmp slt i32 %conv1295, %div1327
  br i1 %cmp1328, label %cond.true.1374, label %lor.lhs.false.1357

cond.false.1330:                                  ; preds = %cond.false.1290
  %256 = load i64, i64* %nargs2, align 8
  %conv1331 = trunc i64 %256 to i32
  %add1332 = add nsw i32 0, %conv1331
  %mul1333 = mul nsw i32 0, %add1332
  %sub1334 = sub nsw i32 %mul1333, 1
  %cmp1335 = icmp slt i32 %sub1334, 0
  br i1 %cmp1335, label %cond.true.1337, label %cond.false.1346

cond.true.1337:                                   ; preds = %cond.false.1330
  %257 = load i64, i64* %nargs2, align 8
  %conv1338 = trunc i64 %257 to i32
  %add1339 = add nsw i32 0, %conv1338
  %mul1340 = mul nsw i32 0, %add1339
  %add1341 = add nsw i32 %mul1340, 1
  %shl1342 = shl i32 %add1341, 30
  %sub1343 = sub nsw i32 %shl1342, 1
  %mul1344 = mul nsw i32 %sub1343, 2
  %add1345 = add nsw i32 %mul1344, 1
  br label %cond.end.1351

cond.false.1346:                                  ; preds = %cond.false.1330
  %258 = load i64, i64* %nargs2, align 8
  %conv1347 = trunc i64 %258 to i32
  %add1348 = add nsw i32 0, %conv1347
  %mul1349 = mul nsw i32 0, %add1348
  %sub1350 = sub nsw i32 %mul1349, 1
  br label %cond.end.1351

cond.end.1351:                                    ; preds = %cond.false.1346, %cond.true.1337
  %cond1352 = phi i32 [ %add1345, %cond.true.1337 ], [ %sub1350, %cond.false.1346 ]
  %div1353 = sdiv i32 %cond1352, 8
  %259 = load i64, i64* %nargs2, align 8
  %conv1354 = trunc i64 %259 to i32
  %cmp1355 = icmp slt i32 %div1353, %conv1354
  br i1 %cmp1355, label %cond.true.1374, label %lor.lhs.false.1357

lor.lhs.false.1357:                               ; preds = %cond.end.1351, %cond.end.1325, %cond.true.1289, %cond.end.1282, %cond.true.1251, %cond.end.1245
  %260 = load i64, i64* %nargs2, align 8
  %conv1358 = trunc i64 %260 to i32
  %mul1359 = mul nsw i32 %conv1358, 8
  %mul1360 = mul nsw i32 0, %mul1359
  %sub1361 = sub nsw i32 %mul1360, 1
  %cmp1362 = icmp slt i32 %sub1361, 0
  br i1 %cmp1362, label %land.lhs.true.1364, label %lor.lhs.false.1369

land.lhs.true.1364:                               ; preds = %lor.lhs.false.1357
  %261 = load i64, i64* %nargs2, align 8
  %conv1365 = trunc i64 %261 to i32
  %mul1366 = mul nsw i32 %conv1365, 8
  %cmp1367 = icmp slt i32 %mul1366, -2147483648
  br i1 %cmp1367, label %cond.true.1374, label %lor.lhs.false.1369

lor.lhs.false.1369:                               ; preds = %land.lhs.true.1364, %lor.lhs.false.1357
  %262 = load i64, i64* %nargs2, align 8
  %conv1370 = trunc i64 %262 to i32
  %mul1371 = mul nsw i32 %conv1370, 8
  %cmp1372 = icmp slt i32 2147483647, %mul1371
  br i1 %cmp1372, label %cond.true.1374, label %cond.false.1390

cond.true.1374:                                   ; preds = %lor.lhs.false.1369, %land.lhs.true.1364, %cond.end.1351, %cond.end.1325, %cond.true.1289, %cond.end.1282, %cond.true.1251, %cond.end.1245, %land.lhs.true.1214
  %263 = load i64, i64* %nargs2, align 8
  %conv1375 = trunc i64 %263 to i32
  %mul1376 = mul i32 %conv1375, 8
  %cmp1377 = icmp ule i32 %mul1376, 2147483647
  br i1 %cmp1377, label %cond.true.1379, label %cond.false.1382

cond.true.1379:                                   ; preds = %cond.true.1374
  %264 = load i64, i64* %nargs2, align 8
  %conv1380 = trunc i64 %264 to i32
  %mul1381 = mul i32 %conv1380, 8
  br label %cond.end.1387

cond.false.1382:                                  ; preds = %cond.true.1374
  %265 = load i64, i64* %nargs2, align 8
  %conv1383 = trunc i64 %265 to i32
  %mul1384 = mul i32 %conv1383, 8
  %sub1385 = sub i32 %mul1384, -2147483648
  %add1386 = add nsw i32 %sub1385, -2147483648
  br label %cond.end.1387

cond.end.1387:                                    ; preds = %cond.false.1382, %cond.true.1379
  %cond1388 = phi i32 [ %mul1381, %cond.true.1379 ], [ %add1386, %cond.false.1382 ]
  %conv1389 = sext i32 %cond1388 to i64
  store i64 %conv1389, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1390:                                  ; preds = %lor.lhs.false.1369
  %266 = load i64, i64* %nargs2, align 8
  %conv1391 = trunc i64 %266 to i32
  %mul1392 = mul i32 %conv1391, 8
  %cmp1393 = icmp ule i32 %mul1392, 2147483647
  br i1 %cmp1393, label %cond.true.1395, label %cond.false.1398

cond.true.1395:                                   ; preds = %cond.false.1390
  %267 = load i64, i64* %nargs2, align 8
  %conv1396 = trunc i64 %267 to i32
  %mul1397 = mul i32 %conv1396, 8
  br label %cond.end.1403

cond.false.1398:                                  ; preds = %cond.false.1390
  %268 = load i64, i64* %nargs2, align 8
  %conv1399 = trunc i64 %268 to i32
  %mul1400 = mul i32 %conv1399, 8
  %sub1401 = sub i32 %mul1400, -2147483648
  %add1402 = add nsw i32 %sub1401, -2147483648
  br label %cond.end.1403

cond.end.1403:                                    ; preds = %cond.false.1398, %cond.true.1395
  %cond1404 = phi i32 [ %mul1397, %cond.true.1395 ], [ %add1402, %cond.false.1398 ]
  %conv1405 = sext i32 %cond1404 to i64
  store i64 %conv1405, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1406:                                  ; preds = %cond.true.1179
  %269 = load i64, i64* %nargs2, align 8
  %add1407 = add nsw i64 0, %269
  %mul1408 = mul nsw i64 0, %add1407
  %sub1409 = sub nsw i64 %mul1408, 1
  %cmp1410 = icmp slt i64 %sub1409, 0
  br i1 %cmp1410, label %cond.true.1412, label %cond.false.1429

cond.true.1412:                                   ; preds = %cond.false.1406
  %270 = load i64, i64* %nargs2, align 8
  %add1413 = add nsw i64 0, %270
  %mul1414 = mul nsw i64 0, %add1413
  %add1415 = add nsw i64 %mul1414, 0
  %neg1416 = xor i64 %add1415, -1
  %cmp1417 = icmp eq i64 %neg1416, -1
  %conv1418 = zext i1 %cmp1417 to i32
  %sub1419 = sub nsw i32 0, %conv1418
  %conv1420 = sext i32 %sub1419 to i64
  %271 = load i64, i64* %nargs2, align 8
  %add1421 = add nsw i64 0, %271
  %mul1422 = mul nsw i64 0, %add1421
  %add1423 = add nsw i64 %mul1422, 1
  %shl1424 = shl i64 %add1423, 62
  %sub1425 = sub nsw i64 %shl1424, 1
  %mul1426 = mul nsw i64 %sub1425, 2
  %add1427 = add nsw i64 %mul1426, 1
  %sub1428 = sub nsw i64 %conv1420, %add1427
  br label %cond.end.1433

cond.false.1429:                                  ; preds = %cond.false.1406
  %272 = load i64, i64* %nargs2, align 8
  %add1430 = add nsw i64 0, %272
  %mul1431 = mul nsw i64 0, %add1430
  %add1432 = add nsw i64 %mul1431, 0
  br label %cond.end.1433

cond.end.1433:                                    ; preds = %cond.false.1429, %cond.true.1412
  %cond1434 = phi i64 [ %sub1428, %cond.true.1412 ], [ %add1432, %cond.false.1429 ]
  %cmp1435 = icmp eq i64 %cond1434, 0
  br i1 %cmp1435, label %land.lhs.true.1437, label %lor.lhs.false.1440

land.lhs.true.1437:                               ; preds = %cond.end.1433
  %273 = load i64, i64* %nargs2, align 8
  %cmp1438 = icmp slt i64 %273, 0
  br i1 %cmp1438, label %cond.true.1575, label %lor.lhs.false.1440

lor.lhs.false.1440:                               ; preds = %land.lhs.true.1437, %cond.end.1433
  br i1 false, label %cond.true.1441, label %cond.false.1501

cond.true.1441:                                   ; preds = %lor.lhs.false.1440
  %274 = load i64, i64* %nargs2, align 8
  %cmp1442 = icmp slt i64 %274, 0
  br i1 %cmp1442, label %cond.true.1444, label %cond.false.1467

cond.true.1444:                                   ; preds = %cond.true.1441
  %275 = load i64, i64* %nargs2, align 8
  %276 = load i64, i64* %nargs2, align 8
  %add1445 = add nsw i64 0, %276
  %mul1446 = mul nsw i64 0, %add1445
  %sub1447 = sub nsw i64 %mul1446, 1
  %cmp1448 = icmp slt i64 %sub1447, 0
  br i1 %cmp1448, label %cond.true.1450, label %cond.false.1458

cond.true.1450:                                   ; preds = %cond.true.1444
  %277 = load i64, i64* %nargs2, align 8
  %add1451 = add nsw i64 0, %277
  %mul1452 = mul nsw i64 0, %add1451
  %add1453 = add nsw i64 %mul1452, 1
  %shl1454 = shl i64 %add1453, 62
  %sub1455 = sub nsw i64 %shl1454, 1
  %mul1456 = mul nsw i64 %sub1455, 2
  %add1457 = add nsw i64 %mul1456, 1
  br label %cond.end.1462

cond.false.1458:                                  ; preds = %cond.true.1444
  %278 = load i64, i64* %nargs2, align 8
  %add1459 = add nsw i64 0, %278
  %mul1460 = mul nsw i64 0, %add1459
  %sub1461 = sub nsw i64 %mul1460, 1
  br label %cond.end.1462

cond.end.1462:                                    ; preds = %cond.false.1458, %cond.true.1450
  %cond1463 = phi i64 [ %add1457, %cond.true.1450 ], [ %sub1461, %cond.false.1458 ]
  %div1464 = sdiv i64 %cond1463, 8
  %cmp1465 = icmp slt i64 %275, %div1464
  br i1 %cmp1465, label %cond.true.1575, label %lor.lhs.false.1561

cond.false.1467:                                  ; preds = %cond.true.1441
  br i1 false, label %cond.true.1468, label %cond.false.1469

cond.true.1468:                                   ; preds = %cond.false.1467
  br i1 false, label %cond.true.1575, label %lor.lhs.false.1561

cond.false.1469:                                  ; preds = %cond.false.1467
  %279 = load i64, i64* %nargs2, align 8
  %add1470 = add nsw i64 0, %279
  %mul1471 = mul nsw i64 0, %add1470
  %sub1472 = sub nsw i64 %mul1471, 1
  %cmp1473 = icmp slt i64 %sub1472, 0
  br i1 %cmp1473, label %cond.true.1475, label %cond.false.1492

cond.true.1475:                                   ; preds = %cond.false.1469
  %280 = load i64, i64* %nargs2, align 8
  %add1476 = add nsw i64 0, %280
  %mul1477 = mul nsw i64 0, %add1476
  %add1478 = add nsw i64 %mul1477, 0
  %neg1479 = xor i64 %add1478, -1
  %cmp1480 = icmp eq i64 %neg1479, -1
  %conv1481 = zext i1 %cmp1480 to i32
  %sub1482 = sub nsw i32 0, %conv1481
  %conv1483 = sext i32 %sub1482 to i64
  %281 = load i64, i64* %nargs2, align 8
  %add1484 = add nsw i64 0, %281
  %mul1485 = mul nsw i64 0, %add1484
  %add1486 = add nsw i64 %mul1485, 1
  %shl1487 = shl i64 %add1486, 62
  %sub1488 = sub nsw i64 %shl1487, 1
  %mul1489 = mul nsw i64 %sub1488, 2
  %add1490 = add nsw i64 %mul1489, 1
  %sub1491 = sub nsw i64 %conv1483, %add1490
  br label %cond.end.1496

cond.false.1492:                                  ; preds = %cond.false.1469
  %282 = load i64, i64* %nargs2, align 8
  %add1493 = add nsw i64 0, %282
  %mul1494 = mul nsw i64 0, %add1493
  %add1495 = add nsw i64 %mul1494, 0
  br label %cond.end.1496

cond.end.1496:                                    ; preds = %cond.false.1492, %cond.true.1475
  %cond1497 = phi i64 [ %sub1491, %cond.true.1475 ], [ %add1495, %cond.false.1492 ]
  %div1498 = sdiv i64 %cond1497, 8
  %283 = load i64, i64* %nargs2, align 8
  %cmp1499 = icmp slt i64 %div1498, %283
  br i1 %cmp1499, label %cond.true.1575, label %lor.lhs.false.1561

cond.false.1501:                                  ; preds = %lor.lhs.false.1440
  br i1 false, label %cond.true.1502, label %cond.false.1503

cond.true.1502:                                   ; preds = %cond.false.1501
  br i1 false, label %cond.true.1575, label %lor.lhs.false.1561

cond.false.1503:                                  ; preds = %cond.false.1501
  %284 = load i64, i64* %nargs2, align 8
  %cmp1504 = icmp slt i64 %284, 0
  br i1 %cmp1504, label %cond.true.1506, label %cond.false.1538

cond.true.1506:                                   ; preds = %cond.false.1503
  %285 = load i64, i64* %nargs2, align 8
  %286 = load i64, i64* %nargs2, align 8
  %add1507 = add nsw i64 0, %286
  %mul1508 = mul nsw i64 0, %add1507
  %sub1509 = sub nsw i64 %mul1508, 1
  %cmp1510 = icmp slt i64 %sub1509, 0
  br i1 %cmp1510, label %cond.true.1512, label %cond.false.1529

cond.true.1512:                                   ; preds = %cond.true.1506
  %287 = load i64, i64* %nargs2, align 8
  %add1513 = add nsw i64 0, %287
  %mul1514 = mul nsw i64 0, %add1513
  %add1515 = add nsw i64 %mul1514, 0
  %neg1516 = xor i64 %add1515, -1
  %cmp1517 = icmp eq i64 %neg1516, -1
  %conv1518 = zext i1 %cmp1517 to i32
  %sub1519 = sub nsw i32 0, %conv1518
  %conv1520 = sext i32 %sub1519 to i64
  %288 = load i64, i64* %nargs2, align 8
  %add1521 = add nsw i64 0, %288
  %mul1522 = mul nsw i64 0, %add1521
  %add1523 = add nsw i64 %mul1522, 1
  %shl1524 = shl i64 %add1523, 62
  %sub1525 = sub nsw i64 %shl1524, 1
  %mul1526 = mul nsw i64 %sub1525, 2
  %add1527 = add nsw i64 %mul1526, 1
  %sub1528 = sub nsw i64 %conv1520, %add1527
  br label %cond.end.1533

cond.false.1529:                                  ; preds = %cond.true.1506
  %289 = load i64, i64* %nargs2, align 8
  %add1530 = add nsw i64 0, %289
  %mul1531 = mul nsw i64 0, %add1530
  %add1532 = add nsw i64 %mul1531, 0
  br label %cond.end.1533

cond.end.1533:                                    ; preds = %cond.false.1529, %cond.true.1512
  %cond1534 = phi i64 [ %sub1528, %cond.true.1512 ], [ %add1532, %cond.false.1529 ]
  %div1535 = sdiv i64 %cond1534, 8
  %cmp1536 = icmp slt i64 %285, %div1535
  br i1 %cmp1536, label %cond.true.1575, label %lor.lhs.false.1561

cond.false.1538:                                  ; preds = %cond.false.1503
  %290 = load i64, i64* %nargs2, align 8
  %add1539 = add nsw i64 0, %290
  %mul1540 = mul nsw i64 0, %add1539
  %sub1541 = sub nsw i64 %mul1540, 1
  %cmp1542 = icmp slt i64 %sub1541, 0
  br i1 %cmp1542, label %cond.true.1544, label %cond.false.1552

cond.true.1544:                                   ; preds = %cond.false.1538
  %291 = load i64, i64* %nargs2, align 8
  %add1545 = add nsw i64 0, %291
  %mul1546 = mul nsw i64 0, %add1545
  %add1547 = add nsw i64 %mul1546, 1
  %shl1548 = shl i64 %add1547, 62
  %sub1549 = sub nsw i64 %shl1548, 1
  %mul1550 = mul nsw i64 %sub1549, 2
  %add1551 = add nsw i64 %mul1550, 1
  br label %cond.end.1556

cond.false.1552:                                  ; preds = %cond.false.1538
  %292 = load i64, i64* %nargs2, align 8
  %add1553 = add nsw i64 0, %292
  %mul1554 = mul nsw i64 0, %add1553
  %sub1555 = sub nsw i64 %mul1554, 1
  br label %cond.end.1556

cond.end.1556:                                    ; preds = %cond.false.1552, %cond.true.1544
  %cond1557 = phi i64 [ %add1551, %cond.true.1544 ], [ %sub1555, %cond.false.1552 ]
  %div1558 = sdiv i64 %cond1557, 8
  %293 = load i64, i64* %nargs2, align 8
  %cmp1559 = icmp slt i64 %div1558, %293
  br i1 %cmp1559, label %cond.true.1575, label %lor.lhs.false.1561

lor.lhs.false.1561:                               ; preds = %cond.end.1556, %cond.end.1533, %cond.true.1502, %cond.end.1496, %cond.true.1468, %cond.end.1462
  %294 = load i64, i64* %nargs2, align 8
  %mul1562 = mul nsw i64 %294, 8
  %mul1563 = mul nsw i64 0, %mul1562
  %sub1564 = sub nsw i64 %mul1563, 1
  %cmp1565 = icmp slt i64 %sub1564, 0
  br i1 %cmp1565, label %land.lhs.true.1567, label %lor.lhs.false.1571

land.lhs.true.1567:                               ; preds = %lor.lhs.false.1561
  %295 = load i64, i64* %nargs2, align 8
  %mul1568 = mul nsw i64 %295, 8
  %cmp1569 = icmp slt i64 %mul1568, -2147483648
  br i1 %cmp1569, label %cond.true.1575, label %lor.lhs.false.1571

lor.lhs.false.1571:                               ; preds = %land.lhs.true.1567, %lor.lhs.false.1561
  %296 = load i64, i64* %nargs2, align 8
  %mul1572 = mul nsw i64 %296, 8
  %cmp1573 = icmp slt i64 2147483647, %mul1572
  br i1 %cmp1573, label %cond.true.1575, label %cond.false.1591

cond.true.1575:                                   ; preds = %lor.lhs.false.1571, %land.lhs.true.1567, %cond.end.1556, %cond.end.1533, %cond.true.1502, %cond.end.1496, %cond.true.1468, %cond.end.1462, %land.lhs.true.1437
  %297 = load i64, i64* %nargs2, align 8
  %conv1576 = trunc i64 %297 to i32
  %mul1577 = mul i32 %conv1576, 8
  %cmp1578 = icmp ule i32 %mul1577, 2147483647
  br i1 %cmp1578, label %cond.true.1580, label %cond.false.1583

cond.true.1580:                                   ; preds = %cond.true.1575
  %298 = load i64, i64* %nargs2, align 8
  %conv1581 = trunc i64 %298 to i32
  %mul1582 = mul i32 %conv1581, 8
  br label %cond.end.1588

cond.false.1583:                                  ; preds = %cond.true.1575
  %299 = load i64, i64* %nargs2, align 8
  %conv1584 = trunc i64 %299 to i32
  %mul1585 = mul i32 %conv1584, 8
  %sub1586 = sub i32 %mul1585, -2147483648
  %add1587 = add nsw i32 %sub1586, -2147483648
  br label %cond.end.1588

cond.end.1588:                                    ; preds = %cond.false.1583, %cond.true.1580
  %cond1589 = phi i32 [ %mul1582, %cond.true.1580 ], [ %add1587, %cond.false.1583 ]
  %conv1590 = sext i32 %cond1589 to i64
  store i64 %conv1590, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1591:                                  ; preds = %lor.lhs.false.1571
  %300 = load i64, i64* %nargs2, align 8
  %conv1592 = trunc i64 %300 to i32
  %mul1593 = mul i32 %conv1592, 8
  %cmp1594 = icmp ule i32 %mul1593, 2147483647
  br i1 %cmp1594, label %cond.true.1596, label %cond.false.1599

cond.true.1596:                                   ; preds = %cond.false.1591
  %301 = load i64, i64* %nargs2, align 8
  %conv1597 = trunc i64 %301 to i32
  %mul1598 = mul i32 %conv1597, 8
  br label %cond.end.1604

cond.false.1599:                                  ; preds = %cond.false.1591
  %302 = load i64, i64* %nargs2, align 8
  %conv1600 = trunc i64 %302 to i32
  %mul1601 = mul i32 %conv1600, 8
  %sub1602 = sub i32 %mul1601, -2147483648
  %add1603 = add nsw i32 %sub1602, -2147483648
  br label %cond.end.1604

cond.end.1604:                                    ; preds = %cond.false.1599, %cond.true.1596
  %cond1605 = phi i32 [ %mul1598, %cond.true.1596 ], [ %add1603, %cond.false.1599 ]
  %conv1606 = sext i32 %cond1605 to i64
  store i64 %conv1606, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1607:                                  ; preds = %cond.false.1178
  br i1 true, label %cond.true.1608, label %cond.false.1995

cond.true.1608:                                   ; preds = %cond.false.1607
  br i1 false, label %cond.true.1609, label %cond.false.1802

cond.true.1609:                                   ; preds = %cond.true.1608
  %303 = load i64, i64* %nargs2, align 8
  %add1610 = add nsw i64 0, %303
  %mul1611 = mul nsw i64 0, %add1610
  %sub1612 = sub nsw i64 %mul1611, 1
  %cmp1613 = icmp slt i64 %sub1612, 0
  br i1 %cmp1613, label %cond.true.1615, label %cond.false.1632

cond.true.1615:                                   ; preds = %cond.true.1609
  %304 = load i64, i64* %nargs2, align 8
  %add1616 = add nsw i64 0, %304
  %mul1617 = mul nsw i64 0, %add1616
  %add1618 = add nsw i64 %mul1617, 0
  %neg1619 = xor i64 %add1618, -1
  %cmp1620 = icmp eq i64 %neg1619, -1
  %conv1621 = zext i1 %cmp1620 to i32
  %sub1622 = sub nsw i32 0, %conv1621
  %conv1623 = sext i32 %sub1622 to i64
  %305 = load i64, i64* %nargs2, align 8
  %add1624 = add nsw i64 0, %305
  %mul1625 = mul nsw i64 0, %add1624
  %add1626 = add nsw i64 %mul1625, 1
  %shl1627 = shl i64 %add1626, 62
  %sub1628 = sub nsw i64 %shl1627, 1
  %mul1629 = mul nsw i64 %sub1628, 2
  %add1630 = add nsw i64 %mul1629, 1
  %sub1631 = sub nsw i64 %conv1623, %add1630
  br label %cond.end.1636

cond.false.1632:                                  ; preds = %cond.true.1609
  %306 = load i64, i64* %nargs2, align 8
  %add1633 = add nsw i64 0, %306
  %mul1634 = mul nsw i64 0, %add1633
  %add1635 = add nsw i64 %mul1634, 0
  br label %cond.end.1636

cond.end.1636:                                    ; preds = %cond.false.1632, %cond.true.1615
  %cond1637 = phi i64 [ %sub1631, %cond.true.1615 ], [ %add1635, %cond.false.1632 ]
  %cmp1638 = icmp eq i64 %cond1637, 0
  br i1 %cmp1638, label %land.lhs.true.1640, label %lor.lhs.false.1643

land.lhs.true.1640:                               ; preds = %cond.end.1636
  %307 = load i64, i64* %nargs2, align 8
  %cmp1641 = icmp slt i64 %307, 0
  br i1 %cmp1641, label %cond.true.1778, label %lor.lhs.false.1643

lor.lhs.false.1643:                               ; preds = %land.lhs.true.1640, %cond.end.1636
  br i1 false, label %cond.true.1644, label %cond.false.1704

cond.true.1644:                                   ; preds = %lor.lhs.false.1643
  %308 = load i64, i64* %nargs2, align 8
  %cmp1645 = icmp slt i64 %308, 0
  br i1 %cmp1645, label %cond.true.1647, label %cond.false.1670

cond.true.1647:                                   ; preds = %cond.true.1644
  %309 = load i64, i64* %nargs2, align 8
  %310 = load i64, i64* %nargs2, align 8
  %add1648 = add nsw i64 0, %310
  %mul1649 = mul nsw i64 0, %add1648
  %sub1650 = sub nsw i64 %mul1649, 1
  %cmp1651 = icmp slt i64 %sub1650, 0
  br i1 %cmp1651, label %cond.true.1653, label %cond.false.1661

cond.true.1653:                                   ; preds = %cond.true.1647
  %311 = load i64, i64* %nargs2, align 8
  %add1654 = add nsw i64 0, %311
  %mul1655 = mul nsw i64 0, %add1654
  %add1656 = add nsw i64 %mul1655, 1
  %shl1657 = shl i64 %add1656, 62
  %sub1658 = sub nsw i64 %shl1657, 1
  %mul1659 = mul nsw i64 %sub1658, 2
  %add1660 = add nsw i64 %mul1659, 1
  br label %cond.end.1665

cond.false.1661:                                  ; preds = %cond.true.1647
  %312 = load i64, i64* %nargs2, align 8
  %add1662 = add nsw i64 0, %312
  %mul1663 = mul nsw i64 0, %add1662
  %sub1664 = sub nsw i64 %mul1663, 1
  br label %cond.end.1665

cond.end.1665:                                    ; preds = %cond.false.1661, %cond.true.1653
  %cond1666 = phi i64 [ %add1660, %cond.true.1653 ], [ %sub1664, %cond.false.1661 ]
  %div1667 = sdiv i64 %cond1666, 8
  %cmp1668 = icmp slt i64 %309, %div1667
  br i1 %cmp1668, label %cond.true.1778, label %lor.lhs.false.1764

cond.false.1670:                                  ; preds = %cond.true.1644
  br i1 false, label %cond.true.1671, label %cond.false.1672

cond.true.1671:                                   ; preds = %cond.false.1670
  br i1 false, label %cond.true.1778, label %lor.lhs.false.1764

cond.false.1672:                                  ; preds = %cond.false.1670
  %313 = load i64, i64* %nargs2, align 8
  %add1673 = add nsw i64 0, %313
  %mul1674 = mul nsw i64 0, %add1673
  %sub1675 = sub nsw i64 %mul1674, 1
  %cmp1676 = icmp slt i64 %sub1675, 0
  br i1 %cmp1676, label %cond.true.1678, label %cond.false.1695

cond.true.1678:                                   ; preds = %cond.false.1672
  %314 = load i64, i64* %nargs2, align 8
  %add1679 = add nsw i64 0, %314
  %mul1680 = mul nsw i64 0, %add1679
  %add1681 = add nsw i64 %mul1680, 0
  %neg1682 = xor i64 %add1681, -1
  %cmp1683 = icmp eq i64 %neg1682, -1
  %conv1684 = zext i1 %cmp1683 to i32
  %sub1685 = sub nsw i32 0, %conv1684
  %conv1686 = sext i32 %sub1685 to i64
  %315 = load i64, i64* %nargs2, align 8
  %add1687 = add nsw i64 0, %315
  %mul1688 = mul nsw i64 0, %add1687
  %add1689 = add nsw i64 %mul1688, 1
  %shl1690 = shl i64 %add1689, 62
  %sub1691 = sub nsw i64 %shl1690, 1
  %mul1692 = mul nsw i64 %sub1691, 2
  %add1693 = add nsw i64 %mul1692, 1
  %sub1694 = sub nsw i64 %conv1686, %add1693
  br label %cond.end.1699

cond.false.1695:                                  ; preds = %cond.false.1672
  %316 = load i64, i64* %nargs2, align 8
  %add1696 = add nsw i64 0, %316
  %mul1697 = mul nsw i64 0, %add1696
  %add1698 = add nsw i64 %mul1697, 0
  br label %cond.end.1699

cond.end.1699:                                    ; preds = %cond.false.1695, %cond.true.1678
  %cond1700 = phi i64 [ %sub1694, %cond.true.1678 ], [ %add1698, %cond.false.1695 ]
  %div1701 = sdiv i64 %cond1700, 8
  %317 = load i64, i64* %nargs2, align 8
  %cmp1702 = icmp slt i64 %div1701, %317
  br i1 %cmp1702, label %cond.true.1778, label %lor.lhs.false.1764

cond.false.1704:                                  ; preds = %lor.lhs.false.1643
  br i1 false, label %cond.true.1705, label %cond.false.1706

cond.true.1705:                                   ; preds = %cond.false.1704
  br i1 false, label %cond.true.1778, label %lor.lhs.false.1764

cond.false.1706:                                  ; preds = %cond.false.1704
  %318 = load i64, i64* %nargs2, align 8
  %cmp1707 = icmp slt i64 %318, 0
  br i1 %cmp1707, label %cond.true.1709, label %cond.false.1741

cond.true.1709:                                   ; preds = %cond.false.1706
  %319 = load i64, i64* %nargs2, align 8
  %320 = load i64, i64* %nargs2, align 8
  %add1710 = add nsw i64 0, %320
  %mul1711 = mul nsw i64 0, %add1710
  %sub1712 = sub nsw i64 %mul1711, 1
  %cmp1713 = icmp slt i64 %sub1712, 0
  br i1 %cmp1713, label %cond.true.1715, label %cond.false.1732

cond.true.1715:                                   ; preds = %cond.true.1709
  %321 = load i64, i64* %nargs2, align 8
  %add1716 = add nsw i64 0, %321
  %mul1717 = mul nsw i64 0, %add1716
  %add1718 = add nsw i64 %mul1717, 0
  %neg1719 = xor i64 %add1718, -1
  %cmp1720 = icmp eq i64 %neg1719, -1
  %conv1721 = zext i1 %cmp1720 to i32
  %sub1722 = sub nsw i32 0, %conv1721
  %conv1723 = sext i32 %sub1722 to i64
  %322 = load i64, i64* %nargs2, align 8
  %add1724 = add nsw i64 0, %322
  %mul1725 = mul nsw i64 0, %add1724
  %add1726 = add nsw i64 %mul1725, 1
  %shl1727 = shl i64 %add1726, 62
  %sub1728 = sub nsw i64 %shl1727, 1
  %mul1729 = mul nsw i64 %sub1728, 2
  %add1730 = add nsw i64 %mul1729, 1
  %sub1731 = sub nsw i64 %conv1723, %add1730
  br label %cond.end.1736

cond.false.1732:                                  ; preds = %cond.true.1709
  %323 = load i64, i64* %nargs2, align 8
  %add1733 = add nsw i64 0, %323
  %mul1734 = mul nsw i64 0, %add1733
  %add1735 = add nsw i64 %mul1734, 0
  br label %cond.end.1736

cond.end.1736:                                    ; preds = %cond.false.1732, %cond.true.1715
  %cond1737 = phi i64 [ %sub1731, %cond.true.1715 ], [ %add1735, %cond.false.1732 ]
  %div1738 = sdiv i64 %cond1737, 8
  %cmp1739 = icmp slt i64 %319, %div1738
  br i1 %cmp1739, label %cond.true.1778, label %lor.lhs.false.1764

cond.false.1741:                                  ; preds = %cond.false.1706
  %324 = load i64, i64* %nargs2, align 8
  %add1742 = add nsw i64 0, %324
  %mul1743 = mul nsw i64 0, %add1742
  %sub1744 = sub nsw i64 %mul1743, 1
  %cmp1745 = icmp slt i64 %sub1744, 0
  br i1 %cmp1745, label %cond.true.1747, label %cond.false.1755

cond.true.1747:                                   ; preds = %cond.false.1741
  %325 = load i64, i64* %nargs2, align 8
  %add1748 = add nsw i64 0, %325
  %mul1749 = mul nsw i64 0, %add1748
  %add1750 = add nsw i64 %mul1749, 1
  %shl1751 = shl i64 %add1750, 62
  %sub1752 = sub nsw i64 %shl1751, 1
  %mul1753 = mul nsw i64 %sub1752, 2
  %add1754 = add nsw i64 %mul1753, 1
  br label %cond.end.1759

cond.false.1755:                                  ; preds = %cond.false.1741
  %326 = load i64, i64* %nargs2, align 8
  %add1756 = add nsw i64 0, %326
  %mul1757 = mul nsw i64 0, %add1756
  %sub1758 = sub nsw i64 %mul1757, 1
  br label %cond.end.1759

cond.end.1759:                                    ; preds = %cond.false.1755, %cond.true.1747
  %cond1760 = phi i64 [ %add1754, %cond.true.1747 ], [ %sub1758, %cond.false.1755 ]
  %div1761 = sdiv i64 %cond1760, 8
  %327 = load i64, i64* %nargs2, align 8
  %cmp1762 = icmp slt i64 %div1761, %327
  br i1 %cmp1762, label %cond.true.1778, label %lor.lhs.false.1764

lor.lhs.false.1764:                               ; preds = %cond.end.1759, %cond.end.1736, %cond.true.1705, %cond.end.1699, %cond.true.1671, %cond.end.1665
  %328 = load i64, i64* %nargs2, align 8
  %mul1765 = mul nsw i64 %328, 8
  %mul1766 = mul nsw i64 0, %mul1765
  %sub1767 = sub nsw i64 %mul1766, 1
  %cmp1768 = icmp slt i64 %sub1767, 0
  br i1 %cmp1768, label %land.lhs.true.1770, label %lor.lhs.false.1774

land.lhs.true.1770:                               ; preds = %lor.lhs.false.1764
  %329 = load i64, i64* %nargs2, align 8
  %mul1771 = mul nsw i64 %329, 8
  %cmp1772 = icmp slt i64 %mul1771, -9223372036854775808
  br i1 %cmp1772, label %cond.true.1778, label %lor.lhs.false.1774

lor.lhs.false.1774:                               ; preds = %land.lhs.true.1770, %lor.lhs.false.1764
  %330 = load i64, i64* %nargs2, align 8
  %mul1775 = mul nsw i64 %330, 8
  %cmp1776 = icmp slt i64 9223372036854775807, %mul1775
  br i1 %cmp1776, label %cond.true.1778, label %cond.false.1790

cond.true.1778:                                   ; preds = %lor.lhs.false.1774, %land.lhs.true.1770, %cond.end.1759, %cond.end.1736, %cond.true.1705, %cond.end.1699, %cond.true.1671, %cond.end.1665, %land.lhs.true.1640
  %331 = load i64, i64* %nargs2, align 8
  %mul1779 = mul i64 %331, 8
  %cmp1780 = icmp ule i64 %mul1779, 9223372036854775807
  br i1 %cmp1780, label %cond.true.1782, label %cond.false.1784

cond.true.1782:                                   ; preds = %cond.true.1778
  %332 = load i64, i64* %nargs2, align 8
  %mul1783 = mul i64 %332, 8
  br label %cond.end.1788

cond.false.1784:                                  ; preds = %cond.true.1778
  %333 = load i64, i64* %nargs2, align 8
  %mul1785 = mul i64 %333, 8
  %sub1786 = sub i64 %mul1785, -9223372036854775808
  %add1787 = add nsw i64 %sub1786, -9223372036854775808
  br label %cond.end.1788

cond.end.1788:                                    ; preds = %cond.false.1784, %cond.true.1782
  %cond1789 = phi i64 [ %mul1783, %cond.true.1782 ], [ %add1787, %cond.false.1784 ]
  store i64 %cond1789, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1790:                                  ; preds = %lor.lhs.false.1774
  %334 = load i64, i64* %nargs2, align 8
  %mul1791 = mul i64 %334, 8
  %cmp1792 = icmp ule i64 %mul1791, 9223372036854775807
  br i1 %cmp1792, label %cond.true.1794, label %cond.false.1796

cond.true.1794:                                   ; preds = %cond.false.1790
  %335 = load i64, i64* %nargs2, align 8
  %mul1795 = mul i64 %335, 8
  br label %cond.end.1800

cond.false.1796:                                  ; preds = %cond.false.1790
  %336 = load i64, i64* %nargs2, align 8
  %mul1797 = mul i64 %336, 8
  %sub1798 = sub i64 %mul1797, -9223372036854775808
  %add1799 = add nsw i64 %sub1798, -9223372036854775808
  br label %cond.end.1800

cond.end.1800:                                    ; preds = %cond.false.1796, %cond.true.1794
  %cond1801 = phi i64 [ %mul1795, %cond.true.1794 ], [ %add1799, %cond.false.1796 ]
  store i64 %cond1801, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1802:                                  ; preds = %cond.true.1608
  %337 = load i64, i64* %nargs2, align 8
  %add1803 = add nsw i64 0, %337
  %mul1804 = mul nsw i64 0, %add1803
  %sub1805 = sub nsw i64 %mul1804, 1
  %cmp1806 = icmp slt i64 %sub1805, 0
  br i1 %cmp1806, label %cond.true.1808, label %cond.false.1825

cond.true.1808:                                   ; preds = %cond.false.1802
  %338 = load i64, i64* %nargs2, align 8
  %add1809 = add nsw i64 0, %338
  %mul1810 = mul nsw i64 0, %add1809
  %add1811 = add nsw i64 %mul1810, 0
  %neg1812 = xor i64 %add1811, -1
  %cmp1813 = icmp eq i64 %neg1812, -1
  %conv1814 = zext i1 %cmp1813 to i32
  %sub1815 = sub nsw i32 0, %conv1814
  %conv1816 = sext i32 %sub1815 to i64
  %339 = load i64, i64* %nargs2, align 8
  %add1817 = add nsw i64 0, %339
  %mul1818 = mul nsw i64 0, %add1817
  %add1819 = add nsw i64 %mul1818, 1
  %shl1820 = shl i64 %add1819, 62
  %sub1821 = sub nsw i64 %shl1820, 1
  %mul1822 = mul nsw i64 %sub1821, 2
  %add1823 = add nsw i64 %mul1822, 1
  %sub1824 = sub nsw i64 %conv1816, %add1823
  br label %cond.end.1829

cond.false.1825:                                  ; preds = %cond.false.1802
  %340 = load i64, i64* %nargs2, align 8
  %add1826 = add nsw i64 0, %340
  %mul1827 = mul nsw i64 0, %add1826
  %add1828 = add nsw i64 %mul1827, 0
  br label %cond.end.1829

cond.end.1829:                                    ; preds = %cond.false.1825, %cond.true.1808
  %cond1830 = phi i64 [ %sub1824, %cond.true.1808 ], [ %add1828, %cond.false.1825 ]
  %cmp1831 = icmp eq i64 %cond1830, 0
  br i1 %cmp1831, label %land.lhs.true.1833, label %lor.lhs.false.1836

land.lhs.true.1833:                               ; preds = %cond.end.1829
  %341 = load i64, i64* %nargs2, align 8
  %cmp1834 = icmp slt i64 %341, 0
  br i1 %cmp1834, label %cond.true.1971, label %lor.lhs.false.1836

lor.lhs.false.1836:                               ; preds = %land.lhs.true.1833, %cond.end.1829
  br i1 false, label %cond.true.1837, label %cond.false.1897

cond.true.1837:                                   ; preds = %lor.lhs.false.1836
  %342 = load i64, i64* %nargs2, align 8
  %cmp1838 = icmp slt i64 %342, 0
  br i1 %cmp1838, label %cond.true.1840, label %cond.false.1863

cond.true.1840:                                   ; preds = %cond.true.1837
  %343 = load i64, i64* %nargs2, align 8
  %344 = load i64, i64* %nargs2, align 8
  %add1841 = add nsw i64 0, %344
  %mul1842 = mul nsw i64 0, %add1841
  %sub1843 = sub nsw i64 %mul1842, 1
  %cmp1844 = icmp slt i64 %sub1843, 0
  br i1 %cmp1844, label %cond.true.1846, label %cond.false.1854

cond.true.1846:                                   ; preds = %cond.true.1840
  %345 = load i64, i64* %nargs2, align 8
  %add1847 = add nsw i64 0, %345
  %mul1848 = mul nsw i64 0, %add1847
  %add1849 = add nsw i64 %mul1848, 1
  %shl1850 = shl i64 %add1849, 62
  %sub1851 = sub nsw i64 %shl1850, 1
  %mul1852 = mul nsw i64 %sub1851, 2
  %add1853 = add nsw i64 %mul1852, 1
  br label %cond.end.1858

cond.false.1854:                                  ; preds = %cond.true.1840
  %346 = load i64, i64* %nargs2, align 8
  %add1855 = add nsw i64 0, %346
  %mul1856 = mul nsw i64 0, %add1855
  %sub1857 = sub nsw i64 %mul1856, 1
  br label %cond.end.1858

cond.end.1858:                                    ; preds = %cond.false.1854, %cond.true.1846
  %cond1859 = phi i64 [ %add1853, %cond.true.1846 ], [ %sub1857, %cond.false.1854 ]
  %div1860 = sdiv i64 %cond1859, 8
  %cmp1861 = icmp slt i64 %343, %div1860
  br i1 %cmp1861, label %cond.true.1971, label %lor.lhs.false.1957

cond.false.1863:                                  ; preds = %cond.true.1837
  br i1 false, label %cond.true.1864, label %cond.false.1865

cond.true.1864:                                   ; preds = %cond.false.1863
  br i1 false, label %cond.true.1971, label %lor.lhs.false.1957

cond.false.1865:                                  ; preds = %cond.false.1863
  %347 = load i64, i64* %nargs2, align 8
  %add1866 = add nsw i64 0, %347
  %mul1867 = mul nsw i64 0, %add1866
  %sub1868 = sub nsw i64 %mul1867, 1
  %cmp1869 = icmp slt i64 %sub1868, 0
  br i1 %cmp1869, label %cond.true.1871, label %cond.false.1888

cond.true.1871:                                   ; preds = %cond.false.1865
  %348 = load i64, i64* %nargs2, align 8
  %add1872 = add nsw i64 0, %348
  %mul1873 = mul nsw i64 0, %add1872
  %add1874 = add nsw i64 %mul1873, 0
  %neg1875 = xor i64 %add1874, -1
  %cmp1876 = icmp eq i64 %neg1875, -1
  %conv1877 = zext i1 %cmp1876 to i32
  %sub1878 = sub nsw i32 0, %conv1877
  %conv1879 = sext i32 %sub1878 to i64
  %349 = load i64, i64* %nargs2, align 8
  %add1880 = add nsw i64 0, %349
  %mul1881 = mul nsw i64 0, %add1880
  %add1882 = add nsw i64 %mul1881, 1
  %shl1883 = shl i64 %add1882, 62
  %sub1884 = sub nsw i64 %shl1883, 1
  %mul1885 = mul nsw i64 %sub1884, 2
  %add1886 = add nsw i64 %mul1885, 1
  %sub1887 = sub nsw i64 %conv1879, %add1886
  br label %cond.end.1892

cond.false.1888:                                  ; preds = %cond.false.1865
  %350 = load i64, i64* %nargs2, align 8
  %add1889 = add nsw i64 0, %350
  %mul1890 = mul nsw i64 0, %add1889
  %add1891 = add nsw i64 %mul1890, 0
  br label %cond.end.1892

cond.end.1892:                                    ; preds = %cond.false.1888, %cond.true.1871
  %cond1893 = phi i64 [ %sub1887, %cond.true.1871 ], [ %add1891, %cond.false.1888 ]
  %div1894 = sdiv i64 %cond1893, 8
  %351 = load i64, i64* %nargs2, align 8
  %cmp1895 = icmp slt i64 %div1894, %351
  br i1 %cmp1895, label %cond.true.1971, label %lor.lhs.false.1957

cond.false.1897:                                  ; preds = %lor.lhs.false.1836
  br i1 false, label %cond.true.1898, label %cond.false.1899

cond.true.1898:                                   ; preds = %cond.false.1897
  br i1 false, label %cond.true.1971, label %lor.lhs.false.1957

cond.false.1899:                                  ; preds = %cond.false.1897
  %352 = load i64, i64* %nargs2, align 8
  %cmp1900 = icmp slt i64 %352, 0
  br i1 %cmp1900, label %cond.true.1902, label %cond.false.1934

cond.true.1902:                                   ; preds = %cond.false.1899
  %353 = load i64, i64* %nargs2, align 8
  %354 = load i64, i64* %nargs2, align 8
  %add1903 = add nsw i64 0, %354
  %mul1904 = mul nsw i64 0, %add1903
  %sub1905 = sub nsw i64 %mul1904, 1
  %cmp1906 = icmp slt i64 %sub1905, 0
  br i1 %cmp1906, label %cond.true.1908, label %cond.false.1925

cond.true.1908:                                   ; preds = %cond.true.1902
  %355 = load i64, i64* %nargs2, align 8
  %add1909 = add nsw i64 0, %355
  %mul1910 = mul nsw i64 0, %add1909
  %add1911 = add nsw i64 %mul1910, 0
  %neg1912 = xor i64 %add1911, -1
  %cmp1913 = icmp eq i64 %neg1912, -1
  %conv1914 = zext i1 %cmp1913 to i32
  %sub1915 = sub nsw i32 0, %conv1914
  %conv1916 = sext i32 %sub1915 to i64
  %356 = load i64, i64* %nargs2, align 8
  %add1917 = add nsw i64 0, %356
  %mul1918 = mul nsw i64 0, %add1917
  %add1919 = add nsw i64 %mul1918, 1
  %shl1920 = shl i64 %add1919, 62
  %sub1921 = sub nsw i64 %shl1920, 1
  %mul1922 = mul nsw i64 %sub1921, 2
  %add1923 = add nsw i64 %mul1922, 1
  %sub1924 = sub nsw i64 %conv1916, %add1923
  br label %cond.end.1929

cond.false.1925:                                  ; preds = %cond.true.1902
  %357 = load i64, i64* %nargs2, align 8
  %add1926 = add nsw i64 0, %357
  %mul1927 = mul nsw i64 0, %add1926
  %add1928 = add nsw i64 %mul1927, 0
  br label %cond.end.1929

cond.end.1929:                                    ; preds = %cond.false.1925, %cond.true.1908
  %cond1930 = phi i64 [ %sub1924, %cond.true.1908 ], [ %add1928, %cond.false.1925 ]
  %div1931 = sdiv i64 %cond1930, 8
  %cmp1932 = icmp slt i64 %353, %div1931
  br i1 %cmp1932, label %cond.true.1971, label %lor.lhs.false.1957

cond.false.1934:                                  ; preds = %cond.false.1899
  %358 = load i64, i64* %nargs2, align 8
  %add1935 = add nsw i64 0, %358
  %mul1936 = mul nsw i64 0, %add1935
  %sub1937 = sub nsw i64 %mul1936, 1
  %cmp1938 = icmp slt i64 %sub1937, 0
  br i1 %cmp1938, label %cond.true.1940, label %cond.false.1948

cond.true.1940:                                   ; preds = %cond.false.1934
  %359 = load i64, i64* %nargs2, align 8
  %add1941 = add nsw i64 0, %359
  %mul1942 = mul nsw i64 0, %add1941
  %add1943 = add nsw i64 %mul1942, 1
  %shl1944 = shl i64 %add1943, 62
  %sub1945 = sub nsw i64 %shl1944, 1
  %mul1946 = mul nsw i64 %sub1945, 2
  %add1947 = add nsw i64 %mul1946, 1
  br label %cond.end.1952

cond.false.1948:                                  ; preds = %cond.false.1934
  %360 = load i64, i64* %nargs2, align 8
  %add1949 = add nsw i64 0, %360
  %mul1950 = mul nsw i64 0, %add1949
  %sub1951 = sub nsw i64 %mul1950, 1
  br label %cond.end.1952

cond.end.1952:                                    ; preds = %cond.false.1948, %cond.true.1940
  %cond1953 = phi i64 [ %add1947, %cond.true.1940 ], [ %sub1951, %cond.false.1948 ]
  %div1954 = sdiv i64 %cond1953, 8
  %361 = load i64, i64* %nargs2, align 8
  %cmp1955 = icmp slt i64 %div1954, %361
  br i1 %cmp1955, label %cond.true.1971, label %lor.lhs.false.1957

lor.lhs.false.1957:                               ; preds = %cond.end.1952, %cond.end.1929, %cond.true.1898, %cond.end.1892, %cond.true.1864, %cond.end.1858
  %362 = load i64, i64* %nargs2, align 8
  %mul1958 = mul nsw i64 %362, 8
  %mul1959 = mul nsw i64 0, %mul1958
  %sub1960 = sub nsw i64 %mul1959, 1
  %cmp1961 = icmp slt i64 %sub1960, 0
  br i1 %cmp1961, label %land.lhs.true.1963, label %lor.lhs.false.1967

land.lhs.true.1963:                               ; preds = %lor.lhs.false.1957
  %363 = load i64, i64* %nargs2, align 8
  %mul1964 = mul nsw i64 %363, 8
  %cmp1965 = icmp slt i64 %mul1964, -9223372036854775808
  br i1 %cmp1965, label %cond.true.1971, label %lor.lhs.false.1967

lor.lhs.false.1967:                               ; preds = %land.lhs.true.1963, %lor.lhs.false.1957
  %364 = load i64, i64* %nargs2, align 8
  %mul1968 = mul nsw i64 %364, 8
  %cmp1969 = icmp slt i64 9223372036854775807, %mul1968
  br i1 %cmp1969, label %cond.true.1971, label %cond.false.1983

cond.true.1971:                                   ; preds = %lor.lhs.false.1967, %land.lhs.true.1963, %cond.end.1952, %cond.end.1929, %cond.true.1898, %cond.end.1892, %cond.true.1864, %cond.end.1858, %land.lhs.true.1833
  %365 = load i64, i64* %nargs2, align 8
  %mul1972 = mul i64 %365, 8
  %cmp1973 = icmp ule i64 %mul1972, 9223372036854775807
  br i1 %cmp1973, label %cond.true.1975, label %cond.false.1977

cond.true.1975:                                   ; preds = %cond.true.1971
  %366 = load i64, i64* %nargs2, align 8
  %mul1976 = mul i64 %366, 8
  br label %cond.end.1981

cond.false.1977:                                  ; preds = %cond.true.1971
  %367 = load i64, i64* %nargs2, align 8
  %mul1978 = mul i64 %367, 8
  %sub1979 = sub i64 %mul1978, -9223372036854775808
  %add1980 = add nsw i64 %sub1979, -9223372036854775808
  br label %cond.end.1981

cond.end.1981:                                    ; preds = %cond.false.1977, %cond.true.1975
  %cond1982 = phi i64 [ %mul1976, %cond.true.1975 ], [ %add1980, %cond.false.1977 ]
  store i64 %cond1982, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1983:                                  ; preds = %lor.lhs.false.1967
  %368 = load i64, i64* %nargs2, align 8
  %mul1984 = mul i64 %368, 8
  %cmp1985 = icmp ule i64 %mul1984, 9223372036854775807
  br i1 %cmp1985, label %cond.true.1987, label %cond.false.1989

cond.true.1987:                                   ; preds = %cond.false.1983
  %369 = load i64, i64* %nargs2, align 8
  %mul1988 = mul i64 %369, 8
  br label %cond.end.1993

cond.false.1989:                                  ; preds = %cond.false.1983
  %370 = load i64, i64* %nargs2, align 8
  %mul1990 = mul i64 %370, 8
  %sub1991 = sub i64 %mul1990, -9223372036854775808
  %add1992 = add nsw i64 %sub1991, -9223372036854775808
  br label %cond.end.1993

cond.end.1993:                                    ; preds = %cond.false.1989, %cond.true.1987
  %cond1994 = phi i64 [ %mul1988, %cond.true.1987 ], [ %add1992, %cond.false.1989 ]
  store i64 %cond1994, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.1995:                                  ; preds = %cond.false.1607
  br i1 false, label %cond.true.1996, label %cond.false.2189

cond.true.1996:                                   ; preds = %cond.false.1995
  %371 = load i64, i64* %nargs2, align 8
  %add1997 = add nsw i64 0, %371
  %mul1998 = mul nsw i64 0, %add1997
  %sub1999 = sub nsw i64 %mul1998, 1
  %cmp2000 = icmp slt i64 %sub1999, 0
  br i1 %cmp2000, label %cond.true.2002, label %cond.false.2019

cond.true.2002:                                   ; preds = %cond.true.1996
  %372 = load i64, i64* %nargs2, align 8
  %add2003 = add nsw i64 0, %372
  %mul2004 = mul nsw i64 0, %add2003
  %add2005 = add nsw i64 %mul2004, 0
  %neg2006 = xor i64 %add2005, -1
  %cmp2007 = icmp eq i64 %neg2006, -1
  %conv2008 = zext i1 %cmp2007 to i32
  %sub2009 = sub nsw i32 0, %conv2008
  %conv2010 = sext i32 %sub2009 to i64
  %373 = load i64, i64* %nargs2, align 8
  %add2011 = add nsw i64 0, %373
  %mul2012 = mul nsw i64 0, %add2011
  %add2013 = add nsw i64 %mul2012, 1
  %shl2014 = shl i64 %add2013, 62
  %sub2015 = sub nsw i64 %shl2014, 1
  %mul2016 = mul nsw i64 %sub2015, 2
  %add2017 = add nsw i64 %mul2016, 1
  %sub2018 = sub nsw i64 %conv2010, %add2017
  br label %cond.end.2023

cond.false.2019:                                  ; preds = %cond.true.1996
  %374 = load i64, i64* %nargs2, align 8
  %add2020 = add nsw i64 0, %374
  %mul2021 = mul nsw i64 0, %add2020
  %add2022 = add nsw i64 %mul2021, 0
  br label %cond.end.2023

cond.end.2023:                                    ; preds = %cond.false.2019, %cond.true.2002
  %cond2024 = phi i64 [ %sub2018, %cond.true.2002 ], [ %add2022, %cond.false.2019 ]
  %cmp2025 = icmp eq i64 %cond2024, 0
  br i1 %cmp2025, label %land.lhs.true.2027, label %lor.lhs.false.2030

land.lhs.true.2027:                               ; preds = %cond.end.2023
  %375 = load i64, i64* %nargs2, align 8
  %cmp2028 = icmp slt i64 %375, 0
  br i1 %cmp2028, label %cond.true.2165, label %lor.lhs.false.2030

lor.lhs.false.2030:                               ; preds = %land.lhs.true.2027, %cond.end.2023
  br i1 false, label %cond.true.2031, label %cond.false.2091

cond.true.2031:                                   ; preds = %lor.lhs.false.2030
  %376 = load i64, i64* %nargs2, align 8
  %cmp2032 = icmp slt i64 %376, 0
  br i1 %cmp2032, label %cond.true.2034, label %cond.false.2057

cond.true.2034:                                   ; preds = %cond.true.2031
  %377 = load i64, i64* %nargs2, align 8
  %378 = load i64, i64* %nargs2, align 8
  %add2035 = add nsw i64 0, %378
  %mul2036 = mul nsw i64 0, %add2035
  %sub2037 = sub nsw i64 %mul2036, 1
  %cmp2038 = icmp slt i64 %sub2037, 0
  br i1 %cmp2038, label %cond.true.2040, label %cond.false.2048

cond.true.2040:                                   ; preds = %cond.true.2034
  %379 = load i64, i64* %nargs2, align 8
  %add2041 = add nsw i64 0, %379
  %mul2042 = mul nsw i64 0, %add2041
  %add2043 = add nsw i64 %mul2042, 1
  %shl2044 = shl i64 %add2043, 62
  %sub2045 = sub nsw i64 %shl2044, 1
  %mul2046 = mul nsw i64 %sub2045, 2
  %add2047 = add nsw i64 %mul2046, 1
  br label %cond.end.2052

cond.false.2048:                                  ; preds = %cond.true.2034
  %380 = load i64, i64* %nargs2, align 8
  %add2049 = add nsw i64 0, %380
  %mul2050 = mul nsw i64 0, %add2049
  %sub2051 = sub nsw i64 %mul2050, 1
  br label %cond.end.2052

cond.end.2052:                                    ; preds = %cond.false.2048, %cond.true.2040
  %cond2053 = phi i64 [ %add2047, %cond.true.2040 ], [ %sub2051, %cond.false.2048 ]
  %div2054 = sdiv i64 %cond2053, 8
  %cmp2055 = icmp slt i64 %377, %div2054
  br i1 %cmp2055, label %cond.true.2165, label %lor.lhs.false.2151

cond.false.2057:                                  ; preds = %cond.true.2031
  br i1 false, label %cond.true.2058, label %cond.false.2059

cond.true.2058:                                   ; preds = %cond.false.2057
  br i1 false, label %cond.true.2165, label %lor.lhs.false.2151

cond.false.2059:                                  ; preds = %cond.false.2057
  %381 = load i64, i64* %nargs2, align 8
  %add2060 = add nsw i64 0, %381
  %mul2061 = mul nsw i64 0, %add2060
  %sub2062 = sub nsw i64 %mul2061, 1
  %cmp2063 = icmp slt i64 %sub2062, 0
  br i1 %cmp2063, label %cond.true.2065, label %cond.false.2082

cond.true.2065:                                   ; preds = %cond.false.2059
  %382 = load i64, i64* %nargs2, align 8
  %add2066 = add nsw i64 0, %382
  %mul2067 = mul nsw i64 0, %add2066
  %add2068 = add nsw i64 %mul2067, 0
  %neg2069 = xor i64 %add2068, -1
  %cmp2070 = icmp eq i64 %neg2069, -1
  %conv2071 = zext i1 %cmp2070 to i32
  %sub2072 = sub nsw i32 0, %conv2071
  %conv2073 = sext i32 %sub2072 to i64
  %383 = load i64, i64* %nargs2, align 8
  %add2074 = add nsw i64 0, %383
  %mul2075 = mul nsw i64 0, %add2074
  %add2076 = add nsw i64 %mul2075, 1
  %shl2077 = shl i64 %add2076, 62
  %sub2078 = sub nsw i64 %shl2077, 1
  %mul2079 = mul nsw i64 %sub2078, 2
  %add2080 = add nsw i64 %mul2079, 1
  %sub2081 = sub nsw i64 %conv2073, %add2080
  br label %cond.end.2086

cond.false.2082:                                  ; preds = %cond.false.2059
  %384 = load i64, i64* %nargs2, align 8
  %add2083 = add nsw i64 0, %384
  %mul2084 = mul nsw i64 0, %add2083
  %add2085 = add nsw i64 %mul2084, 0
  br label %cond.end.2086

cond.end.2086:                                    ; preds = %cond.false.2082, %cond.true.2065
  %cond2087 = phi i64 [ %sub2081, %cond.true.2065 ], [ %add2085, %cond.false.2082 ]
  %div2088 = sdiv i64 %cond2087, 8
  %385 = load i64, i64* %nargs2, align 8
  %cmp2089 = icmp slt i64 %div2088, %385
  br i1 %cmp2089, label %cond.true.2165, label %lor.lhs.false.2151

cond.false.2091:                                  ; preds = %lor.lhs.false.2030
  br i1 false, label %cond.true.2092, label %cond.false.2093

cond.true.2092:                                   ; preds = %cond.false.2091
  br i1 false, label %cond.true.2165, label %lor.lhs.false.2151

cond.false.2093:                                  ; preds = %cond.false.2091
  %386 = load i64, i64* %nargs2, align 8
  %cmp2094 = icmp slt i64 %386, 0
  br i1 %cmp2094, label %cond.true.2096, label %cond.false.2128

cond.true.2096:                                   ; preds = %cond.false.2093
  %387 = load i64, i64* %nargs2, align 8
  %388 = load i64, i64* %nargs2, align 8
  %add2097 = add nsw i64 0, %388
  %mul2098 = mul nsw i64 0, %add2097
  %sub2099 = sub nsw i64 %mul2098, 1
  %cmp2100 = icmp slt i64 %sub2099, 0
  br i1 %cmp2100, label %cond.true.2102, label %cond.false.2119

cond.true.2102:                                   ; preds = %cond.true.2096
  %389 = load i64, i64* %nargs2, align 8
  %add2103 = add nsw i64 0, %389
  %mul2104 = mul nsw i64 0, %add2103
  %add2105 = add nsw i64 %mul2104, 0
  %neg2106 = xor i64 %add2105, -1
  %cmp2107 = icmp eq i64 %neg2106, -1
  %conv2108 = zext i1 %cmp2107 to i32
  %sub2109 = sub nsw i32 0, %conv2108
  %conv2110 = sext i32 %sub2109 to i64
  %390 = load i64, i64* %nargs2, align 8
  %add2111 = add nsw i64 0, %390
  %mul2112 = mul nsw i64 0, %add2111
  %add2113 = add nsw i64 %mul2112, 1
  %shl2114 = shl i64 %add2113, 62
  %sub2115 = sub nsw i64 %shl2114, 1
  %mul2116 = mul nsw i64 %sub2115, 2
  %add2117 = add nsw i64 %mul2116, 1
  %sub2118 = sub nsw i64 %conv2110, %add2117
  br label %cond.end.2123

cond.false.2119:                                  ; preds = %cond.true.2096
  %391 = load i64, i64* %nargs2, align 8
  %add2120 = add nsw i64 0, %391
  %mul2121 = mul nsw i64 0, %add2120
  %add2122 = add nsw i64 %mul2121, 0
  br label %cond.end.2123

cond.end.2123:                                    ; preds = %cond.false.2119, %cond.true.2102
  %cond2124 = phi i64 [ %sub2118, %cond.true.2102 ], [ %add2122, %cond.false.2119 ]
  %div2125 = sdiv i64 %cond2124, 8
  %cmp2126 = icmp slt i64 %387, %div2125
  br i1 %cmp2126, label %cond.true.2165, label %lor.lhs.false.2151

cond.false.2128:                                  ; preds = %cond.false.2093
  %392 = load i64, i64* %nargs2, align 8
  %add2129 = add nsw i64 0, %392
  %mul2130 = mul nsw i64 0, %add2129
  %sub2131 = sub nsw i64 %mul2130, 1
  %cmp2132 = icmp slt i64 %sub2131, 0
  br i1 %cmp2132, label %cond.true.2134, label %cond.false.2142

cond.true.2134:                                   ; preds = %cond.false.2128
  %393 = load i64, i64* %nargs2, align 8
  %add2135 = add nsw i64 0, %393
  %mul2136 = mul nsw i64 0, %add2135
  %add2137 = add nsw i64 %mul2136, 1
  %shl2138 = shl i64 %add2137, 62
  %sub2139 = sub nsw i64 %shl2138, 1
  %mul2140 = mul nsw i64 %sub2139, 2
  %add2141 = add nsw i64 %mul2140, 1
  br label %cond.end.2146

cond.false.2142:                                  ; preds = %cond.false.2128
  %394 = load i64, i64* %nargs2, align 8
  %add2143 = add nsw i64 0, %394
  %mul2144 = mul nsw i64 0, %add2143
  %sub2145 = sub nsw i64 %mul2144, 1
  br label %cond.end.2146

cond.end.2146:                                    ; preds = %cond.false.2142, %cond.true.2134
  %cond2147 = phi i64 [ %add2141, %cond.true.2134 ], [ %sub2145, %cond.false.2142 ]
  %div2148 = sdiv i64 %cond2147, 8
  %395 = load i64, i64* %nargs2, align 8
  %cmp2149 = icmp slt i64 %div2148, %395
  br i1 %cmp2149, label %cond.true.2165, label %lor.lhs.false.2151

lor.lhs.false.2151:                               ; preds = %cond.end.2146, %cond.end.2123, %cond.true.2092, %cond.end.2086, %cond.true.2058, %cond.end.2052
  %396 = load i64, i64* %nargs2, align 8
  %mul2152 = mul nsw i64 %396, 8
  %mul2153 = mul nsw i64 0, %mul2152
  %sub2154 = sub nsw i64 %mul2153, 1
  %cmp2155 = icmp slt i64 %sub2154, 0
  br i1 %cmp2155, label %land.lhs.true.2157, label %lor.lhs.false.2161

land.lhs.true.2157:                               ; preds = %lor.lhs.false.2151
  %397 = load i64, i64* %nargs2, align 8
  %mul2158 = mul nsw i64 %397, 8
  %cmp2159 = icmp slt i64 %mul2158, -9223372036854775808
  br i1 %cmp2159, label %cond.true.2165, label %lor.lhs.false.2161

lor.lhs.false.2161:                               ; preds = %land.lhs.true.2157, %lor.lhs.false.2151
  %398 = load i64, i64* %nargs2, align 8
  %mul2162 = mul nsw i64 %398, 8
  %cmp2163 = icmp slt i64 9223372036854775807, %mul2162
  br i1 %cmp2163, label %cond.true.2165, label %cond.false.2177

cond.true.2165:                                   ; preds = %lor.lhs.false.2161, %land.lhs.true.2157, %cond.end.2146, %cond.end.2123, %cond.true.2092, %cond.end.2086, %cond.true.2058, %cond.end.2052, %land.lhs.true.2027
  %399 = load i64, i64* %nargs2, align 8
  %mul2166 = mul i64 %399, 8
  %cmp2167 = icmp ule i64 %mul2166, 9223372036854775807
  br i1 %cmp2167, label %cond.true.2169, label %cond.false.2171

cond.true.2169:                                   ; preds = %cond.true.2165
  %400 = load i64, i64* %nargs2, align 8
  %mul2170 = mul i64 %400, 8
  br label %cond.end.2175

cond.false.2171:                                  ; preds = %cond.true.2165
  %401 = load i64, i64* %nargs2, align 8
  %mul2172 = mul i64 %401, 8
  %sub2173 = sub i64 %mul2172, -9223372036854775808
  %add2174 = add nsw i64 %sub2173, -9223372036854775808
  br label %cond.end.2175

cond.end.2175:                                    ; preds = %cond.false.2171, %cond.true.2169
  %cond2176 = phi i64 [ %mul2170, %cond.true.2169 ], [ %add2174, %cond.false.2171 ]
  store i64 %cond2176, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.2177:                                  ; preds = %lor.lhs.false.2161
  %402 = load i64, i64* %nargs2, align 8
  %mul2178 = mul i64 %402, 8
  %cmp2179 = icmp ule i64 %mul2178, 9223372036854775807
  br i1 %cmp2179, label %cond.true.2181, label %cond.false.2183

cond.true.2181:                                   ; preds = %cond.false.2177
  %403 = load i64, i64* %nargs2, align 8
  %mul2182 = mul i64 %403, 8
  br label %cond.end.2187

cond.false.2183:                                  ; preds = %cond.false.2177
  %404 = load i64, i64* %nargs2, align 8
  %mul2184 = mul i64 %404, 8
  %sub2185 = sub i64 %mul2184, -9223372036854775808
  %add2186 = add nsw i64 %sub2185, -9223372036854775808
  br label %cond.end.2187

cond.end.2187:                                    ; preds = %cond.false.2183, %cond.true.2181
  %cond2188 = phi i64 [ %mul2182, %cond.true.2181 ], [ %add2186, %cond.false.2183 ]
  store i64 %cond2188, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

cond.false.2189:                                  ; preds = %cond.false.1995
  %405 = load i64, i64* %nargs2, align 8
  %add2190 = add nsw i64 0, %405
  %mul2191 = mul nsw i64 0, %add2190
  %sub2192 = sub nsw i64 %mul2191, 1
  %cmp2193 = icmp slt i64 %sub2192, 0
  br i1 %cmp2193, label %cond.true.2195, label %cond.false.2212

cond.true.2195:                                   ; preds = %cond.false.2189
  %406 = load i64, i64* %nargs2, align 8
  %add2196 = add nsw i64 0, %406
  %mul2197 = mul nsw i64 0, %add2196
  %add2198 = add nsw i64 %mul2197, 0
  %neg2199 = xor i64 %add2198, -1
  %cmp2200 = icmp eq i64 %neg2199, -1
  %conv2201 = zext i1 %cmp2200 to i32
  %sub2202 = sub nsw i32 0, %conv2201
  %conv2203 = sext i32 %sub2202 to i64
  %407 = load i64, i64* %nargs2, align 8
  %add2204 = add nsw i64 0, %407
  %mul2205 = mul nsw i64 0, %add2204
  %add2206 = add nsw i64 %mul2205, 1
  %shl2207 = shl i64 %add2206, 62
  %sub2208 = sub nsw i64 %shl2207, 1
  %mul2209 = mul nsw i64 %sub2208, 2
  %add2210 = add nsw i64 %mul2209, 1
  %sub2211 = sub nsw i64 %conv2203, %add2210
  br label %cond.end.2216

cond.false.2212:                                  ; preds = %cond.false.2189
  %408 = load i64, i64* %nargs2, align 8
  %add2213 = add nsw i64 0, %408
  %mul2214 = mul nsw i64 0, %add2213
  %add2215 = add nsw i64 %mul2214, 0
  br label %cond.end.2216

cond.end.2216:                                    ; preds = %cond.false.2212, %cond.true.2195
  %cond2217 = phi i64 [ %sub2211, %cond.true.2195 ], [ %add2215, %cond.false.2212 ]
  %cmp2218 = icmp eq i64 %cond2217, 0
  br i1 %cmp2218, label %land.lhs.true.2220, label %lor.lhs.false.2223

land.lhs.true.2220:                               ; preds = %cond.end.2216
  %409 = load i64, i64* %nargs2, align 8
  %cmp2221 = icmp slt i64 %409, 0
  br i1 %cmp2221, label %cond.true.2358, label %lor.lhs.false.2223

lor.lhs.false.2223:                               ; preds = %land.lhs.true.2220, %cond.end.2216
  br i1 false, label %cond.true.2224, label %cond.false.2284

cond.true.2224:                                   ; preds = %lor.lhs.false.2223
  %410 = load i64, i64* %nargs2, align 8
  %cmp2225 = icmp slt i64 %410, 0
  br i1 %cmp2225, label %cond.true.2227, label %cond.false.2250

cond.true.2227:                                   ; preds = %cond.true.2224
  %411 = load i64, i64* %nargs2, align 8
  %412 = load i64, i64* %nargs2, align 8
  %add2228 = add nsw i64 0, %412
  %mul2229 = mul nsw i64 0, %add2228
  %sub2230 = sub nsw i64 %mul2229, 1
  %cmp2231 = icmp slt i64 %sub2230, 0
  br i1 %cmp2231, label %cond.true.2233, label %cond.false.2241

cond.true.2233:                                   ; preds = %cond.true.2227
  %413 = load i64, i64* %nargs2, align 8
  %add2234 = add nsw i64 0, %413
  %mul2235 = mul nsw i64 0, %add2234
  %add2236 = add nsw i64 %mul2235, 1
  %shl2237 = shl i64 %add2236, 62
  %sub2238 = sub nsw i64 %shl2237, 1
  %mul2239 = mul nsw i64 %sub2238, 2
  %add2240 = add nsw i64 %mul2239, 1
  br label %cond.end.2245

cond.false.2241:                                  ; preds = %cond.true.2227
  %414 = load i64, i64* %nargs2, align 8
  %add2242 = add nsw i64 0, %414
  %mul2243 = mul nsw i64 0, %add2242
  %sub2244 = sub nsw i64 %mul2243, 1
  br label %cond.end.2245

cond.end.2245:                                    ; preds = %cond.false.2241, %cond.true.2233
  %cond2246 = phi i64 [ %add2240, %cond.true.2233 ], [ %sub2244, %cond.false.2241 ]
  %div2247 = sdiv i64 %cond2246, 8
  %cmp2248 = icmp slt i64 %411, %div2247
  br i1 %cmp2248, label %cond.true.2358, label %lor.lhs.false.2344

cond.false.2250:                                  ; preds = %cond.true.2224
  br i1 false, label %cond.true.2251, label %cond.false.2252

cond.true.2251:                                   ; preds = %cond.false.2250
  br i1 false, label %cond.true.2358, label %lor.lhs.false.2344

cond.false.2252:                                  ; preds = %cond.false.2250
  %415 = load i64, i64* %nargs2, align 8
  %add2253 = add nsw i64 0, %415
  %mul2254 = mul nsw i64 0, %add2253
  %sub2255 = sub nsw i64 %mul2254, 1
  %cmp2256 = icmp slt i64 %sub2255, 0
  br i1 %cmp2256, label %cond.true.2258, label %cond.false.2275

cond.true.2258:                                   ; preds = %cond.false.2252
  %416 = load i64, i64* %nargs2, align 8
  %add2259 = add nsw i64 0, %416
  %mul2260 = mul nsw i64 0, %add2259
  %add2261 = add nsw i64 %mul2260, 0
  %neg2262 = xor i64 %add2261, -1
  %cmp2263 = icmp eq i64 %neg2262, -1
  %conv2264 = zext i1 %cmp2263 to i32
  %sub2265 = sub nsw i32 0, %conv2264
  %conv2266 = sext i32 %sub2265 to i64
  %417 = load i64, i64* %nargs2, align 8
  %add2267 = add nsw i64 0, %417
  %mul2268 = mul nsw i64 0, %add2267
  %add2269 = add nsw i64 %mul2268, 1
  %shl2270 = shl i64 %add2269, 62
  %sub2271 = sub nsw i64 %shl2270, 1
  %mul2272 = mul nsw i64 %sub2271, 2
  %add2273 = add nsw i64 %mul2272, 1
  %sub2274 = sub nsw i64 %conv2266, %add2273
  br label %cond.end.2279

cond.false.2275:                                  ; preds = %cond.false.2252
  %418 = load i64, i64* %nargs2, align 8
  %add2276 = add nsw i64 0, %418
  %mul2277 = mul nsw i64 0, %add2276
  %add2278 = add nsw i64 %mul2277, 0
  br label %cond.end.2279

cond.end.2279:                                    ; preds = %cond.false.2275, %cond.true.2258
  %cond2280 = phi i64 [ %sub2274, %cond.true.2258 ], [ %add2278, %cond.false.2275 ]
  %div2281 = sdiv i64 %cond2280, 8
  %419 = load i64, i64* %nargs2, align 8
  %cmp2282 = icmp slt i64 %div2281, %419
  br i1 %cmp2282, label %cond.true.2358, label %lor.lhs.false.2344

cond.false.2284:                                  ; preds = %lor.lhs.false.2223
  br i1 false, label %cond.true.2285, label %cond.false.2286

cond.true.2285:                                   ; preds = %cond.false.2284
  br i1 false, label %cond.true.2358, label %lor.lhs.false.2344

cond.false.2286:                                  ; preds = %cond.false.2284
  %420 = load i64, i64* %nargs2, align 8
  %cmp2287 = icmp slt i64 %420, 0
  br i1 %cmp2287, label %cond.true.2289, label %cond.false.2321

cond.true.2289:                                   ; preds = %cond.false.2286
  %421 = load i64, i64* %nargs2, align 8
  %422 = load i64, i64* %nargs2, align 8
  %add2290 = add nsw i64 0, %422
  %mul2291 = mul nsw i64 0, %add2290
  %sub2292 = sub nsw i64 %mul2291, 1
  %cmp2293 = icmp slt i64 %sub2292, 0
  br i1 %cmp2293, label %cond.true.2295, label %cond.false.2312

cond.true.2295:                                   ; preds = %cond.true.2289
  %423 = load i64, i64* %nargs2, align 8
  %add2296 = add nsw i64 0, %423
  %mul2297 = mul nsw i64 0, %add2296
  %add2298 = add nsw i64 %mul2297, 0
  %neg2299 = xor i64 %add2298, -1
  %cmp2300 = icmp eq i64 %neg2299, -1
  %conv2301 = zext i1 %cmp2300 to i32
  %sub2302 = sub nsw i32 0, %conv2301
  %conv2303 = sext i32 %sub2302 to i64
  %424 = load i64, i64* %nargs2, align 8
  %add2304 = add nsw i64 0, %424
  %mul2305 = mul nsw i64 0, %add2304
  %add2306 = add nsw i64 %mul2305, 1
  %shl2307 = shl i64 %add2306, 62
  %sub2308 = sub nsw i64 %shl2307, 1
  %mul2309 = mul nsw i64 %sub2308, 2
  %add2310 = add nsw i64 %mul2309, 1
  %sub2311 = sub nsw i64 %conv2303, %add2310
  br label %cond.end.2316

cond.false.2312:                                  ; preds = %cond.true.2289
  %425 = load i64, i64* %nargs2, align 8
  %add2313 = add nsw i64 0, %425
  %mul2314 = mul nsw i64 0, %add2313
  %add2315 = add nsw i64 %mul2314, 0
  br label %cond.end.2316

cond.end.2316:                                    ; preds = %cond.false.2312, %cond.true.2295
  %cond2317 = phi i64 [ %sub2311, %cond.true.2295 ], [ %add2315, %cond.false.2312 ]
  %div2318 = sdiv i64 %cond2317, 8
  %cmp2319 = icmp slt i64 %421, %div2318
  br i1 %cmp2319, label %cond.true.2358, label %lor.lhs.false.2344

cond.false.2321:                                  ; preds = %cond.false.2286
  %426 = load i64, i64* %nargs2, align 8
  %add2322 = add nsw i64 0, %426
  %mul2323 = mul nsw i64 0, %add2322
  %sub2324 = sub nsw i64 %mul2323, 1
  %cmp2325 = icmp slt i64 %sub2324, 0
  br i1 %cmp2325, label %cond.true.2327, label %cond.false.2335

cond.true.2327:                                   ; preds = %cond.false.2321
  %427 = load i64, i64* %nargs2, align 8
  %add2328 = add nsw i64 0, %427
  %mul2329 = mul nsw i64 0, %add2328
  %add2330 = add nsw i64 %mul2329, 1
  %shl2331 = shl i64 %add2330, 62
  %sub2332 = sub nsw i64 %shl2331, 1
  %mul2333 = mul nsw i64 %sub2332, 2
  %add2334 = add nsw i64 %mul2333, 1
  br label %cond.end.2339

cond.false.2335:                                  ; preds = %cond.false.2321
  %428 = load i64, i64* %nargs2, align 8
  %add2336 = add nsw i64 0, %428
  %mul2337 = mul nsw i64 0, %add2336
  %sub2338 = sub nsw i64 %mul2337, 1
  br label %cond.end.2339

cond.end.2339:                                    ; preds = %cond.false.2335, %cond.true.2327
  %cond2340 = phi i64 [ %add2334, %cond.true.2327 ], [ %sub2338, %cond.false.2335 ]
  %div2341 = sdiv i64 %cond2340, 8
  %429 = load i64, i64* %nargs2, align 8
  %cmp2342 = icmp slt i64 %div2341, %429
  br i1 %cmp2342, label %cond.true.2358, label %lor.lhs.false.2344

lor.lhs.false.2344:                               ; preds = %cond.end.2339, %cond.end.2316, %cond.true.2285, %cond.end.2279, %cond.true.2251, %cond.end.2245
  %430 = load i64, i64* %nargs2, align 8
  %mul2345 = mul nsw i64 %430, 8
  %mul2346 = mul nsw i64 0, %mul2345
  %sub2347 = sub nsw i64 %mul2346, 1
  %cmp2348 = icmp slt i64 %sub2347, 0
  br i1 %cmp2348, label %land.lhs.true.2350, label %lor.lhs.false.2354

land.lhs.true.2350:                               ; preds = %lor.lhs.false.2344
  %431 = load i64, i64* %nargs2, align 8
  %mul2351 = mul nsw i64 %431, 8
  %cmp2352 = icmp slt i64 %mul2351, -9223372036854775808
  br i1 %cmp2352, label %cond.true.2358, label %lor.lhs.false.2354

lor.lhs.false.2354:                               ; preds = %land.lhs.true.2350, %lor.lhs.false.2344
  %432 = load i64, i64* %nargs2, align 8
  %mul2355 = mul nsw i64 %432, 8
  %cmp2356 = icmp slt i64 9223372036854775807, %mul2355
  br i1 %cmp2356, label %cond.true.2358, label %cond.false.2370

cond.true.2358:                                   ; preds = %lor.lhs.false.2354, %land.lhs.true.2350, %cond.end.2339, %cond.end.2316, %cond.true.2285, %cond.end.2279, %cond.true.2251, %cond.end.2245, %land.lhs.true.2220
  %433 = load i64, i64* %nargs2, align 8
  %mul2359 = mul i64 %433, 8
  %cmp2360 = icmp ule i64 %mul2359, 9223372036854775807
  br i1 %cmp2360, label %cond.true.2362, label %cond.false.2364

cond.true.2362:                                   ; preds = %cond.true.2358
  %434 = load i64, i64* %nargs2, align 8
  %mul2363 = mul i64 %434, 8
  br label %cond.end.2368

cond.false.2364:                                  ; preds = %cond.true.2358
  %435 = load i64, i64* %nargs2, align 8
  %mul2365 = mul i64 %435, 8
  %sub2366 = sub i64 %mul2365, -9223372036854775808
  %add2367 = add nsw i64 %sub2366, -9223372036854775808
  br label %cond.end.2368

cond.end.2368:                                    ; preds = %cond.false.2364, %cond.true.2362
  %cond2369 = phi i64 [ %mul2363, %cond.true.2362 ], [ %add2367, %cond.false.2364 ]
  store i64 %cond2369, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2385, label %lor.lhs.false.2382

cond.false.2370:                                  ; preds = %lor.lhs.false.2354
  %436 = load i64, i64* %nargs2, align 8
  %mul2371 = mul i64 %436, 8
  %cmp2372 = icmp ule i64 %mul2371, 9223372036854775807
  br i1 %cmp2372, label %cond.true.2374, label %cond.false.2376

cond.true.2374:                                   ; preds = %cond.false.2370
  %437 = load i64, i64* %nargs2, align 8
  %mul2375 = mul i64 %437, 8
  br label %cond.end.2380

cond.false.2376:                                  ; preds = %cond.false.2370
  %438 = load i64, i64* %nargs2, align 8
  %mul2377 = mul i64 %438, 8
  %sub2378 = sub i64 %mul2377, -9223372036854775808
  %add2379 = add nsw i64 %sub2378, -9223372036854775808
  br label %cond.end.2380

cond.end.2380:                                    ; preds = %cond.false.2376, %cond.true.2374
  %cond2381 = phi i64 [ %mul2375, %cond.true.2374 ], [ %add2379, %cond.false.2376 ]
  store i64 %cond2381, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2385, label %lor.lhs.false.2382

lor.lhs.false.2382:                               ; preds = %cond.end.2380, %cond.end.2368, %cond.end.2187, %cond.end.2175, %cond.end.1993, %cond.end.1981, %cond.end.1800, %cond.end.1788, %cond.end.1604, %cond.end.1588, %cond.end.1403, %cond.end.1387, %cond.end.1175, %cond.end.1152, %cond.end.960, %cond.end.937, %cond.end.690, %cond.end.667, %cond.end.475, %cond.end.452
  %439 = load i64, i64* %alloca_nbytes, align 8
  %cmp2383 = icmp ult i64 -1, %439
  br i1 %cmp2383, label %if.then.2385, label %if.else.2386

if.then.2385:                                     ; preds = %lor.lhs.false.2382, %cond.end.2380, %cond.end.2368, %cond.end.2187, %cond.end.2175, %cond.end.1993, %cond.end.1981, %cond.end.1800, %cond.end.1788, %cond.end.1604, %cond.end.1588, %cond.end.1403, %cond.end.1387, %cond.end.1175, %cond.end.1152, %cond.end.960, %cond.end.937, %cond.end.690, %cond.end.667, %cond.end.475, %cond.end.452
  call void @memory_full(i64 -1) #8
  unreachable

if.else.2386:                                     ; preds = %lor.lhs.false.2382
  %440 = load i64, i64* %alloca_nbytes, align 8
  %441 = load i64, i64* %sa_avail, align 8
  %cmp2387 = icmp sle i64 %440, %441
  br i1 %cmp2387, label %if.then.2389, label %if.else.2391

if.then.2389:                                     ; preds = %if.else.2386
  %442 = load i64, i64* %alloca_nbytes, align 8
  %443 = load i64, i64* %sa_avail, align 8
  %sub2390 = sub nsw i64 %443, %442
  store i64 %sub2390, i64* %sa_avail, align 8
  %444 = load i64, i64* %alloca_nbytes, align 8
  %445 = alloca i8, i64 %444
  %446 = bitcast i8* %445 to i64*
  store i64* %446, i64** %args2, align 8
  br label %if.end.2394

if.else.2391:                                     ; preds = %if.else.2386
  %447 = load i64, i64* %alloca_nbytes, align 8
  %call2392 = call noalias i8* @xmalloc(i64 %447)
  %448 = bitcast i8* %call2392 to i64*
  store i64* %448, i64** %args2, align 8
  %449 = load i64*, i64** %args2, align 8
  %450 = load i64, i64* %nargs2, align 8
  %call2393 = call i64 @make_save_memory(i64* %449, i64 %450)
  store i64 %call2393, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %451 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %451)
  br label %if.end.2394

if.end.2394:                                      ; preds = %if.else.2391, %if.then.2389
  br label %if.end.2395

if.end.2395:                                      ; preds = %if.end.2394
  br label %do.end

do.end:                                           ; preds = %if.end.2395
  store i64 0, i64* %i, align 8
  %call2396 = call i64 @builtin_lisp_symbol(i32 873)
  %452 = load i64, i64* %i, align 8
  %inc = add nsw i64 %452, 1
  store i64 %inc, i64* %i, align 8
  %453 = load i64*, i64** %args2, align 8
  %arrayidx = getelementptr inbounds i64, i64* %453, i64 %452
  store i64 %call2396, i64* %arrayidx, align 8
  %454 = load i64, i64* %name, align 8
  %455 = load i64, i64* %i, align 8
  %inc2397 = add nsw i64 %455, 1
  store i64 %inc2397, i64* %i, align 8
  %456 = load i64*, i64** %args2, align 8
  %arrayidx2398 = getelementptr inbounds i64, i64* %456, i64 %455
  store i64 %454, i64* %arrayidx2398, align 8
  %457 = load i64, i64* %buffer, align 8
  %458 = load i64, i64* %i, align 8
  %inc2399 = add nsw i64 %458, 1
  store i64 %inc2399, i64* %i, align 8
  %459 = load i64*, i64** %args2, align 8
  %arrayidx2400 = getelementptr inbounds i64, i64* %459, i64 %458
  store i64 %457, i64* %arrayidx2400, align 8
  %460 = load i64, i64* %command, align 8
  store i64 %460, i64* %tem2, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %461 = load i64, i64* %tem2, align 8
  %and2401 = and i64 %461, 7
  %conv2402 = trunc i64 %and2401 to i32
  %cmp2403 = icmp eq i32 %conv2402, 3
  br i1 %cmp2403, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %462 = load i64, i64* %tem2, align 8
  %sub2405 = sub nsw i64 %462, 3
  %463 = inttoptr i64 %sub2405 to i8*
  %464 = bitcast i8* %463 to %struct.Lisp_Cons*
  %car2406 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %464, i32 0, i32 0
  %465 = load i64, i64* %car2406, align 8
  %466 = load i64, i64* %i, align 8
  %inc2407 = add nsw i64 %466, 1
  store i64 %inc2407, i64* %i, align 8
  %467 = load i64*, i64** %args2, align 8
  %arrayidx2408 = getelementptr inbounds i64, i64* %467, i64 %466
  store i64 %465, i64* %arrayidx2408, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %468 = load i64, i64* %tem2, align 8
  %sub2409 = sub nsw i64 %468, 3
  %469 = inttoptr i64 %sub2409 to i8*
  %470 = bitcast i8* %469 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %470, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %471 = load i64, i64* %cdr, align 8
  store i64 %471, i64* %tem2, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %472 = load i64, i64* %program, align 8
  %call2410 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2411 = icmp eq i64 %472, %call2410
  br i1 %cmp2411, label %if.end.2415, label %if.then.2413

if.then.2413:                                     ; preds = %for.end
  %473 = load i64, i64* %nargs2, align 8
  %474 = load i64*, i64** %args2, align 8
  %call2414 = call i64 @Ffind_operation_coding_system(i64 %473, i64* %474)
  store i64 %call2414, i64* %coding_systems, align 8
  br label %if.end.2415

if.end.2415:                                      ; preds = %if.then.2413, %for.end
  %475 = load i64, i64* %coding_systems, align 8
  %and2416 = and i64 %475, 7
  %conv2417 = trunc i64 %and2416 to i32
  %cmp2418 = icmp eq i32 %conv2417, 3
  br i1 %cmp2418, label %if.then.2420, label %if.else.2423

if.then.2420:                                     ; preds = %if.end.2415
  %476 = load i64, i64* %coding_systems, align 8
  %sub2421 = sub nsw i64 %476, 3
  %477 = inttoptr i64 %sub2421 to i8*
  %478 = bitcast i8* %477 to %struct.Lisp_Cons*
  %car2422 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %478, i32 0, i32 0
  %479 = load i64, i64* %car2422, align 8
  store i64 %479, i64* %val, align 8
  br label %if.end.2432

if.else.2423:                                     ; preds = %if.end.2415
  %480 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and2424 = and i64 %480, 7
  %conv2425 = trunc i64 %and2424 to i32
  %cmp2426 = icmp eq i32 %conv2425, 3
  br i1 %cmp2426, label %if.then.2428, label %if.end.2431

if.then.2428:                                     ; preds = %if.else.2423
  %481 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub2429 = sub nsw i64 %481, 3
  %482 = inttoptr i64 %sub2429 to i8*
  %483 = bitcast i8* %482 to %struct.Lisp_Cons*
  %car2430 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %483, i32 0, i32 0
  %484 = load i64, i64* %car2430, align 8
  store i64 %484, i64* %val, align 8
  br label %if.end.2431

if.end.2431:                                      ; preds = %if.then.2428, %if.else.2423
  br label %if.end.2432

if.end.2432:                                      ; preds = %if.end.2431, %if.then.2420
  br label %if.end.2433

if.end.2433:                                      ; preds = %if.end.2432, %if.end.209
  %485 = load i64, i64* %proc, align 8
  %call2434 = call %struct.Lisp_Process* @XPROCESS(i64 %485)
  %486 = load i64, i64* %val, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %call2434, i64 %486)
  %487 = load i64, i64* %tem, align 8
  %call2435 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2436 = icmp eq i64 %487, %call2435
  br i1 %cmp2436, label %if.else.2448, label %if.then.2438

if.then.2438:                                     ; preds = %if.end.2433
  %488 = load i64, i64* %tem, align 8
  store i64 %488, i64* %val, align 8
  %489 = load i64, i64* %val, align 8
  %and2439 = and i64 %489, 7
  %conv2440 = trunc i64 %and2439 to i32
  %cmp2441 = icmp eq i32 %conv2440, 3
  br i1 %cmp2441, label %if.then.2443, label %if.end.2447

if.then.2443:                                     ; preds = %if.then.2438
  %490 = load i64, i64* %val, align 8
  %sub2444 = sub nsw i64 %490, 3
  %491 = inttoptr i64 %sub2444 to i8*
  %492 = bitcast i8* %491 to %struct.Lisp_Cons*
  %u2445 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %492, i32 0, i32 1
  %cdr2446 = bitcast %union.anon* %u2445 to i64*
  %493 = load i64, i64* %cdr2446, align 8
  store i64 %493, i64* %val, align 8
  br label %if.end.2447

if.end.2447:                                      ; preds = %if.then.2443, %if.then.2438
  br label %if.end.2449

if.else.2448:                                     ; preds = %if.end.2433
  %494 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  store i64 %494, i64* %val, align 8
  br label %if.end.2449

if.end.2449:                                      ; preds = %if.else.2448, %if.end.2447
  %495 = load i64, i64* %val, align 8
  %call2450 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2451 = icmp eq i64 %495, %call2450
  br i1 %cmp2451, label %if.then.2453, label %if.end.4703

if.then.2453:                                     ; preds = %if.end.2449
  %496 = load i64, i64* %coding_systems, align 8
  %call2454 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp2455 = icmp eq i64 %496, %call2454
  br i1 %cmp2455, label %if.then.2457, label %if.end.4683

if.then.2457:                                     ; preds = %if.then.2453
  %497 = load i64, i64* %command, align 8
  %call2459 = call i64 @Flength(i64 %497)
  %shr2460 = ashr i64 %call2459, 2
  %add2461 = add nsw i64 3, %shr2460
  store i64 %add2461, i64* %nargs22458, align 8
  br label %do.body.2463

do.body.2463:                                     ; preds = %if.then.2457
  br i1 false, label %cond.true.2465, label %cond.false.2949

cond.true.2465:                                   ; preds = %do.body.2463
  br i1 false, label %cond.true.2466, label %cond.false.2734

cond.true.2466:                                   ; preds = %cond.true.2465
  %498 = load i64, i64* %nargs22458, align 8
  %conv2467 = trunc i64 %498 to i8
  %conv2468 = sext i8 %conv2467 to i32
  %add2469 = add nsw i32 0, %conv2468
  %mul2470 = mul nsw i32 0, %add2469
  %sub2471 = sub nsw i32 %mul2470, 1
  %cmp2472 = icmp slt i32 %sub2471, 0
  br i1 %cmp2472, label %cond.true.2474, label %cond.false.2494

cond.true.2474:                                   ; preds = %cond.true.2466
  %499 = load i64, i64* %nargs22458, align 8
  %conv2475 = trunc i64 %499 to i8
  %conv2476 = sext i8 %conv2475 to i32
  %add2477 = add nsw i32 0, %conv2476
  %mul2478 = mul nsw i32 0, %add2477
  %add2479 = add nsw i32 %mul2478, 0
  %neg2480 = xor i32 %add2479, -1
  %cmp2481 = icmp eq i32 %neg2480, -1
  %conv2482 = zext i1 %cmp2481 to i32
  %sub2483 = sub nsw i32 0, %conv2482
  %500 = load i64, i64* %nargs22458, align 8
  %conv2484 = trunc i64 %500 to i8
  %conv2485 = sext i8 %conv2484 to i32
  %add2486 = add nsw i32 0, %conv2485
  %mul2487 = mul nsw i32 0, %add2486
  %add2488 = add nsw i32 %mul2487, 1
  %shl2489 = shl i32 %add2488, 30
  %sub2490 = sub nsw i32 %shl2489, 1
  %mul2491 = mul nsw i32 %sub2490, 2
  %add2492 = add nsw i32 %mul2491, 1
  %sub2493 = sub nsw i32 %sub2483, %add2492
  br label %cond.end.2500

cond.false.2494:                                  ; preds = %cond.true.2466
  %501 = load i64, i64* %nargs22458, align 8
  %conv2495 = trunc i64 %501 to i8
  %conv2496 = sext i8 %conv2495 to i32
  %add2497 = add nsw i32 0, %conv2496
  %mul2498 = mul nsw i32 0, %add2497
  %add2499 = add nsw i32 %mul2498, 0
  br label %cond.end.2500

cond.end.2500:                                    ; preds = %cond.false.2494, %cond.true.2474
  %cond2501 = phi i32 [ %sub2493, %cond.true.2474 ], [ %add2499, %cond.false.2494 ]
  %cmp2502 = icmp eq i32 %cond2501, 0
  br i1 %cmp2502, label %land.lhs.true.2504, label %lor.lhs.false.2509

land.lhs.true.2504:                               ; preds = %cond.end.2500
  %502 = load i64, i64* %nargs22458, align 8
  %conv2505 = trunc i64 %502 to i8
  %conv2506 = sext i8 %conv2505 to i32
  %cmp2507 = icmp slt i32 %conv2506, 0
  br i1 %cmp2507, label %cond.true.2688, label %lor.lhs.false.2509

lor.lhs.false.2509:                               ; preds = %land.lhs.true.2504, %cond.end.2500
  br i1 false, label %cond.true.2510, label %cond.false.2589

cond.true.2510:                                   ; preds = %lor.lhs.false.2509
  %503 = load i64, i64* %nargs22458, align 8
  %conv2511 = trunc i64 %503 to i8
  %conv2512 = sext i8 %conv2511 to i32
  %cmp2513 = icmp slt i32 %conv2512, 0
  br i1 %cmp2513, label %cond.true.2515, label %cond.false.2546

cond.true.2515:                                   ; preds = %cond.true.2510
  %504 = load i64, i64* %nargs22458, align 8
  %conv2516 = trunc i64 %504 to i8
  %conv2517 = sext i8 %conv2516 to i32
  %505 = load i64, i64* %nargs22458, align 8
  %conv2518 = trunc i64 %505 to i8
  %conv2519 = sext i8 %conv2518 to i32
  %add2520 = add nsw i32 0, %conv2519
  %mul2521 = mul nsw i32 0, %add2520
  %sub2522 = sub nsw i32 %mul2521, 1
  %cmp2523 = icmp slt i32 %sub2522, 0
  br i1 %cmp2523, label %cond.true.2525, label %cond.false.2535

cond.true.2525:                                   ; preds = %cond.true.2515
  %506 = load i64, i64* %nargs22458, align 8
  %conv2526 = trunc i64 %506 to i8
  %conv2527 = sext i8 %conv2526 to i32
  %add2528 = add nsw i32 0, %conv2527
  %mul2529 = mul nsw i32 0, %add2528
  %add2530 = add nsw i32 %mul2529, 1
  %shl2531 = shl i32 %add2530, 30
  %sub2532 = sub nsw i32 %shl2531, 1
  %mul2533 = mul nsw i32 %sub2532, 2
  %add2534 = add nsw i32 %mul2533, 1
  br label %cond.end.2541

cond.false.2535:                                  ; preds = %cond.true.2515
  %507 = load i64, i64* %nargs22458, align 8
  %conv2536 = trunc i64 %507 to i8
  %conv2537 = sext i8 %conv2536 to i32
  %add2538 = add nsw i32 0, %conv2537
  %mul2539 = mul nsw i32 0, %add2538
  %sub2540 = sub nsw i32 %mul2539, 1
  br label %cond.end.2541

cond.end.2541:                                    ; preds = %cond.false.2535, %cond.true.2525
  %cond2542 = phi i32 [ %add2534, %cond.true.2525 ], [ %sub2540, %cond.false.2535 ]
  %div2543 = sdiv i32 %cond2542, 8
  %cmp2544 = icmp slt i32 %conv2517, %div2543
  br i1 %cmp2544, label %cond.true.2688, label %lor.lhs.false.2668

cond.false.2546:                                  ; preds = %cond.true.2510
  br i1 false, label %cond.true.2547, label %cond.false.2548

cond.true.2547:                                   ; preds = %cond.false.2546
  br i1 false, label %cond.true.2688, label %lor.lhs.false.2668

cond.false.2548:                                  ; preds = %cond.false.2546
  %508 = load i64, i64* %nargs22458, align 8
  %conv2549 = trunc i64 %508 to i8
  %conv2550 = sext i8 %conv2549 to i32
  %add2551 = add nsw i32 0, %conv2550
  %mul2552 = mul nsw i32 0, %add2551
  %sub2553 = sub nsw i32 %mul2552, 1
  %cmp2554 = icmp slt i32 %sub2553, 0
  br i1 %cmp2554, label %cond.true.2556, label %cond.false.2576

cond.true.2556:                                   ; preds = %cond.false.2548
  %509 = load i64, i64* %nargs22458, align 8
  %conv2557 = trunc i64 %509 to i8
  %conv2558 = sext i8 %conv2557 to i32
  %add2559 = add nsw i32 0, %conv2558
  %mul2560 = mul nsw i32 0, %add2559
  %add2561 = add nsw i32 %mul2560, 0
  %neg2562 = xor i32 %add2561, -1
  %cmp2563 = icmp eq i32 %neg2562, -1
  %conv2564 = zext i1 %cmp2563 to i32
  %sub2565 = sub nsw i32 0, %conv2564
  %510 = load i64, i64* %nargs22458, align 8
  %conv2566 = trunc i64 %510 to i8
  %conv2567 = sext i8 %conv2566 to i32
  %add2568 = add nsw i32 0, %conv2567
  %mul2569 = mul nsw i32 0, %add2568
  %add2570 = add nsw i32 %mul2569, 1
  %shl2571 = shl i32 %add2570, 30
  %sub2572 = sub nsw i32 %shl2571, 1
  %mul2573 = mul nsw i32 %sub2572, 2
  %add2574 = add nsw i32 %mul2573, 1
  %sub2575 = sub nsw i32 %sub2565, %add2574
  br label %cond.end.2582

cond.false.2576:                                  ; preds = %cond.false.2548
  %511 = load i64, i64* %nargs22458, align 8
  %conv2577 = trunc i64 %511 to i8
  %conv2578 = sext i8 %conv2577 to i32
  %add2579 = add nsw i32 0, %conv2578
  %mul2580 = mul nsw i32 0, %add2579
  %add2581 = add nsw i32 %mul2580, 0
  br label %cond.end.2582

cond.end.2582:                                    ; preds = %cond.false.2576, %cond.true.2556
  %cond2583 = phi i32 [ %sub2575, %cond.true.2556 ], [ %add2581, %cond.false.2576 ]
  %div2584 = sdiv i32 %cond2583, 8
  %512 = load i64, i64* %nargs22458, align 8
  %conv2585 = trunc i64 %512 to i8
  %conv2586 = sext i8 %conv2585 to i32
  %cmp2587 = icmp slt i32 %div2584, %conv2586
  br i1 %cmp2587, label %cond.true.2688, label %lor.lhs.false.2668

cond.false.2589:                                  ; preds = %lor.lhs.false.2509
  br i1 false, label %cond.true.2590, label %cond.false.2591

cond.true.2590:                                   ; preds = %cond.false.2589
  br i1 false, label %cond.true.2688, label %lor.lhs.false.2668

cond.false.2591:                                  ; preds = %cond.false.2589
  %513 = load i64, i64* %nargs22458, align 8
  %conv2592 = trunc i64 %513 to i8
  %conv2593 = sext i8 %conv2592 to i32
  %cmp2594 = icmp slt i32 %conv2593, 0
  br i1 %cmp2594, label %cond.true.2596, label %cond.false.2637

cond.true.2596:                                   ; preds = %cond.false.2591
  %514 = load i64, i64* %nargs22458, align 8
  %conv2597 = trunc i64 %514 to i8
  %conv2598 = sext i8 %conv2597 to i32
  %515 = load i64, i64* %nargs22458, align 8
  %conv2599 = trunc i64 %515 to i8
  %conv2600 = sext i8 %conv2599 to i32
  %add2601 = add nsw i32 0, %conv2600
  %mul2602 = mul nsw i32 0, %add2601
  %sub2603 = sub nsw i32 %mul2602, 1
  %cmp2604 = icmp slt i32 %sub2603, 0
  br i1 %cmp2604, label %cond.true.2606, label %cond.false.2626

cond.true.2606:                                   ; preds = %cond.true.2596
  %516 = load i64, i64* %nargs22458, align 8
  %conv2607 = trunc i64 %516 to i8
  %conv2608 = sext i8 %conv2607 to i32
  %add2609 = add nsw i32 0, %conv2608
  %mul2610 = mul nsw i32 0, %add2609
  %add2611 = add nsw i32 %mul2610, 0
  %neg2612 = xor i32 %add2611, -1
  %cmp2613 = icmp eq i32 %neg2612, -1
  %conv2614 = zext i1 %cmp2613 to i32
  %sub2615 = sub nsw i32 0, %conv2614
  %517 = load i64, i64* %nargs22458, align 8
  %conv2616 = trunc i64 %517 to i8
  %conv2617 = sext i8 %conv2616 to i32
  %add2618 = add nsw i32 0, %conv2617
  %mul2619 = mul nsw i32 0, %add2618
  %add2620 = add nsw i32 %mul2619, 1
  %shl2621 = shl i32 %add2620, 30
  %sub2622 = sub nsw i32 %shl2621, 1
  %mul2623 = mul nsw i32 %sub2622, 2
  %add2624 = add nsw i32 %mul2623, 1
  %sub2625 = sub nsw i32 %sub2615, %add2624
  br label %cond.end.2632

cond.false.2626:                                  ; preds = %cond.true.2596
  %518 = load i64, i64* %nargs22458, align 8
  %conv2627 = trunc i64 %518 to i8
  %conv2628 = sext i8 %conv2627 to i32
  %add2629 = add nsw i32 0, %conv2628
  %mul2630 = mul nsw i32 0, %add2629
  %add2631 = add nsw i32 %mul2630, 0
  br label %cond.end.2632

cond.end.2632:                                    ; preds = %cond.false.2626, %cond.true.2606
  %cond2633 = phi i32 [ %sub2625, %cond.true.2606 ], [ %add2631, %cond.false.2626 ]
  %div2634 = sdiv i32 %cond2633, 8
  %cmp2635 = icmp slt i32 %conv2598, %div2634
  br i1 %cmp2635, label %cond.true.2688, label %lor.lhs.false.2668

cond.false.2637:                                  ; preds = %cond.false.2591
  %519 = load i64, i64* %nargs22458, align 8
  %conv2638 = trunc i64 %519 to i8
  %conv2639 = sext i8 %conv2638 to i32
  %add2640 = add nsw i32 0, %conv2639
  %mul2641 = mul nsw i32 0, %add2640
  %sub2642 = sub nsw i32 %mul2641, 1
  %cmp2643 = icmp slt i32 %sub2642, 0
  br i1 %cmp2643, label %cond.true.2645, label %cond.false.2655

cond.true.2645:                                   ; preds = %cond.false.2637
  %520 = load i64, i64* %nargs22458, align 8
  %conv2646 = trunc i64 %520 to i8
  %conv2647 = sext i8 %conv2646 to i32
  %add2648 = add nsw i32 0, %conv2647
  %mul2649 = mul nsw i32 0, %add2648
  %add2650 = add nsw i32 %mul2649, 1
  %shl2651 = shl i32 %add2650, 30
  %sub2652 = sub nsw i32 %shl2651, 1
  %mul2653 = mul nsw i32 %sub2652, 2
  %add2654 = add nsw i32 %mul2653, 1
  br label %cond.end.2661

cond.false.2655:                                  ; preds = %cond.false.2637
  %521 = load i64, i64* %nargs22458, align 8
  %conv2656 = trunc i64 %521 to i8
  %conv2657 = sext i8 %conv2656 to i32
  %add2658 = add nsw i32 0, %conv2657
  %mul2659 = mul nsw i32 0, %add2658
  %sub2660 = sub nsw i32 %mul2659, 1
  br label %cond.end.2661

cond.end.2661:                                    ; preds = %cond.false.2655, %cond.true.2645
  %cond2662 = phi i32 [ %add2654, %cond.true.2645 ], [ %sub2660, %cond.false.2655 ]
  %div2663 = sdiv i32 %cond2662, 8
  %522 = load i64, i64* %nargs22458, align 8
  %conv2664 = trunc i64 %522 to i8
  %conv2665 = sext i8 %conv2664 to i32
  %cmp2666 = icmp slt i32 %div2663, %conv2665
  br i1 %cmp2666, label %cond.true.2688, label %lor.lhs.false.2668

lor.lhs.false.2668:                               ; preds = %cond.end.2661, %cond.end.2632, %cond.true.2590, %cond.end.2582, %cond.true.2547, %cond.end.2541
  %523 = load i64, i64* %nargs22458, align 8
  %conv2669 = trunc i64 %523 to i8
  %conv2670 = sext i8 %conv2669 to i32
  %mul2671 = mul nsw i32 %conv2670, 8
  %mul2672 = mul nsw i32 0, %mul2671
  %sub2673 = sub nsw i32 %mul2672, 1
  %cmp2674 = icmp slt i32 %sub2673, 0
  br i1 %cmp2674, label %land.lhs.true.2676, label %lor.lhs.false.2682

land.lhs.true.2676:                               ; preds = %lor.lhs.false.2668
  %524 = load i64, i64* %nargs22458, align 8
  %conv2677 = trunc i64 %524 to i8
  %conv2678 = sext i8 %conv2677 to i32
  %mul2679 = mul nsw i32 %conv2678, 8
  %cmp2680 = icmp slt i32 %mul2679, -128
  br i1 %cmp2680, label %cond.true.2688, label %lor.lhs.false.2682

lor.lhs.false.2682:                               ; preds = %land.lhs.true.2676, %lor.lhs.false.2668
  %525 = load i64, i64* %nargs22458, align 8
  %conv2683 = trunc i64 %525 to i8
  %conv2684 = sext i8 %conv2683 to i32
  %mul2685 = mul nsw i32 %conv2684, 8
  %cmp2686 = icmp slt i32 127, %mul2685
  br i1 %cmp2686, label %cond.true.2688, label %cond.false.2711

cond.true.2688:                                   ; preds = %lor.lhs.false.2682, %land.lhs.true.2676, %cond.end.2661, %cond.end.2632, %cond.true.2590, %cond.end.2582, %cond.true.2547, %cond.end.2541, %land.lhs.true.2504
  %526 = load i64, i64* %nargs22458, align 8
  %conv2689 = trunc i64 %526 to i8
  %conv2690 = zext i8 %conv2689 to i32
  %mul2691 = mul nsw i32 %conv2690, 8
  %cmp2692 = icmp sle i32 %mul2691, 127
  br i1 %cmp2692, label %cond.true.2694, label %cond.false.2700

cond.true.2694:                                   ; preds = %cond.true.2688
  %527 = load i64, i64* %nargs22458, align 8
  %conv2695 = trunc i64 %527 to i8
  %conv2696 = zext i8 %conv2695 to i32
  %mul2697 = mul nsw i32 %conv2696, 8
  %conv2698 = trunc i32 %mul2697 to i8
  %conv2699 = sext i8 %conv2698 to i32
  br label %cond.end.2708

cond.false.2700:                                  ; preds = %cond.true.2688
  %528 = load i64, i64* %nargs22458, align 8
  %conv2701 = trunc i64 %528 to i8
  %conv2702 = zext i8 %conv2701 to i32
  %mul2703 = mul nsw i32 %conv2702, 8
  %sub2704 = sub nsw i32 %mul2703, -128
  %conv2705 = trunc i32 %sub2704 to i8
  %conv2706 = sext i8 %conv2705 to i32
  %add2707 = add nsw i32 %conv2706, -128
  br label %cond.end.2708

cond.end.2708:                                    ; preds = %cond.false.2700, %cond.true.2694
  %cond2709 = phi i32 [ %conv2699, %cond.true.2694 ], [ %add2707, %cond.false.2700 ]
  %conv2710 = sext i32 %cond2709 to i64
  store i64 %conv2710, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.2711:                                  ; preds = %lor.lhs.false.2682
  %529 = load i64, i64* %nargs22458, align 8
  %conv2712 = trunc i64 %529 to i8
  %conv2713 = zext i8 %conv2712 to i32
  %mul2714 = mul nsw i32 %conv2713, 8
  %cmp2715 = icmp sle i32 %mul2714, 127
  br i1 %cmp2715, label %cond.true.2717, label %cond.false.2723

cond.true.2717:                                   ; preds = %cond.false.2711
  %530 = load i64, i64* %nargs22458, align 8
  %conv2718 = trunc i64 %530 to i8
  %conv2719 = zext i8 %conv2718 to i32
  %mul2720 = mul nsw i32 %conv2719, 8
  %conv2721 = trunc i32 %mul2720 to i8
  %conv2722 = sext i8 %conv2721 to i32
  br label %cond.end.2731

cond.false.2723:                                  ; preds = %cond.false.2711
  %531 = load i64, i64* %nargs22458, align 8
  %conv2724 = trunc i64 %531 to i8
  %conv2725 = zext i8 %conv2724 to i32
  %mul2726 = mul nsw i32 %conv2725, 8
  %sub2727 = sub nsw i32 %mul2726, -128
  %conv2728 = trunc i32 %sub2727 to i8
  %conv2729 = sext i8 %conv2728 to i32
  %add2730 = add nsw i32 %conv2729, -128
  br label %cond.end.2731

cond.end.2731:                                    ; preds = %cond.false.2723, %cond.true.2717
  %cond2732 = phi i32 [ %conv2722, %cond.true.2717 ], [ %add2730, %cond.false.2723 ]
  %conv2733 = sext i32 %cond2732 to i64
  store i64 %conv2733, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.2734:                                  ; preds = %cond.true.2465
  %532 = load i64, i64* %nargs22458, align 8
  %add2735 = add nsw i64 0, %532
  %mul2736 = mul nsw i64 0, %add2735
  %sub2737 = sub nsw i64 %mul2736, 1
  %cmp2738 = icmp slt i64 %sub2737, 0
  br i1 %cmp2738, label %cond.true.2740, label %cond.false.2757

cond.true.2740:                                   ; preds = %cond.false.2734
  %533 = load i64, i64* %nargs22458, align 8
  %add2741 = add nsw i64 0, %533
  %mul2742 = mul nsw i64 0, %add2741
  %add2743 = add nsw i64 %mul2742, 0
  %neg2744 = xor i64 %add2743, -1
  %cmp2745 = icmp eq i64 %neg2744, -1
  %conv2746 = zext i1 %cmp2745 to i32
  %sub2747 = sub nsw i32 0, %conv2746
  %conv2748 = sext i32 %sub2747 to i64
  %534 = load i64, i64* %nargs22458, align 8
  %add2749 = add nsw i64 0, %534
  %mul2750 = mul nsw i64 0, %add2749
  %add2751 = add nsw i64 %mul2750, 1
  %shl2752 = shl i64 %add2751, 62
  %sub2753 = sub nsw i64 %shl2752, 1
  %mul2754 = mul nsw i64 %sub2753, 2
  %add2755 = add nsw i64 %mul2754, 1
  %sub2756 = sub nsw i64 %conv2748, %add2755
  br label %cond.end.2761

cond.false.2757:                                  ; preds = %cond.false.2734
  %535 = load i64, i64* %nargs22458, align 8
  %add2758 = add nsw i64 0, %535
  %mul2759 = mul nsw i64 0, %add2758
  %add2760 = add nsw i64 %mul2759, 0
  br label %cond.end.2761

cond.end.2761:                                    ; preds = %cond.false.2757, %cond.true.2740
  %cond2762 = phi i64 [ %sub2756, %cond.true.2740 ], [ %add2760, %cond.false.2757 ]
  %cmp2763 = icmp eq i64 %cond2762, 0
  br i1 %cmp2763, label %land.lhs.true.2765, label %lor.lhs.false.2768

land.lhs.true.2765:                               ; preds = %cond.end.2761
  %536 = load i64, i64* %nargs22458, align 8
  %cmp2766 = icmp slt i64 %536, 0
  br i1 %cmp2766, label %cond.true.2903, label %lor.lhs.false.2768

lor.lhs.false.2768:                               ; preds = %land.lhs.true.2765, %cond.end.2761
  br i1 false, label %cond.true.2769, label %cond.false.2829

cond.true.2769:                                   ; preds = %lor.lhs.false.2768
  %537 = load i64, i64* %nargs22458, align 8
  %cmp2770 = icmp slt i64 %537, 0
  br i1 %cmp2770, label %cond.true.2772, label %cond.false.2795

cond.true.2772:                                   ; preds = %cond.true.2769
  %538 = load i64, i64* %nargs22458, align 8
  %539 = load i64, i64* %nargs22458, align 8
  %add2773 = add nsw i64 0, %539
  %mul2774 = mul nsw i64 0, %add2773
  %sub2775 = sub nsw i64 %mul2774, 1
  %cmp2776 = icmp slt i64 %sub2775, 0
  br i1 %cmp2776, label %cond.true.2778, label %cond.false.2786

cond.true.2778:                                   ; preds = %cond.true.2772
  %540 = load i64, i64* %nargs22458, align 8
  %add2779 = add nsw i64 0, %540
  %mul2780 = mul nsw i64 0, %add2779
  %add2781 = add nsw i64 %mul2780, 1
  %shl2782 = shl i64 %add2781, 62
  %sub2783 = sub nsw i64 %shl2782, 1
  %mul2784 = mul nsw i64 %sub2783, 2
  %add2785 = add nsw i64 %mul2784, 1
  br label %cond.end.2790

cond.false.2786:                                  ; preds = %cond.true.2772
  %541 = load i64, i64* %nargs22458, align 8
  %add2787 = add nsw i64 0, %541
  %mul2788 = mul nsw i64 0, %add2787
  %sub2789 = sub nsw i64 %mul2788, 1
  br label %cond.end.2790

cond.end.2790:                                    ; preds = %cond.false.2786, %cond.true.2778
  %cond2791 = phi i64 [ %add2785, %cond.true.2778 ], [ %sub2789, %cond.false.2786 ]
  %div2792 = sdiv i64 %cond2791, 8
  %cmp2793 = icmp slt i64 %538, %div2792
  br i1 %cmp2793, label %cond.true.2903, label %lor.lhs.false.2889

cond.false.2795:                                  ; preds = %cond.true.2769
  br i1 false, label %cond.true.2796, label %cond.false.2797

cond.true.2796:                                   ; preds = %cond.false.2795
  br i1 false, label %cond.true.2903, label %lor.lhs.false.2889

cond.false.2797:                                  ; preds = %cond.false.2795
  %542 = load i64, i64* %nargs22458, align 8
  %add2798 = add nsw i64 0, %542
  %mul2799 = mul nsw i64 0, %add2798
  %sub2800 = sub nsw i64 %mul2799, 1
  %cmp2801 = icmp slt i64 %sub2800, 0
  br i1 %cmp2801, label %cond.true.2803, label %cond.false.2820

cond.true.2803:                                   ; preds = %cond.false.2797
  %543 = load i64, i64* %nargs22458, align 8
  %add2804 = add nsw i64 0, %543
  %mul2805 = mul nsw i64 0, %add2804
  %add2806 = add nsw i64 %mul2805, 0
  %neg2807 = xor i64 %add2806, -1
  %cmp2808 = icmp eq i64 %neg2807, -1
  %conv2809 = zext i1 %cmp2808 to i32
  %sub2810 = sub nsw i32 0, %conv2809
  %conv2811 = sext i32 %sub2810 to i64
  %544 = load i64, i64* %nargs22458, align 8
  %add2812 = add nsw i64 0, %544
  %mul2813 = mul nsw i64 0, %add2812
  %add2814 = add nsw i64 %mul2813, 1
  %shl2815 = shl i64 %add2814, 62
  %sub2816 = sub nsw i64 %shl2815, 1
  %mul2817 = mul nsw i64 %sub2816, 2
  %add2818 = add nsw i64 %mul2817, 1
  %sub2819 = sub nsw i64 %conv2811, %add2818
  br label %cond.end.2824

cond.false.2820:                                  ; preds = %cond.false.2797
  %545 = load i64, i64* %nargs22458, align 8
  %add2821 = add nsw i64 0, %545
  %mul2822 = mul nsw i64 0, %add2821
  %add2823 = add nsw i64 %mul2822, 0
  br label %cond.end.2824

cond.end.2824:                                    ; preds = %cond.false.2820, %cond.true.2803
  %cond2825 = phi i64 [ %sub2819, %cond.true.2803 ], [ %add2823, %cond.false.2820 ]
  %div2826 = sdiv i64 %cond2825, 8
  %546 = load i64, i64* %nargs22458, align 8
  %cmp2827 = icmp slt i64 %div2826, %546
  br i1 %cmp2827, label %cond.true.2903, label %lor.lhs.false.2889

cond.false.2829:                                  ; preds = %lor.lhs.false.2768
  br i1 false, label %cond.true.2830, label %cond.false.2831

cond.true.2830:                                   ; preds = %cond.false.2829
  br i1 false, label %cond.true.2903, label %lor.lhs.false.2889

cond.false.2831:                                  ; preds = %cond.false.2829
  %547 = load i64, i64* %nargs22458, align 8
  %cmp2832 = icmp slt i64 %547, 0
  br i1 %cmp2832, label %cond.true.2834, label %cond.false.2866

cond.true.2834:                                   ; preds = %cond.false.2831
  %548 = load i64, i64* %nargs22458, align 8
  %549 = load i64, i64* %nargs22458, align 8
  %add2835 = add nsw i64 0, %549
  %mul2836 = mul nsw i64 0, %add2835
  %sub2837 = sub nsw i64 %mul2836, 1
  %cmp2838 = icmp slt i64 %sub2837, 0
  br i1 %cmp2838, label %cond.true.2840, label %cond.false.2857

cond.true.2840:                                   ; preds = %cond.true.2834
  %550 = load i64, i64* %nargs22458, align 8
  %add2841 = add nsw i64 0, %550
  %mul2842 = mul nsw i64 0, %add2841
  %add2843 = add nsw i64 %mul2842, 0
  %neg2844 = xor i64 %add2843, -1
  %cmp2845 = icmp eq i64 %neg2844, -1
  %conv2846 = zext i1 %cmp2845 to i32
  %sub2847 = sub nsw i32 0, %conv2846
  %conv2848 = sext i32 %sub2847 to i64
  %551 = load i64, i64* %nargs22458, align 8
  %add2849 = add nsw i64 0, %551
  %mul2850 = mul nsw i64 0, %add2849
  %add2851 = add nsw i64 %mul2850, 1
  %shl2852 = shl i64 %add2851, 62
  %sub2853 = sub nsw i64 %shl2852, 1
  %mul2854 = mul nsw i64 %sub2853, 2
  %add2855 = add nsw i64 %mul2854, 1
  %sub2856 = sub nsw i64 %conv2848, %add2855
  br label %cond.end.2861

cond.false.2857:                                  ; preds = %cond.true.2834
  %552 = load i64, i64* %nargs22458, align 8
  %add2858 = add nsw i64 0, %552
  %mul2859 = mul nsw i64 0, %add2858
  %add2860 = add nsw i64 %mul2859, 0
  br label %cond.end.2861

cond.end.2861:                                    ; preds = %cond.false.2857, %cond.true.2840
  %cond2862 = phi i64 [ %sub2856, %cond.true.2840 ], [ %add2860, %cond.false.2857 ]
  %div2863 = sdiv i64 %cond2862, 8
  %cmp2864 = icmp slt i64 %548, %div2863
  br i1 %cmp2864, label %cond.true.2903, label %lor.lhs.false.2889

cond.false.2866:                                  ; preds = %cond.false.2831
  %553 = load i64, i64* %nargs22458, align 8
  %add2867 = add nsw i64 0, %553
  %mul2868 = mul nsw i64 0, %add2867
  %sub2869 = sub nsw i64 %mul2868, 1
  %cmp2870 = icmp slt i64 %sub2869, 0
  br i1 %cmp2870, label %cond.true.2872, label %cond.false.2880

cond.true.2872:                                   ; preds = %cond.false.2866
  %554 = load i64, i64* %nargs22458, align 8
  %add2873 = add nsw i64 0, %554
  %mul2874 = mul nsw i64 0, %add2873
  %add2875 = add nsw i64 %mul2874, 1
  %shl2876 = shl i64 %add2875, 62
  %sub2877 = sub nsw i64 %shl2876, 1
  %mul2878 = mul nsw i64 %sub2877, 2
  %add2879 = add nsw i64 %mul2878, 1
  br label %cond.end.2884

cond.false.2880:                                  ; preds = %cond.false.2866
  %555 = load i64, i64* %nargs22458, align 8
  %add2881 = add nsw i64 0, %555
  %mul2882 = mul nsw i64 0, %add2881
  %sub2883 = sub nsw i64 %mul2882, 1
  br label %cond.end.2884

cond.end.2884:                                    ; preds = %cond.false.2880, %cond.true.2872
  %cond2885 = phi i64 [ %add2879, %cond.true.2872 ], [ %sub2883, %cond.false.2880 ]
  %div2886 = sdiv i64 %cond2885, 8
  %556 = load i64, i64* %nargs22458, align 8
  %cmp2887 = icmp slt i64 %div2886, %556
  br i1 %cmp2887, label %cond.true.2903, label %lor.lhs.false.2889

lor.lhs.false.2889:                               ; preds = %cond.end.2884, %cond.end.2861, %cond.true.2830, %cond.end.2824, %cond.true.2796, %cond.end.2790
  %557 = load i64, i64* %nargs22458, align 8
  %mul2890 = mul nsw i64 %557, 8
  %mul2891 = mul nsw i64 0, %mul2890
  %sub2892 = sub nsw i64 %mul2891, 1
  %cmp2893 = icmp slt i64 %sub2892, 0
  br i1 %cmp2893, label %land.lhs.true.2895, label %lor.lhs.false.2899

land.lhs.true.2895:                               ; preds = %lor.lhs.false.2889
  %558 = load i64, i64* %nargs22458, align 8
  %mul2896 = mul nsw i64 %558, 8
  %cmp2897 = icmp slt i64 %mul2896, -128
  br i1 %cmp2897, label %cond.true.2903, label %lor.lhs.false.2899

lor.lhs.false.2899:                               ; preds = %land.lhs.true.2895, %lor.lhs.false.2889
  %559 = load i64, i64* %nargs22458, align 8
  %mul2900 = mul nsw i64 %559, 8
  %cmp2901 = icmp slt i64 127, %mul2900
  br i1 %cmp2901, label %cond.true.2903, label %cond.false.2926

cond.true.2903:                                   ; preds = %lor.lhs.false.2899, %land.lhs.true.2895, %cond.end.2884, %cond.end.2861, %cond.true.2830, %cond.end.2824, %cond.true.2796, %cond.end.2790, %land.lhs.true.2765
  %560 = load i64, i64* %nargs22458, align 8
  %conv2904 = trunc i64 %560 to i8
  %conv2905 = zext i8 %conv2904 to i32
  %mul2906 = mul nsw i32 %conv2905, 8
  %cmp2907 = icmp sle i32 %mul2906, 127
  br i1 %cmp2907, label %cond.true.2909, label %cond.false.2915

cond.true.2909:                                   ; preds = %cond.true.2903
  %561 = load i64, i64* %nargs22458, align 8
  %conv2910 = trunc i64 %561 to i8
  %conv2911 = zext i8 %conv2910 to i32
  %mul2912 = mul nsw i32 %conv2911, 8
  %conv2913 = trunc i32 %mul2912 to i8
  %conv2914 = sext i8 %conv2913 to i32
  br label %cond.end.2923

cond.false.2915:                                  ; preds = %cond.true.2903
  %562 = load i64, i64* %nargs22458, align 8
  %conv2916 = trunc i64 %562 to i8
  %conv2917 = zext i8 %conv2916 to i32
  %mul2918 = mul nsw i32 %conv2917, 8
  %sub2919 = sub nsw i32 %mul2918, -128
  %conv2920 = trunc i32 %sub2919 to i8
  %conv2921 = sext i8 %conv2920 to i32
  %add2922 = add nsw i32 %conv2921, -128
  br label %cond.end.2923

cond.end.2923:                                    ; preds = %cond.false.2915, %cond.true.2909
  %cond2924 = phi i32 [ %conv2914, %cond.true.2909 ], [ %add2922, %cond.false.2915 ]
  %conv2925 = sext i32 %cond2924 to i64
  store i64 %conv2925, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.2926:                                  ; preds = %lor.lhs.false.2899
  %563 = load i64, i64* %nargs22458, align 8
  %conv2927 = trunc i64 %563 to i8
  %conv2928 = zext i8 %conv2927 to i32
  %mul2929 = mul nsw i32 %conv2928, 8
  %cmp2930 = icmp sle i32 %mul2929, 127
  br i1 %cmp2930, label %cond.true.2932, label %cond.false.2938

cond.true.2932:                                   ; preds = %cond.false.2926
  %564 = load i64, i64* %nargs22458, align 8
  %conv2933 = trunc i64 %564 to i8
  %conv2934 = zext i8 %conv2933 to i32
  %mul2935 = mul nsw i32 %conv2934, 8
  %conv2936 = trunc i32 %mul2935 to i8
  %conv2937 = sext i8 %conv2936 to i32
  br label %cond.end.2946

cond.false.2938:                                  ; preds = %cond.false.2926
  %565 = load i64, i64* %nargs22458, align 8
  %conv2939 = trunc i64 %565 to i8
  %conv2940 = zext i8 %conv2939 to i32
  %mul2941 = mul nsw i32 %conv2940, 8
  %sub2942 = sub nsw i32 %mul2941, -128
  %conv2943 = trunc i32 %sub2942 to i8
  %conv2944 = sext i8 %conv2943 to i32
  %add2945 = add nsw i32 %conv2944, -128
  br label %cond.end.2946

cond.end.2946:                                    ; preds = %cond.false.2938, %cond.true.2932
  %cond2947 = phi i32 [ %conv2937, %cond.true.2932 ], [ %add2945, %cond.false.2938 ]
  %conv2948 = sext i32 %cond2947 to i64
  store i64 %conv2948, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.2949:                                  ; preds = %do.body.2463
  br i1 false, label %cond.true.2950, label %cond.false.3434

cond.true.2950:                                   ; preds = %cond.false.2949
  br i1 false, label %cond.true.2951, label %cond.false.3219

cond.true.2951:                                   ; preds = %cond.true.2950
  %566 = load i64, i64* %nargs22458, align 8
  %conv2952 = trunc i64 %566 to i16
  %conv2953 = sext i16 %conv2952 to i32
  %add2954 = add nsw i32 0, %conv2953
  %mul2955 = mul nsw i32 0, %add2954
  %sub2956 = sub nsw i32 %mul2955, 1
  %cmp2957 = icmp slt i32 %sub2956, 0
  br i1 %cmp2957, label %cond.true.2959, label %cond.false.2979

cond.true.2959:                                   ; preds = %cond.true.2951
  %567 = load i64, i64* %nargs22458, align 8
  %conv2960 = trunc i64 %567 to i16
  %conv2961 = sext i16 %conv2960 to i32
  %add2962 = add nsw i32 0, %conv2961
  %mul2963 = mul nsw i32 0, %add2962
  %add2964 = add nsw i32 %mul2963, 0
  %neg2965 = xor i32 %add2964, -1
  %cmp2966 = icmp eq i32 %neg2965, -1
  %conv2967 = zext i1 %cmp2966 to i32
  %sub2968 = sub nsw i32 0, %conv2967
  %568 = load i64, i64* %nargs22458, align 8
  %conv2969 = trunc i64 %568 to i16
  %conv2970 = sext i16 %conv2969 to i32
  %add2971 = add nsw i32 0, %conv2970
  %mul2972 = mul nsw i32 0, %add2971
  %add2973 = add nsw i32 %mul2972, 1
  %shl2974 = shl i32 %add2973, 30
  %sub2975 = sub nsw i32 %shl2974, 1
  %mul2976 = mul nsw i32 %sub2975, 2
  %add2977 = add nsw i32 %mul2976, 1
  %sub2978 = sub nsw i32 %sub2968, %add2977
  br label %cond.end.2985

cond.false.2979:                                  ; preds = %cond.true.2951
  %569 = load i64, i64* %nargs22458, align 8
  %conv2980 = trunc i64 %569 to i16
  %conv2981 = sext i16 %conv2980 to i32
  %add2982 = add nsw i32 0, %conv2981
  %mul2983 = mul nsw i32 0, %add2982
  %add2984 = add nsw i32 %mul2983, 0
  br label %cond.end.2985

cond.end.2985:                                    ; preds = %cond.false.2979, %cond.true.2959
  %cond2986 = phi i32 [ %sub2978, %cond.true.2959 ], [ %add2984, %cond.false.2979 ]
  %cmp2987 = icmp eq i32 %cond2986, 0
  br i1 %cmp2987, label %land.lhs.true.2989, label %lor.lhs.false.2994

land.lhs.true.2989:                               ; preds = %cond.end.2985
  %570 = load i64, i64* %nargs22458, align 8
  %conv2990 = trunc i64 %570 to i16
  %conv2991 = sext i16 %conv2990 to i32
  %cmp2992 = icmp slt i32 %conv2991, 0
  br i1 %cmp2992, label %cond.true.3173, label %lor.lhs.false.2994

lor.lhs.false.2994:                               ; preds = %land.lhs.true.2989, %cond.end.2985
  br i1 false, label %cond.true.2995, label %cond.false.3074

cond.true.2995:                                   ; preds = %lor.lhs.false.2994
  %571 = load i64, i64* %nargs22458, align 8
  %conv2996 = trunc i64 %571 to i16
  %conv2997 = sext i16 %conv2996 to i32
  %cmp2998 = icmp slt i32 %conv2997, 0
  br i1 %cmp2998, label %cond.true.3000, label %cond.false.3031

cond.true.3000:                                   ; preds = %cond.true.2995
  %572 = load i64, i64* %nargs22458, align 8
  %conv3001 = trunc i64 %572 to i16
  %conv3002 = sext i16 %conv3001 to i32
  %573 = load i64, i64* %nargs22458, align 8
  %conv3003 = trunc i64 %573 to i16
  %conv3004 = sext i16 %conv3003 to i32
  %add3005 = add nsw i32 0, %conv3004
  %mul3006 = mul nsw i32 0, %add3005
  %sub3007 = sub nsw i32 %mul3006, 1
  %cmp3008 = icmp slt i32 %sub3007, 0
  br i1 %cmp3008, label %cond.true.3010, label %cond.false.3020

cond.true.3010:                                   ; preds = %cond.true.3000
  %574 = load i64, i64* %nargs22458, align 8
  %conv3011 = trunc i64 %574 to i16
  %conv3012 = sext i16 %conv3011 to i32
  %add3013 = add nsw i32 0, %conv3012
  %mul3014 = mul nsw i32 0, %add3013
  %add3015 = add nsw i32 %mul3014, 1
  %shl3016 = shl i32 %add3015, 30
  %sub3017 = sub nsw i32 %shl3016, 1
  %mul3018 = mul nsw i32 %sub3017, 2
  %add3019 = add nsw i32 %mul3018, 1
  br label %cond.end.3026

cond.false.3020:                                  ; preds = %cond.true.3000
  %575 = load i64, i64* %nargs22458, align 8
  %conv3021 = trunc i64 %575 to i16
  %conv3022 = sext i16 %conv3021 to i32
  %add3023 = add nsw i32 0, %conv3022
  %mul3024 = mul nsw i32 0, %add3023
  %sub3025 = sub nsw i32 %mul3024, 1
  br label %cond.end.3026

cond.end.3026:                                    ; preds = %cond.false.3020, %cond.true.3010
  %cond3027 = phi i32 [ %add3019, %cond.true.3010 ], [ %sub3025, %cond.false.3020 ]
  %div3028 = sdiv i32 %cond3027, 8
  %cmp3029 = icmp slt i32 %conv3002, %div3028
  br i1 %cmp3029, label %cond.true.3173, label %lor.lhs.false.3153

cond.false.3031:                                  ; preds = %cond.true.2995
  br i1 false, label %cond.true.3032, label %cond.false.3033

cond.true.3032:                                   ; preds = %cond.false.3031
  br i1 false, label %cond.true.3173, label %lor.lhs.false.3153

cond.false.3033:                                  ; preds = %cond.false.3031
  %576 = load i64, i64* %nargs22458, align 8
  %conv3034 = trunc i64 %576 to i16
  %conv3035 = sext i16 %conv3034 to i32
  %add3036 = add nsw i32 0, %conv3035
  %mul3037 = mul nsw i32 0, %add3036
  %sub3038 = sub nsw i32 %mul3037, 1
  %cmp3039 = icmp slt i32 %sub3038, 0
  br i1 %cmp3039, label %cond.true.3041, label %cond.false.3061

cond.true.3041:                                   ; preds = %cond.false.3033
  %577 = load i64, i64* %nargs22458, align 8
  %conv3042 = trunc i64 %577 to i16
  %conv3043 = sext i16 %conv3042 to i32
  %add3044 = add nsw i32 0, %conv3043
  %mul3045 = mul nsw i32 0, %add3044
  %add3046 = add nsw i32 %mul3045, 0
  %neg3047 = xor i32 %add3046, -1
  %cmp3048 = icmp eq i32 %neg3047, -1
  %conv3049 = zext i1 %cmp3048 to i32
  %sub3050 = sub nsw i32 0, %conv3049
  %578 = load i64, i64* %nargs22458, align 8
  %conv3051 = trunc i64 %578 to i16
  %conv3052 = sext i16 %conv3051 to i32
  %add3053 = add nsw i32 0, %conv3052
  %mul3054 = mul nsw i32 0, %add3053
  %add3055 = add nsw i32 %mul3054, 1
  %shl3056 = shl i32 %add3055, 30
  %sub3057 = sub nsw i32 %shl3056, 1
  %mul3058 = mul nsw i32 %sub3057, 2
  %add3059 = add nsw i32 %mul3058, 1
  %sub3060 = sub nsw i32 %sub3050, %add3059
  br label %cond.end.3067

cond.false.3061:                                  ; preds = %cond.false.3033
  %579 = load i64, i64* %nargs22458, align 8
  %conv3062 = trunc i64 %579 to i16
  %conv3063 = sext i16 %conv3062 to i32
  %add3064 = add nsw i32 0, %conv3063
  %mul3065 = mul nsw i32 0, %add3064
  %add3066 = add nsw i32 %mul3065, 0
  br label %cond.end.3067

cond.end.3067:                                    ; preds = %cond.false.3061, %cond.true.3041
  %cond3068 = phi i32 [ %sub3060, %cond.true.3041 ], [ %add3066, %cond.false.3061 ]
  %div3069 = sdiv i32 %cond3068, 8
  %580 = load i64, i64* %nargs22458, align 8
  %conv3070 = trunc i64 %580 to i16
  %conv3071 = sext i16 %conv3070 to i32
  %cmp3072 = icmp slt i32 %div3069, %conv3071
  br i1 %cmp3072, label %cond.true.3173, label %lor.lhs.false.3153

cond.false.3074:                                  ; preds = %lor.lhs.false.2994
  br i1 false, label %cond.true.3075, label %cond.false.3076

cond.true.3075:                                   ; preds = %cond.false.3074
  br i1 false, label %cond.true.3173, label %lor.lhs.false.3153

cond.false.3076:                                  ; preds = %cond.false.3074
  %581 = load i64, i64* %nargs22458, align 8
  %conv3077 = trunc i64 %581 to i16
  %conv3078 = sext i16 %conv3077 to i32
  %cmp3079 = icmp slt i32 %conv3078, 0
  br i1 %cmp3079, label %cond.true.3081, label %cond.false.3122

cond.true.3081:                                   ; preds = %cond.false.3076
  %582 = load i64, i64* %nargs22458, align 8
  %conv3082 = trunc i64 %582 to i16
  %conv3083 = sext i16 %conv3082 to i32
  %583 = load i64, i64* %nargs22458, align 8
  %conv3084 = trunc i64 %583 to i16
  %conv3085 = sext i16 %conv3084 to i32
  %add3086 = add nsw i32 0, %conv3085
  %mul3087 = mul nsw i32 0, %add3086
  %sub3088 = sub nsw i32 %mul3087, 1
  %cmp3089 = icmp slt i32 %sub3088, 0
  br i1 %cmp3089, label %cond.true.3091, label %cond.false.3111

cond.true.3091:                                   ; preds = %cond.true.3081
  %584 = load i64, i64* %nargs22458, align 8
  %conv3092 = trunc i64 %584 to i16
  %conv3093 = sext i16 %conv3092 to i32
  %add3094 = add nsw i32 0, %conv3093
  %mul3095 = mul nsw i32 0, %add3094
  %add3096 = add nsw i32 %mul3095, 0
  %neg3097 = xor i32 %add3096, -1
  %cmp3098 = icmp eq i32 %neg3097, -1
  %conv3099 = zext i1 %cmp3098 to i32
  %sub3100 = sub nsw i32 0, %conv3099
  %585 = load i64, i64* %nargs22458, align 8
  %conv3101 = trunc i64 %585 to i16
  %conv3102 = sext i16 %conv3101 to i32
  %add3103 = add nsw i32 0, %conv3102
  %mul3104 = mul nsw i32 0, %add3103
  %add3105 = add nsw i32 %mul3104, 1
  %shl3106 = shl i32 %add3105, 30
  %sub3107 = sub nsw i32 %shl3106, 1
  %mul3108 = mul nsw i32 %sub3107, 2
  %add3109 = add nsw i32 %mul3108, 1
  %sub3110 = sub nsw i32 %sub3100, %add3109
  br label %cond.end.3117

cond.false.3111:                                  ; preds = %cond.true.3081
  %586 = load i64, i64* %nargs22458, align 8
  %conv3112 = trunc i64 %586 to i16
  %conv3113 = sext i16 %conv3112 to i32
  %add3114 = add nsw i32 0, %conv3113
  %mul3115 = mul nsw i32 0, %add3114
  %add3116 = add nsw i32 %mul3115, 0
  br label %cond.end.3117

cond.end.3117:                                    ; preds = %cond.false.3111, %cond.true.3091
  %cond3118 = phi i32 [ %sub3110, %cond.true.3091 ], [ %add3116, %cond.false.3111 ]
  %div3119 = sdiv i32 %cond3118, 8
  %cmp3120 = icmp slt i32 %conv3083, %div3119
  br i1 %cmp3120, label %cond.true.3173, label %lor.lhs.false.3153

cond.false.3122:                                  ; preds = %cond.false.3076
  %587 = load i64, i64* %nargs22458, align 8
  %conv3123 = trunc i64 %587 to i16
  %conv3124 = sext i16 %conv3123 to i32
  %add3125 = add nsw i32 0, %conv3124
  %mul3126 = mul nsw i32 0, %add3125
  %sub3127 = sub nsw i32 %mul3126, 1
  %cmp3128 = icmp slt i32 %sub3127, 0
  br i1 %cmp3128, label %cond.true.3130, label %cond.false.3140

cond.true.3130:                                   ; preds = %cond.false.3122
  %588 = load i64, i64* %nargs22458, align 8
  %conv3131 = trunc i64 %588 to i16
  %conv3132 = sext i16 %conv3131 to i32
  %add3133 = add nsw i32 0, %conv3132
  %mul3134 = mul nsw i32 0, %add3133
  %add3135 = add nsw i32 %mul3134, 1
  %shl3136 = shl i32 %add3135, 30
  %sub3137 = sub nsw i32 %shl3136, 1
  %mul3138 = mul nsw i32 %sub3137, 2
  %add3139 = add nsw i32 %mul3138, 1
  br label %cond.end.3146

cond.false.3140:                                  ; preds = %cond.false.3122
  %589 = load i64, i64* %nargs22458, align 8
  %conv3141 = trunc i64 %589 to i16
  %conv3142 = sext i16 %conv3141 to i32
  %add3143 = add nsw i32 0, %conv3142
  %mul3144 = mul nsw i32 0, %add3143
  %sub3145 = sub nsw i32 %mul3144, 1
  br label %cond.end.3146

cond.end.3146:                                    ; preds = %cond.false.3140, %cond.true.3130
  %cond3147 = phi i32 [ %add3139, %cond.true.3130 ], [ %sub3145, %cond.false.3140 ]
  %div3148 = sdiv i32 %cond3147, 8
  %590 = load i64, i64* %nargs22458, align 8
  %conv3149 = trunc i64 %590 to i16
  %conv3150 = sext i16 %conv3149 to i32
  %cmp3151 = icmp slt i32 %div3148, %conv3150
  br i1 %cmp3151, label %cond.true.3173, label %lor.lhs.false.3153

lor.lhs.false.3153:                               ; preds = %cond.end.3146, %cond.end.3117, %cond.true.3075, %cond.end.3067, %cond.true.3032, %cond.end.3026
  %591 = load i64, i64* %nargs22458, align 8
  %conv3154 = trunc i64 %591 to i16
  %conv3155 = sext i16 %conv3154 to i32
  %mul3156 = mul nsw i32 %conv3155, 8
  %mul3157 = mul nsw i32 0, %mul3156
  %sub3158 = sub nsw i32 %mul3157, 1
  %cmp3159 = icmp slt i32 %sub3158, 0
  br i1 %cmp3159, label %land.lhs.true.3161, label %lor.lhs.false.3167

land.lhs.true.3161:                               ; preds = %lor.lhs.false.3153
  %592 = load i64, i64* %nargs22458, align 8
  %conv3162 = trunc i64 %592 to i16
  %conv3163 = sext i16 %conv3162 to i32
  %mul3164 = mul nsw i32 %conv3163, 8
  %cmp3165 = icmp slt i32 %mul3164, -32768
  br i1 %cmp3165, label %cond.true.3173, label %lor.lhs.false.3167

lor.lhs.false.3167:                               ; preds = %land.lhs.true.3161, %lor.lhs.false.3153
  %593 = load i64, i64* %nargs22458, align 8
  %conv3168 = trunc i64 %593 to i16
  %conv3169 = sext i16 %conv3168 to i32
  %mul3170 = mul nsw i32 %conv3169, 8
  %cmp3171 = icmp slt i32 32767, %mul3170
  br i1 %cmp3171, label %cond.true.3173, label %cond.false.3196

cond.true.3173:                                   ; preds = %lor.lhs.false.3167, %land.lhs.true.3161, %cond.end.3146, %cond.end.3117, %cond.true.3075, %cond.end.3067, %cond.true.3032, %cond.end.3026, %land.lhs.true.2989
  %594 = load i64, i64* %nargs22458, align 8
  %conv3174 = trunc i64 %594 to i16
  %conv3175 = zext i16 %conv3174 to i32
  %mul3176 = mul nsw i32 %conv3175, 8
  %cmp3177 = icmp sle i32 %mul3176, 32767
  br i1 %cmp3177, label %cond.true.3179, label %cond.false.3185

cond.true.3179:                                   ; preds = %cond.true.3173
  %595 = load i64, i64* %nargs22458, align 8
  %conv3180 = trunc i64 %595 to i16
  %conv3181 = zext i16 %conv3180 to i32
  %mul3182 = mul nsw i32 %conv3181, 8
  %conv3183 = trunc i32 %mul3182 to i16
  %conv3184 = sext i16 %conv3183 to i32
  br label %cond.end.3193

cond.false.3185:                                  ; preds = %cond.true.3173
  %596 = load i64, i64* %nargs22458, align 8
  %conv3186 = trunc i64 %596 to i16
  %conv3187 = zext i16 %conv3186 to i32
  %mul3188 = mul nsw i32 %conv3187, 8
  %sub3189 = sub nsw i32 %mul3188, -32768
  %conv3190 = trunc i32 %sub3189 to i16
  %conv3191 = sext i16 %conv3190 to i32
  %add3192 = add nsw i32 %conv3191, -32768
  br label %cond.end.3193

cond.end.3193:                                    ; preds = %cond.false.3185, %cond.true.3179
  %cond3194 = phi i32 [ %conv3184, %cond.true.3179 ], [ %add3192, %cond.false.3185 ]
  %conv3195 = sext i32 %cond3194 to i64
  store i64 %conv3195, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3196:                                  ; preds = %lor.lhs.false.3167
  %597 = load i64, i64* %nargs22458, align 8
  %conv3197 = trunc i64 %597 to i16
  %conv3198 = zext i16 %conv3197 to i32
  %mul3199 = mul nsw i32 %conv3198, 8
  %cmp3200 = icmp sle i32 %mul3199, 32767
  br i1 %cmp3200, label %cond.true.3202, label %cond.false.3208

cond.true.3202:                                   ; preds = %cond.false.3196
  %598 = load i64, i64* %nargs22458, align 8
  %conv3203 = trunc i64 %598 to i16
  %conv3204 = zext i16 %conv3203 to i32
  %mul3205 = mul nsw i32 %conv3204, 8
  %conv3206 = trunc i32 %mul3205 to i16
  %conv3207 = sext i16 %conv3206 to i32
  br label %cond.end.3216

cond.false.3208:                                  ; preds = %cond.false.3196
  %599 = load i64, i64* %nargs22458, align 8
  %conv3209 = trunc i64 %599 to i16
  %conv3210 = zext i16 %conv3209 to i32
  %mul3211 = mul nsw i32 %conv3210, 8
  %sub3212 = sub nsw i32 %mul3211, -32768
  %conv3213 = trunc i32 %sub3212 to i16
  %conv3214 = sext i16 %conv3213 to i32
  %add3215 = add nsw i32 %conv3214, -32768
  br label %cond.end.3216

cond.end.3216:                                    ; preds = %cond.false.3208, %cond.true.3202
  %cond3217 = phi i32 [ %conv3207, %cond.true.3202 ], [ %add3215, %cond.false.3208 ]
  %conv3218 = sext i32 %cond3217 to i64
  store i64 %conv3218, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3219:                                  ; preds = %cond.true.2950
  %600 = load i64, i64* %nargs22458, align 8
  %add3220 = add nsw i64 0, %600
  %mul3221 = mul nsw i64 0, %add3220
  %sub3222 = sub nsw i64 %mul3221, 1
  %cmp3223 = icmp slt i64 %sub3222, 0
  br i1 %cmp3223, label %cond.true.3225, label %cond.false.3242

cond.true.3225:                                   ; preds = %cond.false.3219
  %601 = load i64, i64* %nargs22458, align 8
  %add3226 = add nsw i64 0, %601
  %mul3227 = mul nsw i64 0, %add3226
  %add3228 = add nsw i64 %mul3227, 0
  %neg3229 = xor i64 %add3228, -1
  %cmp3230 = icmp eq i64 %neg3229, -1
  %conv3231 = zext i1 %cmp3230 to i32
  %sub3232 = sub nsw i32 0, %conv3231
  %conv3233 = sext i32 %sub3232 to i64
  %602 = load i64, i64* %nargs22458, align 8
  %add3234 = add nsw i64 0, %602
  %mul3235 = mul nsw i64 0, %add3234
  %add3236 = add nsw i64 %mul3235, 1
  %shl3237 = shl i64 %add3236, 62
  %sub3238 = sub nsw i64 %shl3237, 1
  %mul3239 = mul nsw i64 %sub3238, 2
  %add3240 = add nsw i64 %mul3239, 1
  %sub3241 = sub nsw i64 %conv3233, %add3240
  br label %cond.end.3246

cond.false.3242:                                  ; preds = %cond.false.3219
  %603 = load i64, i64* %nargs22458, align 8
  %add3243 = add nsw i64 0, %603
  %mul3244 = mul nsw i64 0, %add3243
  %add3245 = add nsw i64 %mul3244, 0
  br label %cond.end.3246

cond.end.3246:                                    ; preds = %cond.false.3242, %cond.true.3225
  %cond3247 = phi i64 [ %sub3241, %cond.true.3225 ], [ %add3245, %cond.false.3242 ]
  %cmp3248 = icmp eq i64 %cond3247, 0
  br i1 %cmp3248, label %land.lhs.true.3250, label %lor.lhs.false.3253

land.lhs.true.3250:                               ; preds = %cond.end.3246
  %604 = load i64, i64* %nargs22458, align 8
  %cmp3251 = icmp slt i64 %604, 0
  br i1 %cmp3251, label %cond.true.3388, label %lor.lhs.false.3253

lor.lhs.false.3253:                               ; preds = %land.lhs.true.3250, %cond.end.3246
  br i1 false, label %cond.true.3254, label %cond.false.3314

cond.true.3254:                                   ; preds = %lor.lhs.false.3253
  %605 = load i64, i64* %nargs22458, align 8
  %cmp3255 = icmp slt i64 %605, 0
  br i1 %cmp3255, label %cond.true.3257, label %cond.false.3280

cond.true.3257:                                   ; preds = %cond.true.3254
  %606 = load i64, i64* %nargs22458, align 8
  %607 = load i64, i64* %nargs22458, align 8
  %add3258 = add nsw i64 0, %607
  %mul3259 = mul nsw i64 0, %add3258
  %sub3260 = sub nsw i64 %mul3259, 1
  %cmp3261 = icmp slt i64 %sub3260, 0
  br i1 %cmp3261, label %cond.true.3263, label %cond.false.3271

cond.true.3263:                                   ; preds = %cond.true.3257
  %608 = load i64, i64* %nargs22458, align 8
  %add3264 = add nsw i64 0, %608
  %mul3265 = mul nsw i64 0, %add3264
  %add3266 = add nsw i64 %mul3265, 1
  %shl3267 = shl i64 %add3266, 62
  %sub3268 = sub nsw i64 %shl3267, 1
  %mul3269 = mul nsw i64 %sub3268, 2
  %add3270 = add nsw i64 %mul3269, 1
  br label %cond.end.3275

cond.false.3271:                                  ; preds = %cond.true.3257
  %609 = load i64, i64* %nargs22458, align 8
  %add3272 = add nsw i64 0, %609
  %mul3273 = mul nsw i64 0, %add3272
  %sub3274 = sub nsw i64 %mul3273, 1
  br label %cond.end.3275

cond.end.3275:                                    ; preds = %cond.false.3271, %cond.true.3263
  %cond3276 = phi i64 [ %add3270, %cond.true.3263 ], [ %sub3274, %cond.false.3271 ]
  %div3277 = sdiv i64 %cond3276, 8
  %cmp3278 = icmp slt i64 %606, %div3277
  br i1 %cmp3278, label %cond.true.3388, label %lor.lhs.false.3374

cond.false.3280:                                  ; preds = %cond.true.3254
  br i1 false, label %cond.true.3281, label %cond.false.3282

cond.true.3281:                                   ; preds = %cond.false.3280
  br i1 false, label %cond.true.3388, label %lor.lhs.false.3374

cond.false.3282:                                  ; preds = %cond.false.3280
  %610 = load i64, i64* %nargs22458, align 8
  %add3283 = add nsw i64 0, %610
  %mul3284 = mul nsw i64 0, %add3283
  %sub3285 = sub nsw i64 %mul3284, 1
  %cmp3286 = icmp slt i64 %sub3285, 0
  br i1 %cmp3286, label %cond.true.3288, label %cond.false.3305

cond.true.3288:                                   ; preds = %cond.false.3282
  %611 = load i64, i64* %nargs22458, align 8
  %add3289 = add nsw i64 0, %611
  %mul3290 = mul nsw i64 0, %add3289
  %add3291 = add nsw i64 %mul3290, 0
  %neg3292 = xor i64 %add3291, -1
  %cmp3293 = icmp eq i64 %neg3292, -1
  %conv3294 = zext i1 %cmp3293 to i32
  %sub3295 = sub nsw i32 0, %conv3294
  %conv3296 = sext i32 %sub3295 to i64
  %612 = load i64, i64* %nargs22458, align 8
  %add3297 = add nsw i64 0, %612
  %mul3298 = mul nsw i64 0, %add3297
  %add3299 = add nsw i64 %mul3298, 1
  %shl3300 = shl i64 %add3299, 62
  %sub3301 = sub nsw i64 %shl3300, 1
  %mul3302 = mul nsw i64 %sub3301, 2
  %add3303 = add nsw i64 %mul3302, 1
  %sub3304 = sub nsw i64 %conv3296, %add3303
  br label %cond.end.3309

cond.false.3305:                                  ; preds = %cond.false.3282
  %613 = load i64, i64* %nargs22458, align 8
  %add3306 = add nsw i64 0, %613
  %mul3307 = mul nsw i64 0, %add3306
  %add3308 = add nsw i64 %mul3307, 0
  br label %cond.end.3309

cond.end.3309:                                    ; preds = %cond.false.3305, %cond.true.3288
  %cond3310 = phi i64 [ %sub3304, %cond.true.3288 ], [ %add3308, %cond.false.3305 ]
  %div3311 = sdiv i64 %cond3310, 8
  %614 = load i64, i64* %nargs22458, align 8
  %cmp3312 = icmp slt i64 %div3311, %614
  br i1 %cmp3312, label %cond.true.3388, label %lor.lhs.false.3374

cond.false.3314:                                  ; preds = %lor.lhs.false.3253
  br i1 false, label %cond.true.3315, label %cond.false.3316

cond.true.3315:                                   ; preds = %cond.false.3314
  br i1 false, label %cond.true.3388, label %lor.lhs.false.3374

cond.false.3316:                                  ; preds = %cond.false.3314
  %615 = load i64, i64* %nargs22458, align 8
  %cmp3317 = icmp slt i64 %615, 0
  br i1 %cmp3317, label %cond.true.3319, label %cond.false.3351

cond.true.3319:                                   ; preds = %cond.false.3316
  %616 = load i64, i64* %nargs22458, align 8
  %617 = load i64, i64* %nargs22458, align 8
  %add3320 = add nsw i64 0, %617
  %mul3321 = mul nsw i64 0, %add3320
  %sub3322 = sub nsw i64 %mul3321, 1
  %cmp3323 = icmp slt i64 %sub3322, 0
  br i1 %cmp3323, label %cond.true.3325, label %cond.false.3342

cond.true.3325:                                   ; preds = %cond.true.3319
  %618 = load i64, i64* %nargs22458, align 8
  %add3326 = add nsw i64 0, %618
  %mul3327 = mul nsw i64 0, %add3326
  %add3328 = add nsw i64 %mul3327, 0
  %neg3329 = xor i64 %add3328, -1
  %cmp3330 = icmp eq i64 %neg3329, -1
  %conv3331 = zext i1 %cmp3330 to i32
  %sub3332 = sub nsw i32 0, %conv3331
  %conv3333 = sext i32 %sub3332 to i64
  %619 = load i64, i64* %nargs22458, align 8
  %add3334 = add nsw i64 0, %619
  %mul3335 = mul nsw i64 0, %add3334
  %add3336 = add nsw i64 %mul3335, 1
  %shl3337 = shl i64 %add3336, 62
  %sub3338 = sub nsw i64 %shl3337, 1
  %mul3339 = mul nsw i64 %sub3338, 2
  %add3340 = add nsw i64 %mul3339, 1
  %sub3341 = sub nsw i64 %conv3333, %add3340
  br label %cond.end.3346

cond.false.3342:                                  ; preds = %cond.true.3319
  %620 = load i64, i64* %nargs22458, align 8
  %add3343 = add nsw i64 0, %620
  %mul3344 = mul nsw i64 0, %add3343
  %add3345 = add nsw i64 %mul3344, 0
  br label %cond.end.3346

cond.end.3346:                                    ; preds = %cond.false.3342, %cond.true.3325
  %cond3347 = phi i64 [ %sub3341, %cond.true.3325 ], [ %add3345, %cond.false.3342 ]
  %div3348 = sdiv i64 %cond3347, 8
  %cmp3349 = icmp slt i64 %616, %div3348
  br i1 %cmp3349, label %cond.true.3388, label %lor.lhs.false.3374

cond.false.3351:                                  ; preds = %cond.false.3316
  %621 = load i64, i64* %nargs22458, align 8
  %add3352 = add nsw i64 0, %621
  %mul3353 = mul nsw i64 0, %add3352
  %sub3354 = sub nsw i64 %mul3353, 1
  %cmp3355 = icmp slt i64 %sub3354, 0
  br i1 %cmp3355, label %cond.true.3357, label %cond.false.3365

cond.true.3357:                                   ; preds = %cond.false.3351
  %622 = load i64, i64* %nargs22458, align 8
  %add3358 = add nsw i64 0, %622
  %mul3359 = mul nsw i64 0, %add3358
  %add3360 = add nsw i64 %mul3359, 1
  %shl3361 = shl i64 %add3360, 62
  %sub3362 = sub nsw i64 %shl3361, 1
  %mul3363 = mul nsw i64 %sub3362, 2
  %add3364 = add nsw i64 %mul3363, 1
  br label %cond.end.3369

cond.false.3365:                                  ; preds = %cond.false.3351
  %623 = load i64, i64* %nargs22458, align 8
  %add3366 = add nsw i64 0, %623
  %mul3367 = mul nsw i64 0, %add3366
  %sub3368 = sub nsw i64 %mul3367, 1
  br label %cond.end.3369

cond.end.3369:                                    ; preds = %cond.false.3365, %cond.true.3357
  %cond3370 = phi i64 [ %add3364, %cond.true.3357 ], [ %sub3368, %cond.false.3365 ]
  %div3371 = sdiv i64 %cond3370, 8
  %624 = load i64, i64* %nargs22458, align 8
  %cmp3372 = icmp slt i64 %div3371, %624
  br i1 %cmp3372, label %cond.true.3388, label %lor.lhs.false.3374

lor.lhs.false.3374:                               ; preds = %cond.end.3369, %cond.end.3346, %cond.true.3315, %cond.end.3309, %cond.true.3281, %cond.end.3275
  %625 = load i64, i64* %nargs22458, align 8
  %mul3375 = mul nsw i64 %625, 8
  %mul3376 = mul nsw i64 0, %mul3375
  %sub3377 = sub nsw i64 %mul3376, 1
  %cmp3378 = icmp slt i64 %sub3377, 0
  br i1 %cmp3378, label %land.lhs.true.3380, label %lor.lhs.false.3384

land.lhs.true.3380:                               ; preds = %lor.lhs.false.3374
  %626 = load i64, i64* %nargs22458, align 8
  %mul3381 = mul nsw i64 %626, 8
  %cmp3382 = icmp slt i64 %mul3381, -32768
  br i1 %cmp3382, label %cond.true.3388, label %lor.lhs.false.3384

lor.lhs.false.3384:                               ; preds = %land.lhs.true.3380, %lor.lhs.false.3374
  %627 = load i64, i64* %nargs22458, align 8
  %mul3385 = mul nsw i64 %627, 8
  %cmp3386 = icmp slt i64 32767, %mul3385
  br i1 %cmp3386, label %cond.true.3388, label %cond.false.3411

cond.true.3388:                                   ; preds = %lor.lhs.false.3384, %land.lhs.true.3380, %cond.end.3369, %cond.end.3346, %cond.true.3315, %cond.end.3309, %cond.true.3281, %cond.end.3275, %land.lhs.true.3250
  %628 = load i64, i64* %nargs22458, align 8
  %conv3389 = trunc i64 %628 to i16
  %conv3390 = zext i16 %conv3389 to i32
  %mul3391 = mul nsw i32 %conv3390, 8
  %cmp3392 = icmp sle i32 %mul3391, 32767
  br i1 %cmp3392, label %cond.true.3394, label %cond.false.3400

cond.true.3394:                                   ; preds = %cond.true.3388
  %629 = load i64, i64* %nargs22458, align 8
  %conv3395 = trunc i64 %629 to i16
  %conv3396 = zext i16 %conv3395 to i32
  %mul3397 = mul nsw i32 %conv3396, 8
  %conv3398 = trunc i32 %mul3397 to i16
  %conv3399 = sext i16 %conv3398 to i32
  br label %cond.end.3408

cond.false.3400:                                  ; preds = %cond.true.3388
  %630 = load i64, i64* %nargs22458, align 8
  %conv3401 = trunc i64 %630 to i16
  %conv3402 = zext i16 %conv3401 to i32
  %mul3403 = mul nsw i32 %conv3402, 8
  %sub3404 = sub nsw i32 %mul3403, -32768
  %conv3405 = trunc i32 %sub3404 to i16
  %conv3406 = sext i16 %conv3405 to i32
  %add3407 = add nsw i32 %conv3406, -32768
  br label %cond.end.3408

cond.end.3408:                                    ; preds = %cond.false.3400, %cond.true.3394
  %cond3409 = phi i32 [ %conv3399, %cond.true.3394 ], [ %add3407, %cond.false.3400 ]
  %conv3410 = sext i32 %cond3409 to i64
  store i64 %conv3410, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3411:                                  ; preds = %lor.lhs.false.3384
  %631 = load i64, i64* %nargs22458, align 8
  %conv3412 = trunc i64 %631 to i16
  %conv3413 = zext i16 %conv3412 to i32
  %mul3414 = mul nsw i32 %conv3413, 8
  %cmp3415 = icmp sle i32 %mul3414, 32767
  br i1 %cmp3415, label %cond.true.3417, label %cond.false.3423

cond.true.3417:                                   ; preds = %cond.false.3411
  %632 = load i64, i64* %nargs22458, align 8
  %conv3418 = trunc i64 %632 to i16
  %conv3419 = zext i16 %conv3418 to i32
  %mul3420 = mul nsw i32 %conv3419, 8
  %conv3421 = trunc i32 %mul3420 to i16
  %conv3422 = sext i16 %conv3421 to i32
  br label %cond.end.3431

cond.false.3423:                                  ; preds = %cond.false.3411
  %633 = load i64, i64* %nargs22458, align 8
  %conv3424 = trunc i64 %633 to i16
  %conv3425 = zext i16 %conv3424 to i32
  %mul3426 = mul nsw i32 %conv3425, 8
  %sub3427 = sub nsw i32 %mul3426, -32768
  %conv3428 = trunc i32 %sub3427 to i16
  %conv3429 = sext i16 %conv3428 to i32
  %add3430 = add nsw i32 %conv3429, -32768
  br label %cond.end.3431

cond.end.3431:                                    ; preds = %cond.false.3423, %cond.true.3417
  %cond3432 = phi i32 [ %conv3422, %cond.true.3417 ], [ %add3430, %cond.false.3423 ]
  %conv3433 = sext i32 %cond3432 to i64
  store i64 %conv3433, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3434:                                  ; preds = %cond.false.2949
  br i1 false, label %cond.true.3435, label %cond.false.3863

cond.true.3435:                                   ; preds = %cond.false.3434
  br i1 false, label %cond.true.3436, label %cond.false.3662

cond.true.3436:                                   ; preds = %cond.true.3435
  %634 = load i64, i64* %nargs22458, align 8
  %conv3437 = trunc i64 %634 to i32
  %add3438 = add nsw i32 0, %conv3437
  %mul3439 = mul nsw i32 0, %add3438
  %sub3440 = sub nsw i32 %mul3439, 1
  %cmp3441 = icmp slt i32 %sub3440, 0
  br i1 %cmp3441, label %cond.true.3443, label %cond.false.3461

cond.true.3443:                                   ; preds = %cond.true.3436
  %635 = load i64, i64* %nargs22458, align 8
  %conv3444 = trunc i64 %635 to i32
  %add3445 = add nsw i32 0, %conv3444
  %mul3446 = mul nsw i32 0, %add3445
  %add3447 = add nsw i32 %mul3446, 0
  %neg3448 = xor i32 %add3447, -1
  %cmp3449 = icmp eq i32 %neg3448, -1
  %conv3450 = zext i1 %cmp3449 to i32
  %sub3451 = sub nsw i32 0, %conv3450
  %636 = load i64, i64* %nargs22458, align 8
  %conv3452 = trunc i64 %636 to i32
  %add3453 = add nsw i32 0, %conv3452
  %mul3454 = mul nsw i32 0, %add3453
  %add3455 = add nsw i32 %mul3454, 1
  %shl3456 = shl i32 %add3455, 30
  %sub3457 = sub nsw i32 %shl3456, 1
  %mul3458 = mul nsw i32 %sub3457, 2
  %add3459 = add nsw i32 %mul3458, 1
  %sub3460 = sub nsw i32 %sub3451, %add3459
  br label %cond.end.3466

cond.false.3461:                                  ; preds = %cond.true.3436
  %637 = load i64, i64* %nargs22458, align 8
  %conv3462 = trunc i64 %637 to i32
  %add3463 = add nsw i32 0, %conv3462
  %mul3464 = mul nsw i32 0, %add3463
  %add3465 = add nsw i32 %mul3464, 0
  br label %cond.end.3466

cond.end.3466:                                    ; preds = %cond.false.3461, %cond.true.3443
  %cond3467 = phi i32 [ %sub3460, %cond.true.3443 ], [ %add3465, %cond.false.3461 ]
  %cmp3468 = icmp eq i32 %cond3467, 0
  br i1 %cmp3468, label %land.lhs.true.3470, label %lor.lhs.false.3474

land.lhs.true.3470:                               ; preds = %cond.end.3466
  %638 = load i64, i64* %nargs22458, align 8
  %conv3471 = trunc i64 %638 to i32
  %cmp3472 = icmp slt i32 %conv3471, 0
  br i1 %cmp3472, label %cond.true.3630, label %lor.lhs.false.3474

lor.lhs.false.3474:                               ; preds = %land.lhs.true.3470, %cond.end.3466
  br i1 false, label %cond.true.3475, label %cond.false.3544

cond.true.3475:                                   ; preds = %lor.lhs.false.3474
  %639 = load i64, i64* %nargs22458, align 8
  %conv3476 = trunc i64 %639 to i32
  %cmp3477 = icmp slt i32 %conv3476, 0
  br i1 %cmp3477, label %cond.true.3479, label %cond.false.3506

cond.true.3479:                                   ; preds = %cond.true.3475
  %640 = load i64, i64* %nargs22458, align 8
  %conv3480 = trunc i64 %640 to i32
  %641 = load i64, i64* %nargs22458, align 8
  %conv3481 = trunc i64 %641 to i32
  %add3482 = add nsw i32 0, %conv3481
  %mul3483 = mul nsw i32 0, %add3482
  %sub3484 = sub nsw i32 %mul3483, 1
  %cmp3485 = icmp slt i32 %sub3484, 0
  br i1 %cmp3485, label %cond.true.3487, label %cond.false.3496

cond.true.3487:                                   ; preds = %cond.true.3479
  %642 = load i64, i64* %nargs22458, align 8
  %conv3488 = trunc i64 %642 to i32
  %add3489 = add nsw i32 0, %conv3488
  %mul3490 = mul nsw i32 0, %add3489
  %add3491 = add nsw i32 %mul3490, 1
  %shl3492 = shl i32 %add3491, 30
  %sub3493 = sub nsw i32 %shl3492, 1
  %mul3494 = mul nsw i32 %sub3493, 2
  %add3495 = add nsw i32 %mul3494, 1
  br label %cond.end.3501

cond.false.3496:                                  ; preds = %cond.true.3479
  %643 = load i64, i64* %nargs22458, align 8
  %conv3497 = trunc i64 %643 to i32
  %add3498 = add nsw i32 0, %conv3497
  %mul3499 = mul nsw i32 0, %add3498
  %sub3500 = sub nsw i32 %mul3499, 1
  br label %cond.end.3501

cond.end.3501:                                    ; preds = %cond.false.3496, %cond.true.3487
  %cond3502 = phi i32 [ %add3495, %cond.true.3487 ], [ %sub3500, %cond.false.3496 ]
  %div3503 = sdiv i32 %cond3502, 8
  %cmp3504 = icmp slt i32 %conv3480, %div3503
  br i1 %cmp3504, label %cond.true.3630, label %lor.lhs.false.3613

cond.false.3506:                                  ; preds = %cond.true.3475
  br i1 false, label %cond.true.3507, label %cond.false.3508

cond.true.3507:                                   ; preds = %cond.false.3506
  br i1 false, label %cond.true.3630, label %lor.lhs.false.3613

cond.false.3508:                                  ; preds = %cond.false.3506
  %644 = load i64, i64* %nargs22458, align 8
  %conv3509 = trunc i64 %644 to i32
  %add3510 = add nsw i32 0, %conv3509
  %mul3511 = mul nsw i32 0, %add3510
  %sub3512 = sub nsw i32 %mul3511, 1
  %cmp3513 = icmp slt i32 %sub3512, 0
  br i1 %cmp3513, label %cond.true.3515, label %cond.false.3533

cond.true.3515:                                   ; preds = %cond.false.3508
  %645 = load i64, i64* %nargs22458, align 8
  %conv3516 = trunc i64 %645 to i32
  %add3517 = add nsw i32 0, %conv3516
  %mul3518 = mul nsw i32 0, %add3517
  %add3519 = add nsw i32 %mul3518, 0
  %neg3520 = xor i32 %add3519, -1
  %cmp3521 = icmp eq i32 %neg3520, -1
  %conv3522 = zext i1 %cmp3521 to i32
  %sub3523 = sub nsw i32 0, %conv3522
  %646 = load i64, i64* %nargs22458, align 8
  %conv3524 = trunc i64 %646 to i32
  %add3525 = add nsw i32 0, %conv3524
  %mul3526 = mul nsw i32 0, %add3525
  %add3527 = add nsw i32 %mul3526, 1
  %shl3528 = shl i32 %add3527, 30
  %sub3529 = sub nsw i32 %shl3528, 1
  %mul3530 = mul nsw i32 %sub3529, 2
  %add3531 = add nsw i32 %mul3530, 1
  %sub3532 = sub nsw i32 %sub3523, %add3531
  br label %cond.end.3538

cond.false.3533:                                  ; preds = %cond.false.3508
  %647 = load i64, i64* %nargs22458, align 8
  %conv3534 = trunc i64 %647 to i32
  %add3535 = add nsw i32 0, %conv3534
  %mul3536 = mul nsw i32 0, %add3535
  %add3537 = add nsw i32 %mul3536, 0
  br label %cond.end.3538

cond.end.3538:                                    ; preds = %cond.false.3533, %cond.true.3515
  %cond3539 = phi i32 [ %sub3532, %cond.true.3515 ], [ %add3537, %cond.false.3533 ]
  %div3540 = sdiv i32 %cond3539, 8
  %648 = load i64, i64* %nargs22458, align 8
  %conv3541 = trunc i64 %648 to i32
  %cmp3542 = icmp slt i32 %div3540, %conv3541
  br i1 %cmp3542, label %cond.true.3630, label %lor.lhs.false.3613

cond.false.3544:                                  ; preds = %lor.lhs.false.3474
  br i1 false, label %cond.true.3545, label %cond.false.3546

cond.true.3545:                                   ; preds = %cond.false.3544
  br i1 false, label %cond.true.3630, label %lor.lhs.false.3613

cond.false.3546:                                  ; preds = %cond.false.3544
  %649 = load i64, i64* %nargs22458, align 8
  %conv3547 = trunc i64 %649 to i32
  %cmp3548 = icmp slt i32 %conv3547, 0
  br i1 %cmp3548, label %cond.true.3550, label %cond.false.3586

cond.true.3550:                                   ; preds = %cond.false.3546
  %650 = load i64, i64* %nargs22458, align 8
  %conv3551 = trunc i64 %650 to i32
  %651 = load i64, i64* %nargs22458, align 8
  %conv3552 = trunc i64 %651 to i32
  %add3553 = add nsw i32 0, %conv3552
  %mul3554 = mul nsw i32 0, %add3553
  %sub3555 = sub nsw i32 %mul3554, 1
  %cmp3556 = icmp slt i32 %sub3555, 0
  br i1 %cmp3556, label %cond.true.3558, label %cond.false.3576

cond.true.3558:                                   ; preds = %cond.true.3550
  %652 = load i64, i64* %nargs22458, align 8
  %conv3559 = trunc i64 %652 to i32
  %add3560 = add nsw i32 0, %conv3559
  %mul3561 = mul nsw i32 0, %add3560
  %add3562 = add nsw i32 %mul3561, 0
  %neg3563 = xor i32 %add3562, -1
  %cmp3564 = icmp eq i32 %neg3563, -1
  %conv3565 = zext i1 %cmp3564 to i32
  %sub3566 = sub nsw i32 0, %conv3565
  %653 = load i64, i64* %nargs22458, align 8
  %conv3567 = trunc i64 %653 to i32
  %add3568 = add nsw i32 0, %conv3567
  %mul3569 = mul nsw i32 0, %add3568
  %add3570 = add nsw i32 %mul3569, 1
  %shl3571 = shl i32 %add3570, 30
  %sub3572 = sub nsw i32 %shl3571, 1
  %mul3573 = mul nsw i32 %sub3572, 2
  %add3574 = add nsw i32 %mul3573, 1
  %sub3575 = sub nsw i32 %sub3566, %add3574
  br label %cond.end.3581

cond.false.3576:                                  ; preds = %cond.true.3550
  %654 = load i64, i64* %nargs22458, align 8
  %conv3577 = trunc i64 %654 to i32
  %add3578 = add nsw i32 0, %conv3577
  %mul3579 = mul nsw i32 0, %add3578
  %add3580 = add nsw i32 %mul3579, 0
  br label %cond.end.3581

cond.end.3581:                                    ; preds = %cond.false.3576, %cond.true.3558
  %cond3582 = phi i32 [ %sub3575, %cond.true.3558 ], [ %add3580, %cond.false.3576 ]
  %div3583 = sdiv i32 %cond3582, 8
  %cmp3584 = icmp slt i32 %conv3551, %div3583
  br i1 %cmp3584, label %cond.true.3630, label %lor.lhs.false.3613

cond.false.3586:                                  ; preds = %cond.false.3546
  %655 = load i64, i64* %nargs22458, align 8
  %conv3587 = trunc i64 %655 to i32
  %add3588 = add nsw i32 0, %conv3587
  %mul3589 = mul nsw i32 0, %add3588
  %sub3590 = sub nsw i32 %mul3589, 1
  %cmp3591 = icmp slt i32 %sub3590, 0
  br i1 %cmp3591, label %cond.true.3593, label %cond.false.3602

cond.true.3593:                                   ; preds = %cond.false.3586
  %656 = load i64, i64* %nargs22458, align 8
  %conv3594 = trunc i64 %656 to i32
  %add3595 = add nsw i32 0, %conv3594
  %mul3596 = mul nsw i32 0, %add3595
  %add3597 = add nsw i32 %mul3596, 1
  %shl3598 = shl i32 %add3597, 30
  %sub3599 = sub nsw i32 %shl3598, 1
  %mul3600 = mul nsw i32 %sub3599, 2
  %add3601 = add nsw i32 %mul3600, 1
  br label %cond.end.3607

cond.false.3602:                                  ; preds = %cond.false.3586
  %657 = load i64, i64* %nargs22458, align 8
  %conv3603 = trunc i64 %657 to i32
  %add3604 = add nsw i32 0, %conv3603
  %mul3605 = mul nsw i32 0, %add3604
  %sub3606 = sub nsw i32 %mul3605, 1
  br label %cond.end.3607

cond.end.3607:                                    ; preds = %cond.false.3602, %cond.true.3593
  %cond3608 = phi i32 [ %add3601, %cond.true.3593 ], [ %sub3606, %cond.false.3602 ]
  %div3609 = sdiv i32 %cond3608, 8
  %658 = load i64, i64* %nargs22458, align 8
  %conv3610 = trunc i64 %658 to i32
  %cmp3611 = icmp slt i32 %div3609, %conv3610
  br i1 %cmp3611, label %cond.true.3630, label %lor.lhs.false.3613

lor.lhs.false.3613:                               ; preds = %cond.end.3607, %cond.end.3581, %cond.true.3545, %cond.end.3538, %cond.true.3507, %cond.end.3501
  %659 = load i64, i64* %nargs22458, align 8
  %conv3614 = trunc i64 %659 to i32
  %mul3615 = mul nsw i32 %conv3614, 8
  %mul3616 = mul nsw i32 0, %mul3615
  %sub3617 = sub nsw i32 %mul3616, 1
  %cmp3618 = icmp slt i32 %sub3617, 0
  br i1 %cmp3618, label %land.lhs.true.3620, label %lor.lhs.false.3625

land.lhs.true.3620:                               ; preds = %lor.lhs.false.3613
  %660 = load i64, i64* %nargs22458, align 8
  %conv3621 = trunc i64 %660 to i32
  %mul3622 = mul nsw i32 %conv3621, 8
  %cmp3623 = icmp slt i32 %mul3622, -2147483648
  br i1 %cmp3623, label %cond.true.3630, label %lor.lhs.false.3625

lor.lhs.false.3625:                               ; preds = %land.lhs.true.3620, %lor.lhs.false.3613
  %661 = load i64, i64* %nargs22458, align 8
  %conv3626 = trunc i64 %661 to i32
  %mul3627 = mul nsw i32 %conv3626, 8
  %cmp3628 = icmp slt i32 2147483647, %mul3627
  br i1 %cmp3628, label %cond.true.3630, label %cond.false.3646

cond.true.3630:                                   ; preds = %lor.lhs.false.3625, %land.lhs.true.3620, %cond.end.3607, %cond.end.3581, %cond.true.3545, %cond.end.3538, %cond.true.3507, %cond.end.3501, %land.lhs.true.3470
  %662 = load i64, i64* %nargs22458, align 8
  %conv3631 = trunc i64 %662 to i32
  %mul3632 = mul i32 %conv3631, 8
  %cmp3633 = icmp ule i32 %mul3632, 2147483647
  br i1 %cmp3633, label %cond.true.3635, label %cond.false.3638

cond.true.3635:                                   ; preds = %cond.true.3630
  %663 = load i64, i64* %nargs22458, align 8
  %conv3636 = trunc i64 %663 to i32
  %mul3637 = mul i32 %conv3636, 8
  br label %cond.end.3643

cond.false.3638:                                  ; preds = %cond.true.3630
  %664 = load i64, i64* %nargs22458, align 8
  %conv3639 = trunc i64 %664 to i32
  %mul3640 = mul i32 %conv3639, 8
  %sub3641 = sub i32 %mul3640, -2147483648
  %add3642 = add nsw i32 %sub3641, -2147483648
  br label %cond.end.3643

cond.end.3643:                                    ; preds = %cond.false.3638, %cond.true.3635
  %cond3644 = phi i32 [ %mul3637, %cond.true.3635 ], [ %add3642, %cond.false.3638 ]
  %conv3645 = sext i32 %cond3644 to i64
  store i64 %conv3645, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3646:                                  ; preds = %lor.lhs.false.3625
  %665 = load i64, i64* %nargs22458, align 8
  %conv3647 = trunc i64 %665 to i32
  %mul3648 = mul i32 %conv3647, 8
  %cmp3649 = icmp ule i32 %mul3648, 2147483647
  br i1 %cmp3649, label %cond.true.3651, label %cond.false.3654

cond.true.3651:                                   ; preds = %cond.false.3646
  %666 = load i64, i64* %nargs22458, align 8
  %conv3652 = trunc i64 %666 to i32
  %mul3653 = mul i32 %conv3652, 8
  br label %cond.end.3659

cond.false.3654:                                  ; preds = %cond.false.3646
  %667 = load i64, i64* %nargs22458, align 8
  %conv3655 = trunc i64 %667 to i32
  %mul3656 = mul i32 %conv3655, 8
  %sub3657 = sub i32 %mul3656, -2147483648
  %add3658 = add nsw i32 %sub3657, -2147483648
  br label %cond.end.3659

cond.end.3659:                                    ; preds = %cond.false.3654, %cond.true.3651
  %cond3660 = phi i32 [ %mul3653, %cond.true.3651 ], [ %add3658, %cond.false.3654 ]
  %conv3661 = sext i32 %cond3660 to i64
  store i64 %conv3661, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3662:                                  ; preds = %cond.true.3435
  %668 = load i64, i64* %nargs22458, align 8
  %add3663 = add nsw i64 0, %668
  %mul3664 = mul nsw i64 0, %add3663
  %sub3665 = sub nsw i64 %mul3664, 1
  %cmp3666 = icmp slt i64 %sub3665, 0
  br i1 %cmp3666, label %cond.true.3668, label %cond.false.3685

cond.true.3668:                                   ; preds = %cond.false.3662
  %669 = load i64, i64* %nargs22458, align 8
  %add3669 = add nsw i64 0, %669
  %mul3670 = mul nsw i64 0, %add3669
  %add3671 = add nsw i64 %mul3670, 0
  %neg3672 = xor i64 %add3671, -1
  %cmp3673 = icmp eq i64 %neg3672, -1
  %conv3674 = zext i1 %cmp3673 to i32
  %sub3675 = sub nsw i32 0, %conv3674
  %conv3676 = sext i32 %sub3675 to i64
  %670 = load i64, i64* %nargs22458, align 8
  %add3677 = add nsw i64 0, %670
  %mul3678 = mul nsw i64 0, %add3677
  %add3679 = add nsw i64 %mul3678, 1
  %shl3680 = shl i64 %add3679, 62
  %sub3681 = sub nsw i64 %shl3680, 1
  %mul3682 = mul nsw i64 %sub3681, 2
  %add3683 = add nsw i64 %mul3682, 1
  %sub3684 = sub nsw i64 %conv3676, %add3683
  br label %cond.end.3689

cond.false.3685:                                  ; preds = %cond.false.3662
  %671 = load i64, i64* %nargs22458, align 8
  %add3686 = add nsw i64 0, %671
  %mul3687 = mul nsw i64 0, %add3686
  %add3688 = add nsw i64 %mul3687, 0
  br label %cond.end.3689

cond.end.3689:                                    ; preds = %cond.false.3685, %cond.true.3668
  %cond3690 = phi i64 [ %sub3684, %cond.true.3668 ], [ %add3688, %cond.false.3685 ]
  %cmp3691 = icmp eq i64 %cond3690, 0
  br i1 %cmp3691, label %land.lhs.true.3693, label %lor.lhs.false.3696

land.lhs.true.3693:                               ; preds = %cond.end.3689
  %672 = load i64, i64* %nargs22458, align 8
  %cmp3694 = icmp slt i64 %672, 0
  br i1 %cmp3694, label %cond.true.3831, label %lor.lhs.false.3696

lor.lhs.false.3696:                               ; preds = %land.lhs.true.3693, %cond.end.3689
  br i1 false, label %cond.true.3697, label %cond.false.3757

cond.true.3697:                                   ; preds = %lor.lhs.false.3696
  %673 = load i64, i64* %nargs22458, align 8
  %cmp3698 = icmp slt i64 %673, 0
  br i1 %cmp3698, label %cond.true.3700, label %cond.false.3723

cond.true.3700:                                   ; preds = %cond.true.3697
  %674 = load i64, i64* %nargs22458, align 8
  %675 = load i64, i64* %nargs22458, align 8
  %add3701 = add nsw i64 0, %675
  %mul3702 = mul nsw i64 0, %add3701
  %sub3703 = sub nsw i64 %mul3702, 1
  %cmp3704 = icmp slt i64 %sub3703, 0
  br i1 %cmp3704, label %cond.true.3706, label %cond.false.3714

cond.true.3706:                                   ; preds = %cond.true.3700
  %676 = load i64, i64* %nargs22458, align 8
  %add3707 = add nsw i64 0, %676
  %mul3708 = mul nsw i64 0, %add3707
  %add3709 = add nsw i64 %mul3708, 1
  %shl3710 = shl i64 %add3709, 62
  %sub3711 = sub nsw i64 %shl3710, 1
  %mul3712 = mul nsw i64 %sub3711, 2
  %add3713 = add nsw i64 %mul3712, 1
  br label %cond.end.3718

cond.false.3714:                                  ; preds = %cond.true.3700
  %677 = load i64, i64* %nargs22458, align 8
  %add3715 = add nsw i64 0, %677
  %mul3716 = mul nsw i64 0, %add3715
  %sub3717 = sub nsw i64 %mul3716, 1
  br label %cond.end.3718

cond.end.3718:                                    ; preds = %cond.false.3714, %cond.true.3706
  %cond3719 = phi i64 [ %add3713, %cond.true.3706 ], [ %sub3717, %cond.false.3714 ]
  %div3720 = sdiv i64 %cond3719, 8
  %cmp3721 = icmp slt i64 %674, %div3720
  br i1 %cmp3721, label %cond.true.3831, label %lor.lhs.false.3817

cond.false.3723:                                  ; preds = %cond.true.3697
  br i1 false, label %cond.true.3724, label %cond.false.3725

cond.true.3724:                                   ; preds = %cond.false.3723
  br i1 false, label %cond.true.3831, label %lor.lhs.false.3817

cond.false.3725:                                  ; preds = %cond.false.3723
  %678 = load i64, i64* %nargs22458, align 8
  %add3726 = add nsw i64 0, %678
  %mul3727 = mul nsw i64 0, %add3726
  %sub3728 = sub nsw i64 %mul3727, 1
  %cmp3729 = icmp slt i64 %sub3728, 0
  br i1 %cmp3729, label %cond.true.3731, label %cond.false.3748

cond.true.3731:                                   ; preds = %cond.false.3725
  %679 = load i64, i64* %nargs22458, align 8
  %add3732 = add nsw i64 0, %679
  %mul3733 = mul nsw i64 0, %add3732
  %add3734 = add nsw i64 %mul3733, 0
  %neg3735 = xor i64 %add3734, -1
  %cmp3736 = icmp eq i64 %neg3735, -1
  %conv3737 = zext i1 %cmp3736 to i32
  %sub3738 = sub nsw i32 0, %conv3737
  %conv3739 = sext i32 %sub3738 to i64
  %680 = load i64, i64* %nargs22458, align 8
  %add3740 = add nsw i64 0, %680
  %mul3741 = mul nsw i64 0, %add3740
  %add3742 = add nsw i64 %mul3741, 1
  %shl3743 = shl i64 %add3742, 62
  %sub3744 = sub nsw i64 %shl3743, 1
  %mul3745 = mul nsw i64 %sub3744, 2
  %add3746 = add nsw i64 %mul3745, 1
  %sub3747 = sub nsw i64 %conv3739, %add3746
  br label %cond.end.3752

cond.false.3748:                                  ; preds = %cond.false.3725
  %681 = load i64, i64* %nargs22458, align 8
  %add3749 = add nsw i64 0, %681
  %mul3750 = mul nsw i64 0, %add3749
  %add3751 = add nsw i64 %mul3750, 0
  br label %cond.end.3752

cond.end.3752:                                    ; preds = %cond.false.3748, %cond.true.3731
  %cond3753 = phi i64 [ %sub3747, %cond.true.3731 ], [ %add3751, %cond.false.3748 ]
  %div3754 = sdiv i64 %cond3753, 8
  %682 = load i64, i64* %nargs22458, align 8
  %cmp3755 = icmp slt i64 %div3754, %682
  br i1 %cmp3755, label %cond.true.3831, label %lor.lhs.false.3817

cond.false.3757:                                  ; preds = %lor.lhs.false.3696
  br i1 false, label %cond.true.3758, label %cond.false.3759

cond.true.3758:                                   ; preds = %cond.false.3757
  br i1 false, label %cond.true.3831, label %lor.lhs.false.3817

cond.false.3759:                                  ; preds = %cond.false.3757
  %683 = load i64, i64* %nargs22458, align 8
  %cmp3760 = icmp slt i64 %683, 0
  br i1 %cmp3760, label %cond.true.3762, label %cond.false.3794

cond.true.3762:                                   ; preds = %cond.false.3759
  %684 = load i64, i64* %nargs22458, align 8
  %685 = load i64, i64* %nargs22458, align 8
  %add3763 = add nsw i64 0, %685
  %mul3764 = mul nsw i64 0, %add3763
  %sub3765 = sub nsw i64 %mul3764, 1
  %cmp3766 = icmp slt i64 %sub3765, 0
  br i1 %cmp3766, label %cond.true.3768, label %cond.false.3785

cond.true.3768:                                   ; preds = %cond.true.3762
  %686 = load i64, i64* %nargs22458, align 8
  %add3769 = add nsw i64 0, %686
  %mul3770 = mul nsw i64 0, %add3769
  %add3771 = add nsw i64 %mul3770, 0
  %neg3772 = xor i64 %add3771, -1
  %cmp3773 = icmp eq i64 %neg3772, -1
  %conv3774 = zext i1 %cmp3773 to i32
  %sub3775 = sub nsw i32 0, %conv3774
  %conv3776 = sext i32 %sub3775 to i64
  %687 = load i64, i64* %nargs22458, align 8
  %add3777 = add nsw i64 0, %687
  %mul3778 = mul nsw i64 0, %add3777
  %add3779 = add nsw i64 %mul3778, 1
  %shl3780 = shl i64 %add3779, 62
  %sub3781 = sub nsw i64 %shl3780, 1
  %mul3782 = mul nsw i64 %sub3781, 2
  %add3783 = add nsw i64 %mul3782, 1
  %sub3784 = sub nsw i64 %conv3776, %add3783
  br label %cond.end.3789

cond.false.3785:                                  ; preds = %cond.true.3762
  %688 = load i64, i64* %nargs22458, align 8
  %add3786 = add nsw i64 0, %688
  %mul3787 = mul nsw i64 0, %add3786
  %add3788 = add nsw i64 %mul3787, 0
  br label %cond.end.3789

cond.end.3789:                                    ; preds = %cond.false.3785, %cond.true.3768
  %cond3790 = phi i64 [ %sub3784, %cond.true.3768 ], [ %add3788, %cond.false.3785 ]
  %div3791 = sdiv i64 %cond3790, 8
  %cmp3792 = icmp slt i64 %684, %div3791
  br i1 %cmp3792, label %cond.true.3831, label %lor.lhs.false.3817

cond.false.3794:                                  ; preds = %cond.false.3759
  %689 = load i64, i64* %nargs22458, align 8
  %add3795 = add nsw i64 0, %689
  %mul3796 = mul nsw i64 0, %add3795
  %sub3797 = sub nsw i64 %mul3796, 1
  %cmp3798 = icmp slt i64 %sub3797, 0
  br i1 %cmp3798, label %cond.true.3800, label %cond.false.3808

cond.true.3800:                                   ; preds = %cond.false.3794
  %690 = load i64, i64* %nargs22458, align 8
  %add3801 = add nsw i64 0, %690
  %mul3802 = mul nsw i64 0, %add3801
  %add3803 = add nsw i64 %mul3802, 1
  %shl3804 = shl i64 %add3803, 62
  %sub3805 = sub nsw i64 %shl3804, 1
  %mul3806 = mul nsw i64 %sub3805, 2
  %add3807 = add nsw i64 %mul3806, 1
  br label %cond.end.3812

cond.false.3808:                                  ; preds = %cond.false.3794
  %691 = load i64, i64* %nargs22458, align 8
  %add3809 = add nsw i64 0, %691
  %mul3810 = mul nsw i64 0, %add3809
  %sub3811 = sub nsw i64 %mul3810, 1
  br label %cond.end.3812

cond.end.3812:                                    ; preds = %cond.false.3808, %cond.true.3800
  %cond3813 = phi i64 [ %add3807, %cond.true.3800 ], [ %sub3811, %cond.false.3808 ]
  %div3814 = sdiv i64 %cond3813, 8
  %692 = load i64, i64* %nargs22458, align 8
  %cmp3815 = icmp slt i64 %div3814, %692
  br i1 %cmp3815, label %cond.true.3831, label %lor.lhs.false.3817

lor.lhs.false.3817:                               ; preds = %cond.end.3812, %cond.end.3789, %cond.true.3758, %cond.end.3752, %cond.true.3724, %cond.end.3718
  %693 = load i64, i64* %nargs22458, align 8
  %mul3818 = mul nsw i64 %693, 8
  %mul3819 = mul nsw i64 0, %mul3818
  %sub3820 = sub nsw i64 %mul3819, 1
  %cmp3821 = icmp slt i64 %sub3820, 0
  br i1 %cmp3821, label %land.lhs.true.3823, label %lor.lhs.false.3827

land.lhs.true.3823:                               ; preds = %lor.lhs.false.3817
  %694 = load i64, i64* %nargs22458, align 8
  %mul3824 = mul nsw i64 %694, 8
  %cmp3825 = icmp slt i64 %mul3824, -2147483648
  br i1 %cmp3825, label %cond.true.3831, label %lor.lhs.false.3827

lor.lhs.false.3827:                               ; preds = %land.lhs.true.3823, %lor.lhs.false.3817
  %695 = load i64, i64* %nargs22458, align 8
  %mul3828 = mul nsw i64 %695, 8
  %cmp3829 = icmp slt i64 2147483647, %mul3828
  br i1 %cmp3829, label %cond.true.3831, label %cond.false.3847

cond.true.3831:                                   ; preds = %lor.lhs.false.3827, %land.lhs.true.3823, %cond.end.3812, %cond.end.3789, %cond.true.3758, %cond.end.3752, %cond.true.3724, %cond.end.3718, %land.lhs.true.3693
  %696 = load i64, i64* %nargs22458, align 8
  %conv3832 = trunc i64 %696 to i32
  %mul3833 = mul i32 %conv3832, 8
  %cmp3834 = icmp ule i32 %mul3833, 2147483647
  br i1 %cmp3834, label %cond.true.3836, label %cond.false.3839

cond.true.3836:                                   ; preds = %cond.true.3831
  %697 = load i64, i64* %nargs22458, align 8
  %conv3837 = trunc i64 %697 to i32
  %mul3838 = mul i32 %conv3837, 8
  br label %cond.end.3844

cond.false.3839:                                  ; preds = %cond.true.3831
  %698 = load i64, i64* %nargs22458, align 8
  %conv3840 = trunc i64 %698 to i32
  %mul3841 = mul i32 %conv3840, 8
  %sub3842 = sub i32 %mul3841, -2147483648
  %add3843 = add nsw i32 %sub3842, -2147483648
  br label %cond.end.3844

cond.end.3844:                                    ; preds = %cond.false.3839, %cond.true.3836
  %cond3845 = phi i32 [ %mul3838, %cond.true.3836 ], [ %add3843, %cond.false.3839 ]
  %conv3846 = sext i32 %cond3845 to i64
  store i64 %conv3846, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3847:                                  ; preds = %lor.lhs.false.3827
  %699 = load i64, i64* %nargs22458, align 8
  %conv3848 = trunc i64 %699 to i32
  %mul3849 = mul i32 %conv3848, 8
  %cmp3850 = icmp ule i32 %mul3849, 2147483647
  br i1 %cmp3850, label %cond.true.3852, label %cond.false.3855

cond.true.3852:                                   ; preds = %cond.false.3847
  %700 = load i64, i64* %nargs22458, align 8
  %conv3853 = trunc i64 %700 to i32
  %mul3854 = mul i32 %conv3853, 8
  br label %cond.end.3860

cond.false.3855:                                  ; preds = %cond.false.3847
  %701 = load i64, i64* %nargs22458, align 8
  %conv3856 = trunc i64 %701 to i32
  %mul3857 = mul i32 %conv3856, 8
  %sub3858 = sub i32 %mul3857, -2147483648
  %add3859 = add nsw i32 %sub3858, -2147483648
  br label %cond.end.3860

cond.end.3860:                                    ; preds = %cond.false.3855, %cond.true.3852
  %cond3861 = phi i32 [ %mul3854, %cond.true.3852 ], [ %add3859, %cond.false.3855 ]
  %conv3862 = sext i32 %cond3861 to i64
  store i64 %conv3862, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.3863:                                  ; preds = %cond.false.3434
  br i1 true, label %cond.true.3864, label %cond.false.4251

cond.true.3864:                                   ; preds = %cond.false.3863
  br i1 false, label %cond.true.3865, label %cond.false.4058

cond.true.3865:                                   ; preds = %cond.true.3864
  %702 = load i64, i64* %nargs22458, align 8
  %add3866 = add nsw i64 0, %702
  %mul3867 = mul nsw i64 0, %add3866
  %sub3868 = sub nsw i64 %mul3867, 1
  %cmp3869 = icmp slt i64 %sub3868, 0
  br i1 %cmp3869, label %cond.true.3871, label %cond.false.3888

cond.true.3871:                                   ; preds = %cond.true.3865
  %703 = load i64, i64* %nargs22458, align 8
  %add3872 = add nsw i64 0, %703
  %mul3873 = mul nsw i64 0, %add3872
  %add3874 = add nsw i64 %mul3873, 0
  %neg3875 = xor i64 %add3874, -1
  %cmp3876 = icmp eq i64 %neg3875, -1
  %conv3877 = zext i1 %cmp3876 to i32
  %sub3878 = sub nsw i32 0, %conv3877
  %conv3879 = sext i32 %sub3878 to i64
  %704 = load i64, i64* %nargs22458, align 8
  %add3880 = add nsw i64 0, %704
  %mul3881 = mul nsw i64 0, %add3880
  %add3882 = add nsw i64 %mul3881, 1
  %shl3883 = shl i64 %add3882, 62
  %sub3884 = sub nsw i64 %shl3883, 1
  %mul3885 = mul nsw i64 %sub3884, 2
  %add3886 = add nsw i64 %mul3885, 1
  %sub3887 = sub nsw i64 %conv3879, %add3886
  br label %cond.end.3892

cond.false.3888:                                  ; preds = %cond.true.3865
  %705 = load i64, i64* %nargs22458, align 8
  %add3889 = add nsw i64 0, %705
  %mul3890 = mul nsw i64 0, %add3889
  %add3891 = add nsw i64 %mul3890, 0
  br label %cond.end.3892

cond.end.3892:                                    ; preds = %cond.false.3888, %cond.true.3871
  %cond3893 = phi i64 [ %sub3887, %cond.true.3871 ], [ %add3891, %cond.false.3888 ]
  %cmp3894 = icmp eq i64 %cond3893, 0
  br i1 %cmp3894, label %land.lhs.true.3896, label %lor.lhs.false.3899

land.lhs.true.3896:                               ; preds = %cond.end.3892
  %706 = load i64, i64* %nargs22458, align 8
  %cmp3897 = icmp slt i64 %706, 0
  br i1 %cmp3897, label %cond.true.4034, label %lor.lhs.false.3899

lor.lhs.false.3899:                               ; preds = %land.lhs.true.3896, %cond.end.3892
  br i1 false, label %cond.true.3900, label %cond.false.3960

cond.true.3900:                                   ; preds = %lor.lhs.false.3899
  %707 = load i64, i64* %nargs22458, align 8
  %cmp3901 = icmp slt i64 %707, 0
  br i1 %cmp3901, label %cond.true.3903, label %cond.false.3926

cond.true.3903:                                   ; preds = %cond.true.3900
  %708 = load i64, i64* %nargs22458, align 8
  %709 = load i64, i64* %nargs22458, align 8
  %add3904 = add nsw i64 0, %709
  %mul3905 = mul nsw i64 0, %add3904
  %sub3906 = sub nsw i64 %mul3905, 1
  %cmp3907 = icmp slt i64 %sub3906, 0
  br i1 %cmp3907, label %cond.true.3909, label %cond.false.3917

cond.true.3909:                                   ; preds = %cond.true.3903
  %710 = load i64, i64* %nargs22458, align 8
  %add3910 = add nsw i64 0, %710
  %mul3911 = mul nsw i64 0, %add3910
  %add3912 = add nsw i64 %mul3911, 1
  %shl3913 = shl i64 %add3912, 62
  %sub3914 = sub nsw i64 %shl3913, 1
  %mul3915 = mul nsw i64 %sub3914, 2
  %add3916 = add nsw i64 %mul3915, 1
  br label %cond.end.3921

cond.false.3917:                                  ; preds = %cond.true.3903
  %711 = load i64, i64* %nargs22458, align 8
  %add3918 = add nsw i64 0, %711
  %mul3919 = mul nsw i64 0, %add3918
  %sub3920 = sub nsw i64 %mul3919, 1
  br label %cond.end.3921

cond.end.3921:                                    ; preds = %cond.false.3917, %cond.true.3909
  %cond3922 = phi i64 [ %add3916, %cond.true.3909 ], [ %sub3920, %cond.false.3917 ]
  %div3923 = sdiv i64 %cond3922, 8
  %cmp3924 = icmp slt i64 %708, %div3923
  br i1 %cmp3924, label %cond.true.4034, label %lor.lhs.false.4020

cond.false.3926:                                  ; preds = %cond.true.3900
  br i1 false, label %cond.true.3927, label %cond.false.3928

cond.true.3927:                                   ; preds = %cond.false.3926
  br i1 false, label %cond.true.4034, label %lor.lhs.false.4020

cond.false.3928:                                  ; preds = %cond.false.3926
  %712 = load i64, i64* %nargs22458, align 8
  %add3929 = add nsw i64 0, %712
  %mul3930 = mul nsw i64 0, %add3929
  %sub3931 = sub nsw i64 %mul3930, 1
  %cmp3932 = icmp slt i64 %sub3931, 0
  br i1 %cmp3932, label %cond.true.3934, label %cond.false.3951

cond.true.3934:                                   ; preds = %cond.false.3928
  %713 = load i64, i64* %nargs22458, align 8
  %add3935 = add nsw i64 0, %713
  %mul3936 = mul nsw i64 0, %add3935
  %add3937 = add nsw i64 %mul3936, 0
  %neg3938 = xor i64 %add3937, -1
  %cmp3939 = icmp eq i64 %neg3938, -1
  %conv3940 = zext i1 %cmp3939 to i32
  %sub3941 = sub nsw i32 0, %conv3940
  %conv3942 = sext i32 %sub3941 to i64
  %714 = load i64, i64* %nargs22458, align 8
  %add3943 = add nsw i64 0, %714
  %mul3944 = mul nsw i64 0, %add3943
  %add3945 = add nsw i64 %mul3944, 1
  %shl3946 = shl i64 %add3945, 62
  %sub3947 = sub nsw i64 %shl3946, 1
  %mul3948 = mul nsw i64 %sub3947, 2
  %add3949 = add nsw i64 %mul3948, 1
  %sub3950 = sub nsw i64 %conv3942, %add3949
  br label %cond.end.3955

cond.false.3951:                                  ; preds = %cond.false.3928
  %715 = load i64, i64* %nargs22458, align 8
  %add3952 = add nsw i64 0, %715
  %mul3953 = mul nsw i64 0, %add3952
  %add3954 = add nsw i64 %mul3953, 0
  br label %cond.end.3955

cond.end.3955:                                    ; preds = %cond.false.3951, %cond.true.3934
  %cond3956 = phi i64 [ %sub3950, %cond.true.3934 ], [ %add3954, %cond.false.3951 ]
  %div3957 = sdiv i64 %cond3956, 8
  %716 = load i64, i64* %nargs22458, align 8
  %cmp3958 = icmp slt i64 %div3957, %716
  br i1 %cmp3958, label %cond.true.4034, label %lor.lhs.false.4020

cond.false.3960:                                  ; preds = %lor.lhs.false.3899
  br i1 false, label %cond.true.3961, label %cond.false.3962

cond.true.3961:                                   ; preds = %cond.false.3960
  br i1 false, label %cond.true.4034, label %lor.lhs.false.4020

cond.false.3962:                                  ; preds = %cond.false.3960
  %717 = load i64, i64* %nargs22458, align 8
  %cmp3963 = icmp slt i64 %717, 0
  br i1 %cmp3963, label %cond.true.3965, label %cond.false.3997

cond.true.3965:                                   ; preds = %cond.false.3962
  %718 = load i64, i64* %nargs22458, align 8
  %719 = load i64, i64* %nargs22458, align 8
  %add3966 = add nsw i64 0, %719
  %mul3967 = mul nsw i64 0, %add3966
  %sub3968 = sub nsw i64 %mul3967, 1
  %cmp3969 = icmp slt i64 %sub3968, 0
  br i1 %cmp3969, label %cond.true.3971, label %cond.false.3988

cond.true.3971:                                   ; preds = %cond.true.3965
  %720 = load i64, i64* %nargs22458, align 8
  %add3972 = add nsw i64 0, %720
  %mul3973 = mul nsw i64 0, %add3972
  %add3974 = add nsw i64 %mul3973, 0
  %neg3975 = xor i64 %add3974, -1
  %cmp3976 = icmp eq i64 %neg3975, -1
  %conv3977 = zext i1 %cmp3976 to i32
  %sub3978 = sub nsw i32 0, %conv3977
  %conv3979 = sext i32 %sub3978 to i64
  %721 = load i64, i64* %nargs22458, align 8
  %add3980 = add nsw i64 0, %721
  %mul3981 = mul nsw i64 0, %add3980
  %add3982 = add nsw i64 %mul3981, 1
  %shl3983 = shl i64 %add3982, 62
  %sub3984 = sub nsw i64 %shl3983, 1
  %mul3985 = mul nsw i64 %sub3984, 2
  %add3986 = add nsw i64 %mul3985, 1
  %sub3987 = sub nsw i64 %conv3979, %add3986
  br label %cond.end.3992

cond.false.3988:                                  ; preds = %cond.true.3965
  %722 = load i64, i64* %nargs22458, align 8
  %add3989 = add nsw i64 0, %722
  %mul3990 = mul nsw i64 0, %add3989
  %add3991 = add nsw i64 %mul3990, 0
  br label %cond.end.3992

cond.end.3992:                                    ; preds = %cond.false.3988, %cond.true.3971
  %cond3993 = phi i64 [ %sub3987, %cond.true.3971 ], [ %add3991, %cond.false.3988 ]
  %div3994 = sdiv i64 %cond3993, 8
  %cmp3995 = icmp slt i64 %718, %div3994
  br i1 %cmp3995, label %cond.true.4034, label %lor.lhs.false.4020

cond.false.3997:                                  ; preds = %cond.false.3962
  %723 = load i64, i64* %nargs22458, align 8
  %add3998 = add nsw i64 0, %723
  %mul3999 = mul nsw i64 0, %add3998
  %sub4000 = sub nsw i64 %mul3999, 1
  %cmp4001 = icmp slt i64 %sub4000, 0
  br i1 %cmp4001, label %cond.true.4003, label %cond.false.4011

cond.true.4003:                                   ; preds = %cond.false.3997
  %724 = load i64, i64* %nargs22458, align 8
  %add4004 = add nsw i64 0, %724
  %mul4005 = mul nsw i64 0, %add4004
  %add4006 = add nsw i64 %mul4005, 1
  %shl4007 = shl i64 %add4006, 62
  %sub4008 = sub nsw i64 %shl4007, 1
  %mul4009 = mul nsw i64 %sub4008, 2
  %add4010 = add nsw i64 %mul4009, 1
  br label %cond.end.4015

cond.false.4011:                                  ; preds = %cond.false.3997
  %725 = load i64, i64* %nargs22458, align 8
  %add4012 = add nsw i64 0, %725
  %mul4013 = mul nsw i64 0, %add4012
  %sub4014 = sub nsw i64 %mul4013, 1
  br label %cond.end.4015

cond.end.4015:                                    ; preds = %cond.false.4011, %cond.true.4003
  %cond4016 = phi i64 [ %add4010, %cond.true.4003 ], [ %sub4014, %cond.false.4011 ]
  %div4017 = sdiv i64 %cond4016, 8
  %726 = load i64, i64* %nargs22458, align 8
  %cmp4018 = icmp slt i64 %div4017, %726
  br i1 %cmp4018, label %cond.true.4034, label %lor.lhs.false.4020

lor.lhs.false.4020:                               ; preds = %cond.end.4015, %cond.end.3992, %cond.true.3961, %cond.end.3955, %cond.true.3927, %cond.end.3921
  %727 = load i64, i64* %nargs22458, align 8
  %mul4021 = mul nsw i64 %727, 8
  %mul4022 = mul nsw i64 0, %mul4021
  %sub4023 = sub nsw i64 %mul4022, 1
  %cmp4024 = icmp slt i64 %sub4023, 0
  br i1 %cmp4024, label %land.lhs.true.4026, label %lor.lhs.false.4030

land.lhs.true.4026:                               ; preds = %lor.lhs.false.4020
  %728 = load i64, i64* %nargs22458, align 8
  %mul4027 = mul nsw i64 %728, 8
  %cmp4028 = icmp slt i64 %mul4027, -9223372036854775808
  br i1 %cmp4028, label %cond.true.4034, label %lor.lhs.false.4030

lor.lhs.false.4030:                               ; preds = %land.lhs.true.4026, %lor.lhs.false.4020
  %729 = load i64, i64* %nargs22458, align 8
  %mul4031 = mul nsw i64 %729, 8
  %cmp4032 = icmp slt i64 9223372036854775807, %mul4031
  br i1 %cmp4032, label %cond.true.4034, label %cond.false.4046

cond.true.4034:                                   ; preds = %lor.lhs.false.4030, %land.lhs.true.4026, %cond.end.4015, %cond.end.3992, %cond.true.3961, %cond.end.3955, %cond.true.3927, %cond.end.3921, %land.lhs.true.3896
  %730 = load i64, i64* %nargs22458, align 8
  %mul4035 = mul i64 %730, 8
  %cmp4036 = icmp ule i64 %mul4035, 9223372036854775807
  br i1 %cmp4036, label %cond.true.4038, label %cond.false.4040

cond.true.4038:                                   ; preds = %cond.true.4034
  %731 = load i64, i64* %nargs22458, align 8
  %mul4039 = mul i64 %731, 8
  br label %cond.end.4044

cond.false.4040:                                  ; preds = %cond.true.4034
  %732 = load i64, i64* %nargs22458, align 8
  %mul4041 = mul i64 %732, 8
  %sub4042 = sub i64 %mul4041, -9223372036854775808
  %add4043 = add nsw i64 %sub4042, -9223372036854775808
  br label %cond.end.4044

cond.end.4044:                                    ; preds = %cond.false.4040, %cond.true.4038
  %cond4045 = phi i64 [ %mul4039, %cond.true.4038 ], [ %add4043, %cond.false.4040 ]
  store i64 %cond4045, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4046:                                  ; preds = %lor.lhs.false.4030
  %733 = load i64, i64* %nargs22458, align 8
  %mul4047 = mul i64 %733, 8
  %cmp4048 = icmp ule i64 %mul4047, 9223372036854775807
  br i1 %cmp4048, label %cond.true.4050, label %cond.false.4052

cond.true.4050:                                   ; preds = %cond.false.4046
  %734 = load i64, i64* %nargs22458, align 8
  %mul4051 = mul i64 %734, 8
  br label %cond.end.4056

cond.false.4052:                                  ; preds = %cond.false.4046
  %735 = load i64, i64* %nargs22458, align 8
  %mul4053 = mul i64 %735, 8
  %sub4054 = sub i64 %mul4053, -9223372036854775808
  %add4055 = add nsw i64 %sub4054, -9223372036854775808
  br label %cond.end.4056

cond.end.4056:                                    ; preds = %cond.false.4052, %cond.true.4050
  %cond4057 = phi i64 [ %mul4051, %cond.true.4050 ], [ %add4055, %cond.false.4052 ]
  store i64 %cond4057, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4058:                                  ; preds = %cond.true.3864
  %736 = load i64, i64* %nargs22458, align 8
  %add4059 = add nsw i64 0, %736
  %mul4060 = mul nsw i64 0, %add4059
  %sub4061 = sub nsw i64 %mul4060, 1
  %cmp4062 = icmp slt i64 %sub4061, 0
  br i1 %cmp4062, label %cond.true.4064, label %cond.false.4081

cond.true.4064:                                   ; preds = %cond.false.4058
  %737 = load i64, i64* %nargs22458, align 8
  %add4065 = add nsw i64 0, %737
  %mul4066 = mul nsw i64 0, %add4065
  %add4067 = add nsw i64 %mul4066, 0
  %neg4068 = xor i64 %add4067, -1
  %cmp4069 = icmp eq i64 %neg4068, -1
  %conv4070 = zext i1 %cmp4069 to i32
  %sub4071 = sub nsw i32 0, %conv4070
  %conv4072 = sext i32 %sub4071 to i64
  %738 = load i64, i64* %nargs22458, align 8
  %add4073 = add nsw i64 0, %738
  %mul4074 = mul nsw i64 0, %add4073
  %add4075 = add nsw i64 %mul4074, 1
  %shl4076 = shl i64 %add4075, 62
  %sub4077 = sub nsw i64 %shl4076, 1
  %mul4078 = mul nsw i64 %sub4077, 2
  %add4079 = add nsw i64 %mul4078, 1
  %sub4080 = sub nsw i64 %conv4072, %add4079
  br label %cond.end.4085

cond.false.4081:                                  ; preds = %cond.false.4058
  %739 = load i64, i64* %nargs22458, align 8
  %add4082 = add nsw i64 0, %739
  %mul4083 = mul nsw i64 0, %add4082
  %add4084 = add nsw i64 %mul4083, 0
  br label %cond.end.4085

cond.end.4085:                                    ; preds = %cond.false.4081, %cond.true.4064
  %cond4086 = phi i64 [ %sub4080, %cond.true.4064 ], [ %add4084, %cond.false.4081 ]
  %cmp4087 = icmp eq i64 %cond4086, 0
  br i1 %cmp4087, label %land.lhs.true.4089, label %lor.lhs.false.4092

land.lhs.true.4089:                               ; preds = %cond.end.4085
  %740 = load i64, i64* %nargs22458, align 8
  %cmp4090 = icmp slt i64 %740, 0
  br i1 %cmp4090, label %cond.true.4227, label %lor.lhs.false.4092

lor.lhs.false.4092:                               ; preds = %land.lhs.true.4089, %cond.end.4085
  br i1 false, label %cond.true.4093, label %cond.false.4153

cond.true.4093:                                   ; preds = %lor.lhs.false.4092
  %741 = load i64, i64* %nargs22458, align 8
  %cmp4094 = icmp slt i64 %741, 0
  br i1 %cmp4094, label %cond.true.4096, label %cond.false.4119

cond.true.4096:                                   ; preds = %cond.true.4093
  %742 = load i64, i64* %nargs22458, align 8
  %743 = load i64, i64* %nargs22458, align 8
  %add4097 = add nsw i64 0, %743
  %mul4098 = mul nsw i64 0, %add4097
  %sub4099 = sub nsw i64 %mul4098, 1
  %cmp4100 = icmp slt i64 %sub4099, 0
  br i1 %cmp4100, label %cond.true.4102, label %cond.false.4110

cond.true.4102:                                   ; preds = %cond.true.4096
  %744 = load i64, i64* %nargs22458, align 8
  %add4103 = add nsw i64 0, %744
  %mul4104 = mul nsw i64 0, %add4103
  %add4105 = add nsw i64 %mul4104, 1
  %shl4106 = shl i64 %add4105, 62
  %sub4107 = sub nsw i64 %shl4106, 1
  %mul4108 = mul nsw i64 %sub4107, 2
  %add4109 = add nsw i64 %mul4108, 1
  br label %cond.end.4114

cond.false.4110:                                  ; preds = %cond.true.4096
  %745 = load i64, i64* %nargs22458, align 8
  %add4111 = add nsw i64 0, %745
  %mul4112 = mul nsw i64 0, %add4111
  %sub4113 = sub nsw i64 %mul4112, 1
  br label %cond.end.4114

cond.end.4114:                                    ; preds = %cond.false.4110, %cond.true.4102
  %cond4115 = phi i64 [ %add4109, %cond.true.4102 ], [ %sub4113, %cond.false.4110 ]
  %div4116 = sdiv i64 %cond4115, 8
  %cmp4117 = icmp slt i64 %742, %div4116
  br i1 %cmp4117, label %cond.true.4227, label %lor.lhs.false.4213

cond.false.4119:                                  ; preds = %cond.true.4093
  br i1 false, label %cond.true.4120, label %cond.false.4121

cond.true.4120:                                   ; preds = %cond.false.4119
  br i1 false, label %cond.true.4227, label %lor.lhs.false.4213

cond.false.4121:                                  ; preds = %cond.false.4119
  %746 = load i64, i64* %nargs22458, align 8
  %add4122 = add nsw i64 0, %746
  %mul4123 = mul nsw i64 0, %add4122
  %sub4124 = sub nsw i64 %mul4123, 1
  %cmp4125 = icmp slt i64 %sub4124, 0
  br i1 %cmp4125, label %cond.true.4127, label %cond.false.4144

cond.true.4127:                                   ; preds = %cond.false.4121
  %747 = load i64, i64* %nargs22458, align 8
  %add4128 = add nsw i64 0, %747
  %mul4129 = mul nsw i64 0, %add4128
  %add4130 = add nsw i64 %mul4129, 0
  %neg4131 = xor i64 %add4130, -1
  %cmp4132 = icmp eq i64 %neg4131, -1
  %conv4133 = zext i1 %cmp4132 to i32
  %sub4134 = sub nsw i32 0, %conv4133
  %conv4135 = sext i32 %sub4134 to i64
  %748 = load i64, i64* %nargs22458, align 8
  %add4136 = add nsw i64 0, %748
  %mul4137 = mul nsw i64 0, %add4136
  %add4138 = add nsw i64 %mul4137, 1
  %shl4139 = shl i64 %add4138, 62
  %sub4140 = sub nsw i64 %shl4139, 1
  %mul4141 = mul nsw i64 %sub4140, 2
  %add4142 = add nsw i64 %mul4141, 1
  %sub4143 = sub nsw i64 %conv4135, %add4142
  br label %cond.end.4148

cond.false.4144:                                  ; preds = %cond.false.4121
  %749 = load i64, i64* %nargs22458, align 8
  %add4145 = add nsw i64 0, %749
  %mul4146 = mul nsw i64 0, %add4145
  %add4147 = add nsw i64 %mul4146, 0
  br label %cond.end.4148

cond.end.4148:                                    ; preds = %cond.false.4144, %cond.true.4127
  %cond4149 = phi i64 [ %sub4143, %cond.true.4127 ], [ %add4147, %cond.false.4144 ]
  %div4150 = sdiv i64 %cond4149, 8
  %750 = load i64, i64* %nargs22458, align 8
  %cmp4151 = icmp slt i64 %div4150, %750
  br i1 %cmp4151, label %cond.true.4227, label %lor.lhs.false.4213

cond.false.4153:                                  ; preds = %lor.lhs.false.4092
  br i1 false, label %cond.true.4154, label %cond.false.4155

cond.true.4154:                                   ; preds = %cond.false.4153
  br i1 false, label %cond.true.4227, label %lor.lhs.false.4213

cond.false.4155:                                  ; preds = %cond.false.4153
  %751 = load i64, i64* %nargs22458, align 8
  %cmp4156 = icmp slt i64 %751, 0
  br i1 %cmp4156, label %cond.true.4158, label %cond.false.4190

cond.true.4158:                                   ; preds = %cond.false.4155
  %752 = load i64, i64* %nargs22458, align 8
  %753 = load i64, i64* %nargs22458, align 8
  %add4159 = add nsw i64 0, %753
  %mul4160 = mul nsw i64 0, %add4159
  %sub4161 = sub nsw i64 %mul4160, 1
  %cmp4162 = icmp slt i64 %sub4161, 0
  br i1 %cmp4162, label %cond.true.4164, label %cond.false.4181

cond.true.4164:                                   ; preds = %cond.true.4158
  %754 = load i64, i64* %nargs22458, align 8
  %add4165 = add nsw i64 0, %754
  %mul4166 = mul nsw i64 0, %add4165
  %add4167 = add nsw i64 %mul4166, 0
  %neg4168 = xor i64 %add4167, -1
  %cmp4169 = icmp eq i64 %neg4168, -1
  %conv4170 = zext i1 %cmp4169 to i32
  %sub4171 = sub nsw i32 0, %conv4170
  %conv4172 = sext i32 %sub4171 to i64
  %755 = load i64, i64* %nargs22458, align 8
  %add4173 = add nsw i64 0, %755
  %mul4174 = mul nsw i64 0, %add4173
  %add4175 = add nsw i64 %mul4174, 1
  %shl4176 = shl i64 %add4175, 62
  %sub4177 = sub nsw i64 %shl4176, 1
  %mul4178 = mul nsw i64 %sub4177, 2
  %add4179 = add nsw i64 %mul4178, 1
  %sub4180 = sub nsw i64 %conv4172, %add4179
  br label %cond.end.4185

cond.false.4181:                                  ; preds = %cond.true.4158
  %756 = load i64, i64* %nargs22458, align 8
  %add4182 = add nsw i64 0, %756
  %mul4183 = mul nsw i64 0, %add4182
  %add4184 = add nsw i64 %mul4183, 0
  br label %cond.end.4185

cond.end.4185:                                    ; preds = %cond.false.4181, %cond.true.4164
  %cond4186 = phi i64 [ %sub4180, %cond.true.4164 ], [ %add4184, %cond.false.4181 ]
  %div4187 = sdiv i64 %cond4186, 8
  %cmp4188 = icmp slt i64 %752, %div4187
  br i1 %cmp4188, label %cond.true.4227, label %lor.lhs.false.4213

cond.false.4190:                                  ; preds = %cond.false.4155
  %757 = load i64, i64* %nargs22458, align 8
  %add4191 = add nsw i64 0, %757
  %mul4192 = mul nsw i64 0, %add4191
  %sub4193 = sub nsw i64 %mul4192, 1
  %cmp4194 = icmp slt i64 %sub4193, 0
  br i1 %cmp4194, label %cond.true.4196, label %cond.false.4204

cond.true.4196:                                   ; preds = %cond.false.4190
  %758 = load i64, i64* %nargs22458, align 8
  %add4197 = add nsw i64 0, %758
  %mul4198 = mul nsw i64 0, %add4197
  %add4199 = add nsw i64 %mul4198, 1
  %shl4200 = shl i64 %add4199, 62
  %sub4201 = sub nsw i64 %shl4200, 1
  %mul4202 = mul nsw i64 %sub4201, 2
  %add4203 = add nsw i64 %mul4202, 1
  br label %cond.end.4208

cond.false.4204:                                  ; preds = %cond.false.4190
  %759 = load i64, i64* %nargs22458, align 8
  %add4205 = add nsw i64 0, %759
  %mul4206 = mul nsw i64 0, %add4205
  %sub4207 = sub nsw i64 %mul4206, 1
  br label %cond.end.4208

cond.end.4208:                                    ; preds = %cond.false.4204, %cond.true.4196
  %cond4209 = phi i64 [ %add4203, %cond.true.4196 ], [ %sub4207, %cond.false.4204 ]
  %div4210 = sdiv i64 %cond4209, 8
  %760 = load i64, i64* %nargs22458, align 8
  %cmp4211 = icmp slt i64 %div4210, %760
  br i1 %cmp4211, label %cond.true.4227, label %lor.lhs.false.4213

lor.lhs.false.4213:                               ; preds = %cond.end.4208, %cond.end.4185, %cond.true.4154, %cond.end.4148, %cond.true.4120, %cond.end.4114
  %761 = load i64, i64* %nargs22458, align 8
  %mul4214 = mul nsw i64 %761, 8
  %mul4215 = mul nsw i64 0, %mul4214
  %sub4216 = sub nsw i64 %mul4215, 1
  %cmp4217 = icmp slt i64 %sub4216, 0
  br i1 %cmp4217, label %land.lhs.true.4219, label %lor.lhs.false.4223

land.lhs.true.4219:                               ; preds = %lor.lhs.false.4213
  %762 = load i64, i64* %nargs22458, align 8
  %mul4220 = mul nsw i64 %762, 8
  %cmp4221 = icmp slt i64 %mul4220, -9223372036854775808
  br i1 %cmp4221, label %cond.true.4227, label %lor.lhs.false.4223

lor.lhs.false.4223:                               ; preds = %land.lhs.true.4219, %lor.lhs.false.4213
  %763 = load i64, i64* %nargs22458, align 8
  %mul4224 = mul nsw i64 %763, 8
  %cmp4225 = icmp slt i64 9223372036854775807, %mul4224
  br i1 %cmp4225, label %cond.true.4227, label %cond.false.4239

cond.true.4227:                                   ; preds = %lor.lhs.false.4223, %land.lhs.true.4219, %cond.end.4208, %cond.end.4185, %cond.true.4154, %cond.end.4148, %cond.true.4120, %cond.end.4114, %land.lhs.true.4089
  %764 = load i64, i64* %nargs22458, align 8
  %mul4228 = mul i64 %764, 8
  %cmp4229 = icmp ule i64 %mul4228, 9223372036854775807
  br i1 %cmp4229, label %cond.true.4231, label %cond.false.4233

cond.true.4231:                                   ; preds = %cond.true.4227
  %765 = load i64, i64* %nargs22458, align 8
  %mul4232 = mul i64 %765, 8
  br label %cond.end.4237

cond.false.4233:                                  ; preds = %cond.true.4227
  %766 = load i64, i64* %nargs22458, align 8
  %mul4234 = mul i64 %766, 8
  %sub4235 = sub i64 %mul4234, -9223372036854775808
  %add4236 = add nsw i64 %sub4235, -9223372036854775808
  br label %cond.end.4237

cond.end.4237:                                    ; preds = %cond.false.4233, %cond.true.4231
  %cond4238 = phi i64 [ %mul4232, %cond.true.4231 ], [ %add4236, %cond.false.4233 ]
  store i64 %cond4238, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4239:                                  ; preds = %lor.lhs.false.4223
  %767 = load i64, i64* %nargs22458, align 8
  %mul4240 = mul i64 %767, 8
  %cmp4241 = icmp ule i64 %mul4240, 9223372036854775807
  br i1 %cmp4241, label %cond.true.4243, label %cond.false.4245

cond.true.4243:                                   ; preds = %cond.false.4239
  %768 = load i64, i64* %nargs22458, align 8
  %mul4244 = mul i64 %768, 8
  br label %cond.end.4249

cond.false.4245:                                  ; preds = %cond.false.4239
  %769 = load i64, i64* %nargs22458, align 8
  %mul4246 = mul i64 %769, 8
  %sub4247 = sub i64 %mul4246, -9223372036854775808
  %add4248 = add nsw i64 %sub4247, -9223372036854775808
  br label %cond.end.4249

cond.end.4249:                                    ; preds = %cond.false.4245, %cond.true.4243
  %cond4250 = phi i64 [ %mul4244, %cond.true.4243 ], [ %add4248, %cond.false.4245 ]
  store i64 %cond4250, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4251:                                  ; preds = %cond.false.3863
  br i1 false, label %cond.true.4252, label %cond.false.4445

cond.true.4252:                                   ; preds = %cond.false.4251
  %770 = load i64, i64* %nargs22458, align 8
  %add4253 = add nsw i64 0, %770
  %mul4254 = mul nsw i64 0, %add4253
  %sub4255 = sub nsw i64 %mul4254, 1
  %cmp4256 = icmp slt i64 %sub4255, 0
  br i1 %cmp4256, label %cond.true.4258, label %cond.false.4275

cond.true.4258:                                   ; preds = %cond.true.4252
  %771 = load i64, i64* %nargs22458, align 8
  %add4259 = add nsw i64 0, %771
  %mul4260 = mul nsw i64 0, %add4259
  %add4261 = add nsw i64 %mul4260, 0
  %neg4262 = xor i64 %add4261, -1
  %cmp4263 = icmp eq i64 %neg4262, -1
  %conv4264 = zext i1 %cmp4263 to i32
  %sub4265 = sub nsw i32 0, %conv4264
  %conv4266 = sext i32 %sub4265 to i64
  %772 = load i64, i64* %nargs22458, align 8
  %add4267 = add nsw i64 0, %772
  %mul4268 = mul nsw i64 0, %add4267
  %add4269 = add nsw i64 %mul4268, 1
  %shl4270 = shl i64 %add4269, 62
  %sub4271 = sub nsw i64 %shl4270, 1
  %mul4272 = mul nsw i64 %sub4271, 2
  %add4273 = add nsw i64 %mul4272, 1
  %sub4274 = sub nsw i64 %conv4266, %add4273
  br label %cond.end.4279

cond.false.4275:                                  ; preds = %cond.true.4252
  %773 = load i64, i64* %nargs22458, align 8
  %add4276 = add nsw i64 0, %773
  %mul4277 = mul nsw i64 0, %add4276
  %add4278 = add nsw i64 %mul4277, 0
  br label %cond.end.4279

cond.end.4279:                                    ; preds = %cond.false.4275, %cond.true.4258
  %cond4280 = phi i64 [ %sub4274, %cond.true.4258 ], [ %add4278, %cond.false.4275 ]
  %cmp4281 = icmp eq i64 %cond4280, 0
  br i1 %cmp4281, label %land.lhs.true.4283, label %lor.lhs.false.4286

land.lhs.true.4283:                               ; preds = %cond.end.4279
  %774 = load i64, i64* %nargs22458, align 8
  %cmp4284 = icmp slt i64 %774, 0
  br i1 %cmp4284, label %cond.true.4421, label %lor.lhs.false.4286

lor.lhs.false.4286:                               ; preds = %land.lhs.true.4283, %cond.end.4279
  br i1 false, label %cond.true.4287, label %cond.false.4347

cond.true.4287:                                   ; preds = %lor.lhs.false.4286
  %775 = load i64, i64* %nargs22458, align 8
  %cmp4288 = icmp slt i64 %775, 0
  br i1 %cmp4288, label %cond.true.4290, label %cond.false.4313

cond.true.4290:                                   ; preds = %cond.true.4287
  %776 = load i64, i64* %nargs22458, align 8
  %777 = load i64, i64* %nargs22458, align 8
  %add4291 = add nsw i64 0, %777
  %mul4292 = mul nsw i64 0, %add4291
  %sub4293 = sub nsw i64 %mul4292, 1
  %cmp4294 = icmp slt i64 %sub4293, 0
  br i1 %cmp4294, label %cond.true.4296, label %cond.false.4304

cond.true.4296:                                   ; preds = %cond.true.4290
  %778 = load i64, i64* %nargs22458, align 8
  %add4297 = add nsw i64 0, %778
  %mul4298 = mul nsw i64 0, %add4297
  %add4299 = add nsw i64 %mul4298, 1
  %shl4300 = shl i64 %add4299, 62
  %sub4301 = sub nsw i64 %shl4300, 1
  %mul4302 = mul nsw i64 %sub4301, 2
  %add4303 = add nsw i64 %mul4302, 1
  br label %cond.end.4308

cond.false.4304:                                  ; preds = %cond.true.4290
  %779 = load i64, i64* %nargs22458, align 8
  %add4305 = add nsw i64 0, %779
  %mul4306 = mul nsw i64 0, %add4305
  %sub4307 = sub nsw i64 %mul4306, 1
  br label %cond.end.4308

cond.end.4308:                                    ; preds = %cond.false.4304, %cond.true.4296
  %cond4309 = phi i64 [ %add4303, %cond.true.4296 ], [ %sub4307, %cond.false.4304 ]
  %div4310 = sdiv i64 %cond4309, 8
  %cmp4311 = icmp slt i64 %776, %div4310
  br i1 %cmp4311, label %cond.true.4421, label %lor.lhs.false.4407

cond.false.4313:                                  ; preds = %cond.true.4287
  br i1 false, label %cond.true.4314, label %cond.false.4315

cond.true.4314:                                   ; preds = %cond.false.4313
  br i1 false, label %cond.true.4421, label %lor.lhs.false.4407

cond.false.4315:                                  ; preds = %cond.false.4313
  %780 = load i64, i64* %nargs22458, align 8
  %add4316 = add nsw i64 0, %780
  %mul4317 = mul nsw i64 0, %add4316
  %sub4318 = sub nsw i64 %mul4317, 1
  %cmp4319 = icmp slt i64 %sub4318, 0
  br i1 %cmp4319, label %cond.true.4321, label %cond.false.4338

cond.true.4321:                                   ; preds = %cond.false.4315
  %781 = load i64, i64* %nargs22458, align 8
  %add4322 = add nsw i64 0, %781
  %mul4323 = mul nsw i64 0, %add4322
  %add4324 = add nsw i64 %mul4323, 0
  %neg4325 = xor i64 %add4324, -1
  %cmp4326 = icmp eq i64 %neg4325, -1
  %conv4327 = zext i1 %cmp4326 to i32
  %sub4328 = sub nsw i32 0, %conv4327
  %conv4329 = sext i32 %sub4328 to i64
  %782 = load i64, i64* %nargs22458, align 8
  %add4330 = add nsw i64 0, %782
  %mul4331 = mul nsw i64 0, %add4330
  %add4332 = add nsw i64 %mul4331, 1
  %shl4333 = shl i64 %add4332, 62
  %sub4334 = sub nsw i64 %shl4333, 1
  %mul4335 = mul nsw i64 %sub4334, 2
  %add4336 = add nsw i64 %mul4335, 1
  %sub4337 = sub nsw i64 %conv4329, %add4336
  br label %cond.end.4342

cond.false.4338:                                  ; preds = %cond.false.4315
  %783 = load i64, i64* %nargs22458, align 8
  %add4339 = add nsw i64 0, %783
  %mul4340 = mul nsw i64 0, %add4339
  %add4341 = add nsw i64 %mul4340, 0
  br label %cond.end.4342

cond.end.4342:                                    ; preds = %cond.false.4338, %cond.true.4321
  %cond4343 = phi i64 [ %sub4337, %cond.true.4321 ], [ %add4341, %cond.false.4338 ]
  %div4344 = sdiv i64 %cond4343, 8
  %784 = load i64, i64* %nargs22458, align 8
  %cmp4345 = icmp slt i64 %div4344, %784
  br i1 %cmp4345, label %cond.true.4421, label %lor.lhs.false.4407

cond.false.4347:                                  ; preds = %lor.lhs.false.4286
  br i1 false, label %cond.true.4348, label %cond.false.4349

cond.true.4348:                                   ; preds = %cond.false.4347
  br i1 false, label %cond.true.4421, label %lor.lhs.false.4407

cond.false.4349:                                  ; preds = %cond.false.4347
  %785 = load i64, i64* %nargs22458, align 8
  %cmp4350 = icmp slt i64 %785, 0
  br i1 %cmp4350, label %cond.true.4352, label %cond.false.4384

cond.true.4352:                                   ; preds = %cond.false.4349
  %786 = load i64, i64* %nargs22458, align 8
  %787 = load i64, i64* %nargs22458, align 8
  %add4353 = add nsw i64 0, %787
  %mul4354 = mul nsw i64 0, %add4353
  %sub4355 = sub nsw i64 %mul4354, 1
  %cmp4356 = icmp slt i64 %sub4355, 0
  br i1 %cmp4356, label %cond.true.4358, label %cond.false.4375

cond.true.4358:                                   ; preds = %cond.true.4352
  %788 = load i64, i64* %nargs22458, align 8
  %add4359 = add nsw i64 0, %788
  %mul4360 = mul nsw i64 0, %add4359
  %add4361 = add nsw i64 %mul4360, 0
  %neg4362 = xor i64 %add4361, -1
  %cmp4363 = icmp eq i64 %neg4362, -1
  %conv4364 = zext i1 %cmp4363 to i32
  %sub4365 = sub nsw i32 0, %conv4364
  %conv4366 = sext i32 %sub4365 to i64
  %789 = load i64, i64* %nargs22458, align 8
  %add4367 = add nsw i64 0, %789
  %mul4368 = mul nsw i64 0, %add4367
  %add4369 = add nsw i64 %mul4368, 1
  %shl4370 = shl i64 %add4369, 62
  %sub4371 = sub nsw i64 %shl4370, 1
  %mul4372 = mul nsw i64 %sub4371, 2
  %add4373 = add nsw i64 %mul4372, 1
  %sub4374 = sub nsw i64 %conv4366, %add4373
  br label %cond.end.4379

cond.false.4375:                                  ; preds = %cond.true.4352
  %790 = load i64, i64* %nargs22458, align 8
  %add4376 = add nsw i64 0, %790
  %mul4377 = mul nsw i64 0, %add4376
  %add4378 = add nsw i64 %mul4377, 0
  br label %cond.end.4379

cond.end.4379:                                    ; preds = %cond.false.4375, %cond.true.4358
  %cond4380 = phi i64 [ %sub4374, %cond.true.4358 ], [ %add4378, %cond.false.4375 ]
  %div4381 = sdiv i64 %cond4380, 8
  %cmp4382 = icmp slt i64 %786, %div4381
  br i1 %cmp4382, label %cond.true.4421, label %lor.lhs.false.4407

cond.false.4384:                                  ; preds = %cond.false.4349
  %791 = load i64, i64* %nargs22458, align 8
  %add4385 = add nsw i64 0, %791
  %mul4386 = mul nsw i64 0, %add4385
  %sub4387 = sub nsw i64 %mul4386, 1
  %cmp4388 = icmp slt i64 %sub4387, 0
  br i1 %cmp4388, label %cond.true.4390, label %cond.false.4398

cond.true.4390:                                   ; preds = %cond.false.4384
  %792 = load i64, i64* %nargs22458, align 8
  %add4391 = add nsw i64 0, %792
  %mul4392 = mul nsw i64 0, %add4391
  %add4393 = add nsw i64 %mul4392, 1
  %shl4394 = shl i64 %add4393, 62
  %sub4395 = sub nsw i64 %shl4394, 1
  %mul4396 = mul nsw i64 %sub4395, 2
  %add4397 = add nsw i64 %mul4396, 1
  br label %cond.end.4402

cond.false.4398:                                  ; preds = %cond.false.4384
  %793 = load i64, i64* %nargs22458, align 8
  %add4399 = add nsw i64 0, %793
  %mul4400 = mul nsw i64 0, %add4399
  %sub4401 = sub nsw i64 %mul4400, 1
  br label %cond.end.4402

cond.end.4402:                                    ; preds = %cond.false.4398, %cond.true.4390
  %cond4403 = phi i64 [ %add4397, %cond.true.4390 ], [ %sub4401, %cond.false.4398 ]
  %div4404 = sdiv i64 %cond4403, 8
  %794 = load i64, i64* %nargs22458, align 8
  %cmp4405 = icmp slt i64 %div4404, %794
  br i1 %cmp4405, label %cond.true.4421, label %lor.lhs.false.4407

lor.lhs.false.4407:                               ; preds = %cond.end.4402, %cond.end.4379, %cond.true.4348, %cond.end.4342, %cond.true.4314, %cond.end.4308
  %795 = load i64, i64* %nargs22458, align 8
  %mul4408 = mul nsw i64 %795, 8
  %mul4409 = mul nsw i64 0, %mul4408
  %sub4410 = sub nsw i64 %mul4409, 1
  %cmp4411 = icmp slt i64 %sub4410, 0
  br i1 %cmp4411, label %land.lhs.true.4413, label %lor.lhs.false.4417

land.lhs.true.4413:                               ; preds = %lor.lhs.false.4407
  %796 = load i64, i64* %nargs22458, align 8
  %mul4414 = mul nsw i64 %796, 8
  %cmp4415 = icmp slt i64 %mul4414, -9223372036854775808
  br i1 %cmp4415, label %cond.true.4421, label %lor.lhs.false.4417

lor.lhs.false.4417:                               ; preds = %land.lhs.true.4413, %lor.lhs.false.4407
  %797 = load i64, i64* %nargs22458, align 8
  %mul4418 = mul nsw i64 %797, 8
  %cmp4419 = icmp slt i64 9223372036854775807, %mul4418
  br i1 %cmp4419, label %cond.true.4421, label %cond.false.4433

cond.true.4421:                                   ; preds = %lor.lhs.false.4417, %land.lhs.true.4413, %cond.end.4402, %cond.end.4379, %cond.true.4348, %cond.end.4342, %cond.true.4314, %cond.end.4308, %land.lhs.true.4283
  %798 = load i64, i64* %nargs22458, align 8
  %mul4422 = mul i64 %798, 8
  %cmp4423 = icmp ule i64 %mul4422, 9223372036854775807
  br i1 %cmp4423, label %cond.true.4425, label %cond.false.4427

cond.true.4425:                                   ; preds = %cond.true.4421
  %799 = load i64, i64* %nargs22458, align 8
  %mul4426 = mul i64 %799, 8
  br label %cond.end.4431

cond.false.4427:                                  ; preds = %cond.true.4421
  %800 = load i64, i64* %nargs22458, align 8
  %mul4428 = mul i64 %800, 8
  %sub4429 = sub i64 %mul4428, -9223372036854775808
  %add4430 = add nsw i64 %sub4429, -9223372036854775808
  br label %cond.end.4431

cond.end.4431:                                    ; preds = %cond.false.4427, %cond.true.4425
  %cond4432 = phi i64 [ %mul4426, %cond.true.4425 ], [ %add4430, %cond.false.4427 ]
  store i64 %cond4432, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4433:                                  ; preds = %lor.lhs.false.4417
  %801 = load i64, i64* %nargs22458, align 8
  %mul4434 = mul i64 %801, 8
  %cmp4435 = icmp ule i64 %mul4434, 9223372036854775807
  br i1 %cmp4435, label %cond.true.4437, label %cond.false.4439

cond.true.4437:                                   ; preds = %cond.false.4433
  %802 = load i64, i64* %nargs22458, align 8
  %mul4438 = mul i64 %802, 8
  br label %cond.end.4443

cond.false.4439:                                  ; preds = %cond.false.4433
  %803 = load i64, i64* %nargs22458, align 8
  %mul4440 = mul i64 %803, 8
  %sub4441 = sub i64 %mul4440, -9223372036854775808
  %add4442 = add nsw i64 %sub4441, -9223372036854775808
  br label %cond.end.4443

cond.end.4443:                                    ; preds = %cond.false.4439, %cond.true.4437
  %cond4444 = phi i64 [ %mul4438, %cond.true.4437 ], [ %add4442, %cond.false.4439 ]
  store i64 %cond4444, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4445:                                  ; preds = %cond.false.4251
  %804 = load i64, i64* %nargs22458, align 8
  %add4446 = add nsw i64 0, %804
  %mul4447 = mul nsw i64 0, %add4446
  %sub4448 = sub nsw i64 %mul4447, 1
  %cmp4449 = icmp slt i64 %sub4448, 0
  br i1 %cmp4449, label %cond.true.4451, label %cond.false.4468

cond.true.4451:                                   ; preds = %cond.false.4445
  %805 = load i64, i64* %nargs22458, align 8
  %add4452 = add nsw i64 0, %805
  %mul4453 = mul nsw i64 0, %add4452
  %add4454 = add nsw i64 %mul4453, 0
  %neg4455 = xor i64 %add4454, -1
  %cmp4456 = icmp eq i64 %neg4455, -1
  %conv4457 = zext i1 %cmp4456 to i32
  %sub4458 = sub nsw i32 0, %conv4457
  %conv4459 = sext i32 %sub4458 to i64
  %806 = load i64, i64* %nargs22458, align 8
  %add4460 = add nsw i64 0, %806
  %mul4461 = mul nsw i64 0, %add4460
  %add4462 = add nsw i64 %mul4461, 1
  %shl4463 = shl i64 %add4462, 62
  %sub4464 = sub nsw i64 %shl4463, 1
  %mul4465 = mul nsw i64 %sub4464, 2
  %add4466 = add nsw i64 %mul4465, 1
  %sub4467 = sub nsw i64 %conv4459, %add4466
  br label %cond.end.4472

cond.false.4468:                                  ; preds = %cond.false.4445
  %807 = load i64, i64* %nargs22458, align 8
  %add4469 = add nsw i64 0, %807
  %mul4470 = mul nsw i64 0, %add4469
  %add4471 = add nsw i64 %mul4470, 0
  br label %cond.end.4472

cond.end.4472:                                    ; preds = %cond.false.4468, %cond.true.4451
  %cond4473 = phi i64 [ %sub4467, %cond.true.4451 ], [ %add4471, %cond.false.4468 ]
  %cmp4474 = icmp eq i64 %cond4473, 0
  br i1 %cmp4474, label %land.lhs.true.4476, label %lor.lhs.false.4479

land.lhs.true.4476:                               ; preds = %cond.end.4472
  %808 = load i64, i64* %nargs22458, align 8
  %cmp4477 = icmp slt i64 %808, 0
  br i1 %cmp4477, label %cond.true.4614, label %lor.lhs.false.4479

lor.lhs.false.4479:                               ; preds = %land.lhs.true.4476, %cond.end.4472
  br i1 false, label %cond.true.4480, label %cond.false.4540

cond.true.4480:                                   ; preds = %lor.lhs.false.4479
  %809 = load i64, i64* %nargs22458, align 8
  %cmp4481 = icmp slt i64 %809, 0
  br i1 %cmp4481, label %cond.true.4483, label %cond.false.4506

cond.true.4483:                                   ; preds = %cond.true.4480
  %810 = load i64, i64* %nargs22458, align 8
  %811 = load i64, i64* %nargs22458, align 8
  %add4484 = add nsw i64 0, %811
  %mul4485 = mul nsw i64 0, %add4484
  %sub4486 = sub nsw i64 %mul4485, 1
  %cmp4487 = icmp slt i64 %sub4486, 0
  br i1 %cmp4487, label %cond.true.4489, label %cond.false.4497

cond.true.4489:                                   ; preds = %cond.true.4483
  %812 = load i64, i64* %nargs22458, align 8
  %add4490 = add nsw i64 0, %812
  %mul4491 = mul nsw i64 0, %add4490
  %add4492 = add nsw i64 %mul4491, 1
  %shl4493 = shl i64 %add4492, 62
  %sub4494 = sub nsw i64 %shl4493, 1
  %mul4495 = mul nsw i64 %sub4494, 2
  %add4496 = add nsw i64 %mul4495, 1
  br label %cond.end.4501

cond.false.4497:                                  ; preds = %cond.true.4483
  %813 = load i64, i64* %nargs22458, align 8
  %add4498 = add nsw i64 0, %813
  %mul4499 = mul nsw i64 0, %add4498
  %sub4500 = sub nsw i64 %mul4499, 1
  br label %cond.end.4501

cond.end.4501:                                    ; preds = %cond.false.4497, %cond.true.4489
  %cond4502 = phi i64 [ %add4496, %cond.true.4489 ], [ %sub4500, %cond.false.4497 ]
  %div4503 = sdiv i64 %cond4502, 8
  %cmp4504 = icmp slt i64 %810, %div4503
  br i1 %cmp4504, label %cond.true.4614, label %lor.lhs.false.4600

cond.false.4506:                                  ; preds = %cond.true.4480
  br i1 false, label %cond.true.4507, label %cond.false.4508

cond.true.4507:                                   ; preds = %cond.false.4506
  br i1 false, label %cond.true.4614, label %lor.lhs.false.4600

cond.false.4508:                                  ; preds = %cond.false.4506
  %814 = load i64, i64* %nargs22458, align 8
  %add4509 = add nsw i64 0, %814
  %mul4510 = mul nsw i64 0, %add4509
  %sub4511 = sub nsw i64 %mul4510, 1
  %cmp4512 = icmp slt i64 %sub4511, 0
  br i1 %cmp4512, label %cond.true.4514, label %cond.false.4531

cond.true.4514:                                   ; preds = %cond.false.4508
  %815 = load i64, i64* %nargs22458, align 8
  %add4515 = add nsw i64 0, %815
  %mul4516 = mul nsw i64 0, %add4515
  %add4517 = add nsw i64 %mul4516, 0
  %neg4518 = xor i64 %add4517, -1
  %cmp4519 = icmp eq i64 %neg4518, -1
  %conv4520 = zext i1 %cmp4519 to i32
  %sub4521 = sub nsw i32 0, %conv4520
  %conv4522 = sext i32 %sub4521 to i64
  %816 = load i64, i64* %nargs22458, align 8
  %add4523 = add nsw i64 0, %816
  %mul4524 = mul nsw i64 0, %add4523
  %add4525 = add nsw i64 %mul4524, 1
  %shl4526 = shl i64 %add4525, 62
  %sub4527 = sub nsw i64 %shl4526, 1
  %mul4528 = mul nsw i64 %sub4527, 2
  %add4529 = add nsw i64 %mul4528, 1
  %sub4530 = sub nsw i64 %conv4522, %add4529
  br label %cond.end.4535

cond.false.4531:                                  ; preds = %cond.false.4508
  %817 = load i64, i64* %nargs22458, align 8
  %add4532 = add nsw i64 0, %817
  %mul4533 = mul nsw i64 0, %add4532
  %add4534 = add nsw i64 %mul4533, 0
  br label %cond.end.4535

cond.end.4535:                                    ; preds = %cond.false.4531, %cond.true.4514
  %cond4536 = phi i64 [ %sub4530, %cond.true.4514 ], [ %add4534, %cond.false.4531 ]
  %div4537 = sdiv i64 %cond4536, 8
  %818 = load i64, i64* %nargs22458, align 8
  %cmp4538 = icmp slt i64 %div4537, %818
  br i1 %cmp4538, label %cond.true.4614, label %lor.lhs.false.4600

cond.false.4540:                                  ; preds = %lor.lhs.false.4479
  br i1 false, label %cond.true.4541, label %cond.false.4542

cond.true.4541:                                   ; preds = %cond.false.4540
  br i1 false, label %cond.true.4614, label %lor.lhs.false.4600

cond.false.4542:                                  ; preds = %cond.false.4540
  %819 = load i64, i64* %nargs22458, align 8
  %cmp4543 = icmp slt i64 %819, 0
  br i1 %cmp4543, label %cond.true.4545, label %cond.false.4577

cond.true.4545:                                   ; preds = %cond.false.4542
  %820 = load i64, i64* %nargs22458, align 8
  %821 = load i64, i64* %nargs22458, align 8
  %add4546 = add nsw i64 0, %821
  %mul4547 = mul nsw i64 0, %add4546
  %sub4548 = sub nsw i64 %mul4547, 1
  %cmp4549 = icmp slt i64 %sub4548, 0
  br i1 %cmp4549, label %cond.true.4551, label %cond.false.4568

cond.true.4551:                                   ; preds = %cond.true.4545
  %822 = load i64, i64* %nargs22458, align 8
  %add4552 = add nsw i64 0, %822
  %mul4553 = mul nsw i64 0, %add4552
  %add4554 = add nsw i64 %mul4553, 0
  %neg4555 = xor i64 %add4554, -1
  %cmp4556 = icmp eq i64 %neg4555, -1
  %conv4557 = zext i1 %cmp4556 to i32
  %sub4558 = sub nsw i32 0, %conv4557
  %conv4559 = sext i32 %sub4558 to i64
  %823 = load i64, i64* %nargs22458, align 8
  %add4560 = add nsw i64 0, %823
  %mul4561 = mul nsw i64 0, %add4560
  %add4562 = add nsw i64 %mul4561, 1
  %shl4563 = shl i64 %add4562, 62
  %sub4564 = sub nsw i64 %shl4563, 1
  %mul4565 = mul nsw i64 %sub4564, 2
  %add4566 = add nsw i64 %mul4565, 1
  %sub4567 = sub nsw i64 %conv4559, %add4566
  br label %cond.end.4572

cond.false.4568:                                  ; preds = %cond.true.4545
  %824 = load i64, i64* %nargs22458, align 8
  %add4569 = add nsw i64 0, %824
  %mul4570 = mul nsw i64 0, %add4569
  %add4571 = add nsw i64 %mul4570, 0
  br label %cond.end.4572

cond.end.4572:                                    ; preds = %cond.false.4568, %cond.true.4551
  %cond4573 = phi i64 [ %sub4567, %cond.true.4551 ], [ %add4571, %cond.false.4568 ]
  %div4574 = sdiv i64 %cond4573, 8
  %cmp4575 = icmp slt i64 %820, %div4574
  br i1 %cmp4575, label %cond.true.4614, label %lor.lhs.false.4600

cond.false.4577:                                  ; preds = %cond.false.4542
  %825 = load i64, i64* %nargs22458, align 8
  %add4578 = add nsw i64 0, %825
  %mul4579 = mul nsw i64 0, %add4578
  %sub4580 = sub nsw i64 %mul4579, 1
  %cmp4581 = icmp slt i64 %sub4580, 0
  br i1 %cmp4581, label %cond.true.4583, label %cond.false.4591

cond.true.4583:                                   ; preds = %cond.false.4577
  %826 = load i64, i64* %nargs22458, align 8
  %add4584 = add nsw i64 0, %826
  %mul4585 = mul nsw i64 0, %add4584
  %add4586 = add nsw i64 %mul4585, 1
  %shl4587 = shl i64 %add4586, 62
  %sub4588 = sub nsw i64 %shl4587, 1
  %mul4589 = mul nsw i64 %sub4588, 2
  %add4590 = add nsw i64 %mul4589, 1
  br label %cond.end.4595

cond.false.4591:                                  ; preds = %cond.false.4577
  %827 = load i64, i64* %nargs22458, align 8
  %add4592 = add nsw i64 0, %827
  %mul4593 = mul nsw i64 0, %add4592
  %sub4594 = sub nsw i64 %mul4593, 1
  br label %cond.end.4595

cond.end.4595:                                    ; preds = %cond.false.4591, %cond.true.4583
  %cond4596 = phi i64 [ %add4590, %cond.true.4583 ], [ %sub4594, %cond.false.4591 ]
  %div4597 = sdiv i64 %cond4596, 8
  %828 = load i64, i64* %nargs22458, align 8
  %cmp4598 = icmp slt i64 %div4597, %828
  br i1 %cmp4598, label %cond.true.4614, label %lor.lhs.false.4600

lor.lhs.false.4600:                               ; preds = %cond.end.4595, %cond.end.4572, %cond.true.4541, %cond.end.4535, %cond.true.4507, %cond.end.4501
  %829 = load i64, i64* %nargs22458, align 8
  %mul4601 = mul nsw i64 %829, 8
  %mul4602 = mul nsw i64 0, %mul4601
  %sub4603 = sub nsw i64 %mul4602, 1
  %cmp4604 = icmp slt i64 %sub4603, 0
  br i1 %cmp4604, label %land.lhs.true.4606, label %lor.lhs.false.4610

land.lhs.true.4606:                               ; preds = %lor.lhs.false.4600
  %830 = load i64, i64* %nargs22458, align 8
  %mul4607 = mul nsw i64 %830, 8
  %cmp4608 = icmp slt i64 %mul4607, -9223372036854775808
  br i1 %cmp4608, label %cond.true.4614, label %lor.lhs.false.4610

lor.lhs.false.4610:                               ; preds = %land.lhs.true.4606, %lor.lhs.false.4600
  %831 = load i64, i64* %nargs22458, align 8
  %mul4611 = mul nsw i64 %831, 8
  %cmp4612 = icmp slt i64 9223372036854775807, %mul4611
  br i1 %cmp4612, label %cond.true.4614, label %cond.false.4626

cond.true.4614:                                   ; preds = %lor.lhs.false.4610, %land.lhs.true.4606, %cond.end.4595, %cond.end.4572, %cond.true.4541, %cond.end.4535, %cond.true.4507, %cond.end.4501, %land.lhs.true.4476
  %832 = load i64, i64* %nargs22458, align 8
  %mul4615 = mul i64 %832, 8
  %cmp4616 = icmp ule i64 %mul4615, 9223372036854775807
  br i1 %cmp4616, label %cond.true.4618, label %cond.false.4620

cond.true.4618:                                   ; preds = %cond.true.4614
  %833 = load i64, i64* %nargs22458, align 8
  %mul4619 = mul i64 %833, 8
  br label %cond.end.4624

cond.false.4620:                                  ; preds = %cond.true.4614
  %834 = load i64, i64* %nargs22458, align 8
  %mul4621 = mul i64 %834, 8
  %sub4622 = sub i64 %mul4621, -9223372036854775808
  %add4623 = add nsw i64 %sub4622, -9223372036854775808
  br label %cond.end.4624

cond.end.4624:                                    ; preds = %cond.false.4620, %cond.true.4618
  %cond4625 = phi i64 [ %mul4619, %cond.true.4618 ], [ %add4623, %cond.false.4620 ]
  store i64 %cond4625, i64* %alloca_nbytes2464, align 8
  br i1 true, label %if.then.4641, label %lor.lhs.false.4638

cond.false.4626:                                  ; preds = %lor.lhs.false.4610
  %835 = load i64, i64* %nargs22458, align 8
  %mul4627 = mul i64 %835, 8
  %cmp4628 = icmp ule i64 %mul4627, 9223372036854775807
  br i1 %cmp4628, label %cond.true.4630, label %cond.false.4632

cond.true.4630:                                   ; preds = %cond.false.4626
  %836 = load i64, i64* %nargs22458, align 8
  %mul4631 = mul i64 %836, 8
  br label %cond.end.4636

cond.false.4632:                                  ; preds = %cond.false.4626
  %837 = load i64, i64* %nargs22458, align 8
  %mul4633 = mul i64 %837, 8
  %sub4634 = sub i64 %mul4633, -9223372036854775808
  %add4635 = add nsw i64 %sub4634, -9223372036854775808
  br label %cond.end.4636

cond.end.4636:                                    ; preds = %cond.false.4632, %cond.true.4630
  %cond4637 = phi i64 [ %mul4631, %cond.true.4630 ], [ %add4635, %cond.false.4632 ]
  store i64 %cond4637, i64* %alloca_nbytes2464, align 8
  br i1 false, label %if.then.4641, label %lor.lhs.false.4638

lor.lhs.false.4638:                               ; preds = %cond.end.4636, %cond.end.4624, %cond.end.4443, %cond.end.4431, %cond.end.4249, %cond.end.4237, %cond.end.4056, %cond.end.4044, %cond.end.3860, %cond.end.3844, %cond.end.3659, %cond.end.3643, %cond.end.3431, %cond.end.3408, %cond.end.3216, %cond.end.3193, %cond.end.2946, %cond.end.2923, %cond.end.2731, %cond.end.2708
  %838 = load i64, i64* %alloca_nbytes2464, align 8
  %cmp4639 = icmp ult i64 -1, %838
  br i1 %cmp4639, label %if.then.4641, label %if.else.4642

if.then.4641:                                     ; preds = %lor.lhs.false.4638, %cond.end.4636, %cond.end.4624, %cond.end.4443, %cond.end.4431, %cond.end.4249, %cond.end.4237, %cond.end.4056, %cond.end.4044, %cond.end.3860, %cond.end.3844, %cond.end.3659, %cond.end.3643, %cond.end.3431, %cond.end.3408, %cond.end.3216, %cond.end.3193, %cond.end.2946, %cond.end.2923, %cond.end.2731, %cond.end.2708
  call void @memory_full(i64 -1) #8
  unreachable

if.else.4642:                                     ; preds = %lor.lhs.false.4638
  %839 = load i64, i64* %alloca_nbytes2464, align 8
  %840 = load i64, i64* %sa_avail, align 8
  %cmp4643 = icmp sle i64 %839, %840
  br i1 %cmp4643, label %if.then.4645, label %if.else.4647

if.then.4645:                                     ; preds = %if.else.4642
  %841 = load i64, i64* %alloca_nbytes2464, align 8
  %842 = load i64, i64* %sa_avail, align 8
  %sub4646 = sub nsw i64 %842, %841
  store i64 %sub4646, i64* %sa_avail, align 8
  %843 = load i64, i64* %alloca_nbytes2464, align 8
  %844 = alloca i8, i64 %843
  %845 = bitcast i8* %844 to i64*
  store i64* %845, i64** %args2, align 8
  br label %if.end.4651

if.else.4647:                                     ; preds = %if.else.4642
  %846 = load i64, i64* %alloca_nbytes2464, align 8
  %call4649 = call noalias i8* @xmalloc(i64 %846)
  %847 = bitcast i8* %call4649 to i64*
  store i64* %847, i64** %args2, align 8
  %848 = load i64*, i64** %args2, align 8
  %849 = load i64, i64* %nargs22458, align 8
  %call4650 = call i64 @make_save_memory(i64* %848, i64 %849)
  store i64 %call4650, i64* %arg_4648, align 8
  store i8 1, i8* %sa_must_free, align 1
  %850 = load i64, i64* %arg_4648, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %850)
  br label %if.end.4651

if.end.4651:                                      ; preds = %if.else.4647, %if.then.4645
  br label %if.end.4652

if.end.4652:                                      ; preds = %if.end.4651
  br label %do.end.4653

do.end.4653:                                      ; preds = %if.end.4652
  store i64 0, i64* %i4654, align 8
  %call4655 = call i64 @builtin_lisp_symbol(i32 873)
  %851 = load i64, i64* %i4654, align 8
  %inc4656 = add nsw i64 %851, 1
  store i64 %inc4656, i64* %i4654, align 8
  %852 = load i64*, i64** %args2, align 8
  %arrayidx4657 = getelementptr inbounds i64, i64* %852, i64 %851
  store i64 %call4655, i64* %arrayidx4657, align 8
  %853 = load i64, i64* %name, align 8
  %854 = load i64, i64* %i4654, align 8
  %inc4658 = add nsw i64 %854, 1
  store i64 %inc4658, i64* %i4654, align 8
  %855 = load i64*, i64** %args2, align 8
  %arrayidx4659 = getelementptr inbounds i64, i64* %855, i64 %854
  store i64 %853, i64* %arrayidx4659, align 8
  %856 = load i64, i64* %buffer, align 8
  %857 = load i64, i64* %i4654, align 8
  %inc4660 = add nsw i64 %857, 1
  store i64 %inc4660, i64* %i4654, align 8
  %858 = load i64*, i64** %args2, align 8
  %arrayidx4661 = getelementptr inbounds i64, i64* %858, i64 %857
  store i64 %856, i64* %arrayidx4661, align 8
  %859 = load i64, i64* %command, align 8
  store i64 %859, i64* %tem22462, align 8
  br label %for.cond.4662

for.cond.4662:                                    ; preds = %for.inc.4672, %do.end.4653
  %860 = load i64, i64* %tem22462, align 8
  %and4663 = and i64 %860, 7
  %conv4664 = trunc i64 %and4663 to i32
  %cmp4665 = icmp eq i32 %conv4664, 3
  br i1 %cmp4665, label %for.body.4667, label %for.end.4676

for.body.4667:                                    ; preds = %for.cond.4662
  %861 = load i64, i64* %tem22462, align 8
  %sub4668 = sub nsw i64 %861, 3
  %862 = inttoptr i64 %sub4668 to i8*
  %863 = bitcast i8* %862 to %struct.Lisp_Cons*
  %car4669 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %863, i32 0, i32 0
  %864 = load i64, i64* %car4669, align 8
  %865 = load i64, i64* %i4654, align 8
  %inc4670 = add nsw i64 %865, 1
  store i64 %inc4670, i64* %i4654, align 8
  %866 = load i64*, i64** %args2, align 8
  %arrayidx4671 = getelementptr inbounds i64, i64* %866, i64 %865
  store i64 %864, i64* %arrayidx4671, align 8
  br label %for.inc.4672

for.inc.4672:                                     ; preds = %for.body.4667
  %867 = load i64, i64* %tem22462, align 8
  %sub4673 = sub nsw i64 %867, 3
  %868 = inttoptr i64 %sub4673 to i8*
  %869 = bitcast i8* %868 to %struct.Lisp_Cons*
  %u4674 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %869, i32 0, i32 1
  %cdr4675 = bitcast %union.anon* %u4674 to i64*
  %870 = load i64, i64* %cdr4675, align 8
  store i64 %870, i64* %tem22462, align 8
  br label %for.cond.4662

for.end.4676:                                     ; preds = %for.cond.4662
  %871 = load i64, i64* %program, align 8
  %call4677 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4678 = icmp eq i64 %871, %call4677
  br i1 %cmp4678, label %if.end.4682, label %if.then.4680

if.then.4680:                                     ; preds = %for.end.4676
  %872 = load i64, i64* %nargs22458, align 8
  %873 = load i64*, i64** %args2, align 8
  %call4681 = call i64 @Ffind_operation_coding_system(i64 %872, i64* %873)
  store i64 %call4681, i64* %coding_systems, align 8
  br label %if.end.4682

if.end.4682:                                      ; preds = %if.then.4680, %for.end.4676
  br label %if.end.4683

if.end.4683:                                      ; preds = %if.end.4682, %if.then.2453
  %874 = load i64, i64* %coding_systems, align 8
  %and4684 = and i64 %874, 7
  %conv4685 = trunc i64 %and4684 to i32
  %cmp4686 = icmp eq i32 %conv4685, 3
  br i1 %cmp4686, label %if.then.4688, label %if.else.4692

if.then.4688:                                     ; preds = %if.end.4683
  %875 = load i64, i64* %coding_systems, align 8
  %sub4689 = sub nsw i64 %875, 3
  %876 = inttoptr i64 %sub4689 to i8*
  %877 = bitcast i8* %876 to %struct.Lisp_Cons*
  %u4690 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %877, i32 0, i32 1
  %cdr4691 = bitcast %union.anon* %u4690 to i64*
  %878 = load i64, i64* %cdr4691, align 8
  store i64 %878, i64* %val, align 8
  br label %if.end.4702

if.else.4692:                                     ; preds = %if.end.4683
  %879 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and4693 = and i64 %879, 7
  %conv4694 = trunc i64 %and4693 to i32
  %cmp4695 = icmp eq i32 %conv4694, 3
  br i1 %cmp4695, label %if.then.4697, label %if.end.4701

if.then.4697:                                     ; preds = %if.else.4692
  %880 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub4698 = sub nsw i64 %880, 3
  %881 = inttoptr i64 %sub4698 to i8*
  %882 = bitcast i8* %881 to %struct.Lisp_Cons*
  %u4699 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %882, i32 0, i32 1
  %cdr4700 = bitcast %union.anon* %u4699 to i64*
  %883 = load i64, i64* %cdr4700, align 8
  store i64 %883, i64* %val, align 8
  br label %if.end.4701

if.end.4701:                                      ; preds = %if.then.4697, %if.else.4692
  br label %if.end.4702

if.end.4702:                                      ; preds = %if.end.4701, %if.then.4688
  br label %if.end.4703

if.end.4703:                                      ; preds = %if.end.4702, %if.end.2449
  %884 = load i64, i64* %proc, align 8
  %call4704 = call %struct.Lisp_Process* @XPROCESS(i64 %884)
  %885 = load i64, i64* %val, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %call4704, i64 %885)
  %886 = load i64, i64* %proc, align 8
  %call4705 = call %struct.Lisp_Process* @XPROCESS(i64 %886)
  %887 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_decoding_buf(%struct.Lisp_Process* %call4705, i64 %887)
  %888 = load i64, i64* %proc, align 8
  %call4706 = call %struct.Lisp_Process* @XPROCESS(i64 %888)
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call4706, i32 0, i32 26
  store i32 0, i32* %decoding_carryover, align 4
  %889 = load i64, i64* %proc, align 8
  %call4707 = call %struct.Lisp_Process* @XPROCESS(i64 %889)
  %890 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_encoding_buf(%struct.Lisp_Process* %call4707, i64 %890)
  %891 = load i64, i64* %buffer, align 8
  %call4708 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4709 = icmp eq i64 %891, %call4708
  br i1 %cmp4709, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.4703
  %892 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 447), align 1
  %tobool4711 = trunc i8 %892 to i1
  %lnot4712 = xor i1 %tobool4711, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end.4703
  %893 = phi i1 [ true, %if.end.4703 ], [ %lnot4712, %lor.rhs ]
  %lnot4713 = xor i1 %893, true
  %894 = load i64, i64* %proc, align 8
  %call4714 = call %struct.Lisp_Process* @XPROCESS(i64 %894)
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call4714, i32 0, i32 28
  %895 = zext i1 %lnot4713 to i8
  %bf.load4715 = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.shl4716 = shl i8 %895, 5
  %bf.clear4717 = and i8 %bf.load4715, -33
  %bf.set4718 = or i8 %bf.clear4717, %bf.shl4716
  store i8 %bf.set4718, i8* %inherit_coding_system_flag, align 8
  %tobool4719 = trunc i8 %895 to i1
  %896 = load i64, i64* %program, align 8
  %call4720 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4721 = icmp eq i64 %896, %call4720
  br i1 %cmp4721, label %if.else.4818, label %if.then.4723

if.then.4723:                                     ; preds = %lor.end
  %897 = load i64, i64* %command, align 8
  %sub4724 = sub nsw i64 %897, 3
  %898 = inttoptr i64 %sub4724 to i8*
  %899 = bitcast i8* %898 to %struct.Lisp_Cons*
  %u4725 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %899, i32 0, i32 1
  %cdr4726 = bitcast %union.anon* %u4725 to i64*
  %900 = load i64, i64* %cdr4726, align 8
  store i64 %900, i64* %program_args, align 8
  %901 = load i64, i64* %program, align 8
  %call4727 = call zeroext i8 @SREF(i64 %901, i64 0)
  %conv4728 = zext i8 %call4727 to i32
  %cmp4729 = icmp eq i32 %conv4728, 47
  br i1 %cmp4729, label %if.else.4746, label %land.lhs.true.4731

land.lhs.true.4731:                               ; preds = %if.then.4723
  %902 = load i64, i64* %program, align 8
  %call4732 = call i64 @SCHARS(i64 %902)
  %cmp4733 = icmp sgt i64 %call4732, 1
  br i1 %cmp4733, label %land.lhs.true.4735, label %if.then.4736

land.lhs.true.4735:                               ; preds = %land.lhs.true.4731
  br i1 false, label %if.else.4746, label %if.then.4736

if.then.4736:                                     ; preds = %land.lhs.true.4735, %land.lhs.true.4731
  %call4737 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4737, i64* %tem, align 8
  %903 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 84), align 8
  %904 = load i64, i64* %program, align 8
  %905 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 85), align 8
  %call4738 = call i32 @openp(i64 %903, i64 %904, i64 %905, i64* %tem, i64 6, i1 zeroext false)
  %906 = load i64, i64* %tem, align 8
  %call4739 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4740 = icmp eq i64 %906, %call4739
  br i1 %cmp4740, label %if.then.4742, label %if.end.4743

if.then.4742:                                     ; preds = %if.then.4736
  %907 = load i64, i64* %program, align 8
  call void @report_file_error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0), i64 %907) #8
  unreachable

if.end.4743:                                      ; preds = %if.then.4736
  %908 = load i64, i64* %tem, align 8
  %call4744 = call i64 @builtin_lisp_symbol(i32 0)
  %call4745 = call i64 @Fexpand_file_name(i64 %908, i64 %call4744)
  store i64 %call4745, i64* %tem, align 8
  br label %if.end.4753

if.else.4746:                                     ; preds = %land.lhs.true.4735, %if.then.4723
  %909 = load i64, i64* %program, align 8
  %call4747 = call i64 @Ffile_directory_p(i64 %909)
  %call4748 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4749 = icmp eq i64 %call4747, %call4748
  br i1 %cmp4749, label %if.end.4752, label %if.then.4751

if.then.4751:                                     ; preds = %if.else.4746
  call void (i8*, ...) @error(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.9, i32 0, i32 0)) #8
  unreachable

if.end.4752:                                      ; preds = %if.else.4746
  %910 = load i64, i64* %program, align 8
  store i64 %910, i64* %tem, align 8
  br label %if.end.4753

if.end.4753:                                      ; preds = %if.end.4752, %if.end.4743
  %911 = load i64, i64* %tem, align 8
  %call4754 = call i64 @remove_slash_colon(i64 %911)
  store i64 %call4754, i64* %tem, align 8
  %call4755 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4755, i64* %arg_encoding, align 8
  %912 = load i64, i64* %tem, align 8
  %call4756 = call i64 @encode_file_name(i64 %912)
  %call4757 = call i64 @list1(i64 %call4756)
  store i64 %call4757, i64* %tem, align 8
  store i64 1, i64* %new_argc, align 8
  %913 = load i64, i64* %program_args, align 8
  store i64 %913, i64* %tem24758, align 8
  br label %for.cond.4759

for.cond.4759:                                    ; preds = %for.inc.4780, %if.end.4753
  %914 = load i64, i64* %tem24758, align 8
  %and4760 = and i64 %914, 7
  %conv4761 = trunc i64 %and4760 to i32
  %cmp4762 = icmp eq i32 %conv4761, 3
  br i1 %cmp4762, label %for.body.4764, label %for.end.4784

for.body.4764:                                    ; preds = %for.cond.4759
  %915 = load i64, i64* %tem24758, align 8
  %sub4765 = sub nsw i64 %915, 3
  %916 = inttoptr i64 %sub4765 to i8*
  %917 = bitcast i8* %916 to %struct.Lisp_Cons*
  %car4766 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %917, i32 0, i32 0
  %918 = load i64, i64* %car4766, align 8
  store i64 %918, i64* %arg, align 8
  %919 = load i64, i64* %arg, align 8
  call void @CHECK_STRING(i64 %919)
  %920 = load i64, i64* %arg, align 8
  %call4767 = call zeroext i1 @STRING_MULTIBYTE(i64 %920)
  br i1 %call4767, label %if.then.4768, label %if.end.4777

if.then.4768:                                     ; preds = %for.body.4764
  %921 = load i64, i64* %arg_encoding, align 8
  %call4769 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4770 = icmp eq i64 %921, %call4769
  br i1 %cmp4770, label %if.then.4772, label %if.end.4775

if.then.4772:                                     ; preds = %if.then.4768
  %922 = load i64, i64* %proc, align 8
  %call4773 = call %struct.Lisp_Process* @XPROCESS(i64 %922)
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call4773, i32 0, i32 15
  %923 = load i64, i64* %encode_coding_system, align 8
  %call4774 = call i64 @complement_process_encoding_system(i64 %923)
  store i64 %call4774, i64* %arg_encoding, align 8
  br label %if.end.4775

if.end.4775:                                      ; preds = %if.then.4772, %if.then.4768
  %924 = load i64, i64* %arg, align 8
  %925 = load i64, i64* %arg_encoding, align 8
  %call4776 = call i64 @code_convert_string_norecord(i64 %924, i64 %925, i1 zeroext true)
  store i64 %call4776, i64* %arg, align 8
  br label %if.end.4777

if.end.4777:                                      ; preds = %if.end.4775, %for.body.4764
  %926 = load i64, i64* %arg, align 8
  %927 = load i64, i64* %tem, align 8
  %call4778 = call i64 @Fcons(i64 %926, i64 %927)
  store i64 %call4778, i64* %tem, align 8
  %928 = load i64, i64* %new_argc, align 8
  %inc4779 = add nsw i64 %928, 1
  store i64 %inc4779, i64* %new_argc, align 8
  br label %for.inc.4780

for.inc.4780:                                     ; preds = %if.end.4777
  %929 = load i64, i64* %tem24758, align 8
  %sub4781 = sub nsw i64 %929, 3
  %930 = inttoptr i64 %sub4781 to i8*
  %931 = bitcast i8* %930 to %struct.Lisp_Cons*
  %u4782 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %931, i32 0, i32 1
  %cdr4783 = bitcast %union.anon* %u4782 to i64*
  %932 = load i64, i64* %cdr4783, align 8
  store i64 %932, i64* %tem24758, align 8
  br label %for.cond.4759

for.end.4784:                                     ; preds = %for.cond.4759
  br label %do.body.4785

do.body.4785:                                     ; preds = %for.end.4784
  %933 = load i64, i64* %new_argc, align 8
  %add4786 = add nsw i64 %933, 1
  %934 = load i64, i64* %sa_avail, align 8
  %div4787 = udiv i64 %934, 8
  %div4788 = udiv i64 %div4787, 1
  %cmp4789 = icmp ule i64 %add4786, %div4788
  br i1 %cmp4789, label %if.then.4791, label %if.else.4797

if.then.4791:                                     ; preds = %do.body.4785
  %935 = load i64, i64* %new_argc, align 8
  %add4792 = add nsw i64 %935, 1
  %mul4793 = mul i64 8, %add4792
  %936 = load i64, i64* %sa_avail, align 8
  %sub4794 = sub i64 %936, %mul4793
  store i64 %sub4794, i64* %sa_avail, align 8
  %937 = load i64, i64* %new_argc, align 8
  %add4795 = add nsw i64 %937, 1
  %mul4796 = mul i64 8, %add4795
  %938 = alloca i8, i64 %mul4796
  %939 = bitcast i8* %938 to i8**
  store i8** %939, i8*** %new_argv, align 8
  br label %if.end.4800

if.else.4797:                                     ; preds = %do.body.4785
  %940 = load i64, i64* %new_argc, align 8
  %add4798 = add nsw i64 %940, 1
  %call4799 = call noalias i8* @xnmalloc(i64 %add4798, i64 8)
  %941 = bitcast i8* %call4799 to i8**
  store i8** %941, i8*** %new_argv, align 8
  store i8 1, i8* %sa_must_free, align 1
  %942 = load i8**, i8*** %new_argv, align 8
  %943 = bitcast i8** %942 to i8*
  call void @record_unwind_protect_ptr(void (i8*)* @xfree, i8* %943)
  br label %if.end.4800

if.end.4800:                                      ; preds = %if.else.4797, %if.then.4791
  br label %do.end.4801

do.end.4801:                                      ; preds = %if.end.4800
  %944 = load i64, i64* %new_argc, align 8
  %945 = load i8**, i8*** %new_argv, align 8
  %arrayidx4802 = getelementptr inbounds i8*, i8** %945, i64 %944
  store i8* null, i8** %arrayidx4802, align 8
  %946 = load i64, i64* %new_argc, align 8
  %sub4804 = sub nsw i64 %946, 1
  store i64 %sub4804, i64* %i4803, align 8
  br label %for.cond.4805

for.cond.4805:                                    ; preds = %for.inc.4816, %do.end.4801
  %947 = load i64, i64* %i4803, align 8
  %cmp4806 = icmp sge i64 %947, 0
  br i1 %cmp4806, label %for.body.4808, label %for.end.4817

for.body.4808:                                    ; preds = %for.cond.4805
  %948 = load i64, i64* %tem, align 8
  %sub4809 = sub nsw i64 %948, 3
  %949 = inttoptr i64 %sub4809 to i8*
  %950 = bitcast i8* %949 to %struct.Lisp_Cons*
  %car4810 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %950, i32 0, i32 0
  %951 = load i64, i64* %car4810, align 8
  %call4811 = call i8* @SSDATA(i64 %951)
  %952 = load i64, i64* %i4803, align 8
  %953 = load i8**, i8*** %new_argv, align 8
  %arrayidx4812 = getelementptr inbounds i8*, i8** %953, i64 %952
  store i8* %call4811, i8** %arrayidx4812, align 8
  %954 = load i64, i64* %tem, align 8
  %sub4813 = sub nsw i64 %954, 3
  %955 = inttoptr i64 %sub4813 to i8*
  %956 = bitcast i8* %955 to %struct.Lisp_Cons*
  %u4814 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %956, i32 0, i32 1
  %cdr4815 = bitcast %union.anon* %u4814 to i64*
  %957 = load i64, i64* %cdr4815, align 8
  store i64 %957, i64* %tem, align 8
  br label %for.inc.4816

for.inc.4816:                                     ; preds = %for.body.4808
  %958 = load i64, i64* %i4803, align 8
  %dec = add nsw i64 %958, -1
  store i64 %dec, i64* %i4803, align 8
  br label %for.cond.4805

for.end.4817:                                     ; preds = %for.cond.4805
  %959 = load i64, i64* %proc, align 8
  %960 = load i8**, i8*** %new_argv, align 8
  %961 = load i64, i64* %current_dir, align 8
  call void @create_process(i64 %959, i8** %960, i64 %961)
  br label %if.end.4819

if.else.4818:                                     ; preds = %lor.end
  %962 = load i64, i64* %proc, align 8
  call void @create_pty(i64 %962)
  br label %if.end.4819

if.end.4819:                                      ; preds = %if.else.4818, %for.end.4817
  br label %do.body.4820

do.body.4820:                                     ; preds = %if.end.4819
  %963 = load i8, i8* %sa_must_free, align 1
  %tobool4821 = trunc i8 %963 to i1
  br i1 %tobool4821, label %if.then.4822, label %if.end.4825

if.then.4822:                                     ; preds = %do.body.4820
  store i8 0, i8* %sa_must_free, align 1
  %964 = load i64, i64* %sa_count, align 8
  %call4823 = call i64 @builtin_lisp_symbol(i32 0)
  %call4824 = call i64 @unbind_to(i64 %964, i64 %call4823)
  br label %if.end.4825

if.end.4825:                                      ; preds = %if.then.4822, %do.body.4820
  br label %do.end.4826

do.end.4826:                                      ; preds = %if.end.4825
  %965 = load i64, i64* %count, align 8
  %966 = load i64, i64* %proc, align 8
  %call4827 = call i64 @unbind_to(i64 %965, i64 %966)
  store i64 %call4827, i64* %retval
  br label %return

return:                                           ; preds = %do.end.4826, %if.then
  %967 = load i64, i64* %retval
  ret i64 %967
}

declare i64 @SPECPDL_INDEX() #1

declare i64 @Flist(i64, i64*) #1

declare i64 @Fget_buffer_create(i64) #1

declare i64 @encode_current_directory() #1

; Function Attrs: noreturn
declare void @error(i8*, ...) #2

; Function Attrs: nounwind uwtable
define i64 @Fmake_pipe_process(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %proc = alloca i64, align 8
  %contact = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %name = alloca i64, align 8
  %buffer = alloca i64, align 8
  %tem = alloca i64, align 8
  %specpdl_count = alloca i64, align 8
  %inchannel = alloca i32, align 4
  %outchannel = alloca i32, align 4
  %coding_systems = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %call1 = call i64 @Flist(i64 %1, i64* %2)
  store i64 %call1, i64* %contact, align 8
  %3 = load i64, i64* %contact, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 86)
  %call3 = call i64 @Fplist_get(i64 %3, i64 %call2)
  store i64 %call3, i64* %name, align 8
  %4 = load i64, i64* %name, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %name, align 8
  %call4 = call i64 @make_process(i64 %5)
  store i64 %call4, i64* %proc, align 8
  %call5 = call i64 @SPECPDL_INDEX()
  store i64 %call5, i64* %specpdl_count, align 8
  %6 = load i64, i64* %proc, align 8
  call void @record_unwind_protect(void (i64)* @remove_process, i64 %6)
  %7 = load i64, i64* %proc, align 8
  %call6 = call %struct.Lisp_Process* @XPROCESS(i64 %7)
  store %struct.Lisp_Process* %call6, %struct.Lisp_Process** %p, align 8
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 23
  %arraydecay = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i32 0
  %add.ptr = getelementptr inbounds i32, i32* %arraydecay, i64 0
  %call7 = call i32 @emacs_pipe(i32* %add.ptr)
  %cmp8 = icmp ne i32 %call7, 0
  br i1 %cmp8, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 23
  %arraydecay10 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd9, i32 0, i32 0
  %add.ptr11 = getelementptr inbounds i32, i32* %arraydecay10, i64 2
  %call12 = call i32 @emacs_pipe(i32* %add.ptr11)
  %cmp13 = icmp ne i32 %call12, 0
  br i1 %cmp13, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %lor.lhs.false, %if.end
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.10, i32 0, i32 0), i64 %call15) #8
  unreachable

if.end.16:                                        ; preds = %lor.lhs.false
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd17 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd17, i32 0, i64 1
  %11 = load i32, i32* %arrayidx, align 4
  store i32 %11, i32* %outchannel, align 4
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd18 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 23
  %arrayidx19 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd18, i32 0, i64 2
  %13 = load i32, i32* %arrayidx19, align 4
  store i32 %13, i32* %inchannel, align 4
  %14 = load i32, i32* %inchannel, align 4
  %call20 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %14, i32 4, i32 2048)
  %15 = load i32, i32* %outchannel, align 4
  %call21 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %15, i32 4, i32 2048)
  %16 = load i64, i64* %proc, align 8
  %17 = load i32, i32* %inchannel, align 4
  %idxprom = sext i32 %17 to i64
  %arrayidx22 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  store i64 %16, i64* %arrayidx22, align 8
  %18 = load i32, i32* %inchannel, align 4
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 21
  store i32 %18, i32* %infd, align 4
  %20 = load i32, i32* %outchannel, align 4
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 22
  store i32 %20, i32* %outfd, align 4
  %22 = load i32, i32* %inchannel, align 4
  %23 = load i32, i32* @max_process_desc, align 4
  %cmp23 = icmp sgt i32 %22, %23
  br i1 %cmp23, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %if.end.16
  %24 = load i32, i32* %inchannel, align 4
  store i32 %24, i32* @max_process_desc, align 4
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.24, %if.end.16
  %25 = load i64, i64* %contact, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 16)
  %call27 = call i64 @Fplist_get(i64 %25, i64 %call26)
  store i64 %call27, i64* %buffer, align 8
  %26 = load i64, i64* %buffer, align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp29 = icmp eq i64 %26, %call28
  br i1 %cmp29, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.end.25
  %27 = load i64, i64* %name, align 8
  store i64 %27, i64* %buffer, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %if.end.25
  %28 = load i64, i64* %buffer, align 8
  %call32 = call i64 @Fget_buffer_create(i64 %28)
  store i64 %call32, i64* %buffer, align 8
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %30 = load i64, i64* %buffer, align 8
  call void @pset_buffer(%struct.Lisp_Process* %29, i64 %30)
  %31 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %32 = load i64, i64* %contact, align 8
  call void @pset_childp(%struct.Lisp_Process* %31, i64 %32)
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %34 = load i64, i64* %contact, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 92)
  %call34 = call i64 @Fplist_get(i64 %34, i64 %call33)
  %call35 = call i64 @Fcopy_sequence(i64 %call34)
  call void @pset_plist(%struct.Lisp_Process* %33, i64 %call35)
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call36 = call i64 @builtin_lisp_symbol(i32 750)
  call void @pset_type(%struct.Lisp_Process* %35, i64 %call36)
  %36 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %37 = load i64, i64* %contact, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 115)
  %call38 = call i64 @Fplist_get(i64 %37, i64 %call37)
  call void @pset_sentinel(%struct.Lisp_Process* %36, i64 %call38)
  %38 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %39 = load i64, i64* %contact, align 8
  %call39 = call i64 @builtin_lisp_symbol(i32 42)
  %call40 = call i64 @Fplist_get(i64 %39, i64 %call39)
  call void @pset_filter(%struct.Lisp_Process* %38, i64 %call40)
  %40 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_log(%struct.Lisp_Process* %40, i64 %call41)
  %41 = load i64, i64* %contact, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 87)
  %call43 = call i64 @Fplist_get(i64 %41, i64 %call42)
  store i64 %call43, i64* %tem, align 8
  %42 = load i64, i64* %tem, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp45 = icmp eq i64 %42, %call44
  %lnot = xor i1 %cmp45, true
  br i1 %lnot, label %if.then.46, label %if.end.47

if.then.46:                                       ; preds = %if.end.31
  %43 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %43, i32 0, i32 28
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %kill_without_query, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.46, %if.end.31
  %44 = load i64, i64* %contact, align 8
  %call48 = call i64 @builtin_lisp_symbol(i32 124)
  %call49 = call i64 @Fplist_get(i64 %44, i64 %call48)
  store i64 %call49, i64* %tem, align 8
  %45 = load i64, i64* %tem, align 8
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp51 = icmp eq i64 %45, %call50
  %lnot52 = xor i1 %cmp51, true
  br i1 %lnot52, label %if.then.53, label %if.end.55

if.then.53:                                       ; preds = %if.end.47
  %46 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call54 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_command(%struct.Lisp_Process* %46, i64 %call54)
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.53, %if.end.47
  %47 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %47, i32 0, i32 3
  %48 = load i64, i64* %command, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp57 = icmp eq i64 %48, %call56
  br i1 %cmp57, label %if.end.59, label %if.then.58

if.then.58:                                       ; preds = %if.end.55
  %49 = load i32, i32* %inchannel, align 4
  call void @fd_SET(i32 %49, %struct.fd_set* @input_wait_mask)
  %50 = load i32, i32* %inchannel, align 4
  call void @fd_SET(i32 %50, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.59

if.end.59:                                        ; preds = %if.then.58, %if.end.55
  %51 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236), align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp61 = icmp eq i64 %51, %call60
  br i1 %cmp61, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.59
  br label %cond.end

cond.false:                                       ; preds = %if.end.59
  %52 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236), align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp63 = icmp eq i64 %52, %call62
  %cond = select i1 %cmp63, i32 1, i32 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond64 = phi i32 [ 0, %cond.true ], [ %cond, %cond.false ]
  %53 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %adaptive_read_buffering = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %53, i32 0, i32 28
  %54 = trunc i32 %cond64 to i8
  %bf.load65 = load i8, i8* %adaptive_read_buffering, align 8
  %bf.value = and i8 %54, 3
  %bf.clear66 = and i8 %bf.load65, -4
  %bf.set67 = or i8 %bf.clear66, %bf.value
  store i8 %bf.set67, i8* %adaptive_read_buffering, align 8
  %bf.result.cast = zext i8 %bf.value to i32
  %55 = load i64, i64* %buffer, align 8
  %call68 = call zeroext i1 @BUFFERP(i64 %55)
  br i1 %call68, label %if.then.69, label %if.end.108

if.then.69:                                       ; preds = %cond.end
  %56 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %56, i32 0, i32 11
  %57 = load i64, i64* %mark, align 8
  %58 = load i64, i64* %buffer, align 8
  %59 = load i64, i64* %buffer, align 8
  %call70 = call %struct.buffer* @XBUFFER(i64 %59)
  %60 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp71 = icmp eq %struct.buffer* %call70, %60
  br i1 %cmp71, label %cond.true.72, label %cond.false.73

cond.true.72:                                     ; preds = %if.then.69
  %61 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %61, i32 0, i32 79
  %62 = load i64, i64* %zv, align 8
  br label %cond.end.86

cond.false.73:                                    ; preds = %if.then.69
  %63 = load i64, i64* %buffer, align 8
  %call74 = call %struct.buffer* @XBUFFER(i64 %63)
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call74, i32 0, i32 47
  %64 = load i64, i64* %zv_marker_, align 8
  %call75 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp76 = icmp eq i64 %64, %call75
  br i1 %cmp76, label %cond.true.77, label %cond.false.80

cond.true.77:                                     ; preds = %cond.false.73
  %65 = load i64, i64* %buffer, align 8
  %call78 = call %struct.buffer* @XBUFFER(i64 %65)
  %zv79 = getelementptr inbounds %struct.buffer, %struct.buffer* %call78, i32 0, i32 79
  %66 = load i64, i64* %zv79, align 8
  br label %cond.end.84

cond.false.80:                                    ; preds = %cond.false.73
  %67 = load i64, i64* %buffer, align 8
  %call81 = call %struct.buffer* @XBUFFER(i64 %67)
  %zv_marker_82 = getelementptr inbounds %struct.buffer, %struct.buffer* %call81, i32 0, i32 47
  %68 = load i64, i64* %zv_marker_82, align 8
  %call83 = call i64 @marker_position(i64 %68)
  br label %cond.end.84

cond.end.84:                                      ; preds = %cond.false.80, %cond.true.77
  %cond85 = phi i64 [ %66, %cond.true.77 ], [ %call83, %cond.false.80 ]
  br label %cond.end.86

cond.end.86:                                      ; preds = %cond.end.84, %cond.true.72
  %cond87 = phi i64 [ %62, %cond.true.72 ], [ %cond85, %cond.end.84 ]
  %69 = load i64, i64* %buffer, align 8
  %call88 = call %struct.buffer* @XBUFFER(i64 %69)
  %70 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp89 = icmp eq %struct.buffer* %call88, %70
  br i1 %cmp89, label %cond.true.90, label %cond.false.91

cond.true.90:                                     ; preds = %cond.end.86
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 80
  %72 = load i64, i64* %zv_byte, align 8
  br label %cond.end.105

cond.false.91:                                    ; preds = %cond.end.86
  %73 = load i64, i64* %buffer, align 8
  %call92 = call %struct.buffer* @XBUFFER(i64 %73)
  %zv_marker_93 = getelementptr inbounds %struct.buffer, %struct.buffer* %call92, i32 0, i32 47
  %74 = load i64, i64* %zv_marker_93, align 8
  %call94 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp95 = icmp eq i64 %74, %call94
  br i1 %cmp95, label %cond.true.96, label %cond.false.99

cond.true.96:                                     ; preds = %cond.false.91
  %75 = load i64, i64* %buffer, align 8
  %call97 = call %struct.buffer* @XBUFFER(i64 %75)
  %zv_byte98 = getelementptr inbounds %struct.buffer, %struct.buffer* %call97, i32 0, i32 80
  %76 = load i64, i64* %zv_byte98, align 8
  br label %cond.end.103

cond.false.99:                                    ; preds = %cond.false.91
  %77 = load i64, i64* %buffer, align 8
  %call100 = call %struct.buffer* @XBUFFER(i64 %77)
  %zv_marker_101 = getelementptr inbounds %struct.buffer, %struct.buffer* %call100, i32 0, i32 47
  %78 = load i64, i64* %zv_marker_101, align 8
  %call102 = call i64 @marker_byte_position(i64 %78)
  br label %cond.end.103

cond.end.103:                                     ; preds = %cond.false.99, %cond.true.96
  %cond104 = phi i64 [ %76, %cond.true.96 ], [ %call102, %cond.false.99 ]
  br label %cond.end.105

cond.end.105:                                     ; preds = %cond.end.103, %cond.true.90
  %cond106 = phi i64 [ %72, %cond.true.90 ], [ %cond104, %cond.end.103 ]
  %call107 = call i64 @set_marker_both(i64 %57, i64 %58, i64 %cond87, i64 %cond106)
  br label %if.end.108

if.end.108:                                       ; preds = %cond.end.105, %cond.end
  %call109 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call109, i64* %coding_systems, align 8
  %79 = load i64, i64* %contact, align 8
  %call110 = call i64 @builtin_lisp_symbol(i32 20)
  %call111 = call i64 @Fplist_get(i64 %79, i64 %call110)
  store i64 %call111, i64* %tem, align 8
  %call112 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call112, i64* %val, align 8
  %80 = load i64, i64* %tem, align 8
  %call113 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp114 = icmp eq i64 %80, %call113
  br i1 %cmp114, label %if.else, label %if.then.115

if.then.115:                                      ; preds = %if.end.108
  %81 = load i64, i64* %tem, align 8
  store i64 %81, i64* %val, align 8
  %82 = load i64, i64* %val, align 8
  %and = and i64 %82, 7
  %conv = trunc i64 %and to i32
  %cmp116 = icmp eq i32 %conv, 3
  br i1 %cmp116, label %if.then.118, label %if.end.119

if.then.118:                                      ; preds = %if.then.115
  %83 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %83, 3
  %84 = inttoptr i64 %sub to i8*
  %85 = bitcast i8* %84 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %85, i32 0, i32 0
  %86 = load i64, i64* %car, align 8
  store i64 %86, i64* %val, align 8
  br label %if.end.119

if.end.119:                                       ; preds = %if.then.118, %if.then.115
  br label %if.end.164

if.else:                                          ; preds = %if.end.108
  %87 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  %call120 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp121 = icmp eq i64 %87, %call120
  br i1 %cmp121, label %if.else.124, label %if.then.123

if.then.123:                                      ; preds = %if.else
  %88 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  store i64 %88, i64* %val, align 8
  br label %if.end.163

if.else.124:                                      ; preds = %if.else
  %89 = load i64, i64* %buffer, align 8
  %call125 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp126 = icmp eq i64 %89, %call125
  br i1 %cmp126, label %lor.lhs.false.132, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else.124
  %90 = load i64, i64* %buffer, align 8
  %call128 = call %struct.buffer* @XBUFFER(i64 %90)
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call128, i32 0, i32 39
  %91 = load i64, i64* %enable_multibyte_characters_, align 8
  %call129 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp130 = icmp eq i64 %91, %call129
  br i1 %cmp130, label %if.then.140, label %lor.lhs.false.132

lor.lhs.false.132:                                ; preds = %land.lhs.true, %if.else.124
  %92 = load i64, i64* %buffer, align 8
  %call133 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp134 = icmp eq i64 %92, %call133
  br i1 %cmp134, label %land.lhs.true.136, label %if.else.142

land.lhs.true.136:                                ; preds = %lor.lhs.false.132
  %93 = load i64, i64* getelementptr inbounds (%struct.buffer, %struct.buffer* @buffer_defaults, i32 0, i32 39), align 8
  %call137 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp138 = icmp eq i64 %93, %call137
  br i1 %cmp138, label %if.then.140, label %if.else.142

if.then.140:                                      ; preds = %land.lhs.true.136, %land.lhs.true
  %call141 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call141, i64* %val, align 8
  br label %if.end.162

if.else.142:                                      ; preds = %land.lhs.true.136, %lor.lhs.false.132
  %94 = load i64, i64* %coding_systems, align 8
  %and143 = and i64 %94, 7
  %conv144 = trunc i64 %and143 to i32
  %cmp145 = icmp eq i32 %conv144, 3
  br i1 %cmp145, label %if.then.147, label %if.else.150

if.then.147:                                      ; preds = %if.else.142
  %95 = load i64, i64* %coding_systems, align 8
  %sub148 = sub nsw i64 %95, 3
  %96 = inttoptr i64 %sub148 to i8*
  %97 = bitcast i8* %96 to %struct.Lisp_Cons*
  %car149 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %97, i32 0, i32 0
  %98 = load i64, i64* %car149, align 8
  store i64 %98, i64* %val, align 8
  br label %if.end.161

if.else.150:                                      ; preds = %if.else.142
  %99 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and151 = and i64 %99, 7
  %conv152 = trunc i64 %and151 to i32
  %cmp153 = icmp eq i32 %conv152, 3
  br i1 %cmp153, label %if.then.155, label %if.else.158

if.then.155:                                      ; preds = %if.else.150
  %100 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub156 = sub nsw i64 %100, 3
  %101 = inttoptr i64 %sub156 to i8*
  %102 = bitcast i8* %101 to %struct.Lisp_Cons*
  %car157 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %102, i32 0, i32 0
  %103 = load i64, i64* %car157, align 8
  store i64 %103, i64* %val, align 8
  br label %if.end.160

if.else.158:                                      ; preds = %if.else.150
  %call159 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call159, i64* %val, align 8
  br label %if.end.160

if.end.160:                                       ; preds = %if.else.158, %if.then.155
  br label %if.end.161

if.end.161:                                       ; preds = %if.end.160, %if.then.147
  br label %if.end.162

if.end.162:                                       ; preds = %if.end.161, %if.then.140
  br label %if.end.163

if.end.163:                                       ; preds = %if.end.162, %if.then.123
  br label %if.end.164

if.end.164:                                       ; preds = %if.end.163, %if.end.119
  %104 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %105 = load i64, i64* %val, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %104, i64 %105)
  %106 = load i64, i64* %tem, align 8
  %call165 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp166 = icmp eq i64 %106, %call165
  br i1 %cmp166, label %if.else.176, label %if.then.168

if.then.168:                                      ; preds = %if.end.164
  %107 = load i64, i64* %tem, align 8
  store i64 %107, i64* %val, align 8
  %108 = load i64, i64* %val, align 8
  %and169 = and i64 %108, 7
  %conv170 = trunc i64 %and169 to i32
  %cmp171 = icmp eq i32 %conv170, 3
  br i1 %cmp171, label %if.then.173, label %if.end.175

if.then.173:                                      ; preds = %if.then.168
  %109 = load i64, i64* %val, align 8
  %sub174 = sub nsw i64 %109, 3
  %110 = inttoptr i64 %sub174 to i8*
  %111 = bitcast i8* %110 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %111, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %112 = load i64, i64* %cdr, align 8
  store i64 %112, i64* %val, align 8
  br label %if.end.175

if.end.175:                                       ; preds = %if.then.173, %if.then.168
  br label %if.end.212

if.else.176:                                      ; preds = %if.end.164
  %113 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  %call177 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp178 = icmp eq i64 %113, %call177
  br i1 %cmp178, label %if.else.181, label %if.then.180

if.then.180:                                      ; preds = %if.else.176
  %114 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  store i64 %114, i64* %val, align 8
  br label %if.end.211

if.else.181:                                      ; preds = %if.else.176
  %115 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_182 = getelementptr inbounds %struct.buffer, %struct.buffer* %115, i32 0, i32 39
  %116 = load i64, i64* %enable_multibyte_characters_182, align 8
  %call183 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp184 = icmp eq i64 %116, %call183
  br i1 %cmp184, label %if.then.186, label %if.else.188

if.then.186:                                      ; preds = %if.else.181
  %call187 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call187, i64* %val, align 8
  br label %if.end.210

if.else.188:                                      ; preds = %if.else.181
  %117 = load i64, i64* %coding_systems, align 8
  %and189 = and i64 %117, 7
  %conv190 = trunc i64 %and189 to i32
  %cmp191 = icmp eq i32 %conv190, 3
  br i1 %cmp191, label %if.then.193, label %if.else.197

if.then.193:                                      ; preds = %if.else.188
  %118 = load i64, i64* %coding_systems, align 8
  %sub194 = sub nsw i64 %118, 3
  %119 = inttoptr i64 %sub194 to i8*
  %120 = bitcast i8* %119 to %struct.Lisp_Cons*
  %u195 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %120, i32 0, i32 1
  %cdr196 = bitcast %union.anon* %u195 to i64*
  %121 = load i64, i64* %cdr196, align 8
  store i64 %121, i64* %val, align 8
  br label %if.end.209

if.else.197:                                      ; preds = %if.else.188
  %122 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and198 = and i64 %122, 7
  %conv199 = trunc i64 %and198 to i32
  %cmp200 = icmp eq i32 %conv199, 3
  br i1 %cmp200, label %if.then.202, label %if.else.206

if.then.202:                                      ; preds = %if.else.197
  %123 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub203 = sub nsw i64 %123, 3
  %124 = inttoptr i64 %sub203 to i8*
  %125 = bitcast i8* %124 to %struct.Lisp_Cons*
  %u204 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %125, i32 0, i32 1
  %cdr205 = bitcast %union.anon* %u204 to i64*
  %126 = load i64, i64* %cdr205, align 8
  store i64 %126, i64* %val, align 8
  br label %if.end.208

if.else.206:                                      ; preds = %if.else.197
  %call207 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call207, i64* %val, align 8
  br label %if.end.208

if.end.208:                                       ; preds = %if.else.206, %if.then.202
  br label %if.end.209

if.end.209:                                       ; preds = %if.end.208, %if.then.193
  br label %if.end.210

if.end.210:                                       ; preds = %if.end.209, %if.then.186
  br label %if.end.211

if.end.211:                                       ; preds = %if.end.210, %if.then.180
  br label %if.end.212

if.end.212:                                       ; preds = %if.end.211, %if.end.175
  %127 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %128 = load i64, i64* %val, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %127, i64 %128)
  %129 = load i64, i64* %proc, align 8
  call void @setup_process_coding_systems(i64 %129)
  %130 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %131 = load i64, i64* %specpdl_count, align 8
  %add.ptr213 = getelementptr inbounds %union.specbinding, %union.specbinding* %130, i64 %131
  store %union.specbinding* %add.ptr213, %union.specbinding** @specpdl_ptr, align 8
  %132 = load i64, i64* %proc, align 8
  store i64 %132, i64* %retval
  br label %return

return:                                           ; preds = %if.end.212, %if.then
  %133 = load i64, i64* %retval
  ret i64 %133
}

declare i64 @concat2(i64, i64) #1

declare i64 @build_string(i8*) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_process(i64 %name) #0 {
entry:
  %name.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %tem = alloca i64, align 8
  %name1 = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %suffix = alloca [23 x i8], align 16
  %i = alloca i64, align 8
  store i64 %name, i64* %name.addr, align 8
  %call = call %struct.Lisp_Process* @allocate_process()
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %0, i64 %call1)
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call2 = call i64 @Fmake_marker()
  call void @pset_mark(%struct.Lisp_Process* %1, i64 %call2)
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 21
  store i32 -1, i32* %infd, align 4
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 22
  store i32 -1, i32* %outfd, align 4
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i64, i64* %i, align 8
  %cmp = icmp slt i64 %4, 6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64, i64* %i, align 8
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 %5
  store i32 -1, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, i64* %i, align 8
  %inc = add nsw i64 %7, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_initstage = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 30
  store i32 0, i32* %gnutls_initstage, align 4
  %9 = load i64, i64* %name.addr, align 8
  store i64 %9, i64* %name1, align 8
  store i64 1, i64* %i, align 8
  br label %for.cond.3

for.cond.3:                                       ; preds = %for.inc.9, %for.end
  %10 = load i64, i64* %name1, align 8
  %call4 = call i64 @Fget_process(i64 %10)
  store i64 %call4, i64* %tem, align 8
  %11 = load i64, i64* %tem, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %11, %call5
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond.3
  br label %for.end.11

if.end:                                           ; preds = %for.cond.3
  %12 = load i64, i64* %name.addr, align 8
  %arraydecay = getelementptr inbounds [23 x i8], [23 x i8]* %suffix, i32 0, i32 0
  %13 = load i64, i64* %i, align 8
  %call7 = call i64 (i8*, i8*, ...) @make_formatted_string(i8* %arraydecay, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.61, i32 0, i32 0), i64 %13)
  %call8 = call i64 @concat2(i64 %12, i64 %call7)
  store i64 %call8, i64* %name1, align 8
  br label %for.inc.9

for.inc.9:                                        ; preds = %if.end
  %14 = load i64, i64* %i, align 8
  %inc10 = add nsw i64 %14, 1
  store i64 %inc10, i64* %i, align 8
  br label %for.cond.3

for.end.11:                                       ; preds = %if.then
  %15 = load i64, i64* %name1, align 8
  store i64 %15, i64* %name.addr, align 8
  %16 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %17 = load i64, i64* %name.addr, align 8
  call void @pset_name(%struct.Lisp_Process* %16, i64 %17)
  %18 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 565)
  call void @pset_sentinel(%struct.Lisp_Process* %18, i64 %call12)
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 564)
  call void @pset_filter(%struct.Lisp_Process* %19, i64 %call13)
  %20 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %21 = bitcast %struct.Lisp_Process* %20 to i8*
  %call14 = call i64 @make_lisp_ptr(i8* %21, i32 5)
  store i64 %call14, i64* %val, align 8
  %22 = load i64, i64* %name.addr, align 8
  %23 = load i64, i64* %val, align 8
  %call15 = call i64 @Fcons(i64 %22, i64 %23)
  %24 = load i64, i64* @Vprocess_alist, align 8
  %call16 = call i64 @Fcons(i64 %call15, i64 %24)
  store i64 %call16, i64* @Vprocess_alist, align 8
  %25 = load i64, i64* %val, align 8
  ret i64 %25
}

declare void @record_unwind_protect(void (i64)*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @start_process_unwind(i64 %proc) #0 {
entry:
  %proc.addr = alloca i64, align 8
  store i64 %proc, i64* %proc.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %proc.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 20
  %2 = load i32, i32* %pid, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %land.lhs.true, label %if.end.6

land.lhs.true:                                    ; preds = %if.end
  %3 = load i64, i64* %proc.addr, align 8
  %call2 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %pid3 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call2, i32 0, i32 20
  %4 = load i32, i32* %pid3, align 4
  %cmp4 = icmp ne i32 %4, -2
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %land.lhs.true
  %5 = load i64, i64* %proc.addr, align 8
  call void @remove_process(i64 %5)
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %land.lhs.true, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pset_type(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 10
  store i64 %0, i64* %type, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pset_command(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 3
  store i64 %0, i64* %command, align 8
  ret void
}

declare i64 @Fcopy_sequence(i64) #1

; Function Attrs: noreturn
declare void @report_file_error(i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal void @pset_stderrproc(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %stderrproc = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 19
  store i64 %0, i64* %stderrproc, align 8
  ret void
}

declare void @pset_gnutls_cred_type(%struct.Lisp_Process*, i64) #1

declare zeroext i1 @BUFFERP(i64) #1

declare i64 @set_marker_both(i64, i64, i64, i64) #1

declare %struct.buffer* @XBUFFER(i64) #1

declare i64 @marker_position(i64) #1

declare i64 @marker_byte_position(i64) #1

declare i64 @Flength(i64) #1

; Function Attrs: noreturn
declare void @memory_full(i64) #2

declare noalias i8* @xmalloc(i64) #1

declare i64 @make_save_memory(i64*, i64) #1

declare void @free_save_value(i64) #1

declare i64 @Ffind_operation_coding_system(i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal void @pset_decode_coding_system(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 13
  store i64 %0, i64* %decode_coding_system, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pset_encode_coding_system(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 15
  store i64 %0, i64* %encode_coding_system, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pset_decoding_buf(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decoding_buf = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 14
  store i64 %0, i64* %decoding_buf, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @pset_encoding_buf(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %encoding_buf = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 16
  store i64 %0, i64* %encoding_buf, align 8
  ret void
}

declare zeroext i8 @SREF(i64, i64) #1

declare i64 @SCHARS(i64) #1

declare i32 @openp(i64, i64, i64, i64*, i64, i1 zeroext) #1

declare i64 @Fexpand_file_name(i64, i64) #1

declare i64 @Ffile_directory_p(i64) #1

; Function Attrs: nounwind uwtable
define i64 @remove_slash_colon(i64 %name) #0 {
entry:
  %name.addr = alloca i64, align 8
  store i64 %name, i64* %name.addr, align 8
  %0 = load i64, i64* %name.addr, align 8
  %call = call i64 @SBYTES(i64 %0)
  %cmp = icmp sgt i64 %call, 2
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %name.addr, align 8
  %call1 = call zeroext i8 @SREF(i64 %1, i64 0)
  %conv = zext i8 %call1 to i32
  %cmp2 = icmp eq i32 %conv, 47
  br i1 %cmp2, label %land.lhs.true.4, label %cond.false

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %2 = load i64, i64* %name.addr, align 8
  %call5 = call zeroext i8 @SREF(i64 %2, i64 1)
  %conv6 = zext i8 %call5 to i32
  %cmp7 = icmp eq i32 %conv6, 58
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.4
  %3 = load i64, i64* %name.addr, align 8
  %call9 = call i8* @SSDATA(i64 %3)
  %add.ptr = getelementptr inbounds i8, i8* %call9, i64 2
  %4 = load i64, i64* %name.addr, align 8
  %call10 = call i64 @SCHARS(i64 %4)
  %sub = sub nsw i64 %call10, 2
  %5 = load i64, i64* %name.addr, align 8
  %call11 = call i64 @SBYTES(i64 %5)
  %sub12 = sub nsw i64 %call11, 2
  %6 = load i64, i64* %name.addr, align 8
  %call13 = call zeroext i1 @STRING_MULTIBYTE(i64 %6)
  %call14 = call i64 @make_specified_string(i8* %add.ptr, i64 %sub, i64 %sub12, i1 zeroext %call13)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.4, %land.lhs.true, %entry
  %7 = load i64, i64* %name.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call14, %cond.true ], [ %7, %cond.false ]
  ret i64 %cond
}

declare i64 @list1(i64) #1

declare i64 @encode_file_name(i64) #1

declare zeroext i1 @STRING_MULTIBYTE(i64) #1

declare i64 @complement_process_encoding_system(i64) #1

declare i64 @code_convert_string_norecord(i64, i64, i1 zeroext) #1

declare noalias i8* @xnmalloc(i64, i64) #1

declare void @record_unwind_protect_ptr(void (i8*)*, i8*) #1

declare void @xfree(i8*) #1

declare i8* @SSDATA(i64) #1

; Function Attrs: nounwind uwtable
define internal void @create_process(i64 %process, i8** %new_argv, i64 %current_dir) #0 {
entry:
  %process.addr = alloca i64, align 8
  %new_argv.addr = alloca i8**, align 8
  %current_dir.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %inchannel = alloca i32, align 4
  %outchannel = alloca i32, align 4
  %pid = alloca i32, align 4
  %vfork_errno = alloca i32, align 4
  %forkin = alloca i32, align 4
  %forkout = alloca i32, align 4
  %forkerr = alloca i32, align 4
  %pty_flag = alloca i8, align 1
  %pty_name = alloca [24 x i8], align 16
  %lisp_pty_name = alloca i64, align 8
  %oldset = alloca %struct.__sigset_t, align 8
  %pp = alloca %struct.Lisp_Process*, align 8
  %current_dir_volatile = alloca i64, align 8
  %lisp_pty_name_volatile = alloca i64, align 8
  %new_argv_volatile = alloca i8**, align 8
  %forkin_volatile = alloca i32, align 4
  %forkout_volatile = alloca i32, align 4
  %forkerr_volatile = alloca i32, align 4
  %p_volatile = alloca %struct.Lisp_Process*, align 8
  %j = alloca i32, align 4
  %dummy = alloca i8, align 1
  %pp137 = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i8** %new_argv, i8*** %new_argv.addr, align 8
  store i64 %current_dir, i64* %current_dir.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  store i32 -1, i32* %forkerr, align 4
  store i8 0, i8* %pty_flag, align 1
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %lisp_pty_name, align 8
  store i32 -1, i32* %outchannel, align 4
  store i32 -1, i32* %inchannel, align 4
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag2 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 28
  %bf.load = load i8, i8* %pty_flag2, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %pty_name, i32 0, i32 0
  %call3 = call i32 @allocate_pty(i8* %arraydecay)
  store i32 %call3, i32* %inchannel, align 4
  store i32 %call3, i32* %outchannel, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, i32* %inchannel, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.end
  %3 = load i32, i32* %inchannel, align 4
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 2
  store i32 %3, i32* %arrayidx, align 4
  store i32 -1, i32* %forkout, align 4
  store i32 -1, i32* %forkin, align 4
  store i8 1, i8* %pty_flag, align 1
  %arraydecay5 = getelementptr inbounds [24 x i8], [24 x i8]* %pty_name, i32 0, i32 0
  %call6 = call i64 @build_string(i8* %arraydecay5)
  store i64 %call6, i64* %lisp_pty_name, align 8
  br label %if.end.39

if.else:                                          ; preds = %if.end
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd7 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 23
  %arraydecay8 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd7, i32 0, i32 0
  %add.ptr = getelementptr inbounds i32, i32* %arraydecay8, i64 0
  %call9 = call i32 @emacs_pipe(i32* %add.ptr)
  %cmp10 = icmp ne i32 %call9, 0
  br i1 %cmp10, label %if.then.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd11 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 23
  %arraydecay12 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd11, i32 0, i32 0
  %add.ptr13 = getelementptr inbounds i32, i32* %arraydecay12, i64 2
  %call14 = call i32 @emacs_pipe(i32* %add.ptr13)
  %cmp15 = icmp ne i32 %call14, 0
  br i1 %cmp15, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %lor.lhs.false, %if.else
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.10, i32 0, i32 0), i64 %call17) #8
  unreachable

if.end.18:                                        ; preds = %lor.lhs.false
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd19 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 23
  %arrayidx20 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd19, i32 0, i64 0
  %8 = load i32, i32* %arrayidx20, align 4
  store i32 %8, i32* %forkin, align 4
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd21 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 23
  %arrayidx22 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd21, i32 0, i64 1
  %10 = load i32, i32* %arrayidx22, align 4
  store i32 %10, i32* %outchannel, align 4
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd23 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 23
  %arrayidx24 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd23, i32 0, i64 2
  %12 = load i32, i32* %arrayidx24, align 4
  store i32 %12, i32* %inchannel, align 4
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd25 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %13, i32 0, i32 23
  %arrayidx26 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd25, i32 0, i64 3
  %14 = load i32, i32* %arrayidx26, align 4
  store i32 %14, i32* %forkout, align 4
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %stderrproc = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 19
  %16 = load i64, i64* %stderrproc, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %16, %call27
  br i1 %cmp28, label %if.end.38, label %if.then.29

if.then.29:                                       ; preds = %if.end.18
  %17 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %stderrproc30 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %17, i32 0, i32 19
  %18 = load i64, i64* %stderrproc30, align 8
  %call31 = call %struct.Lisp_Process* @XPROCESS(i64 %18)
  store %struct.Lisp_Process* %call31, %struct.Lisp_Process** %pp, align 8
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %pp, align 8
  %open_fd32 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 23
  %arrayidx33 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd32, i32 0, i64 3
  %20 = load i32, i32* %arrayidx33, align 4
  store i32 %20, i32* %forkerr, align 4
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %pp, align 8
  %open_fd34 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 23
  %arrayidx35 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd34, i32 0, i64 1
  call void @close_process_fd(i32* %arrayidx35)
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %pp, align 8
  %open_fd36 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %22, i32 0, i32 23
  %arrayidx37 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd36, i32 0, i64 0
  call void @close_process_fd(i32* %arrayidx37)
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.29, %if.end.18
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.4
  %23 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd40 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %23, i32 0, i32 23
  %arraydecay41 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd40, i32 0, i32 0
  %add.ptr42 = getelementptr inbounds i32, i32* %arraydecay41, i64 4
  %call43 = call i32 @emacs_pipe(i32* %add.ptr42)
  %cmp44 = icmp ne i32 %call43, 0
  br i1 %cmp44, label %if.then.45, label %if.end.47

if.then.45:                                       ; preds = %if.end.39
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.10, i32 0, i32 0), i64 %call46) #8
  unreachable

if.end.47:                                        ; preds = %if.end.39
  %24 = load i32, i32* %inchannel, align 4
  %call48 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %24, i32 4, i32 2048)
  %25 = load i32, i32* %outchannel, align 4
  %call49 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %25, i32 4, i32 2048)
  %26 = load i64, i64* %process.addr, align 8
  %27 = load i32, i32* %inchannel, align 4
  %idxprom = sext i32 %27 to i64
  %arrayidx50 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  store i64 %26, i64* %arrayidx50, align 8
  %28 = load i32, i32* %inchannel, align 4
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %29, i32 0, i32 21
  store i32 %28, i32* %infd, align 4
  %30 = load i32, i32* %outchannel, align 4
  %31 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %31, i32 0, i32 22
  store i32 %30, i32* %outfd, align 4
  %32 = load i8, i8* %pty_flag, align 1
  %tobool = trunc i8 %32 to i1
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag51 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %33, i32 0, i32 28
  %34 = zext i1 %tobool to i8
  %bf.load52 = load i8, i8* %pty_flag51, align 8
  %bf.shl = shl i8 %34, 4
  %bf.clear53 = and i8 %bf.load52, -17
  %bf.set = or i8 %bf.clear53, %bf.shl
  store i8 %bf.set, i8* %pty_flag51, align 8
  %tobool54 = trunc i8 %34 to i1
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %35, i64 %call55)
  %36 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %36, i32 0, i32 3
  %37 = load i64, i64* %command, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp57 = icmp eq i64 %37, %call56
  br i1 %cmp57, label %if.end.59, label %if.then.58

if.then.58:                                       ; preds = %if.end.47
  %38 = load i32, i32* %inchannel, align 4
  call void @fd_SET(i32 %38, %struct.fd_set* @input_wait_mask)
  %39 = load i32, i32* %inchannel, align 4
  call void @fd_SET(i32 %39, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.59

if.end.59:                                        ; preds = %if.then.58, %if.end.47
  %40 = load i32, i32* %inchannel, align 4
  %41 = load i32, i32* @max_process_desc, align 4
  %cmp60 = icmp sgt i32 %40, %41
  br i1 %cmp60, label %if.then.61, label %if.end.62

if.then.61:                                       ; preds = %if.end.59
  %42 = load i32, i32* %inchannel, align 4
  store i32 %42, i32* @max_process_desc, align 4
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.61, %if.end.59
  %43 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %43)
  call void @block_input()
  call void @block_child_signal(%struct.__sigset_t* %oldset)
  %44 = load i64, i64* %current_dir.addr, align 8
  store volatile i64 %44, i64* %current_dir_volatile, align 8
  %45 = load i64, i64* %lisp_pty_name, align 8
  store volatile i64 %45, i64* %lisp_pty_name_volatile, align 8
  %46 = load i8**, i8*** %new_argv.addr, align 8
  store volatile i8** %46, i8*** %new_argv_volatile, align 8
  %47 = load i32, i32* %forkin, align 4
  store volatile i32 %47, i32* %forkin_volatile, align 4
  %48 = load i32, i32* %forkout, align 4
  store volatile i32 %48, i32* %forkout_volatile, align 4
  %49 = load i32, i32* %forkerr, align 4
  store volatile i32 %49, i32* %forkerr_volatile, align 4
  %50 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  store %struct.Lisp_Process* %50, %struct.Lisp_Process** %p_volatile, align 8
  %call63 = call i32 @vfork() #10
  store i32 %call63, i32* %pid, align 4
  %51 = load volatile i64, i64* %current_dir_volatile, align 8
  store i64 %51, i64* %current_dir.addr, align 8
  %52 = load volatile i64, i64* %lisp_pty_name_volatile, align 8
  store i64 %52, i64* %lisp_pty_name, align 8
  %53 = load volatile i8**, i8*** %new_argv_volatile, align 8
  store i8** %53, i8*** %new_argv.addr, align 8
  %54 = load volatile i32, i32* %forkin_volatile, align 4
  store i32 %54, i32* %forkin, align 4
  %55 = load volatile i32, i32* %forkout_volatile, align 4
  store i32 %55, i32* %forkout, align 4
  %56 = load volatile i32, i32* %forkerr_volatile, align 4
  store i32 %56, i32* %forkerr, align 4
  %57 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p_volatile, align 8
  store %struct.Lisp_Process* %57, %struct.Lisp_Process** %p, align 8
  %58 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag64 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %58, i32 0, i32 28
  %bf.load65 = load i8, i8* %pty_flag64, align 8
  %bf.lshr66 = lshr i8 %bf.load65, 4
  %bf.clear67 = and i8 %bf.lshr66, 1
  %bf.cast68 = trunc i8 %bf.clear67 to i1
  %frombool = zext i1 %bf.cast68 to i8
  store i8 %frombool, i8* %pty_flag, align 1
  %59 = load i32, i32* %pid, align 4
  %cmp69 = icmp eq i32 %59, 0
  br i1 %cmp69, label %if.then.70, label %if.end.109

if.then.70:                                       ; preds = %if.end.62
  %call71 = call i32 @setsid() #5
  %60 = load i8, i8* %pty_flag, align 1
  %tobool72 = trunc i8 %60 to i1
  br i1 %tobool72, label %land.lhs.true, label %if.end.76

land.lhs.true:                                    ; preds = %if.then.70
  %61 = load i32, i32* %forkin, align 4
  %cmp73 = icmp sge i32 %61, 0
  br i1 %cmp73, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %land.lhs.true
  %62 = load i32, i32* %forkin, align 4
  %call75 = call i32 (i32, i64, ...) @ioctl(i32 %62, i64 21518, i32 0) #5
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %land.lhs.true, %if.then.70
  %63 = load i8, i8* %pty_flag, align 1
  %tobool77 = trunc i8 %63 to i1
  br i1 %tobool77, label %if.then.78, label %if.end.85

if.then.78:                                       ; preds = %if.end.76
  %call79 = call i32 @emacs_open(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.62, i32 0, i32 0), i32 2, i32 0)
  store i32 %call79, i32* %j, align 4
  %64 = load i32, i32* %j, align 4
  %cmp80 = icmp sge i32 %64, 0
  br i1 %cmp80, label %if.then.81, label %if.end.84

if.then.81:                                       ; preds = %if.then.78
  %65 = load i32, i32* %j, align 4
  %call82 = call i32 (i32, i64, ...) @ioctl(i32 %65, i64 21538, i32 0) #5
  %66 = load i32, i32* %j, align 4
  %call83 = call i32 @emacs_close(i32 %66)
  br label %if.end.84

if.end.84:                                        ; preds = %if.then.81, %if.then.78
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.end.76
  %67 = load i8, i8* %pty_flag, align 1
  %tobool86 = trunc i8 %67 to i1
  br i1 %tobool86, label %if.then.87, label %if.end.98

if.then.87:                                       ; preds = %if.end.85
  %68 = load i32, i32* %forkin, align 4
  %cmp88 = icmp sge i32 %68, 0
  br i1 %cmp88, label %if.then.89, label %if.end.91

if.then.89:                                       ; preds = %if.then.87
  %69 = load i32, i32* %forkin, align 4
  %call90 = call i32 @emacs_close(i32 %69)
  br label %if.end.91

if.end.91:                                        ; preds = %if.then.89, %if.then.87
  %70 = load i64, i64* %lisp_pty_name, align 8
  %call92 = call i8* @SSDATA(i64 %70)
  %call93 = call i32 @emacs_open(i8* %call92, i32 2, i32 0)
  store i32 %call93, i32* %forkin, align 4
  store i32 %call93, i32* %forkout, align 4
  %71 = load i32, i32* %forkin, align 4
  %cmp94 = icmp slt i32 %71, 0
  br i1 %cmp94, label %if.then.95, label %if.end.97

if.then.95:                                       ; preds = %if.end.91
  %72 = load i64, i64* %lisp_pty_name, align 8
  %call96 = call i8* @SSDATA(i64 %72)
  call void @emacs_perror(i8* %call96)
  call void @_exit(i32 125) #8
  unreachable

if.end.97:                                        ; preds = %if.end.91
  br label %if.end.98

if.end.98:                                        ; preds = %if.end.97, %if.end.85
  %call99 = call void (i32)* @signal(i32 2, void (i32)* null) #5
  %call100 = call void (i32)* @signal(i32 3, void (i32)* null) #5
  %call101 = call void (i32)* @signal(i32 27, void (i32)* null) #5
  %call102 = call void (i32)* @signal(i32 13, void (i32)* null) #5
  call void @unblock_child_signal(%struct.__sigset_t* %oldset)
  %73 = load i8, i8* %pty_flag, align 1
  %tobool103 = trunc i8 %73 to i1
  br i1 %tobool103, label %if.then.104, label %if.end.105

if.then.104:                                      ; preds = %if.end.98
  %74 = load i32, i32* %forkout, align 4
  call void @child_setup_tty(i32 %74)
  br label %if.end.105

if.end.105:                                       ; preds = %if.then.104, %if.end.98
  %75 = load i32, i32* %forkerr, align 4
  %cmp106 = icmp slt i32 %75, 0
  br i1 %cmp106, label %if.then.107, label %if.end.108

if.then.107:                                      ; preds = %if.end.105
  %76 = load i32, i32* %forkout, align 4
  store i32 %76, i32* %forkerr, align 4
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.107, %if.end.105
  %77 = load i32, i32* %forkin, align 4
  %78 = load i32, i32* %forkout, align 4
  %79 = load i32, i32* %forkerr, align 4
  %80 = load i8**, i8*** %new_argv.addr, align 8
  %81 = load i64, i64* %current_dir.addr, align 8
  %82 = call i32 @child_setup(i32 %77, i32 %78, i32 %79, i8** %80, i1 zeroext true, i64 %81) #8
  unreachable

if.end.109:                                       ; preds = %if.end.62
  %call110 = call i32* @__errno_location() #11
  %83 = load i32, i32* %call110, align 4
  store i32 %83, i32* %vfork_errno, align 4
  %84 = load i32, i32* %pid, align 4
  %85 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid111 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %85, i32 0, i32 20
  store i32 %84, i32* %pid111, align 4
  %86 = load i32, i32* %pid, align 4
  %cmp112 = icmp sge i32 %86, 0
  br i1 %cmp112, label %if.then.113, label %if.end.117

if.then.113:                                      ; preds = %if.end.109
  %87 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %alive = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %87, i32 0, i32 28
  %bf.load114 = load i8, i8* %alive, align 8
  %bf.clear115 = and i8 %bf.load114, -65
  %bf.set116 = or i8 %bf.clear115, 64
  store i8 %bf.set116, i8* %alive, align 8
  br label %if.end.117

if.end.117:                                       ; preds = %if.then.113, %if.end.109
  call void @unblock_child_signal(%struct.__sigset_t* %oldset)
  call void @unblock_input()
  %88 = load i32, i32* %pid, align 4
  %cmp118 = icmp slt i32 %88, 0
  br i1 %cmp118, label %if.then.119, label %if.else.121

if.then.119:                                      ; preds = %if.end.117
  %call120 = call i64 @builtin_lisp_symbol(i32 0)
  %89 = load i32, i32* %vfork_errno, align 4
  call void @report_file_errno(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.63, i32 0, i32 0), i64 %call120, i32 %89) #8
  unreachable

if.else.121:                                      ; preds = %if.end.117
  %90 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd122 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %90, i32 0, i32 23
  %arrayidx123 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd122, i32 0, i64 0
  call void @close_process_fd(i32* %arrayidx123)
  %91 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd124 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %91, i32 0, i32 23
  %arrayidx125 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd124, i32 0, i64 3
  call void @close_process_fd(i32* %arrayidx125)
  %92 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %93 = load i64, i64* %lisp_pty_name, align 8
  call void @pset_tty_name(%struct.Lisp_Process* %92, i64 %93)
  %94 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd126 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %94, i32 0, i32 23
  %arrayidx127 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd126, i32 0, i64 5
  call void @close_process_fd(i32* %arrayidx127)
  %95 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd128 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %95, i32 0, i32 23
  %arrayidx129 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd128, i32 0, i64 4
  %96 = load i32, i32* %arrayidx129, align 4
  %call130 = call i64 @emacs_read(i32 %96, i8* %dummy, i64 1)
  %97 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd131 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %97, i32 0, i32 23
  %arrayidx132 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd131, i32 0, i64 4
  call void @close_process_fd(i32* %arrayidx132)
  %98 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %stderrproc133 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %98, i32 0, i32 19
  %99 = load i64, i64* %stderrproc133, align 8
  %call134 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp135 = icmp eq i64 %99, %call134
  br i1 %cmp135, label %if.end.142, label %if.then.136

if.then.136:                                      ; preds = %if.else.121
  %100 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %stderrproc138 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %100, i32 0, i32 19
  %101 = load i64, i64* %stderrproc138, align 8
  %call139 = call %struct.Lisp_Process* @XPROCESS(i64 %101)
  store %struct.Lisp_Process* %call139, %struct.Lisp_Process** %pp137, align 8
  %102 = load %struct.Lisp_Process*, %struct.Lisp_Process** %pp137, align 8
  %open_fd140 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %102, i32 0, i32 23
  %arrayidx141 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd140, i32 0, i64 3
  call void @close_process_fd(i32* %arrayidx141)
  br label %if.end.142

if.end.142:                                       ; preds = %if.then.136, %if.else.121
  br label %if.end.143

if.end.143:                                       ; preds = %if.end.142
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @create_pty(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %pty_name = alloca [24 x i8], align 16
  %pty_fd = alloca i32, align 4
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 28
  %bf.load = load i8, i8* %pty_flag, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %pty_name, i32 0, i32 0
  %call1 = call i32 @allocate_pty(i8* %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ -1, %cond.true ], [ %call1, %cond.false ]
  store i32 %cond, i32* %pty_fd, align 4
  %2 = load i32, i32* %pty_fd, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end.12

if.then:                                          ; preds = %cond.end
  %3 = load i32, i32* %pty_fd, align 4
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 0
  store i32 %3, i32* %arrayidx, align 4
  %5 = load i32, i32* %pty_fd, align 4
  %call2 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %5, i32 4, i32 2048)
  %6 = load i64, i64* %process.addr, align 8
  %7 = load i32, i32* %pty_fd, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx3 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  store i64 %6, i64* %arrayidx3, align 8
  %8 = load i32, i32* %pty_fd, align 4
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 21
  store i32 %8, i32* %infd, align 4
  %10 = load i32, i32* %pty_fd, align 4
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 22
  store i32 %10, i32* %outfd, align 4
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 28
  %bf.load5 = load i8, i8* %pty_flag4, align 8
  %bf.clear6 = and i8 %bf.load5, -17
  %bf.set = or i8 %bf.clear6, 16
  store i8 %bf.set, i8* %pty_flag4, align 8
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %13, i64 %call7)
  %14 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %14)
  %15 = load i32, i32* %pty_fd, align 4
  call void @fd_SET(i32 %15, %struct.fd_set* @input_wait_mask)
  %16 = load i32, i32* %pty_fd, align 4
  call void @fd_SET(i32 %16, %struct.fd_set* @non_keyboard_wait_mask)
  %17 = load i32, i32* %pty_fd, align 4
  %18 = load i32, i32* @max_process_desc, align 4
  %cmp8 = icmp sgt i32 %17, %18
  br i1 %cmp8, label %if.then.9, label %if.end

if.then.9:                                        ; preds = %if.then
  %19 = load i32, i32* %pty_fd, align 4
  store i32 %19, i32* @max_process_desc, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.9, %if.then
  %20 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %arraydecay10 = getelementptr inbounds [24 x i8], [24 x i8]* %pty_name, i32 0, i32 0
  %call11 = call i64 @build_string(i8* %arraydecay10)
  call void @pset_tty_name(%struct.Lisp_Process* %20, i64 %call11)
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %cond.end
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 20
  store i32 -2, i32* %pid, align 4
  ret void
}

declare i64 @unbind_to(i64, i64) #1

declare i32 @emacs_pipe(i32*) #1

declare i32 @rpl_fcntl(i32, i32, ...) #1

; Function Attrs: nounwind uwtable
define internal void @pset_log(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %log = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 6
  store i64 %0, i64* %log, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %sa, i32 %len) #0 {
entry:
  %retval = alloca i64, align 8
  %sa.addr = alloca %struct.sockaddr*, align 8
  %len.addr = alloca i32, align 4
  %address = alloca i64, align 8
  %i = alloca i32, align 4
  %cp = alloca i8*, align 8
  %p = alloca %struct.Lisp_Vector*, align 8
  %sin = alloca %struct.sockaddr_in*, align 8
  %sin6 = alloca %struct.sockaddr_in6*, align 8
  %ip6 = alloca i16*, align 8
  %sockun = alloca %struct.sockaddr_un*, align 8
  %name_length = alloca i64, align 8
  %terminator = alloca i8*, align 8
  store %struct.sockaddr* %sa, %struct.sockaddr** %sa.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* @empty_unibyte_string, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %2, i32 0, i32 0
  %3 = load i16, i16* %sa_family, align 2
  %conv2 = zext i16 %3 to i32
  switch i32 %conv2, label %sw.default [
    i32 2, label %sw.bb
    i32 10, label %sw.bb.10
    i32 1, label %sw.bb.36
  ]

sw.bb:                                            ; preds = %if.end
  %4 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %5 = bitcast %struct.sockaddr* %4 to %struct.sockaddr_in*
  store %struct.sockaddr_in* %5, %struct.sockaddr_in** %sin, align 8
  store i32 5, i32* %len.addr, align 4
  %6 = load i32, i32* %len.addr, align 4
  %conv3 = sext i32 %6 to i64
  %shl = shl i64 %conv3, 2
  %add = add i64 %shl, 2
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fmake_vector(i64 %add, i64 %call)
  store i64 %call4, i64* %address, align 8
  %7 = load i64, i64* %address, align 8
  %call5 = call %struct.Lisp_Vector* @XVECTOR(i64 %7)
  store %struct.Lisp_Vector* %call5, %struct.Lisp_Vector** %p, align 8
  %8 = load %struct.sockaddr_in*, %struct.sockaddr_in** %sin, align 8
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %8, i32 0, i32 1
  %9 = load i16, i16* %sin_port, align 2
  %call6 = call zeroext i16 @ntohs(i16 zeroext %9) #11
  %conv7 = zext i16 %call6 to i64
  %shl8 = shl i64 %conv7, 2
  %add9 = add i64 %shl8, 2
  %10 = load i32, i32* %len.addr, align 4
  %dec = add nsw i32 %10, -1
  store i32 %dec, i32* %len.addr, align 4
  %idxprom = sext i32 %dec to i64
  %11 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %11, i32 0, i32 1
  %arrayidx = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i64 %idxprom
  store i64 %add9, i64* %arrayidx, align 8
  %12 = load %struct.sockaddr_in*, %struct.sockaddr_in** %sin, align 8
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %12, i32 0, i32 2
  %13 = bitcast %struct.in_addr* %sin_addr to i8*
  store i8* %13, i8** %cp, align 8
  br label %sw.epilog

sw.bb.10:                                         ; preds = %if.end
  %14 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %15 = bitcast %struct.sockaddr* %14 to %struct.sockaddr_in6*
  store %struct.sockaddr_in6* %15, %struct.sockaddr_in6** %sin6, align 8
  %16 = load %struct.sockaddr_in6*, %struct.sockaddr_in6** %sin6, align 8
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %16, i32 0, i32 3
  %17 = bitcast %struct.in6_addr* %sin6_addr to i16*
  store i16* %17, i16** %ip6, align 8
  store i32 9, i32* %len.addr, align 4
  %18 = load i32, i32* %len.addr, align 4
  %conv11 = sext i32 %18 to i64
  %shl12 = shl i64 %conv11, 2
  %add13 = add i64 %shl12, 2
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %call15 = call i64 @Fmake_vector(i64 %add13, i64 %call14)
  store i64 %call15, i64* %address, align 8
  %19 = load i64, i64* %address, align 8
  %call16 = call %struct.Lisp_Vector* @XVECTOR(i64 %19)
  store %struct.Lisp_Vector* %call16, %struct.Lisp_Vector** %p, align 8
  %20 = load %struct.sockaddr_in6*, %struct.sockaddr_in6** %sin6, align 8
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %20, i32 0, i32 1
  %21 = load i16, i16* %sin6_port, align 2
  %call17 = call zeroext i16 @ntohs(i16 zeroext %21) #11
  %conv18 = zext i16 %call17 to i64
  %shl19 = shl i64 %conv18, 2
  %add20 = add i64 %shl19, 2
  %22 = load i32, i32* %len.addr, align 4
  %dec21 = add nsw i32 %22, -1
  store i32 %dec21, i32* %len.addr, align 4
  %idxprom22 = sext i32 %dec21 to i64
  %23 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents23 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %23, i32 0, i32 1
  %arrayidx24 = getelementptr inbounds [0 x i64], [0 x i64]* %contents23, i32 0, i64 %idxprom22
  store i64 %add20, i64* %arrayidx24, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.10
  %24 = load i32, i32* %i, align 4
  %25 = load i32, i32* %len.addr, align 4
  %cmp25 = icmp slt i32 %24, %25
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %26 = load i32, i32* %i, align 4
  %idxprom27 = sext i32 %26 to i64
  %27 = load i16*, i16** %ip6, align 8
  %arrayidx28 = getelementptr inbounds i16, i16* %27, i64 %idxprom27
  %28 = load i16, i16* %arrayidx28, align 2
  %call29 = call zeroext i16 @ntohs(i16 zeroext %28) #11
  %conv30 = zext i16 %call29 to i64
  %shl31 = shl i64 %conv30, 2
  %add32 = add i64 %shl31, 2
  %29 = load i32, i32* %i, align 4
  %idxprom33 = sext i32 %29 to i64
  %30 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents34 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %30, i32 0, i32 1
  %arrayidx35 = getelementptr inbounds [0 x i64], [0 x i64]* %contents34, i32 0, i64 %idxprom33
  store i64 %add32, i64* %arrayidx35, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %31 = load i32, i32* %i, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %32 = load i64, i64* %address, align 8
  store i64 %32, i64* %retval
  br label %return

sw.bb.36:                                         ; preds = %if.end
  %33 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %34 = bitcast %struct.sockaddr* %33 to %struct.sockaddr_un*
  store %struct.sockaddr_un* %34, %struct.sockaddr_un** %sockun, align 8
  %35 = load i32, i32* %len.addr, align 4
  %conv37 = sext i32 %35 to i64
  %sub = sub i64 %conv37, 2
  store i64 %sub, i64* %name_length, align 8
  %36 = load i64, i64* %name_length, align 8
  %cmp38 = icmp sgt i64 %36, 0
  br i1 %cmp38, label %land.lhs.true, label %if.end.51

land.lhs.true:                                    ; preds = %sw.bb.36
  %37 = load %struct.sockaddr_un*, %struct.sockaddr_un** %sockun, align 8
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %37, i32 0, i32 1
  %arrayidx40 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i64 0
  %38 = load i8, i8* %arrayidx40, align 1
  %conv41 = sext i8 %38 to i32
  %cmp42 = icmp ne i32 %conv41, 0
  br i1 %cmp42, label %if.then.44, label %if.end.51

if.then.44:                                       ; preds = %land.lhs.true
  %39 = load %struct.sockaddr_un*, %struct.sockaddr_un** %sockun, align 8
  %sun_path45 = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %39, i32 0, i32 1
  %arraydecay = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path45, i32 0, i32 0
  %40 = load i64, i64* %name_length, align 8
  %call46 = call i8* @memchr(i8* %arraydecay, i32 0, i64 %40) #9
  store i8* %call46, i8** %terminator, align 8
  %41 = load i8*, i8** %terminator, align 8
  %tobool = icmp ne i8* %41, null
  br i1 %tobool, label %if.then.47, label %if.end.50

if.then.47:                                       ; preds = %if.then.44
  %42 = load i8*, i8** %terminator, align 8
  %43 = load %struct.sockaddr_un*, %struct.sockaddr_un** %sockun, align 8
  %sun_path48 = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %43, i32 0, i32 1
  %arraydecay49 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path48, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %42 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay49 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %name_length, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.47, %if.then.44
  br label %if.end.51

if.end.51:                                        ; preds = %if.end.50, %land.lhs.true, %sw.bb.36
  %44 = load %struct.sockaddr_un*, %struct.sockaddr_un** %sockun, align 8
  %sun_path52 = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %44, i32 0, i32 1
  %arraydecay53 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path52, i32 0, i32 0
  %45 = load i64, i64* %name_length, align 8
  %call54 = call i64 @make_unibyte_string(i8* %arraydecay53, i64 %45)
  store i64 %call54, i64* %retval
  br label %return

sw.default:                                       ; preds = %if.end
  %46 = load i32, i32* %len.addr, align 4
  %conv55 = sext i32 %46 to i64
  %sub56 = sub i64 %conv55, 2
  %conv57 = trunc i64 %sub56 to i32
  store i32 %conv57, i32* %len.addr, align 4
  %47 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family58 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %47, i32 0, i32 0
  %48 = load i16, i16* %sa_family58, align 2
  %conv59 = zext i16 %48 to i64
  %shl60 = shl i64 %conv59, 2
  %add61 = add i64 %shl60, 2
  %49 = load i32, i32* %len.addr, align 4
  %conv62 = sext i32 %49 to i64
  %shl63 = shl i64 %conv62, 2
  %add64 = add i64 %shl63, 2
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  %call66 = call i64 @Fmake_vector(i64 %add64, i64 %call65)
  %call67 = call i64 @Fcons(i64 %add61, i64 %call66)
  store i64 %call67, i64* %address, align 8
  %50 = load i64, i64* %address, align 8
  %sub68 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub68 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %53 = load i64, i64* %cdr, align 8
  %call69 = call %struct.Lisp_Vector* @XVECTOR(i64 %53)
  store %struct.Lisp_Vector* %call69, %struct.Lisp_Vector** %p, align 8
  %54 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family70 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %54, i32 0, i32 0
  %55 = bitcast i16* %sa_family70 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %55, i64 2
  store i8* %add.ptr, i8** %cp, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb
  store i32 0, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.epilog
  %56 = load i32, i32* %i, align 4
  %57 = load i32, i32* %len.addr, align 4
  %cmp71 = icmp slt i32 %56, %57
  br i1 %cmp71, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %58 = load i8*, i8** %cp, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %58, i32 1
  store i8* %incdec.ptr, i8** %cp, align 8
  %59 = load i8, i8* %58, align 1
  %conv73 = zext i8 %59 to i64
  %shl74 = shl i64 %conv73, 2
  %add75 = add i64 %shl74, 2
  %60 = load i32, i32* %i, align 4
  %inc76 = add nsw i32 %60, 1
  store i32 %inc76, i32* %i, align 4
  %idxprom77 = sext i32 %60 to i64
  %61 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents78 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %61, i32 0, i32 1
  %arrayidx79 = getelementptr inbounds [0 x i64], [0 x i64]* %contents78, i32 0, i64 %idxprom77
  store i64 %add75, i64* %arrayidx79, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %62 = load i64, i64* %address, align 8
  store i64 %62, i64* %retval
  br label %return

return:                                           ; preds = %while.end, %if.end.51, %for.end, %if.then
  %63 = load i64, i64* %retval
  ret i64 %63
}

declare i64 @Fmake_vector(i64, i64) #1

; Function Attrs: nounwind readnone
declare zeroext i16 @ntohs(i16 zeroext) #4

; Function Attrs: nounwind readonly
declare i8* @memchr(i8*, i32, i64) #3

declare i64 @make_unibyte_string(i8*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_process_datagram_address(i64 %process, i64 %address) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %address.addr = alloca i64, align 8
  %channel = alloca i32, align 4
  %family = alloca i32, align 4
  %len = alloca i32, align 4
  store i64 %process, i64* %process.addr, align 8
  store i64 %address, i64* %address.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %1)
  br i1 %call, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %2)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 21
  %3 = load i32, i32* %infd, align 4
  %cmp = icmp sge i32 %3, 0
  br i1 %cmp, label %land.lhs.true.2, label %if.then

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %4 = load i64, i64* %process.addr, align 8
  %call3 = call %struct.Lisp_Process* @XPROCESS(i64 %4)
  %infd4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call3, i32 0, i32 21
  %5 = load i32, i32* %infd4, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx, i32 0, i32 0
  %6 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp5 = icmp ne %struct.sockaddr* %6, null
  br i1 %cmp5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.2, %land.lhs.true, %entry
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.2
  %7 = load i64, i64* %process.addr, align 8
  %call7 = call %struct.Lisp_Process* @XPROCESS(i64 %7)
  %infd8 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call7, i32 0, i32 21
  %8 = load i32, i32* %infd8, align 4
  store i32 %8, i32* %channel, align 4
  %9 = load i64, i64* %address.addr, align 8
  %call9 = call i32 @get_lisp_to_sockaddr_size(i64 %9, i32* %family)
  store i32 %call9, i32* %len, align 4
  %10 = load i32, i32* %len, align 4
  %cmp10 = icmp eq i32 %10, 0
  br i1 %cmp10, label %if.then.15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %11 = load i32, i32* %channel, align 4
  %idxprom11 = sext i32 %11 to i64
  %arrayidx12 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom11
  %len13 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx12, i32 0, i32 1
  %12 = load i32, i32* %len13, align 4
  %13 = load i32, i32* %len, align 4
  %cmp14 = icmp ne i32 %12, %13
  br i1 %cmp14, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %lor.lhs.false, %if.end
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* %retval
  br label %return

if.end.17:                                        ; preds = %lor.lhs.false
  %14 = load i32, i32* %family, align 4
  %15 = load i64, i64* %address.addr, align 8
  %16 = load i32, i32* %channel, align 4
  %idxprom18 = sext i32 %16 to i64
  %arrayidx19 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom18
  %sa20 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx19, i32 0, i32 0
  %17 = load %struct.sockaddr*, %struct.sockaddr** %sa20, align 8
  %18 = load i32, i32* %len, align 4
  call void @conv_lisp_to_sockaddr(i32 %14, i64 %15, %struct.sockaddr* %17, i32 %18)
  %19 = load i64, i64* %address.addr, align 8
  store i64 %19, i64* %retval
  br label %return

return:                                           ; preds = %if.end.17, %if.then.15, %if.then
  %20 = load i64, i64* %retval
  ret i64 %20
}

; Function Attrs: nounwind uwtable
define internal i32 @get_lisp_to_sockaddr_size(i64 %address, i32* %familyp) #0 {
entry:
  %retval = alloca i32, align 4
  %address.addr = alloca i64, align 8
  %familyp.addr = alloca i32*, align 8
  %p = alloca %struct.Lisp_Vector*, align 8
  %sa = alloca %struct.sockaddr*, align 8
  store i64 %address, i64* %address.addr, align 8
  store i32* %familyp, i32** %familyp.addr, align 8
  %0 = load i64, i64* %address.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %if.then, label %if.else.8

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %address.addr, align 8
  %call1 = call %struct.Lisp_Vector* @XVECTOR(i64 %1)
  store %struct.Lisp_Vector* %call1, %struct.Lisp_Vector** %p, align 8
  %2 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %header = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %2, i32 0, i32 0
  %size = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header, i32 0, i32 0
  %3 = load i64, i64* %size, align 8
  %cmp = icmp eq i64 %3, 5
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  %4 = load i32*, i32** %familyp.addr, align 8
  store i32 2, i32* %4, align 4
  store i32 16, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then
  %5 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %header3 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %5, i32 0, i32 0
  %size4 = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header3, i32 0, i32 0
  %6 = load i64, i64* %size4, align 8
  %cmp5 = icmp eq i64 %6, 9
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %if.else
  %7 = load i32*, i32** %familyp.addr, align 8
  store i32 10, i32* %7, align 4
  store i32 28, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end.7

if.end.7:                                         ; preds = %if.end
  br label %if.end.59

if.else.8:                                        ; preds = %entry
  %8 = load i64, i64* %address.addr, align 8
  %call9 = call zeroext i1 @STRINGP(i64 %8)
  br i1 %call9, label %if.then.10, label %if.else.11

if.then.10:                                       ; preds = %if.else.8
  %9 = load i32*, i32** %familyp.addr, align 8
  store i32 1, i32* %9, align 4
  store i32 110, i32* %retval
  br label %return

if.else.11:                                       ; preds = %if.else.8
  %10 = load i64, i64* %address.addr, align 8
  %and = and i64 %10, 7
  %conv = trunc i64 %and to i32
  %cmp12 = icmp eq i32 %conv, 3
  br i1 %cmp12, label %land.lhs.true, label %if.end.57

land.lhs.true:                                    ; preds = %if.else.11
  %11 = load i64, i64* %address.addr, align 8
  %sub = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car, align 8
  %and14 = and i64 %14, 7
  %conv15 = trunc i64 %and14 to i32
  %and16 = and i32 %conv15, -5
  %cmp17 = icmp eq i32 %and16, 2
  br i1 %cmp17, label %land.lhs.true.19, label %if.end.57

land.lhs.true.19:                                 ; preds = %land.lhs.true
  br i1 false, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true.19
  %15 = load i64, i64* %address.addr, align 8
  %sub20 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub20 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car21, align 8
  %shr = ashr i64 %18, 2
  %cmp22 = icmp sle i64 -2147483648, %shr
  br i1 %cmp22, label %land.lhs.true.29, label %if.end.57

cond.false:                                       ; preds = %land.lhs.true.19
  %19 = load i64, i64* %address.addr, align 8
  %sub24 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub24 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %car25 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 0
  %22 = load i64, i64* %car25, align 8
  %shr26 = ashr i64 %22, 2
  %cmp27 = icmp sle i64 0, %shr26
  br i1 %cmp27, label %land.lhs.true.29, label %if.end.57

land.lhs.true.29:                                 ; preds = %cond.false, %cond.true
  %23 = load i64, i64* %address.addr, align 8
  %sub30 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub30 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %car31 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 0
  %26 = load i64, i64* %car31, align 8
  %shr32 = ashr i64 %26, 2
  %cmp33 = icmp sle i64 %shr32, 2147483647
  br i1 %cmp33, label %land.lhs.true.35, label %if.end.57

land.lhs.true.35:                                 ; preds = %land.lhs.true.29
  %27 = load i64, i64* %address.addr, align 8
  %sub36 = sub nsw i64 %27, 3
  %28 = inttoptr i64 %sub36 to i8*
  %29 = bitcast i8* %28 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %29, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %30 = load i64, i64* %cdr, align 8
  %call37 = call zeroext i1 @VECTORP(i64 %30)
  br i1 %call37, label %if.then.39, label %if.end.57

if.then.39:                                       ; preds = %land.lhs.true.35
  %31 = load i64, i64* %address.addr, align 8
  %sub40 = sub nsw i64 %31, 3
  %32 = inttoptr i64 %sub40 to i8*
  %33 = bitcast i8* %32 to %struct.Lisp_Cons*
  %u41 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %33, i32 0, i32 1
  %cdr42 = bitcast %union.anon* %u41 to i64*
  %34 = load i64, i64* %cdr42, align 8
  %call43 = call %struct.Lisp_Vector* @XVECTOR(i64 %34)
  store %struct.Lisp_Vector* %call43, %struct.Lisp_Vector** %p, align 8
  %35 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %header44 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %35, i32 0, i32 0
  %size45 = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header44, i32 0, i32 0
  %36 = load i64, i64* %size45, align 8
  %cmp46 = icmp ult i64 16382, %36
  br i1 %cmp46, label %if.then.48, label %if.end.49

if.then.48:                                       ; preds = %if.then.39
  store i32 0, i32* %retval
  br label %return

if.end.49:                                        ; preds = %if.then.39
  %37 = load i64, i64* %address.addr, align 8
  %sub50 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub50 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car51, align 8
  %shr52 = ashr i64 %40, 2
  %conv53 = trunc i64 %shr52 to i32
  %41 = load i32*, i32** %familyp.addr, align 8
  store i32 %conv53, i32* %41, align 4
  %42 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %header54 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %42, i32 0, i32 0
  %size55 = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header54, i32 0, i32 0
  %43 = load i64, i64* %size55, align 8
  %add = add i64 %43, 2
  %conv56 = trunc i64 %add to i32
  store i32 %conv56, i32* %retval
  br label %return

if.end.57:                                        ; preds = %land.lhs.true.35, %land.lhs.true.29, %cond.false, %cond.true, %land.lhs.true, %if.else.11
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57
  br label %if.end.59

if.end.59:                                        ; preds = %if.end.58, %if.end.7
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.59, %if.end.49, %if.then.48, %if.then.10, %if.then.6, %if.then.2
  %44 = load i32, i32* %retval
  ret i32 %44
}

; Function Attrs: nounwind uwtable
define internal void @conv_lisp_to_sockaddr(i32 %family, i64 %address, %struct.sockaddr* %sa, i32 %len) #0 {
entry:
  %family.addr = alloca i32, align 4
  %address.addr = alloca i64, align 8
  %sa.addr = alloca %struct.sockaddr*, align 8
  %len.addr = alloca i32, align 4
  %p = alloca %struct.Lisp_Vector*, align 8
  %cp = alloca i8*, align 8
  %i = alloca i32, align 4
  %hostport = alloca i64, align 8
  %sin = alloca %struct.sockaddr_in*, align 8
  %sin6 = alloca %struct.sockaddr_in6*, align 8
  %ip6 = alloca i16*, align 8
  %j = alloca i32, align 4
  %sockun = alloca %struct.sockaddr_un*, align 8
  store i32 %family, i32* %family.addr, align 4
  store i64 %address, i64* %address.addr, align 8
  store %struct.sockaddr* %sa, %struct.sockaddr** %sa.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store i8* null, i8** %cp, align 8
  %0 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %1 = bitcast %struct.sockaddr* %0 to i8*
  %2 = load i32, i32* %len.addr, align 4
  %conv = sext i32 %2 to i64
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 %conv, i32 2, i1 false)
  %3 = load i64, i64* %address.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %3)
  br i1 %call, label %if.then, label %if.else.41

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %address.addr, align 8
  %call1 = call %struct.Lisp_Vector* @XVECTOR(i64 %4)
  store %struct.Lisp_Vector* %call1, %struct.Lisp_Vector** %p, align 8
  %5 = load i32, i32* %family.addr, align 4
  %cmp = icmp eq i32 %5, 2
  br i1 %cmp, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.then
  %6 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %7 = bitcast %struct.sockaddr* %6 to %struct.sockaddr_in*
  store %struct.sockaddr_in* %7, %struct.sockaddr_in** %sin, align 8
  store i32 5, i32* %len.addr, align 4
  %8 = load i32, i32* %len.addr, align 4
  %dec = add nsw i32 %8, -1
  store i32 %dec, i32* %len.addr, align 4
  %idxprom = sext i32 %dec to i64
  %9 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %9, i32 0, i32 1
  %arrayidx = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i64 %idxprom
  %10 = load i64, i64* %arrayidx, align 8
  %shr = ashr i64 %10, 2
  store i64 %shr, i64* %hostport, align 8
  %11 = load i64, i64* %hostport, align 8
  %conv4 = trunc i64 %11 to i16
  %call5 = call zeroext i16 @htons(i16 zeroext %conv4) #11
  %12 = load %struct.sockaddr_in*, %struct.sockaddr_in** %sin, align 8
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %12, i32 0, i32 1
  store i16 %call5, i16* %sin_port, align 2
  %13 = load %struct.sockaddr_in*, %struct.sockaddr_in** %sin, align 8
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %13, i32 0, i32 2
  %14 = bitcast %struct.in_addr* %sin_addr to i8*
  store i8* %14, i8** %cp, align 8
  %15 = load i32, i32* %family.addr, align 4
  %conv6 = trunc i32 %15 to i16
  %16 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %16, i32 0, i32 0
  store i16 %conv6, i16* %sa_family, align 2
  br label %if.end.40

if.else:                                          ; preds = %if.then
  %17 = load i32, i32* %family.addr, align 4
  %cmp7 = icmp eq i32 %17, 10
  br i1 %cmp7, label %if.then.9, label %if.else.39

if.then.9:                                        ; preds = %if.else
  %18 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %19 = bitcast %struct.sockaddr* %18 to %struct.sockaddr_in6*
  store %struct.sockaddr_in6* %19, %struct.sockaddr_in6** %sin6, align 8
  %20 = load %struct.sockaddr_in6*, %struct.sockaddr_in6** %sin6, align 8
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %20, i32 0, i32 3
  %21 = bitcast %struct.in6_addr* %sin6_addr to i16*
  store i16* %21, i16** %ip6, align 8
  store i32 9, i32* %len.addr, align 4
  %22 = load i32, i32* %len.addr, align 4
  %dec10 = add nsw i32 %22, -1
  store i32 %dec10, i32* %len.addr, align 4
  %idxprom11 = sext i32 %dec10 to i64
  %23 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents12 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %23, i32 0, i32 1
  %arrayidx13 = getelementptr inbounds [0 x i64], [0 x i64]* %contents12, i32 0, i64 %idxprom11
  %24 = load i64, i64* %arrayidx13, align 8
  %shr14 = ashr i64 %24, 2
  store i64 %shr14, i64* %hostport, align 8
  %25 = load i64, i64* %hostport, align 8
  %conv15 = trunc i64 %25 to i16
  %call16 = call zeroext i16 @htons(i16 zeroext %conv15) #11
  %26 = load %struct.sockaddr_in6*, %struct.sockaddr_in6** %sin6, align 8
  %sin6_port = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %26, i32 0, i32 1
  store i16 %call16, i16* %sin6_port, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.9
  %27 = load i32, i32* %i, align 4
  %28 = load i32, i32* %len.addr, align 4
  %cmp17 = icmp slt i32 %27, %28
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %29 to i64
  %30 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents20 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %30, i32 0, i32 1
  %arrayidx21 = getelementptr inbounds [0 x i64], [0 x i64]* %contents20, i32 0, i64 %idxprom19
  %31 = load i64, i64* %arrayidx21, align 8
  %and = and i64 %31, 7
  %conv22 = trunc i64 %and to i32
  %and23 = and i32 %conv22, -5
  %cmp24 = icmp eq i32 %and23, 2
  br i1 %cmp24, label %if.then.26, label %if.end

if.then.26:                                       ; preds = %for.body
  %32 = load i32, i32* %i, align 4
  %idxprom27 = sext i32 %32 to i64
  %33 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents28 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %33, i32 0, i32 1
  %arrayidx29 = getelementptr inbounds [0 x i64], [0 x i64]* %contents28, i32 0, i64 %idxprom27
  %34 = load i64, i64* %arrayidx29, align 8
  %shr30 = ashr i64 %34, 2
  %and31 = and i64 %shr30, 65535
  %conv32 = trunc i64 %and31 to i32
  store i32 %conv32, i32* %j, align 4
  %35 = load i32, i32* %j, align 4
  %conv33 = trunc i32 %35 to i16
  %call34 = call zeroext i16 @ntohs(i16 zeroext %conv33) #11
  %36 = load i32, i32* %i, align 4
  %idxprom35 = sext i32 %36 to i64
  %37 = load i16*, i16** %ip6, align 8
  %arrayidx36 = getelementptr inbounds i16, i16* %37, i64 %idxprom35
  store i16 %call34, i16* %arrayidx36, align 2
  br label %if.end

if.end:                                           ; preds = %if.then.26, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %38 = load i32, i32* %i, align 4
  %inc = add nsw i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %39 = load i32, i32* %family.addr, align 4
  %conv37 = trunc i32 %39 to i16
  %40 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family38 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %40, i32 0, i32 0
  store i16 %conv37, i16* %sa_family38, align 2
  br label %for.end.89

if.else.39:                                       ; preds = %if.else
  br label %for.end.89

if.end.40:                                        ; preds = %if.then.3
  br label %if.end.65

if.else.41:                                       ; preds = %entry
  %41 = load i64, i64* %address.addr, align 8
  %call42 = call zeroext i1 @STRINGP(i64 %41)
  br i1 %call42, label %if.then.43, label %if.else.62

if.then.43:                                       ; preds = %if.else.41
  %42 = load i32, i32* %family.addr, align 4
  %cmp44 = icmp eq i32 %42, 1
  br i1 %cmp44, label %if.then.46, label %if.end.61

if.then.46:                                       ; preds = %if.then.43
  %43 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %44 = bitcast %struct.sockaddr* %43 to %struct.sockaddr_un*
  store %struct.sockaddr_un* %44, %struct.sockaddr_un** %sockun, align 8
  %45 = load i64, i64* %address.addr, align 8
  %call47 = call i8* @SDATA(i64 %45)
  store i8* %call47, i8** %cp, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.48

for.cond.48:                                      ; preds = %for.inc.56, %if.then.46
  %46 = load i32, i32* %i, align 4
  %conv49 = sext i32 %46 to i64
  %cmp50 = icmp ult i64 %conv49, 108
  br i1 %cmp50, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond.48
  %47 = load i8*, i8** %cp, align 8
  %48 = load i8, i8* %47, align 1
  %conv52 = zext i8 %48 to i32
  %tobool = icmp ne i32 %conv52, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.48
  %49 = phi i1 [ false, %for.cond.48 ], [ %tobool, %land.rhs ]
  br i1 %49, label %for.body.53, label %for.end.58

for.body.53:                                      ; preds = %land.end
  %50 = load i8*, i8** %cp, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %50, i32 1
  store i8* %incdec.ptr, i8** %cp, align 8
  %51 = load i8, i8* %50, align 1
  %52 = load i32, i32* %i, align 4
  %idxprom54 = sext i32 %52 to i64
  %53 = load %struct.sockaddr_un*, %struct.sockaddr_un** %sockun, align 8
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %53, i32 0, i32 1
  %arrayidx55 = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i64 %idxprom54
  store i8 %51, i8* %arrayidx55, align 1
  br label %for.inc.56

for.inc.56:                                       ; preds = %for.body.53
  %54 = load i32, i32* %i, align 4
  %inc57 = add nsw i32 %54, 1
  store i32 %inc57, i32* %i, align 4
  br label %for.cond.48

for.end.58:                                       ; preds = %land.end
  %55 = load i32, i32* %family.addr, align 4
  %conv59 = trunc i32 %55 to i16
  %56 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %sa_family60 = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %56, i32 0, i32 0
  store i16 %conv59, i16* %sa_family60, align 2
  br label %if.end.61

if.end.61:                                        ; preds = %for.end.58, %if.then.43
  br label %for.end.89

if.else.62:                                       ; preds = %if.else.41
  %57 = load i64, i64* %address.addr, align 8
  %sub = sub nsw i64 %57, 3
  %58 = inttoptr i64 %sub to i8*
  %59 = bitcast i8* %58 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %59, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %60 = load i64, i64* %cdr, align 8
  %call63 = call %struct.Lisp_Vector* @XVECTOR(i64 %60)
  store %struct.Lisp_Vector* %call63, %struct.Lisp_Vector** %p, align 8
  %61 = load %struct.sockaddr*, %struct.sockaddr** %sa.addr, align 8
  %62 = bitcast %struct.sockaddr* %61 to i8*
  %add.ptr = getelementptr inbounds i8, i8* %62, i64 2
  store i8* %add.ptr, i8** %cp, align 8
  br label %if.end.64

if.end.64:                                        ; preds = %if.else.62
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %if.end.40
  store i32 0, i32* %i, align 4
  br label %for.cond.66

for.cond.66:                                      ; preds = %for.inc.87, %if.end.65
  %63 = load i32, i32* %i, align 4
  %64 = load i32, i32* %len.addr, align 4
  %cmp67 = icmp slt i32 %63, %64
  br i1 %cmp67, label %for.body.69, label %for.end.89

for.body.69:                                      ; preds = %for.cond.66
  %65 = load i32, i32* %i, align 4
  %idxprom70 = sext i32 %65 to i64
  %66 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents71 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %66, i32 0, i32 1
  %arrayidx72 = getelementptr inbounds [0 x i64], [0 x i64]* %contents71, i32 0, i64 %idxprom70
  %67 = load i64, i64* %arrayidx72, align 8
  %and73 = and i64 %67, 7
  %conv74 = trunc i64 %and73 to i32
  %and75 = and i32 %conv74, -5
  %cmp76 = icmp eq i32 %and75, 2
  br i1 %cmp76, label %if.then.78, label %if.end.86

if.then.78:                                       ; preds = %for.body.69
  %68 = load i32, i32* %i, align 4
  %idxprom79 = sext i32 %68 to i64
  %69 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents80 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %69, i32 0, i32 1
  %arrayidx81 = getelementptr inbounds [0 x i64], [0 x i64]* %contents80, i32 0, i64 %idxprom79
  %70 = load i64, i64* %arrayidx81, align 8
  %shr82 = ashr i64 %70, 2
  %and83 = and i64 %shr82, 255
  %conv84 = trunc i64 %and83 to i8
  %71 = load i8*, i8** %cp, align 8
  %incdec.ptr85 = getelementptr inbounds i8, i8* %71, i32 1
  store i8* %incdec.ptr85, i8** %cp, align 8
  store i8 %conv84, i8* %71, align 1
  br label %if.end.86

if.end.86:                                        ; preds = %if.then.78, %for.body.69
  br label %for.inc.87

for.inc.87:                                       ; preds = %if.end.86
  %72 = load i32, i32* %i, align 4
  %inc88 = add nsw i32 %72, 1
  store i32 %inc88, i32* %i, align 4
  br label %for.cond.66

for.end.89:                                       ; preds = %for.end, %if.else.39, %if.end.61, %for.cond.66
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fset_network_process_option(i64 %process, i64 %option, i64 %value, i64 %no_error) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %option.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %no_error.addr = alloca i64, align 8
  %s = alloca i32, align 4
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %option, i64* %option.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  store i64 %no_error, i64* %no_error.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 10
  %3 = load i64, i64* %type, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp = icmp eq i64 %3, %call1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.11, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 21
  %5 = load i32, i32* %infd, align 4
  store i32 %5, i32* %s, align 4
  %6 = load i32, i32* %s, align 4
  %cmp2 = icmp slt i32 %6, 0
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.12, i32 0, i32 0)) #8
  unreachable

if.end.4:                                         ; preds = %if.end
  %7 = load i32, i32* %s, align 4
  %8 = load i64, i64* %option.addr, align 8
  %9 = load i64, i64* %value.addr, align 8
  %call5 = call i32 @set_socket_option(i32 %7, i64 %8, i64 %9)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end.4
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 8
  %12 = load i64, i64* %childp, align 8
  %13 = load i64, i64* %option.addr, align 8
  %14 = load i64, i64* %value.addr, align 8
  %call7 = call i64 @Fplist_put(i64 %12, i64 %13, i64 %14)
  call void @pset_childp(%struct.Lisp_Process* %10, i64 %call7)
  %call8 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call8, i64* %retval
  br label %return

if.end.9:                                         ; preds = %if.end.4
  %15 = load i64, i64* %no_error.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %15, %call10
  br i1 %cmp11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end.9
  call void (i8*, ...) @error(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.13, i32 0, i32 0)) #8
  unreachable

if.end.13:                                        ; preds = %if.end.9
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call14, i64* %retval
  br label %return

return:                                           ; preds = %if.end.13, %if.then.6
  %16 = load i64, i64* %retval
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @set_socket_option(i32 %s, i64 %opt, i64 %val) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i32, align 4
  %opt.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  %name = alloca i8*, align 8
  %sopt = alloca %struct.socket_options*, align 8
  %ret = alloca i32, align 4
  %optval = alloca i32, align 4
  %optval14 = alloca i32, align 4
  %devname = alloca [17 x i8], align 16
  %arg = alloca i8*, align 8
  %len = alloca i32, align 4
  %linger = alloca %struct.linger, align 4
  %setsockopt_errno = alloca i32, align 4
  store i32 %s, i32* %s.addr, align 4
  store i64 %opt, i64* %opt.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  store i32 0, i32* %ret, align 4
  %0 = load i64, i64* %opt.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %opt.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %opt.addr, align 8
  %call2 = call i64 @SYMBOL_NAME(i64 %4)
  %call3 = call i8* @SSDATA(i64 %call2)
  store i8* %call3, i8** %name, align 8
  store %struct.socket_options* getelementptr inbounds ([9 x %struct.socket_options], [9 x %struct.socket_options]* @socket_options, i32 0, i32 0), %struct.socket_options** %sopt, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %name4 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %5, i32 0, i32 0
  %6 = load i8*, i8** %name4, align 8
  %tobool = icmp ne i8* %6, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i8*, i8** %name, align 8
  %8 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %name5 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %8, i32 0, i32 0
  %9 = load i8*, i8** %name5, align 8
  %call6 = call i32 @strcmp(i8* %7, i8* %9) #9
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %incdec.ptr = getelementptr inbounds %struct.socket_options, %struct.socket_options* %10, i32 1
  store %struct.socket_options* %incdec.ptr, %struct.socket_options** %sopt, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %11 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %opttype = getelementptr inbounds %struct.socket_options, %struct.socket_options* %11, i32 0, i32 3
  %12 = load i32, i32* %opttype, align 4
  switch i32 %12, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb.13
    i32 3, label %sw.bb.38
    i32 4, label %sw.bb.62
  ]

sw.bb:                                            ; preds = %for.end
  %13 = load i64, i64* %val.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %13, %call9
  %cond = select i1 %cmp10, i32 0, i32 1
  store i32 %cond, i32* %optval, align 4
  %14 = load i32, i32* %s.addr, align 4
  %15 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optlevel = getelementptr inbounds %struct.socket_options, %struct.socket_options* %15, i32 0, i32 1
  %16 = load i32, i32* %optlevel, align 4
  %17 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optnum = getelementptr inbounds %struct.socket_options, %struct.socket_options* %17, i32 0, i32 2
  %18 = load i32, i32* %optnum, align 4
  %19 = bitcast i32* %optval to i8*
  %call12 = call i32 @setsockopt(i32 %14, i32 %16, i32 %18, i8* %19, i32 4) #5
  store i32 %call12, i32* %ret, align 4
  br label %sw.epilog

sw.bb.13:                                         ; preds = %for.end
  %20 = load i64, i64* %val.addr, align 8
  %and15 = and i64 %20, 7
  %conv16 = trunc i64 %and15 to i32
  %and17 = and i32 %conv16, -5
  %cmp18 = icmp eq i32 %and17, 2
  br i1 %cmp18, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb.13
  br i1 false, label %cond.false.23, label %cond.true.20

cond.true.20:                                     ; preds = %land.lhs.true
  %21 = load i64, i64* %val.addr, align 8
  %shr = ashr i64 %21, 2
  %cmp21 = icmp sle i64 -2147483648, %shr
  br i1 %cmp21, label %land.lhs.true.27, label %if.else

cond.false.23:                                    ; preds = %land.lhs.true
  %22 = load i64, i64* %val.addr, align 8
  %shr24 = ashr i64 %22, 2
  %cmp25 = icmp sle i64 0, %shr24
  br i1 %cmp25, label %land.lhs.true.27, label %if.else

land.lhs.true.27:                                 ; preds = %cond.false.23, %cond.true.20
  %23 = load i64, i64* %val.addr, align 8
  %shr28 = ashr i64 %23, 2
  %cmp29 = icmp sle i64 %shr28, 2147483647
  br i1 %cmp29, label %if.then.31, label %if.else

if.then.31:                                       ; preds = %land.lhs.true.27
  %24 = load i64, i64* %val.addr, align 8
  %shr32 = ashr i64 %24, 2
  %conv33 = trunc i64 %shr32 to i32
  store i32 %conv33, i32* %optval14, align 4
  br label %if.end.34

if.else:                                          ; preds = %land.lhs.true.27, %cond.false.23, %cond.true.20, %sw.bb.13
  %25 = load i8*, i8** %name, align 8
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.65, i32 0, i32 0), i8* %25) #8
  unreachable

if.end.34:                                        ; preds = %if.then.31
  %26 = load i32, i32* %s.addr, align 4
  %27 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optlevel35 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %27, i32 0, i32 1
  %28 = load i32, i32* %optlevel35, align 4
  %29 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optnum36 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %29, i32 0, i32 2
  %30 = load i32, i32* %optnum36, align 4
  %31 = bitcast i32* %optval14 to i8*
  %call37 = call i32 @setsockopt(i32 %26, i32 %28, i32 %30, i8* %31, i32 4) #5
  store i32 %call37, i32* %ret, align 4
  br label %sw.epilog

sw.bb.38:                                         ; preds = %for.end
  %32 = bitcast [17 x i8]* %devname to i8*
  call void @llvm.memset.p0i8.i64(i8* %32, i8 0, i64 17, i32 16, i1 false)
  %33 = load i64, i64* %val.addr, align 8
  %call39 = call zeroext i1 @STRINGP(i64 %33)
  br i1 %call39, label %if.then.40, label %if.else.52

if.then.40:                                       ; preds = %sw.bb.38
  %34 = load i64, i64* %val.addr, align 8
  %call41 = call i8* @SSDATA(i64 %34)
  store i8* %call41, i8** %arg, align 8
  %35 = load i8*, i8** %arg, align 8
  %call42 = call i64 @strlen(i8* %35) #9
  %cmp43 = icmp ult i64 %call42, 16
  br i1 %cmp43, label %cond.true.45, label %cond.false.47

cond.true.45:                                     ; preds = %if.then.40
  %36 = load i8*, i8** %arg, align 8
  %call46 = call i64 @strlen(i8* %36) #9
  br label %cond.end.48

cond.false.47:                                    ; preds = %if.then.40
  br label %cond.end.48

cond.end.48:                                      ; preds = %cond.false.47, %cond.true.45
  %cond49 = phi i64 [ %call46, %cond.true.45 ], [ 16, %cond.false.47 ]
  %conv50 = trunc i64 %cond49 to i32
  store i32 %conv50, i32* %len, align 4
  %37 = bitcast [17 x i8]* %devname to i8*
  %38 = load i8*, i8** %arg, align 8
  %39 = load i32, i32* %len, align 4
  %conv51 = sext i32 %39 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %37, i8* %38, i64 %conv51, i32 1, i1 false)
  br label %if.end.58

if.else.52:                                       ; preds = %sw.bb.38
  %40 = load i64, i64* %val.addr, align 8
  %call53 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp54 = icmp eq i64 %40, %call53
  br i1 %cmp54, label %if.end.57, label %if.then.56

if.then.56:                                       ; preds = %if.else.52
  %41 = load i8*, i8** %name, align 8
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.65, i32 0, i32 0), i8* %41) #8
  unreachable

if.end.57:                                        ; preds = %if.else.52
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57, %cond.end.48
  %42 = load i32, i32* %s.addr, align 4
  %43 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optlevel59 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %43, i32 0, i32 1
  %44 = load i32, i32* %optlevel59, align 4
  %45 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optnum60 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %45, i32 0, i32 2
  %46 = load i32, i32* %optnum60, align 4
  %arraydecay = getelementptr inbounds [17 x i8], [17 x i8]* %devname, i32 0, i32 0
  %call61 = call i32 @setsockopt(i32 %42, i32 %44, i32 %46, i8* %arraydecay, i32 16) #5
  store i32 %call61, i32* %ret, align 4
  br label %sw.epilog

sw.bb.62:                                         ; preds = %for.end
  %l_onoff = getelementptr inbounds %struct.linger, %struct.linger* %linger, i32 0, i32 0
  store i32 1, i32* %l_onoff, align 4
  %l_linger = getelementptr inbounds %struct.linger, %struct.linger* %linger, i32 0, i32 1
  store i32 0, i32* %l_linger, align 4
  %47 = load i64, i64* %val.addr, align 8
  %and63 = and i64 %47, 7
  %conv64 = trunc i64 %and63 to i32
  %and65 = and i32 %conv64, -5
  %cmp66 = icmp eq i32 %and65, 2
  br i1 %cmp66, label %land.lhs.true.68, label %if.else.85

land.lhs.true.68:                                 ; preds = %sw.bb.62
  br i1 false, label %cond.false.73, label %cond.true.69

cond.true.69:                                     ; preds = %land.lhs.true.68
  %48 = load i64, i64* %val.addr, align 8
  %shr70 = ashr i64 %48, 2
  %cmp71 = icmp sle i64 -2147483648, %shr70
  br i1 %cmp71, label %land.lhs.true.77, label %if.else.85

cond.false.73:                                    ; preds = %land.lhs.true.68
  %49 = load i64, i64* %val.addr, align 8
  %shr74 = ashr i64 %49, 2
  %cmp75 = icmp sle i64 0, %shr74
  br i1 %cmp75, label %land.lhs.true.77, label %if.else.85

land.lhs.true.77:                                 ; preds = %cond.false.73, %cond.true.69
  %50 = load i64, i64* %val.addr, align 8
  %shr78 = ashr i64 %50, 2
  %cmp79 = icmp sle i64 %shr78, 2147483647
  br i1 %cmp79, label %if.then.81, label %if.else.85

if.then.81:                                       ; preds = %land.lhs.true.77
  %51 = load i64, i64* %val.addr, align 8
  %shr82 = ashr i64 %51, 2
  %conv83 = trunc i64 %shr82 to i32
  %l_linger84 = getelementptr inbounds %struct.linger, %struct.linger* %linger, i32 0, i32 1
  store i32 %conv83, i32* %l_linger84, align 4
  br label %if.end.91

if.else.85:                                       ; preds = %land.lhs.true.77, %cond.false.73, %cond.true.69, %sw.bb.62
  %52 = load i64, i64* %val.addr, align 8
  %call86 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp87 = icmp eq i64 %52, %call86
  %cond89 = select i1 %cmp87, i32 0, i32 1
  %l_onoff90 = getelementptr inbounds %struct.linger, %struct.linger* %linger, i32 0, i32 0
  store i32 %cond89, i32* %l_onoff90, align 4
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.85, %if.then.81
  %53 = load i32, i32* %s.addr, align 4
  %54 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optlevel92 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %54, i32 0, i32 1
  %55 = load i32, i32* %optlevel92, align 4
  %56 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optnum93 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %56, i32 0, i32 2
  %57 = load i32, i32* %optnum93, align 4
  %58 = bitcast %struct.linger* %linger to i8*
  %call94 = call i32 @setsockopt(i32 %53, i32 %55, i32 %57, i8* %58, i32 8) #5
  store i32 %call94, i32* %ret, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %for.end
  store i32 0, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %if.end.91, %if.end.58, %if.end.34, %sw.bb
  %59 = load i32, i32* %ret, align 4
  %cmp95 = icmp slt i32 %59, 0
  br i1 %cmp95, label %if.then.97, label %if.end.100

if.then.97:                                       ; preds = %sw.epilog
  %call98 = call i32* @__errno_location() #11
  %60 = load i32, i32* %call98, align 4
  store i32 %60, i32* %setsockopt_errno, align 4
  %61 = load i64, i64* %opt.addr, align 8
  %62 = load i64, i64* %val.addr, align 8
  %call99 = call i64 @list2(i64 %61, i64 %62)
  %63 = load i32, i32* %setsockopt_errno, align 4
  call void @report_file_errno(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.66, i32 0, i32 0), i64 %call99, i32 %63) #8
  unreachable

if.end.100:                                       ; preds = %sw.epilog
  %64 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %optbit = getelementptr inbounds %struct.socket_options, %struct.socket_options* %64, i32 0, i32 4
  %65 = load i32, i32* %optbit, align 4
  %shl = shl i32 1, %65
  store i32 %shl, i32* %retval
  br label %return

return:                                           ; preds = %if.end.100, %sw.default
  %66 = load i32, i32* %retval
  ret i32 %66
}

; Function Attrs: nounwind uwtable
define i64 @Fserial_process_configure(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %contact = alloca i64, align 8
  %proc = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %contact, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %proc, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call2 = call i64 @Flist(i64 %0, i64* %1)
  store i64 %call2, i64* %contact, align 8
  %2 = load i64, i64* %contact, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 97)
  %call4 = call i64 @Fplist_get(i64 %2, i64 %call3)
  store i64 %call4, i64* %proc, align 8
  %3 = load i64, i64* %proc, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %contact, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 86)
  %call7 = call i64 @Fplist_get(i64 %4, i64 %call6)
  store i64 %call7, i64* %proc, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, i64* %proc, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %5, %call8
  br i1 %cmp9, label %if.then.10, label %if.end.13

if.then.10:                                       ; preds = %if.end
  %6 = load i64, i64* %contact, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 16)
  %call12 = call i64 @Fplist_get(i64 %6, i64 %call11)
  store i64 %call12, i64* %proc, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.10, %if.end
  %7 = load i64, i64* %proc, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %7, %call14
  br i1 %cmp15, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %if.end.13
  %8 = load i64, i64* %contact, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 94)
  %call18 = call i64 @Fplist_get(i64 %8, i64 %call17)
  store i64 %call18, i64* %proc, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %if.end.13
  %9 = load i64, i64* %proc, align 8
  %call20 = call i64 @get_process(i64 %9)
  store i64 %call20, i64* %proc, align 8
  %10 = load i64, i64* %proc, align 8
  %call21 = call %struct.Lisp_Process* @XPROCESS(i64 %10)
  store %struct.Lisp_Process* %call21, %struct.Lisp_Process** %p, align 8
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 10
  %12 = load i64, i64* %type, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp23 = icmp eq i64 %12, %call22
  br i1 %cmp23, label %if.end.25, label %if.then.24

if.then.24:                                       ; preds = %if.end.19
  call void (i8*, ...) @error(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.14, i32 0, i32 0)) #8
  unreachable

if.end.25:                                        ; preds = %if.end.19
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %13, i32 0, i32 8
  %14 = load i64, i64* %childp, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 121)
  %call27 = call i64 @Fplist_get(i64 %14, i64 %call26)
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp29 = icmp eq i64 %call27, %call28
  br i1 %cmp29, label %if.then.30, label %if.end.32

if.then.30:                                       ; preds = %if.end.25
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call31, i64* %retval
  br label %return

if.end.32:                                        ; preds = %if.end.25
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %16 = load i64, i64* %contact, align 8
  call void @serial_configure(%struct.Lisp_Process* %15, i64 %16)
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call33, i64* %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then.30
  %17 = load i64, i64* %retval
  ret i64 %17
}

declare void @serial_configure(%struct.Lisp_Process*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fmake_serial_process(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %fd = alloca i32, align 4
  %proc = alloca i64, align 8
  %contact = alloca i64, align 8
  %port = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %name = alloca i64, align 8
  %buffer = alloca i64, align 8
  %tem = alloca i64, align 8
  %val = alloca i64, align 8
  %specpdl_count = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i32 -1, i32* %fd, align 4
  %0 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %call1 = call i64 @Flist(i64 %1, i64* %2)
  store i64 %call1, i64* %contact, align 8
  %3 = load i64, i64* %contact, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 94)
  %call3 = call i64 @Fplist_get(i64 %3, i64 %call2)
  store i64 %call3, i64* %port, align 8
  %4 = load i64, i64* %port, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %4, %call4
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.15, i32 0, i32 0)) #8
  unreachable

if.end.7:                                         ; preds = %if.end
  %5 = load i64, i64* %port, align 8
  call void @CHECK_STRING(i64 %5)
  %6 = load i64, i64* %contact, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 121)
  %call9 = call i64 @Fplist_member(i64 %6, i64 %call8)
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %call9, %call10
  br i1 %cmp11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end.7
  call void (i8*, ...) @error(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.16, i32 0, i32 0)) #8
  unreachable

if.end.13:                                        ; preds = %if.end.7
  %7 = load i64, i64* %contact, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 121)
  %call15 = call i64 @Fplist_get(i64 %7, i64 %call14)
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %call15, %call16
  br i1 %cmp17, label %if.end.27, label %if.then.18

if.then.18:                                       ; preds = %if.end.13
  %8 = load i64, i64* %contact, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 121)
  %call20 = call i64 @Fplist_get(i64 %8, i64 %call19)
  %and = and i64 %call20, 7
  %conv = trunc i64 %and to i32
  %and21 = and i32 %conv, -5
  %cmp22 = icmp eq i32 %and21, 2
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.18
  br label %cond.end

cond.false:                                       ; preds = %if.then.18
  %call24 = call i64 @builtin_lisp_symbol(i32 559)
  %9 = load i64, i64* %contact, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 121)
  %call26 = call i64 @Fplist_get(i64 %9, i64 %call25)
  %10 = call i64 @wrong_type_argument(i64 %call24, i64 %call26) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %11, %cond.true
  br label %if.end.27

if.end.27:                                        ; preds = %cond.end, %if.end.13
  %12 = load i64, i64* %contact, align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 86)
  %call29 = call i64 @Fplist_get(i64 %12, i64 %call28)
  store i64 %call29, i64* %name, align 8
  %13 = load i64, i64* %name, align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %13, %call30
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.end.27
  %14 = load i64, i64* %port, align 8
  store i64 %14, i64* %name, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.33, %if.end.27
  %15 = load i64, i64* %name, align 8
  call void @CHECK_STRING(i64 %15)
  %16 = load i64, i64* %name, align 8
  %call35 = call i64 @make_process(i64 %16)
  store i64 %call35, i64* %proc, align 8
  %call36 = call i64 @SPECPDL_INDEX()
  store i64 %call36, i64* %specpdl_count, align 8
  %17 = load i64, i64* %proc, align 8
  call void @record_unwind_protect(void (i64)* @remove_process, i64 %17)
  %18 = load i64, i64* %proc, align 8
  %call37 = call %struct.Lisp_Process* @XPROCESS(i64 %18)
  store %struct.Lisp_Process* %call37, %struct.Lisp_Process** %p, align 8
  %19 = load i64, i64* %port, align 8
  %call38 = call i32 @serial_open(i64 %19)
  store i32 %call38, i32* %fd, align 4
  %20 = load i32, i32* %fd, align 4
  %21 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %21, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 0
  store i32 %20, i32* %arrayidx, align 4
  %22 = load i32, i32* %fd, align 4
  %23 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %23, i32 0, i32 21
  store i32 %22, i32* %infd, align 4
  %24 = load i32, i32* %fd, align 4
  %25 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %25, i32 0, i32 22
  store i32 %24, i32* %outfd, align 4
  %26 = load i32, i32* %fd, align 4
  %27 = load i32, i32* @max_process_desc, align 4
  %cmp39 = icmp sgt i32 %26, %27
  br i1 %cmp39, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %if.end.34
  %28 = load i32, i32* %fd, align 4
  store i32 %28, i32* @max_process_desc, align 4
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.41, %if.end.34
  %29 = load i64, i64* %proc, align 8
  %30 = load i32, i32* %fd, align 4
  %idxprom = sext i32 %30 to i64
  %arrayidx43 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  store i64 %29, i64* %arrayidx43, align 8
  %31 = load i64, i64* %contact, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 16)
  %call45 = call i64 @Fplist_get(i64 %31, i64 %call44)
  store i64 %call45, i64* %buffer, align 8
  %32 = load i64, i64* %buffer, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %32, %call46
  br i1 %cmp47, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.end.42
  %33 = load i64, i64* %name, align 8
  store i64 %33, i64* %buffer, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.49, %if.end.42
  %34 = load i64, i64* %buffer, align 8
  %call51 = call i64 @Fget_buffer_create(i64 %34)
  store i64 %call51, i64* %buffer, align 8
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %36 = load i64, i64* %buffer, align 8
  call void @pset_buffer(%struct.Lisp_Process* %35, i64 %36)
  %37 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %38 = load i64, i64* %contact, align 8
  call void @pset_childp(%struct.Lisp_Process* %37, i64 %38)
  %39 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %40 = load i64, i64* %contact, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 92)
  %call53 = call i64 @Fplist_get(i64 %40, i64 %call52)
  %call54 = call i64 @Fcopy_sequence(i64 %call53)
  call void @pset_plist(%struct.Lisp_Process* %39, i64 %call54)
  %41 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 845)
  call void @pset_type(%struct.Lisp_Process* %41, i64 %call55)
  %42 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %43 = load i64, i64* %contact, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 115)
  %call57 = call i64 @Fplist_get(i64 %43, i64 %call56)
  call void @pset_sentinel(%struct.Lisp_Process* %42, i64 %call57)
  %44 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %45 = load i64, i64* %contact, align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 42)
  %call59 = call i64 @Fplist_get(i64 %45, i64 %call58)
  call void @pset_filter(%struct.Lisp_Process* %44, i64 %call59)
  %46 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_log(%struct.Lisp_Process* %46, i64 %call60)
  %47 = load i64, i64* %contact, align 8
  %call61 = call i64 @builtin_lisp_symbol(i32 87)
  %call62 = call i64 @Fplist_get(i64 %47, i64 %call61)
  store i64 %call62, i64* %tem, align 8
  %48 = load i64, i64* %tem, align 8
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp64 = icmp eq i64 %48, %call63
  %lnot = xor i1 %cmp64, true
  br i1 %lnot, label %if.then.66, label %if.end.67

if.then.66:                                       ; preds = %if.end.50
  %49 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %49, i32 0, i32 28
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %kill_without_query, align 8
  br label %if.end.67

if.end.67:                                        ; preds = %if.then.66, %if.end.50
  %50 = load i64, i64* %contact, align 8
  %call68 = call i64 @builtin_lisp_symbol(i32 124)
  %call69 = call i64 @Fplist_get(i64 %50, i64 %call68)
  store i64 %call69, i64* %tem, align 8
  %51 = load i64, i64* %tem, align 8
  %call70 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp71 = icmp eq i64 %51, %call70
  %lnot73 = xor i1 %cmp71, true
  br i1 %lnot73, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %if.end.67
  %52 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call75 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_command(%struct.Lisp_Process* %52, i64 %call75)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %if.end.67
  %53 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %53, i32 0, i32 3
  %54 = load i64, i64* %command, align 8
  %call77 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp78 = icmp eq i64 %54, %call77
  br i1 %cmp78, label %if.end.81, label %if.then.80

if.then.80:                                       ; preds = %if.end.76
  %55 = load i32, i32* %fd, align 4
  call void @fd_SET(i32 %55, %struct.fd_set* @input_wait_mask)
  %56 = load i32, i32* %fd, align 4
  call void @fd_SET(i32 %56, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.80, %if.end.76
  %57 = load i64, i64* %buffer, align 8
  %call82 = call zeroext i1 @BUFFERP(i64 %57)
  br i1 %call82, label %if.then.83, label %if.end.125

if.then.83:                                       ; preds = %if.end.81
  %58 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %58, i32 0, i32 11
  %59 = load i64, i64* %mark, align 8
  %60 = load i64, i64* %buffer, align 8
  %61 = load i64, i64* %buffer, align 8
  %call84 = call %struct.buffer* @XBUFFER(i64 %61)
  %62 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp85 = icmp eq %struct.buffer* %call84, %62
  br i1 %cmp85, label %cond.true.87, label %cond.false.88

cond.true.87:                                     ; preds = %if.then.83
  %63 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 79
  %64 = load i64, i64* %zv, align 8
  br label %cond.end.101

cond.false.88:                                    ; preds = %if.then.83
  %65 = load i64, i64* %buffer, align 8
  %call89 = call %struct.buffer* @XBUFFER(i64 %65)
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call89, i32 0, i32 47
  %66 = load i64, i64* %zv_marker_, align 8
  %call90 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp91 = icmp eq i64 %66, %call90
  br i1 %cmp91, label %cond.true.93, label %cond.false.96

cond.true.93:                                     ; preds = %cond.false.88
  %67 = load i64, i64* %buffer, align 8
  %call94 = call %struct.buffer* @XBUFFER(i64 %67)
  %zv95 = getelementptr inbounds %struct.buffer, %struct.buffer* %call94, i32 0, i32 79
  %68 = load i64, i64* %zv95, align 8
  br label %cond.end.100

cond.false.96:                                    ; preds = %cond.false.88
  %69 = load i64, i64* %buffer, align 8
  %call97 = call %struct.buffer* @XBUFFER(i64 %69)
  %zv_marker_98 = getelementptr inbounds %struct.buffer, %struct.buffer* %call97, i32 0, i32 47
  %70 = load i64, i64* %zv_marker_98, align 8
  %call99 = call i64 @marker_position(i64 %70)
  br label %cond.end.100

cond.end.100:                                     ; preds = %cond.false.96, %cond.true.93
  %cond = phi i64 [ %68, %cond.true.93 ], [ %call99, %cond.false.96 ]
  br label %cond.end.101

cond.end.101:                                     ; preds = %cond.end.100, %cond.true.87
  %cond102 = phi i64 [ %64, %cond.true.87 ], [ %cond, %cond.end.100 ]
  %71 = load i64, i64* %buffer, align 8
  %call103 = call %struct.buffer* @XBUFFER(i64 %71)
  %72 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp104 = icmp eq %struct.buffer* %call103, %72
  br i1 %cmp104, label %cond.true.106, label %cond.false.107

cond.true.106:                                    ; preds = %cond.end.101
  %73 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %73, i32 0, i32 80
  %74 = load i64, i64* %zv_byte, align 8
  br label %cond.end.122

cond.false.107:                                   ; preds = %cond.end.101
  %75 = load i64, i64* %buffer, align 8
  %call108 = call %struct.buffer* @XBUFFER(i64 %75)
  %zv_marker_109 = getelementptr inbounds %struct.buffer, %struct.buffer* %call108, i32 0, i32 47
  %76 = load i64, i64* %zv_marker_109, align 8
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp111 = icmp eq i64 %76, %call110
  br i1 %cmp111, label %cond.true.113, label %cond.false.116

cond.true.113:                                    ; preds = %cond.false.107
  %77 = load i64, i64* %buffer, align 8
  %call114 = call %struct.buffer* @XBUFFER(i64 %77)
  %zv_byte115 = getelementptr inbounds %struct.buffer, %struct.buffer* %call114, i32 0, i32 80
  %78 = load i64, i64* %zv_byte115, align 8
  br label %cond.end.120

cond.false.116:                                   ; preds = %cond.false.107
  %79 = load i64, i64* %buffer, align 8
  %call117 = call %struct.buffer* @XBUFFER(i64 %79)
  %zv_marker_118 = getelementptr inbounds %struct.buffer, %struct.buffer* %call117, i32 0, i32 47
  %80 = load i64, i64* %zv_marker_118, align 8
  %call119 = call i64 @marker_byte_position(i64 %80)
  br label %cond.end.120

cond.end.120:                                     ; preds = %cond.false.116, %cond.true.113
  %cond121 = phi i64 [ %78, %cond.true.113 ], [ %call119, %cond.false.116 ]
  br label %cond.end.122

cond.end.122:                                     ; preds = %cond.end.120, %cond.true.106
  %cond123 = phi i64 [ %74, %cond.true.106 ], [ %cond121, %cond.end.120 ]
  %call124 = call i64 @set_marker_both(i64 %59, i64 %60, i64 %cond102, i64 %cond123)
  br label %if.end.125

if.end.125:                                       ; preds = %cond.end.122, %if.end.81
  %81 = load i64, i64* %contact, align 8
  %call126 = call i64 @builtin_lisp_symbol(i32 20)
  %call127 = call i64 @Fplist_member(i64 %81, i64 %call126)
  store i64 %call127, i64* %tem, align 8
  %82 = load i64, i64* %tem, align 8
  %call128 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp129 = icmp eq i64 %82, %call128
  br i1 %cmp129, label %if.end.141, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end.125
  %83 = load i64, i64* %tem, align 8
  %and131 = and i64 %83, 7
  %conv132 = trunc i64 %and131 to i32
  %cmp133 = icmp eq i32 %conv132, 3
  br i1 %cmp133, label %lor.lhs.false, label %if.then.139

lor.lhs.false:                                    ; preds = %land.lhs.true
  %84 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %84, 3
  %85 = inttoptr i64 %sub to i8*
  %86 = bitcast i8* %85 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %86, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %87 = load i64, i64* %cdr, align 8
  %and135 = and i64 %87, 7
  %conv136 = trunc i64 %and135 to i32
  %cmp137 = icmp eq i32 %conv136, 3
  br i1 %cmp137, label %if.end.141, label %if.then.139

if.then.139:                                      ; preds = %lor.lhs.false, %land.lhs.true
  %call140 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call140, i64* %tem, align 8
  br label %if.end.141

if.end.141:                                       ; preds = %if.then.139, %lor.lhs.false, %if.end.125
  %call142 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call142, i64* %val, align 8
  %88 = load i64, i64* %tem, align 8
  %call143 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp144 = icmp eq i64 %88, %call143
  br i1 %cmp144, label %if.else, label %if.then.146

if.then.146:                                      ; preds = %if.end.141
  %89 = load i64, i64* %tem, align 8
  %sub147 = sub nsw i64 %89, 3
  %90 = inttoptr i64 %sub147 to i8*
  %91 = bitcast i8* %90 to %struct.Lisp_Cons*
  %u148 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %91, i32 0, i32 1
  %cdr149 = bitcast %union.anon* %u148 to i64*
  %92 = load i64, i64* %cdr149, align 8
  %sub150 = sub nsw i64 %92, 3
  %93 = inttoptr i64 %sub150 to i8*
  %94 = bitcast i8* %93 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %94, i32 0, i32 0
  %95 = load i64, i64* %car, align 8
  store i64 %95, i64* %val, align 8
  %96 = load i64, i64* %val, align 8
  %and151 = and i64 %96, 7
  %conv152 = trunc i64 %and151 to i32
  %cmp153 = icmp eq i32 %conv152, 3
  br i1 %cmp153, label %if.then.155, label %if.end.158

if.then.155:                                      ; preds = %if.then.146
  %97 = load i64, i64* %val, align 8
  %sub156 = sub nsw i64 %97, 3
  %98 = inttoptr i64 %sub156 to i8*
  %99 = bitcast i8* %98 to %struct.Lisp_Cons*
  %car157 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %99, i32 0, i32 0
  %100 = load i64, i64* %car157, align 8
  store i64 %100, i64* %val, align 8
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.155, %if.then.146
  br label %if.end.184

if.else:                                          ; preds = %if.end.141
  %101 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  %call159 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp160 = icmp eq i64 %101, %call159
  br i1 %cmp160, label %if.else.163, label %if.then.162

if.then.162:                                      ; preds = %if.else
  %102 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  store i64 %102, i64* %val, align 8
  br label %if.end.183

if.else.163:                                      ; preds = %if.else
  %103 = load i64, i64* %buffer, align 8
  %call164 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp165 = icmp eq i64 %103, %call164
  br i1 %cmp165, label %lor.lhs.false.172, label %land.lhs.true.167

land.lhs.true.167:                                ; preds = %if.else.163
  %104 = load i64, i64* %buffer, align 8
  %call168 = call %struct.buffer* @XBUFFER(i64 %104)
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call168, i32 0, i32 39
  %105 = load i64, i64* %enable_multibyte_characters_, align 8
  %call169 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp170 = icmp eq i64 %105, %call169
  br i1 %cmp170, label %if.then.180, label %lor.lhs.false.172

lor.lhs.false.172:                                ; preds = %land.lhs.true.167, %if.else.163
  %106 = load i64, i64* %buffer, align 8
  %call173 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp174 = icmp eq i64 %106, %call173
  br i1 %cmp174, label %land.lhs.true.176, label %if.end.182

land.lhs.true.176:                                ; preds = %lor.lhs.false.172
  %107 = load i64, i64* getelementptr inbounds (%struct.buffer, %struct.buffer* @buffer_defaults, i32 0, i32 39), align 8
  %call177 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp178 = icmp eq i64 %107, %call177
  br i1 %cmp178, label %if.then.180, label %if.end.182

if.then.180:                                      ; preds = %land.lhs.true.176, %land.lhs.true.167
  %call181 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call181, i64* %val, align 8
  br label %if.end.182

if.end.182:                                       ; preds = %if.then.180, %land.lhs.true.176, %lor.lhs.false.172
  br label %if.end.183

if.end.183:                                       ; preds = %if.end.182, %if.then.162
  br label %if.end.184

if.end.184:                                       ; preds = %if.end.183, %if.end.158
  %108 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %109 = load i64, i64* %val, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %108, i64 %109)
  %call185 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call185, i64* %val, align 8
  %110 = load i64, i64* %tem, align 8
  %call186 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp187 = icmp eq i64 %110, %call186
  br i1 %cmp187, label %if.else.204, label %if.then.189

if.then.189:                                      ; preds = %if.end.184
  %111 = load i64, i64* %tem, align 8
  %sub190 = sub nsw i64 %111, 3
  %112 = inttoptr i64 %sub190 to i8*
  %113 = bitcast i8* %112 to %struct.Lisp_Cons*
  %u191 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %113, i32 0, i32 1
  %cdr192 = bitcast %union.anon* %u191 to i64*
  %114 = load i64, i64* %cdr192, align 8
  %sub193 = sub nsw i64 %114, 3
  %115 = inttoptr i64 %sub193 to i8*
  %116 = bitcast i8* %115 to %struct.Lisp_Cons*
  %car194 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %116, i32 0, i32 0
  %117 = load i64, i64* %car194, align 8
  store i64 %117, i64* %val, align 8
  %118 = load i64, i64* %val, align 8
  %and195 = and i64 %118, 7
  %conv196 = trunc i64 %and195 to i32
  %cmp197 = icmp eq i32 %conv196, 3
  br i1 %cmp197, label %if.then.199, label %if.end.203

if.then.199:                                      ; preds = %if.then.189
  %119 = load i64, i64* %val, align 8
  %sub200 = sub nsw i64 %119, 3
  %120 = inttoptr i64 %sub200 to i8*
  %121 = bitcast i8* %120 to %struct.Lisp_Cons*
  %u201 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %121, i32 0, i32 1
  %cdr202 = bitcast %union.anon* %u201 to i64*
  %122 = load i64, i64* %cdr202, align 8
  store i64 %122, i64* %val, align 8
  br label %if.end.203

if.end.203:                                       ; preds = %if.then.199, %if.then.189
  br label %if.end.231

if.else.204:                                      ; preds = %if.end.184
  %123 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  %call205 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp206 = icmp eq i64 %123, %call205
  br i1 %cmp206, label %if.else.209, label %if.then.208

if.then.208:                                      ; preds = %if.else.204
  %124 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  store i64 %124, i64* %val, align 8
  br label %if.end.230

if.else.209:                                      ; preds = %if.else.204
  %125 = load i64, i64* %buffer, align 8
  %call210 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp211 = icmp eq i64 %125, %call210
  br i1 %cmp211, label %lor.lhs.false.219, label %land.lhs.true.213

land.lhs.true.213:                                ; preds = %if.else.209
  %126 = load i64, i64* %buffer, align 8
  %call214 = call %struct.buffer* @XBUFFER(i64 %126)
  %enable_multibyte_characters_215 = getelementptr inbounds %struct.buffer, %struct.buffer* %call214, i32 0, i32 39
  %127 = load i64, i64* %enable_multibyte_characters_215, align 8
  %call216 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp217 = icmp eq i64 %127, %call216
  br i1 %cmp217, label %if.then.227, label %lor.lhs.false.219

lor.lhs.false.219:                                ; preds = %land.lhs.true.213, %if.else.209
  %128 = load i64, i64* %buffer, align 8
  %call220 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp221 = icmp eq i64 %128, %call220
  br i1 %cmp221, label %land.lhs.true.223, label %if.end.229

land.lhs.true.223:                                ; preds = %lor.lhs.false.219
  %129 = load i64, i64* getelementptr inbounds (%struct.buffer, %struct.buffer* @buffer_defaults, i32 0, i32 39), align 8
  %call224 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp225 = icmp eq i64 %129, %call224
  br i1 %cmp225, label %if.then.227, label %if.end.229

if.then.227:                                      ; preds = %land.lhs.true.223, %land.lhs.true.213
  %call228 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call228, i64* %val, align 8
  br label %if.end.229

if.end.229:                                       ; preds = %if.then.227, %land.lhs.true.223, %lor.lhs.false.219
  br label %if.end.230

if.end.230:                                       ; preds = %if.end.229, %if.then.208
  br label %if.end.231

if.end.231:                                       ; preds = %if.end.230, %if.end.203
  %130 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %131 = load i64, i64* %val, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %130, i64 %131)
  %132 = load i64, i64* %proc, align 8
  call void @setup_process_coding_systems(i64 %132)
  %133 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %134 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_decoding_buf(%struct.Lisp_Process* %133, i64 %134)
  %135 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %135, i32 0, i32 26
  store i32 0, i32* %decoding_carryover, align 4
  %136 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %137 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_encoding_buf(%struct.Lisp_Process* %136, i64 %137)
  %138 = load i64, i64* %tem, align 8
  %call232 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp233 = icmp eq i64 %138, %call232
  br i1 %cmp233, label %lor.lhs.false.235, label %lor.end

lor.lhs.false.235:                                ; preds = %if.end.231
  %139 = load i64, i64* %buffer, align 8
  %call236 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp237 = icmp eq i64 %139, %call236
  br i1 %cmp237, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.235
  %140 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 447), align 1
  %tobool = trunc i8 %140 to i1
  %lnot239 = xor i1 %tobool, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.235, %if.end.231
  %141 = phi i1 [ true, %lor.lhs.false.235 ], [ true, %if.end.231 ], [ %lnot239, %lor.rhs ]
  %lnot240 = xor i1 %141, true
  %142 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %142, i32 0, i32 28
  %143 = zext i1 %lnot240 to i8
  %bf.load241 = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.shl = shl i8 %143, 5
  %bf.clear242 = and i8 %bf.load241, -33
  %bf.set243 = or i8 %bf.clear242, %bf.shl
  store i8 %bf.set243, i8* %inherit_coding_system_flag, align 8
  %tobool244 = trunc i8 %143 to i1
  %144 = load i64, i64* %nargs.addr, align 8
  %145 = load i64*, i64** %args.addr, align 8
  %call245 = call i64 @Fserial_process_configure(i64 %144, i64* %145)
  %146 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %147 = load i64, i64* %specpdl_count, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %146, i64 %147
  store %union.specbinding* %add.ptr, %union.specbinding** @specpdl_ptr, align 8
  %148 = load i64, i64* %proc, align 8
  store i64 %148, i64* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.then
  %149 = load i64, i64* %retval
  ret i64 %149
}

declare i64 @Fplist_member(i64, i64) #1

declare i32 @serial_open(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fmake_network_process(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %proc = alloca i64, align 8
  %contact = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %ai = alloca %struct.addrinfo, align 8
  %res = alloca %struct.addrinfo*, align 8
  %lres = alloca %struct.addrinfo*, align 8
  %hints = alloca %struct.addrinfo, align 8
  %portstring = alloca i8*, align 8
  %portbuf = alloca [128 x i8], align 16
  %address_in = alloca %struct.sockaddr_in, align 4
  %address_un = alloca %struct.sockaddr_un, align 2
  %port = alloca i32, align 4
  %ret = alloca i32, align 4
  %xerrno = alloca i32, align 4
  %s = alloca i32, align 4
  %outch = alloca i32, align 4
  %inch = alloca i32, align 4
  %count = alloca i64, align 8
  %count1 = alloca i64, align 8
  %colon_address = alloca i64, align 8
  %tem = alloca i64, align 8
  %name = alloca i64, align 8
  %buffer = alloca i64, align 8
  %host = alloca i64, align 8
  %service = alloca i64, align 8
  %address = alloca i64, align 8
  %filter = alloca i64, align 8
  %sentinel = alloca i64, align 8
  %is_non_blocking_client = alloca i8, align 1
  %is_server = alloca i8, align 1
  %backlog = alloca i32, align 4
  %socktype = alloca i32, align 4
  %family = alloca i32, align 4
  %svc_info = alloca %struct.servent*, align 8
  %optn = alloca i64, align 8
  %optbits = alloca i32, align 4
  %optval = alloca i32, align 4
  %agg.tmp = alloca %union.__CONST_SOCKADDR_ARG, align 8
  %sa1 = alloca %struct.sockaddr_in, align 4
  %len1 = alloca i32, align 4
  %agg.tmp313 = alloca %union.__SOCKADDR_ARG, align 8
  %agg.tmp355 = alloca %union.__CONST_SOCKADDR_ARG, align 8
  %sc = alloca i32, align 4
  %len = alloca i32, align 4
  %fdset = alloca %struct.fd_set, align 8
  %__d0 = alloca i32, align 4
  %__d1 = alloca i32, align 4
  %remote = alloca i64, align 8
  %rfamily = alloca i32, align 4
  %rlen = alloca i32, align 4
  %sa1490 = alloca %struct.sockaddr_in, align 4
  %len1491 = alloca i32, align 4
  %agg.tmp492 = alloca %union.__SOCKADDR_ARG, align 8
  %coding_systems = alloca i64, align 8
  %val = alloca i64, align 8
  %.compoundliteral = alloca [5 x i64], align 8
  %.compoundliteral787 = alloca [5 x i64], align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i32 0, i32* %ret, align 4
  store i32 0, i32* %xerrno, align 4
  store i32 -1, i32* %s, align 4
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  store i8 0, i8* %is_non_blocking_client, align 1
  store i8 0, i8* %is_server, align 1
  store i32 5, i32* %backlog, align 4
  store i32 -1, i32* %family, align 4
  %0 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp eq i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %call2 = call i64 @Flist(i64 %1, i64* %2)
  store i64 %call2, i64* %contact, align 8
  %3 = load i64, i64* %contact, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 131)
  %call4 = call i64 @Fplist_get(i64 %3, i64 %call3)
  store i64 %call4, i64* %tem, align 8
  %4 = load i64, i64* %tem, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.end
  store i32 1, i32* %socktype, align 4
  br label %if.end.18

if.else:                                          ; preds = %if.end
  %5 = load i64, i64* %tem, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 316)
  %cmp9 = icmp eq i64 %5, %call8
  br i1 %cmp9, label %if.then.10, label %if.else.11

if.then.10:                                       ; preds = %if.else
  store i32 2, i32* %socktype, align 4
  br label %if.end.17

if.else.11:                                       ; preds = %if.else
  %6 = load i64, i64* %tem, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 843)
  %cmp13 = icmp eq i64 %6, %call12
  br i1 %cmp13, label %if.then.14, label %if.else.15

if.then.14:                                       ; preds = %if.else.11
  store i32 5, i32* %socktype, align 4
  br label %if.end.16

if.else.15:                                       ; preds = %if.else.11
  call void (i8*, ...) @error(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.17, i32 0, i32 0)) #8
  unreachable

if.end.16:                                        ; preds = %if.then.14
  br label %if.end.17

if.end.17:                                        ; preds = %if.end.16, %if.then.10
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %if.then.7
  %7 = load i64, i64* %contact, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 116)
  %call20 = call i64 @Fplist_get(i64 %7, i64 %call19)
  store i64 %call20, i64* %tem, align 8
  %8 = load i64, i64* %tem, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %8, %call21
  br i1 %cmp22, label %if.end.40, label %if.then.23

if.then.23:                                       ; preds = %if.end.18
  store i8 1, i8* %is_server, align 1
  %9 = load i64, i64* %tem, align 8
  %and = and i64 %9, 7
  %conv = trunc i64 %and to i32
  %and24 = and i32 %conv, -5
  %cmp25 = icmp eq i32 %and24, 2
  br i1 %cmp25, label %land.lhs.true, label %if.end.39

land.lhs.true:                                    ; preds = %if.then.23
  br i1 false, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %10 = load i64, i64* %tem, align 8
  %shr = ashr i64 %10, 2
  %cmp27 = icmp sle i64 -2147483648, %shr
  br i1 %cmp27, label %land.lhs.true.32, label %if.end.39

cond.false:                                       ; preds = %land.lhs.true
  %11 = load i64, i64* %tem, align 8
  %shr29 = ashr i64 %11, 2
  %cmp30 = icmp sle i64 0, %shr29
  br i1 %cmp30, label %land.lhs.true.32, label %if.end.39

land.lhs.true.32:                                 ; preds = %cond.false, %cond.true
  %12 = load i64, i64* %tem, align 8
  %shr33 = ashr i64 %12, 2
  %cmp34 = icmp sle i64 %shr33, 2147483647
  br i1 %cmp34, label %if.then.36, label %if.end.39

if.then.36:                                       ; preds = %land.lhs.true.32
  %13 = load i64, i64* %tem, align 8
  %shr37 = ashr i64 %13, 2
  %conv38 = trunc i64 %shr37 to i32
  store i32 %conv38, i32* %backlog, align 4
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.36, %land.lhs.true.32, %cond.false, %cond.true, %if.then.23
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.end.18
  %14 = load i8, i8* %is_server, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %cond.true.42, label %cond.false.44

cond.true.42:                                     ; preds = %if.end.40
  %call43 = call i64 @builtin_lisp_symbol(i32 77)
  br label %cond.end

cond.false.44:                                    ; preds = %if.end.40
  %call45 = call i64 @builtin_lisp_symbol(i32 108)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.44, %cond.true.42
  %cond = phi i64 [ %call43, %cond.true.42 ], [ %call45, %cond.false.44 ]
  store i64 %cond, i64* %colon_address, align 8
  %15 = load i8, i8* %is_server, align 1
  %tobool46 = trunc i8 %15 to i1
  br i1 %tobool46, label %if.end.57, label %land.lhs.true.47

land.lhs.true.47:                                 ; preds = %cond.end
  %16 = load i32, i32* %socktype, align 4
  %cmp48 = icmp ne i32 %16, 2
  br i1 %cmp48, label %land.lhs.true.50, label %if.end.57

land.lhs.true.50:                                 ; preds = %land.lhs.true.47
  %17 = load i64, i64* %contact, align 8
  %call51 = call i64 @builtin_lisp_symbol(i32 88)
  %call52 = call i64 @Fplist_get(i64 %17, i64 %call51)
  store i64 %call52, i64* %tem, align 8
  %18 = load i64, i64* %tem, align 8
  %call53 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp54 = icmp eq i64 %18, %call53
  %lnot = xor i1 %cmp54, true
  br i1 %lnot, label %if.then.56, label %if.end.57

if.then.56:                                       ; preds = %land.lhs.true.50
  store i8 1, i8* %is_non_blocking_client, align 1
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.56, %land.lhs.true.50, %land.lhs.true.47, %cond.end
  %19 = load i64, i64* %contact, align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 86)
  %call59 = call i64 @Fplist_get(i64 %19, i64 %call58)
  store i64 %call59, i64* %name, align 8
  %20 = load i64, i64* %contact, align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 16)
  %call61 = call i64 @Fplist_get(i64 %20, i64 %call60)
  store i64 %call61, i64* %buffer, align 8
  %21 = load i64, i64* %contact, align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 42)
  %call63 = call i64 @Fplist_get(i64 %21, i64 %call62)
  store i64 %call63, i64* %filter, align 8
  %22 = load i64, i64* %contact, align 8
  %call64 = call i64 @builtin_lisp_symbol(i32 115)
  %call65 = call i64 @Fplist_get(i64 %22, i64 %call64)
  store i64 %call65, i64* %sentinel, align 8
  %23 = load i64, i64* %name, align 8
  call void @CHECK_STRING(i64 %23)
  %24 = load i32, i32* %socktype, align 4
  %ai_socktype = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 2
  store i32 %24, i32* %ai_socktype, align 4
  %ai_protocol = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 3
  store i32 0, i32* %ai_protocol, align 4
  %ai_next = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 7
  store %struct.addrinfo* null, %struct.addrinfo** %ai_next, align 8
  store %struct.addrinfo* %ai, %struct.addrinfo** %res, align 8
  %25 = load i64, i64* %contact, align 8
  %26 = load i64, i64* %colon_address, align 8
  %call66 = call i64 @Fplist_get(i64 %25, i64 %26)
  store i64 %call66, i64* %address, align 8
  %27 = load i64, i64* %address, align 8
  %call67 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp68 = icmp eq i64 %27, %call67
  br i1 %cmp68, label %if.end.80, label %if.then.70

if.then.70:                                       ; preds = %if.end.57
  %call71 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call71, i64* %service, align 8
  store i64 %call71, i64* %host, align 8
  %28 = load i64, i64* %address, align 8
  %call72 = call i32 @get_lisp_to_sockaddr_size(i64 %28, i32* %family)
  %ai_addrlen = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 4
  store i32 %call72, i32* %ai_addrlen, align 4
  %tobool73 = icmp ne i32 %call72, 0
  br i1 %tobool73, label %if.end.75, label %if.then.74

if.then.74:                                       ; preds = %if.then.70
  call void (i8*, ...) @error(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.18, i32 0, i32 0)) #8
  unreachable

if.end.75:                                        ; preds = %if.then.70
  %29 = load i32, i32* %family, align 4
  %ai_family = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 1
  store i32 %29, i32* %ai_family, align 4
  %ai_addrlen76 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 4
  %30 = load i32, i32* %ai_addrlen76, align 4
  %conv77 = zext i32 %30 to i64
  %31 = alloca i8, i64 %conv77
  %32 = bitcast i8* %31 to %struct.sockaddr*
  %ai_addr = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 5
  store %struct.sockaddr* %32, %struct.sockaddr** %ai_addr, align 8
  %33 = load i32, i32* %family, align 4
  %34 = load i64, i64* %address, align 8
  %ai_addr78 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 5
  %35 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr78, align 8
  %ai_addrlen79 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 4
  %36 = load i32, i32* %ai_addrlen79, align 4
  call void @conv_lisp_to_sockaddr(i32 %33, i64 %34, %struct.sockaddr* %35, i32 %36)
  br label %open_socket

if.end.80:                                        ; preds = %if.end.57
  %37 = load i64, i64* %contact, align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 40)
  %call82 = call i64 @Fplist_get(i64 %37, i64 %call81)
  store i64 %call82, i64* %tem, align 8
  %38 = load i64, i64* %tem, align 8
  %call83 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp84 = icmp eq i64 %38, %call83
  br i1 %cmp84, label %if.then.86, label %if.else.87

if.then.86:                                       ; preds = %if.end.80
  store i32 0, i32* %family, align 4
  br label %if.end.129

if.else.87:                                       ; preds = %if.end.80
  %39 = load i64, i64* %tem, align 8
  %call88 = call i64 @builtin_lisp_symbol(i32 632)
  %cmp89 = icmp eq i64 %39, %call88
  br i1 %cmp89, label %if.then.91, label %if.else.92

if.then.91:                                       ; preds = %if.else.87
  store i32 1, i32* %family, align 4
  br label %if.end.128

if.else.92:                                       ; preds = %if.else.87
  %40 = load i64, i64* %tem, align 8
  %call93 = call i64 @builtin_lisp_symbol(i32 576)
  %cmp94 = icmp eq i64 %40, %call93
  br i1 %cmp94, label %if.then.96, label %if.else.97

if.then.96:                                       ; preds = %if.else.92
  store i32 10, i32* %family, align 4
  br label %if.end.127

if.else.97:                                       ; preds = %if.else.92
  %41 = load i64, i64* %tem, align 8
  %call98 = call i64 @builtin_lisp_symbol(i32 575)
  %cmp99 = icmp eq i64 %41, %call98
  br i1 %cmp99, label %if.then.101, label %if.else.102

if.then.101:                                      ; preds = %if.else.97
  store i32 2, i32* %family, align 4
  br label %if.end.126

if.else.102:                                      ; preds = %if.else.97
  %42 = load i64, i64* %tem, align 8
  %and103 = and i64 %42, 7
  %conv104 = trunc i64 %and103 to i32
  %and105 = and i32 %conv104, -5
  %cmp106 = icmp eq i32 %and105, 2
  br i1 %cmp106, label %land.lhs.true.108, label %if.else.124

land.lhs.true.108:                                ; preds = %if.else.102
  br i1 false, label %cond.false.113, label %cond.true.109

cond.true.109:                                    ; preds = %land.lhs.true.108
  %43 = load i64, i64* %tem, align 8
  %shr110 = ashr i64 %43, 2
  %cmp111 = icmp sle i64 -2147483648, %shr110
  br i1 %cmp111, label %land.lhs.true.117, label %if.else.124

cond.false.113:                                   ; preds = %land.lhs.true.108
  %44 = load i64, i64* %tem, align 8
  %shr114 = ashr i64 %44, 2
  %cmp115 = icmp sle i64 0, %shr114
  br i1 %cmp115, label %land.lhs.true.117, label %if.else.124

land.lhs.true.117:                                ; preds = %cond.false.113, %cond.true.109
  %45 = load i64, i64* %tem, align 8
  %shr118 = ashr i64 %45, 2
  %cmp119 = icmp sle i64 %shr118, 2147483647
  br i1 %cmp119, label %if.then.121, label %if.else.124

if.then.121:                                      ; preds = %land.lhs.true.117
  %46 = load i64, i64* %tem, align 8
  %shr122 = ashr i64 %46, 2
  %conv123 = trunc i64 %shr122 to i32
  store i32 %conv123, i32* %family, align 4
  br label %if.end.125

if.else.124:                                      ; preds = %land.lhs.true.117, %cond.false.113, %cond.true.109, %if.else.102
  call void (i8*, ...) @error(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.19, i32 0, i32 0)) #8
  unreachable

if.end.125:                                       ; preds = %if.then.121
  br label %if.end.126

if.end.126:                                       ; preds = %if.end.125, %if.then.101
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %if.then.96
  br label %if.end.128

if.end.128:                                       ; preds = %if.end.127, %if.then.91
  br label %if.end.129

if.end.129:                                       ; preds = %if.end.128, %if.then.86
  %47 = load i32, i32* %family, align 4
  %ai_family130 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 1
  store i32 %47, i32* %ai_family130, align 4
  %48 = load i64, i64* %contact, align 8
  %call131 = call i64 @builtin_lisp_symbol(i32 117)
  %call132 = call i64 @Fplist_get(i64 %48, i64 %call131)
  store i64 %call132, i64* %service, align 8
  %49 = load i64, i64* %contact, align 8
  %call133 = call i64 @builtin_lisp_symbol(i32 63)
  %call134 = call i64 @Fplist_get(i64 %49, i64 %call133)
  store i64 %call134, i64* %host, align 8
  %50 = load i64, i64* %host, align 8
  %call135 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp136 = icmp eq i64 %50, %call135
  br i1 %cmp136, label %if.end.145, label %if.then.138

if.then.138:                                      ; preds = %if.end.129
  %51 = load i64, i64* %host, align 8
  %call139 = call i64 @builtin_lisp_symbol(i32 632)
  %cmp140 = icmp eq i64 %51, %call139
  br i1 %cmp140, label %if.then.142, label %if.end.144

if.then.142:                                      ; preds = %if.then.138
  %call143 = call i64 @build_string(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.20, i32 0, i32 0))
  store i64 %call143, i64* %host, align 8
  br label %if.end.144

if.end.144:                                       ; preds = %if.then.142, %if.then.138
  %52 = load i64, i64* %host, align 8
  call void @CHECK_STRING(i64 %52)
  br label %if.end.145

if.end.145:                                       ; preds = %if.end.144, %if.end.129
  %53 = load i32, i32* %family, align 4
  %cmp146 = icmp eq i32 %53, 1
  br i1 %cmp146, label %if.then.148, label %if.end.166

if.then.148:                                      ; preds = %if.end.145
  %54 = load i64, i64* %host, align 8
  %call149 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp150 = icmp eq i64 %54, %call149
  br i1 %cmp150, label %if.end.157, label %if.then.152

if.then.152:                                      ; preds = %if.then.148
  call void (i8*, ...) @message(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.21, i32 0, i32 0))
  %55 = load i64, i64* %contact, align 8
  %call153 = call i64 @builtin_lisp_symbol(i32 63)
  %call154 = call i64 @builtin_lisp_symbol(i32 0)
  %call155 = call i64 @Fplist_put(i64 %55, i64 %call153, i64 %call154)
  store i64 %call155, i64* %contact, align 8
  %call156 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call156, i64* %host, align 8
  br label %if.end.157

if.end.157:                                       ; preds = %if.then.152, %if.then.148
  %56 = load i64, i64* %service, align 8
  call void @CHECK_STRING(i64 %56)
  %57 = bitcast %struct.sockaddr_un* %address_un to i8*
  call void @llvm.memset.p0i8.i64(i8* %57, i8 0, i64 110, i32 2, i1 false)
  %sun_family = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %address_un, i32 0, i32 0
  store i16 1, i16* %sun_family, align 2
  %58 = load i64, i64* %service, align 8
  %call158 = call i64 @SBYTES(i64 %58)
  %cmp159 = icmp ule i64 108, %call158
  br i1 %cmp159, label %if.then.161, label %if.end.162

if.then.161:                                      ; preds = %if.end.157
  call void (i8*, ...) @error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.22, i32 0, i32 0)) #8
  unreachable

if.end.162:                                       ; preds = %if.end.157
  %sun_path = getelementptr inbounds %struct.sockaddr_un, %struct.sockaddr_un* %address_un, i32 0, i32 1
  %arraydecay = getelementptr inbounds [108 x i8], [108 x i8]* %sun_path, i32 0, i32 0
  %59 = load i64, i64* %service, align 8
  %call163 = call i8* @lispstpcpy(i8* %arraydecay, i64 %59)
  %60 = bitcast %struct.sockaddr_un* %address_un to %struct.sockaddr*
  %ai_addr164 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 5
  store %struct.sockaddr* %60, %struct.sockaddr** %ai_addr164, align 8
  %ai_addrlen165 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 4
  store i32 110, i32* %ai_addrlen165, align 4
  br label %open_socket

if.end.166:                                       ; preds = %if.end.145
  %61 = load i32, i32* %socktype, align 4
  %cmp167 = icmp ne i32 %61, 2
  br i1 %cmp167, label %if.then.169, label %if.end.170

if.then.169:                                      ; preds = %if.end.166
  call void @record_unwind_protect_void(void ()* @run_all_atimers)
  call void @bind_polling_period(i32 10)
  br label %if.end.170

if.end.170:                                       ; preds = %if.then.169, %if.end.166
  %62 = load i64, i64* %host, align 8
  %call171 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp172 = icmp eq i64 %62, %call171
  br i1 %cmp172, label %if.end.218, label %if.then.174

if.then.174:                                      ; preds = %if.end.170
  %63 = load i64, i64* %service, align 8
  %call175 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp176 = icmp eq i64 %63, %call175
  br i1 %cmp176, label %if.then.178, label %if.else.179

if.then.178:                                      ; preds = %if.then.174
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.23, i32 0, i32 0), i8** %portstring, align 8
  br label %if.end.193

if.else.179:                                      ; preds = %if.then.174
  %64 = load i64, i64* %service, align 8
  %and180 = and i64 %64, 7
  %conv181 = trunc i64 %and180 to i32
  %and182 = and i32 %conv181, -5
  %cmp183 = icmp eq i32 %and182, 2
  br i1 %cmp183, label %if.then.185, label %if.else.190

if.then.185:                                      ; preds = %if.else.179
  %arraydecay186 = getelementptr inbounds [128 x i8], [128 x i8]* %portbuf, i32 0, i32 0
  %65 = load i64, i64* %service, align 8
  %shr187 = ashr i64 %65, 2
  %call188 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay186, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.24, i32 0, i32 0), i64 %shr187) #5
  %arraydecay189 = getelementptr inbounds [128 x i8], [128 x i8]* %portbuf, i32 0, i32 0
  store i8* %arraydecay189, i8** %portstring, align 8
  br label %if.end.192

if.else.190:                                      ; preds = %if.else.179
  %66 = load i64, i64* %service, align 8
  call void @CHECK_STRING(i64 %66)
  %67 = load i64, i64* %service, align 8
  %call191 = call i8* @SSDATA(i64 %67)
  store i8* %call191, i8** %portstring, align 8
  br label %if.end.192

if.end.192:                                       ; preds = %if.else.190, %if.then.185
  br label %if.end.193

if.end.193:                                       ; preds = %if.end.192, %if.then.178
  store i8 1, i8* @immediate_quit, align 1
  br label %do.body

do.body:                                          ; preds = %if.end.193
  %68 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call194 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp195 = icmp eq i64 %68, %call194
  br i1 %cmp195, label %if.else.202, label %land.lhs.true.197

land.lhs.true.197:                                ; preds = %do.body
  %69 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call198 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp199 = icmp eq i64 %69, %call198
  br i1 %cmp199, label %if.then.201, label %if.else.202

if.then.201:                                      ; preds = %land.lhs.true.197
  call void @process_quit_flag()
  br label %if.end.206

if.else.202:                                      ; preds = %land.lhs.true.197, %do.body
  %70 = load volatile i8, i8* @pending_signals, align 1
  %tobool203 = trunc i8 %70 to i1
  br i1 %tobool203, label %if.then.204, label %if.end.205

if.then.204:                                      ; preds = %if.else.202
  call void @process_pending_signals()
  br label %if.end.205

if.end.205:                                       ; preds = %if.then.204, %if.else.202
  br label %if.end.206

if.end.206:                                       ; preds = %if.end.205, %if.then.201
  br label %do.end

do.end:                                           ; preds = %if.end.206
  %71 = bitcast %struct.addrinfo* %hints to i8*
  call void @llvm.memset.p0i8.i64(i8* %71, i8 0, i64 48, i32 8, i1 false)
  %ai_flags = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %hints, i32 0, i32 0
  store i32 0, i32* %ai_flags, align 4
  %72 = load i32, i32* %family, align 4
  %ai_family207 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %hints, i32 0, i32 1
  store i32 %72, i32* %ai_family207, align 4
  %73 = load i32, i32* %socktype, align 4
  %ai_socktype208 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %hints, i32 0, i32 2
  store i32 %73, i32* %ai_socktype208, align 4
  %ai_protocol209 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %hints, i32 0, i32 3
  store i32 0, i32* %ai_protocol209, align 4
  %call210 = call i32 @__res_init() #5
  %74 = load i64, i64* %host, align 8
  %call211 = call i8* @SSDATA(i64 %74)
  %75 = load i8*, i8** %portstring, align 8
  %call212 = call i32 @getaddrinfo(i8* %call211, i8* %75, %struct.addrinfo* %hints, %struct.addrinfo** %res)
  store i32 %call212, i32* %ret, align 4
  %76 = load i32, i32* %ret, align 4
  %tobool213 = icmp ne i32 %76, 0
  br i1 %tobool213, label %if.then.214, label %if.end.217

if.then.214:                                      ; preds = %do.end
  %77 = load i64, i64* %host, align 8
  %call215 = call i8* @SSDATA(i64 %77)
  %78 = load i8*, i8** %portstring, align 8
  %79 = load i32, i32* %ret, align 4
  %call216 = call i8* @gai_strerror(i32 %79) #5
  call void (i8*, ...) @error(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0), i8* %call215, i8* %78, i8* %call216) #8
  unreachable

if.end.217:                                       ; preds = %do.end
  store i8 0, i8* @immediate_quit, align 1
  br label %open_socket

if.end.218:                                       ; preds = %if.end.170
  %80 = load i64, i64* %service, align 8
  %call219 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp220 = icmp eq i64 %80, %call219
  br i1 %cmp220, label %if.then.222, label %if.else.223

if.then.222:                                      ; preds = %if.end.218
  store i32 0, i32* %port, align 4
  br label %if.end.246

if.else.223:                                      ; preds = %if.end.218
  %81 = load i64, i64* %service, align 8
  %and224 = and i64 %81, 7
  %conv225 = trunc i64 %and224 to i32
  %and226 = and i32 %conv225, -5
  %cmp227 = icmp eq i32 %and226, 2
  br i1 %cmp227, label %if.then.229, label %if.else.234

if.then.229:                                      ; preds = %if.else.223
  %82 = load i64, i64* %service, align 8
  %shr230 = ashr i64 %82, 2
  %conv231 = trunc i64 %shr230 to i16
  %call232 = call zeroext i16 @htons(i16 zeroext %conv231) #11
  %conv233 = zext i16 %call232 to i32
  store i32 %conv233, i32* %port, align 4
  br label %if.end.245

if.else.234:                                      ; preds = %if.else.223
  %83 = load i64, i64* %service, align 8
  call void @CHECK_STRING(i64 %83)
  %84 = load i64, i64* %service, align 8
  %call235 = call i8* @SSDATA(i64 %84)
  %85 = load i32, i32* %socktype, align 4
  %cmp236 = icmp eq i32 %85, 2
  %cond238 = select i1 %cmp236, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.27, i32 0, i32 0)
  %call239 = call %struct.servent* @getservbyname(i8* %call235, i8* %cond238)
  store %struct.servent* %call239, %struct.servent** %svc_info, align 8
  %86 = load %struct.servent*, %struct.servent** %svc_info, align 8
  %cmp240 = icmp eq %struct.servent* %86, null
  br i1 %cmp240, label %if.then.242, label %if.end.244

if.then.242:                                      ; preds = %if.else.234
  %87 = load i64, i64* %service, align 8
  %call243 = call i8* @SDATA(i64 %87)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.28, i32 0, i32 0), i8* %call243) #8
  unreachable

if.end.244:                                       ; preds = %if.else.234
  %88 = load %struct.servent*, %struct.servent** %svc_info, align 8
  %s_port = getelementptr inbounds %struct.servent, %struct.servent* %88, i32 0, i32 2
  %89 = load i32, i32* %s_port, align 4
  store i32 %89, i32* %port, align 4
  br label %if.end.245

if.end.245:                                       ; preds = %if.end.244, %if.then.229
  br label %if.end.246

if.end.246:                                       ; preds = %if.end.245, %if.then.222
  %90 = bitcast %struct.sockaddr_in* %address_in to i8*
  call void @llvm.memset.p0i8.i64(i8* %90, i8 0, i64 16, i32 4, i1 false)
  %91 = load i32, i32* %family, align 4
  %conv247 = trunc i32 %91 to i16
  %sin_family = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %address_in, i32 0, i32 0
  store i16 %conv247, i16* %sin_family, align 2
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %address_in, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.in_addr, %struct.in_addr* %sin_addr, i32 0, i32 0
  store i32 0, i32* %s_addr, align 4
  %92 = load i32, i32* %port, align 4
  %conv248 = trunc i32 %92 to i16
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %address_in, i32 0, i32 1
  store i16 %conv248, i16* %sin_port, align 2
  %93 = load i32, i32* %family, align 4
  %ai_family249 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 1
  store i32 %93, i32* %ai_family249, align 4
  %94 = bitcast %struct.sockaddr_in* %address_in to %struct.sockaddr*
  %ai_addr250 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 5
  store %struct.sockaddr* %94, %struct.sockaddr** %ai_addr250, align 8
  %ai_addrlen251 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %ai, i32 0, i32 4
  store i32 16, i32* %ai_addrlen251, align 4
  br label %open_socket

open_socket:                                      ; preds = %if.end.246, %if.end.217, %if.end.162, %if.end.75
  %call252 = call i64 @SPECPDL_INDEX()
  store i64 %call252, i64* %count1, align 8
  store i32 -1, i32* %s, align 4
  %95 = load %struct.addrinfo*, %struct.addrinfo** %res, align 8
  store %struct.addrinfo* %95, %struct.addrinfo** %lres, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.421, %open_socket
  %96 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %tobool253 = icmp ne %struct.addrinfo* %96, null
  br i1 %tobool253, label %for.body, label %for.end.423

for.body:                                         ; preds = %for.cond
  %97 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_family254 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %97, i32 0, i32 1
  %98 = load i32, i32* %ai_family254, align 4
  %99 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_socktype255 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %99, i32 0, i32 2
  %100 = load i32, i32* %ai_socktype255, align 4
  %or = or i32 %100, 524288
  %101 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_protocol256 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %101, i32 0, i32 3
  %102 = load i32, i32* %ai_protocol256, align 4
  %call257 = call i32 @socket(i32 %98, i32 %or, i32 %102) #5
  store i32 %call257, i32* %s, align 4
  %103 = load i32, i32* %s, align 4
  %cmp258 = icmp slt i32 %103, 0
  br i1 %cmp258, label %if.then.260, label %if.end.262

if.then.260:                                      ; preds = %for.body
  %call261 = call i32* @__errno_location() #11
  %104 = load i32, i32* %call261, align 4
  store i32 %104, i32* %xerrno, align 4
  br label %for.inc.421

if.end.262:                                       ; preds = %for.body
  %105 = load i8, i8* %is_server, align 1
  %tobool263 = trunc i8 %105 to i1
  br i1 %tobool263, label %if.end.268, label %land.lhs.true.264

land.lhs.true.264:                                ; preds = %if.end.262
  %106 = load i32, i32* %socktype, align 4
  %cmp265 = icmp eq i32 %106, 2
  br i1 %cmp265, label %if.then.267, label %if.end.268

if.then.267:                                      ; preds = %land.lhs.true.264
  br label %for.end.423

if.end.268:                                       ; preds = %land.lhs.true.264, %if.end.262
  %107 = load i8, i8* %is_non_blocking_client, align 1
  %tobool269 = trunc i8 %107 to i1
  br i1 %tobool269, label %if.then.270, label %if.end.278

if.then.270:                                      ; preds = %if.end.268
  %108 = load i32, i32* %s, align 4
  %call271 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %108, i32 4, i32 2048)
  store i32 %call271, i32* %ret, align 4
  %109 = load i32, i32* %ret, align 4
  %cmp272 = icmp slt i32 %109, 0
  br i1 %cmp272, label %if.then.274, label %if.end.277

if.then.274:                                      ; preds = %if.then.270
  %call275 = call i32* @__errno_location() #11
  %110 = load i32, i32* %call275, align 4
  store i32 %110, i32* %xerrno, align 4
  %111 = load i32, i32* %s, align 4
  %call276 = call i32 @emacs_close(i32 %111)
  store i32 -1, i32* %s, align 4
  br label %for.inc.421

if.end.277:                                       ; preds = %if.then.270
  br label %if.end.278

if.end.278:                                       ; preds = %if.end.277, %if.end.268
  %112 = load i32, i32* %s, align 4
  call void @record_unwind_protect_int(void (i32)* @close_file_unwind, i32 %112)
  store i32 0, i32* %optbits, align 4
  store i64 0, i64* %optn, align 8
  br label %for.cond.279

for.cond.279:                                     ; preds = %for.inc, %if.end.278
  %113 = load i64, i64* %optn, align 8
  %114 = load i64, i64* %nargs.addr, align 8
  %sub = sub nsw i64 %114, 1
  %cmp280 = icmp slt i64 %113, %sub
  br i1 %cmp280, label %for.body.282, label %for.end

for.body.282:                                     ; preds = %for.cond.279
  %115 = load i32, i32* %s, align 4
  %116 = load i64, i64* %optn, align 8
  %117 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %117, i64 %116
  %118 = load i64, i64* %arrayidx, align 8
  %119 = load i64, i64* %optn, align 8
  %add = add nsw i64 %119, 1
  %120 = load i64*, i64** %args.addr, align 8
  %arrayidx283 = getelementptr inbounds i64, i64* %120, i64 %add
  %121 = load i64, i64* %arrayidx283, align 8
  %call284 = call i32 @set_socket_option(i32 %115, i64 %118, i64 %121)
  %122 = load i32, i32* %optbits, align 4
  %or285 = or i32 %122, %call284
  store i32 %or285, i32* %optbits, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body.282
  %123 = load i64, i64* %optn, align 8
  %add286 = add nsw i64 %123, 2
  store i64 %add286, i64* %optn, align 8
  br label %for.cond.279

for.end:                                          ; preds = %for.cond.279
  %124 = load i8, i8* %is_server, align 1
  %tobool287 = trunc i8 %124 to i1
  br i1 %tobool287, label %if.then.288, label %if.end.339

if.then.288:                                      ; preds = %for.end
  %125 = load i32, i32* %family, align 4
  %cmp289 = icmp ne i32 %125, 1
  br i1 %cmp289, label %if.then.291, label %if.end.301

if.then.291:                                      ; preds = %if.then.288
  %126 = load i32, i32* %optbits, align 4
  %and292 = and i32 %126, 4
  %tobool293 = icmp ne i32 %and292, 0
  br i1 %tobool293, label %if.end.300, label %if.then.294

if.then.294:                                      ; preds = %if.then.291
  store i32 1, i32* %optval, align 4
  %127 = load i32, i32* %s, align 4
  %128 = bitcast i32* %optval to i8*
  %call295 = call i32 @setsockopt(i32 %127, i32 1, i32 2, i8* %128, i32 4) #5
  %tobool296 = icmp ne i32 %call295, 0
  br i1 %tobool296, label %if.then.297, label %if.end.299

if.then.297:                                      ; preds = %if.then.294
  %call298 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.29, i32 0, i32 0), i64 %call298) #8
  unreachable

if.end.299:                                       ; preds = %if.then.294
  br label %if.end.300

if.end.300:                                       ; preds = %if.end.299, %if.then.291
  br label %if.end.301

if.end.301:                                       ; preds = %if.end.300, %if.then.288
  %129 = load i32, i32* %s, align 4
  %__sockaddr__ = bitcast %union.__CONST_SOCKADDR_ARG* %agg.tmp to %struct.sockaddr**
  %130 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addr302 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %130, i32 0, i32 5
  %131 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr302, align 8
  store %struct.sockaddr* %131, %struct.sockaddr** %__sockaddr__, align 8
  %132 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen303 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %132, i32 0, i32 4
  %133 = load i32, i32* %ai_addrlen303, align 4
  %coerce.dive = getelementptr %union.__CONST_SOCKADDR_ARG, %union.__CONST_SOCKADDR_ARG* %agg.tmp, i32 0, i32 0
  %134 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive, align 8
  %call304 = call i32 @bind(i32 %129, %struct.sockaddr* %134, i32 %133) #5
  %tobool305 = icmp ne i32 %call304, 0
  br i1 %tobool305, label %if.then.306, label %if.end.308

if.then.306:                                      ; preds = %if.end.301
  %call307 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.30, i32 0, i32 0), i64 %call307) #8
  unreachable

if.end.308:                                       ; preds = %if.end.301
  %135 = load i64, i64* %service, align 8
  %call309 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp310 = icmp eq i64 %135, %call309
  br i1 %cmp310, label %if.then.312, label %if.end.330

if.then.312:                                      ; preds = %if.end.308
  store i32 16, i32* %len1, align 4
  %136 = load i32, i32* %s, align 4
  %__sockaddr__314 = bitcast %union.__SOCKADDR_ARG* %agg.tmp313 to %struct.sockaddr**
  %137 = bitcast %struct.sockaddr_in* %sa1 to %struct.sockaddr*
  store %struct.sockaddr* %137, %struct.sockaddr** %__sockaddr__314, align 8
  %coerce.dive315 = getelementptr %union.__SOCKADDR_ARG, %union.__SOCKADDR_ARG* %agg.tmp313, i32 0, i32 0
  %138 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive315, align 8
  %call316 = call i32 @getsockname(i32 %136, %struct.sockaddr* %138, i32* %len1) #5
  %cmp317 = icmp eq i32 %call316, 0
  br i1 %cmp317, label %if.then.319, label %if.end.329

if.then.319:                                      ; preds = %if.then.312
  %sin_port320 = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sa1, i32 0, i32 1
  %139 = load i16, i16* %sin_port320, align 2
  %140 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addr321 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %140, i32 0, i32 5
  %141 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr321, align 8
  %142 = bitcast %struct.sockaddr* %141 to %struct.sockaddr_in*
  %sin_port322 = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %142, i32 0, i32 1
  store i16 %139, i16* %sin_port322, align 2
  %sin_port323 = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %sa1, i32 0, i32 1
  %143 = load i16, i16* %sin_port323, align 2
  %call324 = call zeroext i16 @ntohs(i16 zeroext %143) #11
  %conv325 = zext i16 %call324 to i64
  %shl = shl i64 %conv325, 2
  %add326 = add i64 %shl, 2
  store i64 %add326, i64* %service, align 8
  %144 = load i64, i64* %contact, align 8
  %call327 = call i64 @builtin_lisp_symbol(i32 117)
  %145 = load i64, i64* %service, align 8
  %call328 = call i64 @Fplist_put(i64 %144, i64 %call327, i64 %145)
  store i64 %call328, i64* %contact, align 8
  br label %if.end.329

if.end.329:                                       ; preds = %if.then.319, %if.then.312
  br label %if.end.330

if.end.330:                                       ; preds = %if.end.329, %if.end.308
  %146 = load i32, i32* %socktype, align 4
  %cmp331 = icmp ne i32 %146, 2
  br i1 %cmp331, label %land.lhs.true.333, label %if.end.338

land.lhs.true.333:                                ; preds = %if.end.330
  %147 = load i32, i32* %s, align 4
  %148 = load i32, i32* %backlog, align 4
  %call334 = call i32 @listen(i32 %147, i32 %148) #5
  %tobool335 = icmp ne i32 %call334, 0
  br i1 %tobool335, label %if.then.336, label %if.end.338

if.then.336:                                      ; preds = %land.lhs.true.333
  %call337 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.31, i32 0, i32 0), i64 %call337) #8
  unreachable

if.end.338:                                       ; preds = %land.lhs.true.333, %if.end.330
  br label %for.end.423

if.end.339:                                       ; preds = %for.end
  store i8 1, i8* @immediate_quit, align 1
  br label %do.body.340

do.body.340:                                      ; preds = %if.end.339
  %149 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call341 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp342 = icmp eq i64 %149, %call341
  br i1 %cmp342, label %if.else.349, label %land.lhs.true.344

land.lhs.true.344:                                ; preds = %do.body.340
  %150 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call345 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp346 = icmp eq i64 %150, %call345
  br i1 %cmp346, label %if.then.348, label %if.else.349

if.then.348:                                      ; preds = %land.lhs.true.344
  call void @process_quit_flag()
  br label %if.end.353

if.else.349:                                      ; preds = %land.lhs.true.344, %do.body.340
  %151 = load volatile i8, i8* @pending_signals, align 1
  %tobool350 = trunc i8 %151 to i1
  br i1 %tobool350, label %if.then.351, label %if.end.352

if.then.351:                                      ; preds = %if.else.349
  call void @process_pending_signals()
  br label %if.end.352

if.end.352:                                       ; preds = %if.then.351, %if.else.349
  br label %if.end.353

if.end.353:                                       ; preds = %if.end.352, %if.then.348
  br label %do.end.354

do.end.354:                                       ; preds = %if.end.353
  %152 = load i32, i32* %s, align 4
  %__sockaddr__356 = bitcast %union.__CONST_SOCKADDR_ARG* %agg.tmp355 to %struct.sockaddr**
  %153 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addr357 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %153, i32 0, i32 5
  %154 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr357, align 8
  store %struct.sockaddr* %154, %struct.sockaddr** %__sockaddr__356, align 8
  %155 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen358 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %155, i32 0, i32 4
  %156 = load i32, i32* %ai_addrlen358, align 4
  %coerce.dive359 = getelementptr %union.__CONST_SOCKADDR_ARG, %union.__CONST_SOCKADDR_ARG* %agg.tmp355, i32 0, i32 0
  %157 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive359, align 8
  %call360 = call i32 @connect(i32 %152, %struct.sockaddr* %157, i32 %156)
  store i32 %call360, i32* %ret, align 4
  %call361 = call i32* @__errno_location() #11
  %158 = load i32, i32* %call361, align 4
  store i32 %158, i32* %xerrno, align 4
  %159 = load i32, i32* %ret, align 4
  %cmp362 = icmp eq i32 %159, 0
  br i1 %cmp362, label %if.then.366, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end.354
  %160 = load i32, i32* %xerrno, align 4
  %cmp364 = icmp eq i32 %160, 106
  br i1 %cmp364, label %if.then.366, label %if.end.367

if.then.366:                                      ; preds = %lor.lhs.false, %do.end.354
  br label %for.end.423

if.end.367:                                       ; preds = %lor.lhs.false
  %161 = load i8, i8* %is_non_blocking_client, align 1
  %tobool368 = trunc i8 %161 to i1
  br i1 %tobool368, label %land.lhs.true.370, label %if.end.374

land.lhs.true.370:                                ; preds = %if.end.367
  %162 = load i32, i32* %xerrno, align 4
  %cmp371 = icmp eq i32 %162, 115
  br i1 %cmp371, label %if.then.373, label %if.end.374

if.then.373:                                      ; preds = %land.lhs.true.370
  br label %for.end.423

if.end.374:                                       ; preds = %land.lhs.true.370, %if.end.367
  %163 = load i32, i32* %xerrno, align 4
  %cmp375 = icmp eq i32 %163, 4
  br i1 %cmp375, label %if.then.377, label %if.end.419

if.then.377:                                      ; preds = %if.end.374
  br label %retry_select

retry_select:                                     ; preds = %if.then.405, %if.then.377
  br label %do.body.378

do.body.378:                                      ; preds = %retry_select
  %fds_bits = getelementptr inbounds %struct.fd_set, %struct.fd_set* %fdset, i32 0, i32 0
  %arrayidx379 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits, i32 0, i64 0
  %164 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx379) #5, !srcloc !1
  %asmresult = extractvalue { i64, i64* } %164, 0
  %asmresult380 = extractvalue { i64, i64* } %164, 1
  %165 = trunc i64 %asmresult to i32
  store i32 %165, i32* %__d0, align 4
  %166 = ptrtoint i64* %asmresult380 to i64
  %167 = trunc i64 %166 to i32
  store i32 %167, i32* %__d1, align 4
  br label %do.end.381

do.end.381:                                       ; preds = %do.body.378
  %168 = load i32, i32* %s, align 4
  call void @fd_SET(i32 %168, %struct.fd_set* %fdset)
  br label %do.body.382

do.body.382:                                      ; preds = %do.end.381
  %169 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call383 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp384 = icmp eq i64 %169, %call383
  br i1 %cmp384, label %if.else.391, label %land.lhs.true.386

land.lhs.true.386:                                ; preds = %do.body.382
  %170 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call387 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp388 = icmp eq i64 %170, %call387
  br i1 %cmp388, label %if.then.390, label %if.else.391

if.then.390:                                      ; preds = %land.lhs.true.386
  call void @process_quit_flag()
  br label %if.end.395

if.else.391:                                      ; preds = %land.lhs.true.386, %do.body.382
  %171 = load volatile i8, i8* @pending_signals, align 1
  %tobool392 = trunc i8 %171 to i1
  br i1 %tobool392, label %if.then.393, label %if.end.394

if.then.393:                                      ; preds = %if.else.391
  call void @process_pending_signals()
  br label %if.end.394

if.end.394:                                       ; preds = %if.then.393, %if.else.391
  br label %if.end.395

if.end.395:                                       ; preds = %if.end.394, %if.then.390
  br label %do.end.396

do.end.396:                                       ; preds = %if.end.395
  %172 = load i32, i32* %s, align 4
  %add397 = add nsw i32 %172, 1
  %call398 = call i32 @pselect(i32 %add397, %struct.fd_set* null, %struct.fd_set* %fdset, %struct.fd_set* null, %struct.timespec* null, %struct.__sigset_t* null)
  store i32 %call398, i32* %sc, align 4
  %173 = load i32, i32* %sc, align 4
  %cmp399 = icmp eq i32 %173, -1
  br i1 %cmp399, label %if.then.401, label %if.end.408

if.then.401:                                      ; preds = %do.end.396
  %call402 = call i32* @__errno_location() #11
  %174 = load i32, i32* %call402, align 4
  %cmp403 = icmp eq i32 %174, 4
  br i1 %cmp403, label %if.then.405, label %if.else.406

if.then.405:                                      ; preds = %if.then.401
  br label %retry_select

if.else.406:                                      ; preds = %if.then.401
  %call407 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.32, i32 0, i32 0), i64 %call407) #8
  unreachable

if.end.408:                                       ; preds = %do.end.396
  store i32 4, i32* %len, align 4
  %175 = load i32, i32* %s, align 4
  %176 = bitcast i32* %xerrno to i8*
  %call409 = call i32 @getsockopt(i32 %175, i32 1, i32 4, i8* %176, i32* %len) #5
  %cmp410 = icmp slt i32 %call409, 0
  br i1 %cmp410, label %if.then.412, label %if.end.414

if.then.412:                                      ; preds = %if.end.408
  %call413 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.33, i32 0, i32 0), i64 %call413) #8
  unreachable

if.end.414:                                       ; preds = %if.end.408
  %177 = load i32, i32* %xerrno, align 4
  %tobool415 = icmp ne i32 %177, 0
  br i1 %tobool415, label %if.then.416, label %if.end.418

if.then.416:                                      ; preds = %if.end.414
  %call417 = call i64 @builtin_lisp_symbol(i32 0)
  %178 = load i32, i32* %xerrno, align 4
  call void @report_file_errno(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.34, i32 0, i32 0), i64 %call417, i32 %178) #8
  unreachable

if.end.418:                                       ; preds = %if.end.414
  br label %for.end.423

if.end.419:                                       ; preds = %if.end.374
  store i8 0, i8* @immediate_quit, align 1
  %179 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %180 = load i64, i64* %count1, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %179, i64 %180
  store %union.specbinding* %add.ptr, %union.specbinding** @specpdl_ptr, align 8
  %181 = load i32, i32* %s, align 4
  %call420 = call i32 @emacs_close(i32 %181)
  store i32 -1, i32* %s, align 4
  br label %for.inc.421

for.inc.421:                                      ; preds = %if.end.419, %if.then.274, %if.then.260
  %182 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_next422 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %182, i32 0, i32 7
  %183 = load %struct.addrinfo*, %struct.addrinfo** %ai_next422, align 8
  store %struct.addrinfo* %183, %struct.addrinfo** %lres, align 8
  br label %for.cond

for.end.423:                                      ; preds = %if.end.418, %if.then.373, %if.then.366, %if.end.338, %if.then.267, %for.cond
  %184 = load i32, i32* %s, align 4
  %cmp424 = icmp sge i32 %184, 0
  br i1 %cmp424, label %if.then.426, label %if.end.504

if.then.426:                                      ; preds = %for.end.423
  %185 = load i32, i32* %socktype, align 4
  %cmp427 = icmp eq i32 %185, 2
  br i1 %cmp427, label %if.then.429, label %if.end.483

if.then.429:                                      ; preds = %if.then.426
  %186 = load i32, i32* %s, align 4
  %idxprom = sext i32 %186 to i64
  %arrayidx430 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx430, i32 0, i32 0
  %187 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %tobool431 = icmp ne %struct.sockaddr* %187, null
  br i1 %tobool431, label %if.then.432, label %if.end.433

if.then.432:                                      ; preds = %if.then.429
  call void @emacs_abort() #8
  unreachable

if.end.433:                                       ; preds = %if.then.429
  %188 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen434 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %188, i32 0, i32 4
  %189 = load i32, i32* %ai_addrlen434, align 4
  %conv435 = zext i32 %189 to i64
  %call436 = call noalias i8* @xmalloc(i64 %conv435)
  %190 = bitcast i8* %call436 to %struct.sockaddr*
  %191 = load i32, i32* %s, align 4
  %idxprom437 = sext i32 %191 to i64
  %arrayidx438 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom437
  %sa439 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx438, i32 0, i32 0
  store %struct.sockaddr* %190, %struct.sockaddr** %sa439, align 8
  %192 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen440 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %192, i32 0, i32 4
  %193 = load i32, i32* %ai_addrlen440, align 4
  %194 = load i32, i32* %s, align 4
  %idxprom441 = sext i32 %194 to i64
  %arrayidx442 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom441
  %len443 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx442, i32 0, i32 1
  store i32 %193, i32* %len443, align 4
  %195 = load i8, i8* %is_server, align 1
  %tobool444 = trunc i8 %195 to i1
  br i1 %tobool444, label %if.then.445, label %if.else.475

if.then.445:                                      ; preds = %if.end.433
  %196 = load i32, i32* %s, align 4
  %idxprom446 = sext i32 %196 to i64
  %arrayidx447 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom446
  %sa448 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx447, i32 0, i32 0
  %197 = load %struct.sockaddr*, %struct.sockaddr** %sa448, align 8
  %198 = bitcast %struct.sockaddr* %197 to i8*
  %199 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen449 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %199, i32 0, i32 4
  %200 = load i32, i32* %ai_addrlen449, align 4
  %conv450 = zext i32 %200 to i64
  call void @llvm.memset.p0i8.i64(i8* %198, i8 0, i64 %conv450, i32 2, i1 false)
  %201 = load i64, i64* %contact, align 8
  %call451 = call i64 @builtin_lisp_symbol(i32 108)
  %call452 = call i64 @Fplist_get(i64 %201, i64 %call451)
  store i64 %call452, i64* %remote, align 8
  %202 = load i64, i64* %remote, align 8
  %call453 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp454 = icmp eq i64 %202, %call453
  %lnot456 = xor i1 %cmp454, true
  br i1 %lnot456, label %if.then.457, label %if.end.474

if.then.457:                                      ; preds = %if.then.445
  %203 = load i64, i64* %remote, align 8
  %call458 = call i32 @get_lisp_to_sockaddr_size(i64 %203, i32* %rfamily)
  store i32 %call458, i32* %rlen, align 4
  %204 = load i32, i32* %rlen, align 4
  %cmp459 = icmp ne i32 %204, 0
  br i1 %cmp459, label %land.lhs.true.461, label %if.end.473

land.lhs.true.461:                                ; preds = %if.then.457
  %205 = load i32, i32* %rfamily, align 4
  %206 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_family462 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %206, i32 0, i32 1
  %207 = load i32, i32* %ai_family462, align 4
  %cmp463 = icmp eq i32 %205, %207
  br i1 %cmp463, label %land.lhs.true.465, label %if.end.473

land.lhs.true.465:                                ; preds = %land.lhs.true.461
  %208 = load i32, i32* %rlen, align 4
  %209 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen466 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %209, i32 0, i32 4
  %210 = load i32, i32* %ai_addrlen466, align 4
  %cmp467 = icmp eq i32 %208, %210
  br i1 %cmp467, label %if.then.469, label %if.end.473

if.then.469:                                      ; preds = %land.lhs.true.465
  %211 = load i32, i32* %rfamily, align 4
  %212 = load i64, i64* %remote, align 8
  %213 = load i32, i32* %s, align 4
  %idxprom470 = sext i32 %213 to i64
  %arrayidx471 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom470
  %sa472 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx471, i32 0, i32 0
  %214 = load %struct.sockaddr*, %struct.sockaddr** %sa472, align 8
  %215 = load i32, i32* %rlen, align 4
  call void @conv_lisp_to_sockaddr(i32 %211, i64 %212, %struct.sockaddr* %214, i32 %215)
  br label %if.end.473

if.end.473:                                       ; preds = %if.then.469, %land.lhs.true.465, %land.lhs.true.461, %if.then.457
  br label %if.end.474

if.end.474:                                       ; preds = %if.end.473, %if.then.445
  br label %if.end.482

if.else.475:                                      ; preds = %if.end.433
  %216 = load i32, i32* %s, align 4
  %idxprom476 = sext i32 %216 to i64
  %arrayidx477 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom476
  %sa478 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx477, i32 0, i32 0
  %217 = load %struct.sockaddr*, %struct.sockaddr** %sa478, align 8
  %218 = bitcast %struct.sockaddr* %217 to i8*
  %219 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addr479 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %219, i32 0, i32 5
  %220 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr479, align 8
  %221 = bitcast %struct.sockaddr* %220 to i8*
  %222 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen480 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %222, i32 0, i32 4
  %223 = load i32, i32* %ai_addrlen480, align 4
  %conv481 = zext i32 %223 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %218, i8* %221, i64 %conv481, i32 2, i1 false)
  br label %if.end.482

if.end.482:                                       ; preds = %if.else.475, %if.end.474
  br label %if.end.483

if.end.483:                                       ; preds = %if.end.482, %if.then.426
  %224 = load i64, i64* %contact, align 8
  %225 = load i64, i64* %colon_address, align 8
  %226 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addr484 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %226, i32 0, i32 5
  %227 = load %struct.sockaddr*, %struct.sockaddr** %ai_addr484, align 8
  %228 = load %struct.addrinfo*, %struct.addrinfo** %lres, align 8
  %ai_addrlen485 = getelementptr inbounds %struct.addrinfo, %struct.addrinfo* %228, i32 0, i32 4
  %229 = load i32, i32* %ai_addrlen485, align 4
  %call486 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %227, i32 %229)
  %call487 = call i64 @Fplist_put(i64 %224, i64 %225, i64 %call486)
  store i64 %call487, i64* %contact, align 8
  %230 = load i8, i8* %is_server, align 1
  %tobool488 = trunc i8 %230 to i1
  br i1 %tobool488, label %if.end.503, label %if.then.489

if.then.489:                                      ; preds = %if.end.483
  store i32 16, i32* %len1491, align 4
  %231 = load i32, i32* %s, align 4
  %__sockaddr__493 = bitcast %union.__SOCKADDR_ARG* %agg.tmp492 to %struct.sockaddr**
  %232 = bitcast %struct.sockaddr_in* %sa1490 to %struct.sockaddr*
  store %struct.sockaddr* %232, %struct.sockaddr** %__sockaddr__493, align 8
  %coerce.dive494 = getelementptr %union.__SOCKADDR_ARG, %union.__SOCKADDR_ARG* %agg.tmp492, i32 0, i32 0
  %233 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive494, align 8
  %call495 = call i32 @getsockname(i32 %231, %struct.sockaddr* %233, i32* %len1491) #5
  %cmp496 = icmp eq i32 %call495, 0
  br i1 %cmp496, label %if.then.498, label %if.end.502

if.then.498:                                      ; preds = %if.then.489
  %234 = load i64, i64* %contact, align 8
  %call499 = call i64 @builtin_lisp_symbol(i32 77)
  %235 = bitcast %struct.sockaddr_in* %sa1490 to %struct.sockaddr*
  %236 = load i32, i32* %len1491, align 4
  %call500 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %235, i32 %236)
  %call501 = call i64 @Fplist_put(i64 %234, i64 %call499, i64 %call500)
  store i64 %call501, i64* %contact, align 8
  br label %if.end.502

if.end.502:                                       ; preds = %if.then.498, %if.then.489
  br label %if.end.503

if.end.503:                                       ; preds = %if.end.502, %if.end.483
  br label %if.end.504

if.end.504:                                       ; preds = %if.end.503, %for.end.423
  store i8 0, i8* @immediate_quit, align 1
  %237 = load %struct.addrinfo*, %struct.addrinfo** %res, align 8
  %cmp505 = icmp ne %struct.addrinfo* %237, %ai
  br i1 %cmp505, label %if.then.507, label %if.end.508

if.then.507:                                      ; preds = %if.end.504
  call void @block_input()
  %238 = load %struct.addrinfo*, %struct.addrinfo** %res, align 8
  call void @freeaddrinfo(%struct.addrinfo* %238) #5
  call void @unblock_input()
  br label %if.end.508

if.end.508:                                       ; preds = %if.then.507, %if.end.504
  %239 = load i32, i32* %s, align 4
  %cmp509 = icmp slt i32 %239, 0
  br i1 %cmp509, label %if.then.511, label %if.end.519

if.then.511:                                      ; preds = %if.end.508
  %240 = load i8, i8* %is_non_blocking_client, align 1
  %tobool512 = trunc i8 %240 to i1
  br i1 %tobool512, label %if.then.513, label %if.end.515

if.then.513:                                      ; preds = %if.then.511
  %call514 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call514, i64* %retval
  br label %return

if.end.515:                                       ; preds = %if.then.511
  %241 = load i8, i8* %is_server, align 1
  %tobool516 = trunc i8 %241 to i1
  %cond518 = select i1 %tobool516, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.35, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.36, i32 0, i32 0)
  %242 = load i64, i64* %contact, align 8
  %243 = load i32, i32* %xerrno, align 4
  call void @report_file_errno(i8* %cond518, i64 %242, i32 %243) #8
  unreachable

if.end.519:                                       ; preds = %if.end.508
  %244 = load i32, i32* %s, align 4
  store i32 %244, i32* %inch, align 4
  %245 = load i32, i32* %s, align 4
  store i32 %245, i32* %outch, align 4
  %246 = load i64, i64* %buffer, align 8
  %call520 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp521 = icmp eq i64 %246, %call520
  br i1 %cmp521, label %if.end.525, label %if.then.523

if.then.523:                                      ; preds = %if.end.519
  %247 = load i64, i64* %buffer, align 8
  %call524 = call i64 @Fget_buffer_create(i64 %247)
  store i64 %call524, i64* %buffer, align 8
  br label %if.end.525

if.end.525:                                       ; preds = %if.then.523, %if.end.519
  %248 = load i64, i64* %name, align 8
  %call526 = call i64 @make_process(i64 %248)
  store i64 %call526, i64* %proc, align 8
  %249 = load i64, i64* %proc, align 8
  %250 = load i32, i32* %inch, align 4
  %idxprom527 = sext i32 %250 to i64
  %arrayidx528 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom527
  store i64 %249, i64* %arrayidx528, align 8
  %251 = load i32, i32* %inch, align 4
  %call529 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %251, i32 4, i32 2048)
  %252 = load i64, i64* %proc, align 8
  %call530 = call %struct.Lisp_Process* @XPROCESS(i64 %252)
  store %struct.Lisp_Process* %call530, %struct.Lisp_Process** %p, align 8
  %253 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %254 = load i64, i64* %contact, align 8
  call void @pset_childp(%struct.Lisp_Process* %253, i64 %254)
  %255 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %256 = load i64, i64* %contact, align 8
  %call531 = call i64 @builtin_lisp_symbol(i32 92)
  %call532 = call i64 @Fplist_get(i64 %256, i64 %call531)
  %call533 = call i64 @Fcopy_sequence(i64 %call532)
  call void @pset_plist(%struct.Lisp_Process* %255, i64 %call533)
  %257 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call534 = call i64 @builtin_lisp_symbol(i32 699)
  call void @pset_type(%struct.Lisp_Process* %257, i64 %call534)
  %258 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %259 = load i64, i64* %buffer, align 8
  call void @pset_buffer(%struct.Lisp_Process* %258, i64 %259)
  %260 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %261 = load i64, i64* %sentinel, align 8
  call void @pset_sentinel(%struct.Lisp_Process* %260, i64 %261)
  %262 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %263 = load i64, i64* %filter, align 8
  call void @pset_filter(%struct.Lisp_Process* %262, i64 %263)
  %264 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %265 = load i64, i64* %contact, align 8
  %call535 = call i64 @builtin_lisp_symbol(i32 78)
  %call536 = call i64 @Fplist_get(i64 %265, i64 %call535)
  call void @pset_log(%struct.Lisp_Process* %264, i64 %call536)
  %266 = load i64, i64* %contact, align 8
  %call537 = call i64 @builtin_lisp_symbol(i32 87)
  %call538 = call i64 @Fplist_get(i64 %266, i64 %call537)
  store i64 %call538, i64* %tem, align 8
  %267 = load i64, i64* %tem, align 8
  %call539 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp540 = icmp eq i64 %267, %call539
  %lnot542 = xor i1 %cmp540, true
  br i1 %lnot542, label %if.then.543, label %if.end.544

if.then.543:                                      ; preds = %if.end.525
  %268 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %kill_without_query = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %268, i32 0, i32 28
  %bf.load = load i8, i8* %kill_without_query, align 8
  %bf.clear = and i8 %bf.load, -9
  %bf.set = or i8 %bf.clear, 8
  store i8 %bf.set, i8* %kill_without_query, align 8
  br label %if.end.544

if.end.544:                                       ; preds = %if.then.543, %if.end.525
  %269 = load i64, i64* %contact, align 8
  %call545 = call i64 @builtin_lisp_symbol(i32 124)
  %call546 = call i64 @Fplist_get(i64 %269, i64 %call545)
  store i64 %call546, i64* %tem, align 8
  %270 = load i64, i64* %tem, align 8
  %call547 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp548 = icmp eq i64 %270, %call547
  %lnot550 = xor i1 %cmp548, true
  br i1 %lnot550, label %if.then.551, label %if.end.553

if.then.551:                                      ; preds = %if.end.544
  %271 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call552 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_command(%struct.Lisp_Process* %271, i64 %call552)
  br label %if.end.553

if.end.553:                                       ; preds = %if.then.551, %if.end.544
  %272 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %272, i32 0, i32 20
  store i32 0, i32* %pid, align 4
  %273 = load i32, i32* %inch, align 4
  %274 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %274, i32 0, i32 23
  %arrayidx554 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 0
  store i32 %273, i32* %arrayidx554, align 4
  %275 = load i32, i32* %inch, align 4
  %276 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %276, i32 0, i32 21
  store i32 %275, i32* %infd, align 4
  %277 = load i32, i32* %outch, align 4
  %278 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %278, i32 0, i32 22
  store i32 %277, i32* %outfd, align 4
  %279 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %280 = load i64, i64* %count1, align 8
  %add.ptr555 = getelementptr inbounds %union.specbinding, %union.specbinding* %279, i64 %280
  store %union.specbinding* %add.ptr555, %union.specbinding** @specpdl_ptr, align 8
  %281 = load i64, i64* %count, align 8
  %call556 = call i64 @builtin_lisp_symbol(i32 0)
  %call557 = call i64 @unbind_to(i64 %281, i64 %call556)
  %282 = load i8, i8* %is_server, align 1
  %tobool558 = trunc i8 %282 to i1
  br i1 %tobool558, label %land.lhs.true.560, label %if.end.565

land.lhs.true.560:                                ; preds = %if.end.553
  %283 = load i32, i32* %socktype, align 4
  %cmp561 = icmp ne i32 %283, 2
  br i1 %cmp561, label %if.then.563, label %if.end.565

if.then.563:                                      ; preds = %land.lhs.true.560
  %284 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call564 = call i64 @builtin_lisp_symbol(i32 625)
  call void @pset_status(%struct.Lisp_Process* %284, i64 %call564)
  br label %if.end.565

if.end.565:                                       ; preds = %if.then.563, %land.lhs.true.560, %if.end.553
  %285 = load i64, i64* %buffer, align 8
  %call566 = call zeroext i1 @BUFFERP(i64 %285)
  br i1 %call566, label %if.then.567, label %if.end.610

if.then.567:                                      ; preds = %if.end.565
  %286 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %286, i32 0, i32 11
  %287 = load i64, i64* %mark, align 8
  %288 = load i64, i64* %buffer, align 8
  %289 = load i64, i64* %buffer, align 8
  %call568 = call %struct.buffer* @XBUFFER(i64 %289)
  %290 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp569 = icmp eq %struct.buffer* %call568, %290
  br i1 %cmp569, label %cond.true.571, label %cond.false.572

cond.true.571:                                    ; preds = %if.then.567
  %291 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %291, i32 0, i32 79
  %292 = load i64, i64* %zv, align 8
  br label %cond.end.586

cond.false.572:                                   ; preds = %if.then.567
  %293 = load i64, i64* %buffer, align 8
  %call573 = call %struct.buffer* @XBUFFER(i64 %293)
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call573, i32 0, i32 47
  %294 = load i64, i64* %zv_marker_, align 8
  %call574 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp575 = icmp eq i64 %294, %call574
  br i1 %cmp575, label %cond.true.577, label %cond.false.580

cond.true.577:                                    ; preds = %cond.false.572
  %295 = load i64, i64* %buffer, align 8
  %call578 = call %struct.buffer* @XBUFFER(i64 %295)
  %zv579 = getelementptr inbounds %struct.buffer, %struct.buffer* %call578, i32 0, i32 79
  %296 = load i64, i64* %zv579, align 8
  br label %cond.end.584

cond.false.580:                                   ; preds = %cond.false.572
  %297 = load i64, i64* %buffer, align 8
  %call581 = call %struct.buffer* @XBUFFER(i64 %297)
  %zv_marker_582 = getelementptr inbounds %struct.buffer, %struct.buffer* %call581, i32 0, i32 47
  %298 = load i64, i64* %zv_marker_582, align 8
  %call583 = call i64 @marker_position(i64 %298)
  br label %cond.end.584

cond.end.584:                                     ; preds = %cond.false.580, %cond.true.577
  %cond585 = phi i64 [ %296, %cond.true.577 ], [ %call583, %cond.false.580 ]
  br label %cond.end.586

cond.end.586:                                     ; preds = %cond.end.584, %cond.true.571
  %cond587 = phi i64 [ %292, %cond.true.571 ], [ %cond585, %cond.end.584 ]
  %299 = load i64, i64* %buffer, align 8
  %call588 = call %struct.buffer* @XBUFFER(i64 %299)
  %300 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp589 = icmp eq %struct.buffer* %call588, %300
  br i1 %cmp589, label %cond.true.591, label %cond.false.592

cond.true.591:                                    ; preds = %cond.end.586
  %301 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %301, i32 0, i32 80
  %302 = load i64, i64* %zv_byte, align 8
  br label %cond.end.607

cond.false.592:                                   ; preds = %cond.end.586
  %303 = load i64, i64* %buffer, align 8
  %call593 = call %struct.buffer* @XBUFFER(i64 %303)
  %zv_marker_594 = getelementptr inbounds %struct.buffer, %struct.buffer* %call593, i32 0, i32 47
  %304 = load i64, i64* %zv_marker_594, align 8
  %call595 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp596 = icmp eq i64 %304, %call595
  br i1 %cmp596, label %cond.true.598, label %cond.false.601

cond.true.598:                                    ; preds = %cond.false.592
  %305 = load i64, i64* %buffer, align 8
  %call599 = call %struct.buffer* @XBUFFER(i64 %305)
  %zv_byte600 = getelementptr inbounds %struct.buffer, %struct.buffer* %call599, i32 0, i32 80
  %306 = load i64, i64* %zv_byte600, align 8
  br label %cond.end.605

cond.false.601:                                   ; preds = %cond.false.592
  %307 = load i64, i64* %buffer, align 8
  %call602 = call %struct.buffer* @XBUFFER(i64 %307)
  %zv_marker_603 = getelementptr inbounds %struct.buffer, %struct.buffer* %call602, i32 0, i32 47
  %308 = load i64, i64* %zv_marker_603, align 8
  %call604 = call i64 @marker_byte_position(i64 %308)
  br label %cond.end.605

cond.end.605:                                     ; preds = %cond.false.601, %cond.true.598
  %cond606 = phi i64 [ %306, %cond.true.598 ], [ %call604, %cond.false.601 ]
  br label %cond.end.607

cond.end.607:                                     ; preds = %cond.end.605, %cond.true.591
  %cond608 = phi i64 [ %302, %cond.true.591 ], [ %cond606, %cond.end.605 ]
  %call609 = call i64 @set_marker_both(i64 %287, i64 %288, i64 %cond587, i64 %cond608)
  br label %if.end.610

if.end.610:                                       ; preds = %cond.end.607, %if.end.565
  %309 = load i8, i8* %is_non_blocking_client, align 1
  %tobool611 = trunc i8 %309 to i1
  br i1 %tobool611, label %if.then.612, label %if.else.617

if.then.612:                                      ; preds = %if.end.610
  %310 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call613 = call i64 @builtin_lisp_symbol(i32 293)
  call void @pset_status(%struct.Lisp_Process* %310, i64 %call613)
  %311 = load i32, i32* %inch, align 4
  %call614 = call zeroext i1 @fd_ISSET(i32 %311, %struct.fd_set* @connect_wait_mask)
  br i1 %call614, label %if.end.616, label %if.then.615

if.then.615:                                      ; preds = %if.then.612
  %312 = load i32, i32* %inch, align 4
  call void @fd_SET(i32 %312, %struct.fd_set* @connect_wait_mask)
  %313 = load i32, i32* %inch, align 4
  call void @fd_SET(i32 %313, %struct.fd_set* @write_mask)
  %314 = load i32, i32* @num_pending_connects, align 4
  %inc = add nsw i32 %314, 1
  store i32 %inc, i32* @num_pending_connects, align 4
  br label %if.end.616

if.end.616:                                       ; preds = %if.then.615, %if.then.612
  br label %if.end.637

if.else.617:                                      ; preds = %if.end.610
  %315 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter618 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %315, i32 0, i32 4
  %316 = load i64, i64* %filter618, align 8
  %call619 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp620 = icmp eq i64 %316, %call619
  br i1 %cmp620, label %lor.lhs.false.626, label %land.lhs.true.622

land.lhs.true.622:                                ; preds = %if.else.617
  %317 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %317, i32 0, i32 3
  %318 = load i64, i64* %command, align 8
  %call623 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp624 = icmp eq i64 %318, %call623
  br i1 %cmp624, label %lor.lhs.false.626, label %if.then.635

lor.lhs.false.626:                                ; preds = %land.lhs.true.622, %if.else.617
  %319 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %319, i32 0, i32 12
  %320 = load i64, i64* %status, align 8
  %call627 = call i64 @builtin_lisp_symbol(i32 625)
  %cmp628 = icmp eq i64 %320, %call627
  br i1 %cmp628, label %land.lhs.true.630, label %if.end.636

land.lhs.true.630:                                ; preds = %lor.lhs.false.626
  %321 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command631 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %321, i32 0, i32 3
  %322 = load i64, i64* %command631, align 8
  %call632 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp633 = icmp eq i64 %322, %call632
  br i1 %cmp633, label %if.then.635, label %if.end.636

if.then.635:                                      ; preds = %land.lhs.true.630, %land.lhs.true.622
  %323 = load i32, i32* %inch, align 4
  call void @fd_SET(i32 %323, %struct.fd_set* @input_wait_mask)
  %324 = load i32, i32* %inch, align 4
  call void @fd_SET(i32 %324, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.636

if.end.636:                                       ; preds = %if.then.635, %land.lhs.true.630, %lor.lhs.false.626
  br label %if.end.637

if.end.637:                                       ; preds = %if.end.636, %if.end.616
  %325 = load i32, i32* %inch, align 4
  %326 = load i32, i32* @max_process_desc, align 4
  %cmp638 = icmp sgt i32 %325, %326
  br i1 %cmp638, label %if.then.640, label %if.end.641

if.then.640:                                      ; preds = %if.end.637
  %327 = load i32, i32* %inch, align 4
  store i32 %327, i32* @max_process_desc, align 4
  br label %if.end.641

if.end.641:                                       ; preds = %if.then.640, %if.end.637
  %328 = load i64, i64* %contact, align 8
  %call642 = call i64 @builtin_lisp_symbol(i32 20)
  %call643 = call i64 @Fplist_member(i64 %328, i64 %call642)
  store i64 %call643, i64* %tem, align 8
  %329 = load i64, i64* %tem, align 8
  %call644 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp645 = icmp eq i64 %329, %call644
  br i1 %cmp645, label %if.end.660, label %land.lhs.true.647

land.lhs.true.647:                                ; preds = %if.end.641
  %330 = load i64, i64* %tem, align 8
  %and648 = and i64 %330, 7
  %conv649 = trunc i64 %and648 to i32
  %cmp650 = icmp eq i32 %conv649, 3
  br i1 %cmp650, label %lor.lhs.false.652, label %if.then.658

lor.lhs.false.652:                                ; preds = %land.lhs.true.647
  %331 = load i64, i64* %tem, align 8
  %sub653 = sub nsw i64 %331, 3
  %332 = inttoptr i64 %sub653 to i8*
  %333 = bitcast i8* %332 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %333, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %334 = load i64, i64* %cdr, align 8
  %and654 = and i64 %334, 7
  %conv655 = trunc i64 %and654 to i32
  %cmp656 = icmp eq i32 %conv655, 3
  br i1 %cmp656, label %if.end.660, label %if.then.658

if.then.658:                                      ; preds = %lor.lhs.false.652, %land.lhs.true.647
  %call659 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call659, i64* %tem, align 8
  br label %if.end.660

if.end.660:                                       ; preds = %if.then.658, %lor.lhs.false.652, %if.end.641
  %call661 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call661, i64* %coding_systems, align 8
  %335 = load i64, i64* %tem, align 8
  %call662 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp663 = icmp eq i64 %335, %call662
  br i1 %cmp663, label %if.else.678, label %if.then.665

if.then.665:                                      ; preds = %if.end.660
  %336 = load i64, i64* %tem, align 8
  %sub666 = sub nsw i64 %336, 3
  %337 = inttoptr i64 %sub666 to i8*
  %338 = bitcast i8* %337 to %struct.Lisp_Cons*
  %u667 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %338, i32 0, i32 1
  %cdr668 = bitcast %union.anon* %u667 to i64*
  %339 = load i64, i64* %cdr668, align 8
  %sub669 = sub nsw i64 %339, 3
  %340 = inttoptr i64 %sub669 to i8*
  %341 = bitcast i8* %340 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %341, i32 0, i32 0
  %342 = load i64, i64* %car, align 8
  store i64 %342, i64* %val, align 8
  %343 = load i64, i64* %val, align 8
  %and670 = and i64 %343, 7
  %conv671 = trunc i64 %and670 to i32
  %cmp672 = icmp eq i32 %conv671, 3
  br i1 %cmp672, label %if.then.674, label %if.end.677

if.then.674:                                      ; preds = %if.then.665
  %344 = load i64, i64* %val, align 8
  %sub675 = sub nsw i64 %344, 3
  %345 = inttoptr i64 %sub675 to i8*
  %346 = bitcast i8* %345 to %struct.Lisp_Cons*
  %car676 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %346, i32 0, i32 0
  %347 = load i64, i64* %car676, align 8
  store i64 %347, i64* %val, align 8
  br label %if.end.677

if.end.677:                                       ; preds = %if.then.674, %if.then.665
  br label %if.end.741

if.else.678:                                      ; preds = %if.end.660
  %348 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  %call679 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp680 = icmp eq i64 %348, %call679
  br i1 %cmp680, label %if.else.683, label %if.then.682

if.then.682:                                      ; preds = %if.else.678
  %349 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 35), align 8
  store i64 %349, i64* %val, align 8
  br label %if.end.740

if.else.683:                                      ; preds = %if.else.678
  %350 = load i64, i64* %buffer, align 8
  %call684 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp685 = icmp eq i64 %350, %call684
  br i1 %cmp685, label %lor.lhs.false.692, label %land.lhs.true.687

land.lhs.true.687:                                ; preds = %if.else.683
  %351 = load i64, i64* %buffer, align 8
  %call688 = call %struct.buffer* @XBUFFER(i64 %351)
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call688, i32 0, i32 39
  %352 = load i64, i64* %enable_multibyte_characters_, align 8
  %call689 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp690 = icmp eq i64 %352, %call689
  br i1 %cmp690, label %if.then.700, label %lor.lhs.false.692

lor.lhs.false.692:                                ; preds = %land.lhs.true.687, %if.else.683
  %353 = load i64, i64* %buffer, align 8
  %call693 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp694 = icmp eq i64 %353, %call693
  br i1 %cmp694, label %land.lhs.true.696, label %if.else.702

land.lhs.true.696:                                ; preds = %lor.lhs.false.692
  %354 = load i64, i64* getelementptr inbounds (%struct.buffer, %struct.buffer* @buffer_defaults, i32 0, i32 39), align 8
  %call697 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp698 = icmp eq i64 %354, %call697
  br i1 %cmp698, label %if.then.700, label %if.else.702

if.then.700:                                      ; preds = %land.lhs.true.696, %land.lhs.true.687
  %call701 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call701, i64* %val, align 8
  br label %if.end.739

if.else.702:                                      ; preds = %land.lhs.true.696, %lor.lhs.false.692
  %355 = load i64, i64* %host, align 8
  %call703 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp704 = icmp eq i64 %355, %call703
  br i1 %cmp704, label %if.then.710, label %lor.lhs.false.706

lor.lhs.false.706:                                ; preds = %if.else.702
  %356 = load i64, i64* %service, align 8
  %call707 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp708 = icmp eq i64 %356, %call707
  br i1 %cmp708, label %if.then.710, label %if.else.712

if.then.710:                                      ; preds = %lor.lhs.false.706, %if.else.702
  %call711 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call711, i64* %coding_systems, align 8
  br label %if.end.719

if.else.712:                                      ; preds = %lor.lhs.false.706
  %arrayinit.begin = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral, i64 0, i64 0
  %call713 = call i64 @builtin_lisp_symbol(i32 720)
  store i64 %call713, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %357 = load i64, i64* %name, align 8
  store i64 %357, i64* %arrayinit.element
  %arrayinit.element714 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %358 = load i64, i64* %buffer, align 8
  store i64 %358, i64* %arrayinit.element714
  %arrayinit.element715 = getelementptr inbounds i64, i64* %arrayinit.element714, i64 1
  %359 = load i64, i64* %host, align 8
  store i64 %359, i64* %arrayinit.element715
  %arrayinit.element716 = getelementptr inbounds i64, i64* %arrayinit.element715, i64 1
  %360 = load i64, i64* %service, align 8
  store i64 %360, i64* %arrayinit.element716
  %arraydecay717 = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral, i32 0, i32 0
  %call718 = call i64 @Ffind_operation_coding_system(i64 5, i64* %arraydecay717)
  store i64 %call718, i64* %coding_systems, align 8
  br label %if.end.719

if.end.719:                                       ; preds = %if.else.712, %if.then.710
  %361 = load i64, i64* %coding_systems, align 8
  %and720 = and i64 %361, 7
  %conv721 = trunc i64 %and720 to i32
  %cmp722 = icmp eq i32 %conv721, 3
  br i1 %cmp722, label %if.then.724, label %if.else.727

if.then.724:                                      ; preds = %if.end.719
  %362 = load i64, i64* %coding_systems, align 8
  %sub725 = sub nsw i64 %362, 3
  %363 = inttoptr i64 %sub725 to i8*
  %364 = bitcast i8* %363 to %struct.Lisp_Cons*
  %car726 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %364, i32 0, i32 0
  %365 = load i64, i64* %car726, align 8
  store i64 %365, i64* %val, align 8
  br label %if.end.738

if.else.727:                                      ; preds = %if.end.719
  %366 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and728 = and i64 %366, 7
  %conv729 = trunc i64 %and728 to i32
  %cmp730 = icmp eq i32 %conv729, 3
  br i1 %cmp730, label %if.then.732, label %if.else.735

if.then.732:                                      ; preds = %if.else.727
  %367 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub733 = sub nsw i64 %367, 3
  %368 = inttoptr i64 %sub733 to i8*
  %369 = bitcast i8* %368 to %struct.Lisp_Cons*
  %car734 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %369, i32 0, i32 0
  %370 = load i64, i64* %car734, align 8
  store i64 %370, i64* %val, align 8
  br label %if.end.737

if.else.735:                                      ; preds = %if.else.727
  %call736 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call736, i64* %val, align 8
  br label %if.end.737

if.end.737:                                       ; preds = %if.else.735, %if.then.732
  br label %if.end.738

if.end.738:                                       ; preds = %if.end.737, %if.then.724
  br label %if.end.739

if.end.739:                                       ; preds = %if.end.738, %if.then.700
  br label %if.end.740

if.end.740:                                       ; preds = %if.end.739, %if.then.682
  br label %if.end.741

if.end.741:                                       ; preds = %if.end.740, %if.end.677
  %371 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %372 = load i64, i64* %val, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %371, i64 %372)
  %373 = load i64, i64* %tem, align 8
  %call742 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp743 = icmp eq i64 %373, %call742
  br i1 %cmp743, label %if.else.760, label %if.then.745

if.then.745:                                      ; preds = %if.end.741
  %374 = load i64, i64* %tem, align 8
  %sub746 = sub nsw i64 %374, 3
  %375 = inttoptr i64 %sub746 to i8*
  %376 = bitcast i8* %375 to %struct.Lisp_Cons*
  %u747 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %376, i32 0, i32 1
  %cdr748 = bitcast %union.anon* %u747 to i64*
  %377 = load i64, i64* %cdr748, align 8
  %sub749 = sub nsw i64 %377, 3
  %378 = inttoptr i64 %sub749 to i8*
  %379 = bitcast i8* %378 to %struct.Lisp_Cons*
  %car750 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %379, i32 0, i32 0
  %380 = load i64, i64* %car750, align 8
  store i64 %380, i64* %val, align 8
  %381 = load i64, i64* %val, align 8
  %and751 = and i64 %381, 7
  %conv752 = trunc i64 %and751 to i32
  %cmp753 = icmp eq i32 %conv752, 3
  br i1 %cmp753, label %if.then.755, label %if.end.759

if.then.755:                                      ; preds = %if.then.745
  %382 = load i64, i64* %val, align 8
  %sub756 = sub nsw i64 %382, 3
  %383 = inttoptr i64 %sub756 to i8*
  %384 = bitcast i8* %383 to %struct.Lisp_Cons*
  %u757 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %384, i32 0, i32 1
  %cdr758 = bitcast %union.anon* %u757 to i64*
  %385 = load i64, i64* %cdr758, align 8
  store i64 %385, i64* %val, align 8
  br label %if.end.759

if.end.759:                                       ; preds = %if.then.755, %if.then.745
  br label %if.end.821

if.else.760:                                      ; preds = %if.end.741
  %386 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  %call761 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp762 = icmp eq i64 %386, %call761
  br i1 %cmp762, label %if.else.765, label %if.then.764

if.then.764:                                      ; preds = %if.else.760
  %387 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  store i64 %387, i64* %val, align 8
  br label %if.end.820

if.else.765:                                      ; preds = %if.else.760
  %388 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_766 = getelementptr inbounds %struct.buffer, %struct.buffer* %388, i32 0, i32 39
  %389 = load i64, i64* %enable_multibyte_characters_766, align 8
  %call767 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp768 = icmp eq i64 %389, %call767
  br i1 %cmp768, label %if.then.770, label %if.else.772

if.then.770:                                      ; preds = %if.else.765
  %call771 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call771, i64* %val, align 8
  br label %if.end.819

if.else.772:                                      ; preds = %if.else.765
  %390 = load i64, i64* %coding_systems, align 8
  %call773 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp774 = icmp eq i64 %390, %call773
  br i1 %cmp774, label %if.then.776, label %if.end.797

if.then.776:                                      ; preds = %if.else.772
  %391 = load i64, i64* %host, align 8
  %call777 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp778 = icmp eq i64 %391, %call777
  br i1 %cmp778, label %if.then.784, label %lor.lhs.false.780

lor.lhs.false.780:                                ; preds = %if.then.776
  %392 = load i64, i64* %service, align 8
  %call781 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp782 = icmp eq i64 %392, %call781
  br i1 %cmp782, label %if.then.784, label %if.else.786

if.then.784:                                      ; preds = %lor.lhs.false.780, %if.then.776
  %call785 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call785, i64* %coding_systems, align 8
  br label %if.end.796

if.else.786:                                      ; preds = %lor.lhs.false.780
  %arrayinit.begin788 = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral787, i64 0, i64 0
  %call789 = call i64 @builtin_lisp_symbol(i32 720)
  store i64 %call789, i64* %arrayinit.begin788
  %arrayinit.element790 = getelementptr inbounds i64, i64* %arrayinit.begin788, i64 1
  %393 = load i64, i64* %name, align 8
  store i64 %393, i64* %arrayinit.element790
  %arrayinit.element791 = getelementptr inbounds i64, i64* %arrayinit.element790, i64 1
  %394 = load i64, i64* %buffer, align 8
  store i64 %394, i64* %arrayinit.element791
  %arrayinit.element792 = getelementptr inbounds i64, i64* %arrayinit.element791, i64 1
  %395 = load i64, i64* %host, align 8
  store i64 %395, i64* %arrayinit.element792
  %arrayinit.element793 = getelementptr inbounds i64, i64* %arrayinit.element792, i64 1
  %396 = load i64, i64* %service, align 8
  store i64 %396, i64* %arrayinit.element793
  %arraydecay794 = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral787, i32 0, i32 0
  %call795 = call i64 @Ffind_operation_coding_system(i64 5, i64* %arraydecay794)
  store i64 %call795, i64* %coding_systems, align 8
  br label %if.end.796

if.end.796:                                       ; preds = %if.else.786, %if.then.784
  br label %if.end.797

if.end.797:                                       ; preds = %if.end.796, %if.else.772
  %397 = load i64, i64* %coding_systems, align 8
  %and798 = and i64 %397, 7
  %conv799 = trunc i64 %and798 to i32
  %cmp800 = icmp eq i32 %conv799, 3
  br i1 %cmp800, label %if.then.802, label %if.else.806

if.then.802:                                      ; preds = %if.end.797
  %398 = load i64, i64* %coding_systems, align 8
  %sub803 = sub nsw i64 %398, 3
  %399 = inttoptr i64 %sub803 to i8*
  %400 = bitcast i8* %399 to %struct.Lisp_Cons*
  %u804 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %400, i32 0, i32 1
  %cdr805 = bitcast %union.anon* %u804 to i64*
  %401 = load i64, i64* %cdr805, align 8
  store i64 %401, i64* %val, align 8
  br label %if.end.818

if.else.806:                                      ; preds = %if.end.797
  %402 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %and807 = and i64 %402, 7
  %conv808 = trunc i64 %and807 to i32
  %cmp809 = icmp eq i32 %conv808, 3
  br i1 %cmp809, label %if.then.811, label %if.else.815

if.then.811:                                      ; preds = %if.else.806
  %403 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 62), align 8
  %sub812 = sub nsw i64 %403, 3
  %404 = inttoptr i64 %sub812 to i8*
  %405 = bitcast i8* %404 to %struct.Lisp_Cons*
  %u813 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %405, i32 0, i32 1
  %cdr814 = bitcast %union.anon* %u813 to i64*
  %406 = load i64, i64* %cdr814, align 8
  store i64 %406, i64* %val, align 8
  br label %if.end.817

if.else.815:                                      ; preds = %if.else.806
  %call816 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call816, i64* %val, align 8
  br label %if.end.817

if.end.817:                                       ; preds = %if.else.815, %if.then.811
  br label %if.end.818

if.end.818:                                       ; preds = %if.end.817, %if.then.802
  br label %if.end.819

if.end.819:                                       ; preds = %if.end.818, %if.then.770
  br label %if.end.820

if.end.820:                                       ; preds = %if.end.819, %if.then.764
  br label %if.end.821

if.end.821:                                       ; preds = %if.end.820, %if.end.759
  %407 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %408 = load i64, i64* %val, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %407, i64 %408)
  %409 = load i64, i64* %proc, align 8
  call void @setup_process_coding_systems(i64 %409)
  %410 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %411 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_decoding_buf(%struct.Lisp_Process* %410, i64 %411)
  %412 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %412, i32 0, i32 26
  store i32 0, i32* %decoding_carryover, align 4
  %413 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %414 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_encoding_buf(%struct.Lisp_Process* %413, i64 %414)
  %415 = load i64, i64* %tem, align 8
  %call822 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp823 = icmp eq i64 %415, %call822
  br i1 %cmp823, label %lor.lhs.false.825, label %lor.end

lor.lhs.false.825:                                ; preds = %if.end.821
  %416 = load i64, i64* %buffer, align 8
  %call826 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp827 = icmp eq i64 %416, %call826
  br i1 %cmp827, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.825
  %417 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 447), align 1
  %tobool829 = trunc i8 %417 to i1
  %lnot830 = xor i1 %tobool829, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.825, %if.end.821
  %418 = phi i1 [ true, %lor.lhs.false.825 ], [ true, %if.end.821 ], [ %lnot830, %lor.rhs ]
  %lnot831 = xor i1 %418, true
  %419 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %419, i32 0, i32 28
  %420 = zext i1 %lnot831 to i8
  %bf.load832 = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.shl = shl i8 %420, 5
  %bf.clear833 = and i8 %bf.load832, -33
  %bf.set834 = or i8 %bf.clear833, %bf.shl
  store i8 %bf.set834, i8* %inherit_coding_system_flag, align 8
  %tobool835 = trunc i8 %420 to i1
  %421 = load i64, i64* %proc, align 8
  store i64 %421, i64* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.then.513, %if.then
  %422 = load i64, i64* %retval
  ret i64 %422
}

declare void @message(i8*, ...) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #5

declare i64 @SBYTES(i64) #1

declare i8* @lispstpcpy(i8*, i64) #1

declare void @record_unwind_protect_void(void ()*) #1

declare void @run_all_atimers() #1

declare void @bind_polling_period(i32) #1

; Function Attrs: nounwind
declare i32 @sprintf(i8*, i8*, ...) #6

declare void @process_quit_flag() #1

declare void @process_pending_signals() #1

; Function Attrs: nounwind
declare i32 @__res_init() #6

declare i32 @getaddrinfo(i8*, i8*, %struct.addrinfo*, %struct.addrinfo**) #1

; Function Attrs: nounwind
declare i8* @gai_strerror(i32) #6

; Function Attrs: nounwind readnone
declare zeroext i16 @htons(i16 zeroext) #4

declare %struct.servent* @getservbyname(i8*, i8*) #1

declare i8* @SDATA(i64) #1

; Function Attrs: nounwind
declare i32 @socket(i32, i32, i32) #6

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #4

declare i32 @emacs_close(i32) #1

declare void @record_unwind_protect_int(void (i32)*, i32) #1

declare void @close_file_unwind(i32) #1

; Function Attrs: nounwind
declare i32 @setsockopt(i32, i32, i32, i8*, i32) #6

; Function Attrs: nounwind
declare i32 @bind(i32, %struct.sockaddr*, i32) #6

; Function Attrs: nounwind
declare i32 @getsockname(i32, %struct.sockaddr*, i32*) #6

; Function Attrs: nounwind
declare i32 @listen(i32, i32) #6

declare i32 @connect(i32, %struct.sockaddr*, i32) #1

declare i32 @pselect(i32, %struct.fd_set*, %struct.fd_set*, %struct.fd_set*, %struct.timespec*, %struct.__sigset_t*) #1

; Function Attrs: nounwind
declare i32 @getsockopt(i32, i32, i32, i8*, i32*) #6

; Function Attrs: noreturn
declare void @report_file_errno(i8*, i64, i32) #2

; Function Attrs: noreturn
declare void @emacs_abort() #2

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #5

declare void @block_input() #1

; Function Attrs: nounwind
declare void @freeaddrinfo(%struct.addrinfo*) #6

declare void @unblock_input() #1

declare zeroext i1 @fd_ISSET(i32, %struct.fd_set*) #1

; Function Attrs: nounwind uwtable
define i64 @Fnetwork_interface_list() #0 {
entry:
  %call = call i64 @network_interface_list()
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @network_interface_list() #0 {
entry:
  %retval = alloca i64, align 8
  %ifconf = alloca %struct.ifconf, align 8
  %ifreq = alloca %struct.ifreq*, align 8
  %buf = alloca i8*, align 8
  %buf_size = alloca i64, align 8
  %s = alloca i32, align 4
  %res = alloca i64, align 8
  %count = alloca i64, align 8
  %ifq = alloca %struct.ifreq*, align 8
  %len = alloca i32, align 4
  %namebuf = alloca [17 x i8], align 16
  store i8* null, i8** %buf, align 8
  store i64 512, i64* %buf_size, align 8
  %call = call i32 @socket(i32 2, i32 524289, i32 0) #5
  store i32 %call, i32* %s, align 4
  %0 = load i32, i32* %s, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i64 @SPECPDL_INDEX()
  store i64 %call2, i64* %count, align 8
  %1 = load i32, i32* %s, align 4
  call void @record_unwind_protect_int(void (i32)* @close_file_unwind, i32 %1)
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %2 = load i8*, i8** %buf, align 8
  %call3 = call i8* @xpalloc(i8* %2, i64* %buf_size, i64 1, i64 2147483647, i64 1)
  store i8* %call3, i8** %buf, align 8
  %3 = load i8*, i8** %buf, align 8
  %ifc_ifcu = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 1
  %ifcu_buf = bitcast %union.anon.25* %ifc_ifcu to i8**
  store i8* %3, i8** %ifcu_buf, align 8
  %4 = load i64, i64* %buf_size, align 8
  %conv = trunc i64 %4 to i32
  %ifc_len = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 0
  store i32 %conv, i32* %ifc_len, align 4
  %5 = load i32, i32* %s, align 4
  %call4 = call i32 (i32, i64, ...) @ioctl(i32 %5, i64 35090, %struct.ifconf* %ifconf) #5
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then.5, label %if.end.8

if.then.5:                                        ; preds = %do.body
  %6 = load i32, i32* %s, align 4
  %call6 = call i32 @emacs_close(i32 %6)
  %7 = load i8*, i8** %buf, align 8
  call void @xfree(i8* %7)
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call7, i64* %retval
  br label %return

if.end.8:                                         ; preds = %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end.8
  %ifc_len9 = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 0
  %8 = load i32, i32* %ifc_len9, align 4
  %conv10 = sext i32 %8 to i64
  %9 = load i64, i64* %buf_size, align 8
  %cmp11 = icmp eq i64 %conv10, %9
  br i1 %cmp11, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %10 = load i64, i64* %count, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %call14 = call i64 @unbind_to(i64 %10, i64 %call13)
  store i64 %call14, i64* %res, align 8
  %ifc_ifcu15 = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 1
  %ifcu_req = bitcast %union.anon.25* %ifc_ifcu15 to %struct.ifreq**
  %11 = load %struct.ifreq*, %struct.ifreq** %ifcu_req, align 8
  store %struct.ifreq* %11, %struct.ifreq** %ifreq, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.27, %if.then.26, %do.end
  %12 = load %struct.ifreq*, %struct.ifreq** %ifreq, align 8
  %13 = bitcast %struct.ifreq* %12 to i8*
  %ifc_ifcu16 = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 1
  %ifcu_req17 = bitcast %union.anon.25* %ifc_ifcu16 to %struct.ifreq**
  %14 = load %struct.ifreq*, %struct.ifreq** %ifcu_req17, align 8
  %15 = bitcast %struct.ifreq* %14 to i8*
  %ifc_len18 = getelementptr inbounds %struct.ifconf, %struct.ifconf* %ifconf, i32 0, i32 0
  %16 = load i32, i32* %ifc_len18, align 4
  %idx.ext = sext i32 %16 to i64
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 %idx.ext
  %cmp19 = icmp ult i8* %13, %add.ptr
  br i1 %cmp19, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load %struct.ifreq*, %struct.ifreq** %ifreq, align 8
  store %struct.ifreq* %17, %struct.ifreq** %ifq, align 8
  store i32 40, i32* %len, align 4
  %18 = load %struct.ifreq*, %struct.ifreq** %ifreq, align 8
  %19 = bitcast %struct.ifreq* %18 to i8*
  %20 = load i32, i32* %len, align 4
  %idx.ext21 = sext i32 %20 to i64
  %add.ptr22 = getelementptr inbounds i8, i8* %19, i64 %idx.ext21
  %21 = bitcast i8* %add.ptr22 to %struct.ifreq*
  store %struct.ifreq* %21, %struct.ifreq** %ifreq, align 8
  %22 = load %struct.ifreq*, %struct.ifreq** %ifq, align 8
  %ifr_ifru = getelementptr inbounds %struct.ifreq, %struct.ifreq* %22, i32 0, i32 1
  %ifru_addr = bitcast %union.anon.27* %ifr_ifru to %struct.sockaddr*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %ifru_addr, i32 0, i32 0
  %23 = load i16, i16* %sa_family, align 2
  %conv23 = zext i16 %23 to i32
  %cmp24 = icmp ne i32 %conv23, 2
  br i1 %cmp24, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %while.body
  br label %while.cond

if.end.27:                                        ; preds = %while.body
  %24 = bitcast [17 x i8]* %namebuf to i8*
  %25 = load %struct.ifreq*, %struct.ifreq** %ifq, align 8
  %ifr_ifrn = getelementptr inbounds %struct.ifreq, %struct.ifreq* %25, i32 0, i32 0
  %ifrn_name = bitcast %union.anon.26* %ifr_ifrn to [16 x i8]*
  %26 = bitcast [16 x i8]* %ifrn_name to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %26, i64 16, i32 1, i1 false)
  %arrayidx = getelementptr inbounds [17 x i8], [17 x i8]* %namebuf, i32 0, i64 16
  store i8 0, i8* %arrayidx, align 1
  %arraydecay = getelementptr inbounds [17 x i8], [17 x i8]* %namebuf, i32 0, i32 0
  %call28 = call i64 @build_string(i8* %arraydecay)
  %27 = load %struct.ifreq*, %struct.ifreq** %ifq, align 8
  %ifr_ifru29 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %27, i32 0, i32 1
  %ifru_addr30 = bitcast %union.anon.27* %ifr_ifru29 to %struct.sockaddr*
  %call31 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %ifru_addr30, i32 16)
  %call32 = call i64 @Fcons(i64 %call28, i64 %call31)
  %28 = load i64, i64* %res, align 8
  %call33 = call i64 @Fcons(i64 %call32, i64 %28)
  store i64 %call33, i64* %res, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %29 = load i8*, i8** %buf, align 8
  call void @xfree(i8* %29)
  %30 = load i64, i64* %res, align 8
  store i64 %30, i64* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then.5, %if.then
  %31 = load i64, i64* %retval
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define i64 @Fnetwork_interface_info(i64 %ifname) #0 {
entry:
  %ifname.addr = alloca i64, align 8
  store i64 %ifname, i64* %ifname.addr, align 8
  %0 = load i64, i64* %ifname.addr, align 8
  %call = call i64 @network_interface_info(i64 %0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @network_interface_info(i64 %ifname) #0 {
entry:
  %retval = alloca i64, align 8
  %ifname.addr = alloca i64, align 8
  %rq = alloca %struct.ifreq, align 8
  %res = alloca i64, align 8
  %elt = alloca i64, align 8
  %s = alloca i32, align 4
  %any = alloca i8, align 1
  %count = alloca i64, align 8
  %flags = alloca i32, align 4
  %fp = alloca %struct.ifflag_def*, align 8
  %fnum = alloca i32, align 4
  %hwaddr = alloca i64, align 8
  %p = alloca %struct.Lisp_Vector*, align 8
  %n = alloca i32, align 4
  store i64 %ifname, i64* %ifname.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %res, align 8
  store i8 0, i8* %any, align 1
  %0 = load i64, i64* %ifname.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %ifname.addr, align 8
  %call1 = call i64 @SBYTES(i64 %1)
  %cmp = icmp ule i64 16, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.67, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  %ifr_ifrn = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 0
  %ifrn_name = bitcast %union.anon.26* %ifr_ifrn to [16 x i8]*
  %arraydecay = getelementptr inbounds [16 x i8], [16 x i8]* %ifrn_name, i32 0, i32 0
  %2 = load i64, i64* %ifname.addr, align 8
  %call2 = call i8* @lispstpcpy(i8* %arraydecay, i64 %2)
  %call3 = call i32 @socket(i32 2, i32 524289, i32 0) #5
  store i32 %call3, i32* %s, align 4
  %3 = load i32, i32* %s, align 4
  %cmp4 = icmp slt i32 %3, 0
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %if.end
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %retval
  br label %return

if.end.7:                                         ; preds = %if.end
  %call8 = call i64 @SPECPDL_INDEX()
  store i64 %call8, i64* %count, align 8
  %4 = load i32, i32* %s, align 4
  call void @record_unwind_protect_int(void (i32)* @close_file_unwind, i32 %4)
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call9, i64* %elt, align 8
  %5 = load i32, i32* %s, align 4
  %call10 = call i32 (i32, i64, ...) @ioctl(i32 %5, i64 35091, %struct.ifreq* %rq) #5
  %cmp11 = icmp eq i32 %call10, 0
  br i1 %cmp11, label %if.then.12, label %if.end.44

if.then.12:                                       ; preds = %if.end.7
  %ifr_ifru = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_flags = bitcast %union.anon.27* %ifr_ifru to i16*
  %6 = load i16, i16* %ifru_flags, align 2
  %conv = sext i16 %6 to i32
  store i32 %conv, i32* %flags, align 4
  %7 = load i32, i32* %flags, align 4
  %cmp13 = icmp slt i32 %7, 0
  br i1 %cmp13, label %if.then.15, label %if.end.19

if.then.15:                                       ; preds = %if.then.12
  %ifr_ifru16 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_flags17 = bitcast %union.anon.27* %ifr_ifru16 to i16*
  %8 = load i16, i16* %ifru_flags17, align 2
  %conv18 = zext i16 %8 to i32
  store i32 %conv18, i32* %flags, align 4
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.15, %if.then.12
  store i8 1, i8* %any, align 1
  store %struct.ifflag_def* getelementptr inbounds ([17 x %struct.ifflag_def], [17 x %struct.ifflag_def]* @ifflag_table, i32 0, i32 0), %struct.ifflag_def** %fp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.19
  %9 = load i32, i32* %flags, align 4
  %cmp20 = icmp ne i32 %9, 0
  br i1 %cmp20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %10 = load %struct.ifflag_def*, %struct.ifflag_def** %fp, align 8
  %flag_sym = getelementptr inbounds %struct.ifflag_def, %struct.ifflag_def* %10, i32 0, i32 1
  %11 = load i8*, i8** %flag_sym, align 8
  %tobool = icmp ne i8* %11, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ %tobool, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %13 = load i32, i32* %flags, align 4
  %14 = load %struct.ifflag_def*, %struct.ifflag_def** %fp, align 8
  %flag_bit = getelementptr inbounds %struct.ifflag_def, %struct.ifflag_def* %14, i32 0, i32 0
  %15 = load i32, i32* %flag_bit, align 4
  %and = and i32 %13, %15
  %tobool22 = icmp ne i32 %and, 0
  br i1 %tobool22, label %if.then.23, label %if.end.28

if.then.23:                                       ; preds = %for.body
  %16 = load %struct.ifflag_def*, %struct.ifflag_def** %fp, align 8
  %flag_sym24 = getelementptr inbounds %struct.ifflag_def, %struct.ifflag_def* %16, i32 0, i32 1
  %17 = load i8*, i8** %flag_sym24, align 8
  %call25 = call i64 @intern(i8* %17)
  %18 = load i64, i64* %elt, align 8
  %call26 = call i64 @Fcons(i64 %call25, i64 %18)
  store i64 %call26, i64* %elt, align 8
  %19 = load %struct.ifflag_def*, %struct.ifflag_def** %fp, align 8
  %flag_bit27 = getelementptr inbounds %struct.ifflag_def, %struct.ifflag_def* %19, i32 0, i32 0
  %20 = load i32, i32* %flag_bit27, align 4
  %21 = load i32, i32* %flags, align 4
  %sub = sub nsw i32 %21, %20
  store i32 %sub, i32* %flags, align 4
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.23, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %22 = load %struct.ifflag_def*, %struct.ifflag_def** %fp, align 8
  %incdec.ptr = getelementptr inbounds %struct.ifflag_def, %struct.ifflag_def* %22, i32 1
  store %struct.ifflag_def* %incdec.ptr, %struct.ifflag_def** %fp, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  store i32 0, i32* %fnum, align 4
  br label %for.cond.29

for.cond.29:                                      ; preds = %for.inc.42, %for.end
  %23 = load i32, i32* %flags, align 4
  %tobool30 = icmp ne i32 %23, 0
  br i1 %tobool30, label %land.rhs.31, label %land.end.34

land.rhs.31:                                      ; preds = %for.cond.29
  %24 = load i32, i32* %fnum, align 4
  %cmp32 = icmp slt i32 %24, 32
  br label %land.end.34

land.end.34:                                      ; preds = %land.rhs.31, %for.cond.29
  %25 = phi i1 [ false, %for.cond.29 ], [ %cmp32, %land.rhs.31 ]
  br i1 %25, label %for.body.35, label %for.end.43

for.body.35:                                      ; preds = %land.end.34
  %26 = load i32, i32* %flags, align 4
  %and36 = and i32 %26, 1
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.38, label %if.end.41

if.then.38:                                       ; preds = %for.body.35
  %27 = load i32, i32* %fnum, align 4
  %conv39 = sext i32 %27 to i64
  %shl = shl i64 %conv39, 2
  %add = add i64 %shl, 2
  %28 = load i64, i64* %elt, align 8
  %call40 = call i64 @Fcons(i64 %add, i64 %28)
  store i64 %call40, i64* %elt, align 8
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.38, %for.body.35
  br label %for.inc.42

for.inc.42:                                       ; preds = %if.end.41
  %29 = load i32, i32* %flags, align 4
  %shr = ashr i32 %29, 1
  store i32 %shr, i32* %flags, align 4
  %30 = load i32, i32* %fnum, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %fnum, align 4
  br label %for.cond.29

for.end.43:                                       ; preds = %land.end.34
  br label %if.end.44

if.end.44:                                        ; preds = %for.end.43, %if.end.7
  %31 = load i64, i64* %elt, align 8
  %32 = load i64, i64* %res, align 8
  %call45 = call i64 @Fcons(i64 %31, i64 %32)
  store i64 %call45, i64* %res, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call46, i64* %elt, align 8
  %33 = load i32, i32* %s, align 4
  %call47 = call i32 (i32, i64, ...) @ioctl(i32 %33, i64 35111, %struct.ifreq* %rq) #5
  %cmp48 = icmp eq i32 %call47, 0
  br i1 %cmp48, label %if.then.50, label %if.end.74

if.then.50:                                       ; preds = %if.end.44
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %call52 = call i64 @Fmake_vector(i64 26, i64 %call51)
  store i64 %call52, i64* %hwaddr, align 8
  %34 = load i64, i64* %hwaddr, align 8
  %call53 = call %struct.Lisp_Vector* @XVECTOR(i64 %34)
  store %struct.Lisp_Vector* %call53, %struct.Lisp_Vector** %p, align 8
  store i8 1, i8* %any, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond.54

for.cond.54:                                      ; preds = %for.inc.65, %if.then.50
  %35 = load i32, i32* %n, align 4
  %cmp55 = icmp slt i32 %35, 6
  br i1 %cmp55, label %for.body.57, label %for.end.67

for.body.57:                                      ; preds = %for.cond.54
  %36 = load i32, i32* %n, align 4
  %idxprom = sext i32 %36 to i64
  %ifr_ifru58 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_hwaddr = bitcast %union.anon.27* %ifr_ifru58 to %struct.sockaddr*
  %sa_data = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %ifru_hwaddr, i32 0, i32 1
  %arrayidx = getelementptr inbounds [14 x i8], [14 x i8]* %sa_data, i32 0, i64 0
  %arrayidx59 = getelementptr inbounds i8, i8* %arrayidx, i64 %idxprom
  %37 = load i8, i8* %arrayidx59, align 1
  %conv60 = zext i8 %37 to i64
  %shl61 = shl i64 %conv60, 2
  %add62 = add i64 %shl61, 2
  %38 = load i32, i32* %n, align 4
  %idxprom63 = sext i32 %38 to i64
  %39 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %39, i32 0, i32 1
  %arrayidx64 = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i64 %idxprom63
  store i64 %add62, i64* %arrayidx64, align 8
  br label %for.inc.65

for.inc.65:                                       ; preds = %for.body.57
  %40 = load i32, i32* %n, align 4
  %inc66 = add nsw i32 %40, 1
  store i32 %inc66, i32* %n, align 4
  br label %for.cond.54

for.end.67:                                       ; preds = %for.cond.54
  %ifr_ifru68 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_hwaddr69 = bitcast %union.anon.27* %ifr_ifru68 to %struct.sockaddr*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %ifru_hwaddr69, i32 0, i32 0
  %41 = load i16, i16* %sa_family, align 2
  %conv70 = zext i16 %41 to i64
  %shl71 = shl i64 %conv70, 2
  %add72 = add i64 %shl71, 2
  %42 = load i64, i64* %hwaddr, align 8
  %call73 = call i64 @Fcons(i64 %add72, i64 %42)
  store i64 %call73, i64* %elt, align 8
  br label %if.end.74

if.end.74:                                        ; preds = %for.end.67, %if.end.44
  %43 = load i64, i64* %elt, align 8
  %44 = load i64, i64* %res, align 8
  %call75 = call i64 @Fcons(i64 %43, i64 %44)
  store i64 %call75, i64* %res, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call76, i64* %elt, align 8
  %45 = load i32, i32* %s, align 4
  %call77 = call i32 (i32, i64, ...) @ioctl(i32 %45, i64 35099, %struct.ifreq* %rq) #5
  %cmp78 = icmp eq i32 %call77, 0
  br i1 %cmp78, label %if.then.80, label %if.end.83

if.then.80:                                       ; preds = %if.end.74
  store i8 1, i8* %any, align 1
  %ifr_ifru81 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_netmask = bitcast %union.anon.27* %ifr_ifru81 to %struct.sockaddr*
  %call82 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %ifru_netmask, i32 16)
  store i64 %call82, i64* %elt, align 8
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.80, %if.end.74
  %46 = load i64, i64* %elt, align 8
  %47 = load i64, i64* %res, align 8
  %call84 = call i64 @Fcons(i64 %46, i64 %47)
  store i64 %call84, i64* %res, align 8
  %call85 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call85, i64* %elt, align 8
  %48 = load i32, i32* %s, align 4
  %call86 = call i32 (i32, i64, ...) @ioctl(i32 %48, i64 35097, %struct.ifreq* %rq) #5
  %cmp87 = icmp eq i32 %call86, 0
  br i1 %cmp87, label %if.then.89, label %if.end.92

if.then.89:                                       ; preds = %if.end.83
  store i8 1, i8* %any, align 1
  %ifr_ifru90 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_broadaddr = bitcast %union.anon.27* %ifr_ifru90 to %struct.sockaddr*
  %call91 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %ifru_broadaddr, i32 16)
  store i64 %call91, i64* %elt, align 8
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.89, %if.end.83
  %49 = load i64, i64* %elt, align 8
  %50 = load i64, i64* %res, align 8
  %call93 = call i64 @Fcons(i64 %49, i64 %50)
  store i64 %call93, i64* %res, align 8
  %call94 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call94, i64* %elt, align 8
  %51 = load i32, i32* %s, align 4
  %call95 = call i32 (i32, i64, ...) @ioctl(i32 %51, i64 35093, %struct.ifreq* %rq) #5
  %cmp96 = icmp eq i32 %call95, 0
  br i1 %cmp96, label %if.then.98, label %if.end.101

if.then.98:                                       ; preds = %if.end.92
  store i8 1, i8* %any, align 1
  %ifr_ifru99 = getelementptr inbounds %struct.ifreq, %struct.ifreq* %rq, i32 0, i32 1
  %ifru_addr = bitcast %union.anon.27* %ifr_ifru99 to %struct.sockaddr*
  %call100 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %ifru_addr, i32 16)
  store i64 %call100, i64* %elt, align 8
  br label %if.end.101

if.end.101:                                       ; preds = %if.then.98, %if.end.92
  %52 = load i64, i64* %elt, align 8
  %53 = load i64, i64* %res, align 8
  %call102 = call i64 @Fcons(i64 %52, i64 %53)
  store i64 %call102, i64* %res, align 8
  %54 = load i64, i64* %count, align 8
  %55 = load i8, i8* %any, align 1
  %tobool103 = trunc i8 %55 to i1
  br i1 %tobool103, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.101
  %56 = load i64, i64* %res, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.101
  %call105 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %56, %cond.true ], [ %call105, %cond.false ]
  %call106 = call i64 @unbind_to(i64 %54, i64 %cond)
  store i64 %call106, i64* %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then.5
  %57 = load i64, i64* %retval
  ret i64 %57
}

; Function Attrs: nounwind uwtable
define i64 @Faccept_process_output(i64 %process, i64 %seconds, i64 %millisec, i64 %just_this_one) #0 {
entry:
  %process.addr = alloca i64, align 8
  %seconds.addr = alloca i64, align 8
  %millisec.addr = alloca i64, align 8
  %just_this_one.addr = alloca i64, align 8
  %secs = alloca i64, align 8
  %nsecs = alloca i32, align 4
  %t = alloca %struct.timespec, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %seconds, i64* %seconds.addr, align 8
  store i64 %millisec, i64* %millisec.addr, align 8
  store i64 %just_this_one, i64* %just_this_one.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %1)
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %just_this_one.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load i64, i64* %millisec.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %2, %call2
  br i1 %cmp3, label %if.end.32, label %if.then.4

if.then.4:                                        ; preds = %if.end
  %3 = load i64, i64* %millisec.addr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %and5 = and i32 %conv, -5
  %cmp6 = icmp eq i32 %and5, 2
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.4
  br label %cond.end

cond.false:                                       ; preds = %if.then.4
  %call8 = call i64 @builtin_lisp_symbol(i32 559)
  %4 = load i64, i64* %millisec.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call8, i64 %4) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  %7 = load i64, i64* %seconds.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %7, %call9
  br i1 %cmp10, label %if.then.12, label %if.else.15

if.then.12:                                       ; preds = %cond.end
  %8 = load i64, i64* %millisec.addr, align 8
  %shr = ashr i64 %8, 2
  %conv13 = sitofp i64 %shr to double
  %div = fdiv double %conv13, 1.000000e+03
  %call14 = call i64 @make_float(double %div)
  store i64 %call14, i64* %seconds.addr, align 8
  br label %if.end.31

if.else.15:                                       ; preds = %cond.end
  %9 = load i64, i64* %seconds.addr, align 8
  %and16 = and i64 %9, 7
  %conv17 = trunc i64 %and16 to i32
  %and18 = and i32 %conv17, -5
  %cmp19 = icmp eq i32 %and18, 2
  br i1 %cmp19, label %cond.true.21, label %cond.false.22

cond.true.21:                                     ; preds = %if.else.15
  br label %cond.end.24

cond.false.22:                                    ; preds = %if.else.15
  %call23 = call i64 @builtin_lisp_symbol(i32 559)
  %10 = load i64, i64* %seconds.addr, align 8
  %11 = call i64 @wrong_type_argument(i64 %call23, i64 %10) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.24

cond.end.24:                                      ; preds = %12, %cond.true.21
  %13 = load i64, i64* %millisec.addr, align 8
  %shr25 = ashr i64 %13, 2
  %conv26 = sitofp i64 %shr25 to double
  %div27 = fdiv double %conv26, 1.000000e+03
  %14 = load i64, i64* %seconds.addr, align 8
  %shr28 = ashr i64 %14, 2
  %conv29 = sitofp i64 %shr28 to double
  %add = fadd double %div27, %conv29
  %call30 = call i64 @make_float(double %add)
  store i64 %call30, i64* %seconds.addr, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %cond.end.24, %if.then.12
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.end
  store i64 0, i64* %secs, align 8
  store i32 -1, i32* %nsecs, align 4
  %15 = load i64, i64* %seconds.addr, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp34 = icmp eq i64 %15, %call33
  br i1 %cmp34, label %if.else.73, label %if.then.36

if.then.36:                                       ; preds = %if.end.32
  %16 = load i64, i64* %seconds.addr, align 8
  %and37 = and i64 %16, 7
  %conv38 = trunc i64 %and37 to i32
  %and39 = and i32 %conv38, -5
  %cmp40 = icmp eq i32 %and39, 2
  br i1 %cmp40, label %if.then.42, label %if.else.49

if.then.42:                                       ; preds = %if.then.36
  %17 = load i64, i64* %seconds.addr, align 8
  %shr43 = ashr i64 %17, 2
  %cmp44 = icmp sgt i64 %shr43, 0
  br i1 %cmp44, label %if.then.46, label %if.end.48

if.then.46:                                       ; preds = %if.then.42
  %18 = load i64, i64* %seconds.addr, align 8
  %shr47 = ashr i64 %18, 2
  store i64 %shr47, i64* %secs, align 8
  store i32 0, i32* %nsecs, align 4
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.46, %if.then.42
  br label %if.end.72

if.else.49:                                       ; preds = %if.then.36
  %19 = load i64, i64* %seconds.addr, align 8
  %and50 = and i64 %19, 7
  %conv51 = trunc i64 %and50 to i32
  %cmp52 = icmp eq i32 %conv51, 7
  br i1 %cmp52, label %if.then.54, label %if.else.69

if.then.54:                                       ; preds = %if.else.49
  %20 = load i64, i64* %seconds.addr, align 8
  %call55 = call double @XFLOAT_DATA(i64 %20)
  %cmp56 = fcmp ogt double %call55, 0.000000e+00
  br i1 %cmp56, label %if.then.58, label %if.end.68

if.then.58:                                       ; preds = %if.then.54
  %21 = load i64, i64* %seconds.addr, align 8
  %call59 = call double @XFLOAT_DATA(i64 %21)
  %call60 = call { i64, i64 } @dtotimespec(double %call59) #11
  %22 = bitcast %struct.timespec* %t to { i64, i64 }*
  %23 = getelementptr { i64, i64 }, { i64, i64 }* %22, i32 0, i32 0
  %24 = extractvalue { i64, i64 } %call60, 0
  store i64 %24, i64* %23, align 8
  %25 = getelementptr { i64, i64 }, { i64, i64 }* %22, i32 0, i32 1
  %26 = extractvalue { i64, i64 } %call60, 1
  store i64 %26, i64* %25, align 8
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 0
  %27 = load i64, i64* %tv_sec, align 8
  %cmp61 = icmp slt i64 %27, 9223372036854775807
  br i1 %cmp61, label %cond.true.63, label %cond.false.65

cond.true.63:                                     ; preds = %if.then.58
  %tv_sec64 = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 0
  %28 = load i64, i64* %tv_sec64, align 8
  br label %cond.end.66

cond.false.65:                                    ; preds = %if.then.58
  br label %cond.end.66

cond.end.66:                                      ; preds = %cond.false.65, %cond.true.63
  %cond = phi i64 [ %28, %cond.true.63 ], [ 9223372036854775807, %cond.false.65 ]
  store i64 %cond, i64* %secs, align 8
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 1
  %29 = load i64, i64* %tv_nsec, align 8
  %conv67 = trunc i64 %29 to i32
  store i32 %conv67, i32* %nsecs, align 4
  br label %if.end.68

if.end.68:                                        ; preds = %cond.end.66, %if.then.54
  br label %if.end.71

if.else.69:                                       ; preds = %if.else.49
  %call70 = call i64 @builtin_lisp_symbol(i32 711)
  %30 = load i64, i64* %seconds.addr, align 8
  %31 = call i64 @wrong_type_argument(i64 %call70, i64 %30) #8
  unreachable

if.end.71:                                        ; preds = %if.end.68
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.71, %if.end.48
  br label %if.end.79

if.else.73:                                       ; preds = %if.end.32
  %32 = load i64, i64* %process.addr, align 8
  %call74 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp75 = icmp eq i64 %32, %call74
  br i1 %cmp75, label %if.end.78, label %if.then.77

if.then.77:                                       ; preds = %if.else.73
  store i32 0, i32* %nsecs, align 4
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.77, %if.else.73
  br label %if.end.79

if.end.79:                                        ; preds = %if.end.78, %if.end.72
  %33 = load i64, i64* %secs, align 8
  %34 = load i32, i32* %nsecs, align 4
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  %35 = load i64, i64* %process.addr, align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp82 = icmp eq i64 %35, %call81
  br i1 %cmp82, label %cond.false.86, label %cond.true.84

cond.true.84:                                     ; preds = %if.end.79
  %36 = load i64, i64* %process.addr, align 8
  %call85 = call %struct.Lisp_Process* @XPROCESS(i64 %36)
  br label %cond.end.87

cond.false.86:                                    ; preds = %if.end.79
  br label %cond.end.87

cond.end.87:                                      ; preds = %cond.false.86, %cond.true.84
  %cond88 = phi %struct.Lisp_Process* [ %call85, %cond.true.84 ], [ null, %cond.false.86 ]
  %37 = load i64, i64* %just_this_one.addr, align 8
  %call89 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp90 = icmp eq i64 %37, %call89
  br i1 %cmp90, label %cond.true.92, label %cond.false.93

cond.true.92:                                     ; preds = %cond.end.87
  br label %cond.end.100

cond.false.93:                                    ; preds = %cond.end.87
  %38 = load i64, i64* %just_this_one.addr, align 8
  %and94 = and i64 %38, 7
  %conv95 = trunc i64 %and94 to i32
  %and96 = and i32 %conv95, -5
  %cmp97 = icmp eq i32 %and96, 2
  %lnot = xor i1 %cmp97, true
  %cond99 = select i1 %lnot, i32 1, i32 -1
  br label %cond.end.100

cond.end.100:                                     ; preds = %cond.false.93, %cond.true.92
  %cond101 = phi i32 [ 0, %cond.true.92 ], [ %cond99, %cond.false.93 ]
  %call102 = call i32 @wait_reading_process_output(i64 %33, i32 %34, i32 0, i1 zeroext false, i64 %call80, %struct.Lisp_Process* %cond88, i32 %cond101)
  %cmp103 = icmp sle i32 %call102, 0
  br i1 %cmp103, label %cond.true.105, label %cond.false.107

cond.true.105:                                    ; preds = %cond.end.100
  %call106 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.109

cond.false.107:                                   ; preds = %cond.end.100
  %call108 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.109

cond.end.109:                                     ; preds = %cond.false.107, %cond.true.105
  %cond110 = phi i64 [ %call106, %cond.true.105 ], [ %call108, %cond.false.107 ]
  ret i64 %cond110
}

declare double @XFLOAT_DATA(i64) #1

; Function Attrs: nounwind readnone
declare { i64, i64 } @dtotimespec(double) #4

; Function Attrs: nounwind uwtable
define i32 @wait_reading_process_output(i64 %time_limit, i32 %nsecs, i32 %read_kbd, i1 zeroext %do_display, i64 %wait_for_cell, %struct.Lisp_Process* %wait_proc, i32 %just_wait_proc) #0 {
entry:
  %time_limit.addr = alloca i64, align 8
  %nsecs.addr = alloca i32, align 4
  %read_kbd.addr = alloca i32, align 4
  %do_display.addr = alloca i8, align 1
  %wait_for_cell.addr = alloca i64, align 8
  %wait_proc.addr = alloca %struct.Lisp_Process*, align 8
  %just_wait_proc.addr = alloca i32, align 4
  %channel = alloca i32, align 4
  %nfds = alloca i32, align 4
  %Available = alloca %struct.fd_set, align 8
  %Writeok = alloca %struct.fd_set, align 8
  %check_write = alloca i8, align 1
  %check_delay = alloca i32, align 4
  %no_avail = alloca i8, align 1
  %xerrno = alloca i32, align 4
  %proc = alloca i64, align 8
  %timeout = alloca %struct.timespec, align 8
  %end_time = alloca %struct.timespec, align 8
  %timer_delay = alloca %struct.timespec, align 8
  %got_output_end_time = alloca %struct.timespec, align 8
  %wait = alloca i32, align 4
  %got_some_output = alloca i32, align 4
  %count = alloca i64, align 8
  %now = alloca %struct.timespec, align 8
  %__d0 = alloca i32, align 4
  %__d1 = alloca i32, align 4
  %__d05 = alloca i32, align 4
  %__d16 = alloca i32, align 4
  %coerce = alloca %struct.timespec, align 8
  %agg.tmp = alloca %struct.timespec, align 8
  %coerce44 = alloca %struct.timespec, align 8
  %process_skipped = alloca i8, align 1
  %coerce88 = alloca %struct.timespec, align 8
  %coerce96 = alloca %struct.timespec, align 8
  %coerce102 = alloca %struct.timespec, align 8
  %old_timers_run = alloca i32, align 4
  %old_buffer = alloca %struct.buffer*, align 8
  %old_window = alloca i64, align 8
  %coerce113 = alloca %struct.timespec, align 8
  %Atemp = alloca %struct.fd_set, align 8
  %Ctemp = alloca %struct.fd_set, align 8
  %__d0158 = alloca i32, align 4
  %__d1159 = alloca i32, align 4
  %coerce169 = alloca %struct.timespec, align 8
  %read_some_bytes = alloca i8, align 1
  %nread = alloca i32, align 4
  %__d0300 = alloca i32, align 4
  %__d1301 = alloca i32, align 4
  %adaptive_nsecs = alloca i32, align 4
  %coerce358 = alloca %struct.timespec, align 8
  %coerce373 = alloca %struct.timespec, align 8
  %coerce392 = alloca %struct.timespec, align 8
  %timeout_abs = alloca %struct.timespec, align 8
  %coerce404 = alloca %struct.timespec, align 8
  %coerce415 = alloca %struct.timespec, align 8
  %tls_available = alloca %struct.fd_set, align 8
  %set = alloca i32, align 4
  %__d0435 = alloca i32, align 4
  %__d1436 = alloca i32, align 4
  %p = alloca %struct.Lisp_Process*, align 8
  %huge_timespec = alloca %struct.timespec, align 8
  %cmp_time = alloca %struct.timespec, align 8
  %coerce544 = alloca %struct.timespec, align 8
  %old_timers_run569 = alloca i32, align 4
  %old_buffer570 = alloca %struct.buffer*, align 8
  %old_window571 = alloca i64, align 8
  %leave = alloca i8, align 1
  %d = alloca %struct.fd_callback_data*, align 8
  %nread687 = alloca i32, align 4
  %__d0722 = alloca i32, align 4
  %__d1723 = alloca i32, align 4
  %p757 = alloca %struct.Lisp_Process*, align 8
  %p844 = alloca %struct.Lisp_Process*, align 8
  %xlen = alloca i32, align 4
  store i64 %time_limit, i64* %time_limit.addr, align 8
  store i32 %nsecs, i32* %nsecs.addr, align 4
  store i32 %read_kbd, i32* %read_kbd.addr, align 4
  %frombool = zext i1 %do_display to i8
  store i8 %frombool, i8* %do_display.addr, align 1
  store i64 %wait_for_cell, i64* %wait_for_cell.addr, align 8
  store %struct.Lisp_Process* %wait_proc, %struct.Lisp_Process** %wait_proc.addr, align 8
  store i32 %just_wait_proc, i32* %just_wait_proc.addr, align 4
  %call = call { i64, i64 } @invalid_timespec()
  %0 = bitcast %struct.timespec* %got_output_end_time to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call, 1
  store i64 %4, i64* %3, align 8
  store i32 -1, i32* %got_some_output, align 4
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %count, align 8
  %call2 = call { i64, i64 } @invalid_timespec()
  %5 = bitcast %struct.timespec* %now to { i64, i64 }*
  %6 = getelementptr { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = extractvalue { i64, i64 } %call2, 0
  store i64 %7, i64* %6, align 8
  %8 = getelementptr { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = extractvalue { i64, i64 } %call2, 1
  store i64 %9, i64* %8, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %fds_bits = getelementptr inbounds %struct.fd_set, %struct.fd_set* %Available, i32 0, i32 0
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits, i32 0, i64 0
  %10 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx) #5, !srcloc !2
  %asmresult = extractvalue { i64, i64* } %10, 0
  %asmresult3 = extractvalue { i64, i64* } %10, 1
  %11 = trunc i64 %asmresult to i32
  store i32 %11, i32* %__d0, align 4
  %12 = ptrtoint i64* %asmresult3 to i64
  %13 = trunc i64 %12 to i32
  store i32 %13, i32* %__d1, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body.4

do.body.4:                                        ; preds = %do.end
  %fds_bits7 = getelementptr inbounds %struct.fd_set, %struct.fd_set* %Writeok, i32 0, i32 0
  %arrayidx8 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits7, i32 0, i64 0
  %14 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx8) #5, !srcloc !3
  %asmresult9 = extractvalue { i64, i64* } %14, 0
  %asmresult10 = extractvalue { i64, i64* } %14, 1
  %15 = trunc i64 %asmresult9 to i32
  store i32 %15, i32* %__d05, align 4
  %16 = ptrtoint i64* %asmresult10 to i64
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %__d16, align 4
  br label %do.end.11

do.end.11:                                        ; preds = %do.body.4
  %18 = load i64, i64* %time_limit.addr, align 8
  %cmp = icmp eq i64 %18, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.end.11
  %19 = load i32, i32* %nsecs.addr, align 4
  %cmp12 = icmp eq i32 %19, 0
  br i1 %cmp12, label %land.lhs.true.13, label %if.end

land.lhs.true.13:                                 ; preds = %land.lhs.true
  %20 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool = icmp ne %struct.Lisp_Process* %20, null
  br i1 %tobool, label %land.lhs.true.14, label %if.end

land.lhs.true.14:                                 ; preds = %land.lhs.true.13
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %21, %call15
  br i1 %cmp16, label %if.end, label %land.lhs.true.17

land.lhs.true.17:                                 ; preds = %land.lhs.true.14
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %22, i32 0, i32 12
  %23 = load i64, i64* %status, align 8
  %and = and i64 %23, 7
  %conv = trunc i64 %and to i32
  %cmp18 = icmp eq i32 %conv, 3
  br i1 %cmp18, label %land.lhs.true.20, label %if.then

land.lhs.true.20:                                 ; preds = %land.lhs.true.17
  %24 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %status21 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %24, i32 0, i32 12
  %25 = load i64, i64* %status21, align 8
  %sub = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 0
  %28 = load i64, i64* %car, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 387)
  %cmp23 = icmp eq i64 %28, %call22
  br i1 %cmp23, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.20, %land.lhs.true.17
  call void @message1(i8* getelementptr inbounds ([61 x i8], [61 x i8]* @.str.37, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.20, %land.lhs.true.14, %land.lhs.true.13, %land.lhs.true, %do.end.11
  %29 = load i32, i32* @waiting_for_user_input_p, align 4
  call void @record_unwind_protect_int(void (i32)* @wait_reading_process_output_unwind, i32 %29)
  %30 = load i32, i32* %read_kbd.addr, align 4
  store i32 %30, i32* @waiting_for_user_input_p, align 4
  %31 = load i64, i64* %time_limit.addr, align 8
  %cmp25 = icmp slt i64 9223372036854775807, %31
  br i1 %cmp25, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end
  store i64 9223372036854775807, i64* %time_limit.addr, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %if.end
  %32 = load i64, i64* %time_limit.addr, align 8
  %cmp29 = icmp slt i64 %32, 0
  br i1 %cmp29, label %if.then.33, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.28
  %33 = load i32, i32* %nsecs.addr, align 4
  %cmp31 = icmp slt i32 %33, 0
  br i1 %cmp31, label %if.then.33, label %if.else

if.then.33:                                       ; preds = %lor.lhs.false, %if.end.28
  store i32 -1, i32* %wait, align 4
  br label %if.end.47

if.else:                                          ; preds = %lor.lhs.false
  %34 = load i64, i64* %time_limit.addr, align 8
  %cmp34 = icmp sgt i64 %34, 0
  br i1 %cmp34, label %if.then.39, label %lor.lhs.false.36

lor.lhs.false.36:                                 ; preds = %if.else
  %35 = load i32, i32* %nsecs.addr, align 4
  %cmp37 = icmp sgt i32 %35, 0
  br i1 %cmp37, label %if.then.39, label %if.else.45

if.then.39:                                       ; preds = %lor.lhs.false.36, %if.else
  store i32 0, i32* %wait, align 4
  %call40 = call { i64, i64 } @current_timespec()
  %36 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %37 = getelementptr { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = extractvalue { i64, i64 } %call40, 0
  store i64 %38, i64* %37, align 8
  %39 = getelementptr { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = extractvalue { i64, i64 } %call40, 1
  store i64 %40, i64* %39, align 8
  %41 = bitcast %struct.timespec* %now to i8*
  %42 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %41, i8* %42, i64 16, i32 8, i1 false)
  %43 = load i64, i64* %time_limit.addr, align 8
  %44 = load i32, i32* %nsecs.addr, align 4
  %conv41 = sext i32 %44 to i64
  %call42 = call { i64, i64 } @make_timespec(i64 %43, i64 %conv41)
  %45 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %46 = getelementptr { i64, i64 }, { i64, i64 }* %45, i32 0, i32 0
  %47 = extractvalue { i64, i64 } %call42, 0
  store i64 %47, i64* %46, align 8
  %48 = getelementptr { i64, i64 }, { i64, i64 }* %45, i32 0, i32 1
  %49 = extractvalue { i64, i64 } %call42, 1
  store i64 %49, i64* %48, align 8
  %50 = bitcast %struct.timespec* %now to { i64, i64 }*
  %51 = getelementptr { i64, i64 }, { i64, i64 }* %50, i32 0, i32 0
  %52 = load i64, i64* %51, align 1
  %53 = getelementptr { i64, i64 }, { i64, i64 }* %50, i32 0, i32 1
  %54 = load i64, i64* %53, align 1
  %55 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %56 = getelementptr { i64, i64 }, { i64, i64 }* %55, i32 0, i32 0
  %57 = load i64, i64* %56, align 1
  %58 = getelementptr { i64, i64 }, { i64, i64 }* %55, i32 0, i32 1
  %59 = load i64, i64* %58, align 1
  %call43 = call { i64, i64 } @timespec_add(i64 %52, i64 %54, i64 %57, i64 %59) #11
  %60 = bitcast %struct.timespec* %coerce44 to { i64, i64 }*
  %61 = getelementptr { i64, i64 }, { i64, i64 }* %60, i32 0, i32 0
  %62 = extractvalue { i64, i64 } %call43, 0
  store i64 %62, i64* %61, align 8
  %63 = getelementptr { i64, i64 }, { i64, i64 }* %60, i32 0, i32 1
  %64 = extractvalue { i64, i64 } %call43, 1
  store i64 %64, i64* %63, align 8
  %65 = bitcast %struct.timespec* %end_time to i8*
  %66 = bitcast %struct.timespec* %coerce44 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %65, i8* %66, i64 16, i32 8, i1 false)
  br label %if.end.46

if.else.45:                                       ; preds = %lor.lhs.false.36
  store i32 1, i32* %wait, align 4
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.45, %if.then.39
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.46, %if.then.33
  br label %while.body

while.body:                                       ; preds = %if.end.47, %if.then.647, %for.end.893
  store i8 0, i8* %process_skipped, align 1
  %67 = load i32, i32* %read_kbd.addr, align 4
  %cmp48 = icmp sge i32 %67, 0
  br i1 %cmp48, label %if.then.50, label %if.else.66

if.then.50:                                       ; preds = %while.body
  br label %do.body.51

do.body.51:                                       ; preds = %if.then.50
  %68 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %68, %call52
  br i1 %cmp53, label %if.else.60, label %land.lhs.true.55

land.lhs.true.55:                                 ; preds = %do.body.51
  %69 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp57 = icmp eq i64 %69, %call56
  br i1 %cmp57, label %if.then.59, label %if.else.60

if.then.59:                                       ; preds = %land.lhs.true.55
  call void @process_quit_flag()
  br label %if.end.64

if.else.60:                                       ; preds = %land.lhs.true.55, %do.body.51
  %70 = load volatile i8, i8* @pending_signals, align 1
  %tobool61 = trunc i8 %70 to i1
  br i1 %tobool61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %if.else.60
  call void @process_pending_signals()
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.62, %if.else.60
  br label %if.end.64

if.end.64:                                        ; preds = %if.end.63, %if.then.59
  br label %do.end.65

do.end.65:                                        ; preds = %if.end.64
  br label %if.end.70

if.else.66:                                       ; preds = %while.body
  %71 = load volatile i8, i8* @pending_signals, align 1
  %tobool67 = trunc i8 %71 to i1
  br i1 %tobool67, label %if.then.68, label %if.end.69

if.then.68:                                       ; preds = %if.else.66
  call void @process_pending_signals()
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.68, %if.else.66
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.69, %do.end.65
  %72 = load i64, i64* %wait_for_cell.addr, align 8
  %call71 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp72 = icmp eq i64 %72, %call71
  br i1 %cmp72, label %if.end.81, label %land.lhs.true.74

land.lhs.true.74:                                 ; preds = %if.end.70
  %73 = load i64, i64* %wait_for_cell.addr, align 8
  %sub75 = sub nsw i64 %73, 3
  %74 = inttoptr i64 %sub75 to i8*
  %75 = bitcast i8* %74 to %struct.Lisp_Cons*
  %car76 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %75, i32 0, i32 0
  %76 = load i64, i64* %car76, align 8
  %call77 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp78 = icmp eq i64 %76, %call77
  br i1 %cmp78, label %if.end.81, label %if.then.80

if.then.80:                                       ; preds = %land.lhs.true.74
  br label %while.end.894

if.end.81:                                        ; preds = %land.lhs.true.74, %if.end.70
  %77 = load i32, i32* %wait, align 4
  %cmp82 = icmp eq i32 %77, 0
  br i1 %cmp82, label %if.then.84, label %if.else.97

if.then.84:                                       ; preds = %if.end.81
  %78 = bitcast %struct.timespec* %now to { i64, i64 }*
  %79 = getelementptr { i64, i64 }, { i64, i64 }* %78, i32 0, i32 0
  %80 = load i64, i64* %79, align 1
  %81 = getelementptr { i64, i64 }, { i64, i64 }* %78, i32 0, i32 1
  %82 = load i64, i64* %81, align 1
  %call85 = call zeroext i1 @timespec_valid_p(i64 %80, i64 %82)
  br i1 %call85, label %if.end.89, label %if.then.86

if.then.86:                                       ; preds = %if.then.84
  %call87 = call { i64, i64 } @current_timespec()
  %83 = bitcast %struct.timespec* %coerce88 to { i64, i64 }*
  %84 = getelementptr { i64, i64 }, { i64, i64 }* %83, i32 0, i32 0
  %85 = extractvalue { i64, i64 } %call87, 0
  store i64 %85, i64* %84, align 8
  %86 = getelementptr { i64, i64 }, { i64, i64 }* %83, i32 0, i32 1
  %87 = extractvalue { i64, i64 } %call87, 1
  store i64 %87, i64* %86, align 8
  %88 = bitcast %struct.timespec* %now to i8*
  %89 = bitcast %struct.timespec* %coerce88 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %88, i8* %89, i64 16, i32 8, i1 false)
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.86, %if.then.84
  %90 = bitcast %struct.timespec* %end_time to { i64, i64 }*
  %91 = getelementptr { i64, i64 }, { i64, i64 }* %90, i32 0, i32 0
  %92 = load i64, i64* %91, align 1
  %93 = getelementptr { i64, i64 }, { i64, i64 }* %90, i32 0, i32 1
  %94 = load i64, i64* %93, align 1
  %95 = bitcast %struct.timespec* %now to { i64, i64 }*
  %96 = getelementptr { i64, i64 }, { i64, i64 }* %95, i32 0, i32 0
  %97 = load i64, i64* %96, align 1
  %98 = getelementptr { i64, i64 }, { i64, i64 }* %95, i32 0, i32 1
  %99 = load i64, i64* %98, align 1
  %call90 = call i32 @timespec_cmp(i64 %92, i64 %94, i64 %97, i64 %99) #9
  %cmp91 = icmp sle i32 %call90, 0
  br i1 %cmp91, label %if.then.93, label %if.end.94

if.then.93:                                       ; preds = %if.end.89
  br label %while.end.894

if.end.94:                                        ; preds = %if.end.89
  %100 = bitcast %struct.timespec* %end_time to { i64, i64 }*
  %101 = getelementptr { i64, i64 }, { i64, i64 }* %100, i32 0, i32 0
  %102 = load i64, i64* %101, align 1
  %103 = getelementptr { i64, i64 }, { i64, i64 }* %100, i32 0, i32 1
  %104 = load i64, i64* %103, align 1
  %105 = bitcast %struct.timespec* %now to { i64, i64 }*
  %106 = getelementptr { i64, i64 }, { i64, i64 }* %105, i32 0, i32 0
  %107 = load i64, i64* %106, align 1
  %108 = getelementptr { i64, i64 }, { i64, i64 }* %105, i32 0, i32 1
  %109 = load i64, i64* %108, align 1
  %call95 = call { i64, i64 } @timespec_sub(i64 %102, i64 %104, i64 %107, i64 %109) #11
  %110 = bitcast %struct.timespec* %coerce96 to { i64, i64 }*
  %111 = getelementptr { i64, i64 }, { i64, i64 }* %110, i32 0, i32 0
  %112 = extractvalue { i64, i64 } %call95, 0
  store i64 %112, i64* %111, align 8
  %113 = getelementptr { i64, i64 }, { i64, i64 }* %110, i32 0, i32 1
  %114 = extractvalue { i64, i64 } %call95, 1
  store i64 %114, i64* %113, align 8
  %115 = bitcast %struct.timespec* %timeout to i8*
  %116 = bitcast %struct.timespec* %coerce96 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %115, i8* %116, i64 16, i32 8, i1 false)
  br label %if.end.103

if.else.97:                                       ; preds = %if.end.81
  %117 = load i32, i32* %wait, align 4
  %cmp98 = icmp slt i32 %117, 0
  %cond = select i1 %cmp98, i32 0, i32 100000
  %conv100 = sext i32 %cond to i64
  %call101 = call { i64, i64 } @make_timespec(i64 %conv100, i64 0)
  %118 = bitcast %struct.timespec* %coerce102 to { i64, i64 }*
  %119 = getelementptr { i64, i64 }, { i64, i64 }* %118, i32 0, i32 0
  %120 = extractvalue { i64, i64 } %call101, 0
  store i64 %120, i64* %119, align 8
  %121 = getelementptr { i64, i64 }, { i64, i64 }* %118, i32 0, i32 1
  %122 = extractvalue { i64, i64 } %call101, 1
  store i64 %122, i64* %121, align 8
  %123 = bitcast %struct.timespec* %timeout to i8*
  %124 = bitcast %struct.timespec* %coerce102 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %123, i8* %124, i64 16, i32 8, i1 false)
  br label %if.end.103

if.end.103:                                       ; preds = %if.else.97, %if.end.94
  %125 = load i64, i64* %wait_for_cell.addr, align 8
  %call104 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp105 = icmp eq i64 %125, %call104
  br i1 %cmp105, label %land.lhs.true.107, label %if.end.147

land.lhs.true.107:                                ; preds = %if.end.103
  %126 = load i32, i32* %just_wait_proc.addr, align 4
  %cmp108 = icmp sge i32 %126, 0
  br i1 %cmp108, label %if.then.110, label %if.end.147

if.then.110:                                      ; preds = %land.lhs.true.107
  br label %do.body.111

do.body.111:                                      ; preds = %do.cond, %if.then.110
  %127 = load i32, i32* @timers_run, align 4
  store i32 %127, i32* %old_timers_run, align 4
  %128 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %128, %struct.buffer** %old_buffer, align 8
  %129 = load i64, i64* @selected_window, align 8
  store i64 %129, i64* %old_window, align 8
  %call112 = call { i64, i64 } @timer_check()
  %130 = bitcast %struct.timespec* %coerce113 to { i64, i64 }*
  %131 = getelementptr { i64, i64 }, { i64, i64 }* %130, i32 0, i32 0
  %132 = extractvalue { i64, i64 } %call112, 0
  store i64 %132, i64* %131, align 8
  %133 = getelementptr { i64, i64 }, { i64, i64 }* %130, i32 0, i32 1
  %134 = extractvalue { i64, i64 } %call112, 1
  store i64 %134, i64* %133, align 8
  %135 = bitcast %struct.timespec* %timer_delay to i8*
  %136 = bitcast %struct.timespec* %coerce113 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %135, i8* %136, i64 16, i32 8, i1 false)
  %137 = load i32, i32* @timers_run, align 4
  %138 = load i32, i32* %old_timers_run, align 4
  %cmp114 = icmp ne i32 %137, %138
  br i1 %cmp114, label %land.lhs.true.116, label %if.end.126

land.lhs.true.116:                                ; preds = %do.body.111
  %139 = load %struct.buffer*, %struct.buffer** %old_buffer, align 8
  %140 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp117 = icmp ne %struct.buffer* %139, %140
  br i1 %cmp117, label %land.lhs.true.122, label %lor.lhs.false.119

lor.lhs.false.119:                                ; preds = %land.lhs.true.116
  %141 = load i64, i64* %old_window, align 8
  %142 = load i64, i64* @selected_window, align 8
  %cmp120 = icmp eq i64 %141, %142
  br i1 %cmp120, label %if.end.126, label %land.lhs.true.122

land.lhs.true.122:                                ; preds = %lor.lhs.false.119, %land.lhs.true.116
  %143 = load i32, i32* @waiting_for_user_input_p, align 4
  %cmp123 = icmp eq i32 %143, -1
  br i1 %cmp123, label %if.then.125, label %if.end.126

if.then.125:                                      ; preds = %land.lhs.true.122
  call void @record_asynch_buffer_change()
  br label %if.end.126

if.end.126:                                       ; preds = %if.then.125, %land.lhs.true.122, %lor.lhs.false.119, %do.body.111
  %144 = load i32, i32* @timers_run, align 4
  %145 = load i32, i32* %old_timers_run, align 4
  %cmp127 = icmp ne i32 %144, %145
  br i1 %cmp127, label %land.lhs.true.129, label %if.else.133

land.lhs.true.129:                                ; preds = %if.end.126
  %146 = load i8, i8* %do_display.addr, align 1
  %tobool130 = trunc i8 %146 to i1
  br i1 %tobool130, label %if.then.132, label %if.else.133

if.then.132:                                      ; preds = %land.lhs.true.129
  call void @redisplay_preserve_echo_area(i32 9)
  br label %if.end.134

if.else.133:                                      ; preds = %land.lhs.true.129, %if.end.126
  br label %do.end.136

if.end.134:                                       ; preds = %if.then.132
  br label %do.cond

do.cond:                                          ; preds = %if.end.134
  %call135 = call zeroext i1 @detect_input_pending()
  %lnot = xor i1 %call135, true
  br i1 %lnot, label %do.body.111, label %do.end.136

do.end.136:                                       ; preds = %do.cond, %if.else.133
  %147 = load i32, i32* %read_kbd.addr, align 4
  %cmp137 = icmp ne i32 %147, 0
  br i1 %cmp137, label %land.lhs.true.139, label %if.end.143

land.lhs.true.139:                                ; preds = %do.end.136
  %call140 = call zeroext i1 @requeued_events_pending_p()
  br i1 %call140, label %if.then.142, label %if.end.143

if.then.142:                                      ; preds = %land.lhs.true.139
  br label %while.end.894

if.end.143:                                       ; preds = %land.lhs.true.139, %do.end.136
  %148 = bitcast %struct.timespec* %timer_delay to { i64, i64 }*
  %149 = getelementptr { i64, i64 }, { i64, i64 }* %148, i32 0, i32 0
  %150 = load i64, i64* %149, align 1
  %151 = getelementptr { i64, i64 }, { i64, i64 }* %148, i32 0, i32 1
  %152 = load i64, i64* %151, align 1
  %call144 = call zeroext i1 @timespec_valid_p(i64 %150, i64 %152)
  br i1 %call144, label %if.end.146, label %if.then.145

if.then.145:                                      ; preds = %if.end.143
  call void @wait_reading_process_output_1()
  br label %if.end.146

if.end.146:                                       ; preds = %if.then.145, %if.end.143
  br label %if.end.147

if.end.147:                                       ; preds = %if.end.146, %land.lhs.true.107, %if.end.103
  %153 = load i32, i32* %read_kbd.addr, align 4
  %cmp148 = icmp slt i32 %153, 0
  br i1 %cmp148, label %if.then.150, label %if.end.151

if.then.150:                                      ; preds = %if.end.147
  call void @set_waiting_for_input(%struct.timespec* %timeout)
  br label %if.end.151

if.end.151:                                       ; preds = %if.then.150, %if.end.147
  %154 = load i64, i64* @update_tick, align 8
  %155 = load i64, i64* @process_tick, align 8
  %cmp152 = icmp ne i64 %154, %155
  br i1 %cmp152, label %if.then.154, label %if.end.188

if.then.154:                                      ; preds = %if.end.151
  %call155 = call zeroext i1 @kbd_on_hold_p()
  br i1 %call155, label %if.then.156, label %if.else.166

if.then.156:                                      ; preds = %if.then.154
  br label %do.body.157

do.body.157:                                      ; preds = %if.then.156
  %fds_bits160 = getelementptr inbounds %struct.fd_set, %struct.fd_set* %Atemp, i32 0, i32 0
  %arrayidx161 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits160, i32 0, i64 0
  %156 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx161) #5, !srcloc !4
  %asmresult162 = extractvalue { i64, i64* } %156, 0
  %asmresult163 = extractvalue { i64, i64* } %156, 1
  %157 = trunc i64 %asmresult162 to i32
  store i32 %157, i32* %__d0158, align 4
  %158 = ptrtoint i64* %asmresult163 to i64
  %159 = trunc i64 %158 to i32
  store i32 %159, i32* %__d1159, align 4
  br label %do.end.165

do.end.165:                                       ; preds = %do.body.157
  br label %if.end.167

if.else.166:                                      ; preds = %if.then.154
  %160 = bitcast %struct.fd_set* %Atemp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %160, i8* bitcast (%struct.fd_set* @input_wait_mask to i8*), i64 128, i32 8, i1 false)
  br label %if.end.167

if.end.167:                                       ; preds = %if.else.166, %do.end.165
  %161 = bitcast %struct.fd_set* %Ctemp to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %161, i8* bitcast (%struct.fd_set* @write_mask to i8*), i64 128, i32 8, i1 false)
  %call168 = call { i64, i64 } @make_timespec(i64 0, i64 0)
  %162 = bitcast %struct.timespec* %coerce169 to { i64, i64 }*
  %163 = getelementptr { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = extractvalue { i64, i64 } %call168, 0
  store i64 %164, i64* %163, align 8
  %165 = getelementptr { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = extractvalue { i64, i64 } %call168, 1
  store i64 %166, i64* %165, align 8
  %167 = bitcast %struct.timespec* %timeout to i8*
  %168 = bitcast %struct.timespec* %coerce169 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %167, i8* %168, i64 16, i32 8, i1 false)
  %169 = load i32, i32* @max_process_desc, align 4
  %170 = load i32, i32* @max_input_desc, align 4
  %cmp170 = icmp sgt i32 %169, %170
  br i1 %cmp170, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.167
  %171 = load i32, i32* @max_process_desc, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end.167
  %172 = load i32, i32* @max_input_desc, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond172 = phi i32 [ %171, %cond.true ], [ %172, %cond.false ]
  %add = add nsw i32 %cond172, 1
  %173 = load i32, i32* @num_pending_connects, align 4
  %cmp173 = icmp sgt i32 %173, 0
  br i1 %cmp173, label %cond.true.175, label %cond.false.176

cond.true.175:                                    ; preds = %cond.end
  br label %cond.end.177

cond.false.176:                                   ; preds = %cond.end
  br label %cond.end.177

cond.end.177:                                     ; preds = %cond.false.176, %cond.true.175
  %cond178 = phi %struct.fd_set* [ %Ctemp, %cond.true.175 ], [ null, %cond.false.176 ]
  %call179 = call i32 @pselect(i32 %add, %struct.fd_set* %Atemp, %struct.fd_set* %cond178, %struct.fd_set* null, %struct.timespec* %timeout, %struct.__sigset_t* null)
  %cmp180 = icmp sle i32 %call179, 0
  br i1 %cmp180, label %if.then.182, label %if.end.187

if.then.182:                                      ; preds = %cond.end.177
  call void @clear_waiting_for_input()
  %174 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %call183 = call i32 @status_notify(%struct.Lisp_Process* null, %struct.Lisp_Process* %174)
  store i32 %call183, i32* %got_some_output, align 4
  %175 = load i8, i8* %do_display.addr, align 1
  %tobool184 = trunc i8 %175 to i1
  br i1 %tobool184, label %if.then.185, label %if.end.186

if.then.185:                                      ; preds = %if.then.182
  call void @redisplay_preserve_echo_area(i32 13)
  br label %if.end.186

if.end.186:                                       ; preds = %if.then.185, %if.then.182
  br label %if.end.187

if.end.187:                                       ; preds = %if.end.186, %cond.end.177
  br label %if.end.188

if.end.188:                                       ; preds = %if.end.187, %if.end.151
  %176 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool189 = icmp ne %struct.Lisp_Process* %176, null
  br i1 %tobool189, label %land.lhs.true.190, label %if.end.193

land.lhs.true.190:                                ; preds = %if.end.188
  %177 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %177, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then.192, label %if.end.193

if.then.192:                                      ; preds = %land.lhs.true.190
  %178 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  call void @update_status(%struct.Lisp_Process* %178)
  br label %if.end.193

if.end.193:                                       ; preds = %if.then.192, %land.lhs.true.190, %if.end.188
  %179 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool194 = icmp ne %struct.Lisp_Process* %179, null
  br i1 %tobool194, label %land.lhs.true.195, label %if.end.249

land.lhs.true.195:                                ; preds = %if.end.193
  %180 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %status196 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %180, i32 0, i32 12
  %181 = load i64, i64* %status196, align 8
  %call197 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp198 = icmp eq i64 %181, %call197
  br i1 %cmp198, label %if.end.249, label %land.lhs.true.200

land.lhs.true.200:                                ; preds = %land.lhs.true.195
  %182 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %status201 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %182, i32 0, i32 12
  %183 = load i64, i64* %status201, align 8
  %call202 = call i64 @builtin_lisp_symbol(i32 293)
  %cmp203 = icmp eq i64 %183, %call202
  br i1 %cmp203, label %if.end.249, label %if.then.205

if.then.205:                                      ; preds = %land.lhs.true.200
  store i8 0, i8* %read_some_bytes, align 1
  call void @clear_waiting_for_input()
  %184 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %184, i32 0, i32 21
  %185 = load i32, i32* %infd, align 4
  %cmp206 = icmp sge i32 %185, 0
  br i1 %cmp206, label %if.then.208, label %if.end.241

if.then.208:                                      ; preds = %if.then.205
  %186 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %187 = bitcast %struct.Lisp_Process* %186 to i8*
  %call209 = call i64 @make_lisp_ptr(i8* %187, i32 5)
  store i64 %call209, i64* %proc, align 8
  br label %while.body.211

while.body.211:                                   ; preds = %if.then.208, %if.end.240
  %188 = load i64, i64* %proc, align 8
  %189 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %infd212 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %189, i32 0, i32 21
  %190 = load i32, i32* %infd212, align 4
  %call213 = call i32 @read_process_output(i64 %188, i32 %190)
  store i32 %call213, i32* %nread, align 4
  %191 = load i32, i32* %nread, align 4
  %cmp214 = icmp slt i32 %191, 0
  br i1 %cmp214, label %if.then.216, label %if.else.231

if.then.216:                                      ; preds = %while.body.211
  %call217 = call i32* @__errno_location() #11
  %192 = load i32, i32* %call217, align 4
  %cmp218 = icmp eq i32 %192, 5
  br i1 %cmp218, label %if.then.224, label %lor.lhs.false.220

lor.lhs.false.220:                                ; preds = %if.then.216
  %call221 = call i32* @__errno_location() #11
  %193 = load i32, i32* %call221, align 4
  %cmp222 = icmp eq i32 %193, 11
  br i1 %cmp222, label %if.then.224, label %if.end.225

if.then.224:                                      ; preds = %lor.lhs.false.220, %if.then.216
  br label %while.end

if.end.225:                                       ; preds = %lor.lhs.false.220
  %call226 = call i32* @__errno_location() #11
  %194 = load i32, i32* %call226, align 4
  %cmp227 = icmp eq i32 %194, 11
  br i1 %cmp227, label %if.then.229, label %if.end.230

if.then.229:                                      ; preds = %if.end.225
  br label %while.end

if.end.230:                                       ; preds = %if.end.225
  br label %if.end.240

if.else.231:                                      ; preds = %while.body.211
  %195 = load i32, i32* %got_some_output, align 4
  %196 = load i32, i32* %nread, align 4
  %cmp232 = icmp slt i32 %195, %196
  br i1 %cmp232, label %if.then.234, label %if.end.235

if.then.234:                                      ; preds = %if.else.231
  %197 = load i32, i32* %nread, align 4
  store i32 %197, i32* %got_some_output, align 4
  br label %if.end.235

if.end.235:                                       ; preds = %if.then.234, %if.else.231
  %198 = load i32, i32* %nread, align 4
  %cmp236 = icmp eq i32 %198, 0
  br i1 %cmp236, label %if.then.238, label %if.end.239

if.then.238:                                      ; preds = %if.end.235
  br label %while.end

if.end.239:                                       ; preds = %if.end.235
  store i8 1, i8* %read_some_bytes, align 1
  br label %if.end.240

if.end.240:                                       ; preds = %if.end.239, %if.end.230
  br label %while.body.211

while.end:                                        ; preds = %if.then.238, %if.then.229, %if.then.224
  br label %if.end.241

if.end.241:                                       ; preds = %while.end, %if.then.205
  %199 = load i8, i8* %read_some_bytes, align 1
  %tobool242 = trunc i8 %199 to i1
  br i1 %tobool242, label %land.lhs.true.244, label %if.end.248

land.lhs.true.244:                                ; preds = %if.end.241
  %200 = load i8, i8* %do_display.addr, align 1
  %tobool245 = trunc i8 %200 to i1
  br i1 %tobool245, label %if.then.247, label %if.end.248

if.then.247:                                      ; preds = %land.lhs.true.244
  call void @redisplay_preserve_echo_area(i32 10)
  br label %if.end.248

if.end.248:                                       ; preds = %if.then.247, %land.lhs.true.244, %if.end.241
  br label %while.end.894

if.end.249:                                       ; preds = %land.lhs.true.200, %land.lhs.true.195, %if.end.193
  %201 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool250 = icmp ne %struct.Lisp_Process* %201, null
  br i1 %tobool250, label %land.lhs.true.251, label %if.else.260

land.lhs.true.251:                                ; preds = %if.end.249
  %202 = load i32, i32* %just_wait_proc.addr, align 4
  %tobool252 = icmp ne i32 %202, 0
  br i1 %tobool252, label %if.then.253, label %if.else.260

if.then.253:                                      ; preds = %land.lhs.true.251
  %203 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %infd254 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %203, i32 0, i32 21
  %204 = load i32, i32* %infd254, align 4
  %cmp255 = icmp slt i32 %204, 0
  br i1 %cmp255, label %if.then.257, label %if.end.258

if.then.257:                                      ; preds = %if.then.253
  br label %while.end.894

if.end.258:                                       ; preds = %if.then.253
  %205 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %infd259 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %205, i32 0, i32 21
  %206 = load i32, i32* %infd259, align 4
  call void @fd_SET(i32 %206, %struct.fd_set* %Available)
  store i32 0, i32* %check_delay, align 4
  store i8 0, i8* %check_write, align 1
  br label %if.end.276

if.else.260:                                      ; preds = %land.lhs.true.251, %if.end.249
  %207 = load i64, i64* %wait_for_cell.addr, align 8
  %call261 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp262 = icmp eq i64 %207, %call261
  br i1 %cmp262, label %if.else.265, label %if.then.264

if.then.264:                                      ; preds = %if.else.260
  %208 = bitcast %struct.fd_set* %Available to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %208, i8* bitcast (%struct.fd_set* @non_process_wait_mask to i8*), i64 128, i32 8, i1 false)
  store i32 0, i32* %check_delay, align 4
  store i8 0, i8* %check_write, align 1
  br label %if.end.275

if.else.265:                                      ; preds = %if.else.260
  %209 = load i32, i32* %read_kbd.addr, align 4
  %tobool266 = icmp ne i32 %209, 0
  br i1 %tobool266, label %if.else.268, label %if.then.267

if.then.267:                                      ; preds = %if.else.265
  %210 = bitcast %struct.fd_set* %Available to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %210, i8* bitcast (%struct.fd_set* @non_keyboard_wait_mask to i8*), i64 128, i32 8, i1 false)
  br label %if.end.269

if.else.268:                                      ; preds = %if.else.265
  %211 = bitcast %struct.fd_set* %Available to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %211, i8* bitcast (%struct.fd_set* @input_wait_mask to i8*), i64 128, i32 8, i1 false)
  br label %if.end.269

if.end.269:                                       ; preds = %if.else.268, %if.then.267
  %212 = bitcast %struct.fd_set* %Writeok to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %212, i8* bitcast (%struct.fd_set* @write_mask to i8*), i64 128, i32 8, i1 false)
  %213 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool270 = icmp ne %struct.Lisp_Process* %213, null
  br i1 %tobool270, label %cond.true.271, label %cond.false.272

cond.true.271:                                    ; preds = %if.end.269
  br label %cond.end.273

cond.false.272:                                   ; preds = %if.end.269
  %214 = load i32, i32* @process_output_delay_count, align 4
  br label %cond.end.273

cond.end.273:                                     ; preds = %cond.false.272, %cond.true.271
  %cond274 = phi i32 [ 0, %cond.true.271 ], [ %214, %cond.false.272 ]
  store i32 %cond274, i32* %check_delay, align 4
  store i8 1, i8* %check_write, align 1
  br label %if.end.275

if.end.275:                                       ; preds = %cond.end.273, %if.then.264
  br label %if.end.276

if.end.276:                                       ; preds = %if.end.275, %if.end.258
  %215 = load i8, i8* @frame_garbaged, align 1
  %tobool277 = trunc i8 %215 to i1
  br i1 %tobool277, label %land.lhs.true.279, label %if.end.287

land.lhs.true.279:                                ; preds = %if.end.276
  %216 = load i8, i8* %do_display.addr, align 1
  %tobool280 = trunc i8 %216 to i1
  br i1 %tobool280, label %if.then.282, label %if.end.287

if.then.282:                                      ; preds = %land.lhs.true.279
  call void @clear_waiting_for_input()
  call void @redisplay_preserve_echo_area(i32 11)
  %217 = load i32, i32* %read_kbd.addr, align 4
  %cmp283 = icmp slt i32 %217, 0
  br i1 %cmp283, label %if.then.285, label %if.end.286

if.then.285:                                      ; preds = %if.then.282
  call void @set_waiting_for_input(%struct.timespec* %timeout)
  br label %if.end.286

if.end.286:                                       ; preds = %if.then.285, %if.then.282
  br label %if.end.287

if.end.287:                                       ; preds = %if.end.286, %land.lhs.true.279, %if.end.276
  store i8 0, i8* %no_avail, align 1
  %218 = load i32, i32* %read_kbd.addr, align 4
  %tobool288 = icmp ne i32 %218, 0
  br i1 %tobool288, label %land.lhs.true.293, label %lor.lhs.false.289

lor.lhs.false.289:                                ; preds = %if.end.287
  %219 = load i64, i64* %wait_for_cell.addr, align 8
  %call290 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp291 = icmp eq i64 %219, %call290
  br i1 %cmp291, label %if.else.308, label %land.lhs.true.293

land.lhs.true.293:                                ; preds = %lor.lhs.false.289, %if.end.287
  %call294 = call zeroext i1 @detect_input_pending()
  br i1 %call294, label %if.then.296, label %if.else.308

if.then.296:                                      ; preds = %land.lhs.true.293
  %220 = load i32, i32* %read_kbd.addr, align 4
  %tobool297 = icmp ne i32 %220, 0
  %cond298 = select i1 %tobool297, i32 0, i32 1
  store i32 %cond298, i32* %nfds, align 4
  store i8 1, i8* %no_avail, align 1
  br label %do.body.299

do.body.299:                                      ; preds = %if.then.296
  %fds_bits302 = getelementptr inbounds %struct.fd_set, %struct.fd_set* %Available, i32 0, i32 0
  %arrayidx303 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits302, i32 0, i64 0
  %221 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx303) #5, !srcloc !5
  %asmresult304 = extractvalue { i64, i64* } %221, 0
  %asmresult305 = extractvalue { i64, i64* } %221, 1
  %222 = trunc i64 %asmresult304 to i32
  store i32 %222, i32* %__d0300, align 4
  %223 = ptrtoint i64* %asmresult305 to i64
  %224 = trunc i64 %223 to i32
  store i32 %224, i32* %__d1301, align 4
  br label %do.end.307

do.end.307:                                       ; preds = %do.body.299
  br label %if.end.503

if.else.308:                                      ; preds = %land.lhs.true.293, %lor.lhs.false.289
  %225 = load i8, i8* @process_output_skip, align 1
  %tobool309 = trunc i8 %225 to i1
  br i1 %tobool309, label %land.lhs.true.311, label %if.end.359

land.lhs.true.311:                                ; preds = %if.else.308
  %226 = load i32, i32* %check_delay, align 4
  %cmp312 = icmp sgt i32 %226, 0
  br i1 %cmp312, label %if.then.314, label %if.end.359

if.then.314:                                      ; preds = %land.lhs.true.311
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 1
  %227 = load i64, i64* %tv_nsec, align 8
  %conv315 = trunc i64 %227 to i32
  store i32 %conv315, i32* %adaptive_nsecs, align 4
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 0
  %228 = load i64, i64* %tv_sec, align 8
  %cmp316 = icmp sgt i64 %228, 0
  br i1 %cmp316, label %if.then.321, label %lor.lhs.false.318

lor.lhs.false.318:                                ; preds = %if.then.314
  %229 = load i32, i32* %adaptive_nsecs, align 4
  %cmp319 = icmp sgt i32 %229, 50000000
  br i1 %cmp319, label %if.then.321, label %if.end.322

if.then.321:                                      ; preds = %lor.lhs.false.318, %if.then.314
  store i32 50000000, i32* %adaptive_nsecs, align 4
  br label %if.end.322

if.end.322:                                       ; preds = %if.then.321, %lor.lhs.false.318
  store i32 0, i32* %channel, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.322
  %230 = load i32, i32* %check_delay, align 4
  %cmp323 = icmp sgt i32 %230, 0
  br i1 %cmp323, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %231 = load i32, i32* %channel, align 4
  %232 = load i32, i32* @max_process_desc, align 4
  %cmp325 = icmp sle i32 %231, %232
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %233 = phi i1 [ false, %for.cond ], [ %cmp325, %land.rhs ]
  br i1 %233, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %234 = load i32, i32* %channel, align 4
  %idxprom = sext i32 %234 to i64
  %arrayidx327 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  %235 = load i64, i64* %arrayidx327, align 8
  store i64 %235, i64* %proc, align 8
  %236 = load i64, i64* %proc, align 8
  %call328 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp329 = icmp eq i64 %236, %call328
  br i1 %cmp329, label %if.then.331, label %if.end.332

if.then.331:                                      ; preds = %for.body
  br label %for.inc

if.end.332:                                       ; preds = %for.body
  %237 = load i64, i64* %proc, align 8
  %call333 = call %struct.Lisp_Process* @XPROCESS(i64 %237)
  %read_output_delay = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call333, i32 0, i32 27
  %238 = load i32, i32* %read_output_delay, align 4
  %cmp334 = icmp sgt i32 %238, 0
  br i1 %cmp334, label %if.then.336, label %if.end.355

if.then.336:                                      ; preds = %if.end.332
  %239 = load i32, i32* %check_delay, align 4
  %dec = add nsw i32 %239, -1
  store i32 %dec, i32* %check_delay, align 4
  %240 = load i64, i64* %proc, align 8
  %call337 = call %struct.Lisp_Process* @XPROCESS(i64 %240)
  %read_output_skip = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call337, i32 0, i32 28
  %bf.load338 = load i8, i8* %read_output_skip, align 8
  %bf.lshr339 = lshr i8 %bf.load338, 2
  %bf.clear = and i8 %bf.lshr339, 1
  %bf.cast340 = trunc i8 %bf.clear to i1
  br i1 %bf.cast340, label %if.end.342, label %if.then.341

if.then.341:                                      ; preds = %if.then.336
  br label %for.inc

if.end.342:                                       ; preds = %if.then.336
  %241 = load i32, i32* %channel, align 4
  call void @fd_CLR(i32 %241, %struct.fd_set* %Available)
  store i8 1, i8* %process_skipped, align 1
  %242 = load i64, i64* %proc, align 8
  %call343 = call %struct.Lisp_Process* @XPROCESS(i64 %242)
  %read_output_skip344 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call343, i32 0, i32 28
  %bf.load345 = load i8, i8* %read_output_skip344, align 8
  %bf.clear346 = and i8 %bf.load345, -5
  store i8 %bf.clear346, i8* %read_output_skip344, align 8
  %243 = load i64, i64* %proc, align 8
  %call347 = call %struct.Lisp_Process* @XPROCESS(i64 %243)
  %read_output_delay348 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call347, i32 0, i32 27
  %244 = load i32, i32* %read_output_delay348, align 4
  %245 = load i32, i32* %adaptive_nsecs, align 4
  %cmp349 = icmp slt i32 %244, %245
  br i1 %cmp349, label %if.then.351, label %if.end.354

if.then.351:                                      ; preds = %if.end.342
  %246 = load i64, i64* %proc, align 8
  %call352 = call %struct.Lisp_Process* @XPROCESS(i64 %246)
  %read_output_delay353 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call352, i32 0, i32 27
  %247 = load i32, i32* %read_output_delay353, align 4
  store i32 %247, i32* %adaptive_nsecs, align 4
  br label %if.end.354

if.end.354:                                       ; preds = %if.then.351, %if.end.342
  br label %if.end.355

if.end.355:                                       ; preds = %if.end.354, %if.end.332
  br label %for.inc

for.inc:                                          ; preds = %if.end.355, %if.then.341, %if.then.331
  %248 = load i32, i32* %channel, align 4
  %inc = add nsw i32 %248, 1
  store i32 %inc, i32* %channel, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %249 = load i32, i32* %adaptive_nsecs, align 4
  %conv356 = sext i32 %249 to i64
  %call357 = call { i64, i64 } @make_timespec(i64 0, i64 %conv356)
  %250 = bitcast %struct.timespec* %coerce358 to { i64, i64 }*
  %251 = getelementptr { i64, i64 }, { i64, i64 }* %250, i32 0, i32 0
  %252 = extractvalue { i64, i64 } %call357, 0
  store i64 %252, i64* %251, align 8
  %253 = getelementptr { i64, i64 }, { i64, i64 }* %250, i32 0, i32 1
  %254 = extractvalue { i64, i64 } %call357, 1
  store i64 %254, i64* %253, align 8
  %255 = bitcast %struct.timespec* %timeout to i8*
  %256 = bitcast %struct.timespec* %coerce358 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %255, i8* %256, i64 16, i32 8, i1 false)
  store i8 0, i8* @process_output_skip, align 1
  br label %if.end.359

if.end.359:                                       ; preds = %for.end, %land.lhs.true.311, %if.else.308
  %257 = load i32, i32* %got_some_output, align 4
  %cmp360 = icmp sgt i32 %257, 0
  br i1 %cmp360, label %land.lhs.true.362, label %if.end.374

land.lhs.true.362:                                ; preds = %if.end.359
  %258 = load i8, i8* %process_skipped, align 1
  %tobool363 = trunc i8 %258 to i1
  br i1 %tobool363, label %if.end.374, label %land.lhs.true.364

land.lhs.true.364:                                ; preds = %land.lhs.true.362
  %tv_sec365 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 0
  %259 = load i64, i64* %tv_sec365, align 8
  %tobool366 = icmp ne i64 %259, 0
  br i1 %tobool366, label %if.then.371, label %lor.lhs.false.367

lor.lhs.false.367:                                ; preds = %land.lhs.true.364
  %tv_nsec368 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 1
  %260 = load i64, i64* %tv_nsec368, align 8
  %cmp369 = icmp sgt i64 %260, 10000000
  br i1 %cmp369, label %if.then.371, label %if.end.374

if.then.371:                                      ; preds = %lor.lhs.false.367, %land.lhs.true.364
  %call372 = call { i64, i64 } @make_timespec(i64 0, i64 10000000)
  %261 = bitcast %struct.timespec* %coerce373 to { i64, i64 }*
  %262 = getelementptr { i64, i64 }, { i64, i64 }* %261, i32 0, i32 0
  %263 = extractvalue { i64, i64 } %call372, 0
  store i64 %263, i64* %262, align 8
  %264 = getelementptr { i64, i64 }, { i64, i64 }* %261, i32 0, i32 1
  %265 = extractvalue { i64, i64 } %call372, 1
  store i64 %265, i64* %264, align 8
  %266 = bitcast %struct.timespec* %timeout to i8*
  %267 = bitcast %struct.timespec* %coerce373 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %266, i8* %267, i64 16, i32 8, i1 false)
  br label %if.end.374

if.end.374:                                       ; preds = %if.then.371, %lor.lhs.false.367, %land.lhs.true.362, %if.end.359
  %268 = load i64, i64* %wait_for_cell.addr, align 8
  %call375 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp376 = icmp eq i64 %268, %call375
  br i1 %cmp376, label %land.lhs.true.378, label %if.else.402

land.lhs.true.378:                                ; preds = %if.end.374
  %269 = load i32, i32* %just_wait_proc.addr, align 4
  %cmp379 = icmp sge i32 %269, 0
  br i1 %cmp379, label %land.lhs.true.381, label %if.else.402

land.lhs.true.381:                                ; preds = %land.lhs.true.378
  %270 = bitcast %struct.timespec* %timer_delay to { i64, i64 }*
  %271 = getelementptr { i64, i64 }, { i64, i64 }* %270, i32 0, i32 0
  %272 = load i64, i64* %271, align 1
  %273 = getelementptr { i64, i64 }, { i64, i64 }* %270, i32 0, i32 1
  %274 = load i64, i64* %273, align 1
  %call382 = call zeroext i1 @timespec_valid_p(i64 %272, i64 %274)
  br i1 %call382, label %land.lhs.true.384, label %if.else.402

land.lhs.true.384:                                ; preds = %land.lhs.true.381
  %275 = bitcast %struct.timespec* %timer_delay to { i64, i64 }*
  %276 = getelementptr { i64, i64 }, { i64, i64 }* %275, i32 0, i32 0
  %277 = load i64, i64* %276, align 1
  %278 = getelementptr { i64, i64 }, { i64, i64 }* %275, i32 0, i32 1
  %279 = load i64, i64* %278, align 1
  %280 = bitcast %struct.timespec* %timeout to { i64, i64 }*
  %281 = getelementptr { i64, i64 }, { i64, i64 }* %280, i32 0, i32 0
  %282 = load i64, i64* %281, align 1
  %283 = getelementptr { i64, i64 }, { i64, i64 }* %280, i32 0, i32 1
  %284 = load i64, i64* %283, align 1
  %call385 = call i32 @timespec_cmp(i64 %277, i64 %279, i64 %282, i64 %284) #9
  %cmp386 = icmp slt i32 %call385, 0
  br i1 %cmp386, label %if.then.388, label %if.else.402

if.then.388:                                      ; preds = %land.lhs.true.384
  %285 = bitcast %struct.timespec* %now to { i64, i64 }*
  %286 = getelementptr { i64, i64 }, { i64, i64 }* %285, i32 0, i32 0
  %287 = load i64, i64* %286, align 1
  %288 = getelementptr { i64, i64 }, { i64, i64 }* %285, i32 0, i32 1
  %289 = load i64, i64* %288, align 1
  %call389 = call zeroext i1 @timespec_valid_p(i64 %287, i64 %289)
  br i1 %call389, label %if.end.393, label %if.then.390

if.then.390:                                      ; preds = %if.then.388
  %call391 = call { i64, i64 } @current_timespec()
  %290 = bitcast %struct.timespec* %coerce392 to { i64, i64 }*
  %291 = getelementptr { i64, i64 }, { i64, i64 }* %290, i32 0, i32 0
  %292 = extractvalue { i64, i64 } %call391, 0
  store i64 %292, i64* %291, align 8
  %293 = getelementptr { i64, i64 }, { i64, i64 }* %290, i32 0, i32 1
  %294 = extractvalue { i64, i64 } %call391, 1
  store i64 %294, i64* %293, align 8
  %295 = bitcast %struct.timespec* %now to i8*
  %296 = bitcast %struct.timespec* %coerce392 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %295, i8* %296, i64 16, i32 8, i1 false)
  br label %if.end.393

if.end.393:                                       ; preds = %if.then.390, %if.then.388
  %297 = bitcast %struct.timespec* %now to { i64, i64 }*
  %298 = getelementptr { i64, i64 }, { i64, i64 }* %297, i32 0, i32 0
  %299 = load i64, i64* %298, align 1
  %300 = getelementptr { i64, i64 }, { i64, i64 }* %297, i32 0, i32 1
  %301 = load i64, i64* %300, align 1
  %302 = bitcast %struct.timespec* %timeout to { i64, i64 }*
  %303 = getelementptr { i64, i64 }, { i64, i64 }* %302, i32 0, i32 0
  %304 = load i64, i64* %303, align 1
  %305 = getelementptr { i64, i64 }, { i64, i64 }* %302, i32 0, i32 1
  %306 = load i64, i64* %305, align 1
  %call394 = call { i64, i64 } @timespec_add(i64 %299, i64 %301, i64 %304, i64 %306) #11
  %307 = bitcast %struct.timespec* %timeout_abs to { i64, i64 }*
  %308 = getelementptr { i64, i64 }, { i64, i64 }* %307, i32 0, i32 0
  %309 = extractvalue { i64, i64 } %call394, 0
  store i64 %309, i64* %308, align 8
  %310 = getelementptr { i64, i64 }, { i64, i64 }* %307, i32 0, i32 1
  %311 = extractvalue { i64, i64 } %call394, 1
  store i64 %311, i64* %310, align 8
  %312 = bitcast %struct.timespec* %got_output_end_time to { i64, i64 }*
  %313 = getelementptr { i64, i64 }, { i64, i64 }* %312, i32 0, i32 0
  %314 = load i64, i64* %313, align 1
  %315 = getelementptr { i64, i64 }, { i64, i64 }* %312, i32 0, i32 1
  %316 = load i64, i64* %315, align 1
  %call395 = call zeroext i1 @timespec_valid_p(i64 %314, i64 %316)
  br i1 %call395, label %lor.lhs.false.396, label %if.then.400

lor.lhs.false.396:                                ; preds = %if.end.393
  %317 = bitcast %struct.timespec* %timeout_abs to { i64, i64 }*
  %318 = getelementptr { i64, i64 }, { i64, i64 }* %317, i32 0, i32 0
  %319 = load i64, i64* %318, align 1
  %320 = getelementptr { i64, i64 }, { i64, i64 }* %317, i32 0, i32 1
  %321 = load i64, i64* %320, align 1
  %322 = bitcast %struct.timespec* %got_output_end_time to { i64, i64 }*
  %323 = getelementptr { i64, i64 }, { i64, i64 }* %322, i32 0, i32 0
  %324 = load i64, i64* %323, align 1
  %325 = getelementptr { i64, i64 }, { i64, i64 }* %322, i32 0, i32 1
  %326 = load i64, i64* %325, align 1
  %call397 = call i32 @timespec_cmp(i64 %319, i64 %321, i64 %324, i64 %326) #9
  %cmp398 = icmp slt i32 %call397, 0
  br i1 %cmp398, label %if.then.400, label %if.end.401

if.then.400:                                      ; preds = %lor.lhs.false.396, %if.end.393
  %327 = bitcast %struct.timespec* %got_output_end_time to i8*
  %328 = bitcast %struct.timespec* %timeout_abs to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %327, i8* %328, i64 16, i32 8, i1 false)
  br label %if.end.401

if.end.401:                                       ; preds = %if.then.400, %lor.lhs.false.396
  %329 = bitcast %struct.timespec* %timeout to i8*
  %330 = bitcast %struct.timespec* %timer_delay to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %329, i8* %330, i64 16, i32 8, i1 false)
  br label %if.end.405

if.else.402:                                      ; preds = %land.lhs.true.384, %land.lhs.true.381, %land.lhs.true.378, %if.end.374
  %call403 = call { i64, i64 } @invalid_timespec()
  %331 = bitcast %struct.timespec* %coerce404 to { i64, i64 }*
  %332 = getelementptr { i64, i64 }, { i64, i64 }* %331, i32 0, i32 0
  %333 = extractvalue { i64, i64 } %call403, 0
  store i64 %333, i64* %332, align 8
  %334 = getelementptr { i64, i64 }, { i64, i64 }* %331, i32 0, i32 1
  %335 = extractvalue { i64, i64 } %call403, 1
  store i64 %335, i64* %334, align 8
  %336 = bitcast %struct.timespec* %got_output_end_time to i8*
  %337 = bitcast %struct.timespec* %coerce404 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %336, i8* %337, i64 16, i32 8, i1 false)
  br label %if.end.405

if.end.405:                                       ; preds = %if.else.402, %if.end.401
  %tv_sec406 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 0
  %338 = load i64, i64* %tv_sec406, align 8
  %cmp407 = icmp sgt i64 %338, 0
  br i1 %cmp407, label %if.then.413, label %lor.lhs.false.409

lor.lhs.false.409:                                ; preds = %if.end.405
  %tv_nsec410 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 1
  %339 = load i64, i64* %tv_nsec410, align 8
  %cmp411 = icmp sgt i64 %339, 0
  br i1 %cmp411, label %if.then.413, label %if.end.416

if.then.413:                                      ; preds = %lor.lhs.false.409, %if.end.405
  %call414 = call { i64, i64 } @invalid_timespec()
  %340 = bitcast %struct.timespec* %coerce415 to { i64, i64 }*
  %341 = getelementptr { i64, i64 }, { i64, i64 }* %340, i32 0, i32 0
  %342 = extractvalue { i64, i64 } %call414, 0
  store i64 %342, i64* %341, align 8
  %343 = getelementptr { i64, i64 }, { i64, i64 }* %340, i32 0, i32 1
  %344 = extractvalue { i64, i64 } %call414, 1
  store i64 %344, i64* %343, align 8
  %345 = bitcast %struct.timespec* %now to i8*
  %346 = bitcast %struct.timespec* %coerce415 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %345, i8* %346, i64 16, i32 8, i1 false)
  br label %if.end.416

if.end.416:                                       ; preds = %if.then.413, %lor.lhs.false.409
  %347 = load i32, i32* @max_process_desc, align 4
  %348 = load i32, i32* @max_input_desc, align 4
  %cmp417 = icmp sgt i32 %347, %348
  br i1 %cmp417, label %cond.true.419, label %cond.false.420

cond.true.419:                                    ; preds = %if.end.416
  %349 = load i32, i32* @max_process_desc, align 4
  br label %cond.end.421

cond.false.420:                                   ; preds = %if.end.416
  %350 = load i32, i32* @max_input_desc, align 4
  br label %cond.end.421

cond.end.421:                                     ; preds = %cond.false.420, %cond.true.419
  %cond422 = phi i32 [ %349, %cond.true.419 ], [ %350, %cond.false.420 ]
  %add423 = add nsw i32 %cond422, 1
  %351 = load i8, i8* %check_write, align 1
  %tobool424 = trunc i8 %351 to i1
  br i1 %tobool424, label %cond.true.426, label %cond.false.427

cond.true.426:                                    ; preds = %cond.end.421
  br label %cond.end.428

cond.false.427:                                   ; preds = %cond.end.421
  br label %cond.end.428

cond.end.428:                                     ; preds = %cond.false.427, %cond.true.426
  %cond429 = phi %struct.fd_set* [ %Writeok, %cond.true.426 ], [ null, %cond.false.427 ]
  %call430 = call i32 @xg_select(i32 %add423, %struct.fd_set* %Available, %struct.fd_set* %cond429, %struct.fd_set* null, %struct.timespec* %timeout, %struct.__sigset_t* null)
  store i32 %call430, i32* %nfds, align 4
  %352 = load i32, i32* %nfds, align 4
  %cmp431 = icmp eq i32 %352, 0
  br i1 %cmp431, label %if.then.433, label %if.end.502

if.then.433:                                      ; preds = %cond.end.428
  store i32 0, i32* %set, align 4
  br label %do.body.434

do.body.434:                                      ; preds = %if.then.433
  %fds_bits437 = getelementptr inbounds %struct.fd_set, %struct.fd_set* %tls_available, i32 0, i32 0
  %arrayidx438 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits437, i32 0, i64 0
  %353 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx438) #5, !srcloc !6
  %asmresult439 = extractvalue { i64, i64* } %353, 0
  %asmresult440 = extractvalue { i64, i64* } %353, 1
  %354 = trunc i64 %asmresult439 to i32
  store i32 %354, i32* %__d0435, align 4
  %355 = ptrtoint i64* %asmresult440 to i64
  %356 = trunc i64 %355 to i32
  store i32 %356, i32* %__d1436, align 4
  br label %do.end.442

do.end.442:                                       ; preds = %do.body.434
  %357 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool443 = icmp ne %struct.Lisp_Process* %357, null
  br i1 %tobool443, label %if.else.480, label %if.then.444

if.then.444:                                      ; preds = %do.end.442
  store i32 0, i32* %channel, align 4
  br label %for.cond.445

for.cond.445:                                     ; preds = %for.inc.477, %if.then.444
  %358 = load i32, i32* %channel, align 4
  %cmp446 = icmp slt i32 %358, 1024
  br i1 %cmp446, label %for.body.448, label %for.end.479

for.body.448:                                     ; preds = %for.cond.445
  %359 = load i32, i32* %channel, align 4
  %idxprom449 = sext i32 %359 to i64
  %arrayidx450 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom449
  %360 = load i64, i64* %arrayidx450, align 8
  %call451 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp452 = icmp eq i64 %360, %call451
  br i1 %cmp452, label %if.end.476, label %if.then.454

if.then.454:                                      ; preds = %for.body.448
  %361 = load i32, i32* %channel, align 4
  %idxprom455 = sext i32 %361 to i64
  %arrayidx456 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom455
  %362 = load i64, i64* %arrayidx456, align 8
  %call457 = call %struct.Lisp_Process* @XPROCESS(i64 %362)
  store %struct.Lisp_Process* %call457, %struct.Lisp_Process** %p, align 8
  %363 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tobool458 = icmp ne %struct.Lisp_Process* %363, null
  br i1 %tobool458, label %land.lhs.true.459, label %if.end.475

land.lhs.true.459:                                ; preds = %if.then.454
  %364 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_p = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %364, i32 0, i32 39
  %bf.load460 = load i8, i8* %gnutls_p, align 8
  %bf.clear461 = and i8 %bf.load460, 1
  %bf.cast462 = trunc i8 %bf.clear461 to i1
  br i1 %bf.cast462, label %land.lhs.true.464, label %if.end.475

land.lhs.true.464:                                ; preds = %land.lhs.true.459
  %365 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_state = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %365, i32 0, i32 31
  %366 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state, align 8
  %tobool465 = icmp ne %struct.gnutls_session_int* %366, null
  br i1 %tobool465, label %land.lhs.true.466, label %if.end.475

land.lhs.true.466:                                ; preds = %land.lhs.true.464
  %367 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_state467 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %367, i32 0, i32 31
  %368 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state467, align 8
  %call468 = call i64 @emacs_gnutls_record_check_pending(%struct.gnutls_session_int* %368)
  %cmp469 = icmp sgt i64 %call468, 0
  br i1 %cmp469, label %if.then.471, label %if.end.475

if.then.471:                                      ; preds = %land.lhs.true.466
  %369 = load i32, i32* %nfds, align 4
  %inc472 = add nsw i32 %369, 1
  store i32 %inc472, i32* %nfds, align 4
  %370 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd473 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %370, i32 0, i32 21
  %371 = load i32, i32* %infd473, align 4
  call void @fd_SET(i32 %371, %struct.fd_set* %tls_available)
  %372 = load i32, i32* %set, align 4
  %inc474 = add nsw i32 %372, 1
  store i32 %inc474, i32* %set, align 4
  br label %if.end.475

if.end.475:                                       ; preds = %if.then.471, %land.lhs.true.466, %land.lhs.true.464, %land.lhs.true.459, %if.then.454
  br label %if.end.476

if.end.476:                                       ; preds = %if.end.475, %for.body.448
  br label %for.inc.477

for.inc.477:                                      ; preds = %if.end.476
  %373 = load i32, i32* %channel, align 4
  %inc478 = add nsw i32 %373, 1
  store i32 %inc478, i32* %channel, align 4
  br label %for.cond.445

for.end.479:                                      ; preds = %for.cond.445
  br label %if.end.498

if.else.480:                                      ; preds = %do.end.442
  %374 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %gnutls_p481 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %374, i32 0, i32 39
  %bf.load482 = load i8, i8* %gnutls_p481, align 8
  %bf.clear483 = and i8 %bf.load482, 1
  %bf.cast484 = trunc i8 %bf.clear483 to i1
  br i1 %bf.cast484, label %land.lhs.true.486, label %if.end.497

land.lhs.true.486:                                ; preds = %if.else.480
  %375 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %gnutls_state487 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %375, i32 0, i32 31
  %376 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state487, align 8
  %tobool488 = icmp ne %struct.gnutls_session_int* %376, null
  br i1 %tobool488, label %land.lhs.true.489, label %if.end.497

land.lhs.true.489:                                ; preds = %land.lhs.true.486
  %377 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %gnutls_state490 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %377, i32 0, i32 31
  %378 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state490, align 8
  %call491 = call i64 @emacs_gnutls_record_check_pending(%struct.gnutls_session_int* %378)
  %cmp492 = icmp sgt i64 %call491, 0
  br i1 %cmp492, label %if.then.494, label %if.end.497

if.then.494:                                      ; preds = %land.lhs.true.489
  store i32 1, i32* %nfds, align 4
  %379 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %infd495 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %379, i32 0, i32 21
  %380 = load i32, i32* %infd495, align 4
  call void @fd_SET(i32 %380, %struct.fd_set* %tls_available)
  %381 = load i32, i32* %set, align 4
  %inc496 = add nsw i32 %381, 1
  store i32 %inc496, i32* %set, align 4
  br label %if.end.497

if.end.497:                                       ; preds = %if.then.494, %land.lhs.true.489, %land.lhs.true.486, %if.else.480
  br label %if.end.498

if.end.498:                                       ; preds = %if.end.497, %for.end.479
  %382 = load i32, i32* %set, align 4
  %tobool499 = icmp ne i32 %382, 0
  br i1 %tobool499, label %if.then.500, label %if.end.501

if.then.500:                                      ; preds = %if.end.498
  %383 = bitcast %struct.fd_set* %Available to i8*
  %384 = bitcast %struct.fd_set* %tls_available to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %383, i8* %384, i64 128, i32 8, i1 false)
  br label %if.end.501

if.end.501:                                       ; preds = %if.then.500, %if.end.498
  br label %if.end.502

if.end.502:                                       ; preds = %if.end.501, %cond.end.428
  br label %if.end.503

if.end.503:                                       ; preds = %if.end.502, %do.end.307
  %call504 = call i32* @__errno_location() #11
  %385 = load i32, i32* %call504, align 4
  store i32 %385, i32* %xerrno, align 4
  call void @clear_waiting_for_input()
  call void @do_pending_window_change(i1 zeroext false)
  %386 = load i32, i32* %nfds, align 4
  %cmp505 = icmp eq i32 %386, 0
  br i1 %cmp505, label %if.then.507, label %if.end.551

if.then.507:                                      ; preds = %if.end.503
  %call508 = call { i64, i64 } @make_timespec(i64 9223372036854775807, i64 2000000000)
  %387 = bitcast %struct.timespec* %huge_timespec to { i64, i64 }*
  %388 = getelementptr { i64, i64 }, { i64, i64 }* %387, i32 0, i32 0
  %389 = extractvalue { i64, i64 } %call508, 0
  store i64 %389, i64* %388, align 8
  %390 = getelementptr { i64, i64 }, { i64, i64 }* %387, i32 0, i32 1
  %391 = extractvalue { i64, i64 } %call508, 1
  store i64 %391, i64* %390, align 8
  %392 = bitcast %struct.timespec* %cmp_time to i8*
  %393 = bitcast %struct.timespec* %huge_timespec to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %392, i8* %393, i64 16, i32 8, i1 false)
  %394 = load i32, i32* %wait, align 4
  %cmp509 = icmp slt i32 %394, 0
  br i1 %cmp509, label %if.then.511, label %if.end.512

if.then.511:                                      ; preds = %if.then.507
  br label %while.end.894

if.end.512:                                       ; preds = %if.then.507
  %395 = load i32, i32* %wait, align 4
  %cmp513 = icmp eq i32 %395, 0
  br i1 %cmp513, label %if.then.515, label %if.end.516

if.then.515:                                      ; preds = %if.end.512
  %396 = bitcast %struct.timespec* %cmp_time to i8*
  %397 = bitcast %struct.timespec* %end_time to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %396, i8* %397, i64 16, i32 8, i1 false)
  br label %if.end.516

if.end.516:                                       ; preds = %if.then.515, %if.end.512
  %398 = load i8, i8* %process_skipped, align 1
  %tobool517 = trunc i8 %398 to i1
  br i1 %tobool517, label %if.end.538, label %land.lhs.true.518

land.lhs.true.518:                                ; preds = %if.end.516
  %399 = load i32, i32* %got_some_output, align 4
  %cmp519 = icmp sgt i32 %399, 0
  br i1 %cmp519, label %land.lhs.true.521, label %if.end.538

land.lhs.true.521:                                ; preds = %land.lhs.true.518
  %tv_sec522 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 0
  %400 = load i64, i64* %tv_sec522, align 8
  %cmp523 = icmp sgt i64 %400, 0
  br i1 %cmp523, label %if.then.529, label %lor.lhs.false.525

lor.lhs.false.525:                                ; preds = %land.lhs.true.521
  %tv_nsec526 = getelementptr inbounds %struct.timespec, %struct.timespec* %timeout, i32 0, i32 1
  %401 = load i64, i64* %tv_nsec526, align 8
  %cmp527 = icmp sgt i64 %401, 0
  br i1 %cmp527, label %if.then.529, label %if.end.538

if.then.529:                                      ; preds = %lor.lhs.false.525, %land.lhs.true.521
  %402 = bitcast %struct.timespec* %got_output_end_time to { i64, i64 }*
  %403 = getelementptr { i64, i64 }, { i64, i64 }* %402, i32 0, i32 0
  %404 = load i64, i64* %403, align 1
  %405 = getelementptr { i64, i64 }, { i64, i64 }* %402, i32 0, i32 1
  %406 = load i64, i64* %405, align 1
  %call530 = call zeroext i1 @timespec_valid_p(i64 %404, i64 %406)
  br i1 %call530, label %if.end.532, label %if.then.531

if.then.531:                                      ; preds = %if.then.529
  br label %while.end.894

if.end.532:                                       ; preds = %if.then.529
  %407 = bitcast %struct.timespec* %got_output_end_time to { i64, i64 }*
  %408 = getelementptr { i64, i64 }, { i64, i64 }* %407, i32 0, i32 0
  %409 = load i64, i64* %408, align 1
  %410 = getelementptr { i64, i64 }, { i64, i64 }* %407, i32 0, i32 1
  %411 = load i64, i64* %410, align 1
  %412 = bitcast %struct.timespec* %cmp_time to { i64, i64 }*
  %413 = getelementptr { i64, i64 }, { i64, i64 }* %412, i32 0, i32 0
  %414 = load i64, i64* %413, align 1
  %415 = getelementptr { i64, i64 }, { i64, i64 }* %412, i32 0, i32 1
  %416 = load i64, i64* %415, align 1
  %call533 = call i32 @timespec_cmp(i64 %409, i64 %411, i64 %414, i64 %416) #9
  %cmp534 = icmp slt i32 %call533, 0
  br i1 %cmp534, label %if.then.536, label %if.end.537

if.then.536:                                      ; preds = %if.end.532
  %417 = bitcast %struct.timespec* %cmp_time to i8*
  %418 = bitcast %struct.timespec* %got_output_end_time to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %417, i8* %418, i64 16, i32 8, i1 false)
  br label %if.end.537

if.end.537:                                       ; preds = %if.then.536, %if.end.532
  br label %if.end.538

if.end.538:                                       ; preds = %if.end.537, %lor.lhs.false.525, %land.lhs.true.518, %if.end.516
  %419 = bitcast %struct.timespec* %cmp_time to { i64, i64 }*
  %420 = getelementptr { i64, i64 }, { i64, i64 }* %419, i32 0, i32 0
  %421 = load i64, i64* %420, align 1
  %422 = getelementptr { i64, i64 }, { i64, i64 }* %419, i32 0, i32 1
  %423 = load i64, i64* %422, align 1
  %424 = bitcast %struct.timespec* %huge_timespec to { i64, i64 }*
  %425 = getelementptr { i64, i64 }, { i64, i64 }* %424, i32 0, i32 0
  %426 = load i64, i64* %425, align 1
  %427 = getelementptr { i64, i64 }, { i64, i64 }* %424, i32 0, i32 1
  %428 = load i64, i64* %427, align 1
  %call539 = call i32 @timespec_cmp(i64 %421, i64 %423, i64 %426, i64 %428) #9
  %cmp540 = icmp slt i32 %call539, 0
  br i1 %cmp540, label %if.then.542, label %if.end.550

if.then.542:                                      ; preds = %if.end.538
  %call543 = call { i64, i64 } @current_timespec()
  %429 = bitcast %struct.timespec* %coerce544 to { i64, i64 }*
  %430 = getelementptr { i64, i64 }, { i64, i64 }* %429, i32 0, i32 0
  %431 = extractvalue { i64, i64 } %call543, 0
  store i64 %431, i64* %430, align 8
  %432 = getelementptr { i64, i64 }, { i64, i64 }* %429, i32 0, i32 1
  %433 = extractvalue { i64, i64 } %call543, 1
  store i64 %433, i64* %432, align 8
  %434 = bitcast %struct.timespec* %now to i8*
  %435 = bitcast %struct.timespec* %coerce544 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %434, i8* %435, i64 16, i32 8, i1 false)
  %436 = bitcast %struct.timespec* %cmp_time to { i64, i64 }*
  %437 = getelementptr { i64, i64 }, { i64, i64 }* %436, i32 0, i32 0
  %438 = load i64, i64* %437, align 1
  %439 = getelementptr { i64, i64 }, { i64, i64 }* %436, i32 0, i32 1
  %440 = load i64, i64* %439, align 1
  %441 = bitcast %struct.timespec* %now to { i64, i64 }*
  %442 = getelementptr { i64, i64 }, { i64, i64 }* %441, i32 0, i32 0
  %443 = load i64, i64* %442, align 1
  %444 = getelementptr { i64, i64 }, { i64, i64 }* %441, i32 0, i32 1
  %445 = load i64, i64* %444, align 1
  %call545 = call i32 @timespec_cmp(i64 %438, i64 %440, i64 %443, i64 %445) #9
  %cmp546 = icmp sle i32 %call545, 0
  br i1 %cmp546, label %if.then.548, label %if.end.549

if.then.548:                                      ; preds = %if.then.542
  br label %while.end.894

if.end.549:                                       ; preds = %if.then.542
  br label %if.end.550

if.end.550:                                       ; preds = %if.end.549, %if.end.538
  br label %if.end.551

if.end.551:                                       ; preds = %if.end.550, %if.end.503
  %446 = load i32, i32* %nfds, align 4
  %cmp552 = icmp slt i32 %446, 0
  br i1 %cmp552, label %if.then.554, label %if.end.565

if.then.554:                                      ; preds = %if.end.551
  %447 = load i32, i32* %xerrno, align 4
  %cmp555 = icmp eq i32 %447, 4
  br i1 %cmp555, label %if.then.557, label %if.else.558

if.then.557:                                      ; preds = %if.then.554
  store i8 1, i8* %no_avail, align 1
  br label %if.end.564

if.else.558:                                      ; preds = %if.then.554
  %448 = load i32, i32* %xerrno, align 4
  %cmp559 = icmp eq i32 %448, 9
  br i1 %cmp559, label %if.then.561, label %if.else.562

if.then.561:                                      ; preds = %if.else.558
  call void @emacs_abort() #8
  unreachable

if.else.562:                                      ; preds = %if.else.558
  %call563 = call i64 @builtin_lisp_symbol(i32 0)
  %449 = load i32, i32* %xerrno, align 4
  call void @report_file_errno(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.32, i32 0, i32 0), i64 %call563, i32 %449) #8
  unreachable

if.end.564:                                       ; preds = %if.then.557
  br label %if.end.565

if.end.565:                                       ; preds = %if.end.564, %if.end.551
  %450 = load i32, i32* %read_kbd.addr, align 4
  %cmp566 = icmp ne i32 %450, 0
  br i1 %cmp566, label %if.then.568, label %if.end.597

if.then.568:                                      ; preds = %if.end.565
  %451 = load i32, i32* @timers_run, align 4
  store i32 %451, i32* %old_timers_run569, align 4
  %452 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %452, %struct.buffer** %old_buffer570, align 8
  %453 = load i64, i64* @selected_window, align 8
  store i64 %453, i64* %old_window571, align 8
  store i8 0, i8* %leave, align 1
  %454 = load i8, i8* %do_display.addr, align 1
  %tobool572 = trunc i8 %454 to i1
  %call573 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext %tobool572)
  br i1 %call573, label %if.then.574, label %if.end.580

if.then.574:                                      ; preds = %if.then.568
  %455 = load i8, i8* %do_display.addr, align 1
  %tobool575 = trunc i8 %455 to i1
  call void @swallow_events(i1 zeroext %tobool575)
  %456 = load i8, i8* %do_display.addr, align 1
  %tobool576 = trunc i8 %456 to i1
  %call577 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext %tobool576)
  br i1 %call577, label %if.then.578, label %if.end.579

if.then.578:                                      ; preds = %if.then.574
  store i8 1, i8* %leave, align 1
  br label %if.end.579

if.end.579:                                       ; preds = %if.then.578, %if.then.574
  br label %if.end.580

if.end.580:                                       ; preds = %if.end.579, %if.then.568
  %457 = load i32, i32* @timers_run, align 4
  %458 = load i32, i32* %old_timers_run569, align 4
  %cmp581 = icmp ne i32 %457, %458
  br i1 %cmp581, label %land.lhs.true.583, label %if.end.593

land.lhs.true.583:                                ; preds = %if.end.580
  %459 = load i32, i32* @waiting_for_user_input_p, align 4
  %cmp584 = icmp eq i32 %459, -1
  br i1 %cmp584, label %land.lhs.true.586, label %if.end.593

land.lhs.true.586:                                ; preds = %land.lhs.true.583
  %460 = load %struct.buffer*, %struct.buffer** %old_buffer570, align 8
  %461 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp587 = icmp ne %struct.buffer* %460, %461
  br i1 %cmp587, label %if.then.592, label %lor.lhs.false.589

lor.lhs.false.589:                                ; preds = %land.lhs.true.586
  %462 = load i64, i64* %old_window571, align 8
  %463 = load i64, i64* @selected_window, align 8
  %cmp590 = icmp eq i64 %462, %463
  br i1 %cmp590, label %if.end.593, label %if.then.592

if.then.592:                                      ; preds = %lor.lhs.false.589, %land.lhs.true.586
  call void @record_asynch_buffer_change()
  br label %if.end.593

if.end.593:                                       ; preds = %if.then.592, %lor.lhs.false.589, %land.lhs.true.583, %if.end.580
  %464 = load i8, i8* %leave, align 1
  %tobool594 = trunc i8 %464 to i1
  br i1 %tobool594, label %if.then.595, label %if.end.596

if.then.595:                                      ; preds = %if.end.593
  br label %while.end.894

if.end.596:                                       ; preds = %if.end.593
  br label %if.end.597

if.end.597:                                       ; preds = %if.end.596, %if.end.565
  %465 = load i32, i32* %read_kbd.addr, align 4
  %cmp598 = icmp ne i32 %465, 0
  br i1 %cmp598, label %land.lhs.true.600, label %if.end.604

land.lhs.true.600:                                ; preds = %if.end.597
  %call601 = call zeroext i1 @requeued_events_pending_p()
  br i1 %call601, label %if.then.603, label %if.end.604

if.then.603:                                      ; preds = %land.lhs.true.600
  br label %while.end.894

if.end.604:                                       ; preds = %land.lhs.true.600, %if.end.597
  %466 = load i32, i32* %read_kbd.addr, align 4
  %cmp605 = icmp eq i32 %466, 0
  br i1 %cmp605, label %land.lhs.true.607, label %if.end.612

land.lhs.true.607:                                ; preds = %if.end.604
  %call608 = call zeroext i1 @detect_input_pending()
  br i1 %call608, label %if.then.610, label %if.end.612

if.then.610:                                      ; preds = %land.lhs.true.607
  %467 = load i8, i8* %do_display.addr, align 1
  %tobool611 = trunc i8 %467 to i1
  call void @swallow_events(i1 zeroext %tobool611)
  br label %if.end.612

if.end.612:                                       ; preds = %if.then.610, %land.lhs.true.607, %if.end.604
  %468 = load i64, i64* %wait_for_cell.addr, align 8
  %call613 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp614 = icmp eq i64 %468, %call613
  br i1 %cmp614, label %if.end.623, label %land.lhs.true.616

land.lhs.true.616:                                ; preds = %if.end.612
  %469 = load i64, i64* %wait_for_cell.addr, align 8
  %sub617 = sub nsw i64 %469, 3
  %470 = inttoptr i64 %sub617 to i8*
  %471 = bitcast i8* %470 to %struct.Lisp_Cons*
  %car618 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %471, i32 0, i32 0
  %472 = load i64, i64* %car618, align 8
  %call619 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp620 = icmp eq i64 %472, %call619
  br i1 %cmp620, label %if.end.623, label %if.then.622

if.then.622:                                      ; preds = %land.lhs.true.616
  br label %while.end.894

if.end.623:                                       ; preds = %land.lhs.true.616, %if.end.612
  %473 = load i32, i32* %read_kbd.addr, align 4
  %tobool624 = icmp ne i32 %473, 0
  br i1 %tobool624, label %land.lhs.true.625, label %if.end.634

land.lhs.true.625:                                ; preds = %if.end.623
  %474 = load i8, i8* @interrupt_input, align 1
  %tobool626 = trunc i8 %474 to i1
  br i1 %tobool626, label %land.lhs.true.628, label %if.end.634

land.lhs.true.628:                                ; preds = %land.lhs.true.625
  %call629 = call zeroext i1 @keyboard_bit_set(%struct.fd_set* %Available)
  br i1 %call629, label %land.lhs.true.631, label %if.end.634

land.lhs.true.631:                                ; preds = %land.lhs.true.628
  %475 = load i8, i8* @noninteractive, align 1
  %tobool632 = trunc i8 %475 to i1
  br i1 %tobool632, label %if.end.634, label %if.then.633

if.then.633:                                      ; preds = %land.lhs.true.631
  call void @handle_input_available_signal(i32 29)
  br label %if.end.634

if.end.634:                                       ; preds = %if.then.633, %land.lhs.true.631, %land.lhs.true.628, %land.lhs.true.625, %if.end.623
  %476 = load i32, i32* %read_kbd.addr, align 4
  %tobool635 = icmp ne i32 %476, 0
  br i1 %tobool635, label %if.then.640, label %lor.lhs.false.636

lor.lhs.false.636:                                ; preds = %if.end.634
  %477 = load i64, i64* %wait_for_cell.addr, align 8
  %call637 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp638 = icmp eq i64 %477, %call637
  br i1 %cmp638, label %if.end.641, label %if.then.640

if.then.640:                                      ; preds = %lor.lhs.false.636, %if.end.634
  call void @do_pending_window_change(i1 zeroext false)
  br label %if.end.641

if.end.641:                                       ; preds = %if.then.640, %lor.lhs.false.636
  %478 = load i8, i8* %no_avail, align 1
  %tobool642 = trunc i8 %478 to i1
  br i1 %tobool642, label %if.then.647, label %lor.lhs.false.644

lor.lhs.false.644:                                ; preds = %if.end.641
  %479 = load i32, i32* %nfds, align 4
  %cmp645 = icmp eq i32 %479, 0
  br i1 %cmp645, label %if.then.647, label %if.end.648

if.then.647:                                      ; preds = %lor.lhs.false.644, %if.end.641
  br label %while.body

if.end.648:                                       ; preds = %lor.lhs.false.644
  store i32 0, i32* %channel, align 4
  br label %for.cond.649

for.cond.649:                                     ; preds = %for.inc.672, %if.end.648
  %480 = load i32, i32* %channel, align 4
  %481 = load i32, i32* @max_input_desc, align 4
  %cmp650 = icmp sle i32 %480, %481
  br i1 %cmp650, label %for.body.652, label %for.end.674

for.body.652:                                     ; preds = %for.cond.649
  %482 = load i32, i32* %channel, align 4
  %idxprom653 = sext i32 %482 to i64
  %arrayidx654 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom653
  store %struct.fd_callback_data* %arrayidx654, %struct.fd_callback_data** %d, align 8
  %483 = load %struct.fd_callback_data*, %struct.fd_callback_data** %d, align 8
  %func = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %483, i32 0, i32 0
  %484 = load void (i32, i8*)*, void (i32, i8*)** %func, align 8
  %tobool655 = icmp ne void (i32, i8*)* %484, null
  br i1 %tobool655, label %land.lhs.true.656, label %if.end.671

land.lhs.true.656:                                ; preds = %for.body.652
  %485 = load %struct.fd_callback_data*, %struct.fd_callback_data** %d, align 8
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %485, i32 0, i32 2
  %486 = load i32, i32* %condition, align 4
  %and657 = and i32 %486, 1
  %tobool658 = icmp ne i32 %and657, 0
  br i1 %tobool658, label %land.lhs.true.659, label %lor.lhs.false.662

land.lhs.true.659:                                ; preds = %land.lhs.true.656
  %487 = load i32, i32* %channel, align 4
  %call660 = call zeroext i1 @fd_ISSET(i32 %487, %struct.fd_set* %Available)
  br i1 %call660, label %if.then.669, label %lor.lhs.false.662

lor.lhs.false.662:                                ; preds = %land.lhs.true.659, %land.lhs.true.656
  %488 = load %struct.fd_callback_data*, %struct.fd_callback_data** %d, align 8
  %condition663 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %488, i32 0, i32 2
  %489 = load i32, i32* %condition663, align 4
  %and664 = and i32 %489, 2
  %tobool665 = icmp ne i32 %and664, 0
  br i1 %tobool665, label %land.lhs.true.666, label %if.end.671

land.lhs.true.666:                                ; preds = %lor.lhs.false.662
  %490 = load i32, i32* %channel, align 4
  %call667 = call zeroext i1 @fd_ISSET(i32 %490, %struct.fd_set* @write_mask)
  br i1 %call667, label %if.then.669, label %if.end.671

if.then.669:                                      ; preds = %land.lhs.true.666, %land.lhs.true.659
  %491 = load %struct.fd_callback_data*, %struct.fd_callback_data** %d, align 8
  %func670 = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %491, i32 0, i32 0
  %492 = load void (i32, i8*)*, void (i32, i8*)** %func670, align 8
  %493 = load i32, i32* %channel, align 4
  %494 = load %struct.fd_callback_data*, %struct.fd_callback_data** %d, align 8
  %data = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %494, i32 0, i32 1
  %495 = load i8*, i8** %data, align 8
  call void %492(i32 %493, i8* %495)
  br label %if.end.671

if.end.671:                                       ; preds = %if.then.669, %land.lhs.true.666, %lor.lhs.false.662, %for.body.652
  br label %for.inc.672

for.inc.672:                                      ; preds = %if.end.671
  %496 = load i32, i32* %channel, align 4
  %inc673 = add nsw i32 %496, 1
  store i32 %inc673, i32* %channel, align 4
  br label %for.cond.649

for.end.674:                                      ; preds = %for.cond.649
  store i32 0, i32* %channel, align 4
  br label %for.cond.675

for.cond.675:                                     ; preds = %for.inc.891, %for.end.674
  %497 = load i32, i32* %channel, align 4
  %498 = load i32, i32* @max_process_desc, align 4
  %cmp676 = icmp sle i32 %497, %498
  br i1 %cmp676, label %for.body.678, label %for.end.893

for.body.678:                                     ; preds = %for.cond.675
  %499 = load i32, i32* %channel, align 4
  %call679 = call zeroext i1 @fd_ISSET(i32 %499, %struct.fd_set* %Available)
  br i1 %call679, label %land.lhs.true.681, label %if.end.837

land.lhs.true.681:                                ; preds = %for.body.678
  %500 = load i32, i32* %channel, align 4
  %call682 = call zeroext i1 @fd_ISSET(i32 %500, %struct.fd_set* @non_keyboard_wait_mask)
  br i1 %call682, label %land.lhs.true.684, label %if.end.837

land.lhs.true.684:                                ; preds = %land.lhs.true.681
  %501 = load i32, i32* %channel, align 4
  %call685 = call zeroext i1 @fd_ISSET(i32 %501, %struct.fd_set* @non_process_wait_mask)
  br i1 %call685, label %if.end.837, label %if.then.686

if.then.686:                                      ; preds = %land.lhs.true.684
  %502 = load i32, i32* %channel, align 4
  %idxprom688 = sext i32 %502 to i64
  %arrayidx689 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom688
  %503 = load i64, i64* %arrayidx689, align 8
  store i64 %503, i64* %proc, align 8
  %504 = load i64, i64* %proc, align 8
  %call690 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp691 = icmp eq i64 %504, %call690
  br i1 %cmp691, label %if.then.693, label %if.end.694

if.then.693:                                      ; preds = %if.then.686
  br label %for.inc.891

if.end.694:                                       ; preds = %if.then.686
  %505 = load i64, i64* %proc, align 8
  %call695 = call %struct.Lisp_Process* @XPROCESS(i64 %505)
  %status696 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call695, i32 0, i32 12
  %506 = load i64, i64* %status696, align 8
  %call697 = call i64 @builtin_lisp_symbol(i32 625)
  %cmp698 = icmp eq i64 %506, %call697
  br i1 %cmp698, label %if.then.700, label %if.end.701

if.then.700:                                      ; preds = %if.end.694
  %507 = load i64, i64* %proc, align 8
  %508 = load i32, i32* %channel, align 4
  call void @server_accept_connection(i64 %507, i32 %508)
  br label %for.inc.891

if.end.701:                                       ; preds = %if.end.694
  %509 = load i64, i64* %proc, align 8
  %510 = load i32, i32* %channel, align 4
  %call702 = call i32 @read_process_output(i64 %509, i32 %510)
  store i32 %call702, i32* %nread687, align 4
  %511 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %tobool703 = icmp ne %struct.Lisp_Process* %511, null
  br i1 %tobool703, label %lor.lhs.false.704, label %land.lhs.true.708

lor.lhs.false.704:                                ; preds = %if.end.701
  %512 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %513 = load i64, i64* %proc, align 8
  %call705 = call %struct.Lisp_Process* @XPROCESS(i64 %513)
  %cmp706 = icmp eq %struct.Lisp_Process* %512, %call705
  br i1 %cmp706, label %land.lhs.true.708, label %if.end.712

land.lhs.true.708:                                ; preds = %lor.lhs.false.704, %if.end.701
  %514 = load i32, i32* %got_some_output, align 4
  %515 = load i32, i32* %nread687, align 4
  %cmp709 = icmp slt i32 %514, %515
  br i1 %cmp709, label %if.then.711, label %if.end.712

if.then.711:                                      ; preds = %land.lhs.true.708
  %516 = load i32, i32* %nread687, align 4
  store i32 %516, i32* %got_some_output, align 4
  br label %if.end.712

if.end.712:                                       ; preds = %if.then.711, %land.lhs.true.708, %lor.lhs.false.704
  %517 = load i32, i32* %nread687, align 4
  %cmp713 = icmp sgt i32 %517, 0
  br i1 %cmp713, label %if.then.715, label %if.else.733

if.then.715:                                      ; preds = %if.end.712
  %518 = load %struct.Lisp_Process*, %struct.Lisp_Process** %wait_proc.addr, align 8
  %519 = load i64, i64* %proc, align 8
  %call716 = call %struct.Lisp_Process* @XPROCESS(i64 %519)
  %cmp717 = icmp eq %struct.Lisp_Process* %518, %call716
  br i1 %cmp717, label %if.then.719, label %if.end.720

if.then.719:                                      ; preds = %if.then.715
  store i32 -1, i32* %wait, align 4
  br label %if.end.720

if.end.720:                                       ; preds = %if.then.719, %if.then.715
  br label %do.body.721

do.body.721:                                      ; preds = %if.end.720
  %fds_bits724 = getelementptr inbounds %struct.fd_set, %struct.fd_set* %Available, i32 0, i32 0
  %arrayidx725 = getelementptr inbounds [16 x i64], [16 x i64]* %fds_bits724, i32 0, i64 0
  %520 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* %arrayidx725) #5, !srcloc !7
  %asmresult726 = extractvalue { i64, i64* } %520, 0
  %asmresult727 = extractvalue { i64, i64* } %520, 1
  %521 = trunc i64 %asmresult726 to i32
  store i32 %521, i32* %__d0722, align 4
  %522 = ptrtoint i64* %asmresult727 to i64
  %523 = trunc i64 %522 to i32
  store i32 %523, i32* %__d1723, align 4
  br label %do.end.729

do.end.729:                                       ; preds = %do.body.721
  %524 = load i8, i8* %do_display.addr, align 1
  %tobool730 = trunc i8 %524 to i1
  br i1 %tobool730, label %if.then.731, label %if.end.732

if.then.731:                                      ; preds = %do.end.729
  call void @redisplay_preserve_echo_area(i32 12)
  br label %if.end.732

if.end.732:                                       ; preds = %if.then.731, %do.end.729
  br label %if.end.836

if.else.733:                                      ; preds = %if.end.712
  %525 = load i32, i32* %nread687, align 4
  %cmp734 = icmp eq i32 %525, -1
  br i1 %cmp734, label %land.lhs.true.736, label %if.else.741

land.lhs.true.736:                                ; preds = %if.else.733
  %call737 = call i32* @__errno_location() #11
  %526 = load i32, i32* %call737, align 4
  %cmp738 = icmp eq i32 %526, 11
  br i1 %cmp738, label %if.then.740, label %if.else.741

if.then.740:                                      ; preds = %land.lhs.true.736
  br label %if.end.835

if.else.741:                                      ; preds = %land.lhs.true.736, %if.else.733
  %527 = load i32, i32* %nread687, align 4
  %cmp742 = icmp eq i32 %527, -1
  br i1 %cmp742, label %land.lhs.true.744, label %if.else.749

land.lhs.true.744:                                ; preds = %if.else.741
  %call745 = call i32* @__errno_location() #11
  %528 = load i32, i32* %call745, align 4
  %cmp746 = icmp eq i32 %528, 11
  br i1 %cmp746, label %if.then.748, label %if.else.749

if.then.748:                                      ; preds = %land.lhs.true.744
  br label %if.end.834

if.else.749:                                      ; preds = %land.lhs.true.744, %if.else.741
  %529 = load i32, i32* %nread687, align 4
  %cmp750 = icmp eq i32 %529, -1
  br i1 %cmp750, label %land.lhs.true.752, label %if.else.765

land.lhs.true.752:                                ; preds = %if.else.749
  %call753 = call i32* @__errno_location() #11
  %530 = load i32, i32* %call753, align 4
  %cmp754 = icmp eq i32 %530, 5
  br i1 %cmp754, label %if.then.756, label %if.else.765

if.then.756:                                      ; preds = %land.lhs.true.752
  %531 = load i64, i64* %proc, align 8
  %call758 = call %struct.Lisp_Process* @XPROCESS(i64 %531)
  store %struct.Lisp_Process* %call758, %struct.Lisp_Process** %p757, align 8
  %532 = load i32, i32* %channel, align 4
  call void @fd_CLR(i32 %532, %struct.fd_set* @input_wait_mask)
  %533 = load i32, i32* %channel, align 4
  call void @fd_CLR(i32 %533, %struct.fd_set* @non_keyboard_wait_mask)
  %534 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p757, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %534, i32 0, i32 20
  %535 = load i32, i32* %pid, align 4
  %cmp759 = icmp eq i32 %535, -2
  br i1 %cmp759, label %if.then.761, label %if.end.764

if.then.761:                                      ; preds = %if.then.756
  %536 = load i64, i64* @process_tick, align 8
  %inc762 = add nsw i64 %536, 1
  store i64 %inc762, i64* @process_tick, align 8
  %537 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p757, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %537, i32 0, i32 24
  store i64 %inc762, i64* %tick, align 8
  %538 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p757, align 8
  %call763 = call i64 @builtin_lisp_symbol(i32 401)
  call void @pset_status(%struct.Lisp_Process* %538, i64 %call763)
  br label %if.end.764

if.end.764:                                       ; preds = %if.then.761, %if.then.756
  br label %if.end.833

if.else.765:                                      ; preds = %land.lhs.true.752, %if.else.749
  %539 = load i32, i32* %nread687, align 4
  %cmp766 = icmp eq i32 %539, 0
  br i1 %cmp766, label %land.lhs.true.768, label %if.else.786

land.lhs.true.768:                                ; preds = %if.else.765
  %540 = load i64, i64* %proc, align 8
  %call769 = call %struct.Lisp_Process* @XPROCESS(i64 %540)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call769, i32 0, i32 10
  %541 = load i64, i64* %type, align 8
  %call770 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp771 = icmp eq i64 %541, %call770
  br i1 %cmp771, label %if.else.786, label %land.lhs.true.773

land.lhs.true.773:                                ; preds = %land.lhs.true.768
  %542 = load i64, i64* %proc, align 8
  %call774 = call %struct.Lisp_Process* @XPROCESS(i64 %542)
  %type775 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call774, i32 0, i32 10
  %543 = load i64, i64* %type775, align 8
  %call776 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp777 = icmp eq i64 %543, %call776
  br i1 %cmp777, label %if.else.786, label %land.lhs.true.779

land.lhs.true.779:                                ; preds = %land.lhs.true.773
  %544 = load i64, i64* %proc, align 8
  %call780 = call %struct.Lisp_Process* @XPROCESS(i64 %544)
  %type781 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call780, i32 0, i32 10
  %545 = load i64, i64* %type781, align 8
  %call782 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp783 = icmp eq i64 %545, %call782
  br i1 %cmp783, label %if.else.786, label %if.then.785

if.then.785:                                      ; preds = %land.lhs.true.779
  br label %if.end.832

if.else.786:                                      ; preds = %land.lhs.true.779, %land.lhs.true.773, %land.lhs.true.768, %if.else.765
  %546 = load i32, i32* %nread687, align 4
  %cmp787 = icmp eq i32 %546, 0
  br i1 %cmp787, label %land.lhs.true.789, label %if.else.809

land.lhs.true.789:                                ; preds = %if.else.786
  %547 = load i64, i64* %proc, align 8
  %call790 = call %struct.Lisp_Process* @XPROCESS(i64 %547)
  %type791 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call790, i32 0, i32 10
  %548 = load i64, i64* %type791, align 8
  %call792 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp793 = icmp eq i64 %548, %call792
  br i1 %cmp793, label %if.then.795, label %if.else.809

if.then.795:                                      ; preds = %land.lhs.true.789
  %549 = load i64, i64* @process_tick, align 8
  %inc796 = add nsw i64 %549, 1
  store i64 %inc796, i64* @process_tick, align 8
  %550 = load i64, i64* %proc, align 8
  %call797 = call %struct.Lisp_Process* @XPROCESS(i64 %550)
  %tick798 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call797, i32 0, i32 24
  store i64 %inc796, i64* %tick798, align 8
  %551 = load i64, i64* %proc, align 8
  call void @deactivate_process(i64 %551)
  %552 = load i64, i64* %proc, align 8
  %call799 = call %struct.Lisp_Process* @XPROCESS(i64 %552)
  %status800 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call799, i32 0, i32 12
  %553 = load i64, i64* %status800, align 8
  %call801 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp802 = icmp eq i64 %553, %call801
  br i1 %cmp802, label %if.then.804, label %if.end.808

if.then.804:                                      ; preds = %if.then.795
  %554 = load i64, i64* %proc, align 8
  %call805 = call %struct.Lisp_Process* @XPROCESS(i64 %554)
  %call806 = call i64 @builtin_lisp_symbol(i32 387)
  %call807 = call i64 @list2(i64 %call806, i64 2)
  call void @pset_status(%struct.Lisp_Process* %call805, i64 %call807)
  br label %if.end.808

if.end.808:                                       ; preds = %if.then.804, %if.then.795
  br label %if.end.831

if.else.809:                                      ; preds = %land.lhs.true.789, %if.else.786
  %555 = load i64, i64* @process_tick, align 8
  %inc810 = add nsw i64 %555, 1
  store i64 %inc810, i64* @process_tick, align 8
  %556 = load i64, i64* %proc, align 8
  %call811 = call %struct.Lisp_Process* @XPROCESS(i64 %556)
  %tick812 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call811, i32 0, i32 24
  store i64 %inc810, i64* %tick812, align 8
  %557 = load i64, i64* %proc, align 8
  call void @deactivate_process(i64 %557)
  %558 = load i64, i64* %proc, align 8
  %call813 = call %struct.Lisp_Process* @XPROCESS(i64 %558)
  %raw_status_new814 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call813, i32 0, i32 28
  %bf.load815 = load i8, i8* %raw_status_new814, align 8
  %bf.lshr816 = lshr i8 %bf.load815, 7
  %bf.cast817 = trunc i8 %bf.lshr816 to i1
  br i1 %bf.cast817, label %if.then.818, label %if.end.820

if.then.818:                                      ; preds = %if.else.809
  %559 = load i64, i64* %proc, align 8
  %call819 = call %struct.Lisp_Process* @XPROCESS(i64 %559)
  call void @update_status(%struct.Lisp_Process* %call819)
  br label %if.end.820

if.end.820:                                       ; preds = %if.then.818, %if.else.809
  %560 = load i64, i64* %proc, align 8
  %call821 = call %struct.Lisp_Process* @XPROCESS(i64 %560)
  %status822 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call821, i32 0, i32 12
  %561 = load i64, i64* %status822, align 8
  %call823 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp824 = icmp eq i64 %561, %call823
  br i1 %cmp824, label %if.then.826, label %if.end.830

if.then.826:                                      ; preds = %if.end.820
  %562 = load i64, i64* %proc, align 8
  %call827 = call %struct.Lisp_Process* @XPROCESS(i64 %562)
  %call828 = call i64 @builtin_lisp_symbol(i32 387)
  %call829 = call i64 @list2(i64 %call828, i64 1026)
  call void @pset_status(%struct.Lisp_Process* %call827, i64 %call829)
  br label %if.end.830

if.end.830:                                       ; preds = %if.then.826, %if.end.820
  br label %if.end.831

if.end.831:                                       ; preds = %if.end.830, %if.end.808
  br label %if.end.832

if.end.832:                                       ; preds = %if.end.831, %if.then.785
  br label %if.end.833

if.end.833:                                       ; preds = %if.end.832, %if.end.764
  br label %if.end.834

if.end.834:                                       ; preds = %if.end.833, %if.then.748
  br label %if.end.835

if.end.835:                                       ; preds = %if.end.834, %if.then.740
  br label %if.end.836

if.end.836:                                       ; preds = %if.end.835, %if.end.732
  br label %if.end.837

if.end.837:                                       ; preds = %if.end.836, %land.lhs.true.684, %land.lhs.true.681, %for.body.678
  %563 = load i32, i32* %channel, align 4
  %call838 = call zeroext i1 @fd_ISSET(i32 %563, %struct.fd_set* %Writeok)
  br i1 %call838, label %land.lhs.true.840, label %if.end.890

land.lhs.true.840:                                ; preds = %if.end.837
  %564 = load i32, i32* %channel, align 4
  %call841 = call zeroext i1 @fd_ISSET(i32 %564, %struct.fd_set* @connect_wait_mask)
  br i1 %call841, label %if.then.843, label %if.end.890

if.then.843:                                      ; preds = %land.lhs.true.840
  %565 = load i32, i32* %channel, align 4
  call void @fd_CLR(i32 %565, %struct.fd_set* @connect_wait_mask)
  %566 = load i32, i32* %channel, align 4
  call void @fd_CLR(i32 %566, %struct.fd_set* @write_mask)
  %567 = load i32, i32* @num_pending_connects, align 4
  %dec845 = add nsw i32 %567, -1
  store i32 %dec845, i32* @num_pending_connects, align 4
  %cmp846 = icmp slt i32 %dec845, 0
  br i1 %cmp846, label %if.then.848, label %if.end.849

if.then.848:                                      ; preds = %if.then.843
  call void @emacs_abort() #8
  unreachable

if.end.849:                                       ; preds = %if.then.843
  %568 = load i32, i32* %channel, align 4
  %idxprom850 = sext i32 %568 to i64
  %arrayidx851 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom850
  %569 = load i64, i64* %arrayidx851, align 8
  store i64 %569, i64* %proc, align 8
  %570 = load i64, i64* %proc, align 8
  %call852 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp853 = icmp eq i64 %570, %call852
  br i1 %cmp853, label %if.then.855, label %if.end.856

if.then.855:                                      ; preds = %if.end.849
  br label %for.inc.891

if.end.856:                                       ; preds = %if.end.849
  %571 = load i64, i64* %proc, align 8
  %call857 = call %struct.Lisp_Process* @XPROCESS(i64 %571)
  store %struct.Lisp_Process* %call857, %struct.Lisp_Process** %p844, align 8
  store i32 4, i32* %xlen, align 4
  %572 = load i32, i32* %channel, align 4
  %573 = bitcast i32* %xerrno to i8*
  %call858 = call i32 @getsockopt(i32 %572, i32 1, i32 4, i8* %573, i32* %xlen) #5
  %tobool859 = icmp ne i32 %call858, 0
  br i1 %tobool859, label %if.then.860, label %if.end.862

if.then.860:                                      ; preds = %if.end.856
  %call861 = call i32* @__errno_location() #11
  %574 = load i32, i32* %call861, align 4
  store i32 %574, i32* %xerrno, align 4
  br label %if.end.862

if.end.862:                                       ; preds = %if.then.860, %if.end.856
  %575 = load i32, i32* %xerrno, align 4
  %tobool863 = icmp ne i32 %575, 0
  br i1 %tobool863, label %if.then.864, label %if.else.871

if.then.864:                                      ; preds = %if.end.862
  %576 = load i64, i64* @process_tick, align 8
  %inc865 = add nsw i64 %576, 1
  store i64 %inc865, i64* @process_tick, align 8
  %577 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %tick866 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %577, i32 0, i32 24
  store i64 %inc865, i64* %tick866, align 8
  %578 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %call867 = call i64 @builtin_lisp_symbol(i32 401)
  %579 = load i32, i32* %xerrno, align 4
  %conv868 = sext i32 %579 to i64
  %shl = shl i64 %conv868, 2
  %add869 = add i64 %shl, 2
  %call870 = call i64 @list2(i64 %call867, i64 %add869)
  call void @pset_status(%struct.Lisp_Process* %578, i64 %call870)
  %580 = load i64, i64* %proc, align 8
  call void @deactivate_process(i64 %580)
  br label %if.end.889

if.else.871:                                      ; preds = %if.end.862
  %581 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %call872 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %581, i64 %call872)
  %582 = load i64, i64* %proc, align 8
  %call873 = call i64 @build_string(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.38, i32 0, i32 0))
  call void @exec_sentinel(i64 %582, i64 %call873)
  %583 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %infd874 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %583, i32 0, i32 21
  %584 = load i32, i32* %infd874, align 4
  %cmp875 = icmp sle i32 0, %584
  br i1 %cmp875, label %land.lhs.true.877, label %if.end.888

land.lhs.true.877:                                ; preds = %if.else.871
  %585 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %585, i32 0, i32 4
  %586 = load i64, i64* %filter, align 8
  %call878 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp879 = icmp eq i64 %586, %call878
  br i1 %cmp879, label %if.end.888, label %land.lhs.true.881

land.lhs.true.881:                                ; preds = %land.lhs.true.877
  %587 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %587, i32 0, i32 3
  %588 = load i64, i64* %command, align 8
  %call882 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp883 = icmp eq i64 %588, %call882
  br i1 %cmp883, label %if.end.888, label %if.then.885

if.then.885:                                      ; preds = %land.lhs.true.881
  %589 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %infd886 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %589, i32 0, i32 21
  %590 = load i32, i32* %infd886, align 4
  call void @fd_SET(i32 %590, %struct.fd_set* @input_wait_mask)
  %591 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p844, align 8
  %infd887 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %591, i32 0, i32 21
  %592 = load i32, i32* %infd887, align 4
  call void @fd_SET(i32 %592, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.888

if.end.888:                                       ; preds = %if.then.885, %land.lhs.true.881, %land.lhs.true.877, %if.else.871
  br label %if.end.889

if.end.889:                                       ; preds = %if.end.888, %if.then.864
  br label %if.end.890

if.end.890:                                       ; preds = %if.end.889, %land.lhs.true.840, %if.end.837
  br label %for.inc.891

for.inc.891:                                      ; preds = %if.end.890, %if.then.855, %if.then.700, %if.then.693
  %593 = load i32, i32* %channel, align 4
  %inc892 = add nsw i32 %593, 1
  store i32 %inc892, i32* %channel, align 4
  br label %for.cond.675

for.end.893:                                      ; preds = %for.cond.675
  br label %while.body

while.end.894:                                    ; preds = %if.then.622, %if.then.603, %if.then.595, %if.then.548, %if.then.531, %if.then.511, %if.then.257, %if.end.248, %if.then.142, %if.then.93, %if.then.80
  %594 = load i64, i64* %count, align 8
  %call895 = call i64 @builtin_lisp_symbol(i32 0)
  %call896 = call i64 @unbind_to(i64 %594, i64 %call895)
  %595 = load i32, i32* %read_kbd.addr, align 4
  %cmp897 = icmp sge i32 %595, 0
  br i1 %cmp897, label %if.then.899, label %if.end.916

if.then.899:                                      ; preds = %while.end.894
  call void @clear_input_pending()
  br label %do.body.900

do.body.900:                                      ; preds = %if.then.899
  %596 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call901 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp902 = icmp eq i64 %596, %call901
  br i1 %cmp902, label %if.else.909, label %land.lhs.true.904

land.lhs.true.904:                                ; preds = %do.body.900
  %597 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call905 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp906 = icmp eq i64 %597, %call905
  br i1 %cmp906, label %if.then.908, label %if.else.909

if.then.908:                                      ; preds = %land.lhs.true.904
  call void @process_quit_flag()
  br label %if.end.913

if.else.909:                                      ; preds = %land.lhs.true.904, %do.body.900
  %598 = load volatile i8, i8* @pending_signals, align 1
  %tobool910 = trunc i8 %598 to i1
  br i1 %tobool910, label %if.then.911, label %if.end.912

if.then.911:                                      ; preds = %if.else.909
  call void @process_pending_signals()
  br label %if.end.912

if.end.912:                                       ; preds = %if.then.911, %if.else.909
  br label %if.end.913

if.end.913:                                       ; preds = %if.end.912, %if.then.908
  br label %do.end.915

do.end.915:                                       ; preds = %if.end.913
  br label %if.end.916

if.end.916:                                       ; preds = %do.end.915, %while.end.894
  %599 = load i32, i32* %got_some_output, align 4
  ret i32 %599
}

declare { i64, i64 } @invalid_timespec() #1

declare void @message1(i8*) #1

; Function Attrs: nounwind uwtable
define internal void @wait_reading_process_output_unwind(i32 %data) #0 {
entry:
  %data.addr = alloca i32, align 4
  store i32 %data, i32* %data.addr, align 4
  %0 = load i32, i32* %data.addr, align 4
  store i32 %0, i32* @waiting_for_user_input_p, align 4
  ret void
}

declare { i64, i64 } @current_timespec() #1

; Function Attrs: nounwind readnone
declare { i64, i64 } @timespec_add(i64, i64, i64, i64) #4

declare { i64, i64 } @make_timespec(i64, i64) #1

declare zeroext i1 @timespec_valid_p(i64, i64) #1

; Function Attrs: nounwind readonly
declare i32 @timespec_cmp(i64, i64, i64, i64) #3

; Function Attrs: nounwind readnone
declare { i64, i64 } @timespec_sub(i64, i64, i64, i64) #4

declare { i64, i64 } @timer_check() #1

declare void @record_asynch_buffer_change() #1

declare zeroext i1 @detect_input_pending() #1

declare zeroext i1 @requeued_events_pending_p() #1

; Function Attrs: nounwind uwtable
define internal void @wait_reading_process_output_1() #0 {
entry:
  ret void
}

declare void @set_waiting_for_input(%struct.timespec*) #1

; Function Attrs: nounwind uwtable
define zeroext i1 @kbd_on_hold_p() #0 {
entry:
  %0 = load i8, i8* @kbd_is_on_hold, align 1
  %tobool = trunc i8 %0 to i1
  ret i1 %tobool
}

declare void @clear_waiting_for_input() #1

; Function Attrs: nounwind uwtable
define internal i32 @read_process_output(i64 %proc, i32 %channel) #0 {
entry:
  %retval = alloca i32, align 4
  %proc.addr = alloca i64, align 8
  %channel.addr = alloca i32, align 4
  %nbytes = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %coding = alloca %struct.coding_system*, align 8
  %carryover = alloca i32, align 4
  %count = alloca i64, align 8
  %odeactivate = alloca i64, align 8
  %chars = alloca [4160 x i8], align 16
  %len = alloca i32, align 4
  %agg.tmp = alloca %union.__SOCKADDR_ARG, align 8
  %buffered = alloca i8, align 1
  %delay = alloca i32, align 4
  store i64 %proc, i64* %proc.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  %0 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %1 = load i32, i32* %channel.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_decode_coding_system, i32 0, i64 %idxprom
  %2 = load %struct.coding_system*, %struct.coding_system** %arrayidx, align 8
  store %struct.coding_system* %2, %struct.coding_system** %coding, align 8
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 26
  %4 = load i32, i32* %decoding_carryover, align 4
  store i32 %4, i32* %carryover, align 4
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %count, align 8
  %5 = load i32, i32* %carryover, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = bitcast [4160 x i8]* %chars to i8*
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_buf = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 14
  %8 = load i64, i64* %decoding_buf, align 8
  %call2 = call i8* @SDATA(i64 %8)
  %9 = load i32, i32* %carryover, align 4
  %conv = sext i32 %9 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %call2, i64 %conv, i32 1, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load i32, i32* %channel.addr, align 4
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom3
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx4, i32 0, i32 0
  %11 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp = icmp ne %struct.sockaddr* %11, null
  br i1 %cmp, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.end
  %12 = load i32, i32* %channel.addr, align 4
  %idxprom7 = sext i32 %12 to i64
  %arrayidx8 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom7
  %len9 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx8, i32 0, i32 1
  %13 = load i32, i32* %len9, align 4
  store i32 %13, i32* %len, align 4
  %14 = load i32, i32* %channel.addr, align 4
  %arraydecay = getelementptr inbounds [4160 x i8], [4160 x i8]* %chars, i32 0, i32 0
  %15 = load i32, i32* %carryover, align 4
  %idx.ext = sext i32 %15 to i64
  %add.ptr = getelementptr inbounds i8, i8* %arraydecay, i64 %idx.ext
  %__sockaddr__ = bitcast %union.__SOCKADDR_ARG* %agg.tmp to %struct.sockaddr**
  %16 = load i32, i32* %channel.addr, align 4
  %idxprom10 = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom10
  %sa12 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx11, i32 0, i32 0
  %17 = load %struct.sockaddr*, %struct.sockaddr** %sa12, align 8
  store %struct.sockaddr* %17, %struct.sockaddr** %__sockaddr__, align 8
  %coerce.dive = getelementptr %union.__SOCKADDR_ARG, %union.__SOCKADDR_ARG* %agg.tmp, i32 0, i32 0
  %18 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive, align 8
  %call13 = call i64 @recvfrom(i32 %14, i8* %add.ptr, i64 4096, i32 0, %struct.sockaddr* %18, i32* %len)
  store i64 %call13, i64* %nbytes, align 8
  br label %if.end.109

if.else:                                          ; preds = %if.end
  %19 = load i32, i32* %channel.addr, align 4
  %idxprom14 = sext i32 %19 to i64
  %arrayidx15 = getelementptr inbounds [1024 x i32], [1024 x i32]* @proc_buffered_char, i32 0, i64 %idxprom14
  %20 = load i32, i32* %arrayidx15, align 4
  %cmp16 = icmp sge i32 %20, 0
  %frombool = zext i1 %cmp16 to i8
  store i8 %frombool, i8* %buffered, align 1
  %21 = load i8, i8* %buffered, align 1
  %tobool18 = trunc i8 %21 to i1
  br i1 %tobool18, label %if.then.19, label %if.end.27

if.then.19:                                       ; preds = %if.else
  %22 = load i32, i32* %channel.addr, align 4
  %idxprom20 = sext i32 %22 to i64
  %arrayidx21 = getelementptr inbounds [1024 x i32], [1024 x i32]* @proc_buffered_char, i32 0, i64 %idxprom20
  %23 = load i32, i32* %arrayidx21, align 4
  %conv22 = trunc i32 %23 to i8
  %24 = load i32, i32* %carryover, align 4
  %idxprom23 = sext i32 %24 to i64
  %arrayidx24 = getelementptr inbounds [4160 x i8], [4160 x i8]* %chars, i32 0, i64 %idxprom23
  store i8 %conv22, i8* %arrayidx24, align 1
  %25 = load i32, i32* %channel.addr, align 4
  %idxprom25 = sext i32 %25 to i64
  %arrayidx26 = getelementptr inbounds [1024 x i32], [1024 x i32]* @proc_buffered_char, i32 0, i64 %idxprom25
  store i32 -1, i32* %arrayidx26, align 4
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.19, %if.else
  %26 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_p = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %26, i32 0, i32 39
  %bf.load = load i8, i8* %gnutls_p, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %land.lhs.true, label %if.else.42

land.lhs.true:                                    ; preds = %if.end.27
  %27 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_state = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %27, i32 0, i32 31
  %28 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state, align 8
  %tobool29 = icmp ne %struct.gnutls_session_int* %28, null
  br i1 %tobool29, label %if.then.30, label %if.else.42

if.then.30:                                       ; preds = %land.lhs.true
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %arraydecay31 = getelementptr inbounds [4160 x i8], [4160 x i8]* %chars, i32 0, i32 0
  %30 = load i32, i32* %carryover, align 4
  %idx.ext32 = sext i32 %30 to i64
  %add.ptr33 = getelementptr inbounds i8, i8* %arraydecay31, i64 %idx.ext32
  %31 = load i8, i8* %buffered, align 1
  %tobool34 = trunc i8 %31 to i1
  %conv35 = zext i1 %tobool34 to i32
  %idx.ext36 = sext i32 %conv35 to i64
  %add.ptr37 = getelementptr inbounds i8, i8* %add.ptr33, i64 %idx.ext36
  %32 = load i8, i8* %buffered, align 1
  %tobool38 = trunc i8 %32 to i1
  %conv39 = zext i1 %tobool38 to i32
  %sub = sub nsw i32 4096, %conv39
  %conv40 = sext i32 %sub to i64
  %call41 = call i64 @emacs_gnutls_read(%struct.Lisp_Process* %29, i8* %add.ptr37, i64 %conv40)
  store i64 %call41, i64* %nbytes, align 8
  br label %if.end.55

if.else.42:                                       ; preds = %land.lhs.true, %if.end.27
  %33 = load i32, i32* %channel.addr, align 4
  %arraydecay43 = getelementptr inbounds [4160 x i8], [4160 x i8]* %chars, i32 0, i32 0
  %34 = load i32, i32* %carryover, align 4
  %idx.ext44 = sext i32 %34 to i64
  %add.ptr45 = getelementptr inbounds i8, i8* %arraydecay43, i64 %idx.ext44
  %35 = load i8, i8* %buffered, align 1
  %tobool46 = trunc i8 %35 to i1
  %conv47 = zext i1 %tobool46 to i32
  %idx.ext48 = sext i32 %conv47 to i64
  %add.ptr49 = getelementptr inbounds i8, i8* %add.ptr45, i64 %idx.ext48
  %36 = load i8, i8* %buffered, align 1
  %tobool50 = trunc i8 %36 to i1
  %conv51 = zext i1 %tobool50 to i32
  %sub52 = sub nsw i32 4096, %conv51
  %conv53 = sext i32 %sub52 to i64
  %call54 = call i64 @emacs_read(i32 %33, i8* %add.ptr49, i64 %conv53)
  store i64 %call54, i64* %nbytes, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.else.42, %if.then.30
  %37 = load i64, i64* %nbytes, align 8
  %cmp56 = icmp sgt i64 %37, 0
  br i1 %cmp56, label %land.lhs.true.58, label %if.end.99

land.lhs.true.58:                                 ; preds = %if.end.55
  %38 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %adaptive_read_buffering = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %38, i32 0, i32 28
  %bf.load59 = load i8, i8* %adaptive_read_buffering, align 8
  %bf.clear60 = and i8 %bf.load59, 3
  %bf.cast61 = zext i8 %bf.clear60 to i32
  %tobool62 = icmp ne i32 %bf.cast61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.99

if.then.63:                                       ; preds = %land.lhs.true.58
  %39 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %39, i32 0, i32 27
  %40 = load i32, i32* %read_output_delay, align 4
  store i32 %40, i32* %delay, align 4
  %41 = load i64, i64* %nbytes, align 8
  %cmp64 = icmp slt i64 %41, 256
  br i1 %cmp64, label %if.then.66, label %if.else.75

if.then.66:                                       ; preds = %if.then.63
  %42 = load i32, i32* %delay, align 4
  %cmp67 = icmp slt i32 %42, 70000000
  br i1 %cmp67, label %if.then.69, label %if.end.74

if.then.69:                                       ; preds = %if.then.66
  %43 = load i32, i32* %delay, align 4
  %cmp70 = icmp eq i32 %43, 0
  br i1 %cmp70, label %if.then.72, label %if.end.73

if.then.72:                                       ; preds = %if.then.69
  %44 = load i32, i32* @process_output_delay_count, align 4
  %inc = add nsw i32 %44, 1
  store i32 %inc, i32* @process_output_delay_count, align 4
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.72, %if.then.69
  %45 = load i32, i32* %delay, align 4
  %add = add nsw i32 %45, 20000000
  store i32 %add, i32* %delay, align 4
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.73, %if.then.66
  br label %if.end.92

if.else.75:                                       ; preds = %if.then.63
  %46 = load i32, i32* %delay, align 4
  %cmp76 = icmp sgt i32 %46, 0
  br i1 %cmp76, label %land.lhs.true.78, label %if.end.91

land.lhs.true.78:                                 ; preds = %if.else.75
  %47 = load i64, i64* %nbytes, align 8
  %48 = load i8, i8* %buffered, align 1
  %tobool79 = trunc i8 %48 to i1
  %conv80 = zext i1 %tobool79 to i32
  %sub81 = sub nsw i32 4096, %conv80
  %conv82 = sext i32 %sub81 to i64
  %cmp83 = icmp eq i64 %47, %conv82
  br i1 %cmp83, label %if.then.85, label %if.end.91

if.then.85:                                       ; preds = %land.lhs.true.78
  %49 = load i32, i32* %delay, align 4
  %sub86 = sub nsw i32 %49, 10000000
  store i32 %sub86, i32* %delay, align 4
  %50 = load i32, i32* %delay, align 4
  %cmp87 = icmp eq i32 %50, 0
  br i1 %cmp87, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %if.then.85
  %51 = load i32, i32* @process_output_delay_count, align 4
  %dec = add nsw i32 %51, -1
  store i32 %dec, i32* @process_output_delay_count, align 4
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.89, %if.then.85
  br label %if.end.91

if.end.91:                                        ; preds = %if.end.90, %land.lhs.true.78, %if.else.75
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %if.end.74
  %52 = load i32, i32* %delay, align 4
  %53 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay93 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %53, i32 0, i32 27
  store i32 %52, i32* %read_output_delay93, align 4
  %54 = load i32, i32* %delay, align 4
  %tobool94 = icmp ne i32 %54, 0
  br i1 %tobool94, label %if.then.95, label %if.end.98

if.then.95:                                       ; preds = %if.end.92
  %55 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_skip = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %55, i32 0, i32 28
  %bf.load96 = load i8, i8* %read_output_skip, align 8
  %bf.clear97 = and i8 %bf.load96, -5
  %bf.set = or i8 %bf.clear97, 4
  store i8 %bf.set, i8* %read_output_skip, align 8
  store i8 1, i8* @process_output_skip, align 1
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.95, %if.end.92
  br label %if.end.99

if.end.99:                                        ; preds = %if.end.98, %land.lhs.true.58, %if.end.55
  %56 = load i8, i8* %buffered, align 1
  %tobool100 = trunc i8 %56 to i1
  %conv101 = zext i1 %tobool100 to i64
  %57 = load i64, i64* %nbytes, align 8
  %add102 = add nsw i64 %57, %conv101
  store i64 %add102, i64* %nbytes, align 8
  %58 = load i8, i8* %buffered, align 1
  %tobool103 = trunc i8 %58 to i1
  br i1 %tobool103, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.99
  %59 = load i64, i64* %nbytes, align 8
  %cmp105 = icmp sle i64 %59, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.99
  %60 = phi i1 [ false, %if.end.99 ], [ %cmp105, %land.rhs ]
  %land.ext = zext i1 %60 to i32
  %conv107 = sext i32 %land.ext to i64
  %61 = load i64, i64* %nbytes, align 8
  %add108 = add nsw i64 %61, %conv107
  store i64 %add108, i64* %nbytes, align 8
  br label %if.end.109

if.end.109:                                       ; preds = %land.end, %if.then.6
  %62 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_carryover110 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %62, i32 0, i32 26
  store i32 0, i32* %decoding_carryover110, align 4
  %63 = load i64, i64* %nbytes, align 8
  %cmp111 = icmp sle i64 %63, 0
  br i1 %cmp111, label %if.then.113, label %if.end.129

if.then.113:                                      ; preds = %if.end.109
  %64 = load i64, i64* %nbytes, align 8
  %cmp114 = icmp slt i64 %64, 0
  br i1 %cmp114, label %if.then.119, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.113
  %65 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode = getelementptr inbounds %struct.coding_system, %struct.coding_system* %65, i32 0, i32 1
  %bf.load116 = load i32, i32* %mode, align 8
  %bf.lshr = lshr i32 %bf.load116, 14
  %bf.clear117 = and i32 %bf.lshr, 31
  %and = and i32 %bf.clear117, 1
  %tobool118 = icmp ne i32 %and, 0
  br i1 %tobool118, label %if.then.119, label %if.end.121

if.then.119:                                      ; preds = %lor.lhs.false, %if.then.113
  %66 = load i64, i64* %nbytes, align 8
  %conv120 = trunc i64 %66 to i32
  store i32 %conv120, i32* %retval
  br label %return

if.end.121:                                       ; preds = %lor.lhs.false
  %67 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode122 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %67, i32 0, i32 1
  %bf.load123 = load i32, i32* %mode122, align 8
  %bf.lshr124 = lshr i32 %bf.load123, 14
  %bf.clear125 = and i32 %bf.lshr124, 31
  %or = or i32 %bf.clear125, 1
  %bf.load126 = load i32, i32* %mode122, align 8
  %bf.value = and i32 %or, 31
  %bf.shl = shl i32 %bf.value, 14
  %bf.clear127 = and i32 %bf.load126, -507905
  %bf.set128 = or i32 %bf.clear127, %bf.shl
  store i32 %bf.set128, i32* %mode122, align 8
  br label %if.end.129

if.end.129:                                       ; preds = %if.end.121, %if.end.109
  %68 = load i32, i32* %carryover, align 4
  %conv130 = sext i32 %68 to i64
  %69 = load i64, i64* %nbytes, align 8
  %add131 = add nsw i64 %69, %conv130
  store i64 %add131, i64* %nbytes, align 8
  %70 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  store i64 %70, i64* %odeactivate, align 8
  call void @record_unwind_current_buffer()
  %71 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %arraydecay132 = getelementptr inbounds [4160 x i8], [4160 x i8]* %chars, i32 0, i32 0
  %72 = load i64, i64* %nbytes, align 8
  %73 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  call void @read_and_dispose_of_process_output(%struct.Lisp_Process* %71, i8* %arraydecay132, i64 %72, %struct.coding_system* %73)
  %74 = load i64, i64* %odeactivate, align 8
  store i64 %74, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %75 = load i64, i64* %count, align 8
  %call133 = call i64 @builtin_lisp_symbol(i32 0)
  %call134 = call i64 @unbind_to(i64 %75, i64 %call133)
  %76 = load i64, i64* %nbytes, align 8
  %conv135 = trunc i64 %76 to i32
  store i32 %conv135, i32* %retval
  br label %return

return:                                           ; preds = %if.end.129, %if.then.119
  %77 = load i32, i32* %retval
  ret i32 %77
}

declare i32 @xg_select(i32, %struct.fd_set*, %struct.fd_set*, %struct.fd_set*, %struct.timespec*, %struct.__sigset_t*) #1

declare i64 @emacs_gnutls_record_check_pending(%struct.gnutls_session_int*) #1

declare void @do_pending_window_change(i1 zeroext) #1

declare zeroext i1 @detect_input_pending_run_timers(i1 zeroext) #1

declare void @swallow_events(i1 zeroext) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @keyboard_bit_set(%struct.fd_set* %mask) #0 {
entry:
  %retval = alloca i1, align 1
  %mask.addr = alloca %struct.fd_set*, align 8
  %fd = alloca i32, align 4
  store %struct.fd_set* %mask, %struct.fd_set** %mask.addr, align 8
  store i32 0, i32* %fd, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %fd, align 4
  %1 = load i32, i32* @max_input_desc, align 4
  %cmp = icmp sle i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %fd, align 4
  %3 = load %struct.fd_set*, %struct.fd_set** %mask.addr, align 8
  %call = call zeroext i1 @fd_ISSET(i32 %2, %struct.fd_set* %3)
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %4 = load i32, i32* %fd, align 4
  %call1 = call zeroext i1 @fd_ISSET(i32 %4, %struct.fd_set* @input_wait_mask)
  br i1 %call1, label %land.lhs.true.2, label %if.end

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %5 = load i32, i32* %fd, align 4
  %call3 = call zeroext i1 @fd_ISSET(i32 %5, %struct.fd_set* @non_keyboard_wait_mask)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.2
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.2, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load i32, i32* %fd, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %fd, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %7 = load i1, i1* %retval
  ret i1 %7
}

declare void @handle_input_available_signal(i32) #1

; Function Attrs: nounwind uwtable
define internal void @server_accept_connection(i64 %server, i32 %channel) #0 {
entry:
  %server.addr = alloca i64, align 8
  %channel.addr = alloca i32, align 4
  %proc = alloca i64, align 8
  %caller = alloca i64, align 8
  %name = alloca i64, align 8
  %buffer = alloca i64, align 8
  %contact = alloca i64, align 8
  %host = alloca i64, align 8
  %service = alloca i64, align 8
  %ps = alloca %struct.Lisp_Process*, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %s = alloca i32, align 4
  %saddr = alloca %union.u_sockaddr, align 4
  %len = alloca i32, align 4
  %count = alloca i64, align 8
  %agg.tmp = alloca %union.__SOCKADDR_ARG, align 8
  %code = alloca i32, align 4
  %ip = alloca i8*, align 8
  %ipv4_format = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %.compoundliteral28 = alloca [5 x i64], align 8
  %caller_format = alloca i64, align 8
  %.compoundliteral53 = alloca %union.Aligned_String, align 8
  %.compoundliteral61 = alloca [3 x i64], align 8
  %args = alloca [9 x i64], align 16
  %ip6 = alloca i16*, align 8
  %i = alloca i32, align 4
  %ipv6_format = alloca i64, align 8
  %.compoundliteral68 = alloca %union.Aligned_String, align 8
  %caller_format96 = alloca i64, align 8
  %.compoundliteral97 = alloca %union.Aligned_String, align 8
  %.compoundliteral105 = alloca [3 x i64], align 8
  %space_less_than = alloca i64, align 8
  %.compoundliteral115 = alloca %union.Aligned_String, align 8
  %greater_than = alloca i64, align 8
  %.compoundliteral123 = alloca %union.Aligned_String, align 8
  %agg.tmp182 = alloca %union.__SOCKADDR_ARG, align 8
  %dash = alloca i64, align 8
  %.compoundliteral219 = alloca %union.Aligned_String, align 8
  %nl = alloca i64, align 8
  %.compoundliteral227 = alloca %union.Aligned_String, align 8
  %host_string = alloca i64, align 8
  %accept_from = alloca i64, align 8
  %.compoundliteral246 = alloca %union.Aligned_String, align 8
  %open_from = alloca i64, align 8
  %.compoundliteral258 = alloca %union.Aligned_String, align 8
  store i64 %server, i64* %server.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  %0 = load i64, i64* %server.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %ps, align 8
  store i32 112, i32* %len, align 4
  %1 = load i32, i32* %channel.addr, align 4
  %__sockaddr__ = bitcast %union.__SOCKADDR_ARG* %agg.tmp to %struct.sockaddr**
  %sa = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr*
  store %struct.sockaddr* %sa, %struct.sockaddr** %__sockaddr__, align 8
  %coerce.dive = getelementptr %union.__SOCKADDR_ARG, %union.__SOCKADDR_ARG* %agg.tmp, i32 0, i32 0
  %2 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive, align 8
  %call1 = call i32 @accept4(i32 %1, %struct.sockaddr* %2, i32* %len, i32 524288)
  store i32 %call1, i32* %s, align 4
  %3 = load i32, i32* %s, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end.19

if.then:                                          ; preds = %entry
  %call2 = call i32* @__errno_location() #11
  %4 = load i32, i32* %call2, align 4
  store i32 %4, i32* %code, align 4
  %5 = load i32, i32* %code, align 4
  %cmp3 = icmp eq i32 %5, 11
  br i1 %cmp3, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.then
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i32, i32* %code, align 4
  %cmp5 = icmp eq i32 %6, 11
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end
  br label %return

if.end.7:                                         ; preds = %if.end
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %log = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 6
  %8 = load i64, i64* %log, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %8, %call8
  br i1 %cmp9, label %if.end.18, label %if.then.10

if.then.10:                                       ; preds = %if.end.7
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %log11 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 6
  %10 = load i64, i64* %log11, align 8
  %11 = load i64, i64* %server.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %call13 = call i64 @build_string(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.84, i32 0, i32 0))
  %12 = load i32, i32* %code, align 4
  %conv = sext i32 %12 to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  %call14 = call i64 @Fnumber_to_string(i64 %add)
  %call15 = call i64 @build_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0))
  %call16 = call i64 @concat3(i64 %call13, i64 %call14, i64 %call15)
  %call17 = call i64 @call3(i64 %10, i64 %11, i64 %call12, i64 %call16)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.10, %if.end.7
  br label %return

if.end.19:                                        ; preds = %entry
  %call20 = call i64 @SPECPDL_INDEX()
  store i64 %call20, i64* %count, align 8
  %13 = load i32, i32* %s, align 4
  call void @record_unwind_protect_int(void (i32)* @close_file_unwind, i32 %13)
  %14 = load i64, i64* @connect_counter, align 8
  %inc = add nsw i64 %14, 1
  store i64 %inc, i64* @connect_counter, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call21, i64* %host, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call22, i64* %service, align 8
  %sa23 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr*
  %sa_family = getelementptr inbounds %struct.sockaddr, %struct.sockaddr* %sa23, i32 0, i32 0
  %15 = load i16, i16* %sa_family, align 2
  %conv24 = zext i16 %15 to i32
  switch i32 %conv24, label %sw.default [
    i32 2, label %sw.bb
    i32 10, label %sw.bb.67
    i32 1, label %sw.bb.111
  ]

sw.bb:                                            ; preds = %if.end.19
  %in = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr_in*
  %sin_addr = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %in, i32 0, i32 2
  %s_addr = getelementptr inbounds %struct.in_addr, %struct.in_addr* %sin_addr, i32 0, i32 0
  %16 = bitcast i32* %s_addr to i8*
  store i8* %16, i8** %ip, align 8
  %s25 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s25, i32 0, i32 0
  store i64 11, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s25, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s25, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s25, i32 0, i32 3
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i32 0, i32 0), i8** %data, align 8
  %s26 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %17 = bitcast %struct.Lisp_String* %s26 to i8*
  %call27 = call i64 @make_lisp_ptr(i8* %17, i32 4)
  store i64 %call27, i64* %ipv4_format, align 8
  %arrayinit.begin = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral28, i64 0, i64 0
  %18 = load i64, i64* %ipv4_format, align 8
  store i64 %18, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %19 = load i8*, i8** %ip, align 8
  %arrayidx = getelementptr inbounds i8, i8* %19, i64 0
  %20 = load i8, i8* %arrayidx, align 1
  %conv29 = zext i8 %20 to i64
  %shl30 = shl i64 %conv29, 2
  %add31 = add i64 %shl30, 2
  store i64 %add31, i64* %arrayinit.element
  %arrayinit.element32 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %21 = load i8*, i8** %ip, align 8
  %arrayidx33 = getelementptr inbounds i8, i8* %21, i64 1
  %22 = load i8, i8* %arrayidx33, align 1
  %conv34 = zext i8 %22 to i64
  %shl35 = shl i64 %conv34, 2
  %add36 = add i64 %shl35, 2
  store i64 %add36, i64* %arrayinit.element32
  %arrayinit.element37 = getelementptr inbounds i64, i64* %arrayinit.element32, i64 1
  %23 = load i8*, i8** %ip, align 8
  %arrayidx38 = getelementptr inbounds i8, i8* %23, i64 2
  %24 = load i8, i8* %arrayidx38, align 1
  %conv39 = zext i8 %24 to i64
  %shl40 = shl i64 %conv39, 2
  %add41 = add i64 %shl40, 2
  store i64 %add41, i64* %arrayinit.element37
  %arrayinit.element42 = getelementptr inbounds i64, i64* %arrayinit.element37, i64 1
  %25 = load i8*, i8** %ip, align 8
  %arrayidx43 = getelementptr inbounds i8, i8* %25, i64 3
  %26 = load i8, i8* %arrayidx43, align 1
  %conv44 = zext i8 %26 to i64
  %shl45 = shl i64 %conv44, 2
  %add46 = add i64 %shl45, 2
  store i64 %add46, i64* %arrayinit.element42
  %arraydecay = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral28, i32 0, i32 0
  %call47 = call i64 @Fformat(i64 5, i64* %arraydecay)
  store i64 %call47, i64* %host, align 8
  %in48 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr_in*
  %sin_port = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %in48, i32 0, i32 1
  %27 = load i16, i16* %sin_port, align 2
  %call49 = call zeroext i16 @ntohs(i16 zeroext %27) #11
  %conv50 = zext i16 %call49 to i64
  %shl51 = shl i64 %conv50, 2
  %add52 = add i64 %shl51, 2
  store i64 %add52, i64* %service, align 8
  %s54 = bitcast %union.Aligned_String* %.compoundliteral53 to %struct.Lisp_String*
  %size55 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s54, i32 0, i32 0
  store i64 8, i64* %size55, align 8
  %size_byte56 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s54, i32 0, i32 1
  store i64 -1, i64* %size_byte56, align 8
  %intervals57 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s54, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals57, align 8
  %data58 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s54, i32 0, i32 3
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.86, i32 0, i32 0), i8** %data58, align 8
  %s59 = bitcast %union.Aligned_String* %.compoundliteral53 to %struct.Lisp_String*
  %28 = bitcast %struct.Lisp_String* %s59 to i8*
  %call60 = call i64 @make_lisp_ptr(i8* %28, i32 4)
  store i64 %call60, i64* %caller_format, align 8
  %arrayinit.begin62 = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral61, i64 0, i64 0
  %29 = load i64, i64* %caller_format, align 8
  store i64 %29, i64* %arrayinit.begin62
  %arrayinit.element63 = getelementptr inbounds i64, i64* %arrayinit.begin62, i64 1
  %30 = load i64, i64* %host, align 8
  store i64 %30, i64* %arrayinit.element63
  %arrayinit.element64 = getelementptr inbounds i64, i64* %arrayinit.element63, i64 1
  %31 = load i64, i64* %service, align 8
  store i64 %31, i64* %arrayinit.element64
  %arraydecay65 = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral61, i32 0, i32 0
  %call66 = call i64 @Fformat(i64 3, i64* %arraydecay65)
  store i64 %call66, i64* %caller, align 8
  br label %sw.epilog

sw.bb.67:                                         ; preds = %if.end.19
  %in6 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr_in6*
  %sin6_addr = getelementptr inbounds %struct.sockaddr_in6, %struct.sockaddr_in6* %in6, i32 0, i32 3
  %32 = bitcast %struct.in6_addr* %sin6_addr to i16*
  store i16* %32, i16** %ip6, align 8
  %s69 = bitcast %union.Aligned_String* %.compoundliteral68 to %struct.Lisp_String*
  %size70 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s69, i32 0, i32 0
  store i64 23, i64* %size70, align 8
  %size_byte71 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s69, i32 0, i32 1
  store i64 -1, i64* %size_byte71, align 8
  %intervals72 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s69, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals72, align 8
  %data73 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s69, i32 0, i32 3
  store i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.2, i32 0, i32 0), i8** %data73, align 8
  %s74 = bitcast %union.Aligned_String* %.compoundliteral68 to %struct.Lisp_String*
  %33 = bitcast %struct.Lisp_String* %s74 to i8*
  %call75 = call i64 @make_lisp_ptr(i8* %33, i32 4)
  store i64 %call75, i64* %ipv6_format, align 8
  %34 = load i64, i64* %ipv6_format, align 8
  %arrayidx76 = getelementptr inbounds [9 x i64], [9 x i64]* %args, i32 0, i64 0
  store i64 %34, i64* %arrayidx76, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.67
  %35 = load i32, i32* %i, align 4
  %cmp77 = icmp slt i32 %35, 8
  br i1 %cmp77, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load i32, i32* %i, align 4
  %idxprom = sext i32 %36 to i64
  %37 = load i16*, i16** %ip6, align 8
  %arrayidx79 = getelementptr inbounds i16, i16* %37, i64 %idxprom
  %38 = load i16, i16* %arrayidx79, align 2
  %call80 = call zeroext i16 @ntohs(i16 zeroext %38) #11
  %conv81 = zext i16 %call80 to i64
  %shl82 = shl i64 %conv81, 2
  %add83 = add i64 %shl82, 2
  %39 = load i32, i32* %i, align 4
  %add84 = add nsw i32 %39, 1
  %idxprom85 = sext i32 %add84 to i64
  %arrayidx86 = getelementptr inbounds [9 x i64], [9 x i64]* %args, i32 0, i64 %idxprom85
  store i64 %add83, i64* %arrayidx86, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %40 = load i32, i32* %i, align 4
  %inc87 = add nsw i32 %40, 1
  store i32 %inc87, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arraydecay88 = getelementptr inbounds [9 x i64], [9 x i64]* %args, i32 0, i32 0
  %call89 = call i64 @Fformat(i64 9, i64* %arraydecay88)
  store i64 %call89, i64* %host, align 8
  %in90 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr_in*
  %sin_port91 = getelementptr inbounds %struct.sockaddr_in, %struct.sockaddr_in* %in90, i32 0, i32 1
  %41 = load i16, i16* %sin_port91, align 2
  %call92 = call zeroext i16 @ntohs(i16 zeroext %41) #11
  %conv93 = zext i16 %call92 to i64
  %shl94 = shl i64 %conv93, 2
  %add95 = add i64 %shl94, 2
  store i64 %add95, i64* %service, align 8
  %s98 = bitcast %union.Aligned_String* %.compoundliteral97 to %struct.Lisp_String*
  %size99 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s98, i32 0, i32 0
  store i64 10, i64* %size99, align 8
  %size_byte100 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s98, i32 0, i32 1
  store i64 -1, i64* %size_byte100, align 8
  %intervals101 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s98, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals101, align 8
  %data102 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s98, i32 0, i32 3
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.87, i32 0, i32 0), i8** %data102, align 8
  %s103 = bitcast %union.Aligned_String* %.compoundliteral97 to %struct.Lisp_String*
  %42 = bitcast %struct.Lisp_String* %s103 to i8*
  %call104 = call i64 @make_lisp_ptr(i8* %42, i32 4)
  store i64 %call104, i64* %caller_format96, align 8
  %arrayinit.begin106 = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral105, i64 0, i64 0
  %43 = load i64, i64* %caller_format96, align 8
  store i64 %43, i64* %arrayinit.begin106
  %arrayinit.element107 = getelementptr inbounds i64, i64* %arrayinit.begin106, i64 1
  %44 = load i64, i64* %host, align 8
  store i64 %44, i64* %arrayinit.element107
  %arrayinit.element108 = getelementptr inbounds i64, i64* %arrayinit.element107, i64 1
  %45 = load i64, i64* %service, align 8
  store i64 %45, i64* %arrayinit.element108
  %arraydecay109 = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral105, i32 0, i32 0
  %call110 = call i64 @Fformat(i64 3, i64* %arraydecay109)
  store i64 %call110, i64* %caller, align 8
  br label %sw.epilog

sw.bb.111:                                        ; preds = %if.end.19
  br label %sw.default

sw.default:                                       ; preds = %if.end.19, %sw.bb.111
  %46 = load i64, i64* @connect_counter, align 8
  %shl112 = shl i64 %46, 2
  %add113 = add i64 %shl112, 2
  %call114 = call i64 @Fnumber_to_string(i64 %add113)
  store i64 %call114, i64* %caller, align 8
  %s116 = bitcast %union.Aligned_String* %.compoundliteral115 to %struct.Lisp_String*
  %size117 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s116, i32 0, i32 0
  store i64 2, i64* %size117, align 8
  %size_byte118 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s116, i32 0, i32 1
  store i64 -1, i64* %size_byte118, align 8
  %intervals119 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s116, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals119, align 8
  %data120 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s116, i32 0, i32 3
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.88, i32 0, i32 0), i8** %data120, align 8
  %s121 = bitcast %union.Aligned_String* %.compoundliteral115 to %struct.Lisp_String*
  %47 = bitcast %struct.Lisp_String* %s121 to i8*
  %call122 = call i64 @make_lisp_ptr(i8* %47, i32 4)
  store i64 %call122, i64* %space_less_than, align 8
  %s124 = bitcast %union.Aligned_String* %.compoundliteral123 to %struct.Lisp_String*
  %size125 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s124, i32 0, i32 0
  store i64 1, i64* %size125, align 8
  %size_byte126 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s124, i32 0, i32 1
  store i64 -1, i64* %size_byte126, align 8
  %intervals127 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s124, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals127, align 8
  %data128 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s124, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.89, i32 0, i32 0), i8** %data128, align 8
  %s129 = bitcast %union.Aligned_String* %.compoundliteral123 to %struct.Lisp_String*
  %48 = bitcast %struct.Lisp_String* %s129 to i8*
  %call130 = call i64 @make_lisp_ptr(i8* %48, i32 4)
  store i64 %call130, i64* %greater_than, align 8
  %49 = load i64, i64* %space_less_than, align 8
  %50 = load i64, i64* %caller, align 8
  %51 = load i64, i64* %greater_than, align 8
  %call131 = call i64 @concat3(i64 %49, i64 %50, i64 %51)
  store i64 %call131, i64* %caller, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %for.end, %sw.bb
  %52 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %52, i32 0, i32 4
  %53 = load i64, i64* %filter, align 8
  %call132 = call i64 @builtin_lisp_symbol(i32 564)
  %cmp133 = icmp eq i64 %53, %call132
  br i1 %cmp133, label %if.else, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %54 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %filter135 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %54, i32 0, i32 4
  %55 = load i64, i64* %filter135, align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp137 = icmp eq i64 %55, %call136
  br i1 %cmp137, label %if.else, label %if.then.139

if.then.139:                                      ; preds = %lor.lhs.false
  %call140 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call140, i64* %buffer, align 8
  br label %if.end.157

if.else:                                          ; preds = %lor.lhs.false, %sw.epilog
  %56 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %buffer141 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %56, i32 0, i32 7
  %57 = load i64, i64* %buffer141, align 8
  store i64 %57, i64* %buffer, align 8
  %58 = load i64, i64* %buffer, align 8
  %call142 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp143 = icmp eq i64 %58, %call142
  br i1 %cmp143, label %if.else.147, label %if.then.145

if.then.145:                                      ; preds = %if.else
  %59 = load i64, i64* %buffer, align 8
  %call146 = call i64 @Fbuffer_name(i64 %59)
  store i64 %call146, i64* %buffer, align 8
  br label %if.end.149

if.else.147:                                      ; preds = %if.else
  %60 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %name148 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %60, i32 0, i32 2
  %61 = load i64, i64* %name148, align 8
  store i64 %61, i64* %buffer, align 8
  br label %if.end.149

if.end.149:                                       ; preds = %if.else.147, %if.then.145
  %62 = load i64, i64* %buffer, align 8
  %call150 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp151 = icmp eq i64 %62, %call150
  br i1 %cmp151, label %if.end.156, label %if.then.153

if.then.153:                                      ; preds = %if.end.149
  %63 = load i64, i64* %buffer, align 8
  %64 = load i64, i64* %caller, align 8
  %call154 = call i64 @concat2(i64 %63, i64 %64)
  store i64 %call154, i64* %buffer, align 8
  %65 = load i64, i64* %buffer, align 8
  %call155 = call i64 @Fget_buffer_create(i64 %65)
  store i64 %call155, i64* %buffer, align 8
  br label %if.end.156

if.end.156:                                       ; preds = %if.then.153, %if.end.149
  br label %if.end.157

if.end.157:                                       ; preds = %if.end.156, %if.then.139
  %66 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %name158 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %66, i32 0, i32 2
  %67 = load i64, i64* %name158, align 8
  %68 = load i64, i64* %caller, align 8
  %call159 = call i64 @concat2(i64 %67, i64 %68)
  store i64 %call159, i64* %name, align 8
  %69 = load i64, i64* %name, align 8
  %call160 = call i64 @make_process(i64 %69)
  store i64 %call160, i64* %proc, align 8
  %70 = load i64, i64* %proc, align 8
  %71 = load i32, i32* %s, align 4
  %idxprom161 = sext i32 %71 to i64
  %arrayidx162 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom161
  store i64 %70, i64* %arrayidx162, align 8
  %72 = load i32, i32* %s, align 4
  %call163 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %72, i32 4, i32 2048)
  %73 = load i64, i64* %proc, align 8
  %call164 = call %struct.Lisp_Process* @XPROCESS(i64 %73)
  store %struct.Lisp_Process* %call164, %struct.Lisp_Process** %p, align 8
  %74 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %childp = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %74, i32 0, i32 8
  %75 = load i64, i64* %childp, align 8
  %call165 = call i64 @Fcopy_sequence(i64 %75)
  store i64 %call165, i64* %contact, align 8
  %76 = load i64, i64* %contact, align 8
  %call166 = call i64 @builtin_lisp_symbol(i32 116)
  %call167 = call i64 @builtin_lisp_symbol(i32 0)
  %call168 = call i64 @Fplist_put(i64 %76, i64 %call166, i64 %call167)
  store i64 %call168, i64* %contact, align 8
  %77 = load i64, i64* %contact, align 8
  %call169 = call i64 @builtin_lisp_symbol(i32 63)
  %78 = load i64, i64* %host, align 8
  %call170 = call i64 @Fplist_put(i64 %77, i64 %call169, i64 %78)
  store i64 %call170, i64* %contact, align 8
  %79 = load i64, i64* %service, align 8
  %call171 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp172 = icmp eq i64 %79, %call171
  br i1 %cmp172, label %if.end.177, label %if.then.174

if.then.174:                                      ; preds = %if.end.157
  %80 = load i64, i64* %contact, align 8
  %call175 = call i64 @builtin_lisp_symbol(i32 117)
  %81 = load i64, i64* %service, align 8
  %call176 = call i64 @Fplist_put(i64 %80, i64 %call175, i64 %81)
  store i64 %call176, i64* %contact, align 8
  br label %if.end.177

if.end.177:                                       ; preds = %if.then.174, %if.end.157
  %82 = load i64, i64* %contact, align 8
  %call178 = call i64 @builtin_lisp_symbol(i32 108)
  %sa179 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr*
  %83 = load i32, i32* %len, align 4
  %call180 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %sa179, i32 %83)
  %call181 = call i64 @Fplist_put(i64 %82, i64 %call178, i64 %call180)
  store i64 %call181, i64* %contact, align 8
  store i32 112, i32* %len, align 4
  %84 = load i32, i32* %s, align 4
  %__sockaddr__183 = bitcast %union.__SOCKADDR_ARG* %agg.tmp182 to %struct.sockaddr**
  %sa184 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr*
  store %struct.sockaddr* %sa184, %struct.sockaddr** %__sockaddr__183, align 8
  %coerce.dive185 = getelementptr %union.__SOCKADDR_ARG, %union.__SOCKADDR_ARG* %agg.tmp182, i32 0, i32 0
  %85 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive185, align 8
  %call186 = call i32 @getsockname(i32 %84, %struct.sockaddr* %85, i32* %len) #5
  %cmp187 = icmp eq i32 %call186, 0
  br i1 %cmp187, label %if.then.189, label %if.end.194

if.then.189:                                      ; preds = %if.end.177
  %86 = load i64, i64* %contact, align 8
  %call190 = call i64 @builtin_lisp_symbol(i32 77)
  %sa191 = bitcast %union.u_sockaddr* %saddr to %struct.sockaddr*
  %87 = load i32, i32* %len, align 4
  %call192 = call i64 @conv_sockaddr_to_lisp(%struct.sockaddr* %sa191, i32 %87)
  %call193 = call i64 @Fplist_put(i64 %86, i64 %call190, i64 %call192)
  store i64 %call193, i64* %contact, align 8
  br label %if.end.194

if.end.194:                                       ; preds = %if.then.189, %if.end.177
  %88 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %89 = load i64, i64* %contact, align 8
  call void @pset_childp(%struct.Lisp_Process* %88, i64 %89)
  %90 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %91 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %plist = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %91, i32 0, i32 9
  %92 = load i64, i64* %plist, align 8
  %call195 = call i64 @Fcopy_sequence(i64 %92)
  call void @pset_plist(%struct.Lisp_Process* %90, i64 %call195)
  %93 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call196 = call i64 @builtin_lisp_symbol(i32 699)
  call void @pset_type(%struct.Lisp_Process* %93, i64 %call196)
  %94 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %95 = load i64, i64* %buffer, align 8
  call void @pset_buffer(%struct.Lisp_Process* %94, i64 %95)
  %96 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %97 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %sentinel = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %97, i32 0, i32 5
  %98 = load i64, i64* %sentinel, align 8
  call void @pset_sentinel(%struct.Lisp_Process* %96, i64 %98)
  %99 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %100 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %filter197 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %100, i32 0, i32 4
  %101 = load i64, i64* %filter197, align 8
  call void @pset_filter(%struct.Lisp_Process* %99, i64 %101)
  %102 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call198 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_command(%struct.Lisp_Process* %102, i64 %call198)
  %103 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %103, i32 0, i32 20
  store i32 0, i32* %pid, align 4
  %104 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %105 = load i64, i64* %count, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %104, i64 %105
  store %union.specbinding* %add.ptr, %union.specbinding** @specpdl_ptr, align 8
  %106 = load i32, i32* %s, align 4
  %107 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %107, i32 0, i32 23
  %arrayidx199 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 0
  store i32 %106, i32* %arrayidx199, align 4
  %108 = load i32, i32* %s, align 4
  %109 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %109, i32 0, i32 21
  store i32 %108, i32* %infd, align 4
  %110 = load i32, i32* %s, align 4
  %111 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %111, i32 0, i32 22
  store i32 %110, i32* %outfd, align 4
  %112 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call200 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %112, i64 %call200)
  %113 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter201 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %113, i32 0, i32 4
  %114 = load i64, i64* %filter201, align 8
  %call202 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp203 = icmp eq i64 %114, %call202
  br i1 %cmp203, label %if.end.206, label %if.then.205

if.then.205:                                      ; preds = %if.end.194
  %115 = load i32, i32* %s, align 4
  call void @fd_SET(i32 %115, %struct.fd_set* @input_wait_mask)
  %116 = load i32, i32* %s, align 4
  call void @fd_SET(i32 %116, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.206

if.end.206:                                       ; preds = %if.then.205, %if.end.194
  %117 = load i32, i32* %s, align 4
  %118 = load i32, i32* @max_process_desc, align 4
  %cmp207 = icmp sgt i32 %117, %118
  br i1 %cmp207, label %if.then.209, label %if.end.210

if.then.209:                                      ; preds = %if.end.206
  %119 = load i32, i32* %s, align 4
  store i32 %119, i32* @max_process_desc, align 4
  br label %if.end.210

if.end.210:                                       ; preds = %if.then.209, %if.end.206
  %120 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %121 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %121, i32 0, i32 13
  %122 = load i64, i64* %decode_coding_system, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %120, i64 %122)
  %123 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %124 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %124, i32 0, i32 15
  %125 = load i64, i64* %encode_coding_system, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %123, i64 %125)
  %126 = load i64, i64* %proc, align 8
  call void @setup_process_coding_systems(i64 %126)
  %127 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %128 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_decoding_buf(%struct.Lisp_Process* %127, i64 %128)
  %129 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %129, i32 0, i32 26
  store i32 0, i32* %decoding_carryover, align 4
  %130 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %131 = load i64, i64* @empty_unibyte_string, align 8
  call void @pset_encoding_buf(%struct.Lisp_Process* %130, i64 %131)
  %132 = load i64, i64* %buffer, align 8
  %call211 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp212 = icmp eq i64 %132, %call211
  br i1 %cmp212, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.210
  br label %cond.end

cond.false:                                       ; preds = %if.end.210
  %133 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %133, i32 0, i32 28
  %bf.load = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %conv214 = zext i1 %bf.cast to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %conv214, %cond.false ]
  %tobool = icmp ne i32 %cond, 0
  %134 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %inherit_coding_system_flag215 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %134, i32 0, i32 28
  %135 = zext i1 %tobool to i8
  %bf.load216 = load i8, i8* %inherit_coding_system_flag215, align 8
  %bf.shl = shl i8 %135, 5
  %bf.clear217 = and i8 %bf.load216, -33
  %bf.set = or i8 %bf.clear217, %bf.shl
  store i8 %bf.set, i8* %inherit_coding_system_flag215, align 8
  %tobool218 = trunc i8 %135 to i1
  %s220 = bitcast %union.Aligned_String* %.compoundliteral219 to %struct.Lisp_String*
  %size221 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s220, i32 0, i32 0
  store i64 1, i64* %size221, align 8
  %size_byte222 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s220, i32 0, i32 1
  store i64 -1, i64* %size_byte222, align 8
  %intervals223 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s220, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals223, align 8
  %data224 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s220, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.90, i32 0, i32 0), i8** %data224, align 8
  %s225 = bitcast %union.Aligned_String* %.compoundliteral219 to %struct.Lisp_String*
  %136 = bitcast %struct.Lisp_String* %s225 to i8*
  %call226 = call i64 @make_lisp_ptr(i8* %136, i32 4)
  store i64 %call226, i64* %dash, align 8
  %s228 = bitcast %union.Aligned_String* %.compoundliteral227 to %struct.Lisp_String*
  %size229 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s228, i32 0, i32 0
  store i64 1, i64* %size229, align 8
  %size_byte230 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s228, i32 0, i32 1
  store i64 -1, i64* %size_byte230, align 8
  %intervals231 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s228, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals231, align 8
  %data232 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s228, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0), i8** %data232, align 8
  %s233 = bitcast %union.Aligned_String* %.compoundliteral227 to %struct.Lisp_String*
  %137 = bitcast %struct.Lisp_String* %s233 to i8*
  %call234 = call i64 @make_lisp_ptr(i8* %137, i32 4)
  store i64 %call234, i64* %nl, align 8
  %138 = load i64, i64* %host, align 8
  %call235 = call zeroext i1 @STRINGP(i64 %138)
  br i1 %call235, label %cond.true.237, label %cond.false.238

cond.true.237:                                    ; preds = %cond.end
  %139 = load i64, i64* %host, align 8
  br label %cond.end.239

cond.false.238:                                   ; preds = %cond.end
  %140 = load i64, i64* %dash, align 8
  br label %cond.end.239

cond.end.239:                                     ; preds = %cond.false.238, %cond.true.237
  %cond240 = phi i64 [ %139, %cond.true.237 ], [ %140, %cond.false.238 ]
  store i64 %cond240, i64* %host_string, align 8
  %141 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %log241 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %141, i32 0, i32 6
  %142 = load i64, i64* %log241, align 8
  %call242 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp243 = icmp eq i64 %142, %call242
  br i1 %cmp243, label %if.end.257, label %if.then.245

if.then.245:                                      ; preds = %cond.end.239
  %s247 = bitcast %union.Aligned_String* %.compoundliteral246 to %struct.Lisp_String*
  %size248 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s247, i32 0, i32 0
  store i64 12, i64* %size248, align 8
  %size_byte249 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s247, i32 0, i32 1
  store i64 -1, i64* %size_byte249, align 8
  %intervals250 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s247, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals250, align 8
  %data251 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s247, i32 0, i32 3
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.91, i32 0, i32 0), i8** %data251, align 8
  %s252 = bitcast %union.Aligned_String* %.compoundliteral246 to %struct.Lisp_String*
  %143 = bitcast %struct.Lisp_String* %s252 to i8*
  %call253 = call i64 @make_lisp_ptr(i8* %143, i32 4)
  store i64 %call253, i64* %accept_from, align 8
  %144 = load %struct.Lisp_Process*, %struct.Lisp_Process** %ps, align 8
  %log254 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %144, i32 0, i32 6
  %145 = load i64, i64* %log254, align 8
  %146 = load i64, i64* %server.addr, align 8
  %147 = load i64, i64* %proc, align 8
  %148 = load i64, i64* %accept_from, align 8
  %149 = load i64, i64* %host_string, align 8
  %150 = load i64, i64* %nl, align 8
  %call255 = call i64 @concat3(i64 %148, i64 %149, i64 %150)
  %call256 = call i64 @call3(i64 %145, i64 %146, i64 %147, i64 %call255)
  br label %if.end.257

if.end.257:                                       ; preds = %if.then.245, %cond.end.239
  %s259 = bitcast %union.Aligned_String* %.compoundliteral258 to %struct.Lisp_String*
  %size260 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s259, i32 0, i32 0
  store i64 10, i64* %size260, align 8
  %size_byte261 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s259, i32 0, i32 1
  store i64 -1, i64* %size_byte261, align 8
  %intervals262 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s259, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals262, align 8
  %data263 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s259, i32 0, i32 3
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.92, i32 0, i32 0), i8** %data263, align 8
  %s264 = bitcast %union.Aligned_String* %.compoundliteral258 to %struct.Lisp_String*
  %151 = bitcast %struct.Lisp_String* %s264 to i8*
  %call265 = call i64 @make_lisp_ptr(i8* %151, i32 4)
  store i64 %call265, i64* %open_from, align 8
  %152 = load i64, i64* %proc, align 8
  %153 = load i64, i64* %open_from, align 8
  %154 = load i64, i64* %host_string, align 8
  %155 = load i64, i64* %nl, align 8
  %call266 = call i64 @concat3(i64 %153, i64 %154, i64 %155)
  call void @exec_sentinel(i64 %152, i64 %call266)
  br label %return

return:                                           ; preds = %if.end.257, %if.end.18, %if.then.6, %if.then.4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @deactivate_process(i64 %proc) #0 {
entry:
  %proc.addr = alloca i64, align 8
  %inchannel = alloca i32, align 4
  %p = alloca %struct.Lisp_Process*, align 8
  %i = alloca i32, align 4
  %i35 = alloca i32, align 4
  store i64 %proc, i64* %proc.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %1 = load i64, i64* %proc.addr, align 8
  %call1 = call i64 @emacs_gnutls_deinit(i64 %1)
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 27
  %3 = load i32, i32* %read_output_delay, align 4
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end.5

if.then:                                          ; preds = %entry
  %4 = load i32, i32* @process_output_delay_count, align 4
  %dec = add nsw i32 %4, -1
  store i32 %dec, i32* @process_output_delay_count, align 4
  %cmp2 = icmp slt i32 %dec, 0
  br i1 %cmp2, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  store i32 0, i32* @process_output_delay_count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 27
  store i32 0, i32* %read_output_delay4, align 4
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_skip = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 28
  %bf.load = load i8, i8* %read_output_skip, align 8
  %bf.clear = and i8 %bf.load, -5
  store i8 %bf.clear, i8* %read_output_skip, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.end, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.5
  %7 = load i32, i32* %i, align 4
  %cmp6 = icmp slt i32 %7, 6
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32, i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 23
  %arrayidx = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 %idxprom
  call void @close_process_fd(i32* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 21
  %12 = load i32, i32* %infd, align 4
  store i32 %12, i32* %inchannel, align 4
  %13 = load i32, i32* %inchannel, align 4
  %cmp7 = icmp sge i32 %13, 0
  br i1 %cmp7, label %if.then.8, label %if.end.43

if.then.8:                                        ; preds = %for.end
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 21
  store i32 -1, i32* %infd9, align 4
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 22
  store i32 -1, i32* %outfd, align 4
  %16 = load i32, i32* %inchannel, align 4
  %idxprom10 = sext i32 %16 to i64
  %arrayidx11 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom10
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx11, i32 0, i32 0
  %17 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp12 = icmp ne %struct.sockaddr* %17, null
  br i1 %cmp12, label %if.then.13, label %if.end.22

if.then.13:                                       ; preds = %if.then.8
  %18 = load i32, i32* %inchannel, align 4
  %idxprom14 = sext i32 %18 to i64
  %arrayidx15 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom14
  %sa16 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx15, i32 0, i32 0
  %19 = load %struct.sockaddr*, %struct.sockaddr** %sa16, align 8
  %20 = bitcast %struct.sockaddr* %19 to i8*
  call void @xfree(i8* %20)
  %21 = load i32, i32* %inchannel, align 4
  %idxprom17 = sext i32 %21 to i64
  %arrayidx18 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom17
  %sa19 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx18, i32 0, i32 0
  store %struct.sockaddr* null, %struct.sockaddr** %sa19, align 8
  %22 = load i32, i32* %inchannel, align 4
  %idxprom20 = sext i32 %22 to i64
  %arrayidx21 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom20
  %len = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx21, i32 0, i32 1
  store i32 0, i32* %len, align 4
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.13, %if.then.8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %23 = load i32, i32* %inchannel, align 4
  %idxprom24 = sext i32 %23 to i64
  %arrayidx25 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom24
  store i64 %call23, i64* %arrayidx25, align 8
  %24 = load i32, i32* %inchannel, align 4
  call void @fd_CLR(i32 %24, %struct.fd_set* @input_wait_mask)
  %25 = load i32, i32* %inchannel, align 4
  call void @fd_CLR(i32 %25, %struct.fd_set* @non_keyboard_wait_mask)
  %26 = load i32, i32* %inchannel, align 4
  %call26 = call zeroext i1 @fd_ISSET(i32 %26, %struct.fd_set* @connect_wait_mask)
  br i1 %call26, label %if.then.27, label %if.end.32

if.then.27:                                       ; preds = %if.end.22
  %27 = load i32, i32* %inchannel, align 4
  call void @fd_CLR(i32 %27, %struct.fd_set* @connect_wait_mask)
  %28 = load i32, i32* %inchannel, align 4
  call void @fd_CLR(i32 %28, %struct.fd_set* @write_mask)
  %29 = load i32, i32* @num_pending_connects, align 4
  %dec28 = add nsw i32 %29, -1
  store i32 %dec28, i32* @num_pending_connects, align 4
  %cmp29 = icmp slt i32 %dec28, 0
  br i1 %cmp29, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.then.27
  call void @emacs_abort() #8
  unreachable

if.end.31:                                        ; preds = %if.then.27
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.end.22
  %30 = load i32, i32* %inchannel, align 4
  %31 = load i32, i32* @max_process_desc, align 4
  %cmp33 = icmp eq i32 %30, %31
  br i1 %cmp33, label %if.then.34, label %if.end.42

if.then.34:                                       ; preds = %if.end.32
  %32 = load i32, i32* %inchannel, align 4
  store i32 %32, i32* %i35, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %if.then.34
  %33 = load i32, i32* %i35, align 4
  %dec36 = add nsw i32 %33, -1
  store i32 %dec36, i32* %i35, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %34 = load i32, i32* %i35, align 4
  %cmp37 = icmp sle i32 0, %34
  br i1 %cmp37, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %35 = load i32, i32* %i35, align 4
  %idxprom38 = sext i32 %35 to i64
  %arrayidx39 = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom38
  %36 = load i64, i64* %arrayidx39, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %36, %call40
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %37 = phi i1 [ false, %do.cond ], [ %cmp41, %land.rhs ]
  br i1 %37, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %38 = load i32, i32* %i35, align 4
  store i32 %38, i32* @max_process_desc, align 4
  br label %if.end.42

if.end.42:                                        ; preds = %do.end, %if.end.32
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @exec_sentinel(i64 %proc, i64 %reason) #0 {
entry:
  %proc.addr = alloca i64, align 8
  %reason.addr = alloca i64, align 8
  %sentinel = alloca i64, align 8
  %odeactivate = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %count = alloca i64, align 8
  %outer_running_asynch_code = alloca i8, align 1
  %waiting = alloca i32, align 4
  %tem = alloca i64, align 8
  store i64 %proc, i64* %proc.addr, align 8
  store i64 %reason, i64* %reason.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %count, align 8
  %1 = load i8, i8* @running_asynch_code, align 1
  %tobool = trunc i8 %1 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %outer_running_asynch_code, align 1
  %2 = load i32, i32* @waiting_for_user_input_p, align 4
  store i32 %2, i32* %waiting, align 4
  %3 = load i8, i8* @inhibit_sentinels, align 1
  %tobool2 = trunc i8 %3 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  store i64 %4, i64* %odeactivate, align 8
  call void @record_unwind_current_buffer()
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %sentinel3 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 5
  %6 = load i64, i64* %sentinel3, align 8
  store i64 %6, i64* %sentinel, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 546)
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call4, i64 %call5)
  %call6 = call i64 @builtin_lisp_symbol(i32 604)
  %call7 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call6, i64 %call7)
  %7 = load i8, i8* %outer_running_asynch_code, align 1
  %tobool8 = trunc i8 %7 to i1
  br i1 %tobool8, label %if.then.9, label %if.end.16

if.then.9:                                        ; preds = %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %call13 = call i64 @Fmatch_data(i64 %call10, i64 %call11, i64 %call12)
  store i64 %call13, i64* %tem, align 8
  call void @restore_search_regs()
  call void @record_unwind_save_match_data()
  %8 = load i64, i64* %tem, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 901)
  %call15 = call i64 @Fset_match_data(i64 %8, i64 %call14)
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.9, %if.end
  store i8 1, i8* @running_asynch_code, align 1
  %9 = load i64, i64* %sentinel, align 8
  %10 = load i64, i64* %proc.addr, align 8
  %11 = load i64, i64* %reason.addr, align 8
  %call17 = call i64 @list3(i64 %9, i64 %10, i64 %11)
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 54), align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %12, %call18
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end.16
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %call20 = call i64 @builtin_lisp_symbol(i32 372)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call19, %cond.true ], [ %call20, %cond.false ]
  %call21 = call i64 @internal_condition_case_1(i64 (i64)* @read_process_output_call, i64 %call17, i64 %cond, i64 (i64)* @exec_sentinel_error_handler)
  call void @restore_search_regs()
  %13 = load i8, i8* %outer_running_asynch_code, align 1
  %tobool22 = trunc i8 %13 to i1
  %frombool23 = zext i1 %tobool22 to i8
  store i8 %frombool23, i8* @running_asynch_code, align 1
  %14 = load i64, i64* %odeactivate, align 8
  store i64 %14, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %15 = load i32, i32* %waiting, align 4
  store i32 %15, i32* @waiting_for_user_input_p, align 4
  %16 = load i32, i32* @waiting_for_user_input_p, align 4
  %cmp24 = icmp eq i32 %16, -1
  br i1 %cmp24, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %cond.end
  call void @record_asynch_buffer_change()
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.25, %cond.end
  %17 = load i64, i64* %count, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @unbind_to(i64 %17, i64 %call27)
  br label %return

return:                                           ; preds = %if.end.26, %if.then
  ret void
}

declare void @clear_input_pending() #1

; Function Attrs: nounwind uwtable
define i64 @Finternal_default_process_filter(i64 %proc, i64 %text) #0 {
entry:
  %proc.addr = alloca i64, align 8
  %text.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %opoint = alloca i64, align 8
  %old_read_only = alloca i64, align 8
  %old_begv = alloca i64, align 8
  %old_zv = alloca i64, align 8
  %old_begv_byte = alloca i64, align 8
  %old_zv_byte = alloca i64, align 8
  %before = alloca i64, align 8
  %before_byte = alloca i64, align 8
  %opoint_byte = alloca i64, align 8
  %b = alloca %struct.buffer*, align 8
  store i64 %proc, i64* %proc.addr, align 8
  store i64 %text, i64* %text.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load i64, i64* %text.addr, align 8
  call void @CHECK_STRING(i64 %2)
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 7
  %4 = load i64, i64* %buffer, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %4, %call1
  br i1 %cmp, label %if.end.150, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer2 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 7
  %6 = load i64, i64* %buffer2, align 8
  %call3 = call %struct.buffer* @XBUFFER(i64 %6)
  %name_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call3, i32 0, i32 1
  %7 = load i64, i64* %name_, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %7, %call4
  br i1 %cmp5, label %if.end.150, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer6 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 7
  %9 = load i64, i64* %buffer6, align 8
  %call7 = call i64 @Fset_buffer(i64 %9)
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 75
  %11 = load i64, i64* %pt, align 8
  %add = add nsw i64 %11, 0
  store i64 %add, i64* %opoint, align 8
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 76
  %13 = load i64, i64* %pt_byte, align 8
  %add8 = add nsw i64 %13, 0
  store i64 %add8, i64* %opoint_byte, align 8
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %read_only_ = getelementptr inbounds %struct.buffer, %struct.buffer* %14, i32 0, i32 7
  %15 = load i64, i64* %read_only_, align 8
  store i64 %15, i64* %old_read_only, align 8
  %16 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %16, i32 0, i32 77
  %17 = load i64, i64* %begv, align 8
  store i64 %17, i64* %old_begv, align 8
  %18 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %18, i32 0, i32 79
  %19 = load i64, i64* %zv, align 8
  store i64 %19, i64* %old_zv, align 8
  %20 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %20, i32 0, i32 78
  %21 = load i64, i64* %begv_byte, align 8
  store i64 %21, i64* %old_begv_byte, align 8
  %22 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %22, i32 0, i32 80
  %23 = load i64, i64* %zv_byte, align 8
  store i64 %23, i64* %old_zv_byte, align 8
  %24 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  call void @bset_read_only(%struct.buffer* %24, i64 %call9)
  %25 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %25, i32 0, i32 11
  %26 = load i64, i64* %mark, align 8
  %call10 = call %struct.Lisp_Marker* @XMARKER(i64 %26)
  %buffer11 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call10, i32 0, i32 1
  %27 = load %struct.buffer*, %struct.buffer** %buffer11, align 8
  %tobool = icmp ne %struct.buffer* %27, null
  br i1 %tobool, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %if.then
  %28 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark13 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %28, i32 0, i32 11
  %29 = load i64, i64* %mark13, align 8
  call void @set_point_from_marker(i64 %29)
  br label %if.end

if.else:                                          ; preds = %if.then
  %30 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv14 = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 79
  %31 = load i64, i64* %zv14, align 8
  %32 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte15 = getelementptr inbounds %struct.buffer, %struct.buffer* %32, i32 0, i32 80
  %33 = load i64, i64* %zv_byte15, align 8
  call void @set_point_both(i64 %31, i64 %33)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.12
  %34 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt16 = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 75
  %35 = load i64, i64* %pt16, align 8
  %add17 = add nsw i64 %35, 0
  store i64 %add17, i64* %before, align 8
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte18 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 76
  %37 = load i64, i64* %pt_byte18, align 8
  %add19 = add nsw i64 %37, 0
  store i64 %add19, i64* %before_byte, align 8
  %38 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv20 = getelementptr inbounds %struct.buffer, %struct.buffer* %38, i32 0, i32 77
  %39 = load i64, i64* %begv20, align 8
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt21 = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 75
  %41 = load i64, i64* %pt21, align 8
  %add22 = add nsw i64 %41, 0
  %cmp23 = icmp sle i64 %39, %add22
  br i1 %cmp23, label %land.lhs.true.24, label %if.then.29

land.lhs.true.24:                                 ; preds = %if.end
  %42 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt25 = getelementptr inbounds %struct.buffer, %struct.buffer* %42, i32 0, i32 75
  %43 = load i64, i64* %pt25, align 8
  %add26 = add nsw i64 %43, 0
  %44 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv27 = getelementptr inbounds %struct.buffer, %struct.buffer* %44, i32 0, i32 79
  %45 = load i64, i64* %zv27, align 8
  %cmp28 = icmp sle i64 %add26, %45
  br i1 %cmp28, label %if.end.31, label %if.then.29

if.then.29:                                       ; preds = %land.lhs.true.24, %if.end
  %call30 = call i64 @Fwiden()
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %land.lhs.true.24
  %46 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %46, i32 0, i32 39
  %47 = load i64, i64* %enable_multibyte_characters_, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp33 = icmp eq i64 %47, %call32
  %conv = zext i1 %cmp33 to i32
  %48 = load i64, i64* %text.addr, align 8
  %call34 = call zeroext i1 @STRING_MULTIBYTE(i64 %48)
  %lnot = xor i1 %call34, true
  %lnot.ext = zext i1 %lnot to i32
  %cmp35 = icmp ne i32 %conv, %lnot.ext
  br i1 %cmp35, label %if.then.37, label %if.end.42

if.then.37:                                       ; preds = %if.end.31
  %49 = load i64, i64* %text.addr, align 8
  %call38 = call zeroext i1 @STRING_MULTIBYTE(i64 %49)
  br i1 %call38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.37
  %50 = load i64, i64* %text.addr, align 8
  %call40 = call i64 @Fstring_as_unibyte(i64 %50)
  br label %cond.end

cond.false:                                       ; preds = %if.then.37
  %51 = load i64, i64* %text.addr, align 8
  %call41 = call i64 @Fstring_to_multibyte(i64 %51)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call40, %cond.true ], [ %call41, %cond.false ]
  store i64 %cond, i64* %text.addr, align 8
  br label %if.end.42

if.end.42:                                        ; preds = %cond.end, %if.end.31
  %52 = load i64, i64* %text.addr, align 8
  %53 = load i64, i64* %text.addr, align 8
  %call43 = call i64 @SCHARS(i64 %53)
  %54 = load i64, i64* %text.addr, align 8
  %call44 = call i64 @SBYTES(i64 %54)
  call void @insert_from_string_before_markers(i64 %52, i64 0, i64 0, i64 %call43, i64 %call44, i1 zeroext false)
  %55 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer45 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %55, i32 0, i32 7
  %56 = load i64, i64* %buffer45, align 8
  %call46 = call zeroext i1 @BUFFERP(i64 %56)
  br i1 %call46, label %land.lhs.true.48, label %if.else.94

land.lhs.true.48:                                 ; preds = %if.end.42
  %57 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer49 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %57, i32 0, i32 7
  %58 = load i64, i64* %buffer49, align 8
  %call50 = call %struct.buffer* @XBUFFER(i64 %58)
  store %struct.buffer* %call50, %struct.buffer** %b, align 8
  %59 = load %struct.buffer*, %struct.buffer** %b, align 8
  %60 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp51 = icmp ne %struct.buffer* %59, %60
  br i1 %cmp51, label %if.then.53, label %if.else.94

if.then.53:                                       ; preds = %land.lhs.true.48
  %61 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark54 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %61, i32 0, i32 11
  %62 = load i64, i64* %mark54, align 8
  %63 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer55 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %63, i32 0, i32 7
  %64 = load i64, i64* %buffer55, align 8
  %65 = load %struct.buffer*, %struct.buffer** %b, align 8
  %66 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp56 = icmp eq %struct.buffer* %65, %66
  br i1 %cmp56, label %cond.true.58, label %cond.false.61

cond.true.58:                                     ; preds = %if.then.53
  %67 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt59 = getelementptr inbounds %struct.buffer, %struct.buffer* %67, i32 0, i32 75
  %68 = load i64, i64* %pt59, align 8
  %add60 = add nsw i64 %68, 0
  br label %cond.end.72

cond.false.61:                                    ; preds = %if.then.53
  %69 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %69, i32 0, i32 45
  %70 = load i64, i64* %pt_marker_, align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp63 = icmp eq i64 %70, %call62
  br i1 %cmp63, label %cond.true.65, label %cond.false.67

cond.true.65:                                     ; preds = %cond.false.61
  %71 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt66 = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 75
  %72 = load i64, i64* %pt66, align 8
  br label %cond.end.70

cond.false.67:                                    ; preds = %cond.false.61
  %73 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt_marker_68 = getelementptr inbounds %struct.buffer, %struct.buffer* %73, i32 0, i32 45
  %74 = load i64, i64* %pt_marker_68, align 8
  %call69 = call i64 @marker_position(i64 %74)
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.67, %cond.true.65
  %cond71 = phi i64 [ %72, %cond.true.65 ], [ %call69, %cond.false.67 ]
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.end.70, %cond.true.58
  %cond73 = phi i64 [ %add60, %cond.true.58 ], [ %cond71, %cond.end.70 ]
  %75 = load %struct.buffer*, %struct.buffer** %b, align 8
  %76 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp74 = icmp eq %struct.buffer* %75, %76
  br i1 %cmp74, label %cond.true.76, label %cond.false.79

cond.true.76:                                     ; preds = %cond.end.72
  %77 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte77 = getelementptr inbounds %struct.buffer, %struct.buffer* %77, i32 0, i32 76
  %78 = load i64, i64* %pt_byte77, align 8
  %add78 = add nsw i64 %78, 0
  br label %cond.end.91

cond.false.79:                                    ; preds = %cond.end.72
  %79 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt_marker_80 = getelementptr inbounds %struct.buffer, %struct.buffer* %79, i32 0, i32 45
  %80 = load i64, i64* %pt_marker_80, align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp82 = icmp eq i64 %80, %call81
  br i1 %cmp82, label %cond.true.84, label %cond.false.86

cond.true.84:                                     ; preds = %cond.false.79
  %81 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt_byte85 = getelementptr inbounds %struct.buffer, %struct.buffer* %81, i32 0, i32 76
  %82 = load i64, i64* %pt_byte85, align 8
  br label %cond.end.89

cond.false.86:                                    ; preds = %cond.false.79
  %83 = load %struct.buffer*, %struct.buffer** %b, align 8
  %pt_marker_87 = getelementptr inbounds %struct.buffer, %struct.buffer* %83, i32 0, i32 45
  %84 = load i64, i64* %pt_marker_87, align 8
  %call88 = call i64 @marker_byte_position(i64 %84)
  br label %cond.end.89

cond.end.89:                                      ; preds = %cond.false.86, %cond.true.84
  %cond90 = phi i64 [ %82, %cond.true.84 ], [ %call88, %cond.false.86 ]
  br label %cond.end.91

cond.end.91:                                      ; preds = %cond.end.89, %cond.true.76
  %cond92 = phi i64 [ %add78, %cond.true.76 ], [ %cond90, %cond.end.89 ]
  %call93 = call i64 @set_marker_both(i64 %62, i64 %64, i64 %cond73, i64 %cond92)
  br label %if.end.102

if.else.94:                                       ; preds = %land.lhs.true.48, %if.end.42
  %85 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark95 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %85, i32 0, i32 11
  %86 = load i64, i64* %mark95, align 8
  %87 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer96 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %87, i32 0, i32 7
  %88 = load i64, i64* %buffer96, align 8
  %89 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt97 = getelementptr inbounds %struct.buffer, %struct.buffer* %89, i32 0, i32 75
  %90 = load i64, i64* %pt97, align 8
  %add98 = add nsw i64 %90, 0
  %91 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte99 = getelementptr inbounds %struct.buffer, %struct.buffer* %91, i32 0, i32 76
  %92 = load i64, i64* %pt_byte99, align 8
  %add100 = add nsw i64 %92, 0
  %call101 = call i64 @set_marker_both(i64 %86, i64 %88, i64 %add98, i64 %add100)
  br label %if.end.102

if.end.102:                                       ; preds = %if.else.94, %cond.end.91
  store i32 23, i32* @update_mode_lines, align 4
  %93 = load i64, i64* %opoint, align 8
  %94 = load i64, i64* %before, align 8
  %cmp103 = icmp sge i64 %93, %94
  br i1 %cmp103, label %if.then.105, label %if.end.113

if.then.105:                                      ; preds = %if.end.102
  %95 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt106 = getelementptr inbounds %struct.buffer, %struct.buffer* %95, i32 0, i32 75
  %96 = load i64, i64* %pt106, align 8
  %add107 = add nsw i64 %96, 0
  %97 = load i64, i64* %before, align 8
  %sub = sub nsw i64 %add107, %97
  %98 = load i64, i64* %opoint, align 8
  %add108 = add nsw i64 %98, %sub
  store i64 %add108, i64* %opoint, align 8
  %99 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte109 = getelementptr inbounds %struct.buffer, %struct.buffer* %99, i32 0, i32 76
  %100 = load i64, i64* %pt_byte109, align 8
  %add110 = add nsw i64 %100, 0
  %101 = load i64, i64* %before_byte, align 8
  %sub111 = sub nsw i64 %add110, %101
  %102 = load i64, i64* %opoint_byte, align 8
  %add112 = add nsw i64 %102, %sub111
  store i64 %add112, i64* %opoint_byte, align 8
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.105, %if.end.102
  %103 = load i64, i64* %old_begv, align 8
  %104 = load i64, i64* %before, align 8
  %cmp114 = icmp sgt i64 %103, %104
  br i1 %cmp114, label %if.then.116, label %if.end.125

if.then.116:                                      ; preds = %if.end.113
  %105 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt117 = getelementptr inbounds %struct.buffer, %struct.buffer* %105, i32 0, i32 75
  %106 = load i64, i64* %pt117, align 8
  %add118 = add nsw i64 %106, 0
  %107 = load i64, i64* %before, align 8
  %sub119 = sub nsw i64 %add118, %107
  %108 = load i64, i64* %old_begv, align 8
  %add120 = add nsw i64 %108, %sub119
  store i64 %add120, i64* %old_begv, align 8
  %109 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte121 = getelementptr inbounds %struct.buffer, %struct.buffer* %109, i32 0, i32 76
  %110 = load i64, i64* %pt_byte121, align 8
  %add122 = add nsw i64 %110, 0
  %111 = load i64, i64* %before_byte, align 8
  %sub123 = sub nsw i64 %add122, %111
  %112 = load i64, i64* %old_begv_byte, align 8
  %add124 = add nsw i64 %112, %sub123
  store i64 %add124, i64* %old_begv_byte, align 8
  br label %if.end.125

if.end.125:                                       ; preds = %if.then.116, %if.end.113
  %113 = load i64, i64* %old_zv, align 8
  %114 = load i64, i64* %before, align 8
  %cmp126 = icmp sge i64 %113, %114
  br i1 %cmp126, label %if.then.128, label %if.end.137

if.then.128:                                      ; preds = %if.end.125
  %115 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt129 = getelementptr inbounds %struct.buffer, %struct.buffer* %115, i32 0, i32 75
  %116 = load i64, i64* %pt129, align 8
  %add130 = add nsw i64 %116, 0
  %117 = load i64, i64* %before, align 8
  %sub131 = sub nsw i64 %add130, %117
  %118 = load i64, i64* %old_zv, align 8
  %add132 = add nsw i64 %118, %sub131
  store i64 %add132, i64* %old_zv, align 8
  %119 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte133 = getelementptr inbounds %struct.buffer, %struct.buffer* %119, i32 0, i32 76
  %120 = load i64, i64* %pt_byte133, align 8
  %add134 = add nsw i64 %120, 0
  %121 = load i64, i64* %before_byte, align 8
  %sub135 = sub nsw i64 %add134, %121
  %122 = load i64, i64* %old_zv_byte, align 8
  %add136 = add nsw i64 %122, %sub135
  store i64 %add136, i64* %old_zv_byte, align 8
  br label %if.end.137

if.end.137:                                       ; preds = %if.then.128, %if.end.125
  %123 = load i64, i64* %old_begv, align 8
  %124 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv138 = getelementptr inbounds %struct.buffer, %struct.buffer* %124, i32 0, i32 77
  %125 = load i64, i64* %begv138, align 8
  %cmp139 = icmp ne i64 %123, %125
  br i1 %cmp139, label %if.then.144, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.137
  %126 = load i64, i64* %old_zv, align 8
  %127 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv141 = getelementptr inbounds %struct.buffer, %struct.buffer* %127, i32 0, i32 79
  %128 = load i64, i64* %zv141, align 8
  %cmp142 = icmp ne i64 %126, %128
  br i1 %cmp142, label %if.then.144, label %if.end.149

if.then.144:                                      ; preds = %lor.lhs.false, %if.end.137
  %129 = load i64, i64* %old_begv, align 8
  %shl = shl i64 %129, 2
  %add145 = add i64 %shl, 2
  %130 = load i64, i64* %old_zv, align 8
  %shl146 = shl i64 %130, 2
  %add147 = add i64 %shl146, 2
  %call148 = call i64 @Fnarrow_to_region(i64 %add145, i64 %add147)
  br label %if.end.149

if.end.149:                                       ; preds = %if.then.144, %lor.lhs.false
  %131 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %132 = load i64, i64* %old_read_only, align 8
  call void @bset_read_only(%struct.buffer* %131, i64 %132)
  %133 = load i64, i64* %opoint, align 8
  %134 = load i64, i64* %opoint_byte, align 8
  call void @set_point_both(i64 %133, i64 %134)
  br label %if.end.150

if.end.150:                                       ; preds = %if.end.149, %land.lhs.true, %entry
  %call151 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call151
}

declare i64 @Fset_buffer(i64) #1

declare void @bset_read_only(%struct.buffer*, i64) #1

declare %struct.Lisp_Marker* @XMARKER(i64) #1

declare void @set_point_from_marker(i64) #1

declare void @set_point_both(i64, i64) #1

declare i64 @Fwiden() #1

declare i64 @Fstring_as_unibyte(i64) #1

declare i64 @Fstring_to_multibyte(i64) #1

declare void @insert_from_string_before_markers(i64, i64, i64, i64, i64, i1 zeroext) #1

declare i64 @Fnarrow_to_region(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_send_region(i64 %process, i64 %start, i64 %end) #0 {
entry:
  %process.addr = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %proc = alloca i64, align 8
  %start_byte = alloca i64, align 8
  %end_byte = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %0)
  store i64 %call, i64* %proc, align 8
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %2 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %2, 2
  %call1 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %1, i64 %shr)
  store i64 %call1, i64* %start_byte, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %4 = load i64, i64* %end.addr, align 8
  %shr2 = ashr i64 %4, 2
  %call3 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %3, i64 %shr2)
  store i64 %call3, i64* %end_byte, align 8
  %5 = load i64, i64* %start.addr, align 8
  %shr4 = ashr i64 %5, 2
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 73
  %7 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %7, i32 0, i32 1
  %8 = load i64, i64* %gpt, align 8
  %cmp = icmp slt i64 %shr4, %8
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load i64, i64* %end.addr, align 8
  %shr5 = ashr i64 %9, 2
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text6 = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 73
  %11 = load %struct.buffer_text*, %struct.buffer_text** %text6, align 8
  %gpt7 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %11, i32 0, i32 1
  %12 = load i64, i64* %gpt7, align 8
  %cmp8 = icmp sgt i64 %shr5, %12
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %13 = load i64, i64* %start.addr, align 8
  %shr9 = ashr i64 %13, 2
  %14 = load i64, i64* %start_byte, align 8
  call void @move_gap_both(i64 %shr9, i64 %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %15 = load i64, i64* %proc, align 8
  %16 = load i64, i64* %start_byte, align 8
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text10 = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 73
  %18 = load %struct.buffer_text*, %struct.buffer_text** %text10, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %18, i32 0, i32 3
  %19 = load i64, i64* %gpt_byte, align 8
  %cmp11 = icmp sge i64 %16, %19
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %20 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text12 = getelementptr inbounds %struct.buffer, %struct.buffer* %20, i32 0, i32 73
  %21 = load %struct.buffer_text*, %struct.buffer_text** %text12, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %21, i32 0, i32 5
  %22 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %22, %cond.true ], [ 0, %cond.false ]
  %23 = load i64, i64* %start_byte, align 8
  %add = add nsw i64 %cond, %23
  %24 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text13 = getelementptr inbounds %struct.buffer, %struct.buffer* %24, i32 0, i32 73
  %25 = load %struct.buffer_text*, %struct.buffer_text** %text13, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %25, i32 0, i32 0
  %26 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %26, i64 %add
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %27 = load i64, i64* %end_byte, align 8
  %28 = load i64, i64* %start_byte, align 8
  %sub = sub nsw i64 %27, %28
  %call15 = call i64 @Fcurrent_buffer()
  call void @send_process(i64 %15, i8* %add.ptr14, i64 %sub, i64 %call15)
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call16
}

declare void @validate_region(i64*, i64*) #1

declare i64 @buf_charpos_to_bytepos(%struct.buffer*, i64) #1

declare void @move_gap_both(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @send_process(i64 %proc, i8* %buf, i64 %len, i64 %object) #0 {
entry:
  %proc.addr = alloca i64, align 8
  %buf.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %rv = alloca i64, align 8
  %coding = alloca %struct.coding_system*, align 8
  %from_byte = alloca i64, align 8
  %from = alloca i64, align 8
  %to = alloca i64, align 8
  %save_pt = alloca i64, align 8
  %save_pt_byte = alloca i64, align 8
  %cur = alloca %struct.buffer*, align 8
  %cur_len = alloca i64, align 8
  %cur_buf = alloca i8*, align 8
  %cur_object = alloca i64, align 8
  %written = alloca i64, align 8
  %outfd145 = alloca i32, align 4
  %agg.tmp = alloca %union.__CONST_SOCKADDR_ARG, align 8
  store i64 %proc, i64* %proc.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %0)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  call void @update_status(%struct.Lisp_Process* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %3, i32 0, i32 12
  %4 = load i64, i64* %status, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp = icmp eq i64 %4, %call1
  br i1 %cmp, label %if.end.4, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %5 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %5, i32 0, i32 2
  %6 = load i64, i64* %name, align 8
  %call3 = call i8* @SDATA(i64 %6)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.43, i32 0, i32 0), i8* %call3) #8
  unreachable

if.end.4:                                         ; preds = %if.end
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %7, i32 0, i32 22
  %8 = load i32, i32* %outfd, align 4
  %cmp5 = icmp slt i32 %8, 0
  br i1 %cmp5, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end.4
  %9 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name7 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %9, i32 0, i32 2
  %10 = load i64, i64* %name7, align 8
  %call8 = call i8* @SDATA(i64 %10)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.94, i32 0, i32 0), i8* %call8) #8
  unreachable

if.end.9:                                         ; preds = %if.end.4
  %11 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd10 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %11, i32 0, i32 22
  %12 = load i32, i32* %outfd10, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom
  %13 = load %struct.coding_system*, %struct.coding_system** %arrayidx, align 8
  store %struct.coding_system* %13, %struct.coding_system** %coding, align 8
  %14 = load i64, i64* @Vcoding_system_hash_table, align 8
  %call11 = call %struct.Lisp_Hash_Table* @XHASH_TABLE(i64 %14)
  %15 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %id = getelementptr inbounds %struct.coding_system, %struct.coding_system* %15, i32 0, i32 0
  %16 = load i64, i64* %id, align 8
  %call12 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %call11, i64 %16)
  store i64 %call12, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %17 = load i64, i64* %object.addr, align 8
  %call13 = call zeroext i1 @STRINGP(i64 %17)
  br i1 %call13, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end.9
  %18 = load i64, i64* %object.addr, align 8
  %call14 = call zeroext i1 @STRING_MULTIBYTE(i64 %18)
  br i1 %call14, label %if.then.23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end.9
  %19 = load i64, i64* %object.addr, align 8
  %call15 = call zeroext i1 @BUFFERP(i64 %19)
  br i1 %call15, label %land.lhs.true.16, label %lor.lhs.false.20

land.lhs.true.16:                                 ; preds = %lor.lhs.false
  %20 = load i64, i64* %object.addr, align 8
  %call17 = call %struct.buffer* @XBUFFER(i64 %20)
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call17, i32 0, i32 39
  %21 = load i64, i64* %enable_multibyte_characters_, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %21, %call18
  br i1 %cmp19, label %lor.lhs.false.20, label %if.then.23

lor.lhs.false.20:                                 ; preds = %land.lhs.true.16, %lor.lhs.false
  %22 = load i64, i64* %object.addr, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp22 = icmp eq i64 %22, %call21
  br i1 %cmp22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.20, %land.lhs.true.16, %land.lhs.true
  %23 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %24 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %24, i32 0, i32 15
  %25 = load i64, i64* %encode_coding_system, align 8
  %call24 = call i64 @complement_process_encoding_system(i64 %25)
  call void @pset_encode_coding_system(%struct.Lisp_Process* %23, i64 %call24)
  %26 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %27 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system25 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %27, i32 0, i32 15
  %28 = load i64, i64* %encode_coding_system25, align 8
  %cmp26 = icmp eq i64 %26, %28
  br i1 %cmp26, label %if.end.30, label %if.then.27

if.then.27:                                       ; preds = %if.then.23
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system28 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %29, i32 0, i32 15
  %30 = load i64, i64* %encode_coding_system28, align 8
  %31 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  call void @setup_coding_system(i64 %30, %struct.coding_system* %31)
  %32 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system29 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %32, i32 0, i32 15
  %33 = load i64, i64* %encode_coding_system29, align 8
  store i64 %33, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.27, %if.then.23
  %34 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_multibyte = getelementptr inbounds %struct.coding_system, %struct.coding_system* %34, i32 0, i32 1
  %bf.load31 = load i32, i32* %src_multibyte, align 8
  %bf.clear = and i32 %bf.load31, -524289
  %bf.set = or i32 %bf.clear, 524288
  store i32 %bf.set, i32* %src_multibyte, align 8
  br label %if.end.80

if.else:                                          ; preds = %lor.lhs.false.20
  %35 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_multibyte32 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %35, i32 0, i32 1
  %bf.load33 = load i32, i32* %src_multibyte32, align 8
  %bf.clear34 = and i32 %bf.load33, -524289
  store i32 %bf.clear34, i32* %src_multibyte32, align 8
  %36 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_multibyte35 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %36, i32 0, i32 1
  %bf.load36 = load i32, i32* %src_multibyte35, align 8
  %bf.lshr37 = lshr i32 %bf.load36, 19
  %bf.clear38 = and i32 %bf.lshr37, 1
  %bf.cast39 = trunc i32 %bf.clear38 to i1
  br i1 %bf.cast39, label %if.then.49, label %lor.lhs.false.40

lor.lhs.false.40:                                 ; preds = %if.else
  %37 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %common_flags = getelementptr inbounds %struct.coding_system, %struct.coding_system* %37, i32 0, i32 1
  %bf.load41 = load i32, i32* %common_flags, align 8
  %bf.clear42 = and i32 %bf.load41, 16383
  %and = and i32 %bf.clear42, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.49, label %lor.lhs.false.43

lor.lhs.false.43:                                 ; preds = %lor.lhs.false.40
  %38 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode = getelementptr inbounds %struct.coding_system, %struct.coding_system* %38, i32 0, i32 1
  %bf.load44 = load i32, i32* %mode, align 8
  %bf.lshr45 = lshr i32 %bf.load44, 14
  %bf.clear46 = and i32 %bf.lshr45, 31
  %and47 = and i32 %bf.clear46, 2
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then.49, label %if.end.79

if.then.49:                                       ; preds = %lor.lhs.false.43, %lor.lhs.false.40, %if.else
  %39 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %common_flags50 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %39, i32 0, i32 1
  %bf.load51 = load i32, i32* %common_flags50, align 8
  %bf.clear52 = and i32 %bf.load51, 16383
  %and53 = and i32 %bf.clear52, 512
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %if.then.55, label %if.end.74

if.then.55:                                       ; preds = %if.then.49
  %40 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode56 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %40, i32 0, i32 1
  %bf.load57 = load i32, i32* %mode56, align 8
  %bf.lshr58 = lshr i32 %bf.load57, 14
  %bf.clear59 = and i32 %bf.lshr58, 31
  %or = or i32 %bf.clear59, 1
  %bf.load60 = load i32, i32* %mode56, align 8
  %bf.value = and i32 %or, 31
  %bf.shl = shl i32 %bf.value, 14
  %bf.clear61 = and i32 %bf.load60, -507905
  %bf.set62 = or i32 %bf.clear61, %bf.shl
  store i32 %bf.set62, i32* %mode56, align 8
  %41 = load i64, i64* %proc.addr, align 8
  %call63 = call i64 @builtin_lisp_symbol(i32 901)
  call void @send_process(i64 %41, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.44, i32 0, i32 0), i64 0, i64 %call63)
  %42 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode64 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %42, i32 0, i32 1
  %bf.load65 = load i32, i32* %mode64, align 8
  %bf.lshr66 = lshr i32 %bf.load65, 14
  %bf.clear67 = and i32 %bf.lshr66, 31
  %and68 = and i32 %bf.clear67, 1
  %bf.load69 = load i32, i32* %mode64, align 8
  %bf.value70 = and i32 %and68, 31
  %bf.shl71 = shl i32 %bf.value70, 14
  %bf.clear72 = and i32 %bf.load69, -507905
  %bf.set73 = or i32 %bf.clear72, %bf.shl71
  store i32 %bf.set73, i32* %mode64, align 8
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.55, %if.then.49
  %43 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %call75 = call i64 @raw_text_coding_system(i64 %43)
  %44 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  call void @setup_coding_system(i64 %call75, %struct.coding_system* %44)
  %45 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_multibyte76 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %45, i32 0, i32 1
  %bf.load77 = load i32, i32* %src_multibyte76, align 8
  %bf.clear78 = and i32 %bf.load77, -524289
  store i32 %bf.clear78, i32* %src_multibyte76, align 8
  br label %if.end.79

if.end.79:                                        ; preds = %if.end.74, %lor.lhs.false.43
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.79, %if.end.30
  %46 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %dst_multibyte = getelementptr inbounds %struct.coding_system, %struct.coding_system* %46, i32 0, i32 1
  %bf.load81 = load i32, i32* %dst_multibyte, align 8
  %bf.clear82 = and i32 %bf.load81, -1048577
  store i32 %bf.clear82, i32* %dst_multibyte, align 8
  %47 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_multibyte83 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %47, i32 0, i32 1
  %bf.load84 = load i32, i32* %src_multibyte83, align 8
  %bf.lshr85 = lshr i32 %bf.load84, 19
  %bf.clear86 = and i32 %bf.lshr85, 1
  %bf.cast87 = trunc i32 %bf.clear86 to i1
  br i1 %bf.cast87, label %if.then.101, label %lor.lhs.false.88

lor.lhs.false.88:                                 ; preds = %if.end.80
  %48 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %common_flags89 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %48, i32 0, i32 1
  %bf.load90 = load i32, i32* %common_flags89, align 8
  %bf.clear91 = and i32 %bf.load90, 16383
  %and92 = and i32 %bf.clear91, 2048
  %tobool93 = icmp ne i32 %and92, 0
  br i1 %tobool93, label %if.then.101, label %lor.lhs.false.94

lor.lhs.false.94:                                 ; preds = %lor.lhs.false.88
  %49 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode95 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %49, i32 0, i32 1
  %bf.load96 = load i32, i32* %mode95, align 8
  %bf.lshr97 = lshr i32 %bf.load96, 14
  %bf.clear98 = and i32 %bf.lshr97, 31
  %and99 = and i32 %bf.clear98, 2
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.then.101, label %if.end.136

if.then.101:                                      ; preds = %lor.lhs.false.94, %lor.lhs.false.88, %if.end.80
  %call102 = call i64 @builtin_lisp_symbol(i32 901)
  %50 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %dst_object = getelementptr inbounds %struct.coding_system, %struct.coding_system* %50, i32 0, i32 21
  store i64 %call102, i64* %dst_object, align 8
  %51 = load i64, i64* %object.addr, align 8
  %call103 = call zeroext i1 @BUFFERP(i64 %51)
  br i1 %call103, label %if.then.104, label %if.else.122

if.then.104:                                      ; preds = %if.then.101
  %52 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %52, %struct.buffer** %cur, align 8
  %53 = load i64, i64* %object.addr, align 8
  %call105 = call %struct.buffer* @XBUFFER(i64 %53)
  call void @set_buffer_internal(%struct.buffer* %call105)
  %54 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %54, i32 0, i32 75
  %55 = load i64, i64* %pt, align 8
  %add = add nsw i64 %55, 0
  store i64 %add, i64* %save_pt, align 8
  %56 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %56, i32 0, i32 76
  %57 = load i64, i64* %pt_byte, align 8
  %add106 = add nsw i64 %57, 0
  store i64 %add106, i64* %save_pt_byte, align 8
  %58 = load i8*, i8** %buf.addr, align 8
  %59 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %59, i32 0, i32 73
  %60 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %60, i32 0, i32 0
  %61 = load i8*, i8** %beg, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %58 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %61 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %62 = load i8*, i8** %buf.addr, align 8
  %63 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text107 = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 73
  %64 = load %struct.buffer_text*, %struct.buffer_text** %text107, align 8
  %beg108 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %64, i32 0, i32 0
  %65 = load i8*, i8** %beg108, align 8
  %sub.ptr.lhs.cast109 = ptrtoint i8* %62 to i64
  %sub.ptr.rhs.cast110 = ptrtoint i8* %65 to i64
  %sub.ptr.sub111 = sub i64 %sub.ptr.lhs.cast109, %sub.ptr.rhs.cast110
  %66 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text112 = getelementptr inbounds %struct.buffer, %struct.buffer* %66, i32 0, i32 73
  %67 = load %struct.buffer_text*, %struct.buffer_text** %text112, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %67, i32 0, i32 3
  %68 = load i64, i64* %gpt_byte, align 8
  %sub = sub nsw i64 %68, 1
  %cmp113 = icmp sle i64 %sub.ptr.sub111, %sub
  br i1 %cmp113, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.104
  br label %cond.end

cond.false:                                       ; preds = %if.then.104
  %69 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text114 = getelementptr inbounds %struct.buffer, %struct.buffer* %69, i32 0, i32 73
  %70 = load %struct.buffer_text*, %struct.buffer_text** %text114, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %70, i32 0, i32 5
  %71 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %71, %cond.false ]
  %sub115 = sub nsw i64 %sub.ptr.sub, %cond
  %add116 = add nsw i64 %sub115, 1
  store i64 %add116, i64* %from_byte, align 8
  %72 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %73 = load i64, i64* %from_byte, align 8
  %call117 = call i64 @buf_bytepos_to_charpos(%struct.buffer* %72, i64 %73)
  store i64 %call117, i64* %from, align 8
  %74 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %75 = load i64, i64* %from_byte, align 8
  %76 = load i64, i64* %len.addr, align 8
  %add118 = add nsw i64 %75, %76
  %call119 = call i64 @buf_bytepos_to_charpos(%struct.buffer* %74, i64 %add118)
  store i64 %call119, i64* %to, align 8
  %77 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %78 = load i64, i64* %from, align 8
  %79 = load i64, i64* %from_byte, align 8
  call void @temp_set_point_both(%struct.buffer* %77, i64 %78, i64 %79)
  %80 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %81 = load i64, i64* %object.addr, align 8
  %82 = load i64, i64* %from, align 8
  %83 = load i64, i64* %from_byte, align 8
  %84 = load i64, i64* %to, align 8
  %85 = load i64, i64* %from_byte, align 8
  %86 = load i64, i64* %len.addr, align 8
  %add120 = add nsw i64 %85, %86
  %call121 = call i64 @builtin_lisp_symbol(i32 901)
  call void @encode_coding_object(%struct.coding_system* %80, i64 %81, i64 %82, i64 %83, i64 %84, i64 %add120, i64 %call121)
  %87 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %88 = load i64, i64* %save_pt, align 8
  %89 = load i64, i64* %save_pt_byte, align 8
  call void @temp_set_point_both(%struct.buffer* %87, i64 %88, i64 %89)
  %90 = load %struct.buffer*, %struct.buffer** %cur, align 8
  call void @set_buffer_internal(%struct.buffer* %90)
  br label %if.end.132

if.else.122:                                      ; preds = %if.then.101
  %91 = load i64, i64* %object.addr, align 8
  %call123 = call zeroext i1 @STRINGP(i64 %91)
  br i1 %call123, label %if.then.124, label %if.else.128

if.then.124:                                      ; preds = %if.else.122
  %92 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %93 = load i64, i64* %object.addr, align 8
  %94 = load i64, i64* %object.addr, align 8
  %call125 = call i64 @SCHARS(i64 %94)
  %95 = load i64, i64* %object.addr, align 8
  %call126 = call i64 @SBYTES(i64 %95)
  %call127 = call i64 @builtin_lisp_symbol(i32 901)
  call void @encode_coding_object(%struct.coding_system* %92, i64 %93, i64 0, i64 0, i64 %call125, i64 %call126, i64 %call127)
  br label %if.end.131

if.else.128:                                      ; preds = %if.else.122
  %96 = load i8*, i8** %buf.addr, align 8
  %97 = load i64, i64* %len.addr, align 8
  %call129 = call i64 @make_unibyte_string(i8* %96, i64 %97)
  %98 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %dst_object130 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %98, i32 0, i32 21
  store i64 %call129, i64* %dst_object130, align 8
  %99 = load i64, i64* %len.addr, align 8
  %100 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %produced = getelementptr inbounds %struct.coding_system, %struct.coding_system* %100, i32 0, i32 8
  store i64 %99, i64* %produced, align 8
  br label %if.end.131

if.end.131:                                       ; preds = %if.else.128, %if.then.124
  br label %if.end.132

if.end.132:                                       ; preds = %if.end.131, %cond.end
  %101 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %produced133 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %101, i32 0, i32 8
  %102 = load i64, i64* %produced133, align 8
  store i64 %102, i64* %len.addr, align 8
  %103 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %dst_object134 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %103, i32 0, i32 21
  %104 = load i64, i64* %dst_object134, align 8
  store i64 %104, i64* %object.addr, align 8
  %105 = load i64, i64* %object.addr, align 8
  %call135 = call i8* @SSDATA(i64 %105)
  store i8* %call135, i8** %buf.addr, align 8
  br label %if.end.136

if.end.136:                                       ; preds = %if.end.132, %lor.lhs.false.94
  %106 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %write_queue = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %106, i32 0, i32 17
  %107 = load i64, i64* %write_queue, align 8
  %call137 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp138 = icmp eq i64 %107, %call137
  br i1 %cmp138, label %if.end.140, label %if.then.139

if.then.139:                                      ; preds = %if.end.136
  %108 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %109 = load i64, i64* %object.addr, align 8
  %110 = load i8*, i8** %buf.addr, align 8
  %111 = load i64, i64* %len.addr, align 8
  call void @write_queue_push(%struct.Lisp_Process* %108, i64 %109, i8* %110, i64 %111, i1 zeroext false)
  br label %if.end.140

if.end.140:                                       ; preds = %if.then.139, %if.end.136
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end.140
  store i64 -1, i64* %cur_len, align 8
  %112 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call141 = call zeroext i1 @write_queue_pop(%struct.Lisp_Process* %112, i64* %cur_object, i8** %cur_buf, i64* %cur_len)
  br i1 %call141, label %if.end.143, label %if.then.142

if.then.142:                                      ; preds = %do.body
  %113 = load i64, i64* %len.addr, align 8
  store i64 %113, i64* %cur_len, align 8
  %114 = load i8*, i8** %buf.addr, align 8
  store i8* %114, i8** %cur_buf, align 8
  %115 = load i64, i64* %object.addr, align 8
  store i64 %115, i64* %cur_object, align 8
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.142, %do.body
  br label %while.cond

while.cond:                                       ; preds = %if.end.219, %if.end.143
  %116 = load i64, i64* %cur_len, align 8
  %cmp144 = icmp sgt i64 %116, 0
  br i1 %cmp144, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i64 0, i64* %written, align 8
  %117 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd146 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %117, i32 0, i32 22
  %118 = load i32, i32* %outfd146, align 4
  store i32 %118, i32* %outfd145, align 4
  %119 = load i32, i32* %outfd145, align 4
  %idxprom147 = sext i32 %119 to i64
  %arrayidx148 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom147
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx148, i32 0, i32 0
  %120 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp149 = icmp ne %struct.sockaddr* %120, null
  br i1 %cmp149, label %if.then.150, label %if.else.166

if.then.150:                                      ; preds = %while.body
  %121 = load i32, i32* %outfd145, align 4
  %122 = load i8*, i8** %cur_buf, align 8
  %123 = load i64, i64* %cur_len, align 8
  %__sockaddr__ = bitcast %union.__CONST_SOCKADDR_ARG* %agg.tmp to %struct.sockaddr**
  %124 = load i32, i32* %outfd145, align 4
  %idxprom151 = sext i32 %124 to i64
  %arrayidx152 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom151
  %sa153 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx152, i32 0, i32 0
  %125 = load %struct.sockaddr*, %struct.sockaddr** %sa153, align 8
  store %struct.sockaddr* %125, %struct.sockaddr** %__sockaddr__, align 8
  %126 = load i32, i32* %outfd145, align 4
  %idxprom154 = sext i32 %126 to i64
  %arrayidx155 = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom154
  %len156 = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx155, i32 0, i32 1
  %127 = load i32, i32* %len156, align 4
  %coerce.dive = getelementptr %union.__CONST_SOCKADDR_ARG, %union.__CONST_SOCKADDR_ARG* %agg.tmp, i32 0, i32 0
  %128 = load %struct.sockaddr*, %struct.sockaddr** %coerce.dive, align 8
  %call157 = call i64 @sendto(i32 %121, i8* %122, i64 %123, i32 0, %struct.sockaddr* %128, i32 %127)
  store i64 %call157, i64* %rv, align 8
  %129 = load i64, i64* %rv, align 8
  %cmp158 = icmp sge i64 %129, 0
  br i1 %cmp158, label %if.then.159, label %if.else.160

if.then.159:                                      ; preds = %if.then.150
  %130 = load i64, i64* %rv, align 8
  store i64 %130, i64* %written, align 8
  br label %if.end.165

if.else.160:                                      ; preds = %if.then.150
  %call161 = call i32* @__errno_location() #11
  %131 = load i32, i32* %call161, align 4
  %cmp162 = icmp eq i32 %131, 90
  br i1 %cmp162, label %if.then.163, label %if.end.164

if.then.163:                                      ; preds = %if.else.160
  %132 = load i64, i64* %proc.addr, align 8
  call void @report_file_error(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.95, i32 0, i32 0), i64 %132) #8
  unreachable

if.end.164:                                       ; preds = %if.else.160
  br label %if.end.165

if.end.165:                                       ; preds = %if.end.164, %if.then.159
  br label %if.end.192

if.else.166:                                      ; preds = %while.body
  %133 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_p = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %133, i32 0, i32 39
  %bf.load167 = load i8, i8* %gnutls_p, align 8
  %bf.clear168 = and i8 %bf.load167, 1
  %bf.cast169 = trunc i8 %bf.clear168 to i1
  br i1 %bf.cast169, label %land.lhs.true.170, label %if.else.174

land.lhs.true.170:                                ; preds = %if.else.166
  %134 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %gnutls_state = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %134, i32 0, i32 31
  %135 = load %struct.gnutls_session_int*, %struct.gnutls_session_int** %gnutls_state, align 8
  %tobool171 = icmp ne %struct.gnutls_session_int* %135, null
  br i1 %tobool171, label %if.then.172, label %if.else.174

if.then.172:                                      ; preds = %land.lhs.true.170
  %136 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %137 = load i8*, i8** %cur_buf, align 8
  %138 = load i64, i64* %cur_len, align 8
  %call173 = call i64 @emacs_gnutls_write(%struct.Lisp_Process* %136, i8* %137, i64 %138)
  store i64 %call173, i64* %written, align 8
  br label %if.end.176

if.else.174:                                      ; preds = %land.lhs.true.170, %if.else.166
  %139 = load i32, i32* %outfd145, align 4
  %140 = load i8*, i8** %cur_buf, align 8
  %141 = load i64, i64* %cur_len, align 8
  %call175 = call i64 @emacs_write_sig(i32 %139, i8* %140, i64 %141)
  store i64 %call175, i64* %written, align 8
  br label %if.end.176

if.end.176:                                       ; preds = %if.else.174, %if.then.172
  %142 = load i64, i64* %written, align 8
  %tobool177 = icmp ne i64 %142, 0
  %cond178 = select i1 %tobool177, i32 0, i32 -1
  %conv = sext i32 %cond178 to i64
  store i64 %conv, i64* %rv, align 8
  %143 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %143, i32 0, i32 27
  %144 = load i32, i32* %read_output_delay, align 4
  %cmp179 = icmp sgt i32 %144, 0
  br i1 %cmp179, label %land.lhs.true.181, label %if.end.191

land.lhs.true.181:                                ; preds = %if.end.176
  %145 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %adaptive_read_buffering = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %145, i32 0, i32 28
  %bf.load182 = load i8, i8* %adaptive_read_buffering, align 8
  %bf.clear183 = and i8 %bf.load182, 3
  %bf.cast184 = zext i8 %bf.clear183 to i32
  %cmp185 = icmp eq i32 %bf.cast184, 1
  br i1 %cmp185, label %if.then.187, label %if.end.191

if.then.187:                                      ; preds = %land.lhs.true.181
  %146 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_delay188 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %146, i32 0, i32 27
  store i32 0, i32* %read_output_delay188, align 4
  %147 = load i32, i32* @process_output_delay_count, align 4
  %dec = add nsw i32 %147, -1
  store i32 %dec, i32* @process_output_delay_count, align 4
  %148 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %read_output_skip = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %148, i32 0, i32 28
  %bf.load189 = load i8, i8* %read_output_skip, align 8
  %bf.clear190 = and i8 %bf.load189, -5
  store i8 %bf.clear190, i8* %read_output_skip, align 8
  br label %if.end.191

if.end.191:                                       ; preds = %if.then.187, %land.lhs.true.181, %if.end.176
  br label %if.end.192

if.end.192:                                       ; preds = %if.end.191, %if.end.165
  %149 = load i64, i64* %rv, align 8
  %cmp193 = icmp slt i64 %149, 0
  br i1 %cmp193, label %if.then.195, label %if.end.219

if.then.195:                                      ; preds = %if.end.192
  %call196 = call i32* @__errno_location() #11
  %150 = load i32, i32* %call196, align 4
  %cmp197 = icmp eq i32 %150, 11
  br i1 %cmp197, label %if.then.203, label %lor.lhs.false.199

lor.lhs.false.199:                                ; preds = %if.then.195
  %call200 = call i32* @__errno_location() #11
  %151 = load i32, i32* %call200, align 4
  %cmp201 = icmp eq i32 %151, 11
  br i1 %cmp201, label %if.then.203, label %if.else.206

if.then.203:                                      ; preds = %lor.lhs.false.199, %if.then.195
  %152 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %153 = load i64, i64* %cur_object, align 8
  %154 = load i8*, i8** %cur_buf, align 8
  %155 = load i64, i64* %cur_len, align 8
  call void @write_queue_push(%struct.Lisp_Process* %152, i64 %153, i8* %154, i64 %155, i1 zeroext true)
  %call204 = call i64 @builtin_lisp_symbol(i32 0)
  %call205 = call i32 @wait_reading_process_output(i64 0, i32 20000000, i32 0, i1 zeroext false, i64 %call204, %struct.Lisp_Process* null, i32 0)
  br label %while.end

if.else.206:                                      ; preds = %lor.lhs.false.199
  %call207 = call i32* @__errno_location() #11
  %156 = load i32, i32* %call207, align 4
  %cmp208 = icmp eq i32 %156, 32
  br i1 %cmp208, label %if.then.210, label %if.else.218

if.then.210:                                      ; preds = %if.else.206
  %157 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new211 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %157, i32 0, i32 28
  %bf.load212 = load i8, i8* %raw_status_new211, align 8
  %bf.clear213 = and i8 %bf.load212, 127
  store i8 %bf.clear213, i8* %raw_status_new211, align 8
  %158 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call214 = call i64 @builtin_lisp_symbol(i32 387)
  %call215 = call i64 @list2(i64 %call214, i64 1026)
  call void @pset_status(%struct.Lisp_Process* %158, i64 %call215)
  %159 = load i64, i64* @process_tick, align 8
  %inc = add nsw i64 %159, 1
  store i64 %inc, i64* @process_tick, align 8
  %160 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %160, i32 0, i32 24
  store i64 %inc, i64* %tick, align 8
  %161 = load i64, i64* %proc.addr, align 8
  call void @deactivate_process(i64 %161)
  %162 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name216 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %162, i32 0, i32 2
  %163 = load i64, i64* %name216, align 8
  %call217 = call i8* @SDATA(i64 %163)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.96, i32 0, i32 0), i8* %call217) #8
  unreachable

if.else.218:                                      ; preds = %if.else.206
  %164 = load i64, i64* %proc.addr, align 8
  call void @report_file_error(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.97, i32 0, i32 0), i64 %164) #8
  unreachable

if.end.219:                                       ; preds = %if.end.192
  %165 = load i64, i64* %written, align 8
  %166 = load i8*, i8** %cur_buf, align 8
  %add.ptr = getelementptr inbounds i8, i8* %166, i64 %165
  store i8* %add.ptr, i8** %cur_buf, align 8
  %167 = load i64, i64* %written, align 8
  %168 = load i64, i64* %cur_len, align 8
  %sub220 = sub nsw i64 %168, %167
  store i64 %sub220, i64* %cur_len, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then.203, %while.cond
  br label %do.cond

do.cond:                                          ; preds = %while.end
  %169 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %write_queue221 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %169, i32 0, i32 17
  %170 = load i64, i64* %write_queue221, align 8
  %call222 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp223 = icmp eq i64 %170, %call222
  %lnot = xor i1 %cmp223, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  ret void
}

declare i64 @Fcurrent_buffer() #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_send_string(i64 %process, i64 %string) #0 {
entry:
  %process.addr = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %proc = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %1)
  store i64 %call, i64* %proc, align 8
  %2 = load i64, i64* %proc, align 8
  %3 = load i64, i64* %string.addr, align 8
  %call1 = call i8* @SSDATA(i64 %3)
  %4 = load i64, i64* %string.addr, align 8
  %call2 = call i64 @SBYTES(i64 %4)
  %5 = load i64, i64* %string.addr, align 8
  call void @send_process(i64 %2, i8* %call1, i64 %call2, i64 %5)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @Fprocess_running_child_p(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %gid = alloca i32, align 4
  %proc = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %0)
  store i64 %call, i64* %proc, align 8
  %1 = load i64, i64* %proc, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call1, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 10
  %3 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 793)
  %cmp = icmp eq i64 %3, %call2
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 2
  %5 = load i64, i64* %name, align 8
  %call3 = call i8* @SDATA(i64 %5)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.39, i32 0, i32 0), i8* %call3) #8
  unreachable

if.end:                                           ; preds = %entry
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 21
  %7 = load i32, i32* %infd, align 4
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then.5, label %if.end.8

if.then.5:                                        ; preds = %if.end
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name6 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 2
  %9 = load i64, i64* %name6, align 8
  %call7 = call i8* @SDATA(i64 %9)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.40, i32 0, i32 0), i8* %call7) #8
  unreachable

if.end.8:                                         ; preds = %if.end
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call9 = call i32 @emacs_get_tty_pgrp(%struct.Lisp_Process* %10)
  store i32 %call9, i32* %gid, align 4
  %11 = load i32, i32* %gid, align 4
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 20
  %13 = load i32, i32* %pid, align 4
  %cmp10 = icmp eq i32 %11, %13
  br i1 %cmp10, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %if.end.8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call12, i64* %retval
  br label %return

if.end.13:                                        ; preds = %if.end.8
  %14 = load i32, i32* %gid, align 4
  %cmp14 = icmp ne i32 %14, -1
  br i1 %cmp14, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %if.end.13
  %15 = load i32, i32* %gid, align 4
  %conv = sext i32 %15 to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %retval
  br label %return

if.end.16:                                        ; preds = %if.end.13
  %call17 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call17, i64* %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.15, %if.then.11
  %16 = load i64, i64* %retval
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define internal i32 @emacs_get_tty_pgrp(%struct.Lisp_Process* %p) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %gid = alloca i32, align 4
  %fd = alloca i32, align 4
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i32 -1, i32* %gid, align 4
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %0, i32 0, i32 21
  %1 = load i32, i32* %infd, align 4
  %call = call i32 (i32, i64, ...) @ioctl(i32 %1, i64 21519, i32* %gid) #5
  %cmp = icmp eq i32 %call, -1
  br i1 %cmp, label %land.lhs.true, label %if.end.10

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %tty_name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 1
  %3 = load i64, i64* %tty_name, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %3, %call1
  br i1 %cmp2, label %if.end.10, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %tty_name3 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 1
  %5 = load i64, i64* %tty_name3, align 8
  %call4 = call i8* @SSDATA(i64 %5)
  %call5 = call i32 @emacs_open(i8* %call4, i32 0, i32 0)
  store i32 %call5, i32* %fd, align 4
  %6 = load i32, i32* %fd, align 4
  %cmp6 = icmp ne i32 %6, -1
  br i1 %cmp6, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.then
  %7 = load i32, i32* %fd, align 4
  %call8 = call i32 (i32, i64, ...) @ioctl(i32 %7, i64 21519, i32* %gid) #5
  %8 = load i32, i32* %fd, align 4
  %call9 = call i32 @emacs_close(i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then.7, %if.then
  br label %if.end.10

if.end.10:                                        ; preds = %if.end, %land.lhs.true, %entry
  %9 = load i32, i32* %gid, align 4
  ret i32 %9
}

; Function Attrs: nounwind uwtable
define i64 @Finterrupt_process(i64 %process, i64 %current_group) #0 {
entry:
  %process.addr = alloca i64, align 8
  %current_group.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %current_group, i64* %current_group.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %1 = load i64, i64* %current_group.addr, align 8
  call void @process_send_signal(i64 %0, i32 2, i64 %1, i1 zeroext false)
  %2 = load i64, i64* %process.addr, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define internal void @process_send_signal(i64 %process, i32 %signo, i64 %current_group, i1 zeroext %nomsg) #0 {
entry:
  %process.addr = alloca i64, align 8
  %signo.addr = alloca i32, align 4
  %current_group.addr = alloca i64, align 8
  %nomsg.addr = alloca i8, align 1
  %proc = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %gid = alloca i32, align 4
  %no_pgrp = alloca i8, align 1
  %t = alloca %struct.termios, align 4
  %sig_char = alloca i8*, align 8
  %pid59 = alloca i32, align 4
  %oldset = alloca %struct.__sigset_t, align 8
  store i64 %process, i64* %process.addr, align 8
  store i32 %signo, i32* %signo.addr, align 4
  store i64 %current_group, i64* %current_group.addr, align 8
  %frombool = zext i1 %nomsg to i8
  store i8 %frombool, i8* %nomsg.addr, align 1
  store i8 0, i8* %no_pgrp, align 1
  %0 = load i64, i64* %process.addr, align 8
  %call = call i64 @get_process(i64 %0)
  store i64 %call, i64* %proc, align 8
  %1 = load i64, i64* %proc, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call1, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 10
  %3 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 793)
  %cmp = icmp eq i64 %3, %call2
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 2
  %5 = load i64, i64* %name, align 8
  %call3 = call i8* @SDATA(i64 %5)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.39, i32 0, i32 0), i8* %call3) #8
  unreachable

if.end:                                           ; preds = %entry
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 21
  %7 = load i32, i32* %infd, align 4
  %cmp4 = icmp slt i32 %7, 0
  br i1 %cmp4, label %if.then.5, label %if.end.8

if.then.5:                                        ; preds = %if.end
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name6 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 2
  %9 = load i64, i64* %name6, align 8
  %call7 = call i8* @SDATA(i64 %9)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.40, i32 0, i32 0), i8* %call7) #8
  unreachable

if.end.8:                                         ; preds = %if.end
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pty_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 28
  %bf.load = load i8, i8* %pty_flag, align 8
  %bf.lshr = lshr i8 %bf.load, 4
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end.11, label %if.then.9

if.then.9:                                        ; preds = %if.end.8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* %current_group.addr, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %if.end.8
  %11 = load i64, i64* %current_group.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %11, %call12
  br i1 %cmp13, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %if.end.11
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 20
  %13 = load i32, i32* %pid, align 4
  store i32 %13, i32* %gid, align 4
  br label %if.end.47

if.else:                                          ; preds = %if.end.11
  store i8* null, i8** %sig_char, align 8
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd15 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 21
  %15 = load i32, i32* %infd15, align 4
  %call16 = call i32 @tcgetattr(i32 %15, %struct.termios* %t) #5
  %16 = load i32, i32* %signo.addr, align 4
  switch i32 %16, label %sw.epilog [
    i32 2, label %sw.bb
    i32 3, label %sw.bb.17
    i32 20, label %sw.bb.20
  ]

sw.bb:                                            ; preds = %if.else
  %c_cc = getelementptr inbounds %struct.termios, %struct.termios* %t, i32 0, i32 5
  %arrayidx = getelementptr inbounds [32 x i8], [32 x i8]* %c_cc, i32 0, i64 0
  store i8* %arrayidx, i8** %sig_char, align 8
  br label %sw.epilog

sw.bb.17:                                         ; preds = %if.else
  %c_cc18 = getelementptr inbounds %struct.termios, %struct.termios* %t, i32 0, i32 5
  %arrayidx19 = getelementptr inbounds [32 x i8], [32 x i8]* %c_cc18, i32 0, i64 1
  store i8* %arrayidx19, i8** %sig_char, align 8
  br label %sw.epilog

sw.bb.20:                                         ; preds = %if.else
  %c_cc21 = getelementptr inbounds %struct.termios, %struct.termios* %t, i32 0, i32 5
  %arrayidx22 = getelementptr inbounds [32 x i8], [32 x i8]* %c_cc21, i32 0, i64 10
  store i8* %arrayidx22, i8** %sig_char, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.else, %sw.bb.20, %sw.bb.17, %sw.bb
  %17 = load i8*, i8** %sig_char, align 8
  %tobool = icmp ne i8* %17, null
  br i1 %tobool, label %land.lhs.true, label %if.end.27

land.lhs.true:                                    ; preds = %sw.epilog
  %18 = load i8*, i8** %sig_char, align 8
  %19 = load i8, i8* %18, align 1
  %conv = zext i8 %19 to i32
  %cmp23 = icmp ne i32 %conv, 0
  br i1 %cmp23, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %land.lhs.true
  %20 = load i64, i64* %proc, align 8
  %21 = load i8*, i8** %sig_char, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  call void @send_process(i64 %20, i8* %21, i64 1, i64 %call26)
  br label %return

if.end.27:                                        ; preds = %land.lhs.true, %sw.epilog
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call28 = call i32 @emacs_get_tty_pgrp(%struct.Lisp_Process* %22)
  store i32 %call28, i32* %gid, align 4
  %23 = load i32, i32* %gid, align 4
  %cmp29 = icmp eq i32 %23, -1
  br i1 %cmp29, label %if.then.31, label %if.end.33

if.then.31:                                       ; preds = %if.end.27
  %24 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid32 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %24, i32 0, i32 20
  %25 = load i32, i32* %pid32, align 4
  store i32 %25, i32* %gid, align 4
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.31, %if.end.27
  %26 = load i32, i32* %gid, align 4
  %cmp34 = icmp eq i32 %26, -1
  br i1 %cmp34, label %if.then.36, label %if.end.37

if.then.36:                                       ; preds = %if.end.33
  store i8 1, i8* %no_pgrp, align 1
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.36, %if.end.33
  %27 = load i64, i64* %current_group.addr, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp39 = icmp eq i64 %27, %call38
  br i1 %cmp39, label %land.lhs.true.41, label %if.end.46

land.lhs.true.41:                                 ; preds = %if.end.37
  %28 = load i32, i32* %gid, align 4
  %29 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid42 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %29, i32 0, i32 20
  %30 = load i32, i32* %pid42, align 4
  %cmp43 = icmp eq i32 %28, %30
  br i1 %cmp43, label %if.then.45, label %if.end.46

if.then.45:                                       ; preds = %land.lhs.true.41
  br label %return

if.end.46:                                        ; preds = %land.lhs.true.41, %if.end.37
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.46, %if.then.14
  %31 = load i32, i32* %signo.addr, align 4
  %cmp48 = icmp eq i32 %31, 18
  br i1 %cmp48, label %if.then.50, label %if.end.58

if.then.50:                                       ; preds = %if.end.47
  %32 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %32, i32 0, i32 28
  %bf.load51 = load i8, i8* %raw_status_new, align 8
  %bf.clear52 = and i8 %bf.load51, 127
  store i8 %bf.clear52, i8* %raw_status_new, align 8
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call53 = call i64 @builtin_lisp_symbol(i32 820)
  call void @pset_status(%struct.Lisp_Process* %33, i64 %call53)
  %34 = load i64, i64* @process_tick, align 8
  %inc = add nsw i64 %34, 1
  store i64 %inc, i64* @process_tick, align 8
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %35, i32 0, i32 24
  store i64 %inc, i64* %tick, align 8
  %36 = load i8, i8* %nomsg.addr, align 1
  %tobool54 = trunc i8 %36 to i1
  br i1 %tobool54, label %if.end.57, label %if.then.55

if.then.55:                                       ; preds = %if.then.50
  %call56 = call i32 @status_notify(%struct.Lisp_Process* null, %struct.Lisp_Process* null)
  call void @redisplay_preserve_echo_area(i32 13)
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.55, %if.then.50
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57, %if.end.47
  %37 = load i8, i8* %no_pgrp, align 1
  %tobool60 = trunc i8 %37 to i1
  br i1 %tobool60, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.58
  %38 = load i32, i32* %gid, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end.58
  %39 = load i32, i32* %gid, align 4
  %sub = sub nsw i32 0, %39
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %38, %cond.true ], [ %sub, %cond.false ]
  store i32 %cond, i32* %pid59, align 4
  call void @block_child_signal(%struct.__sigset_t* %oldset)
  %40 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %alive = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %40, i32 0, i32 28
  %bf.load62 = load i8, i8* %alive, align 8
  %bf.lshr63 = lshr i8 %bf.load62, 6
  %bf.clear64 = and i8 %bf.lshr63, 1
  %bf.cast65 = trunc i8 %bf.clear64 to i1
  br i1 %bf.cast65, label %if.then.66, label %if.end.68

if.then.66:                                       ; preds = %cond.end
  %41 = load i32, i32* %pid59, align 4
  %42 = load i32, i32* %signo.addr, align 4
  %call67 = call i32 @kill(i32 %41, i32 %42) #5
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.66, %cond.end
  call void @unblock_child_signal(%struct.__sigset_t* %oldset)
  br label %return

return:                                           ; preds = %if.end.68, %if.then.45, %if.then.25
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fkill_process(i64 %process, i64 %current_group) #0 {
entry:
  %process.addr = alloca i64, align 8
  %current_group.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %current_group, i64* %current_group.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %1 = load i64, i64* %current_group.addr, align 8
  call void @process_send_signal(i64 %0, i32 9, i64 %1, i1 zeroext false)
  %2 = load i64, i64* %process.addr, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fquit_process(i64 %process, i64 %current_group) #0 {
entry:
  %process.addr = alloca i64, align 8
  %current_group.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %current_group, i64* %current_group.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %1 = load i64, i64* %current_group.addr, align 8
  call void @process_send_signal(i64 %0, i32 3, i64 %1, i1 zeroext false)
  %2 = load i64, i64* %process.addr, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fstop_process(i64 %process, i64 %current_group) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %current_group.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %current_group, i64* %current_group.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 10
  %2 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load i64, i64* %process.addr, align 8
  %call3 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %type4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call3, i32 0, i32 10
  %4 = load i64, i64* %type4, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.then, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %lor.lhs.false
  %5 = load i64, i64* %process.addr, align 8
  %call8 = call %struct.Lisp_Process* @XPROCESS(i64 %5)
  %type9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call8, i32 0, i32 10
  %6 = load i64, i64* %type9, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp11 = icmp eq i64 %6, %call10
  br i1 %cmp11, label %if.then, label %if.end.21

if.then:                                          ; preds = %lor.lhs.false.7, %lor.lhs.false, %land.lhs.true
  %7 = load i64, i64* %process.addr, align 8
  %call12 = call %struct.Lisp_Process* @XPROCESS(i64 %7)
  store %struct.Lisp_Process* %call12, %struct.Lisp_Process** %p, align 8
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 3
  %9 = load i64, i64* %command, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %9, %call13
  br i1 %cmp14, label %land.lhs.true.15, label %if.end

land.lhs.true.15:                                 ; preds = %if.then
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 21
  %11 = load i32, i32* %infd, align 4
  %cmp16 = icmp sge i32 %11, 0
  br i1 %cmp16, label %if.then.17, label %if.end

if.then.17:                                       ; preds = %land.lhs.true.15
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd18 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 21
  %13 = load i32, i32* %infd18, align 4
  call void @fd_CLR(i32 %13, %struct.fd_set* @input_wait_mask)
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd19 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 21
  %15 = load i32, i32* %infd19, align 4
  call void @fd_CLR(i32 %15, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end

if.end:                                           ; preds = %if.then.17, %land.lhs.true.15, %if.then
  %16 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 901)
  call void @pset_command(%struct.Lisp_Process* %16, i64 %call20)
  %17 = load i64, i64* %process.addr, align 8
  store i64 %17, i64* %retval
  br label %return

if.end.21:                                        ; preds = %lor.lhs.false.7, %entry
  %18 = load i64, i64* %process.addr, align 8
  %19 = load i64, i64* %current_group.addr, align 8
  call void @process_send_signal(i64 %18, i32 20, i64 %19, i1 zeroext false)
  %20 = load i64, i64* %process.addr, align 8
  store i64 %20, i64* %retval
  br label %return

return:                                           ; preds = %if.end.21, %if.end
  %21 = load i64, i64* %retval
  ret i64 %21
}

; Function Attrs: nounwind uwtable
define i64 @Fcontinue_process(i64 %process, i64 %current_group) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %current_group.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %current_group, i64* %current_group.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %land.lhs.true, label %if.end.29

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 10
  %2 = load i64, i64* %type, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load i64, i64* %process.addr, align 8
  %call3 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %type4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call3, i32 0, i32 10
  %4 = load i64, i64* %type4, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.then, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %lor.lhs.false
  %5 = load i64, i64* %process.addr, align 8
  %call8 = call %struct.Lisp_Process* @XPROCESS(i64 %5)
  %type9 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call8, i32 0, i32 10
  %6 = load i64, i64* %type9, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp11 = icmp eq i64 %6, %call10
  br i1 %cmp11, label %if.then, label %if.end.29

if.then:                                          ; preds = %lor.lhs.false.7, %lor.lhs.false, %land.lhs.true
  %7 = load i64, i64* %process.addr, align 8
  %call12 = call %struct.Lisp_Process* @XPROCESS(i64 %7)
  store %struct.Lisp_Process* %call12, %struct.Lisp_Process** %p, align 8
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %command = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 3
  %9 = load i64, i64* %command, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp14 = icmp eq i64 %9, %call13
  br i1 %cmp14, label %land.lhs.true.15, label %if.end

land.lhs.true.15:                                 ; preds = %if.then
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %10, i32 0, i32 21
  %11 = load i32, i32* %infd, align 4
  %cmp16 = icmp sge i32 %11, 0
  br i1 %cmp16, label %land.lhs.true.17, label %if.end

land.lhs.true.17:                                 ; preds = %land.lhs.true.15
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 4
  %13 = load i64, i64* %filter, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp19 = icmp eq i64 %13, %call18
  br i1 %cmp19, label %lor.lhs.false.20, label %if.then.23

lor.lhs.false.20:                                 ; preds = %land.lhs.true.17
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %14, i32 0, i32 12
  %15 = load i64, i64* %status, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 625)
  %cmp22 = icmp eq i64 %15, %call21
  br i1 %cmp22, label %if.then.23, label %if.end

if.then.23:                                       ; preds = %lor.lhs.false.20, %land.lhs.true.17
  %16 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd24 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %16, i32 0, i32 21
  %17 = load i32, i32* %infd24, align 4
  call void @fd_SET(i32 %17, %struct.fd_set* @input_wait_mask)
  %18 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd25 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %18, i32 0, i32 21
  %19 = load i32, i32* %infd25, align 4
  call void @fd_SET(i32 %19, %struct.fd_set* @non_keyboard_wait_mask)
  %20 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd26 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %20, i32 0, i32 21
  %21 = load i32, i32* %infd26, align 4
  %call27 = call i32 @tcflush(i32 %21, i32 0) #5
  br label %if.end

if.end:                                           ; preds = %if.then.23, %lor.lhs.false.20, %land.lhs.true.15, %if.then
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  call void @pset_command(%struct.Lisp_Process* %22, i64 %call28)
  %23 = load i64, i64* %process.addr, align 8
  store i64 %23, i64* %retval
  br label %return

if.end.29:                                        ; preds = %lor.lhs.false.7, %entry
  %24 = load i64, i64* %process.addr, align 8
  %25 = load i64, i64* %current_group.addr, align 8
  call void @process_send_signal(i64 %24, i32 18, i64 %25, i1 zeroext false)
  %26 = load i64, i64* %process.addr, align 8
  store i64 %26, i64* %retval
  br label %return

return:                                           ; preds = %if.end.29, %if.end
  %27 = load i64, i64* %retval
  ret i64 %27
}

; Function Attrs: nounwind
declare i32 @tcflush(i32, i32) #6

; Function Attrs: nounwind uwtable
define i64 @Fsignal_process(i64 %process, i64 %sigcode) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %sigcode.addr = alloca i64, align 8
  %pid = alloca i32, align 4
  %signo = alloca i32, align 4
  %tem = alloca i64, align 8
  %process_number = alloca i64, align 8
  %name54 = alloca i8*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %sigcode, i64* %sigcode.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call i64 @Fget_process(i64 %1)
  store i64 %call1, i64* %tem, align 8
  %2 = load i64, i64* %tem, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then.3, label %if.end.8

if.then.3:                                        ; preds = %if.then
  %3 = load i64, i64* %process.addr, align 8
  %call4 = call i8* @SSDATA(i64 %3)
  %call5 = call i64 @string_to_number(i8* %call4, i32 10, i1 zeroext true)
  store i64 %call5, i64* %process_number, align 8
  %4 = load i64, i64* %process_number, align 8
  %call6 = call zeroext i1 @NUMBERP(i64 %4)
  br i1 %call6, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.then.3
  %5 = load i64, i64* %process_number, align 8
  store i64 %5, i64* %tem, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.7, %if.then.3
  br label %if.end.8

if.end.8:                                         ; preds = %if.end, %if.then
  %6 = load i64, i64* %tem, align 8
  store i64 %6, i64* %process.addr, align 8
  br label %if.end.13

if.else:                                          ; preds = %entry
  %7 = load i64, i64* %process.addr, align 8
  %call9 = call zeroext i1 @NUMBERP(i64 %7)
  br i1 %call9, label %if.end.12, label %if.then.10

if.then.10:                                       ; preds = %if.else
  %8 = load i64, i64* %process.addr, align 8
  %call11 = call i64 @get_process(i64 %8)
  store i64 %call11, i64* %process.addr, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.else
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %if.end.8
  %9 = load i64, i64* %process.addr, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %9, %call14
  br i1 %cmp15, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %if.end.13
  %10 = load i64, i64* %process.addr, align 8
  store i64 %10, i64* %retval
  br label %return

if.end.17:                                        ; preds = %if.end.13
  %11 = load i64, i64* %process.addr, align 8
  %call18 = call zeroext i1 @NUMBERP(i64 %11)
  br i1 %call18, label %if.then.19, label %if.else.21

if.then.19:                                       ; preds = %if.end.17
  %12 = load i64, i64* %process.addr, align 8
  %call20 = call i64 @cons_to_signed(i64 %12, i64 -2147483648, i64 2147483647)
  %conv = trunc i64 %call20 to i32
  store i32 %conv, i32* %pid, align 4
  br label %if.end.30

if.else.21:                                       ; preds = %if.end.17
  %13 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %13)
  %14 = load i64, i64* %process.addr, align 8
  %call22 = call %struct.Lisp_Process* @XPROCESS(i64 %14)
  %pid23 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call22, i32 0, i32 20
  %15 = load i32, i32* %pid23, align 4
  store i32 %15, i32* %pid, align 4
  %16 = load i32, i32* %pid, align 4
  %cmp24 = icmp sle i32 %16, 0
  br i1 %cmp24, label %if.then.26, label %if.end.29

if.then.26:                                       ; preds = %if.else.21
  %17 = load i64, i64* %process.addr, align 8
  %call27 = call %struct.Lisp_Process* @XPROCESS(i64 %17)
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call27, i32 0, i32 2
  %18 = load i64, i64* %name, align 8
  %call28 = call i8* @SDATA(i64 %18)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.41, i32 0, i32 0), i8* %call28) #8
  unreachable

if.end.29:                                        ; preds = %if.else.21
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %if.then.19
  %19 = load i64, i64* %sigcode.addr, align 8
  %and = and i64 %19, 7
  %conv31 = trunc i64 %and to i32
  %and32 = and i32 %conv31, -5
  %cmp33 = icmp eq i32 %and32, 2
  br i1 %cmp33, label %if.then.35, label %if.else.53

if.then.35:                                       ; preds = %if.end.30
  br label %do.body

do.body:                                          ; preds = %if.then.35
  br label %do.body.36

do.body.36:                                       ; preds = %do.body
  %20 = load i64, i64* %sigcode.addr, align 8
  %and37 = and i64 %20, 7
  %conv38 = trunc i64 %and37 to i32
  %and39 = and i32 %conv38, -5
  %cmp40 = icmp eq i32 %and39, 2
  br i1 %cmp40, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.body.36
  br label %cond.end

cond.false:                                       ; preds = %do.body.36
  %call42 = call i64 @builtin_lisp_symbol(i32 559)
  %21 = load i64, i64* %sigcode.addr, align 8
  %22 = call i64 @wrong_type_argument(i64 %call42, i64 %21) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %23, %cond.true
  %24 = load i64, i64* %sigcode.addr, align 8
  %shr = ashr i64 %24, 2
  %cmp43 = icmp sle i64 -2147483648, %shr
  br i1 %cmp43, label %land.lhs.true, label %if.then.48

land.lhs.true:                                    ; preds = %cond.end
  %25 = load i64, i64* %sigcode.addr, align 8
  %shr45 = ashr i64 %25, 2
  %cmp46 = icmp sle i64 %shr45, 2147483647
  br i1 %cmp46, label %if.end.49, label %if.then.48

if.then.48:                                       ; preds = %land.lhs.true, %cond.end
  %26 = load i64, i64* %sigcode.addr, align 8
  call void @args_out_of_range_3(i64 %26, i64 -8589934590, i64 8589934590) #8
  unreachable

if.end.49:                                        ; preds = %land.lhs.true
  br label %do.end

do.end:                                           ; preds = %if.end.49
  br label %do.end.50

do.end.50:                                        ; preds = %do.end
  %27 = load i64, i64* %sigcode.addr, align 8
  %shr51 = ashr i64 %27, 2
  %conv52 = trunc i64 %shr51 to i32
  store i32 %conv52, i32* %signo, align 4
  br label %if.end.70

if.else.53:                                       ; preds = %if.end.30
  %28 = load i64, i64* %sigcode.addr, align 8
  %and55 = and i64 %28, 7
  %conv56 = trunc i64 %and55 to i32
  %cmp57 = icmp eq i32 %conv56, 0
  br i1 %cmp57, label %cond.true.59, label %cond.false.60

cond.true.59:                                     ; preds = %if.else.53
  br label %cond.end.62

cond.false.60:                                    ; preds = %if.else.53
  %call61 = call i64 @builtin_lisp_symbol(i32 897)
  %29 = load i64, i64* %sigcode.addr, align 8
  %30 = call i64 @wrong_type_argument(i64 %call61, i64 %29) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.62

cond.end.62:                                      ; preds = %31, %cond.true.59
  %32 = load i64, i64* %sigcode.addr, align 8
  %call63 = call i64 @SYMBOL_NAME(i64 %32)
  %call64 = call i8* @SSDATA(i64 %call63)
  store i8* %call64, i8** %name54, align 8
  %33 = load i8*, i8** %name54, align 8
  %call65 = call i32 @abbr_to_signal(i8* %33)
  store i32 %call65, i32* %signo, align 4
  %34 = load i32, i32* %signo, align 4
  %cmp66 = icmp slt i32 %34, 0
  br i1 %cmp66, label %if.then.68, label %if.end.69

if.then.68:                                       ; preds = %cond.end.62
  %35 = load i8*, i8** %name54, align 8
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.42, i32 0, i32 0), i8* %35) #8
  unreachable

if.end.69:                                        ; preds = %cond.end.62
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.69, %do.end.50
  %36 = load i32, i32* %pid, align 4
  %37 = load i32, i32* %signo, align 4
  %call71 = call i32 @kill(i32 %36, i32 %37) #5
  %conv72 = sext i32 %call71 to i64
  %shl = shl i64 %conv72, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %retval
  br label %return

return:                                           ; preds = %if.end.70, %if.then.16
  %38 = load i64, i64* %retval
  ret i64 %38
}

declare i64 @string_to_number(i8*, i32, i1 zeroext) #1

declare zeroext i1 @NUMBERP(i64) #1

declare i64 @cons_to_signed(i64, i64, i64) #1

declare i64 @SYMBOL_NAME(i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @abbr_to_signal(i8* %name) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %signo = alloca i32, align 4
  %sigbuf = alloca [20 x i8], align 16
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %call = call i32 @strncmp(i8* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.98, i32 0, i32 0), i64 3) #9
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8*, i8** %name.addr, align 8
  %call1 = call i32 @strncmp(i8* %1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.99, i32 0, i32 0), i64 3) #9
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load i8*, i8** %name.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 3
  store i8* %add.ptr, i8** %name.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4
  %conv = sext i32 %3 to i64
  %cmp = icmp ult i64 %conv, 20
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load i8*, i8** %name.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %conv4 = sext i8 %6 to i32
  %call5 = call i32 @c_toupper(i32 %conv4)
  %conv6 = trunc i32 %call5 to i8
  %7 = load i32, i32* %i, align 4
  %idxprom7 = sext i32 %7 to i64
  %arrayidx8 = getelementptr inbounds [20 x i8], [20 x i8]* %sigbuf, i32 0, i64 %idxprom7
  store i8 %conv6, i8* %arrayidx8, align 1
  %8 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %8 to i64
  %arrayidx10 = getelementptr inbounds [20 x i8], [20 x i8]* %sigbuf, i32 0, i64 %idxprom9
  %9 = load i8, i8* %arrayidx10, align 1
  %tobool11 = icmp ne i8 %9, 0
  br i1 %tobool11, label %if.end.16, label %if.then.12

if.then.12:                                       ; preds = %for.body
  %arraydecay = getelementptr inbounds [20 x i8], [20 x i8]* %sigbuf, i32 0, i32 0
  %call13 = call i32 @str2sig(i8* %arraydecay, i32* %signo)
  %cmp14 = icmp eq i32 %call13, 0
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.12
  %10 = load i32, i32* %signo, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then.12
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ -1, %cond.false ]
  store i32 %cond, i32* %retval
  br label %return

if.end.16:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.16
  %11 = load i32, i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %cond.end
  %12 = load i32, i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind
declare i32 @kill(i32, i32) #6

; Function Attrs: nounwind uwtable
define i64 @Fprocess_send_eof(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %proc = alloca i64, align 8
  %coding = alloca %struct.coding_system*, align 8
  %outfd = alloca i32, align 4
  %p = alloca %struct.Lisp_Process*, align 8
  %old_outfd = alloca i32, align 4
  %new_outfd = alloca i32, align 4
  store i64 %process, i64* %process.addr, align 8
  store %struct.coding_system* null, %struct.coding_system** %coding, align 8
  %0 = load i64, i64* %process.addr, align 8
  %call = call zeroext i1 @PROCESSP(i64 %0)
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 21
  %2 = load i32, i32* %infd, align 4
  %cmp = icmp sge i32 %2, 0
  br i1 %cmp, label %land.lhs.true.2, label %if.end

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %3 = load i64, i64* %process.addr, align 8
  %call3 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %infd4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call3, i32 0, i32 21
  %4 = load i32, i32* %infd4, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.sockaddr_and_len], [1024 x %struct.sockaddr_and_len]* @datagram_address, i32 0, i64 %idxprom
  %sa = getelementptr inbounds %struct.sockaddr_and_len, %struct.sockaddr_and_len* %arrayidx, i32 0, i32 0
  %5 = load %struct.sockaddr*, %struct.sockaddr** %sa, align 8
  %cmp5 = icmp ne %struct.sockaddr* %5, null
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.2
  %6 = load i64, i64* %process.addr, align 8
  store i64 %6, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.2, %land.lhs.true, %entry
  %7 = load i64, i64* %process.addr, align 8
  %call6 = call i64 @get_process(i64 %7)
  store i64 %call6, i64* %proc, align 8
  %8 = load i64, i64* %proc, align 8
  %call7 = call %struct.Lisp_Process* @XPROCESS(i64 %8)
  %outfd8 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call7, i32 0, i32 22
  %9 = load i32, i32* %outfd8, align 4
  store i32 %9, i32* %outfd, align 4
  %10 = load i32, i32* %outfd, align 4
  %cmp9 = icmp sge i32 %10, 0
  br i1 %cmp9, label %if.then.10, label %if.end.13

if.then.10:                                       ; preds = %if.end
  %11 = load i32, i32* %outfd, align 4
  %idxprom11 = sext i32 %11 to i64
  %arrayidx12 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom11
  %12 = load %struct.coding_system*, %struct.coding_system** %arrayidx12, align 8
  store %struct.coding_system* %12, %struct.coding_system** %coding, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.10, %if.end
  %13 = load i64, i64* %proc, align 8
  %call14 = call %struct.Lisp_Process* @XPROCESS(i64 %13)
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call14, i32 0, i32 28
  %bf.load = load i8, i8* %raw_status_new, align 8
  %bf.lshr = lshr i8 %bf.load, 7
  %bf.cast = trunc i8 %bf.lshr to i1
  br i1 %bf.cast, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.end.13
  %14 = load i64, i64* %proc, align 8
  %call16 = call %struct.Lisp_Process* @XPROCESS(i64 %14)
  call void @update_status(%struct.Lisp_Process* %call16)
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.15, %if.end.13
  %15 = load i64, i64* %proc, align 8
  %call18 = call %struct.Lisp_Process* @XPROCESS(i64 %15)
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call18, i32 0, i32 12
  %16 = load i64, i64* %status, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp20 = icmp eq i64 %16, %call19
  br i1 %cmp20, label %if.end.24, label %if.then.21

if.then.21:                                       ; preds = %if.end.17
  %17 = load i64, i64* %proc, align 8
  %call22 = call %struct.Lisp_Process* @XPROCESS(i64 %17)
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call22, i32 0, i32 2
  %18 = load i64, i64* %name, align 8
  %call23 = call i8* @SDATA(i64 %18)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.43, i32 0, i32 0), i8* %call23) #8
  unreachable

if.end.24:                                        ; preds = %if.end.17
  %19 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %tobool = icmp ne %struct.coding_system* %19, null
  br i1 %tobool, label %land.lhs.true.25, label %if.end.35

land.lhs.true.25:                                 ; preds = %if.end.24
  %20 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %common_flags = getelementptr inbounds %struct.coding_system, %struct.coding_system* %20, i32 0, i32 1
  %bf.load26 = load i32, i32* %common_flags, align 8
  %bf.clear = and i32 %bf.load26, 16383
  %and = and i32 %bf.clear, 512
  %tobool27 = icmp ne i32 %and, 0
  br i1 %tobool27, label %if.then.28, label %if.end.35

if.then.28:                                       ; preds = %land.lhs.true.25
  %21 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %mode = getelementptr inbounds %struct.coding_system, %struct.coding_system* %21, i32 0, i32 1
  %bf.load29 = load i32, i32* %mode, align 8
  %bf.lshr30 = lshr i32 %bf.load29, 14
  %bf.clear31 = and i32 %bf.lshr30, 31
  %or = or i32 %bf.clear31, 1
  %bf.load32 = load i32, i32* %mode, align 8
  %bf.value = and i32 %or, 31
  %bf.shl = shl i32 %bf.value, 14
  %bf.clear33 = and i32 %bf.load32, -507905
  %bf.set = or i32 %bf.clear33, %bf.shl
  store i32 %bf.set, i32* %mode, align 8
  %22 = load i64, i64* %proc, align 8
  %call34 = call i64 @builtin_lisp_symbol(i32 0)
  call void @send_process(i64 %22, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.44, i32 0, i32 0), i64 0, i64 %call34)
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.28, %land.lhs.true.25, %if.end.24
  %23 = load i64, i64* %proc, align 8
  %call36 = call %struct.Lisp_Process* @XPROCESS(i64 %23)
  %pty_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call36, i32 0, i32 28
  %bf.load37 = load i8, i8* %pty_flag, align 8
  %bf.lshr38 = lshr i8 %bf.load37, 4
  %bf.clear39 = and i8 %bf.lshr38, 1
  %bf.cast40 = trunc i8 %bf.clear39 to i1
  br i1 %bf.cast40, label %if.then.41, label %if.else

if.then.41:                                       ; preds = %if.end.35
  %24 = load i64, i64* %proc, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  call void @send_process(i64 %24, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0), i64 1, i64 %call42)
  br label %if.end.97

if.else:                                          ; preds = %if.end.35
  %25 = load i64, i64* %proc, align 8
  %call43 = call %struct.Lisp_Process* @XPROCESS(i64 %25)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call43, i32 0, i32 10
  %26 = load i64, i64* %type, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp45 = icmp eq i64 %26, %call44
  br i1 %cmp45, label %if.then.46, label %if.else.54

if.then.46:                                       ; preds = %if.else
  %27 = load i64, i64* %proc, align 8
  %call47 = call %struct.Lisp_Process* @XPROCESS(i64 %27)
  %outfd48 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call47, i32 0, i32 22
  %28 = load i32, i32* %outfd48, align 4
  %call49 = call i32 @tcdrain(i32 %28)
  %cmp50 = icmp ne i32 %call49, 0
  br i1 %cmp50, label %if.then.51, label %if.end.53

if.then.51:                                       ; preds = %if.then.46
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.46, i32 0, i32 0), i64 %call52) #8
  unreachable

if.end.53:                                        ; preds = %if.then.46
  br label %if.end.96

if.else.54:                                       ; preds = %if.else
  %29 = load i64, i64* %proc, align 8
  %call55 = call %struct.Lisp_Process* @XPROCESS(i64 %29)
  store %struct.Lisp_Process* %call55, %struct.Lisp_Process** %p, align 8
  %30 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd56 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %30, i32 0, i32 22
  %31 = load i32, i32* %outfd56, align 4
  store i32 %31, i32* %old_outfd, align 4
  %32 = load i32, i32* %old_outfd, align 4
  %cmp57 = icmp sle i32 0, %32
  br i1 %cmp57, label %land.lhs.true.58, label %if.end.66

land.lhs.true.58:                                 ; preds = %if.else.54
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %type59 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %33, i32 0, i32 10
  %34 = load i64, i64* %type59, align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp61 = icmp eq i64 %34, %call60
  br i1 %cmp61, label %if.then.64, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.58
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd62 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %35, i32 0, i32 21
  %36 = load i32, i32* %infd62, align 4
  %37 = load i32, i32* %old_outfd, align 4
  %cmp63 = icmp eq i32 %36, %37
  br i1 %cmp63, label %if.then.64, label %if.end.66

if.then.64:                                       ; preds = %lor.lhs.false, %land.lhs.true.58
  %38 = load i32, i32* %old_outfd, align 4
  %call65 = call i32 @shutdown(i32 %38, i32 1) #5
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.64, %lor.lhs.false, %if.else.54
  %39 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %39, i32 0, i32 23
  %arrayidx67 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd, i32 0, i64 1
  call void @close_process_fd(i32* %arrayidx67)
  %call68 = call i32 @emacs_open(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.47, i32 0, i32 0), i32 1, i32 0)
  store i32 %call68, i32* %new_outfd, align 4
  %40 = load i32, i32* %new_outfd, align 4
  %cmp69 = icmp slt i32 %40, 0
  br i1 %cmp69, label %if.then.70, label %if.end.72

if.then.70:                                       ; preds = %if.end.66
  %call71 = call i64 @builtin_lisp_symbol(i32 0)
  call void @report_file_error(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.48, i32 0, i32 0), i64 %call71) #8
  unreachable

if.end.72:                                        ; preds = %if.end.66
  %41 = load i32, i32* %new_outfd, align 4
  %42 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %open_fd73 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %42, i32 0, i32 23
  %arrayidx74 = getelementptr inbounds [6 x i32], [6 x i32]* %open_fd73, i32 0, i64 1
  store i32 %41, i32* %arrayidx74, align 4
  %43 = load i32, i32* %new_outfd, align 4
  %44 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd75 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %44, i32 0, i32 22
  store i32 %43, i32* %outfd75, align 4
  %45 = load i32, i32* %new_outfd, align 4
  %idxprom76 = sext i32 %45 to i64
  %arrayidx77 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom76
  %46 = load %struct.coding_system*, %struct.coding_system** %arrayidx77, align 8
  %tobool78 = icmp ne %struct.coding_system* %46, null
  br i1 %tobool78, label %if.end.83, label %if.then.79

if.then.79:                                       ; preds = %if.end.72
  %call80 = call noalias i8* @xmalloc(i64 616)
  %47 = bitcast i8* %call80 to %struct.coding_system*
  %48 = load i32, i32* %new_outfd, align 4
  %idxprom81 = sext i32 %48 to i64
  %arrayidx82 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom81
  store %struct.coding_system* %47, %struct.coding_system** %arrayidx82, align 8
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.79, %if.end.72
  %49 = load i32, i32* %old_outfd, align 4
  %cmp84 = icmp sge i32 %49, 0
  br i1 %cmp84, label %if.then.85, label %if.else.92

if.then.85:                                       ; preds = %if.end.83
  %50 = load i32, i32* %new_outfd, align 4
  %idxprom86 = sext i32 %50 to i64
  %arrayidx87 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom86
  %51 = load %struct.coding_system*, %struct.coding_system** %arrayidx87, align 8
  %52 = load i32, i32* %old_outfd, align 4
  %idxprom88 = sext i32 %52 to i64
  %arrayidx89 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom88
  %53 = load %struct.coding_system*, %struct.coding_system** %arrayidx89, align 8
  %54 = bitcast %struct.coding_system* %51 to i8*
  %55 = bitcast %struct.coding_system* %53 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 616, i32 8, i1 false)
  %56 = load i32, i32* %old_outfd, align 4
  %idxprom90 = sext i32 %56 to i64
  %arrayidx91 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom90
  %57 = load %struct.coding_system*, %struct.coding_system** %arrayidx91, align 8
  %58 = bitcast %struct.coding_system* %57 to i8*
  call void @llvm.memset.p0i8.i64(i8* %58, i8 0, i64 616, i32 8, i1 false)
  br label %if.end.95

if.else.92:                                       ; preds = %if.end.83
  %59 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %59, i32 0, i32 15
  %60 = load i64, i64* %encode_coding_system, align 8
  %61 = load i32, i32* %new_outfd, align 4
  %idxprom93 = sext i32 %61 to i64
  %arrayidx94 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom93
  %62 = load %struct.coding_system*, %struct.coding_system** %arrayidx94, align 8
  call void @setup_coding_system(i64 %60, %struct.coding_system* %62)
  br label %if.end.95

if.end.95:                                        ; preds = %if.else.92, %if.then.85
  br label %if.end.96

if.end.96:                                        ; preds = %if.end.95, %if.end.53
  br label %if.end.97

if.end.97:                                        ; preds = %if.end.96, %if.then.41
  %63 = load i64, i64* %process.addr, align 8
  store i64 %63, i64* %retval
  br label %return

return:                                           ; preds = %if.end.97, %if.then
  %64 = load i64, i64* %retval
  ret i64 %64
}

declare i32 @tcdrain(i32) #1

; Function Attrs: nounwind
declare i32 @shutdown(i32, i32) #6

; Function Attrs: nounwind uwtable
define internal void @close_process_fd(i32* %fd_addr) #0 {
entry:
  %fd_addr.addr = alloca i32*, align 8
  %fd = alloca i32, align 4
  store i32* %fd_addr, i32** %fd_addr.addr, align 8
  %0 = load i32*, i32** %fd_addr.addr, align 8
  %1 = load i32, i32* %0, align 4
  store i32 %1, i32* %fd, align 4
  %2 = load i32, i32* %fd, align 4
  %cmp = icmp sle i32 0, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32*, i32** %fd_addr.addr, align 8
  store i32 -1, i32* %3, align 4
  %4 = load i32, i32* %fd, align 4
  %call = call i32 @emacs_close(i32 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i32 @emacs_open(i8*, i32, i32) #1

declare void @setup_coding_system(i64, %struct.coding_system*) #1

; Function Attrs: nounwind uwtable
define i64 @Finternal_default_process_sentinel(i64 %proc, i64 %msg) #0 {
entry:
  %retval = alloca i64, align 8
  %proc.addr = alloca i64, align 8
  %msg.addr = alloca i64, align 8
  %buffer = alloca i64, align 8
  %symbol = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %tem = alloca i64, align 8
  %old = alloca %struct.buffer*, align 8
  %opoint = alloca i64, align 8
  %opoint_byte = alloca i64, align 8
  %before = alloca i64, align 8
  %before_byte = alloca i64, align 8
  %tem2 = alloca i64, align 8
  store i64 %proc, i64* %proc.addr, align 8
  store i64 %msg, i64* %msg.addr, align 8
  %0 = load i64, i64* %proc.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %proc.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer1 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 7
  %3 = load i64, i64* %buffer1, align 8
  store i64 %3, i64* %buffer, align 8
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 12
  %5 = load i64, i64* %status, align 8
  store i64 %5, i64* %symbol, align 8
  %6 = load i64, i64* %symbol, align 8
  %and = and i64 %6, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i64, i64* %symbol, align 8
  %sub = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 0
  %10 = load i64, i64* %car, align 8
  store i64 %10, i64* %symbol, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load i64, i64* %symbol, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 820)
  %cmp4 = icmp eq i64 %11, %call3
  br i1 %cmp4, label %if.end.58, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %12 = load i64, i64* %buffer, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %12, %call6
  br i1 %cmp7, label %if.end.58, label %if.then.9

if.then.9:                                        ; preds = %land.lhs.true
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %13, %struct.buffer** %old, align 8
  %14 = load i64, i64* %buffer, align 8
  %call10 = call %struct.buffer* @XBUFFER(i64 %14)
  %name_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call10, i32 0, i32 1
  %15 = load i64, i64* %name_, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %15, %call11
  br i1 %cmp12, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %if.then.9
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* %retval
  br label %return

if.end.16:                                        ; preds = %if.then.9
  %16 = load i64, i64* %buffer, align 8
  %call17 = call i64 @Fset_buffer(i64 %16)
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 39
  %18 = load i64, i64* %enable_multibyte_characters_, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %18, %call18
  br i1 %cmp19, label %if.then.21, label %if.end.23

if.then.21:                                       ; preds = %if.end.16
  %19 = load i64, i64* %msg.addr, align 8
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call22 = call i64 @code_convert_string_norecord(i64 %19, i64 %20, i1 zeroext true)
  store i64 %call22, i64* %msg.addr, align 8
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.21, %if.end.16
  %21 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %21, i32 0, i32 75
  %22 = load i64, i64* %pt, align 8
  %add = add nsw i64 %22, 0
  store i64 %add, i64* %opoint, align 8
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 76
  %24 = load i64, i64* %pt_byte, align 8
  %add24 = add nsw i64 %24, 0
  store i64 %add24, i64* %opoint_byte, align 8
  %25 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %25, i32 0, i32 11
  %26 = load i64, i64* %mark, align 8
  %call25 = call %struct.Lisp_Marker* @XMARKER(i64 %26)
  %buffer26 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call25, i32 0, i32 1
  %27 = load %struct.buffer*, %struct.buffer** %buffer26, align 8
  %tobool = icmp ne %struct.buffer* %27, null
  br i1 %tobool, label %if.then.27, label %if.else

if.then.27:                                       ; preds = %if.end.23
  %28 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark28 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %28, i32 0, i32 11
  %29 = load i64, i64* %mark28, align 8
  %call29 = call i64 @Fgoto_char(i64 %29)
  br label %if.end.30

if.else:                                          ; preds = %if.end.23
  %30 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 79
  %31 = load i64, i64* %zv, align 8
  %32 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %32, i32 0, i32 80
  %33 = load i64, i64* %zv_byte, align 8
  call void @set_point_both(i64 %31, i64 %33)
  br label %if.end.30

if.end.30:                                        ; preds = %if.else, %if.then.27
  %34 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt31 = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 75
  %35 = load i64, i64* %pt31, align 8
  %add32 = add nsw i64 %35, 0
  store i64 %add32, i64* %before, align 8
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte33 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 76
  %37 = load i64, i64* %pt_byte33, align 8
  %add34 = add nsw i64 %37, 0
  store i64 %add34, i64* %before_byte, align 8
  %38 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %read_only_ = getelementptr inbounds %struct.buffer, %struct.buffer* %38, i32 0, i32 7
  %39 = load i64, i64* %read_only_, align 8
  store i64 %39, i64* %tem, align 8
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 0)
  call void @bset_read_only(%struct.buffer* %40, i64 %call35)
  call void @insert_string(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.49, i32 0, i32 0))
  %41 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %41, i32 0, i32 2
  %42 = load i64, i64* %name, align 8
  store i64 %42, i64* %tem2, align 8
  %call36 = call i64 @Finsert(i64 1, i64* %tem2)
  call void @insert_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.50, i32 0, i32 0))
  %call37 = call i64 @Finsert(i64 1, i64* %msg.addr)
  %43 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %44 = load i64, i64* %tem, align 8
  call void @bset_read_only(%struct.buffer* %43, i64 %44)
  %45 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %mark38 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %45, i32 0, i32 11
  %46 = load i64, i64* %mark38, align 8
  %47 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %buffer39 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %47, i32 0, i32 7
  %48 = load i64, i64* %buffer39, align 8
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt40 = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 75
  %50 = load i64, i64* %pt40, align 8
  %add41 = add nsw i64 %50, 0
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte42 = getelementptr inbounds %struct.buffer, %struct.buffer* %51, i32 0, i32 76
  %52 = load i64, i64* %pt_byte42, align 8
  %add43 = add nsw i64 %52, 0
  %call44 = call i64 @set_marker_both(i64 %46, i64 %48, i64 %add41, i64 %add43)
  %53 = load i64, i64* %opoint, align 8
  %54 = load i64, i64* %before, align 8
  %cmp45 = icmp sge i64 %53, %54
  br i1 %cmp45, label %if.then.47, label %if.else.56

if.then.47:                                       ; preds = %if.end.30
  %55 = load i64, i64* %opoint, align 8
  %56 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt48 = getelementptr inbounds %struct.buffer, %struct.buffer* %56, i32 0, i32 75
  %57 = load i64, i64* %pt48, align 8
  %add49 = add nsw i64 %57, 0
  %58 = load i64, i64* %before, align 8
  %sub50 = sub nsw i64 %add49, %58
  %add51 = add nsw i64 %55, %sub50
  %59 = load i64, i64* %opoint_byte, align 8
  %60 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte52 = getelementptr inbounds %struct.buffer, %struct.buffer* %60, i32 0, i32 76
  %61 = load i64, i64* %pt_byte52, align 8
  %add53 = add nsw i64 %61, 0
  %62 = load i64, i64* %before_byte, align 8
  %sub54 = sub nsw i64 %add53, %62
  %add55 = add nsw i64 %59, %sub54
  call void @set_point_both(i64 %add51, i64 %add55)
  br label %if.end.57

if.else.56:                                       ; preds = %if.end.30
  %63 = load i64, i64* %opoint, align 8
  %64 = load i64, i64* %opoint_byte, align 8
  call void @set_point_both(i64 %63, i64 %64)
  br label %if.end.57

if.end.57:                                        ; preds = %if.else.56, %if.then.47
  %65 = load %struct.buffer*, %struct.buffer** %old, align 8
  call void @set_buffer_internal(%struct.buffer* %65)
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57, %land.lhs.true, %if.end
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call59, i64* %retval
  br label %return

return:                                           ; preds = %if.end.58, %if.then.14
  %66 = load i64, i64* %retval
  ret i64 %66
}

declare i64 @Fgoto_char(i64) #1

declare void @insert_string(i8*) #1

declare i64 @Finsert(i64, i64*) #1

declare void @set_buffer_internal(%struct.buffer*) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_process_coding_system(i64 %process, i64 %decoding, i64 %encoding) #0 {
entry:
  %process.addr = alloca i64, align 8
  %decoding.addr = alloca i64, align 8
  %encoding.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %decoding, i64* %decoding.addr, align 8
  store i64 %encoding, i64* %encoding.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 21
  %3 = load i32, i32* %infd, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 2
  %5 = load i64, i64* %name, align 8
  %call1 = call i8* @SDATA(i64 %5)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.51, i32 0, i32 0), i8* %call1) #8
  unreachable

if.end:                                           ; preds = %entry
  %6 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %6, i32 0, i32 22
  %7 = load i32, i32* %outfd, align 4
  %cmp2 = icmp slt i32 %7, 0
  br i1 %cmp2, label %if.then.3, label %if.end.6

if.then.3:                                        ; preds = %if.end
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %name4 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 2
  %9 = load i64, i64* %name4, align 8
  %call5 = call i8* @SDATA(i64 %9)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.52, i32 0, i32 0), i8* %call5) #8
  unreachable

if.end.6:                                         ; preds = %if.end
  %10 = load i64, i64* %decoding.addr, align 8
  %call7 = call i64 @Fcheck_coding_system(i64 %10)
  %11 = load i64, i64* %encoding.addr, align 8
  %call8 = call i64 @Fcheck_coding_system(i64 %11)
  %12 = load i64, i64* %encoding.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %call10 = call i64 @coding_inherit_eol_type(i64 %12, i64 %call9)
  store i64 %call10, i64* %encoding.addr, align 8
  %13 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %14 = load i64, i64* %decoding.addr, align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %13, i64 %14)
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %16 = load i64, i64* %encoding.addr, align 8
  call void @pset_encode_coding_system(%struct.Lisp_Process* %15, i64 %16)
  %17 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %17)
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call11
}

declare i64 @Fcheck_coding_system(i64) #1

declare i64 @coding_inherit_eol_type(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_coding_system(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 13
  %2 = load i64, i64* %decode_coding_system, align 8
  %3 = load i64, i64* %process.addr, align 8
  %call1 = call %struct.Lisp_Process* @XPROCESS(i64 %3)
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call1, i32 0, i32 15
  %4 = load i64, i64* %encode_coding_system, align 8
  %call2 = call i64 @Fcons(i64 %2, i64 %4)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @Fset_process_filter_multibyte(i64 %process, i64 %flag) #0 {
entry:
  %process.addr = alloca i64, align 8
  %flag.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  store i64 %process, i64* %process.addr, align 8
  store i64 %flag, i64* %flag.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load i64, i64* %flag.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 13
  %5 = load i64, i64* %decode_coding_system, align 8
  %call2 = call i64 @raw_text_coding_system(i64 %5)
  call void @pset_decode_coding_system(%struct.Lisp_Process* %3, i64 %call2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i64, i64* %process.addr, align 8
  call void @setup_process_coding_systems(i64 %6)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

declare i64 @raw_text_coding_system(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_filter_multibyte_p(i64 %process) #0 {
entry:
  %retval = alloca i64, align 8
  %process.addr = alloca i64, align 8
  %p = alloca %struct.Lisp_Process*, align 8
  %coding = alloca %struct.coding_system*, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  store %struct.Lisp_Process* %call, %struct.Lisp_Process** %p, align 8
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 21
  %3 = load i32, i32* %infd, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd2 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %4, i32 0, i32 21
  %5 = load i32, i32* %infd2, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_decode_coding_system, i32 0, i64 %idxprom
  %6 = load %struct.coding_system*, %struct.coding_system** %arrayidx, align 8
  store %struct.coding_system* %6, %struct.coding_system** %coding, align 8
  %7 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %common_flags = getelementptr inbounds %struct.coding_system, %struct.coding_system* %7, i32 0, i32 1
  %bf.load = load i32, i32* %common_flags, align 8
  %bf.clear = and i32 %bf.load, 16383
  %and = and i32 %bf.clear, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call3, %cond.true ], [ %call4, %cond.false ]
  store i64 %cond, i64* %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %8 = load i64, i64* %retval
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define void @add_timer_wait_descriptor(i32 %fd) #0 {
entry:
  %fd.addr = alloca i32, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  call void @fd_SET(i32 %0, %struct.fd_set* @input_wait_mask)
  %1 = load i32, i32* %fd.addr, align 4
  call void @fd_SET(i32 %1, %struct.fd_set* @non_keyboard_wait_mask)
  %2 = load i32, i32* %fd.addr, align 4
  call void @fd_SET(i32 %2, %struct.fd_set* @non_process_wait_mask)
  %3 = load i32, i32* %fd.addr, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom
  %func = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx, i32 0, i32 0
  store void (i32, i8*)* @timerfd_callback, void (i32, i8*)** %func, align 8
  %4 = load i32, i32* %fd.addr, align 4
  %idxprom1 = sext i32 %4 to i64
  %arrayidx2 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom1
  %data = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx2, i32 0, i32 1
  store i8* null, i8** %data, align 8
  %5 = load i32, i32* %fd.addr, align 4
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr inbounds [1024 x %struct.fd_callback_data], [1024 x %struct.fd_callback_data]* @fd_callback_info, i32 0, i64 %idxprom3
  %condition = getelementptr inbounds %struct.fd_callback_data, %struct.fd_callback_data* %arrayidx4, i32 0, i32 2
  %6 = load i32, i32* %condition, align 4
  %or = or i32 %6, 1
  store i32 %or, i32* %condition, align 4
  %7 = load i32, i32* %fd.addr, align 4
  %8 = load i32, i32* @max_input_desc, align 4
  %cmp = icmp sgt i32 %7, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %fd.addr, align 4
  store i32 %9, i32* @max_input_desc, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @timerfd_callback(i32, i8*) #1

declare i64 @make_specified_string(i8*, i64, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Fget_buffer_process(i64 %buffer) #0 {
entry:
  %retval = alloca i64, align 8
  %buffer.addr = alloca i64, align 8
  %buf = alloca i64, align 8
  %tail = alloca i64, align 8
  %proc = alloca i64, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  %0 = load i64, i64* %buffer.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %buffer.addr, align 8
  %call2 = call i64 @Fget_buffer(i64 %1)
  store i64 %call2, i64* %buf, align 8
  %2 = load i64, i64* %buf, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %2, %call3
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %if.end
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %retval
  br label %return

if.end.7:                                         ; preds = %if.end
  %3 = load i64, i64* @Vprocess_alist, align 8
  store i64 %3, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.7
  %4 = load i64, i64* %tail, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %cmp8 = icmp eq i32 %conv, 3
  br i1 %cmp8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car, align 8
  %sub10 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub10 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %11 = load i64, i64* %cdr, align 8
  store i64 %11, i64* %proc, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %12 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %12, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %13 = load i64, i64* %proc, align 8
  %call11 = call %struct.Lisp_Process* @XPROCESS(i64 %13)
  %buffer12 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call11, i32 0, i32 7
  %14 = load i64, i64* %buffer12, align 8
  %15 = load i64, i64* %buf, align 8
  %cmp13 = icmp eq i64 %14, %15
  br i1 %cmp13, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %for.body
  %16 = load i64, i64* %proc, align 8
  store i64 %16, i64* %retval
  br label %return

if.end.16:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.16
  %17 = load i64, i64* %tail, align 8
  %sub17 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub17 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %u18 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 1
  %cdr19 = bitcast %union.anon* %u18 to i64*
  %20 = load i64, i64* %cdr19, align 8
  store i64 %20, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call20, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.15, %if.then.5, %if.then
  %21 = load i64, i64* %retval
  ret i64 %21
}

declare i64 @Fget_buffer(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_inherit_coding_system_flag(i64 %process) #0 {
entry:
  %process.addr = alloca i64, align 8
  store i64 %process, i64* %process.addr, align 8
  %0 = load i64, i64* %process.addr, align 8
  call void @CHECK_PROCESS(i64 %0)
  %1 = load i64, i64* %process.addr, align 8
  %call = call %struct.Lisp_Process* @XPROCESS(i64 %1)
  %inherit_coding_system_flag = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call, i32 0, i32 28
  %bf.load = load i8, i8* %inherit_coding_system_flag, align 8
  %bf.lshr = lshr i8 %bf.load, 5
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define void @kill_buffer_processes(i64 %buffer) #0 {
entry:
  %buffer.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %proc = alloca i64, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  %0 = load i64, i64* @Vprocess_alist, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  %sub2 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub2 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  store i64 %8, i64* %proc, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %9 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %9, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %10 = load i64, i64* %buffer.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %10, %call
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %11 = load i64, i64* %proc, align 8
  %call5 = call %struct.Lisp_Process* @XPROCESS(i64 %11)
  %buffer6 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call5, i32 0, i32 7
  %12 = load i64, i64* %buffer6, align 8
  %13 = load i64, i64* %buffer.addr, align 8
  %cmp7 = icmp eq i64 %12, %13
  br i1 %cmp7, label %if.then, label %if.end.33

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %14 = load i64, i64* %proc, align 8
  %call9 = call %struct.Lisp_Process* @XPROCESS(i64 %14)
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call9, i32 0, i32 10
  %15 = load i64, i64* %type, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp11 = icmp eq i64 %15, %call10
  br i1 %cmp11, label %if.then.25, label %lor.lhs.false.13

lor.lhs.false.13:                                 ; preds = %if.then
  %16 = load i64, i64* %proc, align 8
  %call14 = call %struct.Lisp_Process* @XPROCESS(i64 %16)
  %type15 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call14, i32 0, i32 10
  %17 = load i64, i64* %type15, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 845)
  %cmp17 = icmp eq i64 %17, %call16
  br i1 %cmp17, label %if.then.25, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %lor.lhs.false.13
  %18 = load i64, i64* %proc, align 8
  %call20 = call %struct.Lisp_Process* @XPROCESS(i64 %18)
  %type21 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call20, i32 0, i32 10
  %19 = load i64, i64* %type21, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 750)
  %cmp23 = icmp eq i64 %19, %call22
  br i1 %cmp23, label %if.then.25, label %if.else

if.then.25:                                       ; preds = %lor.lhs.false.19, %lor.lhs.false.13, %if.then
  %20 = load i64, i64* %proc, align 8
  %call26 = call i64 @Fdelete_process(i64 %20)
  br label %if.end.32

if.else:                                          ; preds = %lor.lhs.false.19
  %21 = load i64, i64* %proc, align 8
  %call27 = call %struct.Lisp_Process* @XPROCESS(i64 %21)
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %call27, i32 0, i32 21
  %22 = load i32, i32* %infd, align 4
  %cmp28 = icmp sge i32 %22, 0
  br i1 %cmp28, label %if.then.30, label %if.end

if.then.30:                                       ; preds = %if.else
  %23 = load i64, i64* %proc, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  call void @process_send_signal(i64 %23, i32 1, i64 %call31, i1 zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.then.30, %if.else
  br label %if.end.32

if.end.32:                                        ; preds = %if.end, %if.then.25
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end.33
  %24 = load i64, i64* %tail, align 8
  %sub34 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub34 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u35 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr36 = bitcast %union.anon* %u35 to i64*
  %27 = load i64, i64* %cdr36, align 8
  store i64 %27, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fwaiting_for_user_input_p() #0 {
entry:
  %0 = load i32, i32* @waiting_for_user_input_p, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %call1, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define void @hold_keyboard_input() #0 {
entry:
  store i8 1, i8* @kbd_is_on_hold, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define void @unhold_keyboard_input() #0 {
entry:
  store i8 0, i8* @kbd_is_on_hold, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Flist_system_processes() #0 {
entry:
  %call = call i64 @list_system_processes()
  ret i64 %call
}

declare i64 @list_system_processes() #1

; Function Attrs: nounwind uwtable
define i64 @Fprocess_attributes(i64 %pid) #0 {
entry:
  %pid.addr = alloca i64, align 8
  store i64 %pid, i64* %pid.addr, align 8
  %0 = load i64, i64* %pid.addr, align 8
  %call = call i64 @system_process_attributes(i64 %0)
  ret i64 %call
}

declare i64 @system_process_attributes(i64) #1

; Function Attrs: nounwind uwtable
define void @catch_child_signal() #0 {
entry:
  %action = alloca %struct.sigaction, align 8
  %old_action = alloca %struct.sigaction, align 8
  %oldset = alloca %struct.__sigset_t, align 8
  call void @emacs_sigaction_init(%struct.sigaction* %action, void (i32)* @deliver_child_signal)
  call void @block_child_signal(%struct.__sigset_t* %oldset)
  %call = call i32 @sigaction(i32 17, %struct.sigaction* %action, %struct.sigaction* %old_action) #5
  %__sigaction_handler = getelementptr inbounds %struct.sigaction, %struct.sigaction* %old_action, i32 0, i32 0
  %sa_handler = bitcast %union.anon.7* %__sigaction_handler to void (i32)**
  %0 = load void (i32)*, void (i32)** %sa_handler, align 8
  %cmp = icmp ne void (i32)* %0, @deliver_child_signal
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %__sigaction_handler1 = getelementptr inbounds %struct.sigaction, %struct.sigaction* %old_action, i32 0, i32 0
  %sa_handler2 = bitcast %union.anon.7* %__sigaction_handler1 to void (i32)**
  %1 = load void (i32)*, void (i32)** %sa_handler2, align 8
  %cmp3 = icmp eq void (i32)* %1, null
  br i1 %cmp3, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %__sigaction_handler4 = getelementptr inbounds %struct.sigaction, %struct.sigaction* %old_action, i32 0, i32 0
  %sa_handler5 = bitcast %union.anon.7* %__sigaction_handler4 to void (i32)**
  %2 = load void (i32)*, void (i32)** %sa_handler5, align 8
  %cmp6 = icmp eq void (i32)* %2, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %if.then
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %__sigaction_handler7 = getelementptr inbounds %struct.sigaction, %struct.sigaction* %old_action, i32 0, i32 0
  %sa_handler8 = bitcast %union.anon.7* %__sigaction_handler7 to void (i32)**
  %3 = load void (i32)*, void (i32)** %sa_handler8, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi void (i32)* [ @dummy_handler, %cond.true ], [ %3, %cond.false ]
  store volatile void (i32)* %cond, void (i32)** @lib_child_handler, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  call void @unblock_child_signal(%struct.__sigset_t* %oldset)
  ret void
}

declare void @emacs_sigaction_init(%struct.sigaction*, void (i32)*) #1

; Function Attrs: nounwind uwtable
define internal void @deliver_child_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load i32, i32* %sig.addr, align 4
  call void @deliver_process_signal(i32 %0, void (i32)* @handle_child_signal)
  ret void
}

declare void @block_child_signal(%struct.__sigset_t*) #1

; Function Attrs: nounwind
declare i32 @sigaction(i32, %struct.sigaction*, %struct.sigaction*) #6

; Function Attrs: nounwind uwtable
define internal void @dummy_handler(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  store i32 %sig, i32* %sig.addr, align 4
  ret void
}

declare void @unblock_child_signal(%struct.__sigset_t*) #1

; Function Attrs: nounwind uwtable
define void @init_process_emacs() #0 {
entry:
  %i = alloca i32, align 4
  %__d0 = alloca i32, align 4
  %__d1 = alloca i32, align 4
  %__d05 = alloca i32, align 4
  %__d16 = alloca i32, align 4
  %__d011 = alloca i32, align 4
  %__d112 = alloca i32, align 4
  %__d017 = alloca i32, align 4
  %__d118 = alloca i32, align 4
  %__d023 = alloca i32, align 4
  %__d124 = alloca i32, align 4
  store i8 0, i8* @inhibit_sentinels, align 1
  %0 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8, i8* @initialized, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call i32 @getpid() #5
  %call2 = call %struct._GSource* @g_child_watch_source_new(i32 %call)
  call void @g_source_unref(%struct._GSource* %call2)
  call void @catch_child_signal()
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  br label %do.body

do.body:                                          ; preds = %if.end
  %2 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* getelementptr inbounds (%struct.fd_set, %struct.fd_set* @input_wait_mask, i32 0, i32 0, i64 0)) #5, !srcloc !8
  %asmresult = extractvalue { i64, i64* } %2, 0
  %asmresult3 = extractvalue { i64, i64* } %2, 1
  %3 = trunc i64 %asmresult to i32
  store i32 %3, i32* %__d0, align 4
  %4 = ptrtoint i64* %asmresult3 to i64
  %5 = trunc i64 %4 to i32
  store i32 %5, i32* %__d1, align 4
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body.4

do.body.4:                                        ; preds = %do.end
  %6 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* getelementptr inbounds (%struct.fd_set, %struct.fd_set* @non_keyboard_wait_mask, i32 0, i32 0, i64 0)) #5, !srcloc !9
  %asmresult7 = extractvalue { i64, i64* } %6, 0
  %asmresult8 = extractvalue { i64, i64* } %6, 1
  %7 = trunc i64 %asmresult7 to i32
  store i32 %7, i32* %__d05, align 4
  %8 = ptrtoint i64* %asmresult8 to i64
  %9 = trunc i64 %8 to i32
  store i32 %9, i32* %__d16, align 4
  br label %do.end.9

do.end.9:                                         ; preds = %do.body.4
  br label %do.body.10

do.body.10:                                       ; preds = %do.end.9
  %10 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* getelementptr inbounds (%struct.fd_set, %struct.fd_set* @non_process_wait_mask, i32 0, i32 0, i64 0)) #5, !srcloc !10
  %asmresult13 = extractvalue { i64, i64* } %10, 0
  %asmresult14 = extractvalue { i64, i64* } %10, 1
  %11 = trunc i64 %asmresult13 to i32
  store i32 %11, i32* %__d011, align 4
  %12 = ptrtoint i64* %asmresult14 to i64
  %13 = trunc i64 %12 to i32
  store i32 %13, i32* %__d112, align 4
  br label %do.end.15

do.end.15:                                        ; preds = %do.body.10
  br label %do.body.16

do.body.16:                                       ; preds = %do.end.15
  %14 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* getelementptr inbounds (%struct.fd_set, %struct.fd_set* @write_mask, i32 0, i32 0, i64 0)) #5, !srcloc !11
  %asmresult19 = extractvalue { i64, i64* } %14, 0
  %asmresult20 = extractvalue { i64, i64* } %14, 1
  %15 = trunc i64 %asmresult19 to i32
  store i32 %15, i32* %__d017, align 4
  %16 = ptrtoint i64* %asmresult20 to i64
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* %__d118, align 4
  br label %do.end.21

do.end.21:                                        ; preds = %do.body.16
  store i32 -1, i32* @max_input_desc, align 4
  store i32 -1, i32* @max_process_desc, align 4
  call void @llvm.memset.p0i8.i64(i8* bitcast ([1024 x %struct.fd_callback_data]* @fd_callback_info to i8*), i8 0, i64 24576, i32 16, i1 false)
  br label %do.body.22

do.body.22:                                       ; preds = %do.end.21
  %18 = call { i64, i64* } asm sideeffect "cld; rep; stosq", "={cx},={di},{ax},0,1,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 0, i64 16, i64* getelementptr inbounds (%struct.fd_set, %struct.fd_set* @connect_wait_mask, i32 0, i32 0, i64 0)) #5, !srcloc !12
  %asmresult25 = extractvalue { i64, i64* } %18, 0
  %asmresult26 = extractvalue { i64, i64* } %18, 1
  %19 = trunc i64 %asmresult25 to i32
  store i32 %19, i32* %__d023, align 4
  %20 = ptrtoint i64* %asmresult26 to i64
  %21 = trunc i64 %20 to i32
  store i32 %21, i32* %__d124, align 4
  br label %do.end.27

do.end.27:                                        ; preds = %do.body.22
  store i32 0, i32* @num_pending_connects, align 4
  store i32 0, i32* @process_output_delay_count, align 4
  store i8 0, i8* @process_output_skip, align 1
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call28, i64* @Vprocess_alist, align 8
  %call29 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call29, i64* @deleted_pid_list, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end.27
  %22 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %22, 1024
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %23 = load i32, i32* %i, align 4
  %idxprom = sext i32 %23 to i64
  %arrayidx = getelementptr inbounds [1024 x i64], [1024 x i64]* @chan_process, i32 0, i64 %idxprom
  store i64 %call30, i64* %arrayidx, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom31 = sext i32 %24 to i64
  %arrayidx32 = getelementptr inbounds [1024 x i32], [1024 x i32]* @proc_buffered_char, i32 0, i64 %idxprom31
  store i32 -1, i32* %arrayidx32, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %25 = load i32, i32* %i, align 4
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @llvm.memset.p0i8.i64(i8* bitcast ([1024 x %struct.coding_system*]* @proc_decode_coding_system to i8*), i8 0, i64 8192, i32 16, i1 false)
  call void @llvm.memset.p0i8.i64(i8* bitcast ([1024 x %struct.coding_system*]* @proc_encode_coding_system to i8*), i8 0, i64 8192, i32 16, i1 false)
  call void @llvm.memset.p0i8.i64(i8* bitcast ([1024 x %struct.sockaddr_and_len]* @datagram_address to i8*), i8 0, i64 16384, i32 16, i1 false)
  store i8 0, i8* @kbd_is_on_hold, align 1
  ret void
}

declare void @g_source_unref(%struct._GSource*) #1

declare %struct._GSource* @g_child_watch_source_new(i32) #1

; Function Attrs: nounwind
declare i32 @getpid() #6

; Function Attrs: nounwind uwtable
define void @syms_of_process() #0 {
entry:
  %subfeatures = alloca i64, align 8
  %sopt = alloca %struct.socket_options*, align 8
  call void @staticpro(i64* @Vprocess_alist)
  call void @staticpro(i64* @deleted_pid_list)
  br label %do.body

do.body:                                          ; preds = %entry
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_process.b_fwd, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.53, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 436))
  br label %do.end

do.end:                                           ; preds = %do.body
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 436), align 1
  br label %do.body.1

do.body.1:                                        ; preds = %do.end
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_process.o_fwd, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.54, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 238))
  br label %do.end.2

do.end.2:                                         ; preds = %do.body.1
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 238), align 8
  br label %do.body.3

do.body.3:                                        ; preds = %do.end.2
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_process.o_fwd.55, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.56, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236))
  br label %do.end.4

do.end.4:                                         ; preds = %do.body.3
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call5, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 236), align 8
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocessp to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sget_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelete_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_status to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_exit_status to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_id to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_name to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_tty_name to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_command to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_buffer to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_buffer to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_mark to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_filter to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_filter to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_sentinel to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_sentinel to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_window_size to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_inherit_coding_system_flag to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_query_on_exit_flag to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_query_on_exit_flag to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_contact to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_plist to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_plist to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sprocess_list)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smake_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smake_pipe_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sserial_process_configure to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smake_serial_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_network_process_option to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smake_network_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sformat_network_address to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Snetwork_interface_list)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Snetwork_interface_info to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_datagram_address to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_datagram_address to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Saccept_process_output to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_send_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_send_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinterrupt_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Skill_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Squit_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sstop_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scontinue_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_running_child_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_send_eof to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssignal_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Swaiting_for_user_input_p)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_type to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinternal_default_process_sentinel to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinternal_default_process_filter to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_coding_system to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_coding_system to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_process_filter_multibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_filter_multibyte_p to %struct.Lisp_Subr*))
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %subfeatures, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 88)
  %call8 = call i64 @builtin_lisp_symbol(i32 901)
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %call10 = call i64 @pure_cons(i64 %call8, i64 %call9)
  %call11 = call i64 @pure_cons(i64 %call7, i64 %call10)
  %0 = load i64, i64* %subfeatures, align 8
  %call12 = call i64 @pure_cons(i64 %call11, i64 %0)
  store i64 %call12, i64* %subfeatures, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 131)
  %call14 = call i64 @builtin_lisp_symbol(i32 316)
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %call16 = call i64 @pure_cons(i64 %call14, i64 %call15)
  %call17 = call i64 @pure_cons(i64 %call13, i64 %call16)
  %1 = load i64, i64* %subfeatures, align 8
  %call18 = call i64 @pure_cons(i64 %call17, i64 %1)
  store i64 %call18, i64* %subfeatures, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 131)
  %call20 = call i64 @builtin_lisp_symbol(i32 843)
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %call22 = call i64 @pure_cons(i64 %call20, i64 %call21)
  %call23 = call i64 @pure_cons(i64 %call19, i64 %call22)
  %2 = load i64, i64* %subfeatures, align 8
  %call24 = call i64 @pure_cons(i64 %call23, i64 %2)
  store i64 %call24, i64* %subfeatures, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 40)
  %call26 = call i64 @builtin_lisp_symbol(i32 632)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @pure_cons(i64 %call26, i64 %call27)
  %call29 = call i64 @pure_cons(i64 %call25, i64 %call28)
  %3 = load i64, i64* %subfeatures, align 8
  %call30 = call i64 @pure_cons(i64 %call29, i64 %3)
  store i64 %call30, i64* %subfeatures, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 40)
  %call32 = call i64 @builtin_lisp_symbol(i32 575)
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %call34 = call i64 @pure_cons(i64 %call32, i64 %call33)
  %call35 = call i64 @pure_cons(i64 %call31, i64 %call34)
  %4 = load i64, i64* %subfeatures, align 8
  %call36 = call i64 @pure_cons(i64 %call35, i64 %4)
  store i64 %call36, i64* %subfeatures, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 40)
  %call38 = call i64 @builtin_lisp_symbol(i32 576)
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  %call40 = call i64 @pure_cons(i64 %call38, i64 %call39)
  %call41 = call i64 @pure_cons(i64 %call37, i64 %call40)
  %5 = load i64, i64* %subfeatures, align 8
  %call42 = call i64 @pure_cons(i64 %call41, i64 %5)
  store i64 %call42, i64* %subfeatures, align 8
  %call43 = call i64 @builtin_lisp_symbol(i32 117)
  %call44 = call i64 @builtin_lisp_symbol(i32 901)
  %call45 = call i64 @builtin_lisp_symbol(i32 0)
  %call46 = call i64 @pure_cons(i64 %call44, i64 %call45)
  %call47 = call i64 @pure_cons(i64 %call43, i64 %call46)
  %6 = load i64, i64* %subfeatures, align 8
  %call48 = call i64 @pure_cons(i64 %call47, i64 %6)
  store i64 %call48, i64* %subfeatures, align 8
  %call49 = call i64 @builtin_lisp_symbol(i32 116)
  %call50 = call i64 @builtin_lisp_symbol(i32 901)
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %call52 = call i64 @pure_cons(i64 %call50, i64 %call51)
  %call53 = call i64 @pure_cons(i64 %call49, i64 %call52)
  %7 = load i64, i64* %subfeatures, align 8
  %call54 = call i64 @pure_cons(i64 %call53, i64 %7)
  store i64 %call54, i64* %subfeatures, align 8
  store %struct.socket_options* getelementptr inbounds ([9 x %struct.socket_options], [9 x %struct.socket_options]* @socket_options, i32 0, i32 0), %struct.socket_options** %sopt, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end.4
  %8 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %name = getelementptr inbounds %struct.socket_options, %struct.socket_options* %8, i32 0, i32 0
  %9 = load i8*, i8** %name, align 8
  %tobool = icmp ne i8* %9, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %name55 = getelementptr inbounds %struct.socket_options, %struct.socket_options* %10, i32 0, i32 0
  %11 = load i8*, i8** %name55, align 8
  %call56 = call i64 @intern_c_string(i8* %11)
  %12 = load i64, i64* %subfeatures, align 8
  %call57 = call i64 @pure_cons(i64 %call56, i64 %12)
  store i64 %call57, i64* %subfeatures, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load %struct.socket_options*, %struct.socket_options** %sopt, align 8
  %incdec.ptr = getelementptr inbounds %struct.socket_options, %struct.socket_options* %13, i32 1
  store %struct.socket_options* %incdec.ptr, %struct.socket_options** %sopt, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call58 = call i64 @intern_c_string(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.57, i32 0, i32 0))
  %14 = load i64, i64* %subfeatures, align 8
  %call59 = call i64 @Fprovide(i64 %call58, i64 %14)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sget_buffer_process to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_inherit_coding_system_flag to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Slist_system_processes)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprocess_attributes to %struct.Lisp_Subr*))
  ret void
}

declare void @staticpro(i64*) #1

declare void @defvar_bool(%struct.Lisp_Boolfwd*, i8*, i8*) #1

declare void @defvar_lisp(%struct.Lisp_Objfwd*, i8*, i64*) #1

declare void @defsubr(%struct.Lisp_Subr*) #1

declare i64 @pure_cons(i64, i64) #1

declare i64 @intern_c_string(i8*) #1

declare i64 @Fprovide(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @status_convert(i32 %w) #0 {
entry:
  %retval = alloca i64, align 8
  %w.addr = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.17, align 4
  %.compoundliteral1 = alloca %union.anon.18, align 4
  %.compoundliteral8 = alloca %union.anon.19, align 4
  %.compoundliteral16 = alloca %union.anon.20, align 4
  %.compoundliteral24 = alloca %union.anon.21, align 4
  %.compoundliteral33 = alloca %union.anon.22, align 4
  %.compoundliteral45 = alloca %union.anon.23, align 4
  %.compoundliteral52 = alloca %union.anon.24, align 4
  store i32 %w, i32* %w.addr, align 4
  %__in = bitcast %union.anon.17* %.compoundliteral to i32*
  %0 = load i32, i32* %w.addr, align 4
  store i32 %0, i32* %__in, align 4
  %__i = bitcast %union.anon.17* %.compoundliteral to i32*
  %1 = load i32, i32* %__i, align 4
  %and = and i32 %1, 255
  %cmp = icmp eq i32 %and, 127
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 880)
  %__in2 = bitcast %union.anon.18* %.compoundliteral1 to i32*
  %2 = load i32, i32* %w.addr, align 4
  store i32 %2, i32* %__in2, align 4
  %__i3 = bitcast %union.anon.18* %.compoundliteral1 to i32*
  %3 = load i32, i32* %__i3, align 4
  %and4 = and i32 %3, 65280
  %shr = ashr i32 %and4, 8
  %conv = sext i32 %shr to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @Fcons(i64 %add, i64 %call5)
  %call7 = call i64 @Fcons(i64 %call, i64 %call6)
  store i64 %call7, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %__in9 = bitcast %union.anon.19* %.compoundliteral8 to i32*
  %4 = load i32, i32* %w.addr, align 4
  store i32 %4, i32* %__in9, align 4
  %__i10 = bitcast %union.anon.19* %.compoundliteral8 to i32*
  %5 = load i32, i32* %__i10, align 4
  %and11 = and i32 %5, 127
  %cmp12 = icmp eq i32 %and11, 0
  br i1 %cmp12, label %if.then.14, label %if.else.32

if.then.14:                                       ; preds = %if.else
  %call15 = call i64 @builtin_lisp_symbol(i32 387)
  %__in17 = bitcast %union.anon.20* %.compoundliteral16 to i32*
  %6 = load i32, i32* %w.addr, align 4
  store i32 %6, i32* %__in17, align 4
  %__i18 = bitcast %union.anon.20* %.compoundliteral16 to i32*
  %7 = load i32, i32* %__i18, align 4
  %and19 = and i32 %7, 65280
  %shr20 = ashr i32 %and19, 8
  %conv21 = sext i32 %shr20 to i64
  %shl22 = shl i64 %conv21, 2
  %add23 = add i64 %shl22, 2
  %__in25 = bitcast %union.anon.21* %.compoundliteral24 to i32*
  %8 = load i32, i32* %w.addr, align 4
  store i32 %8, i32* %__in25, align 4
  %__i26 = bitcast %union.anon.21* %.compoundliteral24 to i32*
  %9 = load i32, i32* %__i26, align 4
  %and27 = and i32 %9, 128
  %tobool = icmp ne i32 %and27, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.14
  %call28 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.then.14
  %call29 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call28, %cond.true ], [ %call29, %cond.false ]
  %call30 = call i64 @Fcons(i64 %add23, i64 %cond)
  %call31 = call i64 @Fcons(i64 %call15, i64 %call30)
  store i64 %call31, i64* %retval
  br label %return

if.else.32:                                       ; preds = %if.else
  %__in34 = bitcast %union.anon.22* %.compoundliteral33 to i32*
  %10 = load i32, i32* %w.addr, align 4
  store i32 %10, i32* %__in34, align 4
  %__i35 = bitcast %union.anon.22* %.compoundliteral33 to i32*
  %11 = load i32, i32* %__i35, align 4
  %and36 = and i32 %11, 127
  %add37 = add nsw i32 %and36, 1
  %conv38 = trunc i32 %add37 to i8
  %conv39 = sext i8 %conv38 to i32
  %shr40 = ashr i32 %conv39, 1
  %cmp41 = icmp sgt i32 %shr40, 0
  br i1 %cmp41, label %if.then.43, label %if.else.65

if.then.43:                                       ; preds = %if.else.32
  %call44 = call i64 @builtin_lisp_symbol(i32 862)
  %__in46 = bitcast %union.anon.23* %.compoundliteral45 to i32*
  %12 = load i32, i32* %w.addr, align 4
  store i32 %12, i32* %__in46, align 4
  %__i47 = bitcast %union.anon.23* %.compoundliteral45 to i32*
  %13 = load i32, i32* %__i47, align 4
  %and48 = and i32 %13, 127
  %conv49 = sext i32 %and48 to i64
  %shl50 = shl i64 %conv49, 2
  %add51 = add i64 %shl50, 2
  %__in53 = bitcast %union.anon.24* %.compoundliteral52 to i32*
  %14 = load i32, i32* %w.addr, align 4
  store i32 %14, i32* %__in53, align 4
  %__i54 = bitcast %union.anon.24* %.compoundliteral52 to i32*
  %15 = load i32, i32* %__i54, align 4
  %and55 = and i32 %15, 128
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %cond.true.57, label %cond.false.59

cond.true.57:                                     ; preds = %if.then.43
  %call58 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.61

cond.false.59:                                    ; preds = %if.then.43
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.61

cond.end.61:                                      ; preds = %cond.false.59, %cond.true.57
  %cond62 = phi i64 [ %call58, %cond.true.57 ], [ %call60, %cond.false.59 ]
  %call63 = call i64 @Fcons(i64 %add51, i64 %cond62)
  %call64 = call i64 @Fcons(i64 %call44, i64 %call63)
  store i64 %call64, i64* %retval
  br label %return

if.else.65:                                       ; preds = %if.else.32
  %call66 = call i64 @builtin_lisp_symbol(i32 820)
  store i64 %call66, i64* %retval
  br label %return

return:                                           ; preds = %if.else.65, %cond.end.61, %cond.end, %if.then
  %16 = load i64, i64* %retval
  ret i64 %16
}

declare i64 @Frassq(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal %struct.Lisp_Process* @allocate_process() #0 {
entry:
  %call = call %struct.Lisp_Vector* @allocate_pseudovector(i32 36, i32 19, i32 36, i32 2)
  %0 = bitcast %struct.Lisp_Vector* %call to %struct.Lisp_Process*
  ret %struct.Lisp_Process* %0
}

; Function Attrs: nounwind uwtable
define internal void @pset_mark(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %mark = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 11
  store i64 %0, i64* %mark, align 8
  ret void
}

declare i64 @Fmake_marker() #1

declare i64 @make_formatted_string(i8*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @pset_name(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 2
  store i64 %0, i64* %name, align 8
  ret void
}

declare %struct.Lisp_Vector* @allocate_pseudovector(i32, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @allocate_pty(i8* %pty_name) #0 {
entry:
  %retval = alloca i32, align 4
  %pty_name.addr = alloca i8*, align 8
  %fd = alloca i32, align 4
  %i = alloca i32, align 4
  %ptyname = alloca i8*, align 8
  %blocked = alloca %struct.__sigset_t, align 8
  store i8* %pty_name, i8** %pty_name.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %0, 1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %call = call i32 @posix_openpt(i32 524546)
  store i32 %call, i32* %fd, align 4
  %1 = load i32, i32* %fd, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.body
  %call2 = call i32* @__errno_location() #11
  %2 = load i32, i32* %call2, align 4
  %cmp3 = icmp eq i32 %2, 22
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call4 = call i32 @posix_openpt(i32 258)
  store i32 %call4, i32* %fd, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %3 = load i32, i32* %fd, align 4
  %cmp5 = icmp sge i32 %3, 0
  br i1 %cmp5, label %if.then.6, label %if.end.29

if.then.6:                                        ; preds = %do.end
  store i8* null, i8** %ptyname, align 8
  %call7 = call i32 @sigemptyset(%struct.__sigset_t* %blocked) #5
  %call8 = call i32 @sigaddset(%struct.__sigset_t* %blocked, i32 17) #5
  %call9 = call i32 @pthread_sigmask(i32 0, %struct.__sigset_t* %blocked, %struct.__sigset_t* null) #5
  %4 = load i32, i32* %fd, align 4
  %call10 = call i32 @grantpt(i32 %4) #5
  %cmp11 = icmp ne i32 %call10, -1
  br i1 %cmp11, label %land.lhs.true.12, label %if.end.17

land.lhs.true.12:                                 ; preds = %if.then.6
  %5 = load i32, i32* %fd, align 4
  %call13 = call i32 @unlockpt(i32 %5) #5
  %cmp14 = icmp ne i32 %call13, -1
  br i1 %cmp14, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %land.lhs.true.12
  %6 = load i32, i32* %fd, align 4
  %call16 = call i8* @ptsname(i32 %6) #5
  store i8* %call16, i8** %ptyname, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.15, %land.lhs.true.12, %if.then.6
  %call18 = call i32 @pthread_sigmask(i32 1, %struct.__sigset_t* %blocked, %struct.__sigset_t* null) #5
  %7 = load i8*, i8** %ptyname, align 8
  %tobool = icmp ne i8* %7, null
  br i1 %tobool, label %if.end.21, label %if.then.19

if.then.19:                                       ; preds = %if.end.17
  %8 = load i32, i32* %fd, align 4
  %call20 = call i32 @emacs_close(i32 %8)
  store i32 -1, i32* %retval
  br label %return

if.end.21:                                        ; preds = %if.end.17
  %9 = load i8*, i8** %pty_name.addr, align 8
  %10 = load i8*, i8** %ptyname, align 8
  %call22 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %9, i64 24, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.64, i32 0, i32 0), i8* %10) #5
  %11 = load i32, i32* %fd, align 4
  %call23 = call i32 (i32, i32, ...) @rpl_fcntl(i32 %11, i32 2, i32 1)
  %12 = load i8*, i8** %pty_name.addr, align 8
  %call24 = call i32 @faccessat(i32 -100, i8* %12, i32 6, i32 512) #5
  %cmp25 = icmp ne i32 %call24, 0
  br i1 %cmp25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.end.21
  %13 = load i32, i32* %fd, align 4
  %call27 = call i32 @emacs_close(i32 %13)
  br label %for.inc

if.end.28:                                        ; preds = %if.end.21
  %14 = load i32, i32* %fd, align 4
  call void @setup_pty(i32 %14)
  %15 = load i32, i32* %fd, align 4
  store i32 %15, i32* %retval
  br label %return

if.end.29:                                        ; preds = %do.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.29, %if.then.26
  %16 = load i32, i32* %i, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.end.28, %if.then.19
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind returns_twice
declare i32 @vfork() #7

; Function Attrs: nounwind
declare i32 @setsid() #6

; Function Attrs: nounwind
declare i32 @ioctl(i32, i64, ...) #6

declare void @emacs_perror(i8*) #1

; Function Attrs: noreturn
declare void @_exit(i32) #2

; Function Attrs: nounwind
declare void (i32)* @signal(i32, void (i32)*) #6

declare void @child_setup_tty(i32) #1

; Function Attrs: noreturn
declare i32 @child_setup(i32, i32, i32, i8**, i1 zeroext, i64) #2

; Function Attrs: nounwind uwtable
define internal void @pset_tty_name(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %tty_name = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 1
  store i64 %0, i64* %tty_name, align 8
  ret void
}

declare i64 @emacs_read(i32, i8*, i64) #1

declare i32 @posix_openpt(i32) #1

; Function Attrs: nounwind
declare i32 @sigemptyset(%struct.__sigset_t*) #6

; Function Attrs: nounwind
declare i32 @sigaddset(%struct.__sigset_t*, i32) #6

; Function Attrs: nounwind
declare i32 @pthread_sigmask(i32, %struct.__sigset_t*, %struct.__sigset_t*) #6

; Function Attrs: nounwind
declare i32 @grantpt(i32) #6

; Function Attrs: nounwind
declare i32 @unlockpt(i32) #6

; Function Attrs: nounwind
declare i8* @ptsname(i32) #6

; Function Attrs: nounwind
declare i32 @snprintf(i8*, i64, i8*, ...) #6

; Function Attrs: nounwind
declare i32 @faccessat(i32, i8*, i32, i32) #6

declare void @setup_pty(i32) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #3

declare i8* @xpalloc(i8*, i64*, i64, i64, i64) #1

declare i64 @intern(i8*) #1

declare i32 @accept4(i32, %struct.sockaddr*, i32*, i32) #1

declare i64 @call3(i64, i64, i64, i64) #1

declare i64 @concat3(i64, i64, i64) #1

declare i64 @Fnumber_to_string(i64) #1

declare i64 @Fbuffer_name(i64) #1

declare i64 @emacs_gnutls_deinit(i64) #1

declare i64 @recvfrom(i32, i8*, i64, i32, %struct.sockaddr*, i32*) #1

declare i64 @emacs_gnutls_read(%struct.Lisp_Process*, i8*, i64) #1

declare void @record_unwind_current_buffer() #1

; Function Attrs: nounwind uwtable
define internal void @read_and_dispose_of_process_output(%struct.Lisp_Process* %p, i8* %chars, i64 %nbytes, %struct.coding_system* %coding) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %chars.addr = alloca i8*, align 8
  %nbytes.addr = alloca i64, align 8
  %coding.addr = alloca %struct.coding_system*, align 8
  %outstream = alloca i64, align 8
  %text = alloca i64, align 8
  %outer_running_asynch_code = alloca i8, align 1
  %waiting = alloca i32, align 4
  %tem = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i8* %chars, i8** %chars.addr, align 8
  store i64 %nbytes, i64* %nbytes.addr, align 8
  store %struct.coding_system* %coding, %struct.coding_system** %coding.addr, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %filter = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %0, i32 0, i32 4
  %1 = load i64, i64* %filter, align 8
  store i64 %1, i64* %outstream, align 8
  %2 = load i8, i8* @running_asynch_code, align 1
  %tobool = trunc i8 %2 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %outer_running_asynch_code, align 1
  %3 = load i32, i32* @waiting_for_user_input_p, align 4
  store i32 %3, i32* %waiting, align 4
  %call = call i64 @builtin_lisp_symbol(i32 546)
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call, i64 %call1)
  %call2 = call i64 @builtin_lisp_symbol(i32 604)
  %call3 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call2, i64 %call3)
  %4 = load i8, i8* %outer_running_asynch_code, align 1
  %tobool4 = trunc i8 %4 to i1
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %call8 = call i64 @Fmatch_data(i64 %call5, i64 %call6, i64 %call7)
  store i64 %call8, i64* %tem, align 8
  call void @restore_search_regs()
  call void @record_unwind_save_match_data()
  %5 = load i64, i64* %tem, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 901)
  %call10 = call i64 @Fset_match_data(i64 %5, i64 %call9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i8 1, i8* @running_asynch_code, align 1
  br label %do.body

do.body:                                          ; preds = %if.end
  %6 = load i8*, i8** %chars.addr, align 8
  %7 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %source = getelementptr inbounds %struct.coding_system, %struct.coding_system* %7, i32 0, i32 17
  store i8* %6, i8** %source, align 8
  %8 = load i64, i64* %nbytes.addr, align 8
  %9 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %src_bytes = getelementptr inbounds %struct.coding_system, %struct.coding_system* %9, i32 0, i32 15
  store i64 %8, i64* %src_bytes, align 8
  %10 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %src_chars = getelementptr inbounds %struct.coding_system, %struct.coding_system* %10, i32 0, i32 14
  store i64 %8, i64* %src_chars, align 8
  %11 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %12 = load i64, i64* %nbytes.addr, align 8
  %13 = load i64, i64* %nbytes.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 901)
  call void @decode_coding_object(%struct.coding_system* %11, i64 %call11, i64 0, i64 0, i64 %12, i64 %13, i64 %call12)
  br label %do.end

do.end:                                           ; preds = %do.body
  %14 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %dst_object = getelementptr inbounds %struct.coding_system, %struct.coding_system* %14, i32 0, i32 21
  %15 = load i64, i64* %dst_object, align 8
  store i64 %15, i64* %text, align 8
  %16 = load i64, i64* @Vcoding_system_hash_table, align 8
  %call13 = call %struct.Lisp_Hash_Table* @XHASH_TABLE(i64 %16)
  %17 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %id = getelementptr inbounds %struct.coding_system, %struct.coding_system* %17, i32 0, i32 0
  %18 = load i64, i64* %id, align 8
  %call14 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %call13, i64 %18)
  store i64 %call14, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %19 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %19, i32 0, i32 13
  %20 = load i64, i64* %decode_coding_system, align 8
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %cmp = icmp eq i64 %20, %21
  br i1 %cmp, label %if.end.30, label %if.then.15

if.then.15:                                       ; preds = %do.end
  %22 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %23 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  call void @pset_decode_coding_system(%struct.Lisp_Process* %22, i64 %23)
  %24 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %encode_coding_system = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %24, i32 0, i32 15
  %25 = load i64, i64* %encode_coding_system, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %25, %call16
  br i1 %cmp17, label %land.lhs.true, label %if.end.29

land.lhs.true:                                    ; preds = %if.then.15
  %26 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %outfd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %26, i32 0, i32 22
  %27 = load i32, i32* %outfd, align 4
  %cmp18 = icmp sge i32 %27, 0
  br i1 %cmp18, label %land.lhs.true.19, label %if.end.29

land.lhs.true.19:                                 ; preds = %land.lhs.true
  %28 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %outfd20 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %28, i32 0, i32 22
  %29 = load i32, i32* %outfd20, align 4
  %idxprom = sext i32 %29 to i64
  %arrayidx = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom
  %30 = load %struct.coding_system*, %struct.coding_system** %arrayidx, align 8
  %tobool21 = icmp ne %struct.coding_system* %30, null
  br i1 %tobool21, label %if.then.22, label %if.end.29

if.then.22:                                       ; preds = %land.lhs.true.19
  %31 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %32 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 155), align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %call24 = call i64 @coding_inherit_eol_type(i64 %32, i64 %call23)
  call void @pset_encode_coding_system(%struct.Lisp_Process* %31, i64 %call24)
  %33 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %encode_coding_system25 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %33, i32 0, i32 15
  %34 = load i64, i64* %encode_coding_system25, align 8
  %35 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %outfd26 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %35, i32 0, i32 22
  %36 = load i32, i32* %outfd26, align 4
  %idxprom27 = sext i32 %36 to i64
  %arrayidx28 = getelementptr inbounds [1024 x %struct.coding_system*], [1024 x %struct.coding_system*]* @proc_encode_coding_system, i32 0, i64 %idxprom27
  %37 = load %struct.coding_system*, %struct.coding_system** %arrayidx28, align 8
  call void @setup_coding_system(i64 %34, %struct.coding_system* %37)
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.22, %land.lhs.true.19, %land.lhs.true, %if.then.15
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %do.end
  %38 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover_bytes = getelementptr inbounds %struct.coding_system, %struct.coding_system* %38, i32 0, i32 27
  %39 = load i32, i32* %carryover_bytes, align 4
  %cmp31 = icmp sgt i32 %39, 0
  br i1 %cmp31, label %if.then.32, label %if.end.47

if.then.32:                                       ; preds = %if.end.30
  %40 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decoding_buf = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %40, i32 0, i32 14
  %41 = load i64, i64* %decoding_buf, align 8
  %call33 = call i64 @SCHARS(i64 %41)
  %42 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover_bytes34 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %42, i32 0, i32 27
  %43 = load i32, i32* %carryover_bytes34, align 4
  %conv = sext i32 %43 to i64
  %cmp35 = icmp slt i64 %call33, %conv
  br i1 %cmp35, label %if.then.37, label %if.end.41

if.then.37:                                       ; preds = %if.then.32
  %44 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %45 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover_bytes38 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %45, i32 0, i32 27
  %46 = load i32, i32* %carryover_bytes38, align 4
  %conv39 = sext i32 %46 to i64
  %call40 = call i64 @make_uninit_string(i64 %conv39)
  call void @pset_decoding_buf(%struct.Lisp_Process* %44, i64 %call40)
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.37, %if.then.32
  %47 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decoding_buf42 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %47, i32 0, i32 14
  %48 = load i64, i64* %decoding_buf42, align 8
  %call43 = call i8* @SDATA(i64 %48)
  %49 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover = getelementptr inbounds %struct.coding_system, %struct.coding_system* %49, i32 0, i32 26
  %50 = bitcast [64 x i8]* %carryover to i8*
  %51 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover_bytes44 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %51, i32 0, i32 27
  %52 = load i32, i32* %carryover_bytes44, align 4
  %conv45 = sext i32 %52 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call43, i8* %50, i64 %conv45, i32 1, i1 false)
  %53 = load %struct.coding_system*, %struct.coding_system** %coding.addr, align 8
  %carryover_bytes46 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %53, i32 0, i32 27
  %54 = load i32, i32* %carryover_bytes46, align 4
  %55 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %decoding_carryover = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %55, i32 0, i32 26
  store i32 %54, i32* %decoding_carryover, align 4
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.41, %if.end.30
  %56 = load i64, i64* %text, align 8
  %call48 = call i64 @SBYTES(i64 %56)
  %cmp49 = icmp sgt i64 %call48, 0
  br i1 %cmp49, label %if.then.51, label %if.end.60

if.then.51:                                       ; preds = %if.end.47
  %57 = load i64, i64* %outstream, align 8
  %58 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %call52 = call i64 @make_lisp_proc(%struct.Lisp_Process* %58)
  %59 = load i64, i64* %text, align 8
  %call53 = call i64 @list3(i64 %57, i64 %call52, i64 %59)
  %60 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 54), align 8
  %call54 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp55 = icmp eq i64 %60, %call54
  br i1 %cmp55, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.51
  %call57 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.false:                                       ; preds = %if.then.51
  %call58 = call i64 @builtin_lisp_symbol(i32 372)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call57, %cond.true ], [ %call58, %cond.false ]
  %call59 = call i64 @internal_condition_case_1(i64 (i64)* @read_process_output_call, i64 %call53, i64 %cond, i64 (i64)* @read_process_output_error_handler)
  br label %if.end.60

if.end.60:                                        ; preds = %cond.end, %if.end.47
  call void @restore_search_regs()
  %61 = load i8, i8* %outer_running_asynch_code, align 1
  %tobool61 = trunc i8 %61 to i1
  %frombool62 = zext i1 %tobool61 to i8
  store i8 %frombool62, i8* @running_asynch_code, align 1
  %62 = load i32, i32* %waiting, align 4
  store i32 %62, i32* @waiting_for_user_input_p, align 4
  %63 = load i32, i32* @waiting_for_user_input_p, align 4
  %cmp63 = icmp eq i32 %63, -1
  br i1 %cmp63, label %if.then.65, label %if.end.66

if.then.65:                                       ; preds = %if.end.60
  call void @record_asynch_buffer_change()
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.65, %if.end.60
  ret void
}

declare void @specbind(i64, i64) #1

declare i64 @Fmatch_data(i64, i64, i64) #1

declare void @restore_search_regs() #1

declare void @record_unwind_save_match_data() #1

declare i64 @Fset_match_data(i64, i64) #1

declare void @decode_coding_object(%struct.coding_system*, i64, i64, i64, i64, i64, i64) #1

declare i64 @HASH_KEY(%struct.Lisp_Hash_Table*, i64) #1

declare %struct.Lisp_Hash_Table* @XHASH_TABLE(i64) #1

declare i64 @make_uninit_string(i64) #1

declare i64 @internal_condition_case_1(i64 (i64)*, i64, i64, i64 (i64)*) #1

; Function Attrs: nounwind uwtable
define internal i64 @read_process_output_call(i64 %fun_and_args) #0 {
entry:
  %fun_and_args.addr = alloca i64, align 8
  store i64 %fun_and_args, i64* %fun_and_args.addr, align 8
  %0 = load i64, i64* %fun_and_args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %4 = load i64, i64* %fun_and_args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %call = call i64 @apply1(i64 %3, i64 %7)
  ret i64 %call
}

declare i64 @list3(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_lisp_proc(%struct.Lisp_Process* %p) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %1 = bitcast %struct.Lisp_Process* %0 to i8*
  %call = call i64 @make_lisp_ptr(i8* %1, i32 5)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @read_process_output_error_handler(i64 %error_val) #0 {
entry:
  %error_val.addr = alloca i64, align 8
  store i64 %error_val, i64* %error_val.addr, align 8
  %0 = load i64, i64* %error_val.addr, align 8
  call void @cmd_error_internal(i64 %0, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.93, i32 0, i32 0))
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  call void @update_echo_area()
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @Fsleep_for(i64 10, i64 %call1)
  %call3 = call i64 @builtin_lisp_symbol(i32 901)
  ret i64 %call3
}

declare i64 @apply1(i64, i64) #1

declare void @cmd_error_internal(i64, i8*) #1

declare void @update_echo_area() #1

declare i64 @Fsleep_for(i64, i64) #1

declare i64 @buf_bytepos_to_charpos(%struct.buffer*, i64) #1

declare void @temp_set_point_both(%struct.buffer*, i64, i64) #1

declare void @encode_coding_object(%struct.coding_system*, i64, i64, i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @write_queue_push(%struct.Lisp_Process* %p, i64 %input_obj, i8* %buf, i64 %len, i1 zeroext %front) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %input_obj.addr = alloca i64, align 8
  %buf.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %front.addr = alloca i8, align 1
  %offset = alloca i64, align 8
  %entry1 = alloca i64, align 8
  %obj = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %input_obj, i64* %input_obj.addr, align 8
  store i8* %buf, i8** %buf.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %frombool = zext i1 %front to i8
  store i8 %frombool, i8* %front.addr, align 1
  %0 = load i64, i64* %input_obj.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %buf.addr, align 8
  %2 = load i64, i64* %input_obj.addr, align 8
  %call2 = call i8* @SSDATA(i64 %2)
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %call2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %offset, align 8
  %3 = load i64, i64* %input_obj.addr, align 8
  store i64 %3, i64* %obj, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i64 0, i64* %offset, align 8
  %4 = load i8*, i8** %buf.addr, align 8
  %5 = load i64, i64* %len.addr, align 8
  %call3 = call i64 @make_unibyte_string(i8* %4, i64 %5)
  store i64 %call3, i64* %obj, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load i64, i64* %obj, align 8
  %7 = load i64, i64* %offset, align 8
  %shl = shl i64 %7, 2
  %add = add i64 %shl, 2
  %8 = load i64, i64* %len.addr, align 8
  %shl4 = shl i64 %8, 2
  %add5 = add i64 %shl4, 2
  %call6 = call i64 @Fcons(i64 %add, i64 %add5)
  %call7 = call i64 @Fcons(i64 %6, i64 %call6)
  store i64 %call7, i64* %entry1, align 8
  %9 = load i8, i8* %front.addr, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then.8, label %if.else.10

if.then.8:                                        ; preds = %if.end
  %10 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %11 = load i64, i64* %entry1, align 8
  %12 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %12, i32 0, i32 17
  %13 = load i64, i64* %write_queue, align 8
  %call9 = call i64 @Fcons(i64 %11, i64 %13)
  call void @pset_write_queue(%struct.Lisp_Process* %10, i64 %call9)
  br label %if.end.14

if.else.10:                                       ; preds = %if.end
  %14 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %15 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue11 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %15, i32 0, i32 17
  %16 = load i64, i64* %write_queue11, align 8
  %17 = load i64, i64* %entry1, align 8
  %call12 = call i64 @list1(i64 %17)
  %call13 = call i64 @nconc2(i64 %16, i64 %call12)
  call void @pset_write_queue(%struct.Lisp_Process* %14, i64 %call13)
  br label %if.end.14

if.end.14:                                        ; preds = %if.else.10, %if.then.8
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @write_queue_pop(%struct.Lisp_Process* %p, i64* %obj, i8** %buf, i64* %len) #0 {
entry:
  %retval = alloca i1, align 1
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %obj.addr = alloca i64*, align 8
  %buf.addr = alloca i8**, align 8
  %len.addr = alloca i64*, align 8
  %entry1 = alloca i64, align 8
  %offset_length = alloca i64, align 8
  %offset = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64* %obj, i64** %obj.addr, align 8
  store i8** %buf, i8*** %buf.addr, align 8
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %0, i32 0, i32 17
  %1 = load i64, i64* %write_queue, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue2 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %2, i32 0, i32 17
  %3 = load i64, i64* %write_queue2, align 8
  %sub = sub nsw i64 %3, 3
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %5, i32 0, i32 0
  %6 = load i64, i64* %car, align 8
  store i64 %6, i64* %entry1, align 8
  %7 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %8 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue3 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %8, i32 0, i32 17
  %9 = load i64, i64* %write_queue3, align 8
  %sub4 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub4 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %12 = load i64, i64* %cdr, align 8
  call void @pset_write_queue(%struct.Lisp_Process* %7, i64 %12)
  %13 = load i64, i64* %entry1, align 8
  %sub5 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub5 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car6 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car6, align 8
  %17 = load i64*, i64** %obj.addr, align 8
  store i64 %16, i64* %17, align 8
  %18 = load i64, i64* %entry1, align 8
  %sub7 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub7 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %u8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 1
  %cdr9 = bitcast %union.anon* %u8 to i64*
  %21 = load i64, i64* %cdr9, align 8
  store i64 %21, i64* %offset_length, align 8
  %22 = load i64, i64* %offset_length, align 8
  %sub10 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub10 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr12 = bitcast %union.anon* %u11 to i64*
  %25 = load i64, i64* %cdr12, align 8
  %shr = ashr i64 %25, 2
  %26 = load i64*, i64** %len.addr, align 8
  store i64 %shr, i64* %26, align 8
  %27 = load i64, i64* %offset_length, align 8
  %sub13 = sub nsw i64 %27, 3
  %28 = inttoptr i64 %sub13 to i8*
  %29 = bitcast i8* %28 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %29, i32 0, i32 0
  %30 = load i64, i64* %car14, align 8
  %shr15 = ashr i64 %30, 2
  store i64 %shr15, i64* %offset, align 8
  %31 = load i64*, i64** %obj.addr, align 8
  %32 = load i64, i64* %31, align 8
  %call16 = call i8* @SSDATA(i64 %32)
  %33 = load i64, i64* %offset, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call16, i64 %33
  %34 = load i8**, i8*** %buf.addr, align 8
  store i8* %add.ptr, i8** %34, align 8
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %35 = load i1, i1* %retval
  ret i1 %35
}

declare i64 @sendto(i32, i8*, i64, i32, %struct.sockaddr*, i32) #1

declare i64 @emacs_gnutls_write(%struct.Lisp_Process*, i8*, i64) #1

declare i64 @emacs_write_sig(i32, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @pset_write_queue(%struct.Lisp_Process* %p, i64 %val) #0 {
entry:
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %write_queue = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %1, i32 0, i32 17
  store i64 %0, i64* %write_queue, align 8
  ret void
}

declare i64 @nconc2(i64, i64) #1

; Function Attrs: nounwind
declare i32 @tcgetattr(i32, %struct.termios*) #6

; Function Attrs: nounwind readonly
declare i32 @strncmp(i8*, i8*, i64) #3

declare i32 @c_toupper(i32) #1

declare i32 @str2sig(i8*, i32*) #1

; Function Attrs: nounwind uwtable
define internal i64 @exec_sentinel_error_handler(i64 %error_val) #0 {
entry:
  %error_val.addr = alloca i64, align 8
  store i64 %error_val, i64* %error_val.addr, align 8
  %0 = load i64, i64* %error_val.addr, align 8
  call void @cmd_error_internal(i64 %0, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.100, i32 0, i32 0))
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  call void @update_echo_area()
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @Fsleep_for(i64 10, i64 %call1)
  %call3 = call i64 @builtin_lisp_symbol(i32 901)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define internal i64 @status_message(%struct.Lisp_Process* %p) #0 {
entry:
  %retval = alloca i64, align 8
  %p.addr = alloca %struct.Lisp_Process*, align 8
  %status = alloca i64, align 8
  %symbol = alloca i64, align 8
  %code = alloca i32, align 4
  %coredump = alloca i8, align 1
  %string = alloca i64, align 8
  %signame = alloca i8*, align 8
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %suffix = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %prefix = alloca i64, align 8
  %.compoundliteral106 = alloca %union.Aligned_String, align 8
  %suffix118 = alloca i64, align 8
  %.compoundliteral119 = alloca %union.Aligned_String, align 8
  %prefix140 = alloca i64, align 8
  %.compoundliteral141 = alloca %union.Aligned_String, align 8
  %suffix153 = alloca i64, align 8
  %.compoundliteral154 = alloca %union.Aligned_String, align 8
  store %struct.Lisp_Process* %p, %struct.Lisp_Process** %p.addr, align 8
  %0 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %status1 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %0, i32 0, i32 12
  %1 = load i64, i64* %status1, align 8
  store i64 %1, i64* %status, align 8
  %2 = load i64, i64* %status, align 8
  call void @decode_status(i64 %2, i64* %symbol, i32* %code, i8* %coredump)
  %3 = load i64, i64* %symbol, align 8
  %call = call i64 @builtin_lisp_symbol(i32 862)
  %cmp = icmp eq i64 %3, %call
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i64, i64* %symbol, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 880)
  %cmp3 = icmp eq i64 %4, %call2
  br i1 %cmp3, label %if.then, label %if.else.87

if.then:                                          ; preds = %lor.lhs.false, %entry
  call void @synchronize_system_messages_locale()
  %5 = load i32, i32* %code, align 4
  %call4 = call i8* @strsignal(i32 %5) #5
  store i8* %call4, i8** %signame, align 8
  %6 = load i8*, i8** %signame, align 8
  %cmp5 = icmp eq i8* %6, null
  br i1 %cmp5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.then
  %call7 = call i64 @build_string(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.101, i32 0, i32 0))
  store i64 %call7, i64* %string, align 8
  br label %if.end.76

if.else:                                          ; preds = %if.then
  %7 = load i8*, i8** %signame, align 8
  %call8 = call i64 @build_unibyte_string(i8* %7)
  store i64 %call8, i64* %string, align 8
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %8, %call9
  br i1 %cmp10, label %if.end, label %if.then.11

if.then.11:                                       ; preds = %if.else
  %9 = load i64, i64* %string, align 8
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call12 = call i64 @code_convert_string_norecord(i64 %9, i64 %10, i1 zeroext false)
  store i64 %call12, i64* %string, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.11, %if.else
  %11 = load i64, i64* %string, align 8
  %call13 = call i8* @SDATA(i64 %11)
  %arrayidx = getelementptr inbounds i8, i8* %call13, i64 0
  %12 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end
  %13 = load i64, i64* %string, align 8
  %call14 = call i8* @SDATA(i64 %13)
  %arrayidx15 = getelementptr inbounds i8, i8* %call14, i64 0
  %14 = load i8, i8* %arrayidx15, align 1
  %conv16 = zext i8 %14 to i32
  br label %cond.end.65

cond.false:                                       ; preds = %if.end
  %15 = load i64, i64* %string, align 8
  %call17 = call i8* @SDATA(i64 %15)
  %arrayidx18 = getelementptr inbounds i8, i8* %call17, i64 0
  %16 = load i8, i8* %arrayidx18, align 1
  %conv19 = zext i8 %16 to i32
  %and20 = and i32 %conv19, 32
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %cond.false.36, label %cond.true.22

cond.true.22:                                     ; preds = %cond.false
  %17 = load i64, i64* %string, align 8
  %call23 = call i8* @SDATA(i64 %17)
  %arrayidx24 = getelementptr inbounds i8, i8* %call23, i64 0
  %18 = load i8, i8* %arrayidx24, align 1
  %conv25 = zext i8 %18 to i32
  %and26 = and i32 %conv25, 31
  %shl = shl i32 %and26, 6
  %19 = load i64, i64* %string, align 8
  %call27 = call i8* @SDATA(i64 %19)
  %arrayidx28 = getelementptr inbounds i8, i8* %call27, i64 1
  %20 = load i8, i8* %arrayidx28, align 1
  %conv29 = zext i8 %20 to i32
  %and30 = and i32 %conv29, 63
  %or = or i32 %shl, %and30
  %21 = load i64, i64* %string, align 8
  %call31 = call i8* @SDATA(i64 %21)
  %arrayidx32 = getelementptr inbounds i8, i8* %call31, i64 0
  %22 = load i8, i8* %arrayidx32, align 1
  %conv33 = zext i8 %22 to i32
  %cmp34 = icmp slt i32 %conv33, 194
  %cond = select i1 %cmp34, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.63

cond.false.36:                                    ; preds = %cond.false
  %23 = load i64, i64* %string, align 8
  %call37 = call i8* @SDATA(i64 %23)
  %arrayidx38 = getelementptr inbounds i8, i8* %call37, i64 0
  %24 = load i8, i8* %arrayidx38, align 1
  %conv39 = zext i8 %24 to i32
  %and40 = and i32 %conv39, 16
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %cond.false.59, label %cond.true.42

cond.true.42:                                     ; preds = %cond.false.36
  %25 = load i64, i64* %string, align 8
  %call43 = call i8* @SDATA(i64 %25)
  %arrayidx44 = getelementptr inbounds i8, i8* %call43, i64 0
  %26 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %26 to i32
  %and46 = and i32 %conv45, 15
  %shl47 = shl i32 %and46, 12
  %27 = load i64, i64* %string, align 8
  %call48 = call i8* @SDATA(i64 %27)
  %arrayidx49 = getelementptr inbounds i8, i8* %call48, i64 1
  %28 = load i8, i8* %arrayidx49, align 1
  %conv50 = zext i8 %28 to i32
  %and51 = and i32 %conv50, 63
  %shl52 = shl i32 %and51, 6
  %or53 = or i32 %shl47, %shl52
  %29 = load i64, i64* %string, align 8
  %call54 = call i8* @SDATA(i64 %29)
  %arrayidx55 = getelementptr inbounds i8, i8* %call54, i64 2
  %30 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %30 to i32
  %and57 = and i32 %conv56, 63
  %or58 = or i32 %or53, %and57
  br label %cond.end

cond.false.59:                                    ; preds = %cond.false.36
  %31 = load i64, i64* %string, align 8
  %call60 = call i8* @SDATA(i64 %31)
  %call61 = call i32 @string_char(i8* %call60, i8** null, i32* null)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.59, %cond.true.42
  %cond62 = phi i32 [ %or58, %cond.true.42 ], [ %call61, %cond.false.59 ]
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.end, %cond.true.22
  %cond64 = phi i32 [ %add, %cond.true.22 ], [ %cond62, %cond.end ]
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.end.63, %cond.true
  %cond66 = phi i32 [ %conv16, %cond.true ], [ %cond64, %cond.end.63 ]
  store i32 %cond66, i32* %c1, align 4
  %32 = load i32, i32* %c1, align 4
  %call67 = call i32 @downcase(i32 %32)
  store i32 %call67, i32* %c2, align 4
  %33 = load i32, i32* %c1, align 4
  %34 = load i32, i32* %c2, align 4
  %cmp68 = icmp ne i32 %33, %34
  br i1 %cmp68, label %if.then.70, label %if.end.75

if.then.70:                                       ; preds = %cond.end.65
  %35 = load i64, i64* %string, align 8
  %36 = load i32, i32* %c2, align 4
  %conv71 = sext i32 %36 to i64
  %shl72 = shl i64 %conv71, 2
  %add73 = add i64 %shl72, 2
  %call74 = call i64 @Faset(i64 %35, i64 2, i64 %add73)
  br label %if.end.75

if.end.75:                                        ; preds = %if.then.70, %cond.end.65
  br label %if.end.76

if.end.76:                                        ; preds = %if.end.75, %if.then.6
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  %37 = load i8, i8* %coredump, align 1
  %tobool77 = trunc i8 %37 to i1
  %cond79 = select i1 %tobool77, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0)
  %call80 = call i64 @strlen(i8* %cond79) #9
  store i64 %call80, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  %38 = load i8, i8* %coredump, align 1
  %tobool81 = trunc i8 %38 to i1
  %cond83 = select i1 %tobool81, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0)
  store i8* %cond83, i8** %data, align 8
  %s84 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %39 = bitcast %struct.Lisp_String* %s84 to i8*
  %call85 = call i64 @make_lisp_ptr(i8* %39, i32 4)
  store i64 %call85, i64* %suffix, align 8
  %40 = load i64, i64* %string, align 8
  %41 = load i64, i64* %suffix, align 8
  %call86 = call i64 @concat2(i64 %40, i64 %41)
  store i64 %call86, i64* %retval
  br label %return

if.else.87:                                       ; preds = %lor.lhs.false
  %42 = load i64, i64* %symbol, align 8
  %call88 = call i64 @builtin_lisp_symbol(i32 387)
  %cmp89 = icmp eq i64 %42, %call88
  br i1 %cmp89, label %if.then.91, label %if.else.135

if.then.91:                                       ; preds = %if.else.87
  %43 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p.addr, align 8
  %type = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %43, i32 0, i32 10
  %44 = load i64, i64* %type, align 8
  %call92 = call i64 @builtin_lisp_symbol(i32 699)
  %cmp93 = icmp eq i64 %44, %call92
  br i1 %cmp93, label %if.then.95, label %if.end.100

if.then.95:                                       ; preds = %if.then.91
  %45 = load i32, i32* %code, align 4
  %cmp96 = icmp eq i32 %45, 0
  %cond98 = select i1 %cmp96, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.103, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.104, i32 0, i32 0)
  %call99 = call i64 @build_string(i8* %cond98)
  store i64 %call99, i64* %retval
  br label %return

if.end.100:                                       ; preds = %if.then.91
  %46 = load i32, i32* %code, align 4
  %cmp101 = icmp eq i32 %46, 0
  br i1 %cmp101, label %if.then.103, label %if.end.105

if.then.103:                                      ; preds = %if.end.100
  %call104 = call i64 @build_string(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.105, i32 0, i32 0))
  store i64 %call104, i64* %retval
  br label %return

if.end.105:                                       ; preds = %if.end.100
  %s107 = bitcast %union.Aligned_String* %.compoundliteral106 to %struct.Lisp_String*
  %size108 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s107, i32 0, i32 0
  store i64 28, i64* %size108, align 8
  %size_byte109 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s107, i32 0, i32 1
  store i64 -1, i64* %size_byte109, align 8
  %intervals110 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s107, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals110, align 8
  %data111 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s107, i32 0, i32 3
  store i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.106, i32 0, i32 0), i8** %data111, align 8
  %s112 = bitcast %union.Aligned_String* %.compoundliteral106 to %struct.Lisp_String*
  %47 = bitcast %struct.Lisp_String* %s112 to i8*
  %call113 = call i64 @make_lisp_ptr(i8* %47, i32 4)
  store i64 %call113, i64* %prefix, align 8
  %48 = load i32, i32* %code, align 4
  %conv114 = sext i32 %48 to i64
  %shl115 = shl i64 %conv114, 2
  %add116 = add i64 %shl115, 2
  %call117 = call i64 @Fnumber_to_string(i64 %add116)
  store i64 %call117, i64* %string, align 8
  %s120 = bitcast %union.Aligned_String* %.compoundliteral119 to %struct.Lisp_String*
  %size121 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s120, i32 0, i32 0
  %49 = load i8, i8* %coredump, align 1
  %tobool122 = trunc i8 %49 to i1
  %cond124 = select i1 %tobool122, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0)
  %call125 = call i64 @strlen(i8* %cond124) #9
  store i64 %call125, i64* %size121, align 8
  %size_byte126 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s120, i32 0, i32 1
  store i64 -1, i64* %size_byte126, align 8
  %intervals127 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s120, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals127, align 8
  %data128 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s120, i32 0, i32 3
  %50 = load i8, i8* %coredump, align 1
  %tobool129 = trunc i8 %50 to i1
  %cond131 = select i1 %tobool129, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0)
  store i8* %cond131, i8** %data128, align 8
  %s132 = bitcast %union.Aligned_String* %.compoundliteral119 to %struct.Lisp_String*
  %51 = bitcast %struct.Lisp_String* %s132 to i8*
  %call133 = call i64 @make_lisp_ptr(i8* %51, i32 4)
  store i64 %call133, i64* %suffix118, align 8
  %52 = load i64, i64* %prefix, align 8
  %53 = load i64, i64* %string, align 8
  %54 = load i64, i64* %suffix118, align 8
  %call134 = call i64 @concat3(i64 %52, i64 %53, i64 %54)
  store i64 %call134, i64* %retval
  br label %return

if.else.135:                                      ; preds = %if.else.87
  %55 = load i64, i64* %symbol, align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 401)
  %cmp137 = icmp eq i64 %55, %call136
  br i1 %cmp137, label %if.then.139, label %if.else.163

if.then.139:                                      ; preds = %if.else.135
  %s142 = bitcast %union.Aligned_String* %.compoundliteral141 to %struct.Lisp_String*
  %size143 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s142, i32 0, i32 0
  store i64 17, i64* %size143, align 8
  %size_byte144 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s142, i32 0, i32 1
  store i64 -1, i64* %size_byte144, align 8
  %intervals145 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s142, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals145, align 8
  %data146 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s142, i32 0, i32 3
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.107, i32 0, i32 0), i8** %data146, align 8
  %s147 = bitcast %union.Aligned_String* %.compoundliteral141 to %struct.Lisp_String*
  %56 = bitcast %struct.Lisp_String* %s147 to i8*
  %call148 = call i64 @make_lisp_ptr(i8* %56, i32 4)
  store i64 %call148, i64* %prefix140, align 8
  %57 = load i32, i32* %code, align 4
  %conv149 = sext i32 %57 to i64
  %shl150 = shl i64 %conv149, 2
  %add151 = add i64 %shl150, 2
  %call152 = call i64 @Fnumber_to_string(i64 %add151)
  store i64 %call152, i64* %string, align 8
  %s155 = bitcast %union.Aligned_String* %.compoundliteral154 to %struct.Lisp_String*
  %size156 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s155, i32 0, i32 0
  store i64 1, i64* %size156, align 8
  %size_byte157 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s155, i32 0, i32 1
  store i64 -1, i64* %size_byte157, align 8
  %intervals158 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s155, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals158, align 8
  %data159 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s155, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.85, i32 0, i32 0), i8** %data159, align 8
  %s160 = bitcast %union.Aligned_String* %.compoundliteral154 to %struct.Lisp_String*
  %58 = bitcast %struct.Lisp_String* %s160 to i8*
  %call161 = call i64 @make_lisp_ptr(i8* %58, i32 4)
  store i64 %call161, i64* %suffix153, align 8
  %59 = load i64, i64* %prefix140, align 8
  %60 = load i64, i64* %string, align 8
  %61 = load i64, i64* %suffix153, align 8
  %call162 = call i64 @concat3(i64 %59, i64 %60, i64 %61)
  store i64 %call162, i64* %retval
  br label %return

if.else.163:                                      ; preds = %if.else.135
  %62 = load i64, i64* %symbol, align 8
  %call164 = call i64 @Fsymbol_name(i64 %62)
  %call165 = call i64 @Fcopy_sequence(i64 %call164)
  store i64 %call165, i64* %retval
  br label %return

return:                                           ; preds = %if.else.163, %if.then.139, %if.end.105, %if.then.103, %if.then.95, %if.end.76
  %63 = load i64, i64* %retval
  ret i64 %63
}

declare void @bset_update_mode_line(%struct.buffer*) #1

; Function Attrs: nounwind uwtable
define internal void @decode_status(i64 %l, i64* %symbol, i32* %code, i8* %coredump) #0 {
entry:
  %l.addr = alloca i64, align 8
  %symbol.addr = alloca i64*, align 8
  %code.addr = alloca i32*, align 8
  %coredump.addr = alloca i8*, align 8
  %tem = alloca i64, align 8
  store i64 %l, i64* %l.addr, align 8
  store i64* %symbol, i64** %symbol.addr, align 8
  store i32* %code, i32** %code.addr, align 8
  store i8* %coredump, i8** %coredump.addr, align 8
  %0 = load i64, i64* %l.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %l.addr, align 8
  %2 = load i64*, i64** %symbol.addr, align 8
  store i64 %1, i64* %2, align 8
  %3 = load i32*, i32** %code.addr, align 8
  store i32 0, i32* %3, align 4
  %4 = load i8*, i8** %coredump.addr, align 8
  store i8 0, i8* %4, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %5 = load i64, i64* %l.addr, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car, align 8
  %9 = load i64*, i64** %symbol.addr, align 8
  store i64 %8, i64* %9, align 8
  %10 = load i64, i64* %l.addr, align 8
  %sub2 = sub nsw i64 %10, 3
  %11 = inttoptr i64 %sub2 to i8*
  %12 = bitcast i8* %11 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %12, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %13 = load i64, i64* %cdr, align 8
  store i64 %13, i64* %tem, align 8
  %14 = load i64, i64* %tem, align 8
  %sub3 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub3 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %car4 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 0
  %17 = load i64, i64* %car4, align 8
  %shr = ashr i64 %17, 2
  %conv5 = trunc i64 %shr to i32
  %18 = load i32*, i32** %code.addr, align 8
  store i32 %conv5, i32* %18, align 4
  %19 = load i64, i64* %tem, align 8
  %sub6 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub6 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr8 = bitcast %union.anon* %u7 to i64*
  %22 = load i64, i64* %cdr8, align 8
  store i64 %22, i64* %tem, align 8
  %23 = load i64, i64* %tem, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %23, %call
  %lnot = xor i1 %cmp9, true
  %24 = load i8*, i8** %coredump.addr, align 8
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %24, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

declare void @synchronize_system_messages_locale() #1

; Function Attrs: nounwind
declare i8* @strsignal(i32) #6

declare i64 @build_unibyte_string(i8*) #1

declare i32 @string_char(i8*, i8**, i32*) #1

declare i32 @downcase(i32) #1

declare i64 @Faset(i64, i64, i64) #1

declare i64 @Fsymbol_name(i64) #1

declare void @deliver_process_signal(i32, void (i32)*) #1

; Function Attrs: nounwind uwtable
define internal void @handle_child_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %tail = alloca i64, align 8
  %proc = alloca i64, align 8
  %all_pids_are_fixnums = alloca i8, align 1
  %head = alloca i64, align 8
  %xpid = alloca i64, align 8
  %deleted_pid = alloca i32, align 4
  %p = alloca %struct.Lisp_Process*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.28, align 4
  %.compoundliteral68 = alloca %union.anon.29, align 4
  %clear_desc_flag = alloca i8, align 1
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load i64, i64* @deleted_pid_list, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i8 1, i8* %all_pids_are_fixnums, align 1
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %head, align 8
  %6 = load i64, i64* %head, align 8
  %and2 = and i64 %6, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %7 = load i64, i64* %head, align 8
  %sub6 = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub6 to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 0
  %10 = load i64, i64* %car7, align 8
  store i64 %10, i64* %xpid, align 8
  %11 = load i8, i8* %all_pids_are_fixnums, align 1
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %12 = load i64, i64* %xpid, align 8
  %and9 = and i64 %12, 7
  %conv10 = trunc i64 %and9 to i32
  %and11 = and i32 %conv10, -5
  %cmp12 = icmp eq i32 %and11, 2
  br i1 %cmp12, label %if.then.15, label %if.end.40

cond.false:                                       ; preds = %if.end
  %13 = load i64, i64* %xpid, align 8
  %call = call zeroext i1 @NUMBERP(i64 %13)
  br i1 %call, label %if.then.15, label %if.end.40

if.then.15:                                       ; preds = %cond.false, %cond.true
  %14 = load i64, i64* %xpid, align 8
  %and16 = and i64 %14, 7
  %conv17 = trunc i64 %and16 to i32
  %and18 = and i32 %conv17, -5
  %cmp19 = icmp eq i32 %and18, 2
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %if.then.15
  %15 = load i64, i64* %xpid, align 8
  %shr = ashr i64 %15, 2
  %conv22 = trunc i64 %shr to i32
  store i32 %conv22, i32* %deleted_pid, align 4
  br label %if.end.25

if.else:                                          ; preds = %if.then.15
  %16 = load i64, i64* %xpid, align 8
  %call23 = call double @XFLOAT_DATA(i64 %16)
  %conv24 = fptosi double %call23 to i32
  store i32 %conv24, i32* %deleted_pid, align 4
  br label %if.end.25

if.end.25:                                        ; preds = %if.else, %if.then.21
  %17 = load i32, i32* %deleted_pid, align 4
  %call26 = call i32 @child_status_changed(i32 %17, i32* null, i32 0)
  %tobool27 = icmp ne i32 %call26, 0
  br i1 %tobool27, label %if.then.28, label %if.end.39

if.then.28:                                       ; preds = %if.end.25
  %18 = load i64, i64* %head, align 8
  %sub29 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub29 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %21 = load i64, i64* %cdr, align 8
  %call30 = call zeroext i1 @STRINGP(i64 %21)
  br i1 %call30, label %if.then.31, label %if.end.37

if.then.31:                                       ; preds = %if.then.28
  %22 = load i64, i64* %head, align 8
  %sub32 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub32 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u33 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr34 = bitcast %union.anon* %u33 to i64*
  %25 = load i64, i64* %cdr34, align 8
  %call35 = call i8* @SSDATA(i64 %25)
  %call36 = call i32 @unlink(i8* %call35) #5
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.31, %if.then.28
  %26 = load i64, i64* %tail, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 0)
  call void @XSETCAR(i64 %26, i64 %call38)
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.37, %if.end.25
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %cond.false, %cond.true
  br label %for.inc

for.inc:                                          ; preds = %if.end.40, %if.then
  %27 = load i64, i64* %tail, align 8
  %sub41 = sub nsw i64 %27, 3
  %28 = inttoptr i64 %sub41 to i8*
  %29 = bitcast i8* %28 to %struct.Lisp_Cons*
  %u42 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %29, i32 0, i32 1
  %cdr43 = bitcast %union.anon* %u42 to i64*
  %30 = load i64, i64* %cdr43, align 8
  store i64 %30, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %31 = load i64, i64* @Vprocess_alist, align 8
  store i64 %31, i64* %tail, align 8
  br label %for.cond.44

for.cond.44:                                      ; preds = %for.inc.89, %for.end
  %32 = load i64, i64* %tail, align 8
  %and45 = and i64 %32, 7
  %conv46 = trunc i64 %and45 to i32
  %cmp47 = icmp eq i32 %conv46, 3
  br i1 %cmp47, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond.44
  %33 = load i64, i64* %tail, align 8
  %sub49 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub49 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %car50 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 0
  %36 = load i64, i64* %car50, align 8
  %sub51 = sub nsw i64 %36, 3
  %37 = inttoptr i64 %sub51 to i8*
  %38 = bitcast i8* %37 to %struct.Lisp_Cons*
  %u52 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %38, i32 0, i32 1
  %cdr53 = bitcast %union.anon* %u52 to i64*
  %39 = load i64, i64* %cdr53, align 8
  store i64 %39, i64* %proc, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.44
  %40 = phi i1 [ false, %for.cond.44 ], [ true, %land.rhs ]
  br i1 %40, label %for.body.54, label %for.end.93

for.body.54:                                      ; preds = %land.end
  %41 = load i64, i64* %proc, align 8
  %call55 = call %struct.Lisp_Process* @XPROCESS(i64 %41)
  store %struct.Lisp_Process* %call55, %struct.Lisp_Process** %p, align 8
  %42 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %alive = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %42, i32 0, i32 28
  %bf.load = load i8, i8* %alive, align 8
  %bf.lshr = lshr i8 %bf.load, 6
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %land.lhs.true, label %if.end.88

land.lhs.true:                                    ; preds = %for.body.54
  %43 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %pid = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %43, i32 0, i32 20
  %44 = load i32, i32* %pid, align 4
  %call57 = call i32 @child_status_changed(i32 %44, i32* %status, i32 10)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then.59, label %if.end.88

if.then.59:                                       ; preds = %land.lhs.true
  %45 = load i64, i64* @process_tick, align 8
  %inc = add nsw i64 %45, 1
  store i64 %inc, i64* @process_tick, align 8
  %46 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %tick = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %46, i32 0, i32 24
  store i64 %inc, i64* %tick, align 8
  %47 = load i32, i32* %status, align 4
  %48 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %48, i32 0, i32 29
  store i32 %47, i32* %raw_status, align 4
  %49 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %raw_status_new = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %49, i32 0, i32 28
  %bf.load60 = load i8, i8* %raw_status_new, align 8
  %bf.clear61 = and i8 %bf.load60, 127
  %bf.set = or i8 %bf.clear61, -128
  store i8 %bf.set, i8* %raw_status_new, align 8
  %__in = bitcast %union.anon.28* %.compoundliteral to i32*
  %50 = load i32, i32* %status, align 4
  store i32 %50, i32* %__in, align 4
  %__i = bitcast %union.anon.28* %.compoundliteral to i32*
  %51 = load i32, i32* %__i, align 4
  %and62 = and i32 %51, 127
  %add = add nsw i32 %and62, 1
  %conv63 = trunc i32 %add to i8
  %conv64 = sext i8 %conv63 to i32
  %shr65 = ashr i32 %conv64, 1
  %cmp66 = icmp sgt i32 %shr65, 0
  br i1 %cmp66, label %if.then.74, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.59
  %__in69 = bitcast %union.anon.29* %.compoundliteral68 to i32*
  %52 = load i32, i32* %status, align 4
  store i32 %52, i32* %__in69, align 4
  %__i70 = bitcast %union.anon.29* %.compoundliteral68 to i32*
  %53 = load i32, i32* %__i70, align 4
  %and71 = and i32 %53, 127
  %cmp72 = icmp eq i32 %and71, 0
  br i1 %cmp72, label %if.then.74, label %if.end.87

if.then.74:                                       ; preds = %lor.lhs.false, %if.then.59
  store i8 0, i8* %clear_desc_flag, align 1
  %54 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %alive75 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %54, i32 0, i32 28
  %bf.load76 = load i8, i8* %alive75, align 8
  %bf.clear77 = and i8 %bf.load76, -65
  store i8 %bf.clear77, i8* %alive75, align 8
  %55 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %55, i32 0, i32 21
  %56 = load i32, i32* %infd, align 4
  %cmp78 = icmp sge i32 %56, 0
  br i1 %cmp78, label %if.then.80, label %if.end.81

if.then.80:                                       ; preds = %if.then.74
  store i8 1, i8* %clear_desc_flag, align 1
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.80, %if.then.74
  %57 = load i8, i8* %clear_desc_flag, align 1
  %tobool82 = trunc i8 %57 to i1
  br i1 %tobool82, label %if.then.83, label %if.end.86

if.then.83:                                       ; preds = %if.end.81
  %58 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd84 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %58, i32 0, i32 21
  %59 = load i32, i32* %infd84, align 4
  call void @fd_CLR(i32 %59, %struct.fd_set* @input_wait_mask)
  %60 = load %struct.Lisp_Process*, %struct.Lisp_Process** %p, align 8
  %infd85 = getelementptr inbounds %struct.Lisp_Process, %struct.Lisp_Process* %60, i32 0, i32 21
  %61 = load i32, i32* %infd85, align 4
  call void @fd_CLR(i32 %61, %struct.fd_set* @non_keyboard_wait_mask)
  br label %if.end.86

if.end.86:                                        ; preds = %if.then.83, %if.end.81
  br label %if.end.87

if.end.87:                                        ; preds = %if.end.86, %lor.lhs.false
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %land.lhs.true, %for.body.54
  br label %for.inc.89

for.inc.89:                                       ; preds = %if.end.88
  %62 = load i64, i64* %tail, align 8
  %sub90 = sub nsw i64 %62, 3
  %63 = inttoptr i64 %sub90 to i8*
  %64 = bitcast i8* %63 to %struct.Lisp_Cons*
  %u91 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %64, i32 0, i32 1
  %cdr92 = bitcast %union.anon* %u91 to i64*
  %65 = load i64, i64* %cdr92, align 8
  store i64 %65, i64* %tail, align 8
  br label %for.cond.44

for.end.93:                                       ; preds = %land.end
  %66 = load volatile void (i32)*, void (i32)** @lib_child_handler, align 8
  %67 = load i32, i32* %sig.addr, align 4
  call void %66(i32 %67)
  ret void
}

declare i32 @child_status_changed(i32, i32*, i32) #1

; Function Attrs: nounwind
declare i32 @unlink(i8*) #6

declare void @XSETCAR(i64, i64) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind returns_twice "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn }
attributes #9 = { nounwind readonly }
attributes #10 = { nounwind returns_twice }
attributes #11 = { nounwind readnone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{i32 2778988}
!2 = !{i32 2810209}
!3 = !{i32 2810418}
!4 = !{i32 2814032}
!5 = !{i32 2816861}
!6 = !{i32 2819157}
!7 = !{i32 2823895}
!8 = !{i32 2882552}
!9 = !{i32 2882767}
!10 = !{i32 2882989}
!11 = !{i32 2883210}
!12 = !{i32 2883523}
