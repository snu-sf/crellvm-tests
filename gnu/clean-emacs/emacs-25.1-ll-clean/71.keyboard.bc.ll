; ModuleID = './src/keyboard.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.kboard = type { %struct.kboard*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64*, i64*, i64*, i64, i64, i64, i64, i64, i64, i64, i64, i32, i64, i8, i8, i64 }
%struct.emacs_globals = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.buffer = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.buffer_text, %struct.buffer_text*, %struct.buffer*, i64, i64, i64, i64, i64, i64, %struct.buffer*, i32, i32, [50 x i8], %struct.timespec, i64, i64, i64, i64, i64, %struct.region_cache*, %struct.region_cache*, %struct.region_cache*, i8, %struct.Lisp_Overlay*, %struct.Lisp_Overlay*, i64, i64 }
%struct.vectorlike_header = type { i64 }
%struct.buffer_text = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.interval*, %struct.Lisp_Marker*, i8 }
%struct.interval = type { i64, i64, %struct.interval*, %struct.interval*, %union.anon, i8, i64 }
%union.anon = type { %struct.interval* }
%struct.Lisp_Marker = type { i32, %struct.buffer*, %struct.Lisp_Marker*, i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.region_cache = type opaque
%struct.Lisp_Overlay = type { i32, %struct.Lisp_Overlay*, i64, i64, i64 }
%struct.kboard_stack = type { %struct.kboard*, %struct.kboard_stack* }
%struct.terminal = type { %struct.vectorlike_header, i64, i64, i64, i64, %struct.terminal*, i32, i32, i32, i8*, %struct.kboard*, %struct.image_cache*, %union.display_info, %struct.coding_system*, %struct.coding_system*, %struct.redisplay_interface*, void (%struct.frame*, i32, i32)*, void (%struct.frame*, i32, i32)*, {}*, {}*, void (%struct.frame*, i32)*, void (%struct.frame*, i32, i32)*, void (%struct.frame*, %struct.glyph*, i32)*, void (%struct.frame*, %struct.glyph*, i32)*, void (%struct.frame*, i32)*, {}*, void (%struct.frame*, i1)*, void (%struct.terminal*)*, void (%struct.terminal*)*, {}*, {}*, void (%struct.frame*, i32)*, void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)*, {}*, void (%struct.frame*, i1)*, {}*, i64 (%struct.frame*, i32, i32, i32, i64, i8**)*, i64 (%struct.frame*, i64, i64)*, void (%struct.window*, i32, i32, i32)*, void (%struct.window*, i32, i32, i32)*, {}*, void (%struct.window*)*, {}*, i32 (%struct.terminal*, %struct.input_event*)*, {}*, {}*, void (%struct.terminal*)* }
%struct.image_cache = type { %struct.image**, %struct.image**, i64, i64, i64 }
%struct.image = type { %struct.timespec, i64, i64, %struct._XImage*, %struct._XImage*, i64*, i32, i64, i64, i64, i8, i32, i32, [4 x i32], i32, i64, i64, i32, i32, i32, %struct.image_type*, i8, i64, i64, i64, %struct.image*, %struct.image* }
%struct._XImage = type { i32, i32, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i32, i64, i64, i64, i8*, %struct.funcs }
%struct.funcs = type { %struct._XImage* (%struct._XDisplay*, %struct.Visual*, i32, i32, i32, i8*, i32, i32, i32, i32)*, i32 (%struct._XImage*)*, i64 (%struct._XImage*, i32, i32)*, i32 (%struct._XImage*, i32, i32, i64)*, %struct._XImage* (%struct._XImage*, i32, i32, i32, i32)*, i32 (%struct._XImage*, i64)* }
%struct._XDisplay = type opaque
%struct.Visual = type { %struct._XExtData*, i64, i32, i64, i64, i64, i32, i32 }
%struct._XExtData = type { i32, %struct._XExtData*, i32 (%struct._XExtData*)*, i8* }
%struct.image_type = type { i32, i1 (i64)*, i1 (%struct.frame*, %struct.image*)*, void (%struct.frame*, %struct.image*)*, i1 ()*, %struct.image_type* }
%struct.frame = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.face_cache*, i32, %struct.glyph_pool*, %struct.glyph_pool*, %struct.glyph_matrix*, %struct.glyph_matrix*, i48, i32, i32, i32, i32, i8*, i32*, i32*, i32*, i32*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.terminal*, %union.output_data, %struct.font_driver_list*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, [2 x double], double, i32, i64, i64 }
%struct.face_cache = type { %struct.face**, %struct.frame*, %struct.face**, i64, i32, i8 }
%struct.face = type { [19 x i64], i32, %struct._XGC*, i64, i64, i64, i64, i64, i64, i64, %struct.font*, i32, i32, i24, i32, %struct.face*, %struct.face*, %struct.face*, i8* }
%struct._XGC = type opaque
%struct.font = type { %struct.vectorlike_header, [17 x i64], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, i32, i32, i32, i32, i32, %struct.font_driver* }
%struct.font_driver = type { i64, i8, i64 (%struct.frame*)*, i64 (%struct.frame*, i64)*, i64 (%struct.frame*, i64)*, i64 (%struct.frame*)*, void (i64)*, i64 (%struct.frame*, i64, i32)*, void (%struct.font*)*, void (%struct.frame*, %struct.face*)*, void (%struct.frame*, %struct.face*)*, i32 (i64, i32)*, i32 (%struct.font*, i32)*, void (%struct.font*, i32*, i32, %struct.font_metrics*)*, i32 (%struct.glyph_string*, i32, i32, i32, i32, i1)*, i32 (%struct.font*, i32, %struct.font_bitmap*, i32)*, void (%struct.font*, %struct.font_bitmap*)*, i32 (%struct.font*, i32, i32, i32*, i32*)*, i64 (%struct.font*)*, i32 (%struct.font*, i64, i64, i32, i32, i64, i32, i1)*, i32 (%struct.frame*)*, i32 (%struct.frame*)*, i64 (i64)*, i32 (%struct.frame*, %struct.font*)*, i32 (%struct.font*, i32, i32*)*, void (i64, i64)*, i1 (%struct.frame*, i64, i64)*, i64 (%struct.font*)* }
%struct.font_metrics = type { i16, i16, i16, i16, i16 }
%struct.glyph_string = type { i32, i32, i32, i32, i32, i32, i32, i32, %struct.frame*, %struct.window*, %struct._XDisplay*, i64, %struct.glyph_row*, i32, %struct.XChar2b*, i32, i32, %struct.face*, %struct.font*, %struct.composition*, i64, i32, i32, i8, %struct._XGC*, %struct.glyph*, %struct.image*, %struct.xwidget*, %struct.glyph_slice, %struct.glyph_string*, %struct.glyph_string*, [2 x %struct.XRectangle], i32, i32, i32, %struct.glyph_string*, %struct.glyph_string* }
%struct.window = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.glyph_matrix*, %struct.glyph_matrix*, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.cursor_pos, %struct.cursor_pos, %struct.cursor_pos, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i16, i32, i64 }
%struct.cursor_pos = type { i32, i32, i32, i32 }
%struct.glyph_row = type <{ [4 x %struct.glyph*], [4 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.display_pos, %struct.display_pos, %struct.text_pos, %struct.text_pos, i32, [11 x i8], i8, i24, i24, i32, i40, i32, %struct.XRectangle* }>
%struct.display_pos = type { %struct.text_pos, i64, %struct.text_pos, i32 }
%struct.text_pos = type { i64, i64 }
%struct.XRectangle = type { i16, i16, i16, i16 }
%struct.XChar2b = type { i8, i8 }
%struct.composition = type { i32, i16, i16, i16, i16, i16, i32, i32, i64, i8*, i16* }
%struct.glyph = type { i64, i64, i16, i16, i16, i16, i24, i24, %union.anon.0, %union.anon.2 }
%union.anon.0 = type { %struct.glyph_slice }
%union.anon.2 = type { i32 }
%struct.xwidget = type opaque
%struct.glyph_slice = type { i64 }
%struct.font_bitmap = type { i32, i32, i32, i32, i8*, i32, i32, i32 }
%struct.glyph_pool = type { %struct.glyph*, i64, i32, i32 }
%struct.glyph_matrix = type { %struct.glyph_pool*, %struct.glyph_row*, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, %struct.buffer*, i64, i64 }
%union.output_data = type { %struct.tty_output* }
%struct.tty_output = type { %struct.tty_display_info* }
%struct.tty_display_info = type { %struct.tty_display_info*, i8*, i8*, %struct._IO_FILE*, %struct._IO_FILE*, %struct._IO_FILE*, %struct.emacs_tty*, i8, i32, %struct.terminal*, %struct.cm*, i64, %struct.frame*, i32, %struct.Mouse_HLInfo, [4096 x i8], [4096 x i8], i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i32, i32, i32, i8*, i8*, i8*, i32, i32, i32, i32, i32, i32, i8, i32, i32, i8, i32 }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.emacs_tty = type opaque
%struct.cm = type opaque
%struct.Mouse_HLInfo = type { i32, i32, i32, i32, i32, i32, i64, i32, i64, %struct.frame*, i32, i32, i8 }
%struct.font_driver_list = type { i8, %struct.font_driver*, %struct.font_driver_list* }
%union.display_info = type { %struct.tty_display_info* }
%struct.coding_system = type { i64, i32, i32, %union.anon.6, i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8*, i64, i64, i64, i64, i8*, i32*, i32, i32, [64 x i8], i32, i32, i1 (%struct.coding_system*, %struct.coding_detection_info*)*, void (%struct.coding_system*)*, i1 (%struct.coding_system*)* }
%union.anon.6 = type { %struct.ccl_spec*, [328 x i8] }
%struct.ccl_spec = type opaque
%struct.coding_detection_info = type { i32, i32, i32 }
%struct.redisplay_interface = type { void (%struct.frame*, i64, i64)**, void (%struct.it*)*, void (%struct.window*, %struct.glyph_row*, %struct.glyph*, i32, i32)*, void (%struct.window*, %struct.glyph_row*, %struct.glyph*, i32, i32)*, void (%struct.window*, %struct.glyph_row*, i32, i32)*, void (%struct.window*, %struct.run*)*, void (%struct.window*, %struct.glyph_row*)*, void (%struct.window*)*, void (%struct.window*, i1, i1)*, {}*, void (%struct.window*)*, void (%struct.glyph*, %struct.frame*, i32*, i32*)*, void (%struct.window*, %struct.glyph_row*, i32, i32)*, void (%struct.window*, %struct.glyph_row*, %struct.draw_fringe_bitmap_params*)*, void (i32, i16*, i32, i32)*, void (i32)*, void (%struct.glyph_string*)*, void (%struct.glyph_string*)*, void (%struct.frame*, i64)*, void (%struct.frame*, i32, i32, i32, i32)*, void (%struct.window*, %struct.glyph_row*, i32, i32, i32, i32, i1, i1)*, void (%struct.window*, i32, i32, i32)*, void (%struct.window*, i32, i32, i32, i32)*, void (%struct.frame*, i32, i32, i32, i32, i32)*, {}*, {}* }
%struct.it = type { i64, %struct.window*, %struct.frame*, i32, i64, i64, i64, i64, i8*, i64, i64, i8, %struct.Lisp_Char_Table*, i64*, i64*, i32, i32, i32, [16 x i64], %struct.display_pos, %struct.display_pos, i64, i64, [16 x i64], [16 x i64], i64, i64, [5 x %struct.iterator_stack_entry], i32, i64, i32, i32, i16, i32, i32, i32, i32, %struct.composition_it, i32, i32, i64, %struct.xwidget*, %struct.it_slice, i64, i16, i16, i64, i64, %struct.text_pos, i16, i16, i32, i32, i32, i32, i32, i32, i32, i32, %struct.glyph_row*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.text_pos, i32, i32, i32, i32, i56, i24, %struct.bidi_it, i32 }
%struct.Lisp_Char_Table = type { %struct.vectorlike_header, i64, i64, i64, i64, [64 x i64], [0 x i64] }
%struct.iterator_stack_entry = type { i64, i32, i64, i64, i64, i64, %struct.composition_it, i32, %union.anon.7, %struct.text_pos, %struct.display_pos, i64, i32, i32, i32, i8, i32, i16, i64, i64 }
%union.anon.7 = type { %struct.anon.8 }
%struct.anon.8 = type { i64, %struct.it_slice, i64 }
%struct.composition_it = type { i64, i64, i32, i32, i64, i32, i8, i64, i32, i32, i32, i32, i32 }
%struct.it_slice = type { i64, i64, i64, i64 }
%struct.bidi_it = type { i64, i64, i32, i64, i64, i32, i32, i32, i8, i8, i64, i64, %struct.bidi_saved_info, %struct.bidi_saved_info, %struct.bidi_saved_info, %struct.bidi_saved_info, %struct.bidi_saved_info, i64, i32, i64, i32, i32, i32, i64, i32, i32, [128 x %struct.bidi_stack], %struct.bidi_string_data, %struct.window*, i32, i64, i8 }
%struct.bidi_saved_info = type { i64, i32, i32 }
%struct.bidi_stack = type { i64, i16, i8, i8 }
%struct.bidi_string_data = type { i64, i8*, i64, i64, i8 }
%struct.run = type { i32, i32, i32, i32, i32, i32 }
%struct.draw_fringe_bitmap_params = type { i32, i16*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, %struct.face* }
%struct.input_event = type { i32, i32, i32, i64, i64, i64, i64, i64 }
%struct.atimer = type { i32, %struct.timespec, %struct.timespec, void (%struct.atimer*)*, i8*, %struct.atimer* }
%struct.__sigset_t = type { [16 x i64] }
%union.buffered_input_event = type { %struct.input_event }
%struct.user_signal_info = type { i32, i8*, i32, %struct.user_signal_info* }
%struct.Lisp_Symbol = type { i16, i64, %union.anon.22, i64, i64, %struct.Lisp_Symbol* }
%union.anon.22 = type { i64 }
%struct.x_display_info = type { %struct.x_display_info*, %struct.terminal*, %struct._XDisplay*, i32, i64, i32, %struct.Screen*, double, double, %struct.Visual*, i64, i32, i32, i64, i64, i64, i64, i64, i64, void (%struct.frame*, i1)*, %struct._GdkCursor*, %struct._XrmHashBucketRec*, i32, i32, %struct._XGC*, %struct.Mouse_HLInfo, i32, i8*, i32, %struct.x_bitmap_record*, i64, i64, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.frame*, %struct.frame*, %struct.frame*, %struct.frame*, %struct.frame*, %struct.frame*, %struct.frame*, %struct.scroll_bar*, i64, i32, i32, %struct.XRectangle, i64, i64, %struct._XIM*, %struct.XIMStyles*, %struct.xim_inst_t*, %struct.color_name_cache_entry*, %struct.XColor*, i32, i32, i32, i32, i32, i32, i32, i32, i64*, i64, i64, i64, i64, i64*, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.xcb_connection_t* }
%struct.Screen = type { %struct._XExtData*, %struct._XDisplay*, i64, i32, i32, i32, i32, i32, %struct.Depth*, i32, %struct.Visual*, %struct._XGC*, i64, i64, i64, i32, i32, i32, i32, i64 }
%struct.Depth = type { i32, i32, %struct.Visual* }
%struct._GdkCursor = type { i32, i32 }
%struct._XrmHashBucketRec = type opaque
%struct.x_bitmap_record = type { i64, i8, i64, i8*, i32, i32, i32, i32 }
%struct.scroll_bar = type { %struct.vectorlike_header, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i8 }
%struct._XIM = type opaque
%struct.XIMStyles = type { i16, i64* }
%struct.xim_inst_t = type { %struct.x_display_info*, i8* }
%struct.color_name_cache_entry = type { %struct.color_name_cache_entry*, %struct.XColor, i8* }
%struct.XColor = type { i64, i16, i16, i16, i8, i8 }
%struct.xcb_connection_t = type opaque
%struct.Lisp_Objfwd = type { i32, i64* }
%struct.event_head = type { i16, i16 }
%struct.Lisp_Subr = type { %struct.vectorlike_header, %union.anon.23, i16, i16, i8*, i8*, i8* }
%union.anon.23 = type { i64 ()* }
%struct.Lisp_Kboard_Objfwd = type { i32, i32 }
%struct.Lisp_Intfwd = type { i32, i64* }
%struct.Lisp_Boolfwd = type { i32, i8* }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.gl_state_s = type { i64, i64, i64, i8, i64, i64, i64, i64, i64, i8, %struct.interval*, %struct.interval*, i64 }
%struct.Lisp_Cons = type { i64, %union.anon.12 }
%union.anon.12 = type { i64 }
%struct.keyremap = type { i64, i64, i32, i32 }
%union.Aligned_String = type { %struct.Lisp_String }
%struct.Lisp_String = type { i64, i64, %struct.interval*, i8* }
%struct.selection_input_event = type { i16, %struct.x_display_info*, i64, i64, i64, i64, i64 }
%struct.sigaction = type { %union.anon.13, %struct.__sigset_t, i32, void ()* }
%union.anon.13 = type { void (i32)* }
%struct.Lisp_Vector = type { %struct.vectorlike_header, [0 x i64] }
%struct.Lisp_Process = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, i32, [6 x i32], i64, i64, i32, i32, i8, i32, i32, %struct.gnutls_session_int*, %struct.gnutls_certificate_credentials_st*, %struct.gnutls_anon_client_credentials_st*, %struct.gnutls_x509_crt_int*, i32, i32, i32, i32, i8 }
%struct.gnutls_session_int = type opaque
%struct.gnutls_certificate_credentials_st = type opaque
%struct.gnutls_anon_client_credentials_st = type opaque
%struct.gnutls_x509_crt_int = type opaque
%struct.lisp_time = type { i64, i32, i32, i32 }

@current_kboard = common global %struct.kboard* null, align 8
@ok_to_echo_at_next_pause = internal global %struct.kboard* null, align 8
@echo_kboard = common global %struct.kboard* null, align 8
@echo_message_buffer = common global i64 0, align 8
@command_loop_level = common global i64 0, align 8
@redisplaying_p = external global i8, align 1
@globals = external global %struct.emacs_globals, align 8
@last_auto_save = internal global i64 0, align 8
@current_buffer = external global %struct.buffer*, align 8
@selected_window = external global i64, align 8
@update_mode_lines = external global i32, align 4
@selected_frame = external global i64, align 8
@single_kboard = internal global i8 0, align 1
@kboard_stack = internal global %struct.kboard_stack* null, align 8
@terminal_list = external global %struct.terminal*, align 8
@.str = private unnamed_addr constant [43 x i8] c"Terminal %d is locked, cannot read from it\00", align 1
@Vsignaling_function = external global i64, align 8
@empty_unibyte_string = external global i64, align 8
@daemon_pipe = external global [2 x i32], align 4
@noninteractive = external global i8, align 1
@minibuf_level = external global i64, align 8
@.str.1 = private unnamed_addr constant [33 x i8] c"No recursive edit is in progress\00", align 1
@waiting_for_input = common global i8 0, align 1
@this_command_key_count = common global i64 0, align 8
@this_single_command_key_start = internal global i64 0, align 8
@Vrun_hooks = external global i64, align 8
@echo_area_buffer = external global [2 x i64], align 16
@pending_malloc_warning = external global i8*, align 8
@ignore_mouse_drag_p = common global i8 0, align 1
@minibuf_window = external global i64, align 8
@echo_area_window = external global i64, align 8
@quit_char = common global i32 0, align 4
@read_key_sequence_cmd = internal global i64 0, align 8
@pending_signals = common global i8 0, align 1
@last_point_position = internal global i64 0, align 8
@read_key_sequence_remapped = internal global i64 0, align 8
@total_keys = internal global i32 0, align 4
@recent_keys = internal global i64 0, align 8
@recent_keys_index = internal global i32 0, align 4
@point_before_last_command_or_undo = common global i64 0, align 8
@buffer_before_last_command_or_undo = common global %struct.buffer* null, align 8
@.str.2 = private unnamed_addr constant [19 x i8] c"activate-mark-hook\00", align 1
@windows_or_buffers_changed = external global i32, align 4
@interrupt_input = common global i8 0, align 1
@poll_timer = internal global %struct.atimer* null, align 8
@poll_suppress_count = common global i32 0, align 4
@help_echo_showing_p = external global i8, align 1
@internal_last_event_frame = common global i64 0, align 8
@unread_switch_frame = common global i64 0, align 8
@input_pending = common global i8 0, align 1
@input_was_pending = internal global i8 0, align 1
@empty_mask = external global %struct.__sigset_t, align 8
@last_non_minibuf_size = internal global i64 0, align 8
@all_kboards = internal global %struct.kboard* null, align 8
@this_command_keys = common global i64 0, align 8
@.str.3 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@num_input_events = common global i64 0, align 8
@help_form_saved_window_configs = internal global i64 0, align 8
@kbd_fetch_ptr = internal global %union.buffered_input_event* null, align 8
@kbd_store_ptr = internal global %union.buffered_input_event* null, align 8
@kbd_buffer = internal global [4096 x %union.buffered_input_event] zeroinitializer, align 16
@stop_character = common global i32 0, align 4
@immediate_quit = common global i8 0, align 1
@timers_run = common global i32 0, align 4
@timer_idleness_start_time = internal global %struct.timespec zeroinitializer, align 8
@.str.4 = private unnamed_addr constant [29 x i8] c"Two bases given in one event\00", align 1
@.str.5 = private unnamed_addr constant [19 x i8] c"Invalid base event\00", align 1
@.str.6 = private unnamed_addr constant [4 x i8] c"alt\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"ctrl\00", align 1
@.str.8 = private unnamed_addr constant [8 x i8] c"control\00", align 1
@.str.9 = private unnamed_addr constant [6 x i8] c"hyper\00", align 1
@.str.10 = private unnamed_addr constant [5 x i8] c"meta\00", align 1
@.str.11 = private unnamed_addr constant [6 x i8] c"shift\00", align 1
@.str.12 = private unnamed_addr constant [6 x i8] c"super\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"drag\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"down\00", align 1
@.str.15 = private unnamed_addr constant [7 x i8] c"double\00", align 1
@.str.16 = private unnamed_addr constant [7 x i8] c"triple\00", align 1
@.str.17 = private unnamed_addr constant [3 x i8] c"up\00", align 1
@Vframe_list = external global i64, align 8
@interrupt_input_blocked = common global i32 0, align 4
@fatal_error_in_progress = external global i8, align 1
@input_available_clear_time = common global %struct.timespec* null, align 8
@user_signals = internal global %struct.user_signal_info* null, align 8
@.str.18 = private unnamed_addr constant [3 x i8] c"--\00", align 1
@separator_names = internal global [15 x i8*] [i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.363, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.364, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.365, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.366, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.367, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.368, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.369, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.370, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.371, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.372, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.373, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.374, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.375, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.376, i32 0, i32 0), i8* null], align 16
@menu_bar_items_vector = internal global i64 0, align 8
@menu_bar_items_index = internal global i32 0, align 4
@current_global_map = external global i64, align 8
@menu_bar_one_keymap_changed_items = internal global i64 0, align 8
@item_properties = common global i64 0, align 8
@.str.19 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@lispsym = external global [1074 x %struct.Lisp_Symbol], align 8
@ntool_bar_items = internal global i32 0, align 4
@tool_bar_items_vector = internal global i64 0, align 8
@raw_keybuf_count = internal global i32 0, align 4
@raw_keybuf = internal global i64 0, align 8
@dribble = internal global %struct._IO_FILE* null, align 8
@.str.20 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.21 = private unnamed_addr constant [16 x i8] c"Opening dribble\00", align 1
@tty_list = external global %struct.tty_display_info*, align 8
@.str.22 = private unnamed_addr constant [68 x i8] c"There are other tty frames open; close them before suspending Emacs\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"suspend-hook\00", align 1
@.str.24 = private unnamed_addr constant [20 x i8] c"suspend-resume-hook\00", align 1
@x_display_list = external global %struct.x_display_info*, align 8
@.str.25 = private unnamed_addr constant [9 x i8] c"/dev/tty\00", align 1
@.str.26 = private unnamed_addr constant [32 x i8] c"QUIT must be an ASCII character\00", align 1
@initial_kboard = common global %struct.kboard* null, align 8
@keyboard_init_hook = internal global void ()* null, align 8
@pending_funcalls = common global i64 0, align 8
@.str.27 = private unnamed_addr constant [6 x i8] c"mouse\00", align 1
@Vlispy_mouse_stem = internal global i64 0, align 8
@.str.28 = private unnamed_addr constant [18 x i8] c"Back to top level\00", align 1
@regular_top_level_message = internal global i64 0, align 8
@.str.29 = private unnamed_addr constant [45 x i8] c"Re-entering top level after C stack overflow\00", align 1
@recover_top_level_message = internal global i64 0, align 8
@syms_of_keyboard.o_fwd = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.30 = private unnamed_addr constant [28 x i8] c"internal--top-level-message\00", align 1
@tool_bar_item_properties = internal global i64 0, align 8
@head_table = internal constant [9 x %struct.event_head] [%struct.event_head { i16 690, i16 690 }, %struct.event_head { i16 834, i16 690 }, %struct.event_head { i16 895, i16 895 }, %struct.event_head { i16 437, i16 437 }, %struct.event_head { i16 438, i16 438 }, %struct.event_head { i16 334, i16 334 }, %struct.event_head { i16 533, i16 533 }, %struct.event_head { i16 640, i16 640 }, %struct.event_head { i16 840, i16 895 }], align 16
@button_down_location = internal global i64 0, align 8
@mouse_syms = internal global i64 0, align 8
@wheel_syms = internal global i64 0, align 8
@modifier_symbols = internal global i64 0, align 8
@modifier_names = internal constant [28 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.395, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.16, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i32 0, i32 0)], align 16
@accent_key_syms = internal global i64 0, align 8
@func_key_syms = internal global i64 0, align 8
@drag_n_drop_syms = internal global i64 0, align 8
@Scurrent_idle_time = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fcurrent_idle_time }, i16 0, i16 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.396, i32 0, i32 0), i8* null, i8* null }, align 8
@Srecursive_edit = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Frecursive_edit }, i16 0, i16 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.401, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8* null }, align 8
@Sthis_command_keys = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fthis_command_keys }, i16 0, i16 0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.405, i32 0, i32 0), i8* null, i8* null }, align 8
@Sthis_command_keys_vector = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fthis_command_keys_vector }, i16 0, i16 0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.406, i32 0, i32 0), i8* null, i8* null }, align 8
@Sthis_single_command_keys = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fthis_single_command_keys }, i16 0, i16 0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.407, i32 0, i32 0), i8* null, i8* null }, align 8
@Sthis_single_command_raw_keys = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fthis_single_command_raw_keys }, i16 0, i16 0, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.408, i32 0, i32 0), i8* null, i8* null }, align 8
@Sabort_recursive_edit = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fabort_recursive_edit }, i16 0, i16 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.168, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8* null }, align 8
@Sexit_recursive_edit = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fexit_recursive_edit }, i16 0, i16 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.167, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8* null }, align 8
@Srecursion_depth = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Frecursion_depth }, i16 0, i16 0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.410, i32 0, i32 0), i8* null, i8* null }, align 8
@Stop_level = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Ftop_level }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8* null }, align 8
@Sdiscard_input = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fdiscard_input }, i16 0, i16 0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.411, i32 0, i32 0), i8* null, i8* null }, align 8
@Scurrent_input_mode = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.23 { i64 ()* @Fcurrent_input_mode }, i16 0, i16 0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.419, i32 0, i32 0), i8* null, i8* null }, align 8
@syms_of_keyboard.o_fwd.31 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.32 = private unnamed_addr constant [19 x i8] c"last-command-event\00", align 1
@syms_of_keyboard.o_fwd.33 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.34 = private unnamed_addr constant [19 x i8] c"last-nonmenu-event\00", align 1
@syms_of_keyboard.o_fwd.35 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.36 = private unnamed_addr constant [17 x i8] c"last-input-event\00", align 1
@syms_of_keyboard.o_fwd.37 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.38 = private unnamed_addr constant [22 x i8] c"unread-command-events\00", align 1
@syms_of_keyboard.o_fwd.39 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.40 = private unnamed_addr constant [32 x i8] c"unread-post-input-method-events\00", align 1
@syms_of_keyboard.o_fwd.41 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.42 = private unnamed_addr constant [27 x i8] c"unread-input-method-events\00", align 1
@syms_of_keyboard.o_fwd.43 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.44 = private unnamed_addr constant [17 x i8] c"meta-prefix-char\00", align 1
@syms_of_keyboard.ko_fwd = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.45 = private unnamed_addr constant [13 x i8] c"last-command\00", align 1
@syms_of_keyboard.ko_fwd.46 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.47 = private unnamed_addr constant [18 x i8] c"real-last-command\00", align 1
@syms_of_keyboard.ko_fwd.48 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.49 = private unnamed_addr constant [24 x i8] c"last-repeatable-command\00", align 1
@syms_of_keyboard.o_fwd.50 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.51 = private unnamed_addr constant [13 x i8] c"this-command\00", align 1
@syms_of_keyboard.o_fwd.52 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.53 = private unnamed_addr constant [18 x i8] c"real-this-command\00", align 1
@syms_of_keyboard.o_fwd.54 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.55 = private unnamed_addr constant [35 x i8] c"this-command-keys-shift-translated\00", align 1
@syms_of_keyboard.o_fwd.56 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.57 = private unnamed_addr constant [22 x i8] c"this-original-command\00", align 1
@syms_of_keyboard.i_fwd = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.58 = private unnamed_addr constant [19 x i8] c"auto-save-interval\00", align 1
@syms_of_keyboard.o_fwd.59 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.60 = private unnamed_addr constant [18 x i8] c"auto-save-timeout\00", align 1
@syms_of_keyboard.o_fwd.61 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.62 = private unnamed_addr constant [16 x i8] c"echo-keystrokes\00", align 1
@syms_of_keyboard.i_fwd.63 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.64 = private unnamed_addr constant [15 x i8] c"polling-period\00", align 1
@syms_of_keyboard.o_fwd.65 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.66 = private unnamed_addr constant [18 x i8] c"double-click-time\00", align 1
@syms_of_keyboard.i_fwd.67 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.68 = private unnamed_addr constant [18 x i8] c"double-click-fuzz\00", align 1
@syms_of_keyboard.i_fwd.69 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.70 = private unnamed_addr constant [15 x i8] c"num-input-keys\00", align 1
@syms_of_keyboard.i_fwd.71 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.72 = private unnamed_addr constant [26 x i8] c"num-nonmacro-input-events\00", align 1
@syms_of_keyboard.o_fwd.73 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.74 = private unnamed_addr constant [17 x i8] c"last-event-frame\00", align 1
@syms_of_keyboard.o_fwd.75 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.76 = private unnamed_addr constant [15 x i8] c"tty-erase-char\00", align 1
@syms_of_keyboard.o_fwd.77 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.78 = private unnamed_addr constant [10 x i8] c"help-char\00", align 1
@syms_of_keyboard.o_fwd.79 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.80 = private unnamed_addr constant [16 x i8] c"help-event-list\00", align 1
@syms_of_keyboard.o_fwd.81 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.82 = private unnamed_addr constant [10 x i8] c"help-form\00", align 1
@syms_of_keyboard.o_fwd.83 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.84 = private unnamed_addr constant [20 x i8] c"prefix-help-command\00", align 1
@syms_of_keyboard.o_fwd.85 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.86 = private unnamed_addr constant [10 x i8] c"top-level\00", align 1
@syms_of_keyboard.ko_fwd.87 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.88 = private unnamed_addr constant [25 x i8] c"keyboard-translate-table\00", align 1
@syms_of_keyboard.b_fwd = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.89 = private unnamed_addr constant [15 x i8] c"cannot-suspend\00", align 1
@syms_of_keyboard.b_fwd.90 = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.91 = private unnamed_addr constant [15 x i8] c"menu-prompting\00", align 1
@syms_of_keyboard.o_fwd.92 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.93 = private unnamed_addr constant [22 x i8] c"menu-prompt-more-char\00", align 1
@syms_of_keyboard.i_fwd.94 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.95 = private unnamed_addr constant [25 x i8] c"extra-keyboard-modifiers\00", align 1
@syms_of_keyboard.o_fwd.96 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.97 = private unnamed_addr constant [16 x i8] c"deactivate-mark\00", align 1
@syms_of_keyboard.o_fwd.98 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.99 = private unnamed_addr constant [17 x i8] c"pre-command-hook\00", align 1
@syms_of_keyboard.o_fwd.100 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.101 = private unnamed_addr constant [18 x i8] c"post-command-hook\00", align 1
@syms_of_keyboard.o_fwd.102 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.103 = private unnamed_addr constant [26 x i8] c"lucid-menu-bar-dirty-flag\00", align 1
@syms_of_keyboard.o_fwd.104 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.105 = private unnamed_addr constant [21 x i8] c"menu-bar-final-items\00", align 1
@syms_of_keyboard.o_fwd.106 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.107 = private unnamed_addr constant [36 x i8] c"tool-bar-separator-image-expression\00", align 1
@syms_of_keyboard.ko_fwd.108 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.109 = private unnamed_addr constant [30 x i8] c"overriding-terminal-local-map\00", align 1
@syms_of_keyboard.o_fwd.110 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.111 = private unnamed_addr constant [21 x i8] c"overriding-local-map\00", align 1
@syms_of_keyboard.o_fwd.112 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.113 = private unnamed_addr constant [31 x i8] c"overriding-local-map-menu-flag\00", align 1
@syms_of_keyboard.o_fwd.114 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.115 = private unnamed_addr constant [18 x i8] c"special-event-map\00", align 1
@syms_of_keyboard.o_fwd.116 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.117 = private unnamed_addr constant [12 x i8] c"track-mouse\00", align 1
@syms_of_keyboard.ko_fwd.118 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.119 = private unnamed_addr constant [17 x i8] c"system-key-alist\00", align 1
@syms_of_keyboard.ko_fwd.120 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.121 = private unnamed_addr constant [23 x i8] c"local-function-key-map\00", align 1
@syms_of_keyboard.ko_fwd.122 = internal global %struct.Lisp_Kboard_Objfwd zeroinitializer, align 4
@.str.123 = private unnamed_addr constant [17 x i8] c"input-decode-map\00", align 1
@syms_of_keyboard.o_fwd.124 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.125 = private unnamed_addr constant [17 x i8] c"function-key-map\00", align 1
@syms_of_keyboard.o_fwd.126 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.127 = private unnamed_addr constant [20 x i8] c"key-translation-map\00", align 1
@syms_of_keyboard.o_fwd.128 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.129 = private unnamed_addr constant [21 x i8] c"deferred-action-list\00", align 1
@syms_of_keyboard.o_fwd.130 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.131 = private unnamed_addr constant [25 x i8] c"deferred-action-function\00", align 1
@syms_of_keyboard.o_fwd.132 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.133 = private unnamed_addr constant [22 x i8] c"delayed-warnings-list\00", align 1
@syms_of_keyboard.o_fwd.134 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.135 = private unnamed_addr constant [11 x i8] c"timer-list\00", align 1
@syms_of_keyboard.o_fwd.136 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.137 = private unnamed_addr constant [16 x i8] c"timer-idle-list\00", align 1
@syms_of_keyboard.o_fwd.138 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.139 = private unnamed_addr constant [22 x i8] c"input-method-function\00", align 1
@syms_of_keyboard.o_fwd.140 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.141 = private unnamed_addr constant [30 x i8] c"input-method-previous-message\00", align 1
@syms_of_keyboard.o_fwd.142 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.143 = private unnamed_addr constant [19 x i8] c"show-help-function\00", align 1
@syms_of_keyboard.o_fwd.144 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.145 = private unnamed_addr constant [25 x i8] c"disable-point-adjustment\00", align 1
@syms_of_keyboard.o_fwd.146 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.147 = private unnamed_addr constant [32 x i8] c"global-disable-point-adjustment\00", align 1
@syms_of_keyboard.o_fwd.148 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.149 = private unnamed_addr constant [27 x i8] c"minibuffer-message-timeout\00", align 1
@syms_of_keyboard.o_fwd.150 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.151 = private unnamed_addr constant [15 x i8] c"throw-on-input\00", align 1
@syms_of_keyboard.o_fwd.152 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.153 = private unnamed_addr constant [23 x i8] c"command-error-function\00", align 1
@.str.154 = private unnamed_addr constant [31 x i8] c"command-error-default-function\00", align 1
@syms_of_keyboard.o_fwd.155 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.156 = private unnamed_addr constant [34 x i8] c"enable-disabled-menus-and-buttons\00", align 1
@syms_of_keyboard.o_fwd.157 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.158 = private unnamed_addr constant [22 x i8] c"select-active-regions\00", align 1
@syms_of_keyboard.o_fwd.159 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.160 = private unnamed_addr constant [23 x i8] c"saved-region-selection\00", align 1
@syms_of_keyboard.o_fwd.161 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.162 = private unnamed_addr constant [34 x i8] c"selection-inhibit-update-commands\00", align 1
@syms_of_keyboard.o_fwd.163 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.164 = private unnamed_addr constant [15 x i8] c"debug-on-event\00", align 1
@.str.165 = private unnamed_addr constant [8 x i8] c"sigusr2\00", align 1
@global_map = external global i64, align 8
@.str.166 = private unnamed_addr constant [14 x i8] c"suspend-emacs\00", align 1
@control_x_map = external global i64, align 8
@meta_map = external global i64, align 8
@.str.167 = private unnamed_addr constant [20 x i8] c"exit-recursive-edit\00", align 1
@.str.168 = private unnamed_addr constant [21 x i8] c"abort-recursive-edit\00", align 1
@.str.169 = private unnamed_addr constant [25 x i8] c"execute-extended-command\00", align 1
@.str.170 = private unnamed_addr constant [13 x i8] c"delete-frame\00", align 1
@.str.171 = private unnamed_addr constant [20 x i8] c"handle-delete-frame\00", align 1
@.str.172 = private unnamed_addr constant [20 x i8] c"ns-put-working-text\00", align 1
@.str.173 = private unnamed_addr constant [22 x i8] c"ns-unput-working-text\00", align 1
@.str.174 = private unnamed_addr constant [14 x i8] c"iconify-frame\00", align 1
@.str.175 = private unnamed_addr constant [7 x i8] c"ignore\00", align 1
@.str.176 = private unnamed_addr constant [19 x i8] c"make-frame-visible\00", align 1
@.str.177 = private unnamed_addr constant [13 x i8] c"save-session\00", align 1
@.str.178 = private unnamed_addr constant [20 x i8] c"handle-save-session\00", align 1
@.str.179 = private unnamed_addr constant [12 x i8] c"file-notify\00", align 1
@.str.180 = private unnamed_addr constant [25 x i8] c"file-notify-handle-event\00", align 1
@.str.181 = private unnamed_addr constant [21 x i8] c"config-changed-event\00", align 1
@.str.182 = private unnamed_addr constant [9 x i8] c"focus-in\00", align 1
@.str.183 = private unnamed_addr constant [16 x i8] c"handle-focus-in\00", align 1
@.str.184 = private unnamed_addr constant [10 x i8] c"focus-out\00", align 1
@.str.185 = private unnamed_addr constant [17 x i8] c"handle-focus-out\00", align 1
@return_to_command_loop = common global [1 x %struct.__jmp_buf_tag] zeroinitializer, align 16
@interrupts_deferred = common global i8 0, align 1
@executing_kbd_macro = external global i64, align 8
@executing_kbd_macro_iterations = external global i64, align 8
@.str.186 = private unnamed_addr constant [30 x i8] c"After 1 kbd macro iteration: \00", align 1
@.str.187 = private unnamed_addr constant [33 x i8] c"After %ld kbd macro iterations: \00", align 1
@.str.188 = private unnamed_addr constant [50 x i8] c"Bare impure Emacs (standard Lisp code not loaded)\00", align 1
@.str.189 = private unnamed_addr constant [43 x i8] c"Bare Emacs (standard Lisp code not loaded)\00", align 1
@echoing = internal global i8 0, align 1
@.str.190 = private unnamed_addr constant [21 x i8] c"Error in %s (%S): %S\00", align 1
@.str.191 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@button_down_time = internal global i64 0, align 8
@lispy_accent_codes = internal constant [20 x i32] [i32 65106, i32 65104, i32 65107, i32 65111, i32 65108, i32 0, i32 65105, i32 65115, i32 65109, i32 65116, i32 65114, i32 65113, i32 65110, i32 65112, i32 65117, i32 65120, i32 65118, i32 65119, i32 65121, i32 65122], align 16
@lispy_accent_keys = internal constant [20 x i8*] [i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.194, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.195, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.196, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.197, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.198, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.199, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.200, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.201, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.202, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.203, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.204, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.206, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.207, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.208, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.209, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.210, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.211, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.212, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.213, i32 0, i32 0)], align 16
@iso_lispy_function_keys = internal constant [53 x i8*] [i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.214, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.215, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.216, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.217, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.218, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.219, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.220, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.221, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.222, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.223, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.224, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.225, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.226, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.227, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.228, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.229, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.230, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.231, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.232, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.233, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.234, i32 0, i32 0)], align 16
@lispy_function_keys = internal constant [256 x i8*] [i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.235, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.236, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.237, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.238, i32 0, i32 0), i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.239, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.240, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.241, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.242, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.243, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.244, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.245, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.246, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.247, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.248, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.249, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.250, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.251, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.252, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.253, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.254, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.255, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.256, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.257, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.258, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.259, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.260, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.261, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.262, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.263, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.264, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.265, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.266, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.267, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.268, i32 0, i32 0), i8* null, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.269, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.270, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.271, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.272, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.273, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.274, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.275, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.276, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.277, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.278, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.279, i32 0, i32 0), i8* null, i8* null, i8* null, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.280, i32 0, i32 0), i8* null, i8* null, i8* null, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.281, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.282, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.283, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.284, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.285, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.286, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.287, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.288, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.289, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.290, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.291, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.292, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.293, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.294, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.295, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.296, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.297, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.298, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.299, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.300, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.301, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.302, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.303, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.304, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.305, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.306, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.307, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.308, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.309, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.310, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.311, i32 0, i32 0), i8* null, i8* null, i8* null, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.312, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.313, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.314, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.315, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.316, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.317, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.318, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.319, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.320, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.321, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.322, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.323, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.324, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.325, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.326, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.327, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.328, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.329, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.330, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.331, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.332, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.333, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.334, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.335, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.336, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.337, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.338, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.339, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.340, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.341, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.342, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.343, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.344, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.345, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.346, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.347, i32 0, i32 0), i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.348, i32 0, i32 0)], align 16
@last_mouse_button = internal global i32 0, align 4
@last_mouse_x = internal global i32 0, align 4
@last_mouse_y = internal global i32 0, align 4
@double_click_count = internal global i32 0, align 4
@lispy_wheel_names = internal constant [4 x i8*] [i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.349, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.350, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.351, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.352, i32 0, i32 0)], align 16
@lispy_drag_n_drop_names = internal constant [1 x i8*] [i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.353, i32 0, i32 0)], align 8
@.str.192 = private unnamed_addr constant [7 x i8] c"%s-%ld\00", align 1
@.str.193 = private unnamed_addr constant [8 x i8] c"key-%ld\00", align 1
@.str.194 = private unnamed_addr constant [16 x i8] c"dead-circumflex\00", align 1
@.str.195 = private unnamed_addr constant [11 x i8] c"dead-grave\00", align 1
@.str.196 = private unnamed_addr constant [11 x i8] c"dead-tilde\00", align 1
@.str.197 = private unnamed_addr constant [15 x i8] c"dead-diaeresis\00", align 1
@.str.198 = private unnamed_addr constant [12 x i8] c"dead-macron\00", align 1
@.str.199 = private unnamed_addr constant [12 x i8] c"dead-degree\00", align 1
@.str.200 = private unnamed_addr constant [11 x i8] c"dead-acute\00", align 1
@.str.201 = private unnamed_addr constant [13 x i8] c"dead-cedilla\00", align 1
@.str.202 = private unnamed_addr constant [11 x i8] c"dead-breve\00", align 1
@.str.203 = private unnamed_addr constant [12 x i8] c"dead-ogonek\00", align 1
@.str.204 = private unnamed_addr constant [11 x i8] c"dead-caron\00", align 1
@.str.205 = private unnamed_addr constant [17 x i8] c"dead-doubleacute\00", align 1
@.str.206 = private unnamed_addr constant [14 x i8] c"dead-abovedot\00", align 1
@.str.207 = private unnamed_addr constant [15 x i8] c"dead-abovering\00", align 1
@.str.208 = private unnamed_addr constant [10 x i8] c"dead-iota\00", align 1
@.str.209 = private unnamed_addr constant [14 x i8] c"dead-belowdot\00", align 1
@.str.210 = private unnamed_addr constant [18 x i8] c"dead-voiced-sound\00", align 1
@.str.211 = private unnamed_addr constant [22 x i8] c"dead-semivoiced-sound\00", align 1
@.str.212 = private unnamed_addr constant [10 x i8] c"dead-hook\00", align 1
@.str.213 = private unnamed_addr constant [10 x i8] c"dead-horn\00", align 1
@.str.214 = private unnamed_addr constant [12 x i8] c"iso-lefttab\00", align 1
@.str.215 = private unnamed_addr constant [17 x i8] c"iso-move-line-up\00", align 1
@.str.216 = private unnamed_addr constant [19 x i8] c"iso-move-line-down\00", align 1
@.str.217 = private unnamed_addr constant [20 x i8] c"iso-partial-line-up\00", align 1
@.str.218 = private unnamed_addr constant [22 x i8] c"iso-partial-line-down\00", align 1
@.str.219 = private unnamed_addr constant [23 x i8] c"iso-partial-space-left\00", align 1
@.str.220 = private unnamed_addr constant [24 x i8] c"iso-partial-space-right\00", align 1
@.str.221 = private unnamed_addr constant [20 x i8] c"iso-set-margin-left\00", align 1
@.str.222 = private unnamed_addr constant [21 x i8] c"iso-set-margin-right\00", align 1
@.str.223 = private unnamed_addr constant [24 x i8] c"iso-release-margin-left\00", align 1
@.str.224 = private unnamed_addr constant [25 x i8] c"iso-release-margin-right\00", align 1
@.str.225 = private unnamed_addr constant [25 x i8] c"iso-release-both-margins\00", align 1
@.str.226 = private unnamed_addr constant [21 x i8] c"iso-fast-cursor-left\00", align 1
@.str.227 = private unnamed_addr constant [22 x i8] c"iso-fast-cursor-right\00", align 1
@.str.228 = private unnamed_addr constant [19 x i8] c"iso-fast-cursor-up\00", align 1
@.str.229 = private unnamed_addr constant [21 x i8] c"iso-fast-cursor-down\00", align 1
@.str.230 = private unnamed_addr constant [25 x i8] c"iso-continuous-underline\00", align 1
@.str.231 = private unnamed_addr constant [28 x i8] c"iso-discontinuous-underline\00", align 1
@.str.232 = private unnamed_addr constant [14 x i8] c"iso-emphasize\00", align 1
@.str.233 = private unnamed_addr constant [18 x i8] c"iso-center-object\00", align 1
@.str.234 = private unnamed_addr constant [10 x i8] c"iso-enter\00", align 1
@.str.235 = private unnamed_addr constant [10 x i8] c"backspace\00", align 1
@.str.236 = private unnamed_addr constant [4 x i8] c"tab\00", align 1
@.str.237 = private unnamed_addr constant [9 x i8] c"linefeed\00", align 1
@.str.238 = private unnamed_addr constant [6 x i8] c"clear\00", align 1
@.str.239 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.240 = private unnamed_addr constant [6 x i8] c"pause\00", align 1
@.str.241 = private unnamed_addr constant [7 x i8] c"escape\00", align 1
@.str.242 = private unnamed_addr constant [6 x i8] c"kanji\00", align 1
@.str.243 = private unnamed_addr constant [9 x i8] c"muhenkan\00", align 1
@.str.244 = private unnamed_addr constant [7 x i8] c"henkan\00", align 1
@.str.245 = private unnamed_addr constant [7 x i8] c"romaji\00", align 1
@.str.246 = private unnamed_addr constant [9 x i8] c"hiragana\00", align 1
@.str.247 = private unnamed_addr constant [9 x i8] c"katakana\00", align 1
@.str.248 = private unnamed_addr constant [18 x i8] c"hiragana-katakana\00", align 1
@.str.249 = private unnamed_addr constant [8 x i8] c"zenkaku\00", align 1
@.str.250 = private unnamed_addr constant [8 x i8] c"hankaku\00", align 1
@.str.251 = private unnamed_addr constant [16 x i8] c"zenkaku-hankaku\00", align 1
@.str.252 = private unnamed_addr constant [8 x i8] c"touroku\00", align 1
@.str.253 = private unnamed_addr constant [7 x i8] c"massyo\00", align 1
@.str.254 = private unnamed_addr constant [10 x i8] c"kana-lock\00", align 1
@.str.255 = private unnamed_addr constant [11 x i8] c"kana-shift\00", align 1
@.str.256 = private unnamed_addr constant [11 x i8] c"eisu-shift\00", align 1
@.str.257 = private unnamed_addr constant [12 x i8] c"eisu-toggle\00", align 1
@.str.258 = private unnamed_addr constant [5 x i8] c"home\00", align 1
@.str.259 = private unnamed_addr constant [5 x i8] c"left\00", align 1
@.str.260 = private unnamed_addr constant [6 x i8] c"right\00", align 1
@.str.261 = private unnamed_addr constant [6 x i8] c"prior\00", align 1
@.str.262 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@.str.263 = private unnamed_addr constant [4 x i8] c"end\00", align 1
@.str.264 = private unnamed_addr constant [6 x i8] c"begin\00", align 1
@.str.265 = private unnamed_addr constant [7 x i8] c"select\00", align 1
@.str.266 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@.str.267 = private unnamed_addr constant [8 x i8] c"execute\00", align 1
@.str.268 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@.str.269 = private unnamed_addr constant [5 x i8] c"undo\00", align 1
@.str.270 = private unnamed_addr constant [5 x i8] c"redo\00", align 1
@.str.271 = private unnamed_addr constant [5 x i8] c"menu\00", align 1
@.str.272 = private unnamed_addr constant [5 x i8] c"find\00", align 1
@.str.273 = private unnamed_addr constant [7 x i8] c"cancel\00", align 1
@.str.274 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@.str.275 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@.str.276 = private unnamed_addr constant [8 x i8] c"backtab\00", align 1
@.str.277 = private unnamed_addr constant [11 x i8] c"kp-numlock\00", align 1
@.str.278 = private unnamed_addr constant [9 x i8] c"kp-space\00", align 1
@.str.279 = private unnamed_addr constant [7 x i8] c"kp-tab\00", align 1
@.str.280 = private unnamed_addr constant [9 x i8] c"kp-enter\00", align 1
@.str.281 = private unnamed_addr constant [6 x i8] c"kp-f1\00", align 1
@.str.282 = private unnamed_addr constant [6 x i8] c"kp-f2\00", align 1
@.str.283 = private unnamed_addr constant [6 x i8] c"kp-f3\00", align 1
@.str.284 = private unnamed_addr constant [6 x i8] c"kp-f4\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"kp-home\00", align 1
@.str.286 = private unnamed_addr constant [8 x i8] c"kp-left\00", align 1
@.str.287 = private unnamed_addr constant [6 x i8] c"kp-up\00", align 1
@.str.288 = private unnamed_addr constant [9 x i8] c"kp-right\00", align 1
@.str.289 = private unnamed_addr constant [8 x i8] c"kp-down\00", align 1
@.str.290 = private unnamed_addr constant [9 x i8] c"kp-prior\00", align 1
@.str.291 = private unnamed_addr constant [8 x i8] c"kp-next\00", align 1
@.str.292 = private unnamed_addr constant [7 x i8] c"kp-end\00", align 1
@.str.293 = private unnamed_addr constant [9 x i8] c"kp-begin\00", align 1
@.str.294 = private unnamed_addr constant [10 x i8] c"kp-insert\00", align 1
@.str.295 = private unnamed_addr constant [10 x i8] c"kp-delete\00", align 1
@.str.296 = private unnamed_addr constant [12 x i8] c"kp-multiply\00", align 1
@.str.297 = private unnamed_addr constant [7 x i8] c"kp-add\00", align 1
@.str.298 = private unnamed_addr constant [13 x i8] c"kp-separator\00", align 1
@.str.299 = private unnamed_addr constant [12 x i8] c"kp-subtract\00", align 1
@.str.300 = private unnamed_addr constant [11 x i8] c"kp-decimal\00", align 1
@.str.301 = private unnamed_addr constant [10 x i8] c"kp-divide\00", align 1
@.str.302 = private unnamed_addr constant [5 x i8] c"kp-0\00", align 1
@.str.303 = private unnamed_addr constant [5 x i8] c"kp-1\00", align 1
@.str.304 = private unnamed_addr constant [5 x i8] c"kp-2\00", align 1
@.str.305 = private unnamed_addr constant [5 x i8] c"kp-3\00", align 1
@.str.306 = private unnamed_addr constant [5 x i8] c"kp-4\00", align 1
@.str.307 = private unnamed_addr constant [5 x i8] c"kp-5\00", align 1
@.str.308 = private unnamed_addr constant [5 x i8] c"kp-6\00", align 1
@.str.309 = private unnamed_addr constant [5 x i8] c"kp-7\00", align 1
@.str.310 = private unnamed_addr constant [5 x i8] c"kp-8\00", align 1
@.str.311 = private unnamed_addr constant [5 x i8] c"kp-9\00", align 1
@.str.312 = private unnamed_addr constant [9 x i8] c"kp-equal\00", align 1
@.str.313 = private unnamed_addr constant [3 x i8] c"f1\00", align 1
@.str.314 = private unnamed_addr constant [3 x i8] c"f2\00", align 1
@.str.315 = private unnamed_addr constant [3 x i8] c"f3\00", align 1
@.str.316 = private unnamed_addr constant [3 x i8] c"f4\00", align 1
@.str.317 = private unnamed_addr constant [3 x i8] c"f5\00", align 1
@.str.318 = private unnamed_addr constant [3 x i8] c"f6\00", align 1
@.str.319 = private unnamed_addr constant [3 x i8] c"f7\00", align 1
@.str.320 = private unnamed_addr constant [3 x i8] c"f8\00", align 1
@.str.321 = private unnamed_addr constant [3 x i8] c"f9\00", align 1
@.str.322 = private unnamed_addr constant [4 x i8] c"f10\00", align 1
@.str.323 = private unnamed_addr constant [4 x i8] c"f11\00", align 1
@.str.324 = private unnamed_addr constant [4 x i8] c"f12\00", align 1
@.str.325 = private unnamed_addr constant [4 x i8] c"f13\00", align 1
@.str.326 = private unnamed_addr constant [4 x i8] c"f14\00", align 1
@.str.327 = private unnamed_addr constant [4 x i8] c"f15\00", align 1
@.str.328 = private unnamed_addr constant [4 x i8] c"f16\00", align 1
@.str.329 = private unnamed_addr constant [4 x i8] c"f17\00", align 1
@.str.330 = private unnamed_addr constant [4 x i8] c"f18\00", align 1
@.str.331 = private unnamed_addr constant [4 x i8] c"f19\00", align 1
@.str.332 = private unnamed_addr constant [4 x i8] c"f20\00", align 1
@.str.333 = private unnamed_addr constant [4 x i8] c"f21\00", align 1
@.str.334 = private unnamed_addr constant [4 x i8] c"f22\00", align 1
@.str.335 = private unnamed_addr constant [4 x i8] c"f23\00", align 1
@.str.336 = private unnamed_addr constant [4 x i8] c"f24\00", align 1
@.str.337 = private unnamed_addr constant [4 x i8] c"f25\00", align 1
@.str.338 = private unnamed_addr constant [4 x i8] c"f26\00", align 1
@.str.339 = private unnamed_addr constant [4 x i8] c"f27\00", align 1
@.str.340 = private unnamed_addr constant [4 x i8] c"f28\00", align 1
@.str.341 = private unnamed_addr constant [4 x i8] c"f29\00", align 1
@.str.342 = private unnamed_addr constant [4 x i8] c"f30\00", align 1
@.str.343 = private unnamed_addr constant [4 x i8] c"f31\00", align 1
@.str.344 = private unnamed_addr constant [4 x i8] c"f32\00", align 1
@.str.345 = private unnamed_addr constant [4 x i8] c"f33\00", align 1
@.str.346 = private unnamed_addr constant [4 x i8] c"f34\00", align 1
@.str.347 = private unnamed_addr constant [4 x i8] c"f35\00", align 1
@.str.348 = private unnamed_addr constant [7 x i8] c"delete\00", align 1
@.str.349 = private unnamed_addr constant [9 x i8] c"wheel-up\00", align 1
@.str.350 = private unnamed_addr constant [11 x i8] c"wheel-down\00", align 1
@.str.351 = private unnamed_addr constant [11 x i8] c"wheel-left\00", align 1
@.str.352 = private unnamed_addr constant [12 x i8] c"wheel-right\00", align 1
@scroll_bar_parts = internal constant [19 x i16] [i16 0, i16 156, i16 505, i16 201, i16 977, i16 352, i16 928, i16 213, i16 368, i16 787, i16 198, i16 523, i16 166, i16 607, i16 811, i16 611, i16 817, i16 368, i16 787], align 16
@.str.353 = private unnamed_addr constant [12 x i8] c"drag-n-drop\00", align 1
@echo_add_key.text = internal constant [30 x i8] c" (Type ? for further options)\00", align 16
@.str.354 = private unnamed_addr constant [7 x i8] c" 0x%lx\00", align 1
@getcjmp = internal global [1 x %struct.__jmp_buf_tag] zeroinitializer, align 16
@timer_last_idleness_start_time = internal global %struct.timespec zeroinitializer, align 8
@.str.355 = private unnamed_addr constant [26 x i8] c"internal-timer-start-idle\00", align 1
@.str.356 = private unnamed_addr constant [7 x i8] c"mouse-\00", align 1
@.str.357 = private unnamed_addr constant [7 x i8] c"wheel-\00", align 1
@.str.358 = private unnamed_addr constant [8 x i8] c"double-\00", align 1
@.str.359 = private unnamed_addr constant [8 x i8] c"triple-\00", align 1
@.str.360 = private unnamed_addr constant [4 x i8] c"up-\00", align 1
@.str.361 = private unnamed_addr constant [6 x i8] c"down-\00", align 1
@.str.362 = private unnamed_addr constant [6 x i8] c"drag-\00", align 1
@.str.363 = private unnamed_addr constant [6 x i8] c"space\00", align 1
@.str.364 = private unnamed_addr constant [8 x i8] c"no-line\00", align 1
@.str.365 = private unnamed_addr constant [12 x i8] c"single-line\00", align 1
@.str.366 = private unnamed_addr constant [12 x i8] c"double-line\00", align 1
@.str.367 = private unnamed_addr constant [19 x i8] c"single-dashed-line\00", align 1
@.str.368 = private unnamed_addr constant [19 x i8] c"double-dashed-line\00", align 1
@.str.369 = private unnamed_addr constant [17 x i8] c"shadow-etched-in\00", align 1
@.str.370 = private unnamed_addr constant [18 x i8] c"shadow-etched-out\00", align 1
@.str.371 = private unnamed_addr constant [22 x i8] c"shadow-etched-in-dash\00", align 1
@.str.372 = private unnamed_addr constant [23 x i8] c"shadow-etched-out-dash\00", align 1
@.str.373 = private unnamed_addr constant [24 x i8] c"shadow-double-etched-in\00", align 1
@.str.374 = private unnamed_addr constant [25 x i8] c"shadow-double-etched-out\00", align 1
@.str.375 = private unnamed_addr constant [29 x i8] c"shadow-double-etched-in-dash\00", align 1
@.str.376 = private unnamed_addr constant [30 x i8] c"shadow-double-etched-out-dash\00", align 1
@.str.377 = private unnamed_addr constant [19 x i8] c"!!?GARBLED ITEM?!!\00", align 1
@.str.378 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.379 = private unnamed_addr constant [3 x i8] c": \00", align 1
@.str.380 = private unnamed_addr constant [5 x i8] c"(*) \00", align 1
@.str.381 = private unnamed_addr constant [5 x i8] c"( ) \00", align 1
@.str.382 = private unnamed_addr constant [5 x i8] c"[X] \00", align 1
@.str.383 = private unnamed_addr constant [5 x i8] c"[ ] \00", align 1
@.str.384 = private unnamed_addr constant [3 x i8] c", \00", align 1
@.str.385 = private unnamed_addr constant [4 x i8] c" = \00", align 1
@.str.386 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.387 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@.str.388 = private unnamed_addr constant [22 x i8] c"Key sequence too long\00", align 1
@.str.389 = private unnamed_addr constant [41 x i8] c"Function %s returns invalid key sequence\00", align 1
@stdout = external global %struct._IO_FILE*, align 8
@gc_in_progress = external global i8, align 1
@.str.390 = private unnamed_addr constant [21 x i8] c"Auto-save? (y or n) \00", align 1
@.str.391 = private unnamed_addr constant [16 x i8] c"Auto-save done\0A\00", align 1
@.str.392 = private unnamed_addr constant [118 x i8] c"Garbage collection in progress; cannot auto-save now\0D\0Abut will instead do a real quit after garbage collection ends\0D\0A\00", align 1
@.str.393 = private unnamed_addr constant [33 x i8] c"Abort (and dump core)? (y or n) \00", align 1
@.str.394 = private unnamed_addr constant [15 x i8] c"Continuing...\0A\00", align 1
@gl_state = external global %struct.gl_state_s, align 8
@force_quit_count = internal global i32 0, align 4
@.str.395 = private unnamed_addr constant [6 x i8] c"click\00", align 1
@.str.396 = private unnamed_addr constant [18 x i8] c"current-idle-time\00", align 1
@.str.397 = private unnamed_addr constant [38 x i8] c"internal-event-symbol-parse-modifiers\00", align 1
@Sevent_symbol_parse_modifiers = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fevent_symbol_parse_modifiers }, i16 1, i16 1, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.397, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.398 = private unnamed_addr constant [19 x i8] c"event-convert-list\00", align 1
@Sevent_convert_list = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fevent_convert_list }, i16 1, i16 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.398, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.399 = private unnamed_addr constant [18 x i8] c"read-key-sequence\00", align 1
@Sread_key_sequence = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fread_key_sequence }, i16 1, i16 5, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.399, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.400 = private unnamed_addr constant [25 x i8] c"read-key-sequence-vector\00", align 1
@Sread_key_sequence_vector = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fread_key_sequence_vector }, i16 1, i16 5, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.400, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.401 = private unnamed_addr constant [15 x i8] c"recursive-edit\00", align 1
@.str.402 = private unnamed_addr constant [22 x i8] c"internal--track-mouse\00", align 1
@Strack_mouse = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ftrack_mouse }, i16 1, i16 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.402, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.403 = private unnamed_addr constant [16 x i8] c"input-pending-p\00", align 1
@Sinput_pending_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Finput_pending_p }, i16 0, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.403, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.404 = private unnamed_addr constant [12 x i8] c"recent-keys\00", align 1
@Srecent_keys = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Frecent_keys }, i16 0, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.404, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.405 = private unnamed_addr constant [18 x i8] c"this-command-keys\00", align 1
@.str.406 = private unnamed_addr constant [25 x i8] c"this-command-keys-vector\00", align 1
@.str.407 = private unnamed_addr constant [25 x i8] c"this-single-command-keys\00", align 1
@.str.408 = private unnamed_addr constant [29 x i8] c"this-single-command-raw-keys\00", align 1
@.str.409 = private unnamed_addr constant [24 x i8] c"clear-this-command-keys\00", align 1
@Sclear_this_command_keys = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fclear_this_command_keys }, i16 0, i16 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.409, i32 0, i32 0), i8* null, i8* null }, align 8
@Ssuspend_emacs = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsuspend_emacs }, i16 0, i16 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.166, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8* null }, align 8
@.str.410 = private unnamed_addr constant [16 x i8] c"recursion-depth\00", align 1
@Scommand_error_default_function = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fcommand_error_default_function }, i16 3, i16 3, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.154, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.411 = private unnamed_addr constant [14 x i8] c"discard-input\00", align 1
@.str.412 = private unnamed_addr constant [18 x i8] c"open-dribble-file\00", align 1
@.str.413 = private unnamed_addr constant [21 x i8] c"FOpen dribble file: \00", align 1
@Sopen_dribble_file = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fopen_dribble_file }, i16 1, i16 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.412, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.413, i32 0, i32 0), i8* null }, align 8
@.str.414 = private unnamed_addr constant [25 x i8] c"set-input-interrupt-mode\00", align 1
@Sset_input_interrupt_mode = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fset_input_interrupt_mode }, i16 1, i16 1, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.414, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.415 = private unnamed_addr constant [24 x i8] c"set-output-flow-control\00", align 1
@Sset_output_flow_control = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_output_flow_control }, i16 1, i16 2, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.415, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.416 = private unnamed_addr constant [20 x i8] c"set-input-meta-mode\00", align 1
@Sset_input_meta_mode = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_input_meta_mode }, i16 1, i16 2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.416, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.417 = private unnamed_addr constant [14 x i8] c"set-quit-char\00", align 1
@Sset_quit_char = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fset_quit_char }, i16 1, i16 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.417, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.418 = private unnamed_addr constant [15 x i8] c"set-input-mode\00", align 1
@Sset_input_mode = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Fset_input_mode }, i16 3, i16 4, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.418, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.419 = private unnamed_addr constant [19 x i8] c"current-input-mode\00", align 1
@.str.420 = private unnamed_addr constant [14 x i8] c"posn-at-point\00", align 1
@Sposn_at_point = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fposn_at_point }, i16 0, i16 2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.420, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.421 = private unnamed_addr constant [12 x i8] c"posn-at-x-y\00", align 1
@Sposn_at_x_y = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Fposn_at_x_y }, i16 2, i16 4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.421, i32 0, i32 0), i8* null, i8* null }, align 8

; Function Attrs: nounwind uwtable
define void @cancel_echoing() #0 {
entry:
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %immediate_echo, align 1
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_echo_prompt(%struct.kboard* %1, i64 %call)
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_echo_string(%struct.kboard* %2, i64 %call1)
  store %struct.kboard* null, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  store %struct.kboard* null, %struct.kboard** @echo_kboard, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* @echo_message_buffer, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @kset_echo_prompt(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %echo_prompt_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 25
  store i64 %0, i64* %echo_prompt_, align 8
  ret void
}

declare i64 @builtin_lisp_symbol(i32) #1

; Function Attrs: nounwind uwtable
define internal void @kset_echo_string(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 22
  store i64 %0, i64* %echo_string_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @recursive_edit_1() #0 {
entry:
  %count = alloca i64, align 8
  %val = alloca i64, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* @command_loop_level, align 8
  %cmp = icmp sgt i64 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 871)
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call1, i64 %call2)
  %call3 = call i64 @builtin_lisp_symbol(i32 870)
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call3, i64 %call4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @cancel_hourglass()
  %call5 = call i64 @builtin_lisp_symbol(i32 548)
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  call void @specbind(i64 %call5, i64 %call6)
  store i8 0, i8* @redisplaying_p, align 1
  %call7 = call i64 @builtin_lisp_symbol(i32 967)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  call void @specbind(i64 %call7, i64 %call8)
  %call9 = call i64 @command_loop()
  store i64 %call9, i64* %val, align 8
  %1 = load i64, i64* %val, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp11 = icmp eq i64 %1, %call10
  br i1 %cmp11, label %if.then.12, label %if.end.16

if.then.12:                                       ; preds = %if.end
  %call13 = call i64 @builtin_lisp_symbol(i32 782)
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %call15 = call i64 @Fsignal(i64 %call13, i64 %call14)
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.12, %if.end
  %2 = load i64, i64* %val, align 8
  %call17 = call zeroext i1 @STRINGP(i64 %2)
  br i1 %call17, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.end.16
  %call19 = call i64 @builtin_lisp_symbol(i32 372)
  %3 = load i64, i64* %val, align 8
  call void @xsignal1(i64 %call19, i64 %3) #11
  unreachable

if.end.20:                                        ; preds = %if.end.16
  %4 = load i64, i64* %count, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %call22 = call i64 @unbind_to(i64 %4, i64 %call21)
  ret i64 %call22
}

declare i64 @SPECPDL_INDEX() #1

declare void @specbind(i64, i64) #1

declare void @cancel_hourglass() #1

; Function Attrs: nounwind uwtable
define internal i64 @command_loop() #0 {
entry:
  %val = alloca i64, align 8
  %call = call i32 @__sigsetjmp(%struct.__jmp_buf_tag* getelementptr inbounds ([1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* @return_to_command_loop, i32 0, i32 0), i32 1) #12
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @init_eval()
  %0 = load i64, i64* @recover_top_level_message, align 8
  store i64 %0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 146), align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load i64, i64* @regular_top_level_message, align 8
  store i64 %1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 146), align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load i64, i64* @command_loop_level, align 8
  %cmp1 = icmp sgt i64 %2, 0
  br i1 %cmp1, label %if.then.3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %3 = load i64, i64* @minibuf_level, align 8
  %cmp2 = icmp sgt i64 %3, 0
  br i1 %cmp2, label %if.then.3, label %if.else.8

if.then.3:                                        ; preds = %lor.lhs.false, %if.end
  %call4 = call i64 @builtin_lisp_symbol(i32 387)
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @internal_catch(i64 %call4, i64 (i64)* @command_loop_2, i64 %call5)
  store i64 %call6, i64* %val, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call7, i64* @executing_kbd_macro, align 8
  %4 = load i64, i64* %val, align 8
  ret i64 %4

if.else.8:                                        ; preds = %lor.lhs.false
  br label %while.body

while.body:                                       ; preds = %if.else.8, %if.end.18
  %call9 = call i64 @builtin_lisp_symbol(i32 930)
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %call11 = call i64 @internal_catch(i64 %call9, i64 (i64)* @top_level_1, i64 %call10)
  %call12 = call i64 @builtin_lisp_symbol(i32 930)
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %call14 = call i64 @internal_catch(i64 %call12, i64 (i64)* @command_loop_2, i64 %call13)
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* @executing_kbd_macro, align 8
  %5 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %while.body
  %call17 = call i64 @builtin_lisp_symbol(i32 901)
  %6 = call i64 @Fkill_emacs(i64 %call17) #11
  unreachable

if.end.18:                                        ; preds = %while.body
  br label %while.body
}

declare i64 @Fsignal(i64, i64) #1

declare zeroext i1 @STRINGP(i64) #1

; Function Attrs: noreturn
declare void @xsignal1(i64, i64) #2

declare i64 @unbind_to(i64, i64) #1

; Function Attrs: nounwind uwtable
define void @record_auto_save() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  store i64 %0, i64* @last_auto_save, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Frecursive_edit() #0 {
entry:
  %retval = alloca i64, align 8
  %count = alloca i64, align 8
  %buffer = alloca i64, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call zeroext i1 @input_blocked_p()
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i64, i64* @command_loop_level, align 8
  %cmp = icmp sge i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %2 = load i64, i64* @selected_window, align 8
  %call3 = call %struct.window* @XWINDOW(i64 %2)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call3, i32 0, i32 10
  %3 = load i64, i64* %contents, align 8
  %call4 = call %struct.buffer* @XBUFFER(i64 %3)
  %cmp5 = icmp ne %struct.buffer* %1, %call4
  br i1 %cmp5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %land.lhs.true
  %call7 = call i64 @Fcurrent_buffer()
  store i64 %call7, i64* %buffer, align 8
  br label %if.end.9

if.else:                                          ; preds = %land.lhs.true, %if.end
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call8, i64* %buffer, align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.else, %if.then.6
  %4 = load i64, i64* @command_loop_level, align 8
  %inc = add nsw i64 %4, 1
  store i64 %inc, i64* @command_loop_level, align 8
  store i32 17, i32* @update_mode_lines, align 4
  %5 = load i64, i64* %buffer, align 8
  call void @record_unwind_protect(void (i64)* @recursive_edit_unwind, i64 %5)
  %6 = load i64, i64* @command_loop_level, align 8
  %cmp10 = icmp sgt i64 %6, 0
  br i1 %cmp10, label %if.then.11, label %if.end.16

if.then.11:                                       ; preds = %if.end.9
  %7 = load i64, i64* @selected_frame, align 8
  %call12 = call zeroext i1 @FRAMEP(i64 %7)
  br i1 %call12, label %land.lhs.true.13, label %cond.false

land.lhs.true.13:                                 ; preds = %if.then.11
  %8 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %8, 5
  %9 = inttoptr i64 %sub to i8*
  %10 = bitcast i8* %9 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %10, i32 0, i32 61
  %11 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp14 = icmp ne %struct.terminal* %11, null
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.13
  %12 = load i64, i64* @selected_frame, align 8
  %sub15 = sub nsw i64 %12, 5
  %13 = inttoptr i64 %sub15 to i8*
  %14 = bitcast i8* %13 to %struct.frame*
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.13, %if.then.11
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %15, %cond.true
  %cond = phi %struct.frame* [ %14, %cond.true ], [ null, %15 ]
  call void @temporarily_switch_to_single_kboard(%struct.frame* %cond)
  br label %if.end.16

if.end.16:                                        ; preds = %cond.end, %if.end.9
  %call17 = call i64 @recursive_edit_1()
  %16 = load i64, i64* %count, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %call19 = call i64 @unbind_to(i64 %16, i64 %call18)
  store i64 %call19, i64* %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then
  %17 = load i64, i64* %retval
  ret i64 %17
}

declare zeroext i1 @input_blocked_p() #1

declare %struct.buffer* @XBUFFER(i64) #1

declare %struct.window* @XWINDOW(i64) #1

declare i64 @Fcurrent_buffer() #1

declare void @record_unwind_protect(void (i64)*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @recursive_edit_unwind(i64 %buffer) #0 {
entry:
  %buffer.addr = alloca i64, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  %0 = load i64, i64* %buffer.addr, align 8
  %call = call zeroext i1 @BUFFERP(i64 %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %buffer.addr, align 8
  %call1 = call i64 @Fset_buffer(i64 %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* @command_loop_level, align 8
  %dec = add nsw i64 %2, -1
  store i64 %dec, i64* @command_loop_level, align 8
  store i32 18, i32* @update_mode_lines, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @temporarily_switch_to_single_kboard(%struct.frame* %f) #0 {
entry:
  %f.addr = alloca %struct.frame*, align 8
  %was_locked = alloca i8, align 1
  store %struct.frame* %f, %struct.frame** %f.addr, align 8
  %0 = load i8, i8* @single_kboard, align 1
  %tobool = trunc i8 %0 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %was_locked, align 1
  %1 = load i8, i8* %was_locked, align 1
  %tobool1 = trunc i8 %1 to i1
  br i1 %tobool1, label %if.then, label %if.else.5

if.then:                                          ; preds = %entry
  %2 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %cmp = icmp ne %struct.frame* %2, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %3 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %3, i32 0, i32 61
  %4 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %4, i32 0, i32 10
  %5 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  %6 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp2 = icmp ne %struct.kboard* %5, %6
  br i1 %cmp2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %land.lhs.true
  %7 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %terminal4 = getelementptr inbounds %struct.frame, %struct.frame* %7, i32 0, i32 61
  %8 = load %struct.terminal*, %struct.terminal** %terminal4, align 8
  %id = getelementptr inbounds %struct.terminal, %struct.terminal* %8, i32 0, i32 6
  %9 = load i32, i32* %id, align 4
  call void (i8*, ...) @error(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str, i32 0, i32 0), i32 %9) #11
  unreachable

if.else:                                          ; preds = %land.lhs.true, %if.then
  %10 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  call void @push_kboard(%struct.kboard* %10)
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %if.end.11

if.else.5:                                        ; preds = %entry
  %11 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %cmp6 = icmp ne %struct.frame* %11, null
  br i1 %cmp6, label %if.then.7, label %if.end.10

if.then.7:                                        ; preds = %if.else.5
  %12 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %terminal8 = getelementptr inbounds %struct.frame, %struct.frame* %12, i32 0, i32 61
  %13 = load %struct.terminal*, %struct.terminal** %terminal8, align 8
  %kboard9 = getelementptr inbounds %struct.terminal, %struct.terminal* %13, i32 0, i32 10
  %14 = load %struct.kboard*, %struct.kboard** %kboard9, align 8
  store %struct.kboard* %14, %struct.kboard** @current_kboard, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.7, %if.else.5
  br label %if.end.11

if.end.11:                                        ; preds = %if.end.10, %if.end
  store i8 1, i8* @single_kboard, align 1
  %15 = load i8, i8* %was_locked, align 1
  %tobool12 = trunc i8 %15 to i1
  %conv = zext i1 %tobool12 to i32
  call void @record_unwind_protect_int(void (i32)* @restore_kboard_configuration, i32 %conv)
  ret void
}

declare zeroext i1 @FRAMEP(i64) #1

; Function Attrs: noreturn
declare void @emacs_abort() #2

; Function Attrs: nounwind uwtable
define void @not_single_kboard_state(%struct.kboard* %kboard) #0 {
entry:
  %kboard.addr = alloca %struct.kboard*, align 8
  store %struct.kboard* %kboard, %struct.kboard** %kboard.addr, align 8
  %0 = load %struct.kboard*, %struct.kboard** %kboard.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp = icmp eq %struct.kboard* %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, i8* @single_kboard, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @push_kboard(%struct.kboard* %k) #0 {
entry:
  %k.addr = alloca %struct.kboard*, align 8
  %p = alloca %struct.kboard_stack*, align 8
  store %struct.kboard* %k, %struct.kboard** %k.addr, align 8
  %call = call noalias i8* @xmalloc(i64 16)
  %0 = bitcast i8* %call to %struct.kboard_stack*
  store %struct.kboard_stack* %0, %struct.kboard_stack** %p, align 8
  %1 = load %struct.kboard_stack*, %struct.kboard_stack** @kboard_stack, align 8
  %2 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %next = getelementptr inbounds %struct.kboard_stack, %struct.kboard_stack* %2, i32 0, i32 1
  store %struct.kboard_stack* %1, %struct.kboard_stack** %next, align 8
  %3 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %4 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %kboard = getelementptr inbounds %struct.kboard_stack, %struct.kboard_stack* %4, i32 0, i32 0
  store %struct.kboard* %3, %struct.kboard** %kboard, align 8
  %5 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  store %struct.kboard_stack* %5, %struct.kboard_stack** @kboard_stack, align 8
  %6 = load %struct.kboard*, %struct.kboard** %k.addr, align 8
  store %struct.kboard* %6, %struct.kboard** @current_kboard, align 8
  ret void
}

declare noalias i8* @xmalloc(i64) #1

; Function Attrs: nounwind uwtable
define void @pop_kboard() #0 {
entry:
  %t = alloca %struct.terminal*, align 8
  %p = alloca %struct.kboard_stack*, align 8
  %found = alloca i8, align 1
  %0 = load %struct.kboard_stack*, %struct.kboard_stack** @kboard_stack, align 8
  store %struct.kboard_stack* %0, %struct.kboard_stack** %p, align 8
  store i8 0, i8* %found, align 1
  %1 = load %struct.terminal*, %struct.terminal** @terminal_list, align 8
  store %struct.terminal* %1, %struct.terminal** %t, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.terminal*, %struct.terminal** %t, align 8
  %tobool = icmp ne %struct.terminal* %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.terminal*, %struct.terminal** %t, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %3, i32 0, i32 10
  %4 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  %5 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %kboard1 = getelementptr inbounds %struct.kboard_stack, %struct.kboard_stack* %5, i32 0, i32 0
  %6 = load %struct.kboard*, %struct.kboard** %kboard1, align 8
  %cmp = icmp eq %struct.kboard* %4, %6
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %kboard2 = getelementptr inbounds %struct.kboard_stack, %struct.kboard_stack* %7, i32 0, i32 0
  %8 = load %struct.kboard*, %struct.kboard** %kboard2, align 8
  store %struct.kboard* %8, %struct.kboard** @current_kboard, align 8
  store i8 1, i8* %found, align 1
  br label %for.end

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load %struct.terminal*, %struct.terminal** %t, align 8
  %next_terminal = getelementptr inbounds %struct.terminal, %struct.terminal* %9, i32 0, i32 5
  %10 = load %struct.terminal*, %struct.terminal** %next_terminal, align 8
  store %struct.terminal* %10, %struct.terminal** %t, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %11 = load i8, i8* %found, align 1
  %tobool3 = trunc i8 %11 to i1
  br i1 %tobool3, label %if.end.9, label %if.then.4

if.then.4:                                        ; preds = %for.end
  %12 = load i64, i64* @selected_frame, align 8
  %call = call zeroext i1 @FRAMEP(i64 %12)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then.4
  %13 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %13, 5
  %14 = inttoptr i64 %sub to i8*
  %15 = bitcast i8* %14 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %15, i32 0, i32 61
  %16 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp5 = icmp ne %struct.terminal* %16, null
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %17 = load i64, i64* @selected_frame, align 8
  %sub6 = sub nsw i64 %17, 5
  %18 = inttoptr i64 %sub6 to i8*
  %19 = bitcast i8* %18 to %struct.frame*
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.then.4
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %20, %cond.true
  %cond = phi %struct.frame* [ %19, %cond.true ], [ null, %20 ]
  %terminal7 = getelementptr inbounds %struct.frame, %struct.frame* %cond, i32 0, i32 61
  %21 = load %struct.terminal*, %struct.terminal** %terminal7, align 8
  %kboard8 = getelementptr inbounds %struct.terminal, %struct.terminal* %21, i32 0, i32 10
  %22 = load %struct.kboard*, %struct.kboard** %kboard8, align 8
  store %struct.kboard* %22, %struct.kboard** @current_kboard, align 8
  store i8 0, i8* @single_kboard, align 1
  br label %if.end.9

if.end.9:                                         ; preds = %cond.end, %for.end
  %23 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %next = getelementptr inbounds %struct.kboard_stack, %struct.kboard_stack* %23, i32 0, i32 1
  %24 = load %struct.kboard_stack*, %struct.kboard_stack** %next, align 8
  store %struct.kboard_stack* %24, %struct.kboard_stack** @kboard_stack, align 8
  %25 = load %struct.kboard_stack*, %struct.kboard_stack** %p, align 8
  %26 = bitcast %struct.kboard_stack* %25 to i8*
  call void @xfree(i8* %26)
  ret void
}

declare void @xfree(i8*) #1

; Function Attrs: noreturn
declare void @error(i8*, ...) #2

declare void @record_unwind_protect_int(void (i32)*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @restore_kboard_configuration(i32 %was_locked) #0 {
entry:
  %was_locked.addr = alloca i32, align 4
  %prev = alloca %struct.kboard*, align 8
  store i32 %was_locked, i32* %was_locked.addr, align 4
  %0 = load i32, i32* %was_locked.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* @single_kboard, align 1
  %1 = load i32, i32* %was_locked.addr, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end.4

if.then:                                          ; preds = %entry
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  store %struct.kboard* %2, %struct.kboard** %prev, align 8
  call void @pop_kboard()
  %3 = load i8, i8* @single_kboard, align 1
  %tobool2 = trunc i8 %3 to i1
  br i1 %tobool2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %4 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %5 = load %struct.kboard*, %struct.kboard** %prev, align 8
  %cmp = icmp ne %struct.kboard* %4, %5
  br i1 %cmp, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %land.lhs.true
  call void @emacs_abort() #11
  unreachable

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @cmd_error_internal(i64 %data, i8* %context) #0 {
entry:
  %data.addr = alloca i64, align 8
  %context.addr = alloca i8*, align 8
  store i64 %data, i64* %data.addr, align 8
  store i8* %context, i8** %context.addr, align 8
  %0 = load i64, i64* %data.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %call = call i64 @builtin_lisp_symbol(i32 782)
  %cmp = icmp eq i64 %3, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* @Vsignaling_function, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call3, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 40), align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %4, %call4
  br i1 %cmp5, label %if.end.9, label %if.then.6

if.then.6:                                        ; preds = %if.end
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 40), align 8
  %6 = load i64, i64* %data.addr, align 8
  %7 = load i8*, i8** %context.addr, align 8
  %tobool = icmp ne i8* %7, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.6
  %8 = load i8*, i8** %context.addr, align 8
  %call7 = call i64 @build_string(i8* %8)
  br label %cond.end

cond.false:                                       ; preds = %if.then.6
  %9 = load i64, i64* @empty_unibyte_string, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %9, %cond.false ]
  %10 = load i64, i64* @Vsignaling_function, align 8
  %call8 = call i64 @call3(i64 %5, i64 %6, i64 %cond, i64 %10)
  br label %if.end.9

if.end.9:                                         ; preds = %cond.end, %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* @Vsignaling_function, align 8
  ret void
}

declare i64 @call3(i64, i64, i64, i64) #1

declare i64 @build_string(i8*) #1

; Function Attrs: nounwind uwtable
define i64 @Fcommand_error_default_function(i64 %data, i64 %context, i64 %signal) #0 {
entry:
  %data.addr = alloca i64, align 8
  %context.addr = alloca i64, align 8
  %signal.addr = alloca i64, align 8
  %sf = alloca %struct.frame*, align 8
  store i64 %data, i64* %data.addr, align 8
  store i64 %context, i64* %context.addr, align 8
  store i64 %signal, i64* %signal.addr, align 8
  %0 = load i64, i64* @selected_frame, align 8
  %call = call zeroext i1 @FRAMEP(i64 %0)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %1, 5
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %3, i32 0, i32 61
  %4 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp = icmp ne %struct.terminal* %4, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %5 = load i64, i64* @selected_frame, align 8
  %sub1 = sub nsw i64 %5, 5
  %6 = inttoptr i64 %sub1 to i8*
  %7 = bitcast i8* %6 to %struct.frame*
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %cond = phi %struct.frame* [ %7, %cond.true ], [ null, %8 ]
  store %struct.frame* %cond, %struct.frame** %sf, align 8
  %9 = load i64, i64* %context.addr, align 8
  call void @CHECK_STRING(i64 %9)
  %10 = load %struct.frame*, %struct.frame** %sf, align 8
  %glyphs_initialized_p = getelementptr inbounds %struct.frame, %struct.frame* %10, i32 0, i32 26
  %11 = bitcast i48* %glyphs_initialized_p to i64*
  %bf.load = load i64, i64* %11, align 8
  %bf.clear = and i64 %bf.load, 1
  %bf.cast = trunc i64 %bf.clear to i1
  br i1 %bf.cast, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %cond.end
  %12 = load i32, i32* getelementptr inbounds ([2 x i32], [2 x i32]* @daemon_pipe, i32 0, i64 1), align 4
  %cmp2 = icmp ne i32 %12, 0
  br i1 %cmp2, label %lor.lhs.false.8, label %land.lhs.true.3

land.lhs.true.3:                                  ; preds = %lor.lhs.false
  %13 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %13, i32 0, i32 26
  %14 = bitcast i48* %output_method to i64*
  %bf.load4 = load i64, i64* %14, align 8
  %bf.lshr = lshr i64 %bf.load4, 23
  %bf.clear5 = and i64 %bf.lshr, 7
  %bf.cast6 = trunc i64 %bf.clear5 to i32
  %cmp7 = icmp eq i32 %bf.cast6, 0
  br i1 %cmp7, label %if.then, label %lor.lhs.false.8

lor.lhs.false.8:                                  ; preds = %land.lhs.true.3, %lor.lhs.false
  %15 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false.8, %land.lhs.true.3, %cond.end
  %16 = load i64, i64* %data.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 394)
  %17 = load i64, i64* %context.addr, align 8
  %call10 = call i8* @SSDATA(i64 %17)
  %18 = load i64, i64* %signal.addr, align 8
  call void @print_error_message(i64 %16, i64 %call9, i8* %call10, i64 %18)
  %call11 = call i64 @builtin_lisp_symbol(i32 394)
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %call13 = call i64 @Fterpri(i64 %call11, i64 %call12)
  %19 = call i64 @Fkill_emacs(i64 -2) #11
  unreachable

if.else:                                          ; preds = %lor.lhs.false.8
  call void @clear_message(i1 zeroext true, i1 zeroext false)
  %call14 = call i64 @Fdiscard_input()
  call void @message_log_maybe_newline()
  call void @bitch_at_user()
  %20 = load i64, i64* %data.addr, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 901)
  %21 = load i64, i64* %context.addr, align 8
  %call16 = call i8* @SSDATA(i64 %21)
  %22 = load i64, i64* %signal.addr, align 8
  call void @print_error_message(i64 %20, i64 %call15, i8* %call16, i64 %22)
  br label %if.end

if.end:                                           ; preds = %if.else
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call17
}

declare void @CHECK_STRING(i64) #1

declare void @print_error_message(i64, i64, i8*, i64) #1

declare i8* @SSDATA(i64) #1

declare i64 @Fterpri(i64, i64) #1

; Function Attrs: noreturn
declare i64 @Fkill_emacs(i64) #2

declare void @clear_message(i1 zeroext, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Fdiscard_input() #0 {
entry:
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %defining_kbd_macro_ = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 9
  %1 = load i64, i64* %defining_kbd_macro_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @Fcancel_kbd_macro_events()
  call void @end_kbd_macro()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  call void @discard_tty_input()
  %2 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  store %union.buffered_input_event* %2, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store i8 0, i8* @input_pending, align 1
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

declare void @message_log_maybe_newline() #1

declare void @bitch_at_user() #1

; Function Attrs: noreturn nounwind uwtable
define i64 @Ftop_level() #3 {
entry:
  %retval = alloca i64, align 8
  %0 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 438), align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @cancel_hourglass()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  call void @totally_unblock_input()
  %call = call i64 @builtin_lisp_symbol(i32 930)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %1 = call i64 @Fthrow(i64 %call, i64 %call1) #11
  unreachable

return:                                           ; No predecessors!
  %2 = load i64, i64* %retval
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define void @totally_unblock_input() #0 {
entry:
  call void @unblock_input_to(i32 0)
  ret void
}

; Function Attrs: noreturn
declare i64 @Fthrow(i64, i64) #2

; Function Attrs: noreturn nounwind uwtable
define i64 @Fexit_recursive_edit() #3 {
entry:
  %retval = alloca i64, align 8
  %0 = load i64, i64* @command_loop_level, align 8
  %cmp = icmp sgt i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* @minibuf_level, align 8
  %cmp1 = icmp sgt i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call i64 @builtin_lisp_symbol(i32 387)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %2 = call i64 @Fthrow(i64 %call, i64 %call2) #11
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  call void @user_error(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0)) #11
  unreachable

return:                                           ; No predecessors!
  %3 = load i64, i64* %retval
  ret i64 %3
}

; Function Attrs: noreturn nounwind uwtable
define internal void @user_error(i8* %msg) #3 {
entry:
  %msg.addr = alloca i8*, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 981)
  %0 = load i8*, i8** %msg.addr, align 8
  %call1 = call i64 @build_string(i8* %0)
  call void @xsignal1(i64 %call, i64 %call1) #11
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define i64 @Fabort_recursive_edit() #3 {
entry:
  %retval = alloca i64, align 8
  %0 = load i64, i64* @command_loop_level, align 8
  %cmp = icmp sgt i64 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* @minibuf_level, align 8
  %cmp1 = icmp sgt i64 %1, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call i64 @builtin_lisp_symbol(i32 387)
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  %2 = call i64 @Fthrow(i64 %call, i64 %call2) #11
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  call void @user_error(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.1, i32 0, i32 0)) #11
  unreachable

return:                                           ; No predecessors!
  %3 = load i64, i64* %retval
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define i64 @Ftrack_mouse(i64 %bodyfun) #0 {
entry:
  %bodyfun.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %bodyfun, i64* %bodyfun.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  call void @record_unwind_protect(void (i64)* @tracking_off, i64 %0)
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %1 = load i64, i64* %bodyfun.addr, align 8
  %call2 = call i64 @call0(i64 %1)
  store i64 %call2, i64* %val, align 8
  %2 = load i64, i64* %count, align 8
  %3 = load i64, i64* %val, align 8
  %call3 = call i64 @unbind_to(i64 %2, i64 %3)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define internal void @tracking_off(i64 %old_value) #0 {
entry:
  %old_value.addr = alloca i64, align 8
  store i64 %old_value, i64* %old_value.addr, align 8
  %0 = load i64, i64* %old_value.addr, align 8
  store i64 %0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %1 = load i64, i64* %old_value.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end.4

if.then:                                          ; preds = %entry
  %call1 = call zeroext i1 @readable_events(i32 1)
  br i1 %call1, label %if.end, label %if.then.2

if.then.2:                                        ; preds = %if.then
  call void @redisplay_preserve_echo_area(i32 6)
  %call3 = call zeroext i1 @get_input_pending(i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then.2, %if.then
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %entry
  ret void
}

declare i64 @call0(i64) #1

; Function Attrs: nounwind uwtable
define i64 @command_loop_1() #0 {
entry:
  %prev_modiff = alloca i64, align 8
  %prev_buffer = alloca %struct.buffer*, align 8
  %already_adjusted = alloca i8, align 1
  %cmd = alloca i64, align 8
  %keybuf = alloca [30 x i64], align 16
  %i = alloca i32, align 4
  %count = alloca i64, align 8
  %b = alloca %struct.buffer*, align 8
  %scount = alloca i64, align 8
  %txt = alloca i64, align 8
  store i64 0, i64* %prev_modiff, align 8
  store %struct.buffer* null, %struct.buffer** %prev_buffer, align 8
  store i8 0, i8* %already_adjusted, align 1
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_prefix_arg(%struct.kboard* %0, i64 %call)
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_prefix_arg(%struct.kboard* %1, i64 %call1)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  store i8 0, i8* @waiting_for_input, align 1
  call void @cancel_echoing()
  store i64 0, i64* @this_command_key_count, align 8
  store i64 0, i64* @this_single_command_key_start, align 8
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 174), align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call3
  br i1 %cmp, label %if.then, label %if.end.24

if.then:                                          ; preds = %entry
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 219), align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %3, %call4
  br i1 %cmp5, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then
  %4 = load i64, i64* @Vrun_hooks, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %4, %call6
  br i1 %cmp7, label %if.end, label %if.then.8

if.then.8:                                        ; preds = %land.lhs.true
  %call9 = call i64 @builtin_lisp_symbol(i32 762)
  call void @safe_run_hooks(i64 %call9)
  br label %if.end

if.end:                                           ; preds = %if.then.8, %land.lhs.true, %if.then
  %5 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %5, %call10
  br i1 %cmp11, label %if.end.13, label %if.then.12

if.then.12:                                       ; preds = %if.end
  call void @resize_echo_area_exactly()
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 67), align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %6, %call14
  br i1 %cmp15, label %if.end.18, label %if.then.16

if.then.16:                                       ; preds = %if.end.13
  %call17 = call i64 @builtin_lisp_symbol(i32 329)
  call void @safe_run_hooks(i64 %call17)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %if.end.13
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 65), align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp20 = icmp eq i64 %7, %call19
  br i1 %cmp20, label %if.end.23, label %if.then.21

if.then.21:                                       ; preds = %if.end.18
  %call22 = call i64 @builtin_lisp_symbol(i32 326)
  call void @safe_run_hooks(i64 %call22)
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.21, %if.end.18
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %entry
  %8 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  call void @kset_last_command(%struct.kboard* %8, i64 %9)
  %10 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  call void @kset_real_last_command(%struct.kboard* %10, i64 %11)
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 375), align 8
  %and = and i64 %12, 7
  %conv = trunc i64 %and to i32
  %cmp25 = icmp eq i32 %conv, 3
  br i1 %cmp25, label %if.end.28, label %if.then.27

if.then.27:                                       ; preds = %if.end.24
  %13 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  call void @kset_last_repeatable_command(%struct.kboard* %13, i64 %14)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %if.end.24
  br label %while.body

while.body:                                       ; preds = %if.end.28, %if.end.357
  %15 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %15, 5
  %16 = inttoptr i64 %sub to i8*
  %17 = bitcast i8* %16 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %17, i32 0, i32 61
  %18 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp29 = icmp ne %struct.terminal* %18, null
  br i1 %cmp29, label %if.end.33, label %if.then.31

if.then.31:                                       ; preds = %while.body
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %19 = call i64 @Fkill_emacs(i64 %call32) #11
  unreachable

if.end.33:                                        ; preds = %while.body
  %20 = load i64, i64* @selected_window, align 8
  %call34 = call %struct.window* @XWINDOW(i64 %20)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call34, i32 0, i32 10
  %21 = load i64, i64* %contents, align 8
  %call35 = call %struct.buffer* @XBUFFER(i64 %21)
  call void @set_buffer_internal(%struct.buffer* %call35)
  br label %while.cond.36

while.cond.36:                                    ; preds = %while.body.37, %if.end.33
  %22 = load i8*, i8** @pending_malloc_warning, align 8
  %tobool = icmp ne i8* %22, null
  br i1 %tobool, label %while.body.37, label %while.end

while.body.37:                                    ; preds = %while.cond.36
  call void @display_malloc_warning()
  br label %while.cond.36

while.end:                                        ; preds = %while.cond.36
  %call38 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call38, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  store i8 0, i8* @ignore_mouse_drag_p, align 1
  %23 = load i64, i64* @minibuf_level, align 8
  %tobool39 = icmp ne i64 %23, 0
  br i1 %tobool39, label %land.lhs.true.40, label %if.end.66

land.lhs.true.40:                                 ; preds = %while.end
  %24 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp42 = icmp eq i64 %24, %call41
  br i1 %cmp42, label %if.end.66, label %land.lhs.true.44

land.lhs.true.44:                                 ; preds = %land.lhs.true.40
  %25 = load i64, i64* @minibuf_window, align 8
  %26 = load i64, i64* @echo_area_window, align 8
  %cmp45 = icmp eq i64 %25, %26
  br i1 %cmp45, label %land.lhs.true.47, label %if.end.66

land.lhs.true.47:                                 ; preds = %land.lhs.true.44
  %27 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 192), align 8
  %call48 = call zeroext i1 @NUMBERP(i64 %27)
  br i1 %call48, label %if.then.50, label %if.end.66

if.then.50:                                       ; preds = %land.lhs.true.47
  %call51 = call i64 @SPECPDL_INDEX()
  store i64 %call51, i64* %count, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 546)
  %call53 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call52, i64 %call53)
  %28 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 192), align 8
  %call54 = call i64 @sit_for(i64 %28, i1 zeroext false, i32 2)
  call void @message1(i8* null)
  %call55 = call i64 @builtin_lisp_symbol(i32 355)
  call void @safe_run_hooks(i64 %call55)
  %29 = load i64, i64* %count, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  %call57 = call i64 @unbind_to(i64 %29, i64 %call56)
  %30 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp59 = icmp eq i64 %30, %call58
  br i1 %cmp59, label %if.end.65, label %if.then.61

if.then.61:                                       ; preds = %if.then.50
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call62, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %31 = load i32, i32* @quit_char, align 4
  %conv63 = sext i32 %31 to i64
  %shl = shl i64 %conv63, 2
  %add = add i64 %shl, 2
  %call64 = call i64 @list1(i64 %add)
  store i64 %call64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  br label %if.end.65

if.end.65:                                        ; preds = %if.then.61, %if.then.50
  br label %if.end.66

if.end.66:                                        ; preds = %if.end.65, %land.lhs.true.47, %land.lhs.true.44, %land.lhs.true.40, %while.end
  %32 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 169), align 8
  %call67 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp68 = icmp eq i64 %32, %call67
  br i1 %cmp68, label %if.end.79, label %land.lhs.true.70

land.lhs.true.70:                                 ; preds = %if.end.66
  %call71 = call i64 @builtin_lisp_symbol(i32 795)
  %call72 = call i64 @Ffboundp(i64 %call71)
  %call73 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp74 = icmp eq i64 %call72, %call73
  br i1 %cmp74, label %if.end.79, label %if.then.76

if.then.76:                                       ; preds = %land.lhs.true.70
  %call77 = call i64 @builtin_lisp_symbol(i32 795)
  %call78 = call i64 @call0(i64 %call77)
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.76, %land.lhs.true.70, %if.end.66
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call80, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call81, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  %call82 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call82, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 295), align 8
  %call83 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call83, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 294), align 8
  %arraydecay = getelementptr inbounds [30 x i64], [30 x i64]* %keybuf, i32 0, i32 0
  %call84 = call i64 @builtin_lisp_symbol(i32 0)
  %call85 = call i32 @read_key_sequence(i64* %arraydecay, i32 30, i64 %call84, i1 zeroext false, i1 zeroext true, i1 zeroext true, i1 zeroext false)
  store i32 %call85, i32* %i, align 4
  %33 = load i64, i64* @selected_frame, align 8
  %sub86 = sub nsw i64 %33, 5
  %34 = inttoptr i64 %sub86 to i8*
  %35 = bitcast i8* %34 to %struct.frame*
  %terminal87 = getelementptr inbounds %struct.frame, %struct.frame* %35, i32 0, i32 61
  %36 = load %struct.terminal*, %struct.terminal** %terminal87, align 8
  %cmp88 = icmp ne %struct.terminal* %36, null
  br i1 %cmp88, label %if.end.92, label %if.then.90

if.then.90:                                       ; preds = %if.end.79
  %call91 = call i64 @builtin_lisp_symbol(i32 0)
  %37 = call i64 @Fkill_emacs(i64 %call91) #11
  unreachable

if.end.92:                                        ; preds = %if.end.79
  %38 = load i64, i64* @selected_window, align 8
  %call93 = call %struct.window* @XWINDOW(i64 %38)
  %contents94 = getelementptr inbounds %struct.window, %struct.window* %call93, i32 0, i32 10
  %39 = load i64, i64* %contents94, align 8
  %call95 = call %struct.buffer* @XBUFFER(i64 %39)
  call void @set_buffer_internal(%struct.buffer* %call95)
  %40 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 400), align 8
  %inc = add nsw i64 %40, 1
  store i64 %inc, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 400), align 8
  %41 = load i32, i32* %i, align 4
  %cmp96 = icmp eq i32 %41, 0
  br i1 %cmp96, label %if.then.98, label %if.end.100

if.then.98:                                       ; preds = %if.end.92
  %call99 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call99

if.end.100:                                       ; preds = %if.end.92
  %42 = load i32, i32* %i, align 4
  %cmp101 = icmp eq i32 %42, -1
  br i1 %cmp101, label %if.then.103, label %if.end.104

if.then.103:                                      ; preds = %if.end.100
  call void @cancel_echoing()
  store i64 0, i64* @this_command_key_count, align 8
  store i64 0, i64* @this_single_command_key_start, align 8
  br label %finalize

if.end.104:                                       ; preds = %if.end.100
  %43 = load i32, i32* %i, align 4
  %sub105 = sub nsw i32 %43, 1
  %idxprom = sext i32 %sub105 to i64
  %arrayidx = getelementptr inbounds [30 x i64], [30 x i64]* %keybuf, i32 0, i64 %idxprom
  %44 = load i64, i64* %arrayidx, align 8
  store i64 %44, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 375), align 8
  %45 = load i64, i64* @selected_window, align 8
  %call106 = call %struct.window* @XWINDOW(i64 %45)
  %force_start = getelementptr inbounds %struct.window, %struct.window* %call106, i32 0, i32 67
  %bf.load = load i16, i16* %force_start, align 4
  %bf.lshr = lshr i16 %bf.load, 5
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.then.107, label %if.end.116

if.then.107:                                      ; preds = %if.end.104
  %46 = load i64, i64* @selected_window, align 8
  %call108 = call %struct.window* @XWINDOW(i64 %46)
  %force_start109 = getelementptr inbounds %struct.window, %struct.window* %call108, i32 0, i32 67
  %bf.load110 = load i16, i16* %force_start109, align 4
  %bf.clear111 = and i16 %bf.load110, -33
  store i16 %bf.clear111, i16* %force_start109, align 4
  %47 = load i64, i64* @selected_window, align 8
  %call112 = call %struct.window* @XWINDOW(i64 %47)
  %contents113 = getelementptr inbounds %struct.window, %struct.window* %call112, i32 0, i32 10
  %48 = load i64, i64* %contents113, align 8
  %call114 = call %struct.buffer* @XBUFFER(i64 %48)
  store %struct.buffer* %call114, %struct.buffer** %b, align 8
  %49 = load %struct.buffer*, %struct.buffer** %b, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 73
  %50 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %end_unchanged = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %50, i32 0, i32 12
  store i64 0, i64* %end_unchanged, align 8
  %51 = load %struct.buffer*, %struct.buffer** %b, align 8
  %text115 = getelementptr inbounds %struct.buffer, %struct.buffer* %51, i32 0, i32 73
  %52 = load %struct.buffer_text*, %struct.buffer_text** %text115, align 8
  %beg_unchanged = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %52, i32 0, i32 11
  store i64 0, i64* %beg_unchanged, align 8
  br label %if.end.116

if.end.116:                                       ; preds = %if.then.107, %if.end.104
  %53 = load i64, i64* @read_key_sequence_cmd, align 8
  store i64 %53, i64* %cmd, align 8
  %54 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call117 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp118 = icmp eq i64 %54, %call117
  br i1 %cmp118, label %if.end.139, label %if.then.120

if.then.120:                                      ; preds = %if.end.116
  %55 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call121 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp122 = icmp eq i64 %55, %call121
  br i1 %cmp122, label %if.end.138, label %if.then.124

if.then.124:                                      ; preds = %if.then.120
  %call125 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call125, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  br label %do.body

do.body:                                          ; preds = %if.then.124
  %56 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call126 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp127 = icmp eq i64 %56, %call126
  br i1 %cmp127, label %if.else, label %land.lhs.true.129

land.lhs.true.129:                                ; preds = %do.body
  %57 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call130 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp131 = icmp eq i64 %57, %call130
  br i1 %cmp131, label %if.then.133, label %if.else

if.then.133:                                      ; preds = %land.lhs.true.129
  call void @process_quit_flag()
  br label %if.end.137

if.else:                                          ; preds = %land.lhs.true.129, %do.body
  %58 = load volatile i8, i8* @pending_signals, align 1
  %tobool134 = trunc i8 %58 to i1
  br i1 %tobool134, label %if.then.135, label %if.end.136

if.then.135:                                      ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.136

if.end.136:                                       ; preds = %if.then.135, %if.else
  br label %if.end.137

if.end.137:                                       ; preds = %if.end.136, %if.then.133
  br label %do.end

do.end:                                           ; preds = %if.end.137
  br label %if.end.138

if.end.138:                                       ; preds = %do.end, %if.then.120
  br label %if.end.139

if.end.139:                                       ; preds = %if.end.138, %if.end.116
  %59 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %59, %struct.buffer** %prev_buffer, align 8
  %60 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text140 = getelementptr inbounds %struct.buffer, %struct.buffer* %60, i32 0, i32 73
  %61 = load %struct.buffer_text*, %struct.buffer_text** %text140, align 8
  %modiff = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %61, i32 0, i32 6
  %62 = load i64, i64* %modiff, align 8
  store i64 %62, i64* %prev_modiff, align 8
  %63 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 75
  %64 = load i64, i64* %pt, align 8
  %add141 = add nsw i64 %64, 0
  store i64 %add141, i64* @last_point_position, align 8
  %call142 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call142, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 70), align 8
  %call143 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call143, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %65 = load i64, i64* %cmd, align 8
  store i64 %65, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 295), align 8
  %66 = load i64, i64* @read_key_sequence_remapped, align 8
  %call144 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp145 = icmp eq i64 %66, %call144
  br i1 %cmp145, label %if.end.148, label %if.then.147

if.then.147:                                      ; preds = %if.end.139
  %67 = load i64, i64* @read_key_sequence_remapped, align 8
  store i64 %67, i64* %cmd, align 8
  br label %if.end.148

if.end.148:                                       ; preds = %if.then.147, %if.end.139
  %68 = load i32, i32* @total_keys, align 4
  %cmp149 = icmp slt i32 %68, 300
  %conv150 = zext i1 %cmp149 to i32
  %69 = load i32, i32* @total_keys, align 4
  %add151 = add nsw i32 %69, %conv150
  store i32 %add151, i32* @total_keys, align 4
  %70 = load i64, i64* @recent_keys, align 8
  %71 = load i32, i32* @recent_keys_index, align 4
  %conv152 = sext i32 %71 to i64
  %call153 = call i64 @builtin_lisp_symbol(i32 0)
  %72 = load i64, i64* %cmd, align 8
  %call154 = call i64 @Fcons(i64 %call153, i64 %72)
  call void @ASET(i64 %70, i64 %conv152, i64 %call154)
  %73 = load i32, i32* @recent_keys_index, align 4
  %inc155 = add nsw i32 %73, 1
  store i32 %inc155, i32* @recent_keys_index, align 4
  %cmp156 = icmp sge i32 %inc155, 300
  br i1 %cmp156, label %if.then.158, label %if.end.159

if.then.158:                                      ; preds = %if.end.148
  store i32 0, i32* @recent_keys_index, align 4
  br label %if.end.159

if.end.159:                                       ; preds = %if.then.158, %if.end.148
  %74 = load i64, i64* %cmd, align 8
  store i64 %74, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  %75 = load i64, i64* %cmd, align 8
  store i64 %75, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  %call160 = call i64 @builtin_lisp_symbol(i32 767)
  call void @safe_run_hooks(i64 %call160)
  store i8 0, i8* %already_adjusted, align 1
  %76 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  %call161 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp162 = icmp eq i64 %76, %call161
  br i1 %cmp162, label %if.then.164, label %if.else.167

if.then.164:                                      ; preds = %if.end.159
  %call165 = call i64 @builtin_lisp_symbol(i32 959)
  %call166 = call i64 @call0(i64 %call165)
  br label %if.end.190

if.else.167:                                      ; preds = %if.end.159
  %call168 = call i64 @SPECPDL_INDEX()
  store i64 %call168, i64* %scount, align 8
  %77 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 438), align 1
  %tobool169 = trunc i8 %77 to i1
  br i1 %tobool169, label %land.lhs.true.171, label %if.end.176

land.lhs.true.171:                                ; preds = %if.else.167
  %78 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call172 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp173 = icmp eq i64 %78, %call172
  br i1 %cmp173, label %if.then.175, label %if.end.176

if.then.175:                                      ; preds = %land.lhs.true.171
  call void @record_unwind_protect_void(void ()* @cancel_hourglass)
  call void @start_hourglass()
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.175, %land.lhs.true.171, %if.else.167
  %call177 = call i64 @builtin_lisp_symbol(i32 962)
  %call178 = call i64 @call0(i64 %call177)
  %79 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt179 = getelementptr inbounds %struct.buffer, %struct.buffer* %79, i32 0, i32 75
  %80 = load i64, i64* %pt179, align 8
  %add180 = add nsw i64 %80, 0
  store i64 %add180, i64* @point_before_last_command_or_undo, align 8
  %81 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %81, %struct.buffer** @buffer_before_last_command_or_undo, align 8
  %call181 = call i64 @builtin_lisp_symbol(i32 285)
  %82 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  %call182 = call i64 @call1(i64 %call181, i64 %82)
  %83 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call183 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp184 = icmp eq i64 %83, %call183
  br i1 %cmp184, label %if.then.186, label %if.end.189

if.then.186:                                      ; preds = %if.end.176
  %84 = load i64, i64* %scount, align 8
  %call187 = call i64 @builtin_lisp_symbol(i32 0)
  %call188 = call i64 @unbind_to(i64 %84, i64 %call187)
  br label %if.end.189

if.end.189:                                       ; preds = %if.then.186, %if.end.176
  br label %if.end.190

if.end.190:                                       ; preds = %if.end.189, %if.then.164
  %85 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %86 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 50), align 8
  call void @kset_last_prefix_arg(%struct.kboard* %85, i64 %86)
  %call191 = call i64 @builtin_lisp_symbol(i32 762)
  call void @safe_run_hooks(i64 %call191)
  %87 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call192 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp193 = icmp eq i64 %87, %call192
  br i1 %cmp193, label %if.end.196, label %if.then.195

if.then.195:                                      ; preds = %if.end.190
  call void @resize_echo_area_exactly()
  br label %if.end.196

if.end.196:                                       ; preds = %if.then.195, %if.end.190
  %88 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 67), align 8
  %call197 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp198 = icmp eq i64 %88, %call197
  br i1 %cmp198, label %if.end.202, label %if.then.200

if.then.200:                                      ; preds = %if.end.196
  %call201 = call i64 @builtin_lisp_symbol(i32 329)
  call void @safe_run_hooks(i64 %call201)
  br label %if.end.202

if.end.202:                                       ; preds = %if.then.200, %if.end.196
  %call203 = call i64 @builtin_lisp_symbol(i32 326)
  call void @safe_run_hooks(i64 %call203)
  %89 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %90 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  call void @kset_last_command(%struct.kboard* %89, i64 %90)
  %91 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %92 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  call void @kset_real_last_command(%struct.kboard* %91, i64 %92)
  %93 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 375), align 8
  %and204 = and i64 %93, 7
  %conv205 = trunc i64 %and204 to i32
  %cmp206 = icmp eq i32 %conv205, 3
  br i1 %cmp206, label %if.end.209, label %if.then.208

if.then.208:                                      ; preds = %if.end.202
  %94 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %95 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  call void @kset_last_repeatable_command(%struct.kboard* %94, i64 %95)
  br label %if.end.209

if.end.209:                                       ; preds = %if.then.208, %if.end.202
  store i64 0, i64* @this_command_key_count, align 8
  store i64 0, i64* @this_single_command_key_start, align 8
  %96 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %96, i32 0, i32 24
  %bf.load210 = load i8, i8* %immediate_echo, align 1
  %bf.clear211 = and i8 %bf.load210, 1
  %bf.cast212 = trunc i8 %bf.clear211 to i1
  br i1 %bf.cast212, label %land.lhs.true.214, label %if.else.224

land.lhs.true.214:                                ; preds = %if.end.209
  %call215 = call i64 @builtin_lisp_symbol(i32 566)
  %call216 = call i64 @call0(i64 %call215)
  %call217 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp218 = icmp eq i64 %call216, %call217
  br i1 %cmp218, label %if.else.224, label %if.then.220

if.then.220:                                      ; preds = %land.lhs.true.214
  %97 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo221 = getelementptr inbounds %struct.kboard, %struct.kboard* %97, i32 0, i32 24
  %bf.load222 = load i8, i8* %immediate_echo221, align 1
  %bf.clear223 = and i8 %bf.load222, -2
  store i8 %bf.clear223, i8* %immediate_echo221, align 1
  call void @echo_now()
  br label %if.end.225

if.else.224:                                      ; preds = %land.lhs.true.214, %if.end.209
  call void @cancel_echoing()
  br label %if.end.225

if.end.225:                                       ; preds = %if.else.224, %if.then.220
  %98 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %mark_active_ = getelementptr inbounds %struct.buffer, %struct.buffer* %98, i32 0, i32 38
  %99 = load i64, i64* %mark_active_, align 8
  %call226 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp227 = icmp eq i64 %99, %call226
  br i1 %cmp227, label %if.end.307, label %land.lhs.true.229

land.lhs.true.229:                                ; preds = %if.end.225
  %100 = load i64, i64* @Vrun_hooks, align 8
  %call230 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp231 = icmp eq i64 %100, %call230
  br i1 %cmp231, label %if.end.307, label %if.then.233

if.then.233:                                      ; preds = %land.lhs.true.229
  %101 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  %call234 = call i64 @builtin_lisp_symbol(i32 534)
  %cmp235 = icmp eq i64 %101, %call234
  br i1 %cmp235, label %if.then.237, label %if.else.239

if.then.237:                                      ; preds = %if.then.233
  %call238 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call238, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  br label %if.end.246

if.else.239:                                      ; preds = %if.then.233
  %102 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  %call240 = call i64 @builtin_lisp_symbol(i32 717)
  %cmp241 = icmp eq i64 %102, %call240
  br i1 %cmp241, label %if.then.243, label %if.end.245

if.then.243:                                      ; preds = %if.else.239
  %call244 = call i64 @builtin_lisp_symbol(i32 534)
  store i64 %call244, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  br label %if.end.245

if.end.245:                                       ; preds = %if.then.243, %if.else.239
  br label %if.end.246

if.end.246:                                       ; preds = %if.end.245, %if.then.237
  %103 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %call247 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp248 = icmp eq i64 %103, %call247
  br i1 %cmp248, label %if.else.253, label %if.then.250

if.then.250:                                      ; preds = %if.end.246
  %call251 = call i64 @builtin_lisp_symbol(i32 319)
  %call252 = call i64 @call0(i64 %call251)
  br label %if.end.305

if.else.253:                                      ; preds = %if.end.246
  %call254 = call i64 @builtin_lisp_symbol(i32 0)
  %call255 = call i64 @Fwindow_system(i64 %call254)
  %call256 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp257 = icmp eq i64 %call255, %call256
  br i1 %cmp257, label %if.end.295, label %land.lhs.true.259

land.lhs.true.259:                                ; preds = %if.else.253
  %104 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %mark_ = getelementptr inbounds %struct.buffer, %struct.buffer* %104, i32 0, i32 8
  %105 = load i64, i64* %mark_, align 8
  %call260 = call %struct.Lisp_Marker* @XMARKER(i64 %105)
  %buffer = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call260, i32 0, i32 1
  %106 = load %struct.buffer*, %struct.buffer** %buffer, align 8
  %tobool261 = icmp ne %struct.buffer* %106, null
  br i1 %tobool261, label %land.lhs.true.262, label %if.end.295

land.lhs.true.262:                                ; preds = %land.lhs.true.259
  %107 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 263), align 8
  %call263 = call i64 @builtin_lisp_symbol(i32 717)
  %cmp264 = icmp eq i64 %107, %call263
  br i1 %cmp264, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.262
  %108 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  %call266 = call i64 @CAR_SAFE(i64 %108)
  %call267 = call i64 @builtin_lisp_symbol(i32 717)
  %cmp268 = icmp eq i64 %call266, %call267
  br i1 %cmp268, label %land.lhs.true.277, label %if.end.295

cond.false:                                       ; preds = %land.lhs.true.262
  %109 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 263), align 8
  %call270 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp271 = icmp eq i64 %109, %call270
  br i1 %cmp271, label %if.end.295, label %land.lhs.true.273

land.lhs.true.273:                                ; preds = %cond.false
  %110 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  %call274 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp275 = icmp eq i64 %110, %call274
  br i1 %cmp275, label %if.end.295, label %land.lhs.true.277

land.lhs.true.277:                                ; preds = %land.lhs.true.273, %cond.true
  %111 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  %112 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 266), align 8
  %call278 = call i64 @Fmemq(i64 %111, i64 %112)
  %call279 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp280 = icmp eq i64 %call278, %call279
  br i1 %cmp280, label %if.then.282, label %if.end.295

if.then.282:                                      ; preds = %land.lhs.true.277
  %call283 = call i64 @builtin_lisp_symbol(i32 801)
  %call284 = call i64 @Fsymbol_value(i64 %call283)
  %call285 = call i64 @builtin_lisp_symbol(i32 0)
  %call286 = call i64 @call1(i64 %call284, i64 %call285)
  store i64 %call286, i64* %txt, align 8
  %113 = load i64, i64* %txt, align 8
  %call287 = call i64 @Flength(i64 %113)
  %shr = ashr i64 %call287, 2
  %cmp288 = icmp sgt i64 %shr, 0
  br i1 %cmp288, label %if.then.290, label %if.end.294

if.then.290:                                      ; preds = %if.then.282
  %call291 = call i64 @builtin_lisp_symbol(i32 503)
  %call292 = call i64 @builtin_lisp_symbol(i32 147)
  %114 = load i64, i64* %txt, align 8
  %call293 = call i64 @call2(i64 %call291, i64 %call292, i64 %114)
  br label %if.end.294

if.end.294:                                       ; preds = %if.then.290, %if.then.282
  br label %if.end.295

if.end.295:                                       ; preds = %if.end.294, %land.lhs.true.277, %land.lhs.true.273, %cond.false, %cond.true, %land.lhs.true.259, %if.else.253
  %115 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %116 = load %struct.buffer*, %struct.buffer** %prev_buffer, align 8
  %cmp296 = icmp ne %struct.buffer* %115, %116
  br i1 %cmp296, label %if.then.302, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.295
  %117 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text298 = getelementptr inbounds %struct.buffer, %struct.buffer* %117, i32 0, i32 73
  %118 = load %struct.buffer_text*, %struct.buffer_text** %text298, align 8
  %modiff299 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %118, i32 0, i32 6
  %119 = load i64, i64* %modiff299, align 8
  %120 = load i64, i64* %prev_modiff, align 8
  %cmp300 = icmp ne i64 %119, %120
  br i1 %cmp300, label %if.then.302, label %if.end.304

if.then.302:                                      ; preds = %lor.lhs.false, %if.end.295
  %call303 = call i64 @intern(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.2, i32 0, i32 0))
  call void @run_hook(i64 %call303)
  br label %if.end.304

if.end.304:                                       ; preds = %if.then.302, %lor.lhs.false
  br label %if.end.305

if.end.305:                                       ; preds = %if.end.304, %if.then.250
  %call306 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call306, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 258), align 8
  br label %if.end.307

if.end.307:                                       ; preds = %if.end.305, %land.lhs.true.229, %if.end.225
  br label %finalize

finalize:                                         ; preds = %if.end.307, %if.then.103
  %121 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %122 = load %struct.buffer*, %struct.buffer** %prev_buffer, align 8
  %cmp308 = icmp eq %struct.buffer* %121, %122
  br i1 %cmp308, label %land.lhs.true.310, label %if.end.348

land.lhs.true.310:                                ; preds = %finalize
  %123 = load i64, i64* @selected_window, align 8
  %call311 = call %struct.window* @XWINDOW(i64 %123)
  %contents312 = getelementptr inbounds %struct.window, %struct.window* %call311, i32 0, i32 10
  %124 = load i64, i64* %contents312, align 8
  %call313 = call %struct.buffer* @XBUFFER(i64 %124)
  %125 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp314 = icmp eq %struct.buffer* %call313, %125
  br i1 %cmp314, label %land.lhs.true.316, label %if.end.348

land.lhs.true.316:                                ; preds = %land.lhs.true.310
  %126 = load i64, i64* @last_point_position, align 8
  %127 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt317 = getelementptr inbounds %struct.buffer, %struct.buffer* %127, i32 0, i32 75
  %128 = load i64, i64* %pt317, align 8
  %add318 = add nsw i64 %128, 0
  %cmp319 = icmp ne i64 %126, %add318
  br i1 %cmp319, label %land.lhs.true.321, label %if.end.348

land.lhs.true.321:                                ; preds = %land.lhs.true.316
  %129 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 70), align 8
  %call322 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp323 = icmp eq i64 %129, %call322
  br i1 %cmp323, label %land.lhs.true.325, label %if.end.348

land.lhs.true.325:                                ; preds = %land.lhs.true.321
  %130 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 116), align 8
  %call326 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp327 = icmp eq i64 %130, %call326
  br i1 %cmp327, label %if.then.329, label %if.end.348

if.then.329:                                      ; preds = %land.lhs.true.325
  %131 = load i64, i64* @last_point_position, align 8
  %132 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %132, i32 0, i32 77
  %133 = load i64, i64* %begv, align 8
  %cmp330 = icmp sgt i64 %131, %133
  br i1 %cmp330, label %land.lhs.true.332, label %if.end.340

land.lhs.true.332:                                ; preds = %if.then.329
  %134 = load i64, i64* @last_point_position, align 8
  %135 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %135, i32 0, i32 79
  %136 = load i64, i64* %zv, align 8
  %cmp333 = icmp slt i64 %134, %136
  br i1 %cmp333, label %land.lhs.true.335, label %if.end.340

land.lhs.true.335:                                ; preds = %land.lhs.true.332
  %137 = load i64, i64* @last_point_position, align 8
  %138 = load i64, i64* @last_point_position, align 8
  %call336 = call i64 @composition_adjust_point(i64 %137, i64 %138)
  %139 = load i64, i64* @last_point_position, align 8
  %cmp337 = icmp ne i64 %call336, %139
  br i1 %cmp337, label %if.then.339, label %if.end.340

if.then.339:                                      ; preds = %land.lhs.true.335
  store i32 21, i32* @windows_or_buffers_changed, align 4
  br label %if.end.340

if.end.340:                                       ; preds = %if.then.339, %land.lhs.true.335, %land.lhs.true.332, %if.then.329
  %140 = load i8, i8* %already_adjusted, align 1
  %tobool341 = trunc i8 %140 to i1
  br i1 %tobool341, label %if.end.347, label %if.then.342

if.then.342:                                      ; preds = %if.end.340
  %141 = load i64, i64* @last_point_position, align 8
  %142 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text343 = getelementptr inbounds %struct.buffer, %struct.buffer* %142, i32 0, i32 73
  %143 = load %struct.buffer_text*, %struct.buffer_text** %text343, align 8
  %modiff344 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %143, i32 0, i32 6
  %144 = load i64, i64* %modiff344, align 8
  %145 = load i64, i64* %prev_modiff, align 8
  %cmp345 = icmp ne i64 %144, %145
  call void @adjust_point_for_property(i64 %141, i1 zeroext %cmp345)
  br label %if.end.347

if.end.347:                                       ; preds = %if.then.342, %if.end.340
  br label %if.end.348

if.end.348:                                       ; preds = %if.end.347, %land.lhs.true.325, %land.lhs.true.321, %land.lhs.true.316, %land.lhs.true.310, %finalize
  %146 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %defining_kbd_macro_ = getelementptr inbounds %struct.kboard, %struct.kboard* %146, i32 0, i32 9
  %147 = load i64, i64* %defining_kbd_macro_, align 8
  %call349 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp350 = icmp eq i64 %147, %call349
  br i1 %cmp350, label %if.end.357, label %land.lhs.true.352

land.lhs.true.352:                                ; preds = %if.end.348
  %148 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vprefix_arg_ = getelementptr inbounds %struct.kboard, %struct.kboard* %148, i32 0, i32 6
  %149 = load i64, i64* %Vprefix_arg_, align 8
  %call353 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp354 = icmp eq i64 %149, %call353
  br i1 %cmp354, label %if.then.356, label %if.end.357

if.then.356:                                      ; preds = %land.lhs.true.352
  call void @finalize_kbd_macro_chars()
  br label %if.end.357

if.end.357:                                       ; preds = %if.then.356, %land.lhs.true.352, %if.end.348
  br label %while.body
}

declare void @kset_prefix_arg(%struct.kboard*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @kset_last_prefix_arg(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vlast_prefix_arg_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 7
  store i64 %0, i64* %Vlast_prefix_arg_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @safe_run_hooks(i64 %hook) #0 {
entry:
  %hook.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %hook, i64* %hook.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 546)
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call1, i64 %call2)
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %hook.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %hook.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call3 = call i64 @run_hook_with_args(i64 2, i64* %arraydecay, i64 (i64, i64*)* @safe_run_hook_funcall)
  %2 = load i64, i64* %count, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %call5 = call i64 @unbind_to(i64 %2, i64 %call4)
  ret void
}

declare void @resize_echo_area_exactly() #1

declare void @kset_last_command(%struct.kboard*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @kset_real_last_command(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vreal_last_command_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 3
  store i64 %0, i64* %Vreal_last_command_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @kset_last_repeatable_command(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vlast_repeatable_command_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 5
  store i64 %0, i64* %Vlast_repeatable_command_, align 8
  ret void
}

declare void @set_buffer_internal(%struct.buffer*) #1

declare void @display_malloc_warning() #1

declare zeroext i1 @NUMBERP(i64) #1

declare i64 @sit_for(i64, i1 zeroext, i32) #1

declare void @message1(i8*) #1

declare i64 @list1(i64) #1

declare i64 @Ffboundp(i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @read_key_sequence(i64* %keybuf, i32 %bufsize, i64 %prompt, i1 zeroext %dont_downcase_last, i1 zeroext %can_return_switch_frame, i1 zeroext %fix_current_buffer, i1 zeroext %prevent_redisplay) #0 {
entry:
  %retval = alloca i32, align 4
  %keybuf.addr = alloca i64*, align 8
  %bufsize.addr = alloca i32, align 4
  %prompt.addr = alloca i64, align 8
  %dont_downcase_last.addr = alloca i8, align 1
  %can_return_switch_frame.addr = alloca i8, align 1
  %fix_current_buffer.addr = alloca i8, align 1
  %prevent_redisplay.addr = alloca i8, align 1
  %count = alloca i64, align 8
  %t = alloca i32, align 4
  %echo_start = alloca i64, align 8
  %keys_start = alloca i64, align 8
  %current_binding = alloca i64, align 8
  %first_event = alloca i64, align 8
  %first_unbound = alloca i32, align 4
  %mock_input = alloca i32, align 4
  %fkey = alloca %struct.keyremap, align 8
  %keytran = alloca %struct.keyremap, align 8
  %indec = alloca %struct.keyremap, align 8
  %shift_translated = alloca i8, align 1
  %delayed_switch_frame = alloca i64, align 8
  %original_uppercase = alloca i64, align 8
  %original_uppercase_position = alloca i32, align 4
  %dummyflag = alloca i8, align 1
  %starting_buffer = alloca %struct.buffer*, align 8
  %fake_prefixed_keys = alloca i64, align 8
  %key = alloca i64, align 8
  %used_mouse_menu = alloca i8, align 1
  %last_real_key_start = alloca i32, align 4
  %echo_local_start = alloca i64, align 8
  %keys_local_start = alloca i32, align 4
  %new_binding = alloca i64, align 8
  %i = alloca i32, align 4
  %interrupted_kboard = alloca %struct.kboard*, align 8
  %interrupted_frame = alloca %struct.frame*, align 8
  %found = alloca i8, align 1
  %k = alloca %struct.kboard*, align 8
  %frame = alloca i64, align 8
  %kind = alloca i64, align 8
  %window = alloca i64, align 8
  %posn = alloca i64, align 8
  %posn480 = alloca i64, align 8
  %head = alloca i64, align 8
  %breakdown = alloca i64, align 8
  %modifiers = alloca i32, align 4
  %new_head = alloca i64, align 8
  %new_click = alloca i64, align 8
  %done = alloca i8, align 1
  %diff = alloca i32, align 4
  %done730 = alloca i8, align 1
  %diff731 = alloca i32, align 4
  %done770 = alloca i8, align 1
  %diff771 = alloca i32, align 4
  %new_key = alloca i64, align 8
  %breakdown896 = alloca i64, align 8
  %modifiers898 = alloca i32, align 4
  %new_key935 = alloca i64, align 8
  store i64* %keybuf, i64** %keybuf.addr, align 8
  store i32 %bufsize, i32* %bufsize.addr, align 4
  store i64 %prompt, i64* %prompt.addr, align 8
  %frombool = zext i1 %dont_downcase_last to i8
  store i8 %frombool, i8* %dont_downcase_last.addr, align 1
  %frombool1 = zext i1 %can_return_switch_frame to i8
  store i8 %frombool1, i8* %can_return_switch_frame.addr, align 1
  %frombool2 = zext i1 %fix_current_buffer to i8
  store i8 %frombool2, i8* %fix_current_buffer.addr, align 1
  %frombool3 = zext i1 %prevent_redisplay to i8
  store i8 %frombool3, i8* %prevent_redisplay.addr, align 1
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4, i64* %current_binding, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* %first_event, align 8
  store i32 0, i32* %mock_input, align 4
  store i8 0, i8* %shift_translated, align 1
  store i32 -1, i32* %original_uppercase_position, align 4
  store i8 0, i8* %dummyflag, align 1
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* %fake_prefixed_keys, align 8
  store i32 0, i32* @raw_keybuf_count, align 4
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call7, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call8, i64* %delayed_switch_frame, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call9
  br i1 %cmp, label %land.lhs.true, label %if.end.24

land.lhs.true:                                    ; preds = %entry
  %1 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end.24, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %prompt.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %2, %call10
  br i1 %cmp11, label %if.else, label %if.then.12

if.then.12:                                       ; preds = %if.then
  %3 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %4 = load i64, i64* %prompt.addr, align 8
  call void @kset_echo_prompt(%struct.kboard* %3, i64 %4)
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %5, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %immediate_echo, align 1
  call void @echo_now()
  %call13 = call zeroext i1 @echo_keystrokes_p()
  br i1 %call13, label %if.end, label %if.then.14

if.then.14:                                       ; preds = %if.then.12
  %6 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo15 = getelementptr inbounds %struct.kboard, %struct.kboard* %6, i32 0, i32 24
  %bf.load16 = load i8, i8* %immediate_echo15, align 1
  %bf.clear17 = and i8 %bf.load16, -2
  store i8 %bf.clear17, i8* %immediate_echo15, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.14, %if.then.12
  br label %if.end.23

if.else:                                          ; preds = %if.then
  %7 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 431), align 1
  %tobool18 = trunc i8 %7 to i1
  br i1 %tobool18, label %land.lhs.true.19, label %if.end.22

land.lhs.true.19:                                 ; preds = %if.else
  %call20 = call zeroext i1 @echo_keystrokes_p()
  br i1 %call20, label %if.then.21, label %if.end.22

if.then.21:                                       ; preds = %land.lhs.true.19
  call void @echo_dash()
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.21, %land.lhs.true.19, %if.else
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.22, %if.end
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %land.lhs.true, %entry
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %8, %call25
  br i1 %cmp26, label %land.lhs.true.27, label %if.end.31

land.lhs.true.27:                                 ; preds = %if.end.24
  %9 = load i8, i8* @noninteractive, align 1
  %tobool28 = trunc i8 %9 to i1
  br i1 %tobool28, label %if.end.31, label %if.then.29

if.then.29:                                       ; preds = %land.lhs.true.27
  %call30 = call i64 @echo_length()
  store i64 %call30, i64* %echo_start, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %land.lhs.true.27, %if.end.24
  %10 = load i64, i64* @this_command_key_count, align 8
  store i64 %10, i64* %keys_start, align 8
  %11 = load i64, i64* %keys_start, align 8
  store i64 %11, i64* @this_single_command_key_start, align 8
  br label %replay_entire_sequence

replay_entire_sequence:                           ; preds = %if.end.219, %if.then.167, %if.end.31
  %12 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vinput_decode_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %12, i32 0, i32 19
  %13 = load i64, i64* %Vinput_decode_map_, align 8
  %parent = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 0
  store i64 %13, i64* %parent, align 8
  %map = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 1
  store i64 %13, i64* %map, align 8
  %14 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vlocal_function_key_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %14, i32 0, i32 18
  %15 = load i64, i64* %Vlocal_function_key_map_, align 8
  %parent32 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 0
  store i64 %15, i64* %parent32, align 8
  %map33 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 1
  store i64 %15, i64* %map33, align 8
  %16 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 151), align 8
  %parent34 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 0
  store i64 %16, i64* %parent34, align 8
  %map35 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 1
  store i64 %16, i64* %map35, align 8
  %end = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  store i32 0, i32* %end, align 4
  %start = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  store i32 0, i32* %start, align 4
  %end36 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  store i32 0, i32* %end36, align 4
  %start37 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  store i32 0, i32* %start37, align 4
  %end38 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  store i32 0, i32* %end38, align 4
  %start39 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  store i32 0, i32* %start39, align 4
  br label %replay_sequence

replay_sequence:                                  ; preds = %cond.end.962, %cond.end.864, %cond.end.786, %cond.end.754, %cond.end.698, %if.else.647, %if.end.497, %if.end.423, %if.end.281, %if.end.259, %for.end, %replay_entire_sequence
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %17, %struct.buffer** %starting_buffer, align 8
  %18 = load i32, i32* %bufsize.addr, align 4
  %add = add nsw i32 %18, 1
  store i32 %add, i32* %first_unbound, align 4
  %19 = load i64, i64* %first_event, align 8
  %call40 = call i64 @active_maps(i64 %19)
  store i64 %call40, i64* %current_binding, align 8
  store i32 0, i32* %t, align 4
  %20 = load i64, i64* %keys_start, align 8
  store i64 %20, i64* @this_command_key_count, align 8
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp42 = icmp eq i64 %21, %call41
  br i1 %cmp42, label %land.lhs.true.43, label %if.end.48

land.lhs.true.43:                                 ; preds = %replay_sequence
  %22 = load i8, i8* @noninteractive, align 1
  %tobool44 = trunc i8 %22 to i1
  br i1 %tobool44, label %if.end.48, label %land.lhs.true.45

land.lhs.true.45:                                 ; preds = %land.lhs.true.43
  %23 = load i32, i32* %t, align 4
  %24 = load i32, i32* %mock_input, align 4
  %cmp46 = icmp slt i32 %23, %24
  br i1 %cmp46, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %land.lhs.true.45
  %25 = load i64, i64* %echo_start, align 8
  call void @echo_truncate(i64 %25)
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %land.lhs.true.45, %land.lhs.true.43, %replay_sequence
  br label %while.cond

while.cond:                                       ; preds = %if.end.969, %if.end.48
  %26 = load i64, i64* %current_binding, align 8
  %call49 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp50 = icmp eq i64 %26, %call49
  br i1 %cmp50, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.cond
  %27 = load i64, i64* %current_binding, align 8
  %call51 = call i64 @get_keymap(i64 %27, i1 zeroext false, i1 zeroext false)
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %call51, %call52
  %lnot = xor i1 %cmp53, true
  %lnot.ext = zext i1 %lnot to i32
  br label %cond.end

cond.false:                                       ; preds = %while.cond
  %start54 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %28 = load i32, i32* %start54, align 4
  %29 = load i32, i32* %t, align 4
  %cmp55 = icmp slt i32 %28, %29
  %conv = zext i1 %cmp55 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %lnot.ext, %cond.true ], [ %conv, %cond.false ]
  %tobool56 = icmp ne i32 %cond, 0
  br i1 %tobool56, label %while.body, label %while.end.970

while.body:                                       ; preds = %cond.end
  store i8 0, i8* %used_mouse_menu, align 1
  %30 = load i32, i32* %first_unbound, align 4
  %start57 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %31 = load i32, i32* %start57, align 4
  %cmp58 = icmp slt i32 %30, %31
  br i1 %cmp58, label %if.then.60, label %if.end.87

if.then.60:                                       ; preds = %while.body
  %32 = load i32, i32* %first_unbound, align 4
  %add61 = add nsw i32 %32, 1
  store i32 %add61, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.60
  %33 = load i32, i32* %i, align 4
  %34 = load i32, i32* %t, align 4
  %cmp62 = icmp slt i32 %33, %34
  br i1 %cmp62, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %35 = load i32, i32* %i, align 4
  %idxprom = sext i32 %35 to i64
  %36 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %36, i64 %idxprom
  %37 = load i64, i64* %arrayidx, align 8
  %38 = load i32, i32* %i, align 4
  %39 = load i32, i32* %first_unbound, align 4
  %sub = sub nsw i32 %38, %39
  %sub64 = sub nsw i32 %sub, 1
  %idxprom65 = sext i32 %sub64 to i64
  %40 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx66 = getelementptr inbounds i64, i64* %40, i64 %idxprom65
  store i64 %37, i64* %arrayidx66, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %41 = load i32, i32* %i, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %42 = load i32, i32* %t, align 4
  %43 = load i32, i32* %first_unbound, align 4
  %sub67 = sub nsw i32 %42, %43
  %sub68 = sub nsw i32 %sub67, 1
  store i32 %sub68, i32* %mock_input, align 4
  %44 = load i32, i32* %first_unbound, align 4
  %add69 = add nsw i32 %44, 1
  %start70 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %45 = load i32, i32* %start70, align 4
  %sub71 = sub nsw i32 %45, %add69
  store i32 %sub71, i32* %start70, align 4
  %end72 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  store i32 %sub71, i32* %end72, align 4
  %parent73 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 0
  %46 = load i64, i64* %parent73, align 8
  %map74 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 1
  store i64 %46, i64* %map74, align 8
  %47 = load i32, i32* %first_unbound, align 4
  %add75 = add nsw i32 %47, 1
  %start76 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %48 = load i32, i32* %start76, align 4
  %sub77 = sub nsw i32 %48, %add75
  store i32 %sub77, i32* %start76, align 4
  %end78 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  store i32 %sub77, i32* %end78, align 4
  %parent79 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 0
  %49 = load i64, i64* %parent79, align 8
  %map80 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 1
  store i64 %49, i64* %map80, align 8
  %50 = load i32, i32* %first_unbound, align 4
  %add81 = add nsw i32 %50, 1
  %start82 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %51 = load i32, i32* %start82, align 4
  %sub83 = sub nsw i32 %51, %add81
  store i32 %sub83, i32* %start82, align 4
  %end84 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  store i32 %sub83, i32* %end84, align 4
  %parent85 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 0
  %52 = load i64, i64* %parent85, align 8
  %map86 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 1
  store i64 %52, i64* %map86, align 8
  br label %replay_sequence

if.end.87:                                        ; preds = %while.body
  %53 = load i32, i32* %t, align 4
  %54 = load i32, i32* %bufsize.addr, align 4
  %cmp88 = icmp sge i32 %53, %54
  br i1 %cmp88, label %if.then.90, label %if.end.91

if.then.90:                                       ; preds = %if.end.87
  call void (i8*, ...) @error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.388, i32 0, i32 0)) #11
  unreachable

if.end.91:                                        ; preds = %if.end.87
  %55 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call92 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp93 = icmp eq i64 %55, %call92
  br i1 %cmp93, label %land.lhs.true.95, label %if.end.99

land.lhs.true.95:                                 ; preds = %if.end.91
  %56 = load i8, i8* @noninteractive, align 1
  %tobool96 = trunc i8 %56 to i1
  br i1 %tobool96, label %if.end.99, label %if.then.97

if.then.97:                                       ; preds = %land.lhs.true.95
  %call98 = call i64 @echo_length()
  store i64 %call98, i64* %echo_local_start, align 8
  br label %if.end.99

if.end.99:                                        ; preds = %if.then.97, %land.lhs.true.95, %if.end.91
  %57 = load i64, i64* @this_command_key_count, align 8
  %conv100 = trunc i64 %57 to i32
  store i32 %conv100, i32* %keys_local_start, align 4
  br label %replay_key

replay_key:                                       ; preds = %if.then.646, %if.end.447, %if.then.315, %if.end.99
  %58 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call101 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp102 = icmp eq i64 %58, %call101
  br i1 %cmp102, label %land.lhs.true.104, label %if.end.110

land.lhs.true.104:                                ; preds = %replay_key
  %59 = load i8, i8* @noninteractive, align 1
  %tobool105 = trunc i8 %59 to i1
  br i1 %tobool105, label %if.end.110, label %land.lhs.true.106

land.lhs.true.106:                                ; preds = %land.lhs.true.104
  %60 = load i32, i32* %t, align 4
  %61 = load i32, i32* %mock_input, align 4
  %cmp107 = icmp slt i32 %60, %61
  br i1 %cmp107, label %if.then.109, label %if.end.110

if.then.109:                                      ; preds = %land.lhs.true.106
  %62 = load i64, i64* %echo_local_start, align 8
  call void @echo_truncate(i64 %62)
  br label %if.end.110

if.end.110:                                       ; preds = %if.then.109, %land.lhs.true.106, %land.lhs.true.104, %replay_key
  %63 = load i32, i32* %keys_local_start, align 4
  %conv111 = sext i32 %63 to i64
  store i64 %conv111, i64* @this_command_key_count, align 8
  %64 = load i32, i32* %t, align 4
  store i32 %64, i32* %last_real_key_start, align 4
  %65 = load i32, i32* %t, align 4
  %66 = load i32, i32* %mock_input, align 4
  %cmp112 = icmp slt i32 %65, %66
  br i1 %cmp112, label %if.then.114, label %if.else.125

if.then.114:                                      ; preds = %if.end.110
  %67 = load i32, i32* %t, align 4
  %idxprom115 = sext i32 %67 to i64
  %68 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx116 = getelementptr inbounds i64, i64* %68, i64 %idxprom115
  %69 = load i64, i64* %arrayidx116, align 8
  store i64 %69, i64* %key, align 8
  %70 = load i64, i64* %key, align 8
  call void @add_command_key(i64 %70)
  %71 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo117 = getelementptr inbounds %struct.kboard, %struct.kboard* %71, i32 0, i32 24
  %bf.load118 = load i8, i8* %immediate_echo117, align 1
  %bf.clear119 = and i8 %bf.load118, 1
  %bf.cast = trunc i8 %bf.clear119 to i1
  br i1 %bf.cast, label %if.then.120, label %if.end.124

if.then.120:                                      ; preds = %if.then.114
  %72 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo121 = getelementptr inbounds %struct.kboard, %struct.kboard* %72, i32 0, i32 24
  %bf.load122 = load i8, i8* %immediate_echo121, align 1
  %bf.clear123 = and i8 %bf.load122, -2
  store i8 %bf.clear123, i8* %immediate_echo121, align 1
  call void @echo_now()
  br label %if.end.124

if.end.124:                                       ; preds = %if.then.120, %if.then.114
  br label %if.end.346

if.else.125:                                      ; preds = %if.end.110
  %73 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  store %struct.kboard* %73, %struct.kboard** %interrupted_kboard, align 8
  %74 = load i64, i64* @selected_frame, align 8
  %call126 = call zeroext i1 @FRAMEP(i64 %74)
  br i1 %call126, label %land.lhs.true.128, label %cond.false.134

land.lhs.true.128:                                ; preds = %if.else.125
  %75 = load i64, i64* @selected_frame, align 8
  %sub129 = sub nsw i64 %75, 5
  %76 = inttoptr i64 %sub129 to i8*
  %77 = bitcast i8* %76 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %77, i32 0, i32 61
  %78 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp130 = icmp ne %struct.terminal* %78, null
  br i1 %cmp130, label %cond.true.132, label %cond.false.134

cond.true.132:                                    ; preds = %land.lhs.true.128
  %79 = load i64, i64* @selected_frame, align 8
  %sub133 = sub nsw i64 %79, 5
  %80 = inttoptr i64 %sub133 to i8*
  %81 = bitcast i8* %80 to %struct.frame*
  br label %cond.end.135

cond.false.134:                                   ; preds = %land.lhs.true.128, %if.else.125
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.135

cond.end.135:                                     ; preds = %82, %cond.true.132
  %cond136 = phi %struct.frame* [ %81, %cond.true.132 ], [ null, %82 ]
  store %struct.frame* %cond136, %struct.frame** %interrupted_frame, align 8
  %83 = load i8, i8* %prevent_redisplay.addr, align 1
  %tobool137 = trunc i8 %83 to i1
  br i1 %tobool137, label %cond.true.139, label %cond.false.140

cond.true.139:                                    ; preds = %cond.end.135
  br label %cond.end.144

cond.false.140:                                   ; preds = %cond.end.135
  %84 = load i64, i64* %prompt.addr, align 8
  %call141 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp142 = icmp eq i64 %84, %call141
  %conv143 = zext i1 %cmp142 to i32
  br label %cond.end.144

cond.end.144:                                     ; preds = %cond.false.140, %cond.true.139
  %cond145 = phi i32 [ -2, %cond.true.139 ], [ %conv143, %cond.false.140 ]
  %85 = load i64, i64* %current_binding, align 8
  %86 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %call146 = call i64 @read_char(i32 %cond145, i64 %85, i64 %86, i8* %used_mouse_menu, %struct.timespec* null)
  store i64 %call146, i64* %key, align 8
  %87 = load i64, i64* %key, align 8
  %and = and i64 %87, 7
  %conv147 = trunc i64 %and to i32
  %and148 = and i32 %conv147, -5
  %cmp149 = icmp eq i32 %and148, 2
  br i1 %cmp149, label %land.lhs.true.151, label %lor.lhs.false

land.lhs.true.151:                                ; preds = %cond.end.144
  %88 = load i64, i64* %key, align 8
  %shr = ashr i64 %88, 2
  %cmp152 = icmp eq i64 %shr, -2
  br i1 %cmp152, label %if.then.156, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.151, %cond.end.144
  %89 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %90 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp154 = icmp ne %struct.kboard* %89, %90
  br i1 %cmp154, label %if.then.156, label %if.end.220

if.then.156:                                      ; preds = %lor.lhs.false, %land.lhs.true.151
  store i8 0, i8* %found, align 1
  %91 = load %struct.kboard*, %struct.kboard** @all_kboards, align 8
  store %struct.kboard* %91, %struct.kboard** %k, align 8
  br label %for.cond.157

for.cond.157:                                     ; preds = %for.inc.164, %if.then.156
  %92 = load %struct.kboard*, %struct.kboard** %k, align 8
  %tobool158 = icmp ne %struct.kboard* %92, null
  br i1 %tobool158, label %for.body.159, label %for.end.165

for.body.159:                                     ; preds = %for.cond.157
  %93 = load %struct.kboard*, %struct.kboard** %k, align 8
  %94 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %cmp160 = icmp eq %struct.kboard* %93, %94
  br i1 %cmp160, label %if.then.162, label %if.end.163

if.then.162:                                      ; preds = %for.body.159
  store i8 1, i8* %found, align 1
  br label %if.end.163

if.end.163:                                       ; preds = %if.then.162, %for.body.159
  br label %for.inc.164

for.inc.164:                                      ; preds = %if.end.163
  %95 = load %struct.kboard*, %struct.kboard** %k, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %95, i32 0, i32 0
  %96 = load %struct.kboard*, %struct.kboard** %next_kboard, align 8
  store %struct.kboard* %96, %struct.kboard** %k, align 8
  br label %for.cond.157

for.end.165:                                      ; preds = %for.cond.157
  %97 = load i8, i8* %found, align 1
  %tobool166 = trunc i8 %97 to i1
  br i1 %tobool166, label %if.end.169, label %if.then.167

if.then.167:                                      ; preds = %for.end.165
  %call168 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call168, i64* %delayed_switch_frame, align 8
  br label %replay_entire_sequence

if.end.169:                                       ; preds = %for.end.165
  %98 = load i64, i64* %delayed_switch_frame, align 8
  %call170 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp171 = icmp eq i64 %98, %call170
  br i1 %cmp171, label %if.end.176, label %if.then.173

if.then.173:                                      ; preds = %if.end.169
  %99 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %100 = load i64, i64* %delayed_switch_frame, align 8
  %101 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %kbd_queue_ = getelementptr inbounds %struct.kboard, %struct.kboard* %101, i32 0, i32 8
  %102 = load i64, i64* %kbd_queue_, align 8
  %call174 = call i64 @Fcons(i64 %100, i64 %102)
  call void @kset_kbd_queue(%struct.kboard* %99, i64 %call174)
  %call175 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call175, i64* %delayed_switch_frame, align 8
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.173, %if.end.169
  br label %while.cond.177

while.cond.177:                                   ; preds = %while.body.180, %if.end.176
  %103 = load i32, i32* %t, align 4
  %cmp178 = icmp sgt i32 %103, 0
  br i1 %cmp178, label %while.body.180, label %while.end

while.body.180:                                   ; preds = %while.cond.177
  %104 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %105 = load i32, i32* %t, align 4
  %dec = add nsw i32 %105, -1
  store i32 %dec, i32* %t, align 4
  %idxprom181 = sext i32 %dec to i64
  %106 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx182 = getelementptr inbounds i64, i64* %106, i64 %idxprom181
  %107 = load i64, i64* %arrayidx182, align 8
  %108 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %kbd_queue_183 = getelementptr inbounds %struct.kboard, %struct.kboard* %108, i32 0, i32 8
  %109 = load i64, i64* %kbd_queue_183, align 8
  %call184 = call i64 @Fcons(i64 %107, i64 %109)
  call void @kset_kbd_queue(%struct.kboard* %104, i64 %call184)
  br label %while.cond.177

while.end:                                        ; preds = %while.cond.177
  %110 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %kbd_queue_185 = getelementptr inbounds %struct.kboard, %struct.kboard* %110, i32 0, i32 8
  %111 = load i64, i64* %kbd_queue_185, align 8
  %and186 = and i64 %111, 7
  %conv187 = trunc i64 %and186 to i32
  %cmp188 = icmp eq i32 %conv187, 3
  br i1 %cmp188, label %land.lhs.true.190, label %if.end.219

land.lhs.true.190:                                ; preds = %while.end
  %112 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %kbd_queue_191 = getelementptr inbounds %struct.kboard, %struct.kboard* %112, i32 0, i32 8
  %113 = load i64, i64* %kbd_queue_191, align 8
  %sub192 = sub nsw i64 %113, 3
  %114 = inttoptr i64 %sub192 to i8*
  %115 = bitcast i8* %114 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %115, i32 0, i32 0
  %116 = load i64, i64* %car, align 8
  store i64 %116, i64* %key, align 8
  %117 = load i64, i64* %key, align 8
  %and193 = and i64 %117, 7
  %conv194 = trunc i64 %and193 to i32
  %cmp195 = icmp eq i32 %conv194, 3
  br i1 %cmp195, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true.190
  %118 = load i64, i64* %key, align 8
  %and197 = and i64 %118, 7
  %conv198 = trunc i64 %and197 to i32
  %cmp199 = icmp eq i32 %conv198, 3
  br i1 %cmp199, label %cond.true.201, label %cond.false.204

cond.true.201:                                    ; preds = %land.rhs
  %119 = load i64, i64* %key, align 8
  %sub202 = sub nsw i64 %119, 3
  %120 = inttoptr i64 %sub202 to i8*
  %121 = bitcast i8* %120 to %struct.Lisp_Cons*
  %car203 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %121, i32 0, i32 0
  %122 = load i64, i64* %car203, align 8
  br label %cond.end.205

cond.false.204:                                   ; preds = %land.rhs
  %123 = load i64, i64* %key, align 8
  br label %cond.end.205

cond.end.205:                                     ; preds = %cond.false.204, %cond.true.201
  %cond206 = phi i64 [ %122, %cond.true.201 ], [ %123, %cond.false.204 ]
  %call207 = call i64 @builtin_lisp_symbol(i32 382)
  %call208 = call i64 @Fget(i64 %cond206, i64 %call207)
  %call209 = call i64 @builtin_lisp_symbol(i32 895)
  %cmp210 = icmp eq i64 %call208, %call209
  br label %land.end

land.end:                                         ; preds = %cond.end.205, %land.lhs.true.190
  %124 = phi i1 [ false, %land.lhs.true.190 ], [ %cmp210, %cond.end.205 ]
  %lnot212 = xor i1 %124, true
  br i1 %lnot212, label %if.then.214, label %if.end.219

if.then.214:                                      ; preds = %land.end
  %125 = load %struct.frame*, %struct.frame** %interrupted_frame, align 8
  %126 = bitcast %struct.frame* %125 to i8*
  %call215 = call i64 @make_lisp_ptr(i8* %126, i32 5)
  store i64 %call215, i64* %frame, align 8
  %127 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %128 = load i64, i64* %frame, align 8
  %call216 = call i64 @make_lispy_switch_frame(i64 %128)
  %129 = load %struct.kboard*, %struct.kboard** %interrupted_kboard, align 8
  %kbd_queue_217 = getelementptr inbounds %struct.kboard, %struct.kboard* %129, i32 0, i32 8
  %130 = load i64, i64* %kbd_queue_217, align 8
  %call218 = call i64 @Fcons(i64 %call216, i64 %130)
  call void @kset_kbd_queue(%struct.kboard* %127, i64 %call218)
  br label %if.end.219

if.end.219:                                       ; preds = %if.then.214, %land.end, %while.end
  store i32 0, i32* %mock_input, align 4
  br label %replay_entire_sequence

if.end.220:                                       ; preds = %lor.lhs.false
  %131 = load i64, i64* %key, align 8
  %call221 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp222 = icmp eq i64 %131, %call221
  br i1 %cmp222, label %if.then.224, label %if.end.227

if.then.224:                                      ; preds = %if.end.220
  %132 = load i64, i64* %count, align 8
  %call225 = call i64 @builtin_lisp_symbol(i32 0)
  %call226 = call i64 @unbind_to(i64 %132, i64 %call225)
  store i32 -1, i32* %retval
  br label %return

if.end.227:                                       ; preds = %if.end.220
  %133 = load i64, i64* %key, align 8
  %and228 = and i64 %133, 7
  %conv229 = trunc i64 %and228 to i32
  %and230 = and i32 %conv229, -5
  %cmp231 = icmp eq i32 %and230, 2
  br i1 %cmp231, label %land.lhs.true.233, label %if.end.238

land.lhs.true.233:                                ; preds = %if.end.227
  %134 = load i64, i64* %key, align 8
  %shr234 = ashr i64 %134, 2
  %cmp235 = icmp eq i64 %shr234, -1
  br i1 %cmp235, label %if.then.237, label %if.end.238

if.then.237:                                      ; preds = %land.lhs.true.233
  store i32 0, i32* %t, align 4
  store i8 1, i8* %dummyflag, align 1
  br label %while.end.970

if.end.238:                                       ; preds = %land.lhs.true.233, %if.end.227
  %135 = load i64, i64* %key, align 8
  %call239 = call zeroext i1 @BUFFERP(i64 %135)
  br i1 %call239, label %if.then.240, label %if.end.260

if.then.240:                                      ; preds = %if.end.238
  call void @timer_resume_idle()
  %136 = load i32, i32* %t, align 4
  store i32 %136, i32* %mock_input, align 4
  %137 = load i8, i8* %fix_current_buffer.addr, align 1
  %tobool241 = trunc i8 %137 to i1
  br i1 %tobool241, label %if.then.242, label %if.end.259

if.then.242:                                      ; preds = %if.then.240
  %138 = load i64, i64* @selected_frame, align 8
  %sub243 = sub nsw i64 %138, 5
  %139 = inttoptr i64 %sub243 to i8*
  %140 = bitcast i8* %139 to %struct.frame*
  %terminal244 = getelementptr inbounds %struct.frame, %struct.frame* %140, i32 0, i32 61
  %141 = load %struct.terminal*, %struct.terminal** %terminal244, align 8
  %cmp245 = icmp ne %struct.terminal* %141, null
  br i1 %cmp245, label %if.end.249, label %if.then.247

if.then.247:                                      ; preds = %if.then.242
  %call248 = call i64 @builtin_lisp_symbol(i32 0)
  %142 = call i64 @Fkill_emacs(i64 %call248) #11
  unreachable

if.end.249:                                       ; preds = %if.then.242
  %143 = load i64, i64* @selected_window, align 8
  %call250 = call %struct.window* @XWINDOW(i64 %143)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call250, i32 0, i32 10
  %144 = load i64, i64* %contents, align 8
  %call251 = call %struct.buffer* @XBUFFER(i64 %144)
  %145 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp252 = icmp ne %struct.buffer* %call251, %145
  br i1 %cmp252, label %if.then.254, label %if.end.258

if.then.254:                                      ; preds = %if.end.249
  %146 = load i64, i64* @selected_window, align 8
  %call255 = call %struct.window* @XWINDOW(i64 %146)
  %contents256 = getelementptr inbounds %struct.window, %struct.window* %call255, i32 0, i32 10
  %147 = load i64, i64* %contents256, align 8
  %call257 = call i64 @Fset_buffer(i64 %147)
  br label %if.end.258

if.end.258:                                       ; preds = %if.then.254, %if.end.249
  br label %if.end.259

if.end.259:                                       ; preds = %if.end.258, %if.then.240
  br label %replay_sequence

if.end.260:                                       ; preds = %if.end.238
  %148 = load i64, i64* %key, align 8
  %and261 = and i64 %148, 7
  %conv262 = trunc i64 %and261 to i32
  %and263 = and i32 %conv262, -5
  %cmp264 = icmp eq i32 %and263, 2
  br i1 %cmp264, label %land.lhs.true.266, label %if.end.288

land.lhs.true.266:                                ; preds = %if.end.260
  %149 = load i64, i64* %key, align 8
  %shr267 = ashr i64 %149, 2
  %150 = load i32, i32* @quit_char, align 4
  %conv268 = sext i32 %150 to i64
  %cmp269 = icmp eq i64 %shr267, %conv268
  br i1 %cmp269, label %land.lhs.true.271, label %if.end.288

land.lhs.true.271:                                ; preds = %land.lhs.true.266
  %151 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %152 = load %struct.buffer*, %struct.buffer** %starting_buffer, align 8
  %cmp272 = icmp ne %struct.buffer* %151, %152
  br i1 %cmp272, label %if.then.274, label %if.end.288

if.then.274:                                      ; preds = %land.lhs.true.271
  %153 = load i32, i32* @raw_keybuf_count, align 4
  %conv275 = sext i32 %153 to i64
  %154 = load i64, i64* @raw_keybuf, align 8
  %call276 = call i64 @ASIZE(i64 %154)
  %cmp277 = icmp eq i64 %conv275, %call276
  br i1 %cmp277, label %if.then.279, label %if.end.281

if.then.279:                                      ; preds = %if.then.274
  %155 = load i64, i64* @raw_keybuf, align 8
  %call280 = call i64 @larger_vector(i64 %155, i64 1, i64 -1)
  store i64 %call280, i64* @raw_keybuf, align 8
  br label %if.end.281

if.end.281:                                       ; preds = %if.then.279, %if.then.274
  %156 = load i64, i64* @raw_keybuf, align 8
  %157 = load i32, i32* @raw_keybuf_count, align 4
  %conv282 = sext i32 %157 to i64
  %158 = load i64, i64* %key, align 8
  call void @ASET(i64 %156, i64 %conv282, i64 %158)
  %159 = load i32, i32* @raw_keybuf_count, align 4
  %inc283 = add nsw i32 %159, 1
  store i32 %inc283, i32* @raw_keybuf_count, align 4
  %160 = load i64, i64* %key, align 8
  %161 = load i32, i32* %t, align 4
  %inc284 = add nsw i32 %161, 1
  store i32 %inc284, i32* %t, align 4
  %idxprom285 = sext i32 %161 to i64
  %162 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx286 = getelementptr inbounds i64, i64* %162, i64 %idxprom285
  store i64 %160, i64* %arrayidx286, align 8
  %163 = load i32, i32* %t, align 4
  store i32 %163, i32* %mock_input, align 4
  %call287 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call287, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %replay_sequence

if.end.288:                                       ; preds = %land.lhs.true.271, %land.lhs.true.266, %if.end.260
  %call289 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call289, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %164 = load i64, i64* %key, align 8
  %and290 = and i64 %164, 7
  %conv291 = trunc i64 %and290 to i32
  %cmp292 = icmp eq i32 %conv291, 3
  br i1 %cmp292, label %land.lhs.true.294, label %if.end.317

land.lhs.true.294:                                ; preds = %if.end.288
  %165 = load i64, i64* %key, align 8
  %and295 = and i64 %165, 7
  %conv296 = trunc i64 %and295 to i32
  %cmp297 = icmp eq i32 %conv296, 3
  br i1 %cmp297, label %cond.true.299, label %cond.false.302

cond.true.299:                                    ; preds = %land.lhs.true.294
  %166 = load i64, i64* %key, align 8
  %sub300 = sub nsw i64 %166, 3
  %167 = inttoptr i64 %sub300 to i8*
  %168 = bitcast i8* %167 to %struct.Lisp_Cons*
  %car301 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %168, i32 0, i32 0
  %169 = load i64, i64* %car301, align 8
  br label %cond.end.303

cond.false.302:                                   ; preds = %land.lhs.true.294
  %170 = load i64, i64* %key, align 8
  br label %cond.end.303

cond.end.303:                                     ; preds = %cond.false.302, %cond.true.299
  %cond304 = phi i64 [ %169, %cond.true.299 ], [ %170, %cond.false.302 ]
  %call305 = call i64 @builtin_lisp_symbol(i32 382)
  %call306 = call i64 @Fget(i64 %cond304, i64 %call305)
  %call307 = call i64 @builtin_lisp_symbol(i32 895)
  %cmp308 = icmp eq i64 %call306, %call307
  br i1 %cmp308, label %if.then.310, label %if.end.317

if.then.310:                                      ; preds = %cond.end.303
  %171 = load i32, i32* %t, align 4
  %cmp311 = icmp sgt i32 %171, 0
  br i1 %cmp311, label %if.then.315, label %lor.lhs.false.313

lor.lhs.false.313:                                ; preds = %if.then.310
  %172 = load i8, i8* %can_return_switch_frame.addr, align 1
  %tobool314 = trunc i8 %172 to i1
  br i1 %tobool314, label %if.end.316, label %if.then.315

if.then.315:                                      ; preds = %lor.lhs.false.313, %if.then.310
  %173 = load i64, i64* %key, align 8
  store i64 %173, i64* %delayed_switch_frame, align 8
  br label %replay_key

if.end.316:                                       ; preds = %lor.lhs.false.313
  br label %if.end.317

if.end.317:                                       ; preds = %if.end.316, %cond.end.303, %if.end.288
  %174 = load i64, i64* %first_event, align 8
  %call318 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp319 = icmp eq i64 %174, %call318
  br i1 %cmp319, label %if.then.321, label %if.end.336

if.then.321:                                      ; preds = %if.end.317
  %175 = load i64, i64* %key, align 8
  store i64 %175, i64* %first_event, align 8
  %176 = load i8, i8* %fix_current_buffer.addr, align 1
  %tobool322 = trunc i8 %176 to i1
  br i1 %tobool322, label %land.lhs.true.324, label %if.end.334

land.lhs.true.324:                                ; preds = %if.then.321
  %177 = load i64, i64* @selected_window, align 8
  %call325 = call %struct.window* @XWINDOW(i64 %177)
  %contents326 = getelementptr inbounds %struct.window, %struct.window* %call325, i32 0, i32 10
  %178 = load i64, i64* %contents326, align 8
  %call327 = call %struct.buffer* @XBUFFER(i64 %178)
  %179 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp328 = icmp ne %struct.buffer* %call327, %179
  br i1 %cmp328, label %if.then.330, label %if.end.334

if.then.330:                                      ; preds = %land.lhs.true.324
  %180 = load i64, i64* @selected_window, align 8
  %call331 = call %struct.window* @XWINDOW(i64 %180)
  %contents332 = getelementptr inbounds %struct.window, %struct.window* %call331, i32 0, i32 10
  %181 = load i64, i64* %contents332, align 8
  %call333 = call i64 @Fset_buffer(i64 %181)
  br label %if.end.334

if.end.334:                                       ; preds = %if.then.330, %land.lhs.true.324, %if.then.321
  %182 = load i64, i64* %first_event, align 8
  %call335 = call i64 @active_maps(i64 %182)
  store i64 %call335, i64* %current_binding, align 8
  br label %if.end.336

if.end.336:                                       ; preds = %if.end.334, %if.end.317
  %183 = load i32, i32* @raw_keybuf_count, align 4
  %conv337 = sext i32 %183 to i64
  %184 = load i64, i64* @raw_keybuf, align 8
  %call338 = call i64 @ASIZE(i64 %184)
  %cmp339 = icmp eq i64 %conv337, %call338
  br i1 %cmp339, label %if.then.341, label %if.end.343

if.then.341:                                      ; preds = %if.end.336
  %185 = load i64, i64* @raw_keybuf, align 8
  %call342 = call i64 @larger_vector(i64 %185, i64 1, i64 -1)
  store i64 %call342, i64* @raw_keybuf, align 8
  br label %if.end.343

if.end.343:                                       ; preds = %if.then.341, %if.end.336
  %186 = load i64, i64* @raw_keybuf, align 8
  %187 = load i32, i32* @raw_keybuf_count, align 4
  %conv344 = sext i32 %187 to i64
  %188 = load i64, i64* %key, align 8
  call void @ASET(i64 %186, i64 %conv344, i64 %188)
  %189 = load i32, i32* @raw_keybuf_count, align 4
  %inc345 = add nsw i32 %189, 1
  store i32 %inc345, i32* @raw_keybuf_count, align 4
  br label %if.end.346

if.end.346:                                       ; preds = %if.end.343, %if.end.124
  %190 = load i64, i64* %key, align 8
  %and347 = and i64 %190, 7
  %conv348 = trunc i64 %and347 to i32
  %cmp349 = icmp eq i32 %conv348, 3
  br i1 %cmp349, label %if.then.351, label %if.end.528

if.then.351:                                      ; preds = %if.end.346
  %191 = load i64, i64* %key, align 8
  %and352 = and i64 %191, 7
  %conv353 = trunc i64 %and352 to i32
  %cmp354 = icmp eq i32 %conv353, 3
  br i1 %cmp354, label %cond.true.356, label %cond.false.359

cond.true.356:                                    ; preds = %if.then.351
  %192 = load i64, i64* %key, align 8
  %sub357 = sub nsw i64 %192, 3
  %193 = inttoptr i64 %sub357 to i8*
  %194 = bitcast i8* %193 to %struct.Lisp_Cons*
  %car358 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %194, i32 0, i32 0
  %195 = load i64, i64* %car358, align 8
  br label %cond.end.360

cond.false.359:                                   ; preds = %if.then.351
  %196 = load i64, i64* %key, align 8
  br label %cond.end.360

cond.end.360:                                     ; preds = %cond.false.359, %cond.true.356
  %cond361 = phi i64 [ %195, %cond.true.356 ], [ %196, %cond.false.359 ]
  %call362 = call i64 @builtin_lisp_symbol(i32 382)
  %call363 = call i64 @Fget(i64 %cond361, i64 %call362)
  store i64 %call363, i64* %kind, align 8
  %197 = load i64, i64* %kind, align 8
  %call364 = call i64 @builtin_lisp_symbol(i32 685)
  %cmp365 = icmp eq i64 %197, %call364
  br i1 %cmp365, label %if.then.367, label %if.else.456

if.then.367:                                      ; preds = %cond.end.360
  %198 = load i64, i64* %key, align 8
  %call368 = call i64 @CDR_SAFE(i64 %198)
  %call369 = call i64 @CAR_SAFE(i64 %call368)
  %call370 = call i64 @CAR_SAFE(i64 %call369)
  store i64 %call370, i64* %window, align 8
  %199 = load i64, i64* %key, align 8
  %call371 = call i64 @CDR_SAFE(i64 %199)
  %call372 = call i64 @CAR_SAFE(i64 %call371)
  %call373 = call i64 @CDR_SAFE(i64 %call372)
  %call374 = call i64 @CAR_SAFE(i64 %call373)
  store i64 %call374, i64* %posn, align 8
  %200 = load i64, i64* %posn, align 8
  %and375 = and i64 %200, 7
  %conv376 = trunc i64 %and375 to i32
  %cmp377 = icmp eq i32 %conv376, 3
  br i1 %cmp377, label %if.then.388, label %lor.lhs.false.379

lor.lhs.false.379:                                ; preds = %if.then.367
  %201 = load i64, i64* %fake_prefixed_keys, align 8
  %call380 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp381 = icmp eq i64 %201, %call380
  br i1 %cmp381, label %if.end.394, label %land.lhs.true.383

land.lhs.true.383:                                ; preds = %lor.lhs.false.379
  %202 = load i64, i64* %key, align 8
  %203 = load i64, i64* %fake_prefixed_keys, align 8
  %call384 = call i64 @Fmemq(i64 %202, i64 %203)
  %call385 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp386 = icmp eq i64 %call384, %call385
  br i1 %cmp386, label %if.end.394, label %if.then.388

if.then.388:                                      ; preds = %land.lhs.true.383, %if.then.367
  %204 = load i32, i32* %t, align 4
  %cmp389 = icmp sgt i32 %204, 0
  br i1 %cmp389, label %if.then.391, label %if.end.393

if.then.391:                                      ; preds = %if.then.388
  %205 = load i32, i32* %t, align 4
  %sub392 = sub nsw i32 %205, 1
  store i32 %sub392, i32* %last_real_key_start, align 4
  br label %if.end.393

if.end.393:                                       ; preds = %if.then.391, %if.then.388
  br label %if.end.394

if.end.394:                                       ; preds = %if.end.393, %land.lhs.true.383, %lor.lhs.false.379
  %206 = load i32, i32* %last_real_key_start, align 4
  %cmp395 = icmp eq i32 %206, 0
  br i1 %cmp395, label %if.then.397, label %if.end.428

if.then.397:                                      ; preds = %if.end.394
  %207 = load i64, i64* %window, align 8
  %call398 = call zeroext i1 @WINDOWP(i64 %207)
  br i1 %call398, label %land.lhs.true.400, label %if.end.427

land.lhs.true.400:                                ; preds = %if.then.397
  %208 = load i64, i64* %window, align 8
  %call401 = call %struct.window* @XWINDOW(i64 %208)
  %contents402 = getelementptr inbounds %struct.window, %struct.window* %call401, i32 0, i32 10
  %209 = load i64, i64* %contents402, align 8
  %call403 = call zeroext i1 @BUFFERP(i64 %209)
  br i1 %call403, label %land.lhs.true.405, label %if.end.427

land.lhs.true.405:                                ; preds = %land.lhs.true.400
  %210 = load i64, i64* %window, align 8
  %call406 = call %struct.window* @XWINDOW(i64 %210)
  %contents407 = getelementptr inbounds %struct.window, %struct.window* %call406, i32 0, i32 10
  %211 = load i64, i64* %contents407, align 8
  %call408 = call %struct.buffer* @XBUFFER(i64 %211)
  %212 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp409 = icmp ne %struct.buffer* %call408, %212
  br i1 %cmp409, label %if.then.411, label %if.end.427

if.then.411:                                      ; preds = %land.lhs.true.405
  %213 = load i64, i64* @raw_keybuf, align 8
  %214 = load i32, i32* @raw_keybuf_count, align 4
  %conv412 = sext i32 %214 to i64
  %215 = load i64, i64* %key, align 8
  call void @ASET(i64 %213, i64 %conv412, i64 %215)
  %216 = load i32, i32* @raw_keybuf_count, align 4
  %inc413 = add nsw i32 %216, 1
  store i32 %inc413, i32* @raw_keybuf_count, align 4
  %217 = load i64, i64* %key, align 8
  %218 = load i32, i32* %t, align 4
  %idxprom414 = sext i32 %218 to i64
  %219 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx415 = getelementptr inbounds i64, i64* %219, i64 %idxprom414
  store i64 %217, i64* %arrayidx415, align 8
  %220 = load i32, i32* %t, align 4
  %add416 = add nsw i32 %220, 1
  store i32 %add416, i32* %mock_input, align 4
  call void @record_unwind_current_buffer()
  %221 = load i64, i64* @selected_frame, align 8
  %sub417 = sub nsw i64 %221, 5
  %222 = inttoptr i64 %sub417 to i8*
  %223 = bitcast i8* %222 to %struct.frame*
  %terminal418 = getelementptr inbounds %struct.frame, %struct.frame* %223, i32 0, i32 61
  %224 = load %struct.terminal*, %struct.terminal** %terminal418, align 8
  %cmp419 = icmp ne %struct.terminal* %224, null
  br i1 %cmp419, label %if.end.423, label %if.then.421

if.then.421:                                      ; preds = %if.then.411
  %call422 = call i64 @builtin_lisp_symbol(i32 0)
  %225 = call i64 @Fkill_emacs(i64 %call422) #11
  unreachable

if.end.423:                                       ; preds = %if.then.411
  %226 = load i64, i64* %window, align 8
  %call424 = call %struct.window* @XWINDOW(i64 %226)
  %contents425 = getelementptr inbounds %struct.window, %struct.window* %call424, i32 0, i32 10
  %227 = load i64, i64* %contents425, align 8
  %call426 = call %struct.buffer* @XBUFFER(i64 %227)
  call void @set_buffer_internal(%struct.buffer* %call426)
  br label %replay_sequence

if.end.427:                                       ; preds = %land.lhs.true.405, %land.lhs.true.400, %if.then.397
  br label %if.end.428

if.end.428:                                       ; preds = %if.end.427, %if.end.394
  %228 = load i64, i64* %posn, align 8
  %and429 = and i64 %228, 7
  %conv430 = trunc i64 %and429 to i32
  %cmp431 = icmp eq i32 %conv430, 0
  br i1 %cmp431, label %land.lhs.true.433, label %if.end.455

land.lhs.true.433:                                ; preds = %if.end.428
  %229 = load i64, i64* %fake_prefixed_keys, align 8
  %call434 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp435 = icmp eq i64 %229, %call434
  br i1 %cmp435, label %if.then.442, label %lor.lhs.false.437

lor.lhs.false.437:                                ; preds = %land.lhs.true.433
  %230 = load i64, i64* %key, align 8
  %231 = load i64, i64* %fake_prefixed_keys, align 8
  %call438 = call i64 @Fmemq(i64 %230, i64 %231)
  %call439 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp440 = icmp eq i64 %call438, %call439
  br i1 %cmp440, label %if.then.442, label %if.end.455

if.then.442:                                      ; preds = %lor.lhs.false.437, %land.lhs.true.433
  %232 = load i32, i32* %bufsize.addr, align 4
  %233 = load i32, i32* %t, align 4
  %sub443 = sub nsw i32 %232, %233
  %cmp444 = icmp sle i32 %sub443, 1
  br i1 %cmp444, label %if.then.446, label %if.end.447

if.then.446:                                      ; preds = %if.then.442
  call void (i8*, ...) @error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.388, i32 0, i32 0)) #11
  unreachable

if.end.447:                                       ; preds = %if.then.442
  %234 = load i64, i64* %posn, align 8
  %235 = load i32, i32* %t, align 4
  %idxprom448 = sext i32 %235 to i64
  %236 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx449 = getelementptr inbounds i64, i64* %236, i64 %idxprom448
  store i64 %234, i64* %arrayidx449, align 8
  %237 = load i64, i64* %key, align 8
  %238 = load i32, i32* %t, align 4
  %add450 = add nsw i32 %238, 1
  %idxprom451 = sext i32 %add450 to i64
  %239 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx452 = getelementptr inbounds i64, i64* %239, i64 %idxprom451
  store i64 %237, i64* %arrayidx452, align 8
  %240 = load i32, i32* %t, align 4
  %add453 = add nsw i32 %240, 2
  store i32 %add453, i32* %mock_input, align 4
  %241 = load i64, i64* %key, align 8
  %242 = load i64, i64* %fake_prefixed_keys, align 8
  %call454 = call i64 @Fcons(i64 %241, i64 %242)
  store i64 %call454, i64* %fake_prefixed_keys, align 8
  br label %replay_key

if.end.455:                                       ; preds = %lor.lhs.false.437, %if.end.428
  br label %if.end.527

if.else.456:                                      ; preds = %cond.end.360
  %243 = load i64, i64* %key, align 8
  %sub457 = sub nsw i64 %243, 3
  %244 = inttoptr i64 %sub457 to i8*
  %245 = bitcast i8* %244 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %245, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %246 = load i64, i64* %cdr, align 8
  %and458 = and i64 %246, 7
  %conv459 = trunc i64 %and458 to i32
  %cmp460 = icmp eq i32 %conv459, 3
  br i1 %cmp460, label %land.lhs.true.462, label %if.end.526

land.lhs.true.462:                                ; preds = %if.else.456
  %247 = load i64, i64* %key, align 8
  %call463 = call i64 @CDR_SAFE(i64 %247)
  %call464 = call i64 @CAR_SAFE(i64 %call463)
  %and465 = and i64 %call464, 7
  %conv466 = trunc i64 %and465 to i32
  %cmp467 = icmp eq i32 %conv466, 3
  br i1 %cmp467, label %land.lhs.true.469, label %if.end.526

land.lhs.true.469:                                ; preds = %land.lhs.true.462
  %248 = load i64, i64* %key, align 8
  %call470 = call i64 @CDR_SAFE(i64 %248)
  %call471 = call i64 @CAR_SAFE(i64 %call470)
  %sub472 = sub nsw i64 %call471, 3
  %249 = inttoptr i64 %sub472 to i8*
  %250 = bitcast i8* %249 to %struct.Lisp_Cons*
  %u473 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %250, i32 0, i32 1
  %cdr474 = bitcast %union.anon.12* %u473 to i64*
  %251 = load i64, i64* %cdr474, align 8
  %and475 = and i64 %251, 7
  %conv476 = trunc i64 %and475 to i32
  %cmp477 = icmp eq i32 %conv476, 3
  br i1 %cmp477, label %if.then.479, label %if.end.526

if.then.479:                                      ; preds = %land.lhs.true.469
  %252 = load i64, i64* %key, align 8
  %call481 = call i64 @CDR_SAFE(i64 %252)
  %call482 = call i64 @CAR_SAFE(i64 %call481)
  %call483 = call i64 @CDR_SAFE(i64 %call482)
  %call484 = call i64 @CAR_SAFE(i64 %call483)
  store i64 %call484, i64* %posn480, align 8
  %253 = load i64, i64* %posn480, align 8
  %call485 = call i64 @builtin_lisp_symbol(i32 651)
  %cmp486 = icmp eq i64 %253, %call485
  br i1 %cmp486, label %if.then.492, label %lor.lhs.false.488

lor.lhs.false.488:                                ; preds = %if.then.479
  %254 = load i64, i64* %posn480, align 8
  %call489 = call i64 @builtin_lisp_symbol(i32 921)
  %cmp490 = icmp eq i64 %254, %call489
  br i1 %cmp490, label %if.then.492, label %if.else.510

if.then.492:                                      ; preds = %lor.lhs.false.488, %if.then.479
  %255 = load i32, i32* %bufsize.addr, align 4
  %256 = load i32, i32* %t, align 4
  %sub493 = sub nsw i32 %255, %256
  %cmp494 = icmp sle i32 %sub493, 1
  br i1 %cmp494, label %if.then.496, label %if.end.497

if.then.496:                                      ; preds = %if.then.492
  call void (i8*, ...) @error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.388, i32 0, i32 0)) #11
  unreachable

if.end.497:                                       ; preds = %if.then.492
  %257 = load i64, i64* %posn480, align 8
  %258 = load i32, i32* %t, align 4
  %idxprom498 = sext i32 %258 to i64
  %259 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx499 = getelementptr inbounds i64, i64* %259, i64 %idxprom498
  store i64 %257, i64* %arrayidx499, align 8
  %260 = load i64, i64* %key, align 8
  %261 = load i32, i32* %t, align 4
  %add500 = add nsw i32 %261, 1
  %idxprom501 = sext i32 %add500 to i64
  %262 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx502 = getelementptr inbounds i64, i64* %262, i64 %idxprom501
  store i64 %260, i64* %arrayidx502, align 8
  %263 = load i64, i64* %key, align 8
  %call503 = call i64 @CDR_SAFE(i64 %263)
  %call504 = call i64 @CAR_SAFE(i64 %call503)
  %sub505 = sub nsw i64 %call504, 3
  %264 = inttoptr i64 %sub505 to i8*
  %265 = bitcast i8* %264 to %struct.Lisp_Cons*
  %u506 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %265, i32 0, i32 1
  %cdr507 = bitcast %union.anon.12* %u506 to i64*
  %266 = load i64, i64* %cdr507, align 8
  %267 = load i64, i64* %posn480, align 8
  %call508 = call i64 @list1(i64 %267)
  call void @XSETCAR(i64 %266, i64 %call508)
  %268 = load i32, i32* %t, align 4
  %add509 = add nsw i32 %268, 2
  store i32 %add509, i32* %mock_input, align 4
  br label %replay_sequence

if.else.510:                                      ; preds = %lor.lhs.false.488
  %269 = load i64, i64* %posn480, align 8
  %and511 = and i64 %269, 7
  %conv512 = trunc i64 %and511 to i32
  %cmp513 = icmp eq i32 %conv512, 3
  br i1 %cmp513, label %if.then.515, label %if.end.524

if.then.515:                                      ; preds = %if.else.510
  %270 = load i32, i32* %last_real_key_start, align 4
  %271 = load i32, i32* %t, align 4
  %cmp516 = icmp eq i32 %270, %271
  br i1 %cmp516, label %land.lhs.true.518, label %if.end.523

land.lhs.true.518:                                ; preds = %if.then.515
  %272 = load i32, i32* %t, align 4
  %cmp519 = icmp sgt i32 %272, 0
  br i1 %cmp519, label %if.then.521, label %if.end.523

if.then.521:                                      ; preds = %land.lhs.true.518
  %273 = load i32, i32* %t, align 4
  %sub522 = sub nsw i32 %273, 1
  store i32 %sub522, i32* %last_real_key_start, align 4
  br label %if.end.523

if.end.523:                                       ; preds = %if.then.521, %land.lhs.true.518, %if.then.515
  br label %if.end.524

if.end.524:                                       ; preds = %if.end.523, %if.else.510
  br label %if.end.525

if.end.525:                                       ; preds = %if.end.524
  br label %if.end.526

if.end.526:                                       ; preds = %if.end.525, %land.lhs.true.469, %land.lhs.true.462, %if.else.456
  br label %if.end.527

if.end.527:                                       ; preds = %if.end.526, %if.end.455
  br label %if.end.528

if.end.528:                                       ; preds = %if.end.527, %if.end.346
  %274 = load i64, i64* %current_binding, align 8
  %275 = load i64, i64* %key, align 8
  %call529 = call i64 @follow_key(i64 %274, i64 %275)
  store i64 %call529, i64* %new_binding, align 8
  %276 = load i64, i64* %new_binding, align 8
  %call530 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp531 = icmp eq i64 %276, %call530
  br i1 %cmp531, label %if.else.542, label %if.then.533

if.then.533:                                      ; preds = %if.end.528
  %277 = load i32, i32* %t, align 4
  %add534 = add nsw i32 %277, 1
  %278 = load i32, i32* %first_unbound, align 4
  %cmp535 = icmp sgt i32 %add534, %278
  br i1 %cmp535, label %cond.true.537, label %cond.false.539

cond.true.537:                                    ; preds = %if.then.533
  %279 = load i32, i32* %t, align 4
  %add538 = add nsw i32 %279, 1
  br label %cond.end.540

cond.false.539:                                   ; preds = %if.then.533
  %280 = load i32, i32* %first_unbound, align 4
  br label %cond.end.540

cond.end.540:                                     ; preds = %cond.false.539, %cond.true.537
  %cond541 = phi i32 [ %add538, %cond.true.537 ], [ %280, %cond.false.539 ]
  store i32 %cond541, i32* %first_unbound, align 4
  br label %if.end.666

if.else.542:                                      ; preds = %if.end.528
  %281 = load i32, i32* %t, align 4
  %282 = load i32, i32* %first_unbound, align 4
  %cmp543 = icmp slt i32 %281, %282
  br i1 %cmp543, label %cond.true.545, label %cond.false.546

cond.true.545:                                    ; preds = %if.else.542
  %283 = load i32, i32* %t, align 4
  br label %cond.end.547

cond.false.546:                                   ; preds = %if.else.542
  %284 = load i32, i32* %first_unbound, align 4
  br label %cond.end.547

cond.end.547:                                     ; preds = %cond.false.546, %cond.true.545
  %cond548 = phi i32 [ %283, %cond.true.545 ], [ %284, %cond.false.546 ]
  store i32 %cond548, i32* %first_unbound, align 4
  %285 = load i64, i64* %key, align 8
  %and549 = and i64 %285, 7
  %conv550 = trunc i64 %and549 to i32
  %cmp551 = icmp eq i32 %conv550, 3
  br i1 %cmp551, label %cond.true.553, label %cond.false.556

cond.true.553:                                    ; preds = %cond.end.547
  %286 = load i64, i64* %key, align 8
  %sub554 = sub nsw i64 %286, 3
  %287 = inttoptr i64 %sub554 to i8*
  %288 = bitcast i8* %287 to %struct.Lisp_Cons*
  %car555 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %288, i32 0, i32 0
  %289 = load i64, i64* %car555, align 8
  br label %cond.end.557

cond.false.556:                                   ; preds = %cond.end.547
  %290 = load i64, i64* %key, align 8
  br label %cond.end.557

cond.end.557:                                     ; preds = %cond.false.556, %cond.true.553
  %cond558 = phi i64 [ %289, %cond.true.553 ], [ %290, %cond.false.556 ]
  store i64 %cond558, i64* %head, align 8
  %291 = load i64, i64* %head, align 8
  %and559 = and i64 %291, 7
  %conv560 = trunc i64 %and559 to i32
  %cmp561 = icmp eq i32 %conv560, 0
  br i1 %cmp561, label %if.then.563, label %if.end.665

if.then.563:                                      ; preds = %cond.end.557
  %292 = load i64, i64* %head, align 8
  %call564 = call i64 @parse_modifiers(i64 %292)
  store i64 %call564, i64* %breakdown, align 8
  %293 = load i64, i64* %breakdown, align 8
  %sub565 = sub nsw i64 %293, 3
  %294 = inttoptr i64 %sub565 to i8*
  %295 = bitcast i8* %294 to %struct.Lisp_Cons*
  %u566 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %295, i32 0, i32 1
  %cdr567 = bitcast %union.anon.12* %u566 to i64*
  %296 = load i64, i64* %cdr567, align 8
  %sub568 = sub nsw i64 %296, 3
  %297 = inttoptr i64 %sub568 to i8*
  %298 = bitcast i8* %297 to %struct.Lisp_Cons*
  %car569 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %298, i32 0, i32 0
  %299 = load i64, i64* %car569, align 8
  %shr570 = ashr i64 %299, 2
  %conv571 = trunc i64 %shr570 to i32
  store i32 %conv571, i32* %modifiers, align 4
  %300 = load i32, i32* %modifiers, align 4
  %and572 = and i32 %300, 55
  %tobool573 = icmp ne i32 %and572, 0
  br i1 %tobool573, label %if.then.574, label %if.end.664

if.then.574:                                      ; preds = %if.then.563
  br label %while.cond.575

while.cond.575:                                   ; preds = %if.end.662, %if.then.574
  %301 = load i32, i32* %modifiers, align 4
  %and576 = and i32 %301, 55
  %tobool577 = icmp ne i32 %and576, 0
  br i1 %tobool577, label %while.body.578, label %while.end.663

while.body.578:                                   ; preds = %while.cond.575
  %302 = load i32, i32* %modifiers, align 4
  %and579 = and i32 %302, 32
  %tobool580 = icmp ne i32 %and579, 0
  br i1 %tobool580, label %if.then.581, label %if.else.582

if.then.581:                                      ; preds = %while.body.578
  %303 = load i32, i32* %modifiers, align 4
  %xor = xor i32 %303, 48
  store i32 %xor, i32* %modifiers, align 4
  br label %if.end.650

if.else.582:                                      ; preds = %while.body.578
  %304 = load i32, i32* %modifiers, align 4
  %and583 = and i32 %304, 16
  %tobool584 = icmp ne i32 %and583, 0
  br i1 %tobool584, label %if.then.585, label %if.else.587

if.then.585:                                      ; preds = %if.else.582
  %305 = load i32, i32* %modifiers, align 4
  %and586 = and i32 %305, -17
  store i32 %and586, i32* %modifiers, align 4
  br label %if.end.649

if.else.587:                                      ; preds = %if.else.582
  %306 = load i32, i32* %modifiers, align 4
  %and588 = and i32 %306, 4
  %tobool589 = icmp ne i32 %and588, 0
  br i1 %tobool589, label %if.then.590, label %if.else.592

if.then.590:                                      ; preds = %if.else.587
  %307 = load i32, i32* %modifiers, align 4
  %and591 = and i32 %307, -5
  store i32 %and591, i32* %modifiers, align 4
  br label %if.end.648

if.else.592:                                      ; preds = %if.else.587
  %end593 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  %308 = load i32, i32* %end593, align 4
  %309 = load i32, i32* %last_real_key_start, align 4
  %cmp594 = icmp sgt i32 %308, %309
  br i1 %cmp594, label %if.then.596, label %if.end.643

if.then.596:                                      ; preds = %if.else.592
  %310 = load i32, i32* %last_real_key_start, align 4
  %start597 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %311 = load i32, i32* %start597, align 4
  %cmp598 = icmp slt i32 %310, %311
  br i1 %cmp598, label %cond.true.600, label %cond.false.601

cond.true.600:                                    ; preds = %if.then.596
  %312 = load i32, i32* %last_real_key_start, align 4
  br label %cond.end.603

cond.false.601:                                   ; preds = %if.then.596
  %start602 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %313 = load i32, i32* %start602, align 4
  br label %cond.end.603

cond.end.603:                                     ; preds = %cond.false.601, %cond.true.600
  %cond604 = phi i32 [ %312, %cond.true.600 ], [ %313, %cond.false.601 ]
  %start605 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  store i32 %cond604, i32* %start605, align 4
  %end606 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  store i32 %cond604, i32* %end606, align 4
  %parent607 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 0
  %314 = load i64, i64* %parent607, align 8
  %map608 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 1
  store i64 %314, i64* %map608, align 8
  %end609 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  %315 = load i32, i32* %end609, align 4
  %316 = load i32, i32* %last_real_key_start, align 4
  %cmp610 = icmp sgt i32 %315, %316
  br i1 %cmp610, label %if.then.612, label %if.end.642

if.then.612:                                      ; preds = %cond.end.603
  %317 = load i32, i32* %last_real_key_start, align 4
  %start613 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %318 = load i32, i32* %start613, align 4
  %cmp614 = icmp slt i32 %317, %318
  br i1 %cmp614, label %cond.true.616, label %cond.false.617

cond.true.616:                                    ; preds = %if.then.612
  %319 = load i32, i32* %last_real_key_start, align 4
  br label %cond.end.619

cond.false.617:                                   ; preds = %if.then.612
  %start618 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %320 = load i32, i32* %start618, align 4
  br label %cond.end.619

cond.end.619:                                     ; preds = %cond.false.617, %cond.true.616
  %cond620 = phi i32 [ %319, %cond.true.616 ], [ %320, %cond.false.617 ]
  %start621 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  store i32 %cond620, i32* %start621, align 4
  %end622 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  store i32 %cond620, i32* %end622, align 4
  %parent623 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 0
  %321 = load i64, i64* %parent623, align 8
  %map624 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 1
  store i64 %321, i64* %map624, align 8
  %end625 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  %322 = load i32, i32* %end625, align 4
  %323 = load i32, i32* %last_real_key_start, align 4
  %cmp626 = icmp sgt i32 %322, %323
  br i1 %cmp626, label %if.then.628, label %if.end.641

if.then.628:                                      ; preds = %cond.end.619
  %324 = load i32, i32* %last_real_key_start, align 4
  %start629 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %325 = load i32, i32* %start629, align 4
  %cmp630 = icmp slt i32 %324, %325
  br i1 %cmp630, label %cond.true.632, label %cond.false.633

cond.true.632:                                    ; preds = %if.then.628
  %326 = load i32, i32* %last_real_key_start, align 4
  br label %cond.end.635

cond.false.633:                                   ; preds = %if.then.628
  %start634 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %327 = load i32, i32* %start634, align 4
  br label %cond.end.635

cond.end.635:                                     ; preds = %cond.false.633, %cond.true.632
  %cond636 = phi i32 [ %326, %cond.true.632 ], [ %327, %cond.false.633 ]
  %start637 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  store i32 %cond636, i32* %start637, align 4
  %end638 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  store i32 %cond636, i32* %end638, align 4
  %parent639 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 0
  %328 = load i64, i64* %parent639, align 8
  %map640 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 1
  store i64 %328, i64* %map640, align 8
  br label %if.end.641

if.end.641:                                       ; preds = %cond.end.635, %cond.end.619
  br label %if.end.642

if.end.642:                                       ; preds = %if.end.641, %cond.end.603
  br label %if.end.643

if.end.643:                                       ; preds = %if.end.642, %if.else.592
  %329 = load i32, i32* %t, align 4
  %330 = load i32, i32* %last_real_key_start, align 4
  %cmp644 = icmp eq i32 %329, %330
  br i1 %cmp644, label %if.then.646, label %if.else.647

if.then.646:                                      ; preds = %if.end.643
  store i32 0, i32* %mock_input, align 4
  br label %replay_key

if.else.647:                                      ; preds = %if.end.643
  %331 = load i32, i32* %last_real_key_start, align 4
  store i32 %331, i32* %mock_input, align 4
  br label %replay_sequence

if.end.648:                                       ; preds = %if.then.590
  br label %if.end.649

if.end.649:                                       ; preds = %if.end.648, %if.then.585
  br label %if.end.650

if.end.650:                                       ; preds = %if.end.649, %if.then.581
  %332 = load i32, i32* %modifiers, align 4
  %333 = load i64, i64* %breakdown, align 8
  %sub651 = sub nsw i64 %333, 3
  %334 = inttoptr i64 %sub651 to i8*
  %335 = bitcast i8* %334 to %struct.Lisp_Cons*
  %car652 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %335, i32 0, i32 0
  %336 = load i64, i64* %car652, align 8
  %call653 = call i64 @apply_modifiers(i32 %332, i64 %336)
  store i64 %call653, i64* %new_head, align 8
  %337 = load i64, i64* %new_head, align 8
  %338 = load i64, i64* %key, align 8
  %call654 = call i64 @CDR_SAFE(i64 %338)
  %call655 = call i64 @CAR_SAFE(i64 %call654)
  %call656 = call i64 @list2(i64 %337, i64 %call655)
  store i64 %call656, i64* %new_click, align 8
  %339 = load i64, i64* %current_binding, align 8
  %340 = load i64, i64* %new_click, align 8
  %call657 = call i64 @follow_key(i64 %339, i64 %340)
  store i64 %call657, i64* %new_binding, align 8
  %341 = load i64, i64* %new_binding, align 8
  %call658 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp659 = icmp eq i64 %341, %call658
  br i1 %cmp659, label %if.end.662, label %if.then.661

if.then.661:                                      ; preds = %if.end.650
  %342 = load i64, i64* %new_binding, align 8
  store i64 %342, i64* %current_binding, align 8
  %343 = load i64, i64* %new_click, align 8
  store i64 %343, i64* %key, align 8
  br label %while.end.663

if.end.662:                                       ; preds = %if.end.650
  br label %while.cond.575

while.end.663:                                    ; preds = %if.then.661, %while.cond.575
  br label %if.end.664

if.end.664:                                       ; preds = %while.end.663, %if.then.563
  br label %if.end.665

if.end.665:                                       ; preds = %if.end.664, %cond.end.557
  br label %if.end.666

if.end.666:                                       ; preds = %if.end.665, %cond.end.540
  %344 = load i64, i64* %new_binding, align 8
  store i64 %344, i64* %current_binding, align 8
  %345 = load i64, i64* %key, align 8
  %346 = load i32, i32* %t, align 4
  %inc667 = add nsw i32 %346, 1
  store i32 %inc667, i32* %t, align 4
  %idxprom668 = sext i32 %346 to i64
  %347 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx669 = getelementptr inbounds i64, i64* %347, i64 %idxprom668
  store i64 %345, i64* %arrayidx669, align 8
  %348 = load i8, i8* %used_mouse_menu, align 1
  %tobool670 = trunc i8 %348 to i1
  br i1 %tobool670, label %if.end.672, label %if.then.671

if.then.671:                                      ; preds = %if.end.666
  %349 = load i64, i64* %key, align 8
  store i64 %349, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  br label %if.end.672

if.end.672:                                       ; preds = %if.then.671, %if.end.666
  %350 = load i64, i64* @this_command_key_count, align 8
  %351 = load i32, i32* %t, align 4
  %conv673 = sext i32 %351 to i64
  %sub674 = sub nsw i64 %350, %conv673
  store i64 %sub674, i64* @this_single_command_key_start, align 8
  %352 = load i64, i64* @this_single_command_key_start, align 8
  %cmp675 = icmp slt i64 %352, 0
  br i1 %cmp675, label %if.then.677, label %if.end.678

if.then.677:                                      ; preds = %if.end.672
  store i64 0, i64* @this_single_command_key_start, align 8
  br label %if.end.678

if.end.678:                                       ; preds = %if.then.677, %if.end.672
  br label %while.cond.679

while.cond.679:                                   ; preds = %if.end.701, %if.end.678
  %end680 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  %353 = load i32, i32* %end680, align 4
  %354 = load i32, i32* %t, align 4
  %cmp681 = icmp slt i32 %353, %354
  br i1 %cmp681, label %while.body.683, label %while.end.702

while.body.683:                                   ; preds = %while.cond.679
  %355 = load i64*, i64** %keybuf.addr, align 8
  %356 = load i32, i32* %bufsize.addr, align 4
  %357 = load i32, i32* %t, align 4
  %358 = load i32, i32* %mock_input, align 4
  %cmp684 = icmp sgt i32 %357, %358
  br i1 %cmp684, label %cond.true.686, label %cond.false.687

cond.true.686:                                    ; preds = %while.body.683
  %359 = load i32, i32* %t, align 4
  br label %cond.end.688

cond.false.687:                                   ; preds = %while.body.683
  %360 = load i32, i32* %mock_input, align 4
  br label %cond.end.688

cond.end.688:                                     ; preds = %cond.false.687, %cond.true.686
  %cond689 = phi i32 [ %359, %cond.true.686 ], [ %360, %cond.false.687 ]
  %361 = load i64, i64* %prompt.addr, align 8
  %call690 = call zeroext i1 @keyremap_step(i64* %355, i32 %356, %struct.keyremap* %indec, i32 %cond689, i1 zeroext true, i32* %diff, i64 %361)
  %frombool691 = zext i1 %call690 to i8
  store i8 %frombool691, i8* %done, align 1
  %362 = load i8, i8* %done, align 1
  %tobool692 = trunc i8 %362 to i1
  br i1 %tobool692, label %if.then.693, label %if.end.701

if.then.693:                                      ; preds = %cond.end.688
  %363 = load i32, i32* %diff, align 4
  %364 = load i32, i32* %t, align 4
  %365 = load i32, i32* %mock_input, align 4
  %cmp694 = icmp sgt i32 %364, %365
  br i1 %cmp694, label %cond.true.696, label %cond.false.697

cond.true.696:                                    ; preds = %if.then.693
  %366 = load i32, i32* %t, align 4
  br label %cond.end.698

cond.false.697:                                   ; preds = %if.then.693
  %367 = load i32, i32* %mock_input, align 4
  br label %cond.end.698

cond.end.698:                                     ; preds = %cond.false.697, %cond.true.696
  %cond699 = phi i32 [ %366, %cond.true.696 ], [ %367, %cond.false.697 ]
  %add700 = add nsw i32 %363, %cond699
  store i32 %add700, i32* %mock_input, align 4
  br label %replay_sequence

if.end.701:                                       ; preds = %cond.end.688
  br label %while.cond.679

while.end.702:                                    ; preds = %while.cond.679
  %368 = load i64, i64* %current_binding, align 8
  %call703 = call i64 @get_keymap(i64 %368, i1 zeroext false, i1 zeroext false)
  %call704 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp705 = icmp eq i64 %call703, %call704
  br i1 %cmp705, label %land.lhs.true.707, label %if.else.723

land.lhs.true.707:                                ; preds = %while.end.702
  %369 = load i64, i64* %current_binding, align 8
  %call708 = call zeroext i1 @test_undefined(i64 %369)
  br i1 %call708, label %if.else.723, label %land.lhs.true.709

land.lhs.true.709:                                ; preds = %land.lhs.true.707
  %start710 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %370 = load i32, i32* %start710, align 4
  %371 = load i32, i32* %t, align 4
  %cmp711 = icmp sge i32 %370, %371
  br i1 %cmp711, label %if.then.713, label %if.else.723

if.then.713:                                      ; preds = %land.lhs.true.709
  %start714 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %372 = load i32, i32* %start714, align 4
  %373 = load i32, i32* %t, align 4
  %cmp715 = icmp slt i32 %372, %373
  br i1 %cmp715, label %if.then.717, label %if.end.722

if.then.717:                                      ; preds = %if.then.713
  %374 = load i32, i32* %t, align 4
  %end718 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  store i32 %374, i32* %end718, align 4
  %start719 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  store i32 %374, i32* %start719, align 4
  %parent720 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 0
  %375 = load i64, i64* %parent720, align 8
  %map721 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 1
  store i64 %375, i64* %map721, align 8
  br label %if.end.722

if.end.722:                                       ; preds = %if.then.717, %if.then.713
  br label %if.end.763

if.else.723:                                      ; preds = %land.lhs.true.709, %land.lhs.true.707, %while.end.702
  br label %while.cond.724

while.cond.724:                                   ; preds = %if.end.761, %if.else.723
  %end725 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  %376 = load i32, i32* %end725, align 4
  %start726 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %377 = load i32, i32* %start726, align 4
  %cmp727 = icmp slt i32 %376, %377
  br i1 %cmp727, label %while.body.729, label %while.end.762

while.body.729:                                   ; preds = %while.cond.724
  %378 = load i64*, i64** %keybuf.addr, align 8
  %379 = load i32, i32* %bufsize.addr, align 4
  %380 = load i32, i32* %t, align 4
  %381 = load i32, i32* %mock_input, align 4
  %cmp732 = icmp sgt i32 %380, %381
  br i1 %cmp732, label %cond.true.734, label %cond.false.735

cond.true.734:                                    ; preds = %while.body.729
  %382 = load i32, i32* %t, align 4
  br label %cond.end.736

cond.false.735:                                   ; preds = %while.body.729
  %383 = load i32, i32* %mock_input, align 4
  br label %cond.end.736

cond.end.736:                                     ; preds = %cond.false.735, %cond.true.734
  %cond737 = phi i32 [ %382, %cond.true.734 ], [ %383, %cond.false.735 ]
  %end738 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  %384 = load i32, i32* %end738, align 4
  %add739 = add nsw i32 %384, 1
  %385 = load i32, i32* %t, align 4
  %cmp740 = icmp eq i32 %add739, %385
  br i1 %cmp740, label %land.rhs.742, label %land.end.745

land.rhs.742:                                     ; preds = %cond.end.736
  %386 = load i64, i64* %current_binding, align 8
  %call743 = call zeroext i1 @test_undefined(i64 %386)
  br label %land.end.745

land.end.745:                                     ; preds = %land.rhs.742, %cond.end.736
  %387 = phi i1 [ false, %cond.end.736 ], [ %call743, %land.rhs.742 ]
  %388 = load i64, i64* %prompt.addr, align 8
  %call746 = call zeroext i1 @keyremap_step(i64* %378, i32 %379, %struct.keyremap* %fkey, i32 %cond737, i1 zeroext %387, i32* %diff731, i64 %388)
  %frombool747 = zext i1 %call746 to i8
  store i8 %frombool747, i8* %done730, align 1
  %389 = load i8, i8* %done730, align 1
  %tobool748 = trunc i8 %389 to i1
  br i1 %tobool748, label %if.then.749, label %if.end.761

if.then.749:                                      ; preds = %land.end.745
  %390 = load i32, i32* %diff731, align 4
  %391 = load i32, i32* %t, align 4
  %392 = load i32, i32* %mock_input, align 4
  %cmp750 = icmp sgt i32 %391, %392
  br i1 %cmp750, label %cond.true.752, label %cond.false.753

cond.true.752:                                    ; preds = %if.then.749
  %393 = load i32, i32* %t, align 4
  br label %cond.end.754

cond.false.753:                                   ; preds = %if.then.749
  %394 = load i32, i32* %mock_input, align 4
  br label %cond.end.754

cond.end.754:                                     ; preds = %cond.false.753, %cond.true.752
  %cond755 = phi i32 [ %393, %cond.true.752 ], [ %394, %cond.false.753 ]
  %add756 = add nsw i32 %390, %cond755
  store i32 %add756, i32* %mock_input, align 4
  %395 = load i32, i32* %diff731, align 4
  %end757 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  %396 = load i32, i32* %end757, align 4
  %add758 = add nsw i32 %396, %395
  store i32 %add758, i32* %end757, align 4
  %397 = load i32, i32* %diff731, align 4
  %start759 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %398 = load i32, i32* %start759, align 4
  %add760 = add nsw i32 %398, %397
  store i32 %add760, i32* %start759, align 4
  br label %replay_sequence

if.end.761:                                       ; preds = %land.end.745
  br label %while.cond.724

while.end.762:                                    ; preds = %while.cond.724
  br label %if.end.763

if.end.763:                                       ; preds = %while.end.762, %if.end.722
  br label %while.cond.764

while.cond.764:                                   ; preds = %if.end.797, %if.end.763
  %end765 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  %399 = load i32, i32* %end765, align 4
  %start766 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %400 = load i32, i32* %start766, align 4
  %cmp767 = icmp slt i32 %399, %400
  br i1 %cmp767, label %while.body.769, label %while.end.798

while.body.769:                                   ; preds = %while.cond.764
  %401 = load i64*, i64** %keybuf.addr, align 8
  %402 = load i32, i32* %bufsize.addr, align 4
  %403 = load i32, i32* %t, align 4
  %404 = load i32, i32* %mock_input, align 4
  %cmp772 = icmp sgt i32 %403, %404
  br i1 %cmp772, label %cond.true.774, label %cond.false.775

cond.true.774:                                    ; preds = %while.body.769
  %405 = load i32, i32* %t, align 4
  br label %cond.end.776

cond.false.775:                                   ; preds = %while.body.769
  %406 = load i32, i32* %mock_input, align 4
  br label %cond.end.776

cond.end.776:                                     ; preds = %cond.false.775, %cond.true.774
  %cond777 = phi i32 [ %405, %cond.true.774 ], [ %406, %cond.false.775 ]
  %407 = load i64, i64* %prompt.addr, align 8
  %call778 = call zeroext i1 @keyremap_step(i64* %401, i32 %402, %struct.keyremap* %keytran, i32 %cond777, i1 zeroext true, i32* %diff771, i64 %407)
  %frombool779 = zext i1 %call778 to i8
  store i8 %frombool779, i8* %done770, align 1
  %408 = load i8, i8* %done770, align 1
  %tobool780 = trunc i8 %408 to i1
  br i1 %tobool780, label %if.then.781, label %if.end.797

if.then.781:                                      ; preds = %cond.end.776
  %409 = load i32, i32* %diff771, align 4
  %410 = load i32, i32* %t, align 4
  %411 = load i32, i32* %mock_input, align 4
  %cmp782 = icmp sgt i32 %410, %411
  br i1 %cmp782, label %cond.true.784, label %cond.false.785

cond.true.784:                                    ; preds = %if.then.781
  %412 = load i32, i32* %t, align 4
  br label %cond.end.786

cond.false.785:                                   ; preds = %if.then.781
  %413 = load i32, i32* %mock_input, align 4
  br label %cond.end.786

cond.end.786:                                     ; preds = %cond.false.785, %cond.true.784
  %cond787 = phi i32 [ %412, %cond.true.784 ], [ %413, %cond.false.785 ]
  %add788 = add nsw i32 %409, %cond787
  store i32 %add788, i32* %mock_input, align 4
  %414 = load i32, i32* %diff771, align 4
  %end789 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 3
  %415 = load i32, i32* %end789, align 4
  %add790 = add nsw i32 %415, %414
  store i32 %add790, i32* %end789, align 4
  %416 = load i32, i32* %diff771, align 4
  %start791 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %indec, i32 0, i32 2
  %417 = load i32, i32* %start791, align 4
  %add792 = add nsw i32 %417, %416
  store i32 %add792, i32* %start791, align 4
  %418 = load i32, i32* %diff771, align 4
  %end793 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  %419 = load i32, i32* %end793, align 4
  %add794 = add nsw i32 %419, %418
  store i32 %add794, i32* %end793, align 4
  %420 = load i32, i32* %diff771, align 4
  %start795 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  %421 = load i32, i32* %start795, align 4
  %add796 = add nsw i32 %421, %420
  store i32 %add796, i32* %start795, align 4
  br label %replay_sequence

if.end.797:                                       ; preds = %cond.end.776
  br label %while.cond.764

while.end.798:                                    ; preds = %while.cond.764
  %422 = load i64, i64* %current_binding, align 8
  %call799 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp800 = icmp eq i64 %422, %call799
  br i1 %cmp800, label %land.lhs.true.802, label %if.end.866

land.lhs.true.802:                                ; preds = %while.end.798
  %start803 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %423 = load i32, i32* %start803, align 4
  %424 = load i32, i32* %t, align 4
  %cmp804 = icmp sge i32 %423, %424
  br i1 %cmp804, label %land.lhs.true.806, label %if.end.866

land.lhs.true.806:                                ; preds = %land.lhs.true.802
  %425 = load i64, i64* %key, align 8
  %and807 = and i64 %425, 7
  %conv808 = trunc i64 %and807 to i32
  %and809 = and i32 %conv808, -5
  %cmp810 = icmp eq i32 %and809, 2
  br i1 %cmp810, label %land.lhs.true.812, label %if.end.866

land.lhs.true.812:                                ; preds = %land.lhs.true.806
  %426 = load i64, i64* %key, align 8
  %shr813 = ashr i64 %426, 2
  %and814 = and i64 %shr813, -264241153
  %shl = shl i64 %and814, 2
  %add815 = add i64 %shl, 2
  %call816 = call zeroext i1 @NATNUMP(i64 %add815)
  br i1 %call816, label %land.lhs.true.818, label %lor.lhs.false.832

land.lhs.true.818:                                ; preds = %land.lhs.true.812
  %427 = load i64, i64* %key, align 8
  %shr819 = ashr i64 %427, 2
  %and820 = and i64 %shr819, -264241153
  %shl821 = shl i64 %and820, 2
  %add822 = add i64 %shl821, 2
  %shr823 = ashr i64 %add822, 2
  %cmp824 = icmp sle i64 %shr823, 4194303
  br i1 %cmp824, label %land.lhs.true.826, label %lor.lhs.false.832

land.lhs.true.826:                                ; preds = %land.lhs.true.818
  %428 = load i64, i64* %key, align 8
  %shr827 = ashr i64 %428, 2
  %and828 = and i64 %shr827, -264241153
  %conv829 = trunc i64 %and828 to i32
  %call830 = call zeroext i1 @uppercasep(i32 %conv829)
  br i1 %call830, label %if.then.836, label %lor.lhs.false.832

lor.lhs.false.832:                                ; preds = %land.lhs.true.826, %land.lhs.true.818, %land.lhs.true.812
  %429 = load i64, i64* %key, align 8
  %shr833 = ashr i64 %429, 2
  %and834 = and i64 %shr833, 33554432
  %tobool835 = icmp ne i64 %and834, 0
  br i1 %tobool835, label %if.then.836, label %if.end.866

if.then.836:                                      ; preds = %lor.lhs.false.832, %land.lhs.true.826
  %430 = load i64, i64* %key, align 8
  store i64 %430, i64* %original_uppercase, align 8
  %431 = load i32, i32* %t, align 4
  %sub837 = sub nsw i32 %431, 1
  store i32 %sub837, i32* %original_uppercase_position, align 4
  %432 = load i64, i64* %key, align 8
  %shr838 = ashr i64 %432, 2
  %and839 = and i64 %shr838, 33554432
  %tobool840 = icmp ne i64 %and839, 0
  br i1 %tobool840, label %if.then.841, label %if.else.846

if.then.841:                                      ; preds = %if.then.836
  %433 = load i64, i64* %key, align 8
  %shr842 = ashr i64 %433, 2
  %and843 = and i64 %shr842, -33554433
  %shl844 = shl i64 %and843, 2
  %add845 = add i64 %shl844, 2
  store i64 %add845, i64* %new_key, align 8
  br label %if.end.856

if.else.846:                                      ; preds = %if.then.836
  %434 = load i64, i64* %key, align 8
  %shr847 = ashr i64 %434, 2
  %and848 = and i64 %shr847, -264241153
  %conv849 = trunc i64 %and848 to i32
  %call850 = call i32 @downcase(i32 %conv849)
  %conv851 = sext i32 %call850 to i64
  %435 = load i64, i64* %key, align 8
  %shr852 = ashr i64 %435, 2
  %and853 = and i64 %shr852, 264241152
  %or = or i64 %conv851, %and853
  %shl854 = shl i64 %or, 2
  %add855 = add i64 %shl854, 2
  store i64 %add855, i64* %new_key, align 8
  br label %if.end.856

if.end.856:                                       ; preds = %if.else.846, %if.then.841
  %436 = load i64, i64* %new_key, align 8
  %437 = load i32, i32* %t, align 4
  %sub857 = sub nsw i32 %437, 1
  %idxprom858 = sext i32 %sub857 to i64
  %438 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx859 = getelementptr inbounds i64, i64* %438, i64 %idxprom858
  store i64 %436, i64* %arrayidx859, align 8
  %439 = load i32, i32* %t, align 4
  %440 = load i32, i32* %mock_input, align 4
  %cmp860 = icmp sgt i32 %439, %440
  br i1 %cmp860, label %cond.true.862, label %cond.false.863

cond.true.862:                                    ; preds = %if.end.856
  %441 = load i32, i32* %t, align 4
  br label %cond.end.864

cond.false.863:                                   ; preds = %if.end.856
  %442 = load i32, i32* %mock_input, align 4
  br label %cond.end.864

cond.end.864:                                     ; preds = %cond.false.863, %cond.true.862
  %cond865 = phi i32 [ %441, %cond.true.862 ], [ %442, %cond.false.863 ]
  store i32 %cond865, i32* %mock_input, align 4
  store i8 1, i8* %shift_translated, align 1
  br label %replay_sequence

if.end.866:                                       ; preds = %lor.lhs.false.832, %land.lhs.true.806, %land.lhs.true.802, %while.end.798
  %443 = load i64, i64* %current_binding, align 8
  %call867 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp868 = icmp eq i64 %443, %call867
  br i1 %cmp868, label %land.lhs.true.870, label %if.end.887

land.lhs.true.870:                                ; preds = %if.end.866
  %444 = load i64, i64* %key, align 8
  %and871 = and i64 %444, 7
  %conv872 = trunc i64 %and871 to i32
  %cmp873 = icmp eq i32 %conv872, 3
  br i1 %cmp873, label %cond.true.875, label %cond.false.878

cond.true.875:                                    ; preds = %land.lhs.true.870
  %445 = load i64, i64* %key, align 8
  %sub876 = sub nsw i64 %445, 3
  %446 = inttoptr i64 %sub876 to i8*
  %447 = bitcast i8* %446 to %struct.Lisp_Cons*
  %car877 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %447, i32 0, i32 0
  %448 = load i64, i64* %car877, align 8
  br label %cond.end.879

cond.false.878:                                   ; preds = %land.lhs.true.870
  %449 = load i64, i64* %key, align 8
  br label %cond.end.879

cond.end.879:                                     ; preds = %cond.false.878, %cond.true.875
  %cond880 = phi i64 [ %448, %cond.true.875 ], [ %449, %cond.false.878 ]
  %call881 = call zeroext i1 @help_char_p(i64 %cond880)
  br i1 %call881, label %land.lhs.true.883, label %if.end.887

land.lhs.true.883:                                ; preds = %cond.end.879
  %450 = load i32, i32* %t, align 4
  %cmp884 = icmp sgt i32 %450, 1
  br i1 %cmp884, label %if.then.886, label %if.end.887

if.then.886:                                      ; preds = %land.lhs.true.883
  %451 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 224), align 8
  store i64 %451, i64* @read_key_sequence_cmd, align 8
  store i8 1, i8* %dummyflag, align 1
  br label %while.end.970

if.end.887:                                       ; preds = %land.lhs.true.883, %cond.end.879, %if.end.866
  %452 = load i64, i64* %current_binding, align 8
  %call888 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp889 = icmp eq i64 %452, %call888
  br i1 %cmp889, label %land.lhs.true.891, label %if.end.969

land.lhs.true.891:                                ; preds = %if.end.887
  %start892 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  %453 = load i32, i32* %start892, align 4
  %454 = load i32, i32* %t, align 4
  %cmp893 = icmp sge i32 %453, %454
  br i1 %cmp893, label %if.then.895, label %if.end.969

if.then.895:                                      ; preds = %land.lhs.true.891
  %455 = load i64, i64* %key, align 8
  %call897 = call i64 @parse_modifiers(i64 %455)
  store i64 %call897, i64* %breakdown896, align 8
  %456 = load i64, i64* %breakdown896, align 8
  %and899 = and i64 %456, 7
  %conv900 = trunc i64 %and899 to i32
  %cmp901 = icmp eq i32 %conv900, 3
  br i1 %cmp901, label %cond.true.903, label %cond.false.910

cond.true.903:                                    ; preds = %if.then.895
  %457 = load i64, i64* %breakdown896, align 8
  %sub904 = sub nsw i64 %457, 3
  %458 = inttoptr i64 %sub904 to i8*
  %459 = bitcast i8* %458 to %struct.Lisp_Cons*
  %u905 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %459, i32 0, i32 1
  %cdr906 = bitcast %union.anon.12* %u905 to i64*
  %460 = load i64, i64* %cdr906, align 8
  %sub907 = sub nsw i64 %460, 3
  %461 = inttoptr i64 %sub907 to i8*
  %462 = bitcast i8* %461 to %struct.Lisp_Cons*
  %car908 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %462, i32 0, i32 0
  %463 = load i64, i64* %car908, align 8
  %shr909 = ashr i64 %463, 2
  br label %cond.end.911

cond.false.910:                                   ; preds = %if.then.895
  br label %cond.end.911

cond.end.911:                                     ; preds = %cond.false.910, %cond.true.903
  %cond912 = phi i64 [ %shr909, %cond.true.903 ], [ 0, %cond.false.910 ]
  %conv913 = trunc i64 %cond912 to i32
  store i32 %conv913, i32* %modifiers898, align 4
  %464 = load i32, i32* %modifiers898, align 4
  %and914 = and i32 %464, 33554432
  %tobool915 = icmp ne i32 %and914, 0
  br i1 %tobool915, label %if.then.934, label %lor.lhs.false.916

lor.lhs.false.916:                                ; preds = %cond.end.911
  %465 = load i64, i64* %key, align 8
  %and917 = and i64 %465, 7
  %conv918 = trunc i64 %and917 to i32
  %and919 = and i32 %conv918, -5
  %cmp920 = icmp eq i32 %and919, 2
  br i1 %cmp920, label %land.lhs.true.922, label %if.end.968

land.lhs.true.922:                                ; preds = %lor.lhs.false.916
  %466 = load i64, i64* %key, align 8
  %shr923 = ashr i64 %466, 2
  %and924 = and i64 %shr923, 4194303
  %467 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %downcase_table_ = getelementptr inbounds %struct.buffer, %struct.buffer* %467, i32 0, i32 23
  %468 = load i64, i64* %downcase_table_, align 8
  %call925 = call %struct.Lisp_Char_Table* @XCHAR_TABLE(i64 %468)
  %header = getelementptr inbounds %struct.Lisp_Char_Table, %struct.Lisp_Char_Table* %call925, i32 0, i32 0
  %size = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header, i32 0, i32 0
  %469 = load i64, i64* %size, align 8
  %cmp926 = icmp slt i64 %and924, %469
  br i1 %cmp926, label %land.lhs.true.928, label %if.end.968

land.lhs.true.928:                                ; preds = %land.lhs.true.922
  %470 = load i64, i64* %key, align 8
  %shr929 = ashr i64 %470, 2
  %and930 = and i64 %shr929, 4194303
  %conv931 = trunc i64 %and930 to i32
  %call932 = call zeroext i1 @uppercasep(i32 %conv931)
  br i1 %call932, label %if.then.934, label %if.end.968

if.then.934:                                      ; preds = %land.lhs.true.928, %cond.end.911
  %471 = load i32, i32* %modifiers898, align 4
  %and936 = and i32 %471, 33554432
  %tobool937 = icmp ne i32 %and936, 0
  br i1 %tobool937, label %cond.true.938, label %cond.false.943

cond.true.938:                                    ; preds = %if.then.934
  %472 = load i32, i32* %modifiers898, align 4
  %and939 = and i32 %472, -33554433
  %473 = load i64, i64* %breakdown896, align 8
  %sub940 = sub nsw i64 %473, 3
  %474 = inttoptr i64 %sub940 to i8*
  %475 = bitcast i8* %474 to %struct.Lisp_Cons*
  %car941 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %475, i32 0, i32 0
  %476 = load i64, i64* %car941, align 8
  %call942 = call i64 @apply_modifiers(i32 %and939, i64 %476)
  br label %cond.end.952

cond.false.943:                                   ; preds = %if.then.934
  %477 = load i64, i64* %key, align 8
  %shr944 = ashr i64 %477, 2
  %and945 = and i64 %shr944, 4194303
  %conv946 = trunc i64 %and945 to i32
  %call947 = call i32 @downcase(i32 %conv946)
  %478 = load i32, i32* %modifiers898, align 4
  %or948 = or i32 %call947, %478
  %conv949 = sext i32 %or948 to i64
  %shl950 = shl i64 %conv949, 2
  %add951 = add i64 %shl950, 2
  br label %cond.end.952

cond.end.952:                                     ; preds = %cond.false.943, %cond.true.938
  %cond953 = phi i64 [ %call942, %cond.true.938 ], [ %add951, %cond.false.943 ]
  store i64 %cond953, i64* %new_key935, align 8
  %479 = load i64, i64* %key, align 8
  store i64 %479, i64* %original_uppercase, align 8
  %480 = load i32, i32* %t, align 4
  %sub954 = sub nsw i32 %480, 1
  store i32 %sub954, i32* %original_uppercase_position, align 4
  %481 = load i64, i64* %new_key935, align 8
  %482 = load i32, i32* %t, align 4
  %sub955 = sub nsw i32 %482, 1
  %idxprom956 = sext i32 %sub955 to i64
  %483 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx957 = getelementptr inbounds i64, i64* %483, i64 %idxprom956
  store i64 %481, i64* %arrayidx957, align 8
  %484 = load i32, i32* %t, align 4
  %485 = load i32, i32* %mock_input, align 4
  %cmp958 = icmp sgt i32 %484, %485
  br i1 %cmp958, label %cond.true.960, label %cond.false.961

cond.true.960:                                    ; preds = %cond.end.952
  %486 = load i32, i32* %t, align 4
  br label %cond.end.962

cond.false.961:                                   ; preds = %cond.end.952
  %487 = load i32, i32* %mock_input, align 4
  br label %cond.end.962

cond.end.962:                                     ; preds = %cond.false.961, %cond.true.960
  %cond963 = phi i32 [ %486, %cond.true.960 ], [ %487, %cond.false.961 ]
  store i32 %cond963, i32* %mock_input, align 4
  %end964 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 3
  store i32 0, i32* %end964, align 4
  %start965 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %fkey, i32 0, i32 2
  store i32 0, i32* %start965, align 4
  %end966 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 3
  store i32 0, i32* %end966, align 4
  %start967 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %keytran, i32 0, i32 2
  store i32 0, i32* %start967, align 4
  store i8 1, i8* %shift_translated, align 1
  br label %replay_sequence

if.end.968:                                       ; preds = %land.lhs.true.928, %land.lhs.true.922, %lor.lhs.false.916
  br label %if.end.969

if.end.969:                                       ; preds = %if.end.968, %land.lhs.true.891, %if.end.887
  br label %while.cond

while.end.970:                                    ; preds = %if.then.886, %if.then.237, %cond.end
  %488 = load i8, i8* %dummyflag, align 1
  %tobool971 = trunc i8 %488 to i1
  br i1 %tobool971, label %if.end.973, label %if.then.972

if.then.972:                                      ; preds = %while.end.970
  %489 = load i64, i64* %current_binding, align 8
  store i64 %489, i64* @read_key_sequence_cmd, align 8
  br label %if.end.973

if.end.973:                                       ; preds = %if.then.972, %while.end.970
  %490 = load i64, i64* @read_key_sequence_cmd, align 8
  %and974 = and i64 %490, 7
  %conv975 = trunc i64 %and974 to i32
  %cmp976 = icmp eq i32 %conv975, 0
  br i1 %cmp976, label %cond.true.978, label %cond.false.982

cond.true.978:                                    ; preds = %if.end.973
  %491 = load i64, i64* @read_key_sequence_cmd, align 8
  %call979 = call i64 @builtin_lisp_symbol(i32 0)
  %call980 = call i64 @builtin_lisp_symbol(i32 0)
  %call981 = call i64 @Fcommand_remapping(i64 %491, i64 %call979, i64 %call980)
  br label %cond.end.984

cond.false.982:                                   ; preds = %if.end.973
  %call983 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.984

cond.end.984:                                     ; preds = %cond.false.982, %cond.true.978
  %cond985 = phi i64 [ %call981, %cond.true.978 ], [ %call983, %cond.false.982 ]
  store i64 %cond985, i64* @read_key_sequence_remapped, align 8
  %492 = load i64, i64* %delayed_switch_frame, align 8
  store i64 %492, i64* @unread_switch_frame, align 8
  %493 = load i64, i64* %count, align 8
  %call986 = call i64 @builtin_lisp_symbol(i32 0)
  %call987 = call i64 @unbind_to(i64 %493, i64 %call986)
  %494 = load i8, i8* %dont_downcase_last.addr, align 1
  %tobool988 = trunc i8 %494 to i1
  br i1 %tobool988, label %land.lhs.true.994, label %lor.lhs.false.990

lor.lhs.false.990:                                ; preds = %cond.end.984
  %495 = load i64, i64* %current_binding, align 8
  %call991 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp992 = icmp eq i64 %495, %call991
  br i1 %cmp992, label %land.lhs.true.994, label %if.end.1005

land.lhs.true.994:                                ; preds = %lor.lhs.false.990, %cond.end.984
  %496 = load i32, i32* %t, align 4
  %cmp995 = icmp sgt i32 %496, 0
  br i1 %cmp995, label %land.lhs.true.997, label %if.end.1005

land.lhs.true.997:                                ; preds = %land.lhs.true.994
  %497 = load i32, i32* %t, align 4
  %sub998 = sub nsw i32 %497, 1
  %498 = load i32, i32* %original_uppercase_position, align 4
  %cmp999 = icmp eq i32 %sub998, %498
  br i1 %cmp999, label %if.then.1001, label %if.end.1005

if.then.1001:                                     ; preds = %land.lhs.true.997
  %499 = load i64, i64* %original_uppercase, align 8
  %500 = load i32, i32* %t, align 4
  %sub1002 = sub nsw i32 %500, 1
  %idxprom1003 = sext i32 %sub1002 to i64
  %501 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx1004 = getelementptr inbounds i64, i64* %501, i64 %idxprom1003
  store i64 %499, i64* %arrayidx1004, align 8
  store i8 0, i8* %shift_translated, align 1
  br label %if.end.1005

if.end.1005:                                      ; preds = %if.then.1001, %land.lhs.true.997, %land.lhs.true.994, %lor.lhs.false.990
  %502 = load i8, i8* %shift_translated, align 1
  %tobool1006 = trunc i8 %502 to i1
  br i1 %tobool1006, label %if.then.1007, label %if.end.1009

if.then.1007:                                     ; preds = %if.end.1005
  %call1008 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1008, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 294), align 8
  br label %if.end.1009

if.end.1009:                                      ; preds = %if.then.1007, %if.end.1005
  br label %for.cond.1010

for.cond.1010:                                    ; preds = %for.inc.1016, %if.end.1009
  %503 = load i32, i32* %t, align 4
  %504 = load i32, i32* %mock_input, align 4
  %cmp1011 = icmp slt i32 %503, %504
  br i1 %cmp1011, label %for.body.1013, label %for.end.1018

for.body.1013:                                    ; preds = %for.cond.1010
  %505 = load i32, i32* %t, align 4
  %idxprom1014 = sext i32 %505 to i64
  %506 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx1015 = getelementptr inbounds i64, i64* %506, i64 %idxprom1014
  %507 = load i64, i64* %arrayidx1015, align 8
  call void @add_command_key(i64 %507)
  br label %for.inc.1016

for.inc.1016:                                     ; preds = %for.body.1013
  %508 = load i32, i32* %t, align 4
  %inc1017 = add nsw i32 %508, 1
  store i32 %inc1017, i32* %t, align 4
  br label %for.cond.1010

for.end.1018:                                     ; preds = %for.cond.1010
  call void @echo_update()
  %509 = load i32, i32* %t, align 4
  store i32 %509, i32* %retval
  br label %return

return:                                           ; preds = %for.end.1018, %if.then.224
  %510 = load i32, i32* %retval
  ret i32 %510
}

declare void @process_quit_flag() #1

; Function Attrs: nounwind uwtable
define void @process_pending_signals() #0 {
entry:
  store volatile i8 0, i8* @pending_signals, align 1
  call void @handle_async_input()
  call void @do_pending_atimers()
  ret void
}

declare void @ASET(i64, i64, i64) #1

declare i64 @Fcons(i64, i64) #1

declare void @record_unwind_protect_void(void ()*) #1

declare void @start_hourglass() #1

declare i64 @call1(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @echo_now() #0 {
entry:
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo1 = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 24
  %bf.load2 = load i8, i8* %immediate_echo1, align 1
  %bf.clear3 = and i8 %bf.load2, -2
  %bf.set = or i8 %bf.clear3, 1
  store i8 %bf.set, i8* %immediate_echo1, align 1
  call void @echo_update()
  call void @echo_dash()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i8 1, i8* @echoing, align 1
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %2, i32 0, i32 22
  %3 = load i64, i64* %echo_string_, align 8
  call void @message3_nolog(i64 %3)
  store i8 0, i8* @echoing, align 1
  %4 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  store i64 %4, i64* @echo_message_buffer, align 8
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  store %struct.kboard* %5, %struct.kboard** @echo_kboard, align 8
  %6 = load i8, i8* @waiting_for_input, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end.5

land.lhs.true:                                    ; preds = %if.end
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %7, %call
  br i1 %cmp, label %if.end.5, label %if.then.4

if.then.4:                                        ; preds = %land.lhs.true
  call void @quit_throw_to_read_char(i1 zeroext false) #11
  unreachable

if.end.5:                                         ; preds = %land.lhs.true, %if.end
  ret void
}

declare i64 @Fwindow_system(i64) #1

declare %struct.Lisp_Marker* @XMARKER(i64) #1

declare i64 @CAR_SAFE(i64) #1

declare i64 @Fmemq(i64, i64) #1

declare i64 @Fsymbol_value(i64) #1

declare i64 @Flength(i64) #1

declare i64 @call2(i64, i64, i64) #1

declare void @run_hook(i64) #1

declare i64 @intern(i8*) #1

declare i64 @composition_adjust_point(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @adjust_point_for_property(i64 %last_pt, i1 zeroext %modified) #0 {
entry:
  %last_pt.addr = alloca i64, align 8
  %modified.addr = alloca i8, align 1
  %beg = alloca i64, align 8
  %end = alloca i64, align 8
  %val = alloca i64, align 8
  %overlay = alloca i64, align 8
  %tmp = alloca i64, align 8
  %check_composition = alloca i8, align 1
  %check_display = alloca i8, align 1
  %check_invisible = alloca i8, align 1
  %orig_pt = alloca i64, align 8
  %inv = alloca i32, align 4
  %ellipsis = alloca i8, align 1
  store i64 %last_pt, i64* %last_pt.addr, align 8
  %frombool = zext i1 %modified to i8
  store i8 %frombool, i8* %modified.addr, align 1
  %0 = load i8, i8* %modified.addr, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  %frombool2 = zext i1 %lnot to i8
  store i8 %frombool2, i8* %check_composition, align 1
  store i8 1, i8* %check_display, align 1
  store i8 1, i8* %check_invisible, align 1
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 75
  %2 = load i64, i64* %pt, align 8
  %add = add nsw i64 %2, 0
  store i64 %add, i64* %orig_pt, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.448, %entry
  %3 = load i8, i8* %check_composition, align 1
  %tobool6 = trunc i8 %3 to i1
  br i1 %tobool6, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.cond
  %4 = load i8, i8* %check_display, align 1
  %tobool7 = trunc i8 %4 to i1
  br i1 %tobool7, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %5 = load i8, i8* %check_invisible, align 1
  %tobool8 = trunc i8 %5 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %while.cond
  %6 = phi i1 [ true, %lor.lhs.false ], [ true, %while.cond ], [ %tobool8, %lor.rhs ]
  br i1 %6, label %while.body, label %while.end.449

while.body:                                       ; preds = %lor.end
  %7 = load i8, i8* %check_composition, align 1
  %tobool9 = trunc i8 %7 to i1
  br i1 %tobool9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt10 = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 75
  %9 = load i64, i64* %pt10, align 8
  %add11 = add nsw i64 %9, 0
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 77
  %11 = load i64, i64* %begv, align 8
  %cmp = icmp sgt i64 %add11, %11
  br i1 %cmp, label %land.lhs.true.12, label %if.end

land.lhs.true.12:                                 ; preds = %land.lhs.true
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt13 = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 75
  %13 = load i64, i64* %pt13, align 8
  %add14 = add nsw i64 %13, 0
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %14, i32 0, i32 79
  %15 = load i64, i64* %zv, align 8
  %cmp15 = icmp slt i64 %add14, %15
  br i1 %cmp15, label %land.lhs.true.16, label %if.end

land.lhs.true.16:                                 ; preds = %land.lhs.true.12
  %16 = load i64, i64* %last_pt.addr, align 8
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt17 = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 75
  %18 = load i64, i64* %pt17, align 8
  %add18 = add nsw i64 %18, 0
  %call = call i64 @composition_adjust_point(i64 %16, i64 %add18)
  store i64 %call, i64* %beg, align 8
  %19 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt19 = getelementptr inbounds %struct.buffer, %struct.buffer* %19, i32 0, i32 75
  %20 = load i64, i64* %pt19, align 8
  %add20 = add nsw i64 %20, 0
  %cmp21 = icmp ne i64 %call, %add20
  br i1 %cmp21, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.16
  %21 = load i64, i64* %beg, align 8
  call void @set_point(i64 %21)
  store i8 1, i8* %check_invisible, align 1
  store i8 1, i8* %check_display, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.16, %land.lhs.true.12, %land.lhs.true, %while.body
  store i8 0, i8* %check_composition, align 1
  %22 = load i8, i8* %check_display, align 1
  %tobool22 = trunc i8 %22 to i1
  br i1 %tobool22, label %land.lhs.true.23, label %if.end.132

land.lhs.true.23:                                 ; preds = %if.end
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt24 = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 75
  %24 = load i64, i64* %pt24, align 8
  %add25 = add nsw i64 %24, 0
  %25 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv26 = getelementptr inbounds %struct.buffer, %struct.buffer* %25, i32 0, i32 77
  %26 = load i64, i64* %begv26, align 8
  %cmp27 = icmp sgt i64 %add25, %26
  br i1 %cmp27, label %land.lhs.true.28, label %if.end.132

land.lhs.true.28:                                 ; preds = %land.lhs.true.23
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt29 = getelementptr inbounds %struct.buffer, %struct.buffer* %27, i32 0, i32 75
  %28 = load i64, i64* %pt29, align 8
  %add30 = add nsw i64 %28, 0
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv31 = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 79
  %30 = load i64, i64* %zv31, align 8
  %cmp32 = icmp slt i64 %add30, %30
  br i1 %cmp32, label %land.lhs.true.33, label %if.end.132

land.lhs.true.33:                                 ; preds = %land.lhs.true.28
  %31 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt34 = getelementptr inbounds %struct.buffer, %struct.buffer* %31, i32 0, i32 75
  %32 = load i64, i64* %pt34, align 8
  %add35 = add nsw i64 %32, 0
  %shl = shl i64 %add35, 2
  %add36 = add i64 %shl, 2
  %call37 = call i64 @builtin_lisp_symbol(i32 344)
  %33 = load i64, i64* @selected_window, align 8
  %call38 = call i64 @get_char_property_and_overlay(i64 %add36, i64 %call37, i64 %33, i64* %overlay)
  store i64 %call38, i64* %val, align 8
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp40 = icmp eq i64 %call38, %call39
  br i1 %cmp40, label %if.end.132, label %land.lhs.true.41

land.lhs.true.41:                                 ; preds = %land.lhs.true.33
  %34 = load i64, i64* %val, align 8
  %35 = load i64, i64* %overlay, align 8
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt42 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 75
  %37 = load i64, i64* %pt42, align 8
  %add43 = add nsw i64 %37, 0
  %38 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %38, i32 0, i32 76
  %39 = load i64, i64* %pt_byte, align 8
  %add44 = add nsw i64 %39, 0
  %call45 = call zeroext i1 @display_prop_intangible_p(i64 %34, i64 %35, i64 %add43, i64 %add44)
  br i1 %call45, label %land.lhs.true.46, label %if.end.132

land.lhs.true.46:                                 ; preds = %land.lhs.true.41
  %40 = load i64, i64* %overlay, align 8
  %call47 = call zeroext i1 @OVERLAYP(i64 %40)
  br i1 %call47, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true.46
  %41 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt48 = getelementptr inbounds %struct.buffer, %struct.buffer* %41, i32 0, i32 75
  %42 = load i64, i64* %pt48, align 8
  %add49 = add nsw i64 %42, 0
  %call50 = call i64 @builtin_lisp_symbol(i32 344)
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %call52 = call zeroext i1 @get_property_and_range(i64 %add49, i64 %call50, i64* %val, i64* %beg, i64* %end, i64 %call51)
  br i1 %call52, label %land.lhs.true.87, label %if.end.132

cond.false:                                       ; preds = %land.lhs.true.46
  %43 = load i64, i64* %overlay, align 8
  %call53 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %43)
  %start = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call53, i32 0, i32 2
  %44 = load i64, i64* %start, align 8
  %and = and i64 %44, 7
  %conv = trunc i64 %and to i32
  %cmp54 = icmp eq i32 %conv, 1
  br i1 %cmp54, label %land.lhs.true.56, label %cond.false.66

land.lhs.true.56:                                 ; preds = %cond.false
  %45 = load i64, i64* %overlay, align 8
  %call57 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %45)
  %start58 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call57, i32 0, i32 2
  %46 = load i64, i64* %start58, align 8
  %call59 = call i32 @XMISCTYPE(i64 %46)
  %cmp60 = icmp eq i32 %call59, 24236
  br i1 %cmp60, label %cond.true.62, label %cond.false.66

cond.true.62:                                     ; preds = %land.lhs.true.56
  %47 = load i64, i64* %overlay, align 8
  %call63 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %47)
  %start64 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call63, i32 0, i32 2
  %48 = load i64, i64* %start64, align 8
  %call65 = call i64 @marker_position(i64 %48)
  br label %cond.end

cond.false.66:                                    ; preds = %land.lhs.true.56, %cond.false
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %49, %cond.true.62
  %cond = phi i64 [ %call65, %cond.true.62 ], [ 0, %49 ]
  store i64 %cond, i64* %beg, align 8
  %50 = load i64, i64* %overlay, align 8
  %call67 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %50)
  %end68 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call67, i32 0, i32 3
  %51 = load i64, i64* %end68, align 8
  %and69 = and i64 %51, 7
  %conv70 = trunc i64 %and69 to i32
  %cmp71 = icmp eq i32 %conv70, 1
  br i1 %cmp71, label %land.lhs.true.73, label %cond.false.83

land.lhs.true.73:                                 ; preds = %cond.end
  %52 = load i64, i64* %overlay, align 8
  %call74 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %52)
  %end75 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call74, i32 0, i32 3
  %53 = load i64, i64* %end75, align 8
  %call76 = call i32 @XMISCTYPE(i64 %53)
  %cmp77 = icmp eq i32 %call76, 24236
  br i1 %cmp77, label %cond.true.79, label %cond.false.83

cond.true.79:                                     ; preds = %land.lhs.true.73
  %54 = load i64, i64* %overlay, align 8
  %call80 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %54)
  %end81 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call80, i32 0, i32 3
  %55 = load i64, i64* %end81, align 8
  %call82 = call i64 @marker_position(i64 %55)
  br label %cond.end.84

cond.false.83:                                    ; preds = %land.lhs.true.73, %cond.end
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.84

cond.end.84:                                      ; preds = %56, %cond.true.79
  %cond85 = phi i64 [ %call82, %cond.true.79 ], [ 0, %56 ]
  store i64 %cond85, i64* %end, align 8
  %tobool86 = icmp ne i64 %cond85, 0
  br i1 %tobool86, label %land.lhs.true.87, label %if.end.132

land.lhs.true.87:                                 ; preds = %cond.end.84, %cond.true
  %57 = load i64, i64* %beg, align 8
  %58 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt88 = getelementptr inbounds %struct.buffer, %struct.buffer* %58, i32 0, i32 75
  %59 = load i64, i64* %pt88, align 8
  %add89 = add nsw i64 %59, 0
  %cmp90 = icmp slt i64 %57, %add89
  br i1 %cmp90, label %if.then.104, label %lor.lhs.false.92

lor.lhs.false.92:                                 ; preds = %land.lhs.true.87
  %60 = load i64, i64* %beg, align 8
  %61 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt93 = getelementptr inbounds %struct.buffer, %struct.buffer* %61, i32 0, i32 75
  %62 = load i64, i64* %pt93, align 8
  %add94 = add nsw i64 %62, 0
  %cmp95 = icmp sle i64 %60, %add94
  br i1 %cmp95, label %land.lhs.true.97, label %if.end.132

land.lhs.true.97:                                 ; preds = %lor.lhs.false.92
  %63 = load i64, i64* %val, align 8
  %call98 = call zeroext i1 @STRINGP(i64 %63)
  br i1 %call98, label %land.lhs.true.100, label %if.end.132

land.lhs.true.100:                                ; preds = %land.lhs.true.97
  %64 = load i64, i64* %val, align 8
  %call101 = call i64 @SCHARS(i64 %64)
  %cmp102 = icmp eq i64 %call101, 0
  br i1 %cmp102, label %if.then.104, label %if.end.132

if.then.104:                                      ; preds = %land.lhs.true.100, %land.lhs.true.87
  %65 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt105 = getelementptr inbounds %struct.buffer, %struct.buffer* %65, i32 0, i32 75
  %66 = load i64, i64* %pt105, align 8
  %add106 = add nsw i64 %66, 0
  %67 = load i64, i64* %last_pt.addr, align 8
  %cmp107 = icmp slt i64 %add106, %67
  br i1 %cmp107, label %cond.true.109, label %cond.false.129

cond.true.109:                                    ; preds = %if.then.104
  %68 = load i64, i64* %val, align 8
  %call110 = call zeroext i1 @STRINGP(i64 %68)
  br i1 %call110, label %land.lhs.true.112, label %cond.false.126

land.lhs.true.112:                                ; preds = %cond.true.109
  %69 = load i64, i64* %val, align 8
  %call113 = call i64 @SCHARS(i64 %69)
  %cmp114 = icmp eq i64 %call113, 0
  br i1 %cmp114, label %cond.true.116, label %cond.false.126

cond.true.116:                                    ; preds = %land.lhs.true.112
  %70 = load i64, i64* %beg, align 8
  %sub = sub nsw i64 %70, 1
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv117 = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 77
  %72 = load i64, i64* %begv117, align 8
  %cmp118 = icmp sgt i64 %sub, %72
  br i1 %cmp118, label %cond.true.120, label %cond.false.122

cond.true.120:                                    ; preds = %cond.true.116
  %73 = load i64, i64* %beg, align 8
  %sub121 = sub nsw i64 %73, 1
  br label %cond.end.124

cond.false.122:                                   ; preds = %cond.true.116
  %74 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv123 = getelementptr inbounds %struct.buffer, %struct.buffer* %74, i32 0, i32 77
  %75 = load i64, i64* %begv123, align 8
  br label %cond.end.124

cond.end.124:                                     ; preds = %cond.false.122, %cond.true.120
  %cond125 = phi i64 [ %sub121, %cond.true.120 ], [ %75, %cond.false.122 ]
  br label %cond.end.127

cond.false.126:                                   ; preds = %land.lhs.true.112, %cond.true.109
  %76 = load i64, i64* %beg, align 8
  br label %cond.end.127

cond.end.127:                                     ; preds = %cond.false.126, %cond.end.124
  %cond128 = phi i64 [ %cond125, %cond.end.124 ], [ %76, %cond.false.126 ]
  br label %cond.end.130

cond.false.129:                                   ; preds = %if.then.104
  %77 = load i64, i64* %end, align 8
  br label %cond.end.130

cond.end.130:                                     ; preds = %cond.false.129, %cond.end.127
  %cond131 = phi i64 [ %cond128, %cond.end.127 ], [ %77, %cond.false.129 ]
  call void @set_point(i64 %cond131)
  store i8 1, i8* %check_invisible, align 1
  store i8 1, i8* %check_composition, align 1
  br label %if.end.132

if.end.132:                                       ; preds = %cond.end.130, %land.lhs.true.100, %land.lhs.true.97, %lor.lhs.false.92, %cond.end.84, %cond.true, %land.lhs.true.41, %land.lhs.true.33, %land.lhs.true.28, %land.lhs.true.23, %if.end
  store i8 0, i8* %check_display, align 1
  %78 = load i8, i8* %check_invisible, align 1
  %tobool133 = trunc i8 %78 to i1
  br i1 %tobool133, label %land.lhs.true.135, label %if.end.448

land.lhs.true.135:                                ; preds = %if.end.132
  %79 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt136 = getelementptr inbounds %struct.buffer, %struct.buffer* %79, i32 0, i32 75
  %80 = load i64, i64* %pt136, align 8
  %add137 = add nsw i64 %80, 0
  %81 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv138 = getelementptr inbounds %struct.buffer, %struct.buffer* %81, i32 0, i32 77
  %82 = load i64, i64* %begv138, align 8
  %cmp139 = icmp sgt i64 %add137, %82
  br i1 %cmp139, label %land.lhs.true.141, label %if.end.448

land.lhs.true.141:                                ; preds = %land.lhs.true.135
  %83 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt142 = getelementptr inbounds %struct.buffer, %struct.buffer* %83, i32 0, i32 75
  %84 = load i64, i64* %pt142, align 8
  %add143 = add nsw i64 %84, 0
  %85 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv144 = getelementptr inbounds %struct.buffer, %struct.buffer* %85, i32 0, i32 79
  %86 = load i64, i64* %zv144, align 8
  %cmp145 = icmp slt i64 %add143, %86
  br i1 %cmp145, label %if.then.147, label %if.end.448

if.then.147:                                      ; preds = %land.lhs.true.141
  store i8 0, i8* %ellipsis, align 1
  %87 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt150 = getelementptr inbounds %struct.buffer, %struct.buffer* %87, i32 0, i32 75
  %88 = load i64, i64* %pt150, align 8
  %add151 = add nsw i64 %88, 0
  store i64 %add151, i64* %end, align 8
  store i64 %add151, i64* %beg, align 8
  br label %while.cond.152

while.cond.152:                                   ; preds = %cond.end.217, %if.then.147
  %89 = load i64, i64* %end, align 8
  %90 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv153 = getelementptr inbounds %struct.buffer, %struct.buffer* %90, i32 0, i32 79
  %91 = load i64, i64* %zv153, align 8
  %cmp154 = icmp slt i64 %89, %91
  br i1 %cmp154, label %land.lhs.true.156, label %land.end

land.lhs.true.156:                                ; preds = %while.cond.152
  %92 = load i64, i64* %end, align 8
  %shl157 = shl i64 %92, 2
  %add158 = add i64 %shl157, 2
  %call159 = call i64 @builtin_lisp_symbol(i32 574)
  %call160 = call i64 @builtin_lisp_symbol(i32 0)
  %call161 = call i64 @get_char_property_and_overlay(i64 %add158, i64 %call159, i64 %call160, i64* %overlay)
  store i64 %call161, i64* %val, align 8
  %call162 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp163 = icmp eq i64 %call161, %call162
  br i1 %cmp163, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true.156
  %93 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_ = getelementptr inbounds %struct.buffer, %struct.buffer* %93, i32 0, i32 50
  %94 = load i64, i64* %invisibility_spec_, align 8
  %call165 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp166 = icmp eq i64 %94, %call165
  br i1 %cmp166, label %cond.true.168, label %cond.false.173

cond.true.168:                                    ; preds = %land.rhs
  %95 = load i64, i64* %val, align 8
  %call169 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp170 = icmp eq i64 %95, %call169
  %lnot172 = xor i1 %cmp170, true
  %lnot.ext = zext i1 %lnot172 to i32
  br label %cond.end.176

cond.false.173:                                   ; preds = %land.rhs
  %96 = load i64, i64* %val, align 8
  %97 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_174 = getelementptr inbounds %struct.buffer, %struct.buffer* %97, i32 0, i32 50
  %98 = load i64, i64* %invisibility_spec_174, align 8
  %call175 = call i32 @invisible_prop(i64 %96, i64 %98)
  br label %cond.end.176

cond.end.176:                                     ; preds = %cond.false.173, %cond.true.168
  %cond177 = phi i32 [ %lnot.ext, %cond.true.168 ], [ %call175, %cond.false.173 ]
  store i32 %cond177, i32* %inv, align 4
  %tobool178 = icmp ne i32 %cond177, 0
  br label %land.end

land.end:                                         ; preds = %cond.end.176, %land.lhs.true.156, %while.cond.152
  %99 = phi i1 [ false, %land.lhs.true.156 ], [ false, %while.cond.152 ], [ %tobool178, %cond.end.176 ]
  br i1 %99, label %while.body.179, label %while.end

while.body.179:                                   ; preds = %land.end
  %100 = load i8, i8* %ellipsis, align 1
  %tobool180 = trunc i8 %100 to i1
  br i1 %tobool180, label %lor.end.204, label %lor.lhs.false.182

lor.lhs.false.182:                                ; preds = %while.body.179
  %101 = load i32, i32* %inv, align 4
  %cmp183 = icmp sgt i32 %101, 1
  br i1 %cmp183, label %lor.end.204, label %lor.rhs.185

lor.rhs.185:                                      ; preds = %lor.lhs.false.182
  %102 = load i64, i64* %overlay, align 8
  %call186 = call zeroext i1 @OVERLAYP(i64 %102)
  br i1 %call186, label %land.rhs.188, label %land.end.203

land.rhs.188:                                     ; preds = %lor.rhs.185
  %103 = load i64, i64* %overlay, align 8
  %call189 = call i64 @builtin_lisp_symbol(i32 168)
  %call190 = call i64 @Foverlay_get(i64 %103, i64 %call189)
  %call191 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp192 = icmp eq i64 %call190, %call191
  br i1 %cmp192, label %lor.rhs.194, label %lor.end.202

lor.rhs.194:                                      ; preds = %land.rhs.188
  %104 = load i64, i64* %overlay, align 8
  %call195 = call i64 @builtin_lisp_symbol(i32 199)
  %call196 = call i64 @Foverlay_get(i64 %104, i64 %call195)
  %call197 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp198 = icmp eq i64 %call196, %call197
  %lnot200 = xor i1 %cmp198, true
  br label %lor.end.202

lor.end.202:                                      ; preds = %lor.rhs.194, %land.rhs.188
  %105 = phi i1 [ true, %land.rhs.188 ], [ %lnot200, %lor.rhs.194 ]
  br label %land.end.203

land.end.203:                                     ; preds = %lor.end.202, %lor.rhs.185
  %106 = phi i1 [ false, %lor.rhs.185 ], [ %105, %lor.end.202 ]
  br label %lor.end.204

lor.end.204:                                      ; preds = %land.end.203, %lor.lhs.false.182, %while.body.179
  %107 = phi i1 [ true, %lor.lhs.false.182 ], [ true, %while.body.179 ], [ %106, %land.end.203 ]
  %frombool205 = zext i1 %107 to i8
  store i8 %frombool205, i8* %ellipsis, align 1
  %108 = load i64, i64* %end, align 8
  %shl206 = shl i64 %108, 2
  %add207 = add i64 %shl206, 2
  %call208 = call i64 @builtin_lisp_symbol(i32 574)
  %call209 = call i64 @builtin_lisp_symbol(i32 0)
  %call210 = call i64 @builtin_lisp_symbol(i32 0)
  %call211 = call i64 @Fnext_single_char_property_change(i64 %add207, i64 %call208, i64 %call209, i64 %call210)
  store i64 %call211, i64* %tmp, align 8
  %109 = load i64, i64* %tmp, align 8
  %call212 = call zeroext i1 @NATNUMP(i64 %109)
  br i1 %call212, label %cond.true.214, label %cond.false.215

cond.true.214:                                    ; preds = %lor.end.204
  %110 = load i64, i64* %tmp, align 8
  %shr = ashr i64 %110, 2
  br label %cond.end.217

cond.false.215:                                   ; preds = %lor.end.204
  %111 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv216 = getelementptr inbounds %struct.buffer, %struct.buffer* %111, i32 0, i32 79
  %112 = load i64, i64* %zv216, align 8
  br label %cond.end.217

cond.end.217:                                     ; preds = %cond.false.215, %cond.true.214
  %cond218 = phi i64 [ %shr, %cond.true.214 ], [ %112, %cond.false.215 ]
  store i64 %cond218, i64* %end, align 8
  br label %while.cond.152

while.end:                                        ; preds = %land.end
  br label %while.cond.219

while.cond.219:                                   ; preds = %cond.end.290, %while.end
  %113 = load i64, i64* %beg, align 8
  %114 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv220 = getelementptr inbounds %struct.buffer, %struct.buffer* %114, i32 0, i32 77
  %115 = load i64, i64* %begv220, align 8
  %cmp221 = icmp sgt i64 %113, %115
  br i1 %cmp221, label %land.lhs.true.223, label %land.end.250

land.lhs.true.223:                                ; preds = %while.cond.219
  %116 = load i64, i64* %beg, align 8
  %sub224 = sub nsw i64 %116, 1
  %shl225 = shl i64 %sub224, 2
  %add226 = add i64 %shl225, 2
  %call227 = call i64 @builtin_lisp_symbol(i32 574)
  %call228 = call i64 @builtin_lisp_symbol(i32 0)
  %call229 = call i64 @get_char_property_and_overlay(i64 %add226, i64 %call227, i64 %call228, i64* %overlay)
  store i64 %call229, i64* %val, align 8
  %call230 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp231 = icmp eq i64 %call229, %call230
  br i1 %cmp231, label %land.end.250, label %land.rhs.233

land.rhs.233:                                     ; preds = %land.lhs.true.223
  %117 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_234 = getelementptr inbounds %struct.buffer, %struct.buffer* %117, i32 0, i32 50
  %118 = load i64, i64* %invisibility_spec_234, align 8
  %call235 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp236 = icmp eq i64 %118, %call235
  br i1 %cmp236, label %cond.true.238, label %cond.false.244

cond.true.238:                                    ; preds = %land.rhs.233
  %119 = load i64, i64* %val, align 8
  %call239 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp240 = icmp eq i64 %119, %call239
  %lnot242 = xor i1 %cmp240, true
  %lnot.ext243 = zext i1 %lnot242 to i32
  br label %cond.end.247

cond.false.244:                                   ; preds = %land.rhs.233
  %120 = load i64, i64* %val, align 8
  %121 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_245 = getelementptr inbounds %struct.buffer, %struct.buffer* %121, i32 0, i32 50
  %122 = load i64, i64* %invisibility_spec_245, align 8
  %call246 = call i32 @invisible_prop(i64 %120, i64 %122)
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.false.244, %cond.true.238
  %cond248 = phi i32 [ %lnot.ext243, %cond.true.238 ], [ %call246, %cond.false.244 ]
  store i32 %cond248, i32* %inv, align 4
  %tobool249 = icmp ne i32 %cond248, 0
  br label %land.end.250

land.end.250:                                     ; preds = %cond.end.247, %land.lhs.true.223, %while.cond.219
  %123 = phi i1 [ false, %land.lhs.true.223 ], [ false, %while.cond.219 ], [ %tobool249, %cond.end.247 ]
  br i1 %123, label %while.body.251, label %while.end.292

while.body.251:                                   ; preds = %land.end.250
  %124 = load i8, i8* %ellipsis, align 1
  %tobool252 = trunc i8 %124 to i1
  br i1 %tobool252, label %lor.end.276, label %lor.lhs.false.254

lor.lhs.false.254:                                ; preds = %while.body.251
  %125 = load i32, i32* %inv, align 4
  %cmp255 = icmp sgt i32 %125, 1
  br i1 %cmp255, label %lor.end.276, label %lor.rhs.257

lor.rhs.257:                                      ; preds = %lor.lhs.false.254
  %126 = load i64, i64* %overlay, align 8
  %call258 = call zeroext i1 @OVERLAYP(i64 %126)
  br i1 %call258, label %land.rhs.260, label %land.end.275

land.rhs.260:                                     ; preds = %lor.rhs.257
  %127 = load i64, i64* %overlay, align 8
  %call261 = call i64 @builtin_lisp_symbol(i32 168)
  %call262 = call i64 @Foverlay_get(i64 %127, i64 %call261)
  %call263 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp264 = icmp eq i64 %call262, %call263
  br i1 %cmp264, label %lor.rhs.266, label %lor.end.274

lor.rhs.266:                                      ; preds = %land.rhs.260
  %128 = load i64, i64* %overlay, align 8
  %call267 = call i64 @builtin_lisp_symbol(i32 199)
  %call268 = call i64 @Foverlay_get(i64 %128, i64 %call267)
  %call269 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp270 = icmp eq i64 %call268, %call269
  %lnot272 = xor i1 %cmp270, true
  br label %lor.end.274

lor.end.274:                                      ; preds = %lor.rhs.266, %land.rhs.260
  %129 = phi i1 [ true, %land.rhs.260 ], [ %lnot272, %lor.rhs.266 ]
  br label %land.end.275

land.end.275:                                     ; preds = %lor.end.274, %lor.rhs.257
  %130 = phi i1 [ false, %lor.rhs.257 ], [ %129, %lor.end.274 ]
  br label %lor.end.276

lor.end.276:                                      ; preds = %land.end.275, %lor.lhs.false.254, %while.body.251
  %131 = phi i1 [ true, %lor.lhs.false.254 ], [ true, %while.body.251 ], [ %130, %land.end.275 ]
  %frombool277 = zext i1 %131 to i8
  store i8 %frombool277, i8* %ellipsis, align 1
  %132 = load i64, i64* %beg, align 8
  %shl278 = shl i64 %132, 2
  %add279 = add i64 %shl278, 2
  %call280 = call i64 @builtin_lisp_symbol(i32 574)
  %call281 = call i64 @builtin_lisp_symbol(i32 0)
  %call282 = call i64 @builtin_lisp_symbol(i32 0)
  %call283 = call i64 @Fprevious_single_char_property_change(i64 %add279, i64 %call280, i64 %call281, i64 %call282)
  store i64 %call283, i64* %tmp, align 8
  %133 = load i64, i64* %tmp, align 8
  %call284 = call zeroext i1 @NATNUMP(i64 %133)
  br i1 %call284, label %cond.true.286, label %cond.false.288

cond.true.286:                                    ; preds = %lor.end.276
  %134 = load i64, i64* %tmp, align 8
  %shr287 = ashr i64 %134, 2
  br label %cond.end.290

cond.false.288:                                   ; preds = %lor.end.276
  %135 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv289 = getelementptr inbounds %struct.buffer, %struct.buffer* %135, i32 0, i32 77
  %136 = load i64, i64* %begv289, align 8
  br label %cond.end.290

cond.end.290:                                     ; preds = %cond.false.288, %cond.true.286
  %cond291 = phi i64 [ %shr287, %cond.true.286 ], [ %136, %cond.false.288 ]
  store i64 %cond291, i64* %beg, align 8
  br label %while.cond.219

while.end.292:                                    ; preds = %land.end.250
  %137 = load i64, i64* %beg, align 8
  %138 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt293 = getelementptr inbounds %struct.buffer, %struct.buffer* %138, i32 0, i32 75
  %139 = load i64, i64* %pt293, align 8
  %add294 = add nsw i64 %139, 0
  %cmp295 = icmp slt i64 %137, %add294
  br i1 %cmp295, label %land.lhs.true.297, label %if.end.333

land.lhs.true.297:                                ; preds = %while.end.292
  %140 = load i64, i64* %end, align 8
  %141 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt298 = getelementptr inbounds %struct.buffer, %struct.buffer* %141, i32 0, i32 75
  %142 = load i64, i64* %pt298, align 8
  %add299 = add nsw i64 %142, 0
  %cmp300 = icmp sgt i64 %140, %add299
  br i1 %cmp300, label %if.then.302, label %if.end.333

if.then.302:                                      ; preds = %land.lhs.true.297
  %143 = load i64, i64* %orig_pt, align 8
  %144 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt303 = getelementptr inbounds %struct.buffer, %struct.buffer* %144, i32 0, i32 75
  %145 = load i64, i64* %pt303, align 8
  %add304 = add nsw i64 %145, 0
  %cmp305 = icmp eq i64 %143, %add304
  br i1 %cmp305, label %land.lhs.true.307, label %cond.false.322

land.lhs.true.307:                                ; preds = %if.then.302
  %146 = load i64, i64* %last_pt.addr, align 8
  %147 = load i64, i64* %beg, align 8
  %cmp308 = icmp slt i64 %146, %147
  br i1 %cmp308, label %cond.true.313, label %lor.lhs.false.310

lor.lhs.false.310:                                ; preds = %land.lhs.true.307
  %148 = load i64, i64* %last_pt.addr, align 8
  %149 = load i64, i64* %end, align 8
  %cmp311 = icmp sgt i64 %148, %149
  br i1 %cmp311, label %cond.true.313, label %cond.false.322

cond.true.313:                                    ; preds = %lor.lhs.false.310, %land.lhs.true.307
  store i64 -1, i64* %orig_pt, align 8
  %150 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt314 = getelementptr inbounds %struct.buffer, %struct.buffer* %150, i32 0, i32 75
  %151 = load i64, i64* %pt314, align 8
  %add315 = add nsw i64 %151, 0
  %152 = load i64, i64* %last_pt.addr, align 8
  %cmp316 = icmp slt i64 %add315, %152
  br i1 %cmp316, label %cond.true.318, label %cond.false.319

cond.true.318:                                    ; preds = %cond.true.313
  %153 = load i64, i64* %end, align 8
  br label %cond.end.320

cond.false.319:                                   ; preds = %cond.true.313
  %154 = load i64, i64* %beg, align 8
  br label %cond.end.320

cond.end.320:                                     ; preds = %cond.false.319, %cond.true.318
  %cond321 = phi i64 [ %153, %cond.true.318 ], [ %154, %cond.false.319 ]
  br label %cond.end.331

cond.false.322:                                   ; preds = %lor.lhs.false.310, %if.then.302
  %155 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt323 = getelementptr inbounds %struct.buffer, %struct.buffer* %155, i32 0, i32 75
  %156 = load i64, i64* %pt323, align 8
  %add324 = add nsw i64 %156, 0
  %157 = load i64, i64* %last_pt.addr, align 8
  %cmp325 = icmp slt i64 %add324, %157
  br i1 %cmp325, label %cond.true.327, label %cond.false.328

cond.true.327:                                    ; preds = %cond.false.322
  %158 = load i64, i64* %beg, align 8
  br label %cond.end.329

cond.false.328:                                   ; preds = %cond.false.322
  %159 = load i64, i64* %end, align 8
  br label %cond.end.329

cond.end.329:                                     ; preds = %cond.false.328, %cond.true.327
  %cond330 = phi i64 [ %158, %cond.true.327 ], [ %159, %cond.false.328 ]
  br label %cond.end.331

cond.end.331:                                     ; preds = %cond.end.329, %cond.end.320
  %cond332 = phi i64 [ %cond321, %cond.end.320 ], [ %cond330, %cond.end.329 ]
  call void @set_point(i64 %cond332)
  store i8 1, i8* %check_display, align 1
  store i8 1, i8* %check_composition, align 1
  br label %if.end.333

if.end.333:                                       ; preds = %cond.end.331, %land.lhs.true.297, %while.end.292
  %160 = load i8, i8* %modified.addr, align 1
  %tobool334 = trunc i8 %160 to i1
  br i1 %tobool334, label %if.end.447, label %land.lhs.true.335

land.lhs.true.335:                                ; preds = %if.end.333
  %161 = load i8, i8* %ellipsis, align 1
  %tobool336 = trunc i8 %161 to i1
  br i1 %tobool336, label %if.end.447, label %land.lhs.true.337

land.lhs.true.337:                                ; preds = %land.lhs.true.335
  %162 = load i64, i64* %beg, align 8
  %163 = load i64, i64* %end, align 8
  %cmp338 = icmp slt i64 %162, %163
  br i1 %cmp338, label %if.then.340, label %if.end.447

if.then.340:                                      ; preds = %land.lhs.true.337
  %164 = load i64, i64* %last_pt.addr, align 8
  %165 = load i64, i64* %beg, align 8
  %cmp341 = icmp eq i64 %164, %165
  br i1 %cmp341, label %land.lhs.true.343, label %if.else

land.lhs.true.343:                                ; preds = %if.then.340
  %166 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt344 = getelementptr inbounds %struct.buffer, %struct.buffer* %166, i32 0, i32 75
  %167 = load i64, i64* %pt344, align 8
  %add345 = add nsw i64 %167, 0
  %168 = load i64, i64* %end, align 8
  %cmp346 = icmp eq i64 %add345, %168
  br i1 %cmp346, label %land.lhs.true.348, label %if.else

land.lhs.true.348:                                ; preds = %land.lhs.true.343
  %169 = load i64, i64* %end, align 8
  %170 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv349 = getelementptr inbounds %struct.buffer, %struct.buffer* %170, i32 0, i32 79
  %171 = load i64, i64* %zv349, align 8
  %cmp350 = icmp slt i64 %169, %171
  br i1 %cmp350, label %if.then.352, label %if.else

if.then.352:                                      ; preds = %land.lhs.true.348
  store i8 1, i8* %check_display, align 1
  store i8 1, i8* %check_composition, align 1
  %172 = load i64, i64* %end, align 8
  %add353 = add nsw i64 %172, 1
  call void @set_point(i64 %add353)
  br label %if.end.446

if.else:                                          ; preds = %land.lhs.true.348, %land.lhs.true.343, %if.then.340
  %173 = load i64, i64* %last_pt.addr, align 8
  %174 = load i64, i64* %end, align 8
  %cmp354 = icmp eq i64 %173, %174
  br i1 %cmp354, label %land.lhs.true.356, label %if.else.367

land.lhs.true.356:                                ; preds = %if.else
  %175 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt357 = getelementptr inbounds %struct.buffer, %struct.buffer* %175, i32 0, i32 75
  %176 = load i64, i64* %pt357, align 8
  %add358 = add nsw i64 %176, 0
  %177 = load i64, i64* %beg, align 8
  %cmp359 = icmp eq i64 %add358, %177
  br i1 %cmp359, label %land.lhs.true.361, label %if.else.367

land.lhs.true.361:                                ; preds = %land.lhs.true.356
  %178 = load i64, i64* %beg, align 8
  %179 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv362 = getelementptr inbounds %struct.buffer, %struct.buffer* %179, i32 0, i32 77
  %180 = load i64, i64* %begv362, align 8
  %cmp363 = icmp sgt i64 %178, %180
  br i1 %cmp363, label %if.then.365, label %if.else.367

if.then.365:                                      ; preds = %land.lhs.true.361
  store i8 1, i8* %check_display, align 1
  store i8 1, i8* %check_composition, align 1
  %181 = load i64, i64* %beg, align 8
  %sub366 = sub nsw i64 %181, 1
  call void @set_point(i64 %sub366)
  br label %if.end.445

if.else.367:                                      ; preds = %land.lhs.true.361, %land.lhs.true.356, %if.else
  %182 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt368 = getelementptr inbounds %struct.buffer, %struct.buffer* %182, i32 0, i32 75
  %183 = load i64, i64* %pt368, align 8
  %add369 = add nsw i64 %183, 0
  %184 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt370 = getelementptr inbounds %struct.buffer, %struct.buffer* %184, i32 0, i32 75
  %185 = load i64, i64* %pt370, align 8
  %add371 = add nsw i64 %185, 0
  %186 = load i64, i64* %last_pt.addr, align 8
  %cmp372 = icmp slt i64 %add371, %186
  br i1 %cmp372, label %cond.true.374, label %cond.false.375

cond.true.374:                                    ; preds = %if.else.367
  %187 = load i64, i64* %beg, align 8
  br label %cond.end.376

cond.false.375:                                   ; preds = %if.else.367
  %188 = load i64, i64* %end, align 8
  br label %cond.end.376

cond.end.376:                                     ; preds = %cond.false.375, %cond.true.374
  %cond377 = phi i64 [ %187, %cond.true.374 ], [ %188, %cond.false.375 ]
  %cmp378 = icmp eq i64 %add369, %cond377
  br i1 %cmp378, label %if.then.380, label %if.else.381

if.then.380:                                      ; preds = %cond.end.376
  br label %if.end.444

if.else.381:                                      ; preds = %cond.end.376
  %189 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt382 = getelementptr inbounds %struct.buffer, %struct.buffer* %189, i32 0, i32 75
  %190 = load i64, i64* %pt382, align 8
  %add383 = add nsw i64 %190, 0
  %shl384 = shl i64 %add383, 2
  %add385 = add i64 %shl384, 2
  %call386 = call i64 @builtin_lisp_symbol(i32 574)
  %call387 = call i64 @builtin_lisp_symbol(i32 0)
  %call388 = call i64 @Fget_pos_property(i64 %add385, i64 %call386, i64 %call387)
  store i64 %call388, i64* %val, align 8
  %191 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_389 = getelementptr inbounds %struct.buffer, %struct.buffer* %191, i32 0, i32 50
  %192 = load i64, i64* %invisibility_spec_389, align 8
  %call390 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp391 = icmp eq i64 %192, %call390
  br i1 %cmp391, label %cond.true.393, label %cond.false.397

cond.true.393:                                    ; preds = %if.else.381
  %193 = load i64, i64* %val, align 8
  %call394 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp395 = icmp eq i64 %193, %call394
  br i1 %cmp395, label %land.end.433, label %land.rhs.401

cond.false.397:                                   ; preds = %if.else.381
  %194 = load i64, i64* %val, align 8
  %195 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_398 = getelementptr inbounds %struct.buffer, %struct.buffer* %195, i32 0, i32 50
  %196 = load i64, i64* %invisibility_spec_398, align 8
  %call399 = call i32 @invisible_prop(i64 %194, i64 %196)
  %tobool400 = icmp ne i32 %call399, 0
  br i1 %tobool400, label %land.rhs.401, label %land.end.433

land.rhs.401:                                     ; preds = %cond.false.397, %cond.true.393
  %197 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt402 = getelementptr inbounds %struct.buffer, %struct.buffer* %197, i32 0, i32 75
  %198 = load i64, i64* %pt402, align 8
  %add403 = add nsw i64 %198, 0
  %199 = load i64, i64* %beg, align 8
  %cmp404 = icmp eq i64 %add403, %199
  br i1 %cmp404, label %cond.true.406, label %cond.false.407

cond.true.406:                                    ; preds = %land.rhs.401
  %200 = load i64, i64* %end, align 8
  br label %cond.end.408

cond.false.407:                                   ; preds = %land.rhs.401
  %201 = load i64, i64* %beg, align 8
  br label %cond.end.408

cond.end.408:                                     ; preds = %cond.false.407, %cond.true.406
  %cond409 = phi i64 [ %200, %cond.true.406 ], [ %201, %cond.false.407 ]
  %shl410 = shl i64 %cond409, 2
  %add411 = add i64 %shl410, 2
  %call412 = call i64 @builtin_lisp_symbol(i32 574)
  %call413 = call i64 @builtin_lisp_symbol(i32 0)
  %call414 = call i64 @Fget_pos_property(i64 %add411, i64 %call412, i64 %call413)
  store i64 %call414, i64* %val, align 8
  %202 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_415 = getelementptr inbounds %struct.buffer, %struct.buffer* %202, i32 0, i32 50
  %203 = load i64, i64* %invisibility_spec_415, align 8
  %call416 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp417 = icmp eq i64 %203, %call416
  br i1 %cmp417, label %cond.true.419, label %cond.false.425

cond.true.419:                                    ; preds = %cond.end.408
  %204 = load i64, i64* %val, align 8
  %call420 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp421 = icmp eq i64 %204, %call420
  %lnot423 = xor i1 %cmp421, true
  %lnot.ext424 = zext i1 %lnot423 to i32
  br label %cond.end.428

cond.false.425:                                   ; preds = %cond.end.408
  %205 = load i64, i64* %val, align 8
  %206 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %invisibility_spec_426 = getelementptr inbounds %struct.buffer, %struct.buffer* %206, i32 0, i32 50
  %207 = load i64, i64* %invisibility_spec_426, align 8
  %call427 = call i32 @invisible_prop(i64 %205, i64 %207)
  br label %cond.end.428

cond.end.428:                                     ; preds = %cond.false.425, %cond.true.419
  %cond429 = phi i32 [ %lnot.ext424, %cond.true.419 ], [ %call427, %cond.false.425 ]
  %tobool430 = icmp ne i32 %cond429, 0
  %lnot431 = xor i1 %tobool430, true
  br label %land.end.433

land.end.433:                                     ; preds = %cond.end.428, %cond.false.397, %cond.true.393
  %208 = phi i1 [ false, %cond.false.397 ], [ false, %cond.true.393 ], [ %lnot431, %cond.end.428 ]
  br i1 %208, label %if.then.434, label %if.end.443

if.then.434:                                      ; preds = %land.end.433
  store i8 1, i8* %check_display, align 1
  store i8 1, i8* %check_composition, align 1
  %209 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt435 = getelementptr inbounds %struct.buffer, %struct.buffer* %209, i32 0, i32 75
  %210 = load i64, i64* %pt435, align 8
  %add436 = add nsw i64 %210, 0
  %211 = load i64, i64* %beg, align 8
  %cmp437 = icmp eq i64 %add436, %211
  br i1 %cmp437, label %cond.true.439, label %cond.false.440

cond.true.439:                                    ; preds = %if.then.434
  %212 = load i64, i64* %end, align 8
  br label %cond.end.441

cond.false.440:                                   ; preds = %if.then.434
  %213 = load i64, i64* %beg, align 8
  br label %cond.end.441

cond.end.441:                                     ; preds = %cond.false.440, %cond.true.439
  %cond442 = phi i64 [ %212, %cond.true.439 ], [ %213, %cond.false.440 ]
  call void @set_point(i64 %cond442)
  br label %if.end.443

if.end.443:                                       ; preds = %cond.end.441, %land.end.433
  br label %if.end.444

if.end.444:                                       ; preds = %if.end.443, %if.then.380
  br label %if.end.445

if.end.445:                                       ; preds = %if.end.444, %if.then.365
  br label %if.end.446

if.end.446:                                       ; preds = %if.end.445, %if.then.352
  br label %if.end.447

if.end.447:                                       ; preds = %if.end.446, %land.lhs.true.337, %land.lhs.true.335, %if.end.333
  br label %if.end.448

if.end.448:                                       ; preds = %if.end.447, %land.lhs.true.141, %land.lhs.true.135, %if.end.132
  store i8 0, i8* %check_invisible, align 1
  br label %while.cond

while.end.449:                                    ; preds = %lor.end
  ret void
}

declare void @finalize_kbd_macro_chars() #1

; Function Attrs: nounwind uwtable
define i64 @read_menu_command() #0 {
entry:
  %retval = alloca i64, align 8
  %keybuf = alloca [30 x i64], align 16
  %count = alloca i64, align 8
  %i = alloca i32, align 4
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 356)
  call void @specbind(i64 %call1, i64 2)
  %arraydecay = getelementptr inbounds [30 x i64], [30 x i64]* %keybuf, i32 0, i32 0
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %call3 = call i32 @read_key_sequence(i64* %arraydecay, i32 30, i64 %call2, i1 zeroext false, i1 zeroext true, i1 zeroext true, i1 zeroext true)
  store i32 %call3, i32* %i, align 4
  %0 = load i64, i64* %count, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %call5 = call i64 @unbind_to(i64 %0, i64 %call4)
  %1 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %1, 5
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %3, i32 0, i32 61
  %4 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp = icmp ne %struct.terminal* %4, null
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %5 = call i64 @Fkill_emacs(i64 %call6) #11
  unreachable

if.end:                                           ; preds = %entry
  %6 = load i32, i32* %i, align 4
  %cmp7 = icmp eq i32 %6, 0
  br i1 %cmp7, label %if.then.9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %7 = load i32, i32* %i, align 4
  %cmp8 = icmp eq i32 %7, -1
  br i1 %cmp8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %lor.lhs.false, %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call10, i64* %retval
  br label %return

if.end.11:                                        ; preds = %lor.lhs.false
  %8 = load i64, i64* @read_key_sequence_cmd, align 8
  store i64 %8, i64* %retval
  br label %return

return:                                           ; preds = %if.end.11, %if.then.9
  %9 = load i64, i64* %retval
  ret i64 %9
}

declare i64 @run_hook_with_args(i64, i64*, i64 (i64, i64*)*) #1

; Function Attrs: nounwind uwtable
define internal i64 @safe_run_hook_funcall(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 1
  %1 = load i64, i64* %arrayidx, align 8
  store i64 %1, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %2, i64 0
  %3 = load i64, i64* %arrayidx1, align 8
  store i64 %3, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @builtin_lisp_symbol(i32 901)
  %call2 = call i64 @internal_condition_case_n(i64 (i64, i64*)* @safe_run_hooks_1, i64 2, i64* %arraydecay, i64 %call, i64 (i64, i64, i64*)* @safe_run_hooks_error)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define void @poll_for_input_1() #0 {
entry:
  %call = call zeroext i1 @input_blocked_p()
  br i1 %call, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %0 = load i8, i8* @waiting_for_input, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call1 = call i32 @gobble_input()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gobble_input() #0 {
entry:
  %nread = alloca i32, align 4
  %err = alloca i8, align 1
  %t = alloca %struct.terminal*, align 8
  %next = alloca %struct.terminal*, align 8
  %nr = alloca i32, align 4
  %hold_quit = alloca %struct.input_event, align 8
  %tmp = alloca i64, align 8
  %tail = alloca i64, align 8
  %frame = alloca i64, align 8
  %f = alloca %struct.frame*, align 8
  store i32 0, i32* %nread, align 4
  store i8 0, i8* %err, align 1
  call void @store_user_signal_events()
  %0 = load %struct.terminal*, %struct.terminal** @terminal_list, align 8
  store %struct.terminal* %0, %struct.terminal** %t, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.40, %entry
  %1 = load %struct.terminal*, %struct.terminal** %t, align 8
  %tobool = icmp ne %struct.terminal* %1, null
  br i1 %tobool, label %while.body, label %while.end.41

while.body:                                       ; preds = %while.cond
  %2 = load %struct.terminal*, %struct.terminal** %t, align 8
  %next_terminal = getelementptr inbounds %struct.terminal, %struct.terminal* %2, i32 0, i32 5
  %3 = load %struct.terminal*, %struct.terminal** %next_terminal, align 8
  store %struct.terminal* %3, %struct.terminal** %next, align 8
  %4 = load %struct.terminal*, %struct.terminal** %t, align 8
  %read_socket_hook = getelementptr inbounds %struct.terminal, %struct.terminal* %4, i32 0, i32 43
  %5 = load i32 (%struct.terminal*, %struct.input_event*)*, i32 (%struct.terminal*, %struct.input_event*)** %read_socket_hook, align 8
  %tobool1 = icmp ne i32 (%struct.terminal*, %struct.input_event*)* %5, null
  br i1 %tobool1, label %if.then, label %if.end.40

if.then:                                          ; preds = %while.body
  %call = call zeroext i1 @input_blocked_p()
  br i1 %call, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  store volatile i8 1, i8* @pending_signals, align 1
  br label %while.end.41

if.end:                                           ; preds = %if.then
  %6 = bitcast %struct.input_event* %hold_quit to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 56, i32 8, i1 false)
  %7 = bitcast %struct.input_event* %hold_quit to i32*
  %bf.load = load i32, i32* %7, align 8
  %bf.clear = and i32 %bf.load, -65536
  store i32 %bf.clear, i32* %7, align 8
  br label %while.cond.3

while.cond.3:                                     ; preds = %while.body.6, %if.end
  %8 = load %struct.terminal*, %struct.terminal** %t, align 8
  %read_socket_hook4 = getelementptr inbounds %struct.terminal, %struct.terminal* %8, i32 0, i32 43
  %9 = load i32 (%struct.terminal*, %struct.input_event*)*, i32 (%struct.terminal*, %struct.input_event*)** %read_socket_hook4, align 8
  %10 = load %struct.terminal*, %struct.terminal** %t, align 8
  %call5 = call i32 %9(%struct.terminal* %10, %struct.input_event* %hold_quit)
  store i32 %call5, i32* %nr, align 4
  %cmp = icmp sgt i32 %call5, 0
  br i1 %cmp, label %while.body.6, label %while.end

while.body.6:                                     ; preds = %while.cond.3
  %11 = load i32, i32* %nr, align 4
  %12 = load i32, i32* %nread, align 4
  %add = add nsw i32 %12, %11
  store i32 %add, i32* %nread, align 4
  br label %while.cond.3

while.end:                                        ; preds = %while.cond.3
  %13 = load i32, i32* %nr, align 4
  %cmp7 = icmp eq i32 %13, -1
  br i1 %cmp7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %while.end
  store i8 1, i8* %err, align 1
  br label %if.end.19

if.else:                                          ; preds = %while.end
  %14 = load i32, i32* %nr, align 4
  %cmp9 = icmp eq i32 %14, -2
  br i1 %cmp9, label %if.then.10, label %if.end.18

if.then.10:                                       ; preds = %if.else
  %15 = load %struct.terminal*, %struct.terminal** @terminal_list, align 8
  %next_terminal11 = getelementptr inbounds %struct.terminal, %struct.terminal* %15, i32 0, i32 5
  %16 = load %struct.terminal*, %struct.terminal** %next_terminal11, align 8
  %tobool12 = icmp ne %struct.terminal* %16, null
  br i1 %tobool12, label %if.end.14, label %if.then.13

if.then.13:                                       ; preds = %if.then.10
  call void @terminate_due_to_signal(i32 1, i32 10) #11
  unreachable

if.end.14:                                        ; preds = %if.then.10
  %17 = load %struct.terminal*, %struct.terminal** %t, align 8
  %18 = bitcast %struct.terminal* %17 to i8*
  %call15 = call i64 @make_lisp_ptr(i8* %18, i32 5)
  store i64 %call15, i64* %tmp, align 8
  %19 = load i64, i64* %tmp, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 704)
  %call17 = call i64 @Fdelete_terminal(i64 %19, i64 %call16)
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.14, %if.else
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %if.then.8
  %20 = load i32, i32* %nr, align 4
  %cmp20 = icmp sge i32 %20, 0
  br i1 %cmp20, label %if.then.21, label %if.end.33

if.then.21:                                       ; preds = %if.end.19
  %21 = load i64, i64* @Vframe_list, align 8
  store i64 %21, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.21
  %22 = load i64, i64* %tail, align 8
  %and = and i64 %22, 7
  %conv = trunc i64 %and to i32
  %cmp24 = icmp eq i32 %conv, 3
  br i1 %cmp24, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %23 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 0
  %26 = load i64, i64* %car, align 8
  store i64 %26, i64* %frame, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %27 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %27, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %28 = load i64, i64* %frame, align 8
  %sub27 = sub nsw i64 %28, 5
  %29 = inttoptr i64 %sub27 to i8*
  %30 = bitcast i8* %29 to %struct.frame*
  store %struct.frame* %30, %struct.frame** %f, align 8
  %31 = load %struct.frame*, %struct.frame** %f, align 8
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %31, i32 0, i32 61
  %32 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %33 = load %struct.terminal*, %struct.terminal** %t, align 8
  %cmp28 = icmp eq %struct.terminal* %32, %33
  br i1 %cmp28, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %for.body
  %34 = load %struct.frame*, %struct.frame** %f, align 8
  call void @frame_make_pointer_visible(%struct.frame* %34)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.31
  %35 = load i64, i64* %tail, align 8
  %sub32 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub32 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %38 = load i64, i64* %cdr, align 8
  store i64 %38, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %if.end.33

if.end.33:                                        ; preds = %for.end, %if.end.19
  %39 = bitcast %struct.input_event* %hold_quit to i32*
  %bf.load34 = load i32, i32* %39, align 8
  %bf.clear35 = and i32 %bf.load34, 65535
  %cmp36 = icmp ne i32 %bf.clear35, 0
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.end.33
  call void @kbd_buffer_store_event(%struct.input_event* %hold_quit)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.38, %if.end.33
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %while.body
  %40 = load %struct.terminal*, %struct.terminal** %next, align 8
  store %struct.terminal* %40, %struct.terminal** %t, align 8
  br label %while.cond

while.end.41:                                     ; preds = %if.then.2, %while.cond
  %41 = load i8, i8* %err, align 1
  %tobool42 = trunc i8 %41 to i1
  br i1 %tobool42, label %land.lhs.true, label %if.end.46

land.lhs.true:                                    ; preds = %while.end.41
  %42 = load i32, i32* %nread, align 4
  %tobool44 = icmp ne i32 %42, 0
  br i1 %tobool44, label %if.end.46, label %if.then.45

if.then.45:                                       ; preds = %land.lhs.true
  store i32 -1, i32* %nread, align 4
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.45, %land.lhs.true, %while.end.41
  %43 = load i32, i32* %nread, align 4
  ret i32 %43
}

; Function Attrs: nounwind uwtable
define void @start_polling() #0 {
entry:
  %period = alloca i64, align 8
  %interval14 = alloca %struct.timespec, align 8
  %0 = load i8, i8* @interrupt_input, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end.19, label %if.then

if.then:                                          ; preds = %entry
  call void @turn_on_atimers(i1 zeroext true)
  %1 = load %struct.atimer*, %struct.atimer** @poll_timer, align 8
  %cmp = icmp eq %struct.atimer* %1, null
  br i1 %cmp, label %if.then.2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %2 = load %struct.atimer*, %struct.atimer** @poll_timer, align 8
  %interval = getelementptr inbounds %struct.atimer, %struct.atimer* %2, i32 0, i32 2
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %interval, i32 0, i32 0
  %3 = load i64, i64* %tv_sec, align 8
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  %cmp1 = icmp ne i64 %3, %4
  br i1 %cmp1, label %if.then.2, label %if.end.18

if.then.2:                                        ; preds = %lor.lhs.false, %if.then
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  %cmp3 = icmp slt i64 %5, 9223372036854775807
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.2
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %6, %cond.true ], [ 9223372036854775807, %cond.false ]
  %cmp4 = icmp sgt i64 1, %cond
  br i1 %cmp4, label %cond.true.5, label %cond.false.6

cond.true.5:                                      ; preds = %cond.end
  br label %cond.end.12

cond.false.6:                                     ; preds = %cond.end
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  %cmp7 = icmp slt i64 %7, 9223372036854775807
  br i1 %cmp7, label %cond.true.8, label %cond.false.9

cond.true.8:                                      ; preds = %cond.false.6
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  br label %cond.end.10

cond.false.9:                                     ; preds = %cond.false.6
  br label %cond.end.10

cond.end.10:                                      ; preds = %cond.false.9, %cond.true.8
  %cond11 = phi i64 [ %8, %cond.true.8 ], [ 9223372036854775807, %cond.false.9 ]
  br label %cond.end.12

cond.end.12:                                      ; preds = %cond.end.10, %cond.true.5
  %cond13 = phi i64 [ 1, %cond.true.5 ], [ %cond11, %cond.end.10 ]
  store i64 %cond13, i64* %period, align 8
  %9 = load i64, i64* %period, align 8
  %call = call { i64, i64 } @make_timespec(i64 %9, i64 0)
  %10 = bitcast %struct.timespec* %interval14 to { i64, i64 }*
  %11 = getelementptr { i64, i64 }, { i64, i64 }* %10, i32 0, i32 0
  %12 = extractvalue { i64, i64 } %call, 0
  store i64 %12, i64* %11, align 8
  %13 = getelementptr { i64, i64 }, { i64, i64 }* %10, i32 0, i32 1
  %14 = extractvalue { i64, i64 } %call, 1
  store i64 %14, i64* %13, align 8
  %15 = load %struct.atimer*, %struct.atimer** @poll_timer, align 8
  %tobool15 = icmp ne %struct.atimer* %15, null
  br i1 %tobool15, label %if.then.16, label %if.end

if.then.16:                                       ; preds = %cond.end.12
  %16 = load %struct.atimer*, %struct.atimer** @poll_timer, align 8
  call void @cancel_atimer(%struct.atimer* %16)
  br label %if.end

if.end:                                           ; preds = %if.then.16, %cond.end.12
  %17 = bitcast %struct.timespec* %interval14 to { i64, i64 }*
  %18 = getelementptr { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = load i64, i64* %18, align 1
  %20 = getelementptr { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = load i64, i64* %20, align 1
  %call17 = call %struct.atimer* @start_atimer(i32 2, i64 %19, i64 %21, void (%struct.atimer*)* @poll_for_input, i8* null)
  store %struct.atimer* %call17, %struct.atimer** @poll_timer, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.end, %lor.lhs.false
  %22 = load i32, i32* @poll_suppress_count, align 4
  %dec = add nsw i32 %22, -1
  store i32 %dec, i32* @poll_suppress_count, align 4
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %entry
  ret void
}

declare void @turn_on_atimers(i1 zeroext) #1

declare { i64, i64 } @make_timespec(i64, i64) #1

declare void @cancel_atimer(%struct.atimer*) #1

declare %struct.atimer* @start_atimer(i32, i64, i64, void (%struct.atimer*)*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @poll_for_input(%struct.atimer* %timer) #0 {
entry:
  %timer.addr = alloca %struct.atimer*, align 8
  store %struct.atimer* %timer, %struct.atimer** %timer.addr, align 8
  %0 = load i32, i32* @poll_suppress_count, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store volatile i8 1, i8* @pending_signals, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @input_polling_used() #0 {
entry:
  %0 = load i8, i8* @interrupt_input, align 1
  %tobool = trunc i8 %0 to i1
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

; Function Attrs: nounwind uwtable
define void @stop_polling() #0 {
entry:
  %0 = load i8, i8* @interrupt_input, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i32, i32* @poll_suppress_count, align 4
  %inc = add nsw i32 %1, 1
  store i32 %inc, i32* @poll_suppress_count, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_poll_suppress_count(i32 %count) #0 {
entry:
  %count.addr = alloca i32, align 4
  store i32 %count, i32* %count.addr, align 4
  %0 = load i32, i32* %count.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* @poll_suppress_count, align 4
  %cmp1 = icmp ne i32 %1, 0
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* @poll_suppress_count, align 4
  call void @start_polling()
  br label %if.end.6

if.else:                                          ; preds = %land.lhs.true, %entry
  %2 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp ne i32 %2, 0
  br i1 %cmp2, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %if.else
  %3 = load i32, i32* @poll_suppress_count, align 4
  %cmp4 = icmp eq i32 %3, 0
  br i1 %cmp4, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %land.lhs.true.3
  call void @stop_polling()
  br label %if.end

if.end:                                           ; preds = %if.then.5, %land.lhs.true.3, %if.else
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %4 = load i32, i32* %count.addr, align 4
  store i32 %4, i32* @poll_suppress_count, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define void @bind_polling_period(i32 %n) #0 {
entry:
  %n.addr = alloca i32, align 4
  %new = alloca i64, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  store i64 %0, i64* %new, align 8
  %1 = load i32, i32* %n.addr, align 4
  %conv = sext i32 %1 to i64
  %2 = load i64, i64* %new, align 8
  %cmp = icmp sgt i64 %conv, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32, i32* %n.addr, align 4
  %conv2 = sext i32 %3 to i64
  store i64 %conv2, i64* %new, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.atimer*, %struct.atimer** @poll_timer, align 8
  call void @stop_other_atimers(%struct.atimer* %4)
  call void @stop_polling()
  %call = call i64 @builtin_lisp_symbol(i32 758)
  %5 = load i64, i64* %new, align 8
  %shl = shl i64 %5, 2
  %add = add i64 %shl, 2
  call void @specbind(i64 %call, i64 %add)
  call void @start_polling()
  ret void
}

declare void @stop_other_atimers(%struct.atimer*) #1

; Function Attrs: nounwind readnone uwtable
define i32 @make_ctrl_char(i32 %c) #4 {
entry:
  %retval = alloca i32, align 4
  %c.addr = alloca i32, align 4
  %upper = alloca i32, align 4
  %oc = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %and = and i32 %0, -128
  store i32 %and, i32* %upper, align 4
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i32, i32* %c.addr, align 4
  %add = add i32 %1, 0
  %cmp = icmp ult i32 %add, 128
  br i1 %cmp, label %if.end, label %if.then

cond.false:                                       ; preds = %entry
  %2 = load i32, i32* %c.addr, align 4
  %conv = sext i32 %2 to i64
  %add1 = add i64 %conv, 0
  %cmp2 = icmp ult i64 %add1, 128
  br i1 %cmp2, label %if.end, label %if.then

if.then:                                          ; preds = %cond.false, %cond.true
  %3 = load i32, i32* %c.addr, align 4
  %or = or i32 %3, 67108864
  store i32 %or, i32* %c.addr, align 4
  store i32 %or, i32* %retval
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  %4 = load i32, i32* %c.addr, align 4
  %and4 = and i32 %4, 127
  store i32 %and4, i32* %c.addr, align 4
  %5 = load i32, i32* %c.addr, align 4
  %cmp5 = icmp sge i32 %5, 64
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %6 = load i32, i32* %c.addr, align 4
  %cmp7 = icmp slt i32 %6, 96
  br i1 %cmp7, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %land.lhs.true
  %7 = load i32, i32* %c.addr, align 4
  store i32 %7, i32* %oc, align 4
  %8 = load i32, i32* %c.addr, align 4
  %and10 = and i32 %8, -97
  store i32 %and10, i32* %c.addr, align 4
  %9 = load i32, i32* %oc, align 4
  %cmp11 = icmp sge i32 %9, 65
  br i1 %cmp11, label %land.lhs.true.13, label %if.end.18

land.lhs.true.13:                                 ; preds = %if.then.9
  %10 = load i32, i32* %oc, align 4
  %cmp14 = icmp sle i32 %10, 90
  br i1 %cmp14, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %land.lhs.true.13
  %11 = load i32, i32* %c.addr, align 4
  %or17 = or i32 %11, 33554432
  store i32 %or17, i32* %c.addr, align 4
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %land.lhs.true.13, %if.then.9
  br label %if.end.33

if.else:                                          ; preds = %land.lhs.true, %if.end
  %12 = load i32, i32* %c.addr, align 4
  %cmp19 = icmp sge i32 %12, 97
  br i1 %cmp19, label %land.lhs.true.21, label %if.else.26

land.lhs.true.21:                                 ; preds = %if.else
  %13 = load i32, i32* %c.addr, align 4
  %cmp22 = icmp sle i32 %13, 122
  br i1 %cmp22, label %if.then.24, label %if.else.26

if.then.24:                                       ; preds = %land.lhs.true.21
  %14 = load i32, i32* %c.addr, align 4
  %and25 = and i32 %14, -97
  store i32 %and25, i32* %c.addr, align 4
  br label %if.end.32

if.else.26:                                       ; preds = %land.lhs.true.21, %if.else
  %15 = load i32, i32* %c.addr, align 4
  %cmp27 = icmp sge i32 %15, 32
  br i1 %cmp27, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.else.26
  %16 = load i32, i32* %c.addr, align 4
  %or30 = or i32 %16, 67108864
  store i32 %or30, i32* %c.addr, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.else.26
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.24
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.end.18
  %17 = load i32, i32* %upper, align 4
  %and34 = and i32 %17, -67108865
  %18 = load i32, i32* %c.addr, align 4
  %or35 = or i32 %18, %and34
  store i32 %or35, i32* %c.addr, align 4
  %19 = load i32, i32* %c.addr, align 4
  store i32 %19, i32* %retval
  br label %return

return:                                           ; preds = %if.end.33, %if.then
  %20 = load i32, i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind uwtable
define void @show_help_echo(i64 %help, i64 %window, i64 %object, i64 %pos) #0 {
entry:
  %help.addr = alloca i64, align 8
  %window.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %f = alloca %struct.frame*, align 8
  store i64 %help, i64* %help.addr, align 8
  store i64 %window, i64* %window.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %help.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.end.9, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %help.addr, align 8
  %call1 = call zeroext i1 @STRINGP(i64 %1)
  br i1 %call1, label %if.end.9, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %help.addr, align 8
  %call2 = call zeroext i1 @FUNCTIONP(i64 %2)
  br i1 %call2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.then
  %3 = load i64, i64* %help.addr, align 8
  %4 = load i64, i64* %window.addr, align 8
  %5 = load i64, i64* %object.addr, align 8
  %6 = load i64, i64* %pos.addr, align 8
  %call4 = call i64 (i64, i64, ...) @safe_call(i64 4, i64 %3, i64 %4, i64 %5, i64 %6)
  store i64 %call4, i64* %help.addr, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load i64, i64* %help.addr, align 8
  %call5 = call i64 @safe_eval(i64 %7)
  store i64 %call5, i64* %help.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.3
  %8 = load i64, i64* %help.addr, align 8
  %call6 = call zeroext i1 @STRINGP(i64 %8)
  br i1 %call6, label %if.end.8, label %if.then.7

if.then.7:                                        ; preds = %if.end
  br label %if.end.33

if.end.8:                                         ; preds = %if.end
  br label %if.end.9

if.end.9:                                         ; preds = %if.end.8, %land.lhs.true, %entry
  %9 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.end.21, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %if.end.9
  %10 = load i64, i64* %help.addr, align 8
  %call11 = call zeroext i1 @STRINGP(i64 %10)
  br i1 %call11, label %if.then.12, label %if.end.21

if.then.12:                                       ; preds = %land.lhs.true.10
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %11, %call13
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.12
  br label %cond.end

cond.false:                                       ; preds = %if.then.12
  %call15 = call %struct.frame* @some_mouse_moved()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.frame* [ null, %cond.true ], [ %call15, %cond.false ]
  store %struct.frame* %cond, %struct.frame** %f, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 688)
  %12 = load i64, i64* %help.addr, align 8
  %call17 = call i64 @call1(i64 %call16, i64 %12)
  store i64 %call17, i64* %help.addr, align 8
  %13 = load %struct.frame*, %struct.frame** %f, align 8
  %tobool18 = icmp ne %struct.frame* %13, null
  br i1 %tobool18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %cond.end
  %14 = load %struct.frame*, %struct.frame** %f, align 8
  %mouse_moved = getelementptr inbounds %struct.frame, %struct.frame* %14, i32 0, i32 26
  %15 = bitcast i48* %mouse_moved to i64*
  %bf.load = load i64, i64* %15, align 8
  %bf.clear = and i64 %bf.load, -1048577
  %bf.set = or i64 %bf.clear, 1048576
  store i64 %bf.set, i64* %15, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.19, %cond.end
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %land.lhs.true.10, %if.end.9
  %16 = load i64, i64* %help.addr, align 8
  %call22 = call zeroext i1 @STRINGP(i64 %16)
  br i1 %call22, label %if.then.25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.21
  %17 = load i64, i64* %help.addr, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp24 = icmp eq i64 %17, %call23
  br i1 %cmp24, label %if.then.25, label %if.end.33

if.then.25:                                       ; preds = %lor.lhs.false, %if.end.21
  %18 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 270), align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp27 = icmp eq i64 %18, %call26
  br i1 %cmp27, label %if.end.31, label %if.then.28

if.then.28:                                       ; preds = %if.then.25
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 270), align 8
  %20 = load i64, i64* %help.addr, align 8
  %call29 = call i64 @Fsubstitute_command_keys(i64 %20)
  %call30 = call i64 @call1(i64 %19, i64 %call29)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.28, %if.then.25
  %21 = load i64, i64* %help.addr, align 8
  %call32 = call zeroext i1 @STRINGP(i64 %21)
  %frombool = zext i1 %call32 to i8
  store i8 %frombool, i8* @help_echo_showing_p, align 1
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.7, %if.end.31, %lor.lhs.false
  ret void
}

declare zeroext i1 @FUNCTIONP(i64) #1

declare i64 @safe_call(i64, i64, ...) #1

declare i64 @safe_eval(i64) #1

; Function Attrs: nounwind uwtable
define internal %struct.frame* @some_mouse_moved() #0 {
entry:
  %retval = alloca %struct.frame*, align 8
  %tail = alloca i64, align 8
  %frame = alloca i64, align 8
  %0 = load i8, i8* @ignore_mouse_drag_p, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.frame* null, %struct.frame** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* @Vframe_list, align 8
  store i64 %1, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i64, i64* %tail, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %3, 3
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %5, i32 0, i32 0
  %6 = load i64, i64* %car, align 8
  store i64 %6, i64* %frame, align 8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %7 = phi i1 [ false, %for.cond ], [ true, %land.rhs ]
  br i1 %7, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %8 = load i64, i64* %frame, align 8
  %sub2 = sub nsw i64 %8, 5
  %9 = inttoptr i64 %sub2 to i8*
  %10 = bitcast i8* %9 to %struct.frame*
  %mouse_moved = getelementptr inbounds %struct.frame, %struct.frame* %10, i32 0, i32 26
  %11 = bitcast i48* %mouse_moved to i64*
  %bf.load = load i64, i64* %11, align 8
  %bf.lshr = lshr i64 %bf.load, 20
  %bf.clear = and i64 %bf.lshr, 1
  %bf.cast = trunc i64 %bf.clear to i1
  br i1 %bf.cast, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %for.body
  %12 = load i64, i64* %frame, align 8
  %sub4 = sub nsw i64 %12, 5
  %13 = inttoptr i64 %sub4 to i8*
  %14 = bitcast i8* %13 to %struct.frame*
  store %struct.frame* %14, %struct.frame** %retval
  br label %return

if.end.5:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.5
  %15 = load i64, i64* %tail, align 8
  %sub6 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub6 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %18 = load i64, i64* %cdr, align 8
  store i64 %18, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  store %struct.frame* null, %struct.frame** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.3, %if.then
  %19 = load %struct.frame*, %struct.frame** %retval
  ret %struct.frame* %19
}

declare i64 @Fsubstitute_command_keys(i64) #1

; Function Attrs: nounwind uwtable
define i64 @read_char(i32 %commandflag, i64 %map, i64 %prev_event, i8* %used_mouse_menu, %struct.timespec* %end_time) #0 {
entry:
  %retval = alloca i64, align 8
  %commandflag.addr = alloca i32, align 4
  %map.addr = alloca i64, align 8
  %prev_event.addr = alloca i64, align 8
  %used_mouse_menu.addr = alloca i8*, align 8
  %end_time.addr = alloca %struct.timespec*, align 8
  %c = alloca i64, align 8
  %jmpcount = alloca i64, align 8
  %local_getcjmp = alloca [1 x %struct.__jmp_buf_tag], align 16
  %save_jump = alloca [1 x %struct.__jmp_buf_tag], align 16
  %tem = alloca i64, align 8
  %save = alloca i64, align 8
  %previous_echo_area_message = alloca i64, align 8
  %also_record = alloca i64, align 8
  %reread = alloca i8, align 1
  %recorded = alloca i8, align 1
  %polling_stopped_here = alloca i8, align 1
  %orig_kboard = alloca %struct.kboard*, align 8
  %was_disabled = alloca i8, align 1
  %echo_current = alloca i8, align 1
  %kb = alloca %struct.kboard*, align 8
  %last = alloca i64, align 8
  %tem0 = alloca i64, align 8
  %delay_level = alloca i32, align 4
  %buffer_size = alloca i64, align 8
  %tem0517 = alloca i64, align 8
  %timeout = alloca i64, align 8
  %kb656 = alloca %struct.kboard*, align 8
  %agg.tmp = alloca %struct.timespec, align 8
  %prev_buffer = alloca %struct.buffer*, align 8
  %d = alloca i64, align 8
  %posn = alloca i64, align 8
  %keys = alloca i64, align 8
  %key_count = alloca i64, align 8
  %command_key_start = alloca i64, align 8
  %count = alloca i64, align 8
  %saved_immediate_echo = alloca i8, align 1
  %saved_ok_to_echo = alloca %struct.kboard*, align 8
  %saved_echo_string = alloca i64, align 8
  %saved_echo_prompt = alloca i64, align 8
  %help = alloca i64, align 8
  %object = alloca i64, align 8
  %position = alloca i64, align 8
  %window = alloca i64, align 8
  %htem = alloca i64, align 8
  %count1078 = alloca i64, align 8
  store i32 %commandflag, i32* %commandflag.addr, align 4
  store i64 %map, i64* %map.addr, align 8
  store i64 %prev_event, i64* %prev_event.addr, align 8
  store i8* %used_mouse_menu, i8** %used_mouse_menu.addr, align 8
  store %struct.timespec* %end_time, %struct.timespec** %end_time.addr, align 8
  store volatile i8 0, i8* %polling_stopped_here, align 1
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  store %struct.kboard* %0, %struct.kboard** %orig_kboard, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store volatile i64 %call, i64* %also_record, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %c, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store volatile i64 %call2, i64* %previous_echo_area_message, align 8
  br label %retry

retry:                                            ; preds = %if.end.1033, %if.end.997, %if.else.742, %entry
  store volatile i8 0, i8* %recorded, align 1
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %retry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %c, align 8
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %sub4 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub4 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %10 = load i64, i64* %c, align 8
  %and5 = and i64 %10, 7
  %conv6 = trunc i64 %and5 to i32
  %cmp7 = icmp eq i32 %conv6, 3
  br i1 %cmp7, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %11 = load i64, i64* %c, align 8
  %sub9 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub9 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car10, align 8
  %and11 = and i64 %14, 7
  %conv12 = trunc i64 %and11 to i32
  %cmp13 = icmp eq i32 %conv12, 0
  br i1 %cmp13, label %land.lhs.true.22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %15 = load i64, i64* %c, align 8
  %sub15 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub15 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car16, align 8
  %and17 = and i64 %18, 7
  %conv18 = trunc i64 %and17 to i32
  %and19 = and i32 %conv18, -5
  %cmp20 = icmp eq i32 %and19, 2
  br i1 %cmp20, label %land.lhs.true.22, label %if.end

land.lhs.true.22:                                 ; preds = %lor.lhs.false, %land.lhs.true
  %19 = load i64, i64* %c, align 8
  %sub23 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub23 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u24 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr25 = bitcast %union.anon.12* %u24 to i64*
  %22 = load i64, i64* %cdr25, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp27 = icmp eq i64 %22, %call26
  br i1 %cmp27, label %if.then.29, label %if.end

if.then.29:                                       ; preds = %land.lhs.true.22
  %23 = load i64, i64* %c, align 8
  %sub30 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub30 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %car31 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 0
  %26 = load i64, i64* %car31, align 8
  store i64 %26, i64* %c, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.29, %land.lhs.true.22, %lor.lhs.false, %if.then
  store volatile i8 1, i8* %reread, align 1
  br label %reread_first

if.else:                                          ; preds = %retry
  store volatile i8 0, i8* %reread, align 1
  br label %if.end.32

if.end.32:                                        ; preds = %if.else
  %27 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and33 = and i64 %27, 7
  %conv34 = trunc i64 %and33 to i32
  %cmp35 = icmp eq i32 %conv34, 3
  br i1 %cmp35, label %if.then.37, label %if.end.102

if.then.37:                                       ; preds = %if.end.32
  store i8 0, i8* %was_disabled, align 1
  %28 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub38 = sub nsw i64 %28, 3
  %29 = inttoptr i64 %sub38 to i8*
  %30 = bitcast i8* %29 to %struct.Lisp_Cons*
  %car39 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %30, i32 0, i32 0
  %31 = load i64, i64* %car39, align 8
  store i64 %31, i64* %c, align 8
  %32 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub40 = sub nsw i64 %32, 3
  %33 = inttoptr i64 %sub40 to i8*
  %34 = bitcast i8* %33 to %struct.Lisp_Cons*
  %u41 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %34, i32 0, i32 1
  %cdr42 = bitcast %union.anon.12* %u41 to i64*
  %35 = load i64, i64* %cdr42, align 8
  store i64 %35, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %36 = load i64, i64* %c, align 8
  %and43 = and i64 %36, 7
  %conv44 = trunc i64 %and43 to i32
  %cmp45 = icmp eq i32 %conv44, 3
  br i1 %cmp45, label %land.lhs.true.47, label %if.else.57

land.lhs.true.47:                                 ; preds = %if.then.37
  %37 = load i64, i64* %c, align 8
  %sub48 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub48 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car49 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car49, align 8
  %call50 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp51 = icmp eq i64 %40, %call50
  br i1 %cmp51, label %if.then.53, label %if.else.57

if.then.53:                                       ; preds = %land.lhs.true.47
  %41 = load i64, i64* %c, align 8
  %sub54 = sub nsw i64 %41, 3
  %42 = inttoptr i64 %sub54 to i8*
  %43 = bitcast i8* %42 to %struct.Lisp_Cons*
  %u55 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %43, i32 0, i32 1
  %cdr56 = bitcast %union.anon.12* %u55 to i64*
  %44 = load i64, i64* %cdr56, align 8
  store i64 %44, i64* %c, align 8
  br label %if.end.58

if.else.57:                                       ; preds = %land.lhs.true.47, %if.then.37
  store volatile i8 1, i8* %reread, align 1
  br label %if.end.58

if.end.58:                                        ; preds = %if.else.57, %if.then.53
  %45 = load i64, i64* %c, align 8
  %and59 = and i64 %45, 7
  %conv60 = trunc i64 %and59 to i32
  %cmp61 = icmp eq i32 %conv60, 3
  br i1 %cmp61, label %land.lhs.true.63, label %if.end.88

land.lhs.true.63:                                 ; preds = %if.end.58
  %46 = load i64, i64* %c, align 8
  %sub64 = sub nsw i64 %46, 3
  %47 = inttoptr i64 %sub64 to i8*
  %48 = bitcast i8* %47 to %struct.Lisp_Cons*
  %u65 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %48, i32 0, i32 1
  %cdr66 = bitcast %union.anon.12* %u65 to i64*
  %49 = load i64, i64* %cdr66, align 8
  %call67 = call i64 @builtin_lisp_symbol(i32 343)
  %cmp68 = icmp eq i64 %49, %call67
  br i1 %cmp68, label %land.lhs.true.70, label %if.end.88

land.lhs.true.70:                                 ; preds = %land.lhs.true.63
  %50 = load i64, i64* %c, align 8
  %sub71 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub71 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %car72 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 0
  %53 = load i64, i64* %car72, align 8
  %and73 = and i64 %53, 7
  %conv74 = trunc i64 %and73 to i32
  %cmp75 = icmp eq i32 %conv74, 0
  br i1 %cmp75, label %if.then.85, label %lor.lhs.false.77

lor.lhs.false.77:                                 ; preds = %land.lhs.true.70
  %54 = load i64, i64* %c, align 8
  %sub78 = sub nsw i64 %54, 3
  %55 = inttoptr i64 %sub78 to i8*
  %56 = bitcast i8* %55 to %struct.Lisp_Cons*
  %car79 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %56, i32 0, i32 0
  %57 = load i64, i64* %car79, align 8
  %and80 = and i64 %57, 7
  %conv81 = trunc i64 %and80 to i32
  %and82 = and i32 %conv81, -5
  %cmp83 = icmp eq i32 %and82, 2
  br i1 %cmp83, label %if.then.85, label %if.end.88

if.then.85:                                       ; preds = %lor.lhs.false.77, %land.lhs.true.70
  store i8 1, i8* %was_disabled, align 1
  %58 = load i64, i64* %c, align 8
  %sub86 = sub nsw i64 %58, 3
  %59 = inttoptr i64 %sub86 to i8*
  %60 = bitcast i8* %59 to %struct.Lisp_Cons*
  %car87 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %60, i32 0, i32 0
  %61 = load i64, i64* %car87, align 8
  store i64 %61, i64* %c, align 8
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.85, %lor.lhs.false.77, %land.lhs.true.63, %if.end.58
  %62 = load i8*, i8** %used_mouse_menu.addr, align 8
  %tobool = icmp ne i8* %62, null
  br i1 %tobool, label %land.lhs.true.89, label %if.end.101

land.lhs.true.89:                                 ; preds = %if.end.88
  %63 = load i64, i64* %c, align 8
  %call90 = call i64 @builtin_lisp_symbol(i32 921)
  %cmp91 = icmp eq i64 %63, %call90
  br i1 %cmp91, label %if.then.100, label %lor.lhs.false.93

lor.lhs.false.93:                                 ; preds = %land.lhs.true.89
  %64 = load i64, i64* %c, align 8
  %call94 = call i64 @builtin_lisp_symbol(i32 651)
  %cmp95 = icmp eq i64 %64, %call94
  br i1 %cmp95, label %if.then.100, label %lor.lhs.false.97

lor.lhs.false.97:                                 ; preds = %lor.lhs.false.93
  %65 = load i8, i8* %was_disabled, align 1
  %tobool98 = trunc i8 %65 to i1
  br i1 %tobool98, label %if.then.100, label %if.end.101

if.then.100:                                      ; preds = %lor.lhs.false.97, %lor.lhs.false.93, %land.lhs.true.89
  %66 = load i8*, i8** %used_mouse_menu.addr, align 8
  store i8 1, i8* %66, align 1
  br label %if.end.101

if.end.101:                                       ; preds = %if.then.100, %lor.lhs.false.97, %if.end.88
  br label %reread_for_input_method

if.end.102:                                       ; preds = %if.end.32
  %67 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  %and103 = and i64 %67, 7
  %conv104 = trunc i64 %and103 to i32
  %cmp105 = icmp eq i32 %conv104, 3
  br i1 %cmp105, label %if.then.107, label %if.end.143

if.then.107:                                      ; preds = %if.end.102
  %68 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  %sub108 = sub nsw i64 %68, 3
  %69 = inttoptr i64 %sub108 to i8*
  %70 = bitcast i8* %69 to %struct.Lisp_Cons*
  %car109 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %70, i32 0, i32 0
  %71 = load i64, i64* %car109, align 8
  store i64 %71, i64* %c, align 8
  %72 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  %sub110 = sub nsw i64 %72, 3
  %73 = inttoptr i64 %sub110 to i8*
  %74 = bitcast i8* %73 to %struct.Lisp_Cons*
  %u111 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %74, i32 0, i32 1
  %cdr112 = bitcast %union.anon.12* %u111 to i64*
  %75 = load i64, i64* %cdr112, align 8
  store i64 %75, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  %76 = load i64, i64* %c, align 8
  %and113 = and i64 %76, 7
  %conv114 = trunc i64 %and113 to i32
  %cmp115 = icmp eq i32 %conv114, 3
  br i1 %cmp115, label %land.lhs.true.117, label %if.end.142

land.lhs.true.117:                                ; preds = %if.then.107
  %77 = load i64, i64* %c, align 8
  %sub118 = sub nsw i64 %77, 3
  %78 = inttoptr i64 %sub118 to i8*
  %79 = bitcast i8* %78 to %struct.Lisp_Cons*
  %car119 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %79, i32 0, i32 0
  %80 = load i64, i64* %car119, align 8
  %and120 = and i64 %80, 7
  %conv121 = trunc i64 %and120 to i32
  %cmp122 = icmp eq i32 %conv121, 0
  br i1 %cmp122, label %land.lhs.true.132, label %lor.lhs.false.124

lor.lhs.false.124:                                ; preds = %land.lhs.true.117
  %81 = load i64, i64* %c, align 8
  %sub125 = sub nsw i64 %81, 3
  %82 = inttoptr i64 %sub125 to i8*
  %83 = bitcast i8* %82 to %struct.Lisp_Cons*
  %car126 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %83, i32 0, i32 0
  %84 = load i64, i64* %car126, align 8
  %and127 = and i64 %84, 7
  %conv128 = trunc i64 %and127 to i32
  %and129 = and i32 %conv128, -5
  %cmp130 = icmp eq i32 %and129, 2
  br i1 %cmp130, label %land.lhs.true.132, label %if.end.142

land.lhs.true.132:                                ; preds = %lor.lhs.false.124, %land.lhs.true.117
  %85 = load i64, i64* %c, align 8
  %sub133 = sub nsw i64 %85, 3
  %86 = inttoptr i64 %sub133 to i8*
  %87 = bitcast i8* %86 to %struct.Lisp_Cons*
  %u134 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %87, i32 0, i32 1
  %cdr135 = bitcast %union.anon.12* %u134 to i64*
  %88 = load i64, i64* %cdr135, align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp137 = icmp eq i64 %88, %call136
  br i1 %cmp137, label %if.then.139, label %if.end.142

if.then.139:                                      ; preds = %land.lhs.true.132
  %89 = load i64, i64* %c, align 8
  %sub140 = sub nsw i64 %89, 3
  %90 = inttoptr i64 %sub140 to i8*
  %91 = bitcast i8* %90 to %struct.Lisp_Cons*
  %car141 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %91, i32 0, i32 0
  %92 = load i64, i64* %car141, align 8
  store i64 %92, i64* %c, align 8
  br label %if.end.142

if.end.142:                                       ; preds = %if.then.139, %land.lhs.true.132, %lor.lhs.false.124, %if.then.107
  store volatile i8 1, i8* %reread, align 1
  br label %reread_for_input_method

if.end.143:                                       ; preds = %if.end.102
  %93 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call144 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp145 = icmp eq i64 %93, %call144
  br i1 %cmp145, label %if.end.174, label %if.then.147

if.then.147:                                      ; preds = %if.end.143
  %call148 = call i64 @builtin_lisp_symbol(i32 636)
  store i64 %call148, i64* @internal_last_event_frame, align 8
  store i64 %call148, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  %94 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call149 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp150 = icmp eq i64 %94, %call149
  br i1 %cmp150, label %if.then.156, label %lor.lhs.false.152

lor.lhs.false.152:                                ; preds = %if.then.147
  %95 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 386), align 8
  %96 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call153 = call i64 @Flength(i64 %96)
  %shr = ashr i64 %call153, 2
  %cmp154 = icmp sge i64 %95, %shr
  br i1 %cmp154, label %if.then.156, label %if.end.157

if.then.156:                                      ; preds = %lor.lhs.false.152, %if.then.147
  store i64 -2, i64* %c, align 8
  br label %exit

if.end.157:                                       ; preds = %lor.lhs.false.152
  %97 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %98 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 386), align 8
  %shl = shl i64 %98, 2
  %add = add i64 %shl, 2
  %call158 = call i64 @Faref(i64 %97, i64 %add)
  store i64 %call158, i64* %c, align 8
  %99 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call159 = call zeroext i1 @STRINGP(i64 %99)
  br i1 %call159, label %land.lhs.true.161, label %if.end.173

land.lhs.true.161:                                ; preds = %if.end.157
  %100 = load i64, i64* %c, align 8
  %shr162 = ashr i64 %100, 2
  %and163 = and i64 %shr162, 128
  %tobool164 = icmp ne i64 %and163, 0
  br i1 %tobool164, label %land.lhs.true.165, label %if.end.173

land.lhs.true.165:                                ; preds = %land.lhs.true.161
  %101 = load i64, i64* %c, align 8
  %shr166 = ashr i64 %101, 2
  %cmp167 = icmp sle i64 %shr166, 255
  br i1 %cmp167, label %if.then.169, label %if.end.173

if.then.169:                                      ; preds = %land.lhs.true.165
  %102 = load i64, i64* %c, align 8
  %shr170 = ashr i64 %102, 2
  %and171 = and i64 %shr170, -129
  %or = or i64 134217728, %and171
  %call172 = call i64 @make_natnum(i64 %or)
  store i64 %call172, i64* %c, align 8
  br label %if.end.173

if.end.173:                                       ; preds = %if.then.169, %land.lhs.true.165, %land.lhs.true.161, %if.end.157
  %103 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 386), align 8
  %inc = add nsw i64 %103, 1
  store i64 %inc, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 386), align 8
  br label %from_macro

if.end.174:                                       ; preds = %if.end.143
  %104 = load i64, i64* @unread_switch_frame, align 8
  %call175 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp176 = icmp eq i64 %104, %call175
  br i1 %cmp176, label %if.end.180, label %if.then.178

if.then.178:                                      ; preds = %if.end.174
  %105 = load i64, i64* @unread_switch_frame, align 8
  store i64 %105, i64* %c, align 8
  %call179 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call179, i64* @unread_switch_frame, align 8
  br label %reread_first

if.end.180:                                       ; preds = %if.end.174
  %106 = load i32, i32* %commandflag.addr, align 4
  %cmp181 = icmp sge i32 %106, 0
  br i1 %cmp181, label %if.then.183, label %if.end.219

if.then.183:                                      ; preds = %if.end.180
  %107 = load i64, i64* @echo_message_buffer, align 8
  %108 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %cmp184 = icmp eq i64 %107, %108
  %frombool = zext i1 %cmp184 to i8
  store i8 %frombool, i8* %echo_current, align 1
  %109 = load i8, i8* @input_pending, align 1
  %tobool186 = trunc i8 %109 to i1
  br i1 %tobool186, label %if.then.191, label %lor.lhs.false.188

lor.lhs.false.188:                                ; preds = %if.then.183
  %call189 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext false)
  br i1 %call189, label %if.then.191, label %if.end.192

if.then.191:                                      ; preds = %lor.lhs.false.188, %if.then.183
  call void @swallow_events(i1 zeroext false)
  br label %if.end.192

if.end.192:                                       ; preds = %if.then.191, %lor.lhs.false.188
  br label %while.cond

while.cond:                                       ; preds = %if.end.211, %if.end.192
  %110 = load i8, i8* @input_pending, align 1
  %tobool193 = trunc i8 %110 to i1
  br i1 %tobool193, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %111 = load i8, i8* @input_was_pending, align 1
  %tobool195 = trunc i8 %111 to i1
  br i1 %tobool195, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %112 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 487), align 1
  %tobool197 = trunc i8 %112 to i1
  %lnot = xor i1 %tobool197, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %113 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %114 = phi i1 [ false, %while.cond ], [ %113, %lor.end ]
  %lnot198 = xor i1 %114, true
  br i1 %lnot198, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %115 = load i8, i8* @input_pending, align 1
  %tobool199 = trunc i8 %115 to i1
  %frombool200 = zext i1 %tobool199 to i8
  store i8 %frombool200, i8* @input_was_pending, align 1
  %116 = load i8, i8* @help_echo_showing_p, align 1
  %tobool201 = trunc i8 %116 to i1
  br i1 %tobool201, label %land.lhs.true.203, label %if.else.207

land.lhs.true.203:                                ; preds = %while.body
  %117 = load i64, i64* @selected_window, align 8
  %118 = load i64, i64* @minibuf_window, align 8
  %cmp204 = icmp eq i64 %117, %118
  br i1 %cmp204, label %if.else.207, label %if.then.206

if.then.206:                                      ; preds = %land.lhs.true.203
  call void @redisplay_preserve_echo_area(i32 5)
  br label %if.end.208

if.else.207:                                      ; preds = %land.lhs.true.203, %while.body
  call void @redisplay()
  br label %if.end.208

if.end.208:                                       ; preds = %if.else.207, %if.then.206
  %119 = load i8, i8* @input_pending, align 1
  %tobool209 = trunc i8 %119 to i1
  br i1 %tobool209, label %if.end.211, label %if.then.210

if.then.210:                                      ; preds = %if.end.208
  br label %while.end

if.end.211:                                       ; preds = %if.end.208
  call void @swallow_events(i1 zeroext false)
  br label %while.cond

while.end:                                        ; preds = %if.then.210, %land.end
  %120 = load i32, i32* %commandflag.addr, align 4
  %cmp212 = icmp eq i32 %120, 0
  br i1 %cmp212, label %land.lhs.true.214, label %if.end.218

land.lhs.true.214:                                ; preds = %while.end
  %121 = load i8, i8* %echo_current, align 1
  %tobool215 = trunc i8 %121 to i1
  br i1 %tobool215, label %if.then.217, label %if.end.218

if.then.217:                                      ; preds = %land.lhs.true.214
  %122 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  store i64 %122, i64* @echo_message_buffer, align 8
  br label %if.end.218

if.end.218:                                       ; preds = %if.then.217, %land.lhs.true.214, %while.end
  br label %if.end.219

if.end.219:                                       ; preds = %if.end.218, %if.end.180
  %123 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call220 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp221 = icmp eq i64 %123, %call220
  br i1 %cmp221, label %if.else.230, label %land.lhs.true.223

land.lhs.true.223:                                ; preds = %if.end.219
  %124 = load %struct.kboard*, %struct.kboard** @echo_kboard, align 8
  %125 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp224 = icmp ne %struct.kboard* %124, %125
  br i1 %cmp224, label %if.then.229, label %lor.lhs.false.226

lor.lhs.false.226:                                ; preds = %land.lhs.true.223
  %126 = load %struct.kboard*, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  %cmp227 = icmp eq %struct.kboard* %126, null
  br i1 %cmp227, label %if.then.229, label %if.else.230

if.then.229:                                      ; preds = %lor.lhs.false.226, %land.lhs.true.223
  call void @cancel_echoing()
  br label %if.end.231

if.else.230:                                      ; preds = %lor.lhs.false.226, %if.end.219
  call void @echo_dash()
  br label %if.end.231

if.end.231:                                       ; preds = %if.else.230, %if.then.229
  %call232 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call232, i64* %c, align 8
  %127 = load i64, i64* %map.addr, align 8
  %call233 = call i64 @get_keymap(i64 %127, i1 zeroext false, i1 zeroext false)
  %call234 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp235 = icmp eq i64 %call233, %call234
  br i1 %cmp235, label %if.end.277, label %land.lhs.true.237

land.lhs.true.237:                                ; preds = %if.end.231
  %128 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call238 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp239 = icmp eq i64 %128, %call238
  br i1 %cmp239, label %land.lhs.true.241, label %if.end.277

land.lhs.true.241:                                ; preds = %land.lhs.true.237
  %129 = load i8, i8* @noninteractive, align 1
  %tobool242 = trunc i8 %129 to i1
  br i1 %tobool242, label %if.end.277, label %land.lhs.true.243

land.lhs.true.243:                                ; preds = %land.lhs.true.241
  %130 = load i64, i64* %prev_event.addr, align 8
  %call244 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp245 = icmp eq i64 %130, %call244
  br i1 %cmp245, label %if.end.277, label %land.lhs.true.247

land.lhs.true.247:                                ; preds = %land.lhs.true.243
  %131 = load i64, i64* %prev_event.addr, align 8
  %and248 = and i64 %131, 7
  %conv249 = trunc i64 %and248 to i32
  %cmp250 = icmp eq i32 %conv249, 3
  br i1 %cmp250, label %if.end.277, label %land.lhs.true.252

land.lhs.true.252:                                ; preds = %land.lhs.true.247
  %132 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and253 = and i64 %132, 7
  %conv254 = trunc i64 %and253 to i32
  %cmp255 = icmp eq i32 %conv254, 3
  br i1 %cmp255, label %if.end.277, label %land.lhs.true.257

land.lhs.true.257:                                ; preds = %land.lhs.true.252
  %call258 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext false)
  br i1 %call258, label %if.end.277, label %if.then.259

if.then.259:                                      ; preds = %land.lhs.true.257
  %133 = load i32, i32* %commandflag.addr, align 4
  %134 = load i64, i64* %map.addr, align 8
  %call260 = call i64 @read_char_minibuf_menu_prompt(i32 %133, i64 %134)
  store i64 %call260, i64* %c, align 8
  %135 = load i64, i64* %c, align 8
  %and261 = and i64 %135, 7
  %conv262 = trunc i64 %and261 to i32
  %and263 = and i32 %conv262, -5
  %cmp264 = icmp eq i32 %and263, 2
  br i1 %cmp264, label %land.lhs.true.266, label %if.end.271

land.lhs.true.266:                                ; preds = %if.then.259
  %136 = load i64, i64* %c, align 8
  %shr267 = ashr i64 %136, 2
  %cmp268 = icmp eq i64 %shr267, -2
  br i1 %cmp268, label %if.then.270, label %if.end.271

if.then.270:                                      ; preds = %land.lhs.true.266
  %137 = load i64, i64* %c, align 8
  store i64 %137, i64* %retval
  br label %return

if.end.271:                                       ; preds = %land.lhs.true.266, %if.then.259
  %138 = load i64, i64* %c, align 8
  %call272 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp273 = icmp eq i64 %138, %call272
  br i1 %cmp273, label %if.end.276, label %if.then.275

if.then.275:                                      ; preds = %if.end.271
  br label %exit

if.end.276:                                       ; preds = %if.end.271
  br label %if.end.277

if.end.277:                                       ; preds = %if.end.276, %land.lhs.true.257, %land.lhs.true.252, %land.lhs.true.247, %land.lhs.true.243, %land.lhs.true.241, %land.lhs.true.237, %if.end.231
  %call278 = call i64 @SPECPDL_INDEX()
  store i64 %call278, i64* %jmpcount, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %local_getcjmp, i32 0, i32 0
  %call279 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #12
  %tobool280 = icmp ne i32 %call279, 0
  br i1 %tobool280, label %if.then.281, label %if.end.339

if.then.281:                                      ; preds = %if.end.277
  %arraydecay282 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay282)
  %call283 = call i32 @pthread_sigmask(i32 2, %struct.__sigset_t* @empty_mask, %struct.__sigset_t* null) #8
  %139 = load i64, i64* %jmpcount, align 8
  %call284 = call i64 @builtin_lisp_symbol(i32 0)
  %call285 = call i64 @unbind_to(i64 %139, i64 %call284)
  %140 = load i32, i32* @quit_char, align 4
  %conv286 = sext i32 %140 to i64
  %shl287 = shl i64 %conv286, 2
  %add288 = add i64 %shl287, 2
  store i64 %add288, i64* %c, align 8
  %141 = load i64, i64* @selected_frame, align 8
  store i64 %141, i64* @internal_last_event_frame, align 8
  %142 = load i64, i64* @internal_last_event_frame, align 8
  store i64 %142, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  %143 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call289 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp290 = icmp eq i64 %143, %call289
  br i1 %cmp290, label %if.end.294, label %if.then.292

if.then.292:                                      ; preds = %if.then.281
  %call293 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call293, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %if.end.294

if.end.294:                                       ; preds = %if.then.292, %if.then.281
  %144 = load i64, i64* @selected_frame, align 8
  %sub295 = sub nsw i64 %144, 5
  %145 = inttoptr i64 %sub295 to i8*
  %146 = bitcast i8* %145 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %146, i32 0, i32 61
  %147 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %147, i32 0, i32 10
  %148 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  store %struct.kboard* %148, %struct.kboard** %kb, align 8
  %149 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %150 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp296 = icmp ne %struct.kboard* %149, %150
  br i1 %cmp296, label %if.then.298, label %if.end.338

if.then.298:                                      ; preds = %if.end.294
  %151 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_ = getelementptr inbounds %struct.kboard, %struct.kboard* %151, i32 0, i32 8
  %152 = load i64, i64* %kbd_queue_, align 8
  store i64 %152, i64* %last, align 8
  %153 = load i8, i8* @single_kboard, align 1
  %tobool299 = trunc i8 %153 to i1
  br i1 %tobool299, label %if.then.300, label %if.end.301

if.then.300:                                      ; preds = %if.then.298
  call void @emacs_abort() #11
  unreachable

if.end.301:                                       ; preds = %if.then.298
  %154 = load i64, i64* %last, align 8
  %and302 = and i64 %154, 7
  %conv303 = trunc i64 %and302 to i32
  %cmp304 = icmp eq i32 %conv303, 3
  br i1 %cmp304, label %if.then.306, label %if.end.328

if.then.306:                                      ; preds = %if.end.301
  br label %while.cond.307

while.cond.307:                                   ; preds = %while.body.315, %if.then.306
  %155 = load i64, i64* %last, align 8
  %sub308 = sub nsw i64 %155, 3
  %156 = inttoptr i64 %sub308 to i8*
  %157 = bitcast i8* %156 to %struct.Lisp_Cons*
  %u309 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %157, i32 0, i32 1
  %cdr310 = bitcast %union.anon.12* %u309 to i64*
  %158 = load i64, i64* %cdr310, align 8
  %and311 = and i64 %158, 7
  %conv312 = trunc i64 %and311 to i32
  %cmp313 = icmp eq i32 %conv312, 3
  br i1 %cmp313, label %while.body.315, label %while.end.319

while.body.315:                                   ; preds = %while.cond.307
  %159 = load i64, i64* %last, align 8
  %sub316 = sub nsw i64 %159, 3
  %160 = inttoptr i64 %sub316 to i8*
  %161 = bitcast i8* %160 to %struct.Lisp_Cons*
  %u317 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %161, i32 0, i32 1
  %cdr318 = bitcast %union.anon.12* %u317 to i64*
  %162 = load i64, i64* %cdr318, align 8
  store i64 %162, i64* %last, align 8
  br label %while.cond.307

while.end.319:                                    ; preds = %while.cond.307
  %163 = load i64, i64* %last, align 8
  %sub320 = sub nsw i64 %163, 3
  %164 = inttoptr i64 %sub320 to i8*
  %165 = bitcast i8* %164 to %struct.Lisp_Cons*
  %u321 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %165, i32 0, i32 1
  %cdr322 = bitcast %union.anon.12* %u321 to i64*
  %166 = load i64, i64* %cdr322, align 8
  %call323 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp324 = icmp eq i64 %166, %call323
  br i1 %cmp324, label %if.end.327, label %if.then.326

if.then.326:                                      ; preds = %while.end.319
  call void @emacs_abort() #11
  unreachable

if.end.327:                                       ; preds = %while.end.319
  br label %if.end.328

if.end.328:                                       ; preds = %if.end.327, %if.end.301
  %167 = load i64, i64* %last, align 8
  %and329 = and i64 %167, 7
  %conv330 = trunc i64 %and329 to i32
  %cmp331 = icmp eq i32 %conv330, 3
  br i1 %cmp331, label %if.else.335, label %if.then.333

if.then.333:                                      ; preds = %if.end.328
  %168 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %169 = load i64, i64* %c, align 8
  %call334 = call i64 @list1(i64 %169)
  call void @kset_kbd_queue(%struct.kboard* %168, i64 %call334)
  br label %if.end.337

if.else.335:                                      ; preds = %if.end.328
  %170 = load i64, i64* %last, align 8
  %171 = load i64, i64* %c, align 8
  %call336 = call i64 @list1(i64 %171)
  call void @XSETCDR(i64 %170, i64 %call336)
  br label %if.end.337

if.end.337:                                       ; preds = %if.else.335, %if.then.333
  %172 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_has_data = getelementptr inbounds %struct.kboard, %struct.kboard* %172, i32 0, i32 23
  store i8 1, i8* %kbd_queue_has_data, align 1
  %173 = load %struct.kboard*, %struct.kboard** %kb, align 8
  store %struct.kboard* %173, %struct.kboard** @current_kboard, align 8
  store i64 -6, i64* %retval
  br label %return

if.end.338:                                       ; preds = %if.end.294
  br label %non_reread

if.end.339:                                       ; preds = %if.end.277
  %174 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool340 = icmp ne %struct.timespec* %174, null
  br i1 %tobool340, label %if.end.342, label %if.then.341

if.then.341:                                      ; preds = %if.end.339
  call void @timer_start_idle()
  br label %if.end.342

if.end.342:                                       ; preds = %if.then.341, %if.end.339
  %175 = load i64, i64* @minibuf_level, align 8
  %cmp343 = icmp eq i64 %175, 0
  br i1 %cmp343, label %land.lhs.true.345, label %if.end.401

land.lhs.true.345:                                ; preds = %if.end.342
  %176 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool346 = icmp ne %struct.timespec* %176, null
  br i1 %tobool346, label %if.end.401, label %land.lhs.true.347

land.lhs.true.347:                                ; preds = %land.lhs.true.345
  %177 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %177, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end.401, label %land.lhs.true.348

land.lhs.true.348:                                ; preds = %land.lhs.true.347
  %178 = load i64, i64* @this_command_key_count, align 8
  %cmp349 = icmp sgt i64 %178, 0
  br i1 %cmp349, label %land.lhs.true.357, label %lor.lhs.false.351

lor.lhs.false.351:                                ; preds = %land.lhs.true.348
  %call352 = call i64 @builtin_lisp_symbol(i32 566)
  %call353 = call i64 @call0(i64 %call352)
  %call354 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp355 = icmp eq i64 %call353, %call354
  br i1 %cmp355, label %if.end.401, label %land.lhs.true.357

land.lhs.true.357:                                ; preds = %lor.lhs.false.351, %land.lhs.true.348
  %179 = load i8, i8* @noninteractive, align 1
  %tobool358 = trunc i8 %179 to i1
  br i1 %tobool358, label %if.end.401, label %land.lhs.true.359

land.lhs.true.359:                                ; preds = %land.lhs.true.357
  %call360 = call zeroext i1 @echo_keystrokes_p()
  br i1 %call360, label %land.lhs.true.362, label %if.end.401

land.lhs.true.362:                                ; preds = %land.lhs.true.359
  %180 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call363 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp364 = icmp eq i64 %180, %call363
  br i1 %cmp364, label %if.then.379, label %lor.lhs.false.366

lor.lhs.false.366:                                ; preds = %land.lhs.true.362
  %181 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call367 = call %struct.buffer* @XBUFFER(i64 %181)
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %call367, i32 0, i32 73
  %182 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %182, i32 0, i32 2
  %183 = load i64, i64* %z, align 8
  %cmp368 = icmp eq i64 1, %183
  br i1 %cmp368, label %if.then.379, label %lor.lhs.false.370

lor.lhs.false.370:                                ; preds = %lor.lhs.false.366
  %184 = load %struct.kboard*, %struct.kboard** @echo_kboard, align 8
  %tobool371 = icmp ne %struct.kboard* %184, null
  br i1 %tobool371, label %land.lhs.true.372, label %lor.lhs.false.375

land.lhs.true.372:                                ; preds = %lor.lhs.false.370
  %185 = load %struct.kboard*, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  %186 = load %struct.kboard*, %struct.kboard** @echo_kboard, align 8
  %cmp373 = icmp eq %struct.kboard* %185, %186
  br i1 %cmp373, label %if.then.379, label %lor.lhs.false.375

lor.lhs.false.375:                                ; preds = %land.lhs.true.372, %lor.lhs.false.370
  %187 = load %struct.kboard*, %struct.kboard** @echo_kboard, align 8
  %tobool376 = icmp ne %struct.kboard* %187, null
  br i1 %tobool376, label %if.end.401, label %land.lhs.true.377

land.lhs.true.377:                                ; preds = %lor.lhs.false.375
  %188 = load %struct.kboard*, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  %tobool378 = icmp ne %struct.kboard* %188, null
  br i1 %tobool378, label %if.then.379, label %if.end.401

if.then.379:                                      ; preds = %land.lhs.true.377, %land.lhs.true.372, %lor.lhs.false.366, %land.lhs.true.362
  %189 = load i64, i64* %prev_event.addr, align 8
  %and380 = and i64 %189, 7
  %conv381 = trunc i64 %and380 to i32
  %cmp382 = icmp eq i32 %conv381, 3
  br i1 %cmp382, label %if.then.384, label %if.else.385

if.then.384:                                      ; preds = %if.then.379
  call void @echo_now()
  br label %if.end.400

if.else.385:                                      ; preds = %if.then.379
  %arraydecay386 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @save_getcjmp(%struct.__jmp_buf_tag* %arraydecay386)
  %arraydecay387 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %local_getcjmp, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay387)
  %190 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  %call388 = call i64 @sit_for(i64 %190, i1 zeroext true, i32 1)
  store i64 %call388, i64* %tem0, align 8
  %arraydecay389 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay389)
  %191 = load i64, i64* %tem0, align 8
  %call390 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp391 = icmp eq i64 %191, %call390
  br i1 %cmp391, label %land.lhs.true.393, label %if.end.399

land.lhs.true.393:                                ; preds = %if.else.385
  %192 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and394 = and i64 %192, 7
  %conv395 = trunc i64 %and394 to i32
  %cmp396 = icmp eq i32 %conv395, 3
  br i1 %cmp396, label %if.end.399, label %if.then.398

if.then.398:                                      ; preds = %land.lhs.true.393
  call void @echo_now()
  br label %if.end.399

if.end.399:                                       ; preds = %if.then.398, %land.lhs.true.393, %if.else.385
  br label %if.end.400

if.end.400:                                       ; preds = %if.end.399, %if.then.384
  br label %if.end.401

if.end.401:                                       ; preds = %if.end.400, %land.lhs.true.377, %lor.lhs.false.375, %land.lhs.true.359, %land.lhs.true.357, %lor.lhs.false.351, %land.lhs.true.347, %land.lhs.true.345, %if.end.342
  %193 = load i32, i32* %commandflag.addr, align 4
  %cmp402 = icmp ne i32 %193, 0
  br i1 %cmp402, label %land.lhs.true.404, label %if.end.422

land.lhs.true.404:                                ; preds = %if.end.401
  %194 = load i32, i32* %commandflag.addr, align 4
  %cmp405 = icmp ne i32 %194, -2
  br i1 %cmp405, label %land.lhs.true.407, label %if.end.422

land.lhs.true.407:                                ; preds = %land.lhs.true.404
  %195 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 380), align 8
  %cmp408 = icmp sgt i64 %195, 0
  br i1 %cmp408, label %land.lhs.true.410, label %if.end.422

land.lhs.true.410:                                ; preds = %land.lhs.true.407
  %196 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  %197 = load i64, i64* @last_auto_save, align 8
  %sub411 = sub nsw i64 %196, %197
  %198 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 380), align 8
  %cmp412 = icmp sgt i64 %198, 20
  br i1 %cmp412, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.410
  %199 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 380), align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.410
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %199, %cond.true ], [ 20, %cond.false ]
  %cmp414 = icmp sgt i64 %sub411, %cond
  br i1 %cmp414, label %land.lhs.true.416, label %if.end.422

land.lhs.true.416:                                ; preds = %cond.end
  %call417 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext false)
  br i1 %call417, label %if.end.422, label %if.then.418

if.then.418:                                      ; preds = %land.lhs.true.416
  %call419 = call i64 @builtin_lisp_symbol(i32 0)
  %call420 = call i64 @builtin_lisp_symbol(i32 0)
  %call421 = call i64 @Fdo_auto_save(i64 %call419, i64 %call420)
  call void @redisplay()
  br label %if.end.422

if.end.422:                                       ; preds = %if.then.418, %land.lhs.true.416, %cond.end, %land.lhs.true.407, %land.lhs.true.404, %if.end.401
  %200 = load i64, i64* %map.addr, align 8
  %call423 = call i64 @get_keymap(i64 %200, i1 zeroext false, i1 zeroext false)
  %call424 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp425 = icmp eq i64 %call423, %call424
  br i1 %cmp425, label %if.end.464, label %land.lhs.true.427

land.lhs.true.427:                                ; preds = %if.end.422
  %201 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call428 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp429 = icmp eq i64 %201, %call428
  br i1 %cmp429, label %land.lhs.true.431, label %if.end.464

land.lhs.true.431:                                ; preds = %land.lhs.true.427
  %202 = load i8, i8* @noninteractive, align 1
  %tobool432 = trunc i8 %202 to i1
  br i1 %tobool432, label %if.end.464, label %land.lhs.true.433

land.lhs.true.433:                                ; preds = %land.lhs.true.431
  %203 = load i64, i64* %prev_event.addr, align 8
  %call434 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp435 = icmp eq i64 %203, %call434
  br i1 %cmp435, label %if.end.464, label %land.lhs.true.437

land.lhs.true.437:                                ; preds = %land.lhs.true.433
  %204 = load i64, i64* %prev_event.addr, align 8
  %and438 = and i64 %204, 7
  %conv439 = trunc i64 %and438 to i32
  %cmp440 = icmp eq i32 %conv439, 3
  br i1 %cmp440, label %land.lhs.true.442, label %if.end.464

land.lhs.true.442:                                ; preds = %land.lhs.true.437
  %205 = load i64, i64* %prev_event.addr, align 8
  %sub443 = sub nsw i64 %205, 3
  %206 = inttoptr i64 %sub443 to i8*
  %207 = bitcast i8* %206 to %struct.Lisp_Cons*
  %car444 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %207, i32 0, i32 0
  %208 = load i64, i64* %car444, align 8
  %call445 = call i64 @builtin_lisp_symbol(i32 651)
  %cmp446 = icmp eq i64 %208, %call445
  br i1 %cmp446, label %if.end.464, label %land.lhs.true.448

land.lhs.true.448:                                ; preds = %land.lhs.true.442
  %209 = load i64, i64* %prev_event.addr, align 8
  %sub449 = sub nsw i64 %209, 3
  %210 = inttoptr i64 %sub449 to i8*
  %211 = bitcast i8* %210 to %struct.Lisp_Cons*
  %car450 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %211, i32 0, i32 0
  %212 = load i64, i64* %car450, align 8
  %call451 = call i64 @builtin_lisp_symbol(i32 921)
  %cmp452 = icmp eq i64 %212, %call451
  br i1 %cmp452, label %if.end.464, label %land.lhs.true.454

land.lhs.true.454:                                ; preds = %land.lhs.true.448
  %213 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and455 = and i64 %213, 7
  %conv456 = trunc i64 %and455 to i32
  %cmp457 = icmp eq i32 %conv456, 3
  br i1 %cmp457, label %if.end.464, label %if.then.459

if.then.459:                                      ; preds = %land.lhs.true.454
  %214 = load i64, i64* %map.addr, align 8
  %215 = load i64, i64* %prev_event.addr, align 8
  %216 = load i8*, i8** %used_mouse_menu.addr, align 8
  %call460 = call i64 @read_char_x_menu_prompt(i64 %214, i64 %215, i8* %216)
  store i64 %call460, i64* %c, align 8
  %217 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool461 = icmp ne %struct.timespec* %217, null
  br i1 %tobool461, label %if.end.463, label %if.then.462

if.then.462:                                      ; preds = %if.then.459
  call void @timer_stop_idle()
  br label %if.end.463

if.end.463:                                       ; preds = %if.then.462, %if.then.459
  br label %exit

if.end.464:                                       ; preds = %land.lhs.true.454, %land.lhs.true.448, %land.lhs.true.442, %land.lhs.true.437, %land.lhs.true.433, %land.lhs.true.431, %land.lhs.true.427, %if.end.422
  %218 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call465 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp466 = icmp eq i64 %218, %call465
  br i1 %cmp466, label %land.lhs.true.468, label %if.end.555

land.lhs.true.468:                                ; preds = %if.end.464
  %219 = load i8, i8* @noninteractive, align 1
  %tobool469 = trunc i8 %219 to i1
  br i1 %tobool469, label %if.end.555, label %land.lhs.true.470

land.lhs.true.470:                                ; preds = %land.lhs.true.468
  %220 = load i64, i64* %c, align 8
  %call471 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp472 = icmp eq i64 %220, %call471
  br i1 %cmp472, label %if.then.474, label %if.end.555

if.then.474:                                      ; preds = %land.lhs.true.470
  %221 = load i64, i64* @selected_window, align 8
  %call475 = call %struct.window* @XWINDOW(i64 %221)
  %mini = getelementptr inbounds %struct.window, %struct.window* %call475, i32 0, i32 67
  %bf.load476 = load i16, i16* %mini, align 4
  %bf.clear477 = and i16 %bf.load476, 1
  %bf.cast478 = trunc i16 %bf.clear477 to i1
  br i1 %bf.cast478, label %if.end.483, label %if.then.479

if.then.479:                                      ; preds = %if.then.474
  %222 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text480 = getelementptr inbounds %struct.buffer, %struct.buffer* %222, i32 0, i32 73
  %223 = load %struct.buffer_text*, %struct.buffer_text** %text480, align 8
  %z481 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %223, i32 0, i32 2
  %224 = load i64, i64* %z481, align 8
  %sub482 = sub nsw i64 %224, 1
  store i64 %sub482, i64* @last_non_minibuf_size, align 8
  br label %if.end.483

if.end.483:                                       ; preds = %if.then.479, %if.then.474
  %225 = load i64, i64* @last_non_minibuf_size, align 8
  %shr484 = ashr i64 %225, 8
  %add485 = add nsw i64 %shr484, 1
  store i64 %add485, i64* %buffer_size, align 8
  store i32 0, i32* %delay_level, align 4
  br label %while.cond.486

while.cond.486:                                   ; preds = %while.body.489, %if.end.483
  %226 = load i64, i64* %buffer_size, align 8
  %cmp487 = icmp sgt i64 %226, 64
  br i1 %cmp487, label %while.body.489, label %while.end.493

while.body.489:                                   ; preds = %while.cond.486
  %227 = load i32, i32* %delay_level, align 4
  %inc490 = add nsw i32 %227, 1
  store i32 %inc490, i32* %delay_level, align 4
  %228 = load i64, i64* %buffer_size, align 8
  %shr491 = ashr i64 %228, 2
  %229 = load i64, i64* %buffer_size, align 8
  %sub492 = sub nsw i64 %229, %shr491
  store i64 %sub492, i64* %buffer_size, align 8
  br label %while.cond.486

while.end.493:                                    ; preds = %while.cond.486
  %230 = load i32, i32* %delay_level, align 4
  %cmp494 = icmp slt i32 %230, 4
  br i1 %cmp494, label %if.then.496, label %if.end.497

if.then.496:                                      ; preds = %while.end.493
  store i32 4, i32* %delay_level, align 4
  br label %if.end.497

if.end.497:                                       ; preds = %if.then.496, %while.end.493
  %231 = load i32, i32* %commandflag.addr, align 4
  %cmp498 = icmp ne i32 %231, 0
  br i1 %cmp498, label %land.lhs.true.500, label %if.end.551

land.lhs.true.500:                                ; preds = %if.end.497
  %232 = load i32, i32* %commandflag.addr, align 4
  %cmp501 = icmp ne i32 %232, -2
  br i1 %cmp501, label %land.lhs.true.503, label %if.end.551

land.lhs.true.503:                                ; preds = %land.lhs.true.500
  %233 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  %234 = load i64, i64* @last_auto_save, align 8
  %cmp504 = icmp sgt i64 %233, %234
  br i1 %cmp504, label %land.lhs.true.506, label %if.end.551

land.lhs.true.506:                                ; preds = %land.lhs.true.503
  %235 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 11), align 8
  %and507 = and i64 %235, 7
  %conv508 = trunc i64 %and507 to i32
  %and509 = and i32 %conv508, -5
  %cmp510 = icmp eq i32 %and509, 2
  br i1 %cmp510, label %land.lhs.true.512, label %if.end.551

land.lhs.true.512:                                ; preds = %land.lhs.true.506
  %236 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 11), align 8
  %shr513 = ashr i64 %236, 2
  %cmp514 = icmp sgt i64 %shr513, 0
  br i1 %cmp514, label %if.then.516, label %if.end.551

if.then.516:                                      ; preds = %land.lhs.true.512
  %237 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 11), align 8
  %shr518 = ashr i64 %237, 2
  store i64 %shr518, i64* %timeout, align 8
  %238 = load i64, i64* %timeout, align 8
  %239 = load i32, i32* %delay_level, align 4
  %conv519 = sext i32 %239 to i64
  %div = sdiv i64 2305843009213693951, %conv519
  %mul = mul nsw i64 %div, 4
  %cmp520 = icmp slt i64 %238, %mul
  br i1 %cmp520, label %cond.true.522, label %cond.false.523

cond.true.522:                                    ; preds = %if.then.516
  %240 = load i64, i64* %timeout, align 8
  br label %cond.end.527

cond.false.523:                                   ; preds = %if.then.516
  %241 = load i32, i32* %delay_level, align 4
  %conv524 = sext i32 %241 to i64
  %div525 = sdiv i64 2305843009213693951, %conv524
  %mul526 = mul nsw i64 %div525, 4
  br label %cond.end.527

cond.end.527:                                     ; preds = %cond.false.523, %cond.true.522
  %cond528 = phi i64 [ %240, %cond.true.522 ], [ %mul526, %cond.false.523 ]
  store i64 %cond528, i64* %timeout, align 8
  %242 = load i32, i32* %delay_level, align 4
  %conv529 = sext i32 %242 to i64
  %243 = load i64, i64* %timeout, align 8
  %mul530 = mul nsw i64 %conv529, %243
  %div531 = sdiv i64 %mul530, 4
  store i64 %div531, i64* %timeout, align 8
  %arraydecay532 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @save_getcjmp(%struct.__jmp_buf_tag* %arraydecay532)
  %arraydecay533 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %local_getcjmp, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay533)
  %244 = load i64, i64* %timeout, align 8
  %shl534 = shl i64 %244, 2
  %add535 = add i64 %shl534, 2
  %call536 = call i64 @sit_for(i64 %add535, i1 zeroext true, i32 1)
  store i64 %call536, i64* %tem0517, align 8
  %arraydecay537 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay537)
  %245 = load i64, i64* %tem0517, align 8
  %call538 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp539 = icmp eq i64 %245, %call538
  br i1 %cmp539, label %land.lhs.true.541, label %if.end.550

land.lhs.true.541:                                ; preds = %cond.end.527
  %246 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and542 = and i64 %246, 7
  %conv543 = trunc i64 %and542 to i32
  %cmp544 = icmp eq i32 %conv543, 3
  br i1 %cmp544, label %if.end.550, label %if.then.546

if.then.546:                                      ; preds = %land.lhs.true.541
  %call547 = call i64 @builtin_lisp_symbol(i32 0)
  %call548 = call i64 @builtin_lisp_symbol(i32 0)
  %call549 = call i64 @Fdo_auto_save(i64 %call547, i64 %call548)
  call void @redisplay()
  br label %if.end.550

if.end.550:                                       ; preds = %if.then.546, %land.lhs.true.541, %cond.end.527
  br label %if.end.551

if.end.551:                                       ; preds = %if.end.550, %land.lhs.true.512, %land.lhs.true.506, %land.lhs.true.503, %land.lhs.true.500, %if.end.497
  %call552 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext false)
  br i1 %call552, label %if.end.554, label %if.then.553

if.then.553:                                      ; preds = %if.end.551
  call void @maybe_gc()
  br label %if.end.554

if.end.554:                                       ; preds = %if.then.553, %if.end.551
  br label %if.end.555

if.end.555:                                       ; preds = %if.end.554, %land.lhs.true.470, %land.lhs.true.468, %if.end.464
  %247 = load i64, i64* %c, align 8
  %call556 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp557 = icmp eq i64 %247, %call556
  br i1 %cmp557, label %land.lhs.true.559, label %if.end.563

land.lhs.true.559:                                ; preds = %if.end.555
  %248 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %249 = load %struct.kboard*, %struct.kboard** %orig_kboard, align 8
  %cmp560 = icmp ne %struct.kboard* %248, %249
  br i1 %cmp560, label %if.then.562, label %if.end.563

if.then.562:                                      ; preds = %land.lhs.true.559
  store i64 -6, i64* %retval
  br label %return

if.end.563:                                       ; preds = %land.lhs.true.559, %if.end.555
  %250 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and564 = and i64 %250, 7
  %conv565 = trunc i64 %and564 to i32
  %cmp566 = icmp eq i32 %conv565, 3
  br i1 %cmp566, label %if.then.568, label %if.end.590

if.then.568:                                      ; preds = %if.end.563
  %251 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub569 = sub nsw i64 %251, 3
  %252 = inttoptr i64 %sub569 to i8*
  %253 = bitcast i8* %252 to %struct.Lisp_Cons*
  %car570 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %253, i32 0, i32 0
  %254 = load i64, i64* %car570, align 8
  store i64 %254, i64* %c, align 8
  %255 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub571 = sub nsw i64 %255, 3
  %256 = inttoptr i64 %sub571 to i8*
  %257 = bitcast i8* %256 to %struct.Lisp_Cons*
  %u572 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %257, i32 0, i32 1
  %cdr573 = bitcast %union.anon.12* %u572 to i64*
  %258 = load i64, i64* %cdr573, align 8
  store i64 %258, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %259 = load i64, i64* %c, align 8
  %and574 = and i64 %259, 7
  %conv575 = trunc i64 %and574 to i32
  %cmp576 = icmp eq i32 %conv575, 3
  br i1 %cmp576, label %land.lhs.true.578, label %if.else.588

land.lhs.true.578:                                ; preds = %if.then.568
  %260 = load i64, i64* %c, align 8
  %sub579 = sub nsw i64 %260, 3
  %261 = inttoptr i64 %sub579 to i8*
  %262 = bitcast i8* %261 to %struct.Lisp_Cons*
  %car580 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %262, i32 0, i32 0
  %263 = load i64, i64* %car580, align 8
  %call581 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp582 = icmp eq i64 %263, %call581
  br i1 %cmp582, label %if.then.584, label %if.else.588

if.then.584:                                      ; preds = %land.lhs.true.578
  %264 = load i64, i64* %c, align 8
  %sub585 = sub nsw i64 %264, 3
  %265 = inttoptr i64 %sub585 to i8*
  %266 = bitcast i8* %265 to %struct.Lisp_Cons*
  %u586 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %266, i32 0, i32 1
  %cdr587 = bitcast %union.anon.12* %u586 to i64*
  %267 = load i64, i64* %cdr587, align 8
  store i64 %267, i64* %c, align 8
  br label %if.end.589

if.else.588:                                      ; preds = %land.lhs.true.578, %if.then.568
  store volatile i8 1, i8* %reread, align 1
  br label %if.end.589

if.end.589:                                       ; preds = %if.else.588, %if.then.584
  br label %if.end.590

if.end.590:                                       ; preds = %if.end.589, %if.end.563
  %268 = load i64, i64* %c, align 8
  %call591 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp592 = icmp eq i64 %268, %call591
  br i1 %cmp592, label %if.then.594, label %if.end.649

if.then.594:                                      ; preds = %if.end.590
  %269 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_has_data595 = getelementptr inbounds %struct.kboard, %struct.kboard* %269, i32 0, i32 23
  %270 = load i8, i8* %kbd_queue_has_data595, align 1
  %tobool596 = trunc i8 %270 to i1
  br i1 %tobool596, label %if.then.597, label %if.end.648

if.then.597:                                      ; preds = %if.then.594
  %271 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_598 = getelementptr inbounds %struct.kboard, %struct.kboard* %271, i32 0, i32 8
  %272 = load i64, i64* %kbd_queue_598, align 8
  %and599 = and i64 %272, 7
  %conv600 = trunc i64 %and599 to i32
  %cmp601 = icmp eq i32 %conv600, 3
  br i1 %cmp601, label %if.end.604, label %if.then.603

if.then.603:                                      ; preds = %if.then.597
  call void @emacs_abort() #11
  unreachable

if.end.604:                                       ; preds = %if.then.597
  %273 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_605 = getelementptr inbounds %struct.kboard, %struct.kboard* %273, i32 0, i32 8
  %274 = load i64, i64* %kbd_queue_605, align 8
  %sub606 = sub nsw i64 %274, 3
  %275 = inttoptr i64 %sub606 to i8*
  %276 = bitcast i8* %275 to %struct.Lisp_Cons*
  %car607 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %276, i32 0, i32 0
  %277 = load i64, i64* %car607, align 8
  store i64 %277, i64* %c, align 8
  %278 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %279 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_608 = getelementptr inbounds %struct.kboard, %struct.kboard* %279, i32 0, i32 8
  %280 = load i64, i64* %kbd_queue_608, align 8
  %sub609 = sub nsw i64 %280, 3
  %281 = inttoptr i64 %sub609 to i8*
  %282 = bitcast i8* %281 to %struct.Lisp_Cons*
  %u610 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %282, i32 0, i32 1
  %cdr611 = bitcast %union.anon.12* %u610 to i64*
  %283 = load i64, i64* %cdr611, align 8
  call void @kset_kbd_queue(%struct.kboard* %278, i64 %283)
  %284 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_612 = getelementptr inbounds %struct.kboard, %struct.kboard* %284, i32 0, i32 8
  %285 = load i64, i64* %kbd_queue_612, align 8
  %call613 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp614 = icmp eq i64 %285, %call613
  br i1 %cmp614, label %if.then.616, label %if.end.618

if.then.616:                                      ; preds = %if.end.604
  %286 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_has_data617 = getelementptr inbounds %struct.kboard, %struct.kboard* %286, i32 0, i32 23
  store i8 0, i8* %kbd_queue_has_data617, align 1
  br label %if.end.618

if.end.618:                                       ; preds = %if.then.616, %if.end.604
  %call619 = call zeroext i1 @readable_events(i32 0)
  %frombool620 = zext i1 %call619 to i8
  store i8 %frombool620, i8* @input_pending, align 1
  %287 = load i64, i64* %c, align 8
  %and621 = and i64 %287, 7
  %conv622 = trunc i64 %and621 to i32
  %cmp623 = icmp eq i32 %conv622, 3
  br i1 %cmp623, label %land.lhs.true.625, label %if.end.647

land.lhs.true.625:                                ; preds = %if.end.618
  %288 = load i64, i64* %c, align 8
  %and626 = and i64 %288, 7
  %conv627 = trunc i64 %and626 to i32
  %cmp628 = icmp eq i32 %conv627, 3
  br i1 %cmp628, label %cond.true.630, label %cond.false.633

cond.true.630:                                    ; preds = %land.lhs.true.625
  %289 = load i64, i64* %c, align 8
  %sub631 = sub nsw i64 %289, 3
  %290 = inttoptr i64 %sub631 to i8*
  %291 = bitcast i8* %290 to %struct.Lisp_Cons*
  %car632 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %291, i32 0, i32 0
  %292 = load i64, i64* %car632, align 8
  br label %cond.end.634

cond.false.633:                                   ; preds = %land.lhs.true.625
  %293 = load i64, i64* %c, align 8
  br label %cond.end.634

cond.end.634:                                     ; preds = %cond.false.633, %cond.true.630
  %cond635 = phi i64 [ %292, %cond.true.630 ], [ %293, %cond.false.633 ]
  %call636 = call i64 @builtin_lisp_symbol(i32 382)
  %call637 = call i64 @Fget(i64 %cond635, i64 %call636)
  %call638 = call i64 @builtin_lisp_symbol(i32 895)
  %cmp639 = icmp eq i64 %call637, %call638
  br i1 %cmp639, label %if.then.641, label %if.end.647

if.then.641:                                      ; preds = %cond.end.634
  %294 = load i64, i64* %c, align 8
  %sub642 = sub nsw i64 %294, 3
  %295 = inttoptr i64 %sub642 to i8*
  %296 = bitcast i8* %295 to %struct.Lisp_Cons*
  %u643 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %296, i32 0, i32 1
  %cdr644 = bitcast %union.anon.12* %u643 to i64*
  %297 = load i64, i64* %cdr644, align 8
  %sub645 = sub nsw i64 %297, 3
  %298 = inttoptr i64 %sub645 to i8*
  %299 = bitcast i8* %298 to %struct.Lisp_Cons*
  %car646 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %299, i32 0, i32 0
  %300 = load i64, i64* %car646, align 8
  store i64 %300, i64* @internal_last_event_frame, align 8
  br label %if.end.647

if.end.647:                                       ; preds = %if.then.641, %cond.end.634, %if.end.618
  %301 = load i64, i64* @internal_last_event_frame, align 8
  store i64 %301, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  br label %if.end.648

if.end.648:                                       ; preds = %if.end.647, %if.then.594
  br label %if.end.649

if.end.649:                                       ; preds = %if.end.648, %if.end.590
  %302 = load i64, i64* %c, align 8
  %call650 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp651 = icmp eq i64 %302, %call650
  br i1 %cmp651, label %land.lhs.true.653, label %if.end.662

land.lhs.true.653:                                ; preds = %if.end.649
  %303 = load i8, i8* @single_kboard, align 1
  %tobool654 = trunc i8 %303 to i1
  br i1 %tobool654, label %if.end.662, label %if.then.655

if.then.655:                                      ; preds = %land.lhs.true.653
  %304 = load %struct.kboard*, %struct.kboard** @all_kboards, align 8
  store %struct.kboard* %304, %struct.kboard** %kb656, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.655
  %305 = load %struct.kboard*, %struct.kboard** %kb656, align 8
  %tobool657 = icmp ne %struct.kboard* %305, null
  br i1 %tobool657, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %306 = load %struct.kboard*, %struct.kboard** %kb656, align 8
  %kbd_queue_has_data658 = getelementptr inbounds %struct.kboard, %struct.kboard* %306, i32 0, i32 23
  %307 = load i8, i8* %kbd_queue_has_data658, align 1
  %tobool659 = trunc i8 %307 to i1
  br i1 %tobool659, label %if.then.660, label %if.end.661

if.then.660:                                      ; preds = %for.body
  %308 = load %struct.kboard*, %struct.kboard** %kb656, align 8
  store %struct.kboard* %308, %struct.kboard** @current_kboard, align 8
  store i64 -6, i64* %retval
  br label %return

if.end.661:                                       ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.661
  %309 = load %struct.kboard*, %struct.kboard** %kb656, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %309, i32 0, i32 0
  %310 = load %struct.kboard*, %struct.kboard** %next_kboard, align 8
  store %struct.kboard* %310, %struct.kboard** %kb656, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.662

if.end.662:                                       ; preds = %for.end, %land.lhs.true.653, %if.end.649
  br label %wrong_kboard

wrong_kboard:                                     ; preds = %if.end.708, %if.end.662
  br label %do.body

do.body:                                          ; preds = %wrong_kboard
  %311 = load volatile i8, i8* %polling_stopped_here, align 1
  %tobool663 = trunc i8 %311 to i1
  br i1 %tobool663, label %if.end.665, label %if.then.664

if.then.664:                                      ; preds = %do.body
  call void @stop_polling()
  br label %if.end.665

if.end.665:                                       ; preds = %if.then.664, %do.body
  store volatile i8 1, i8* %polling_stopped_here, align 1
  br label %do.end

do.end:                                           ; preds = %if.end.665
  %312 = load i64, i64* %c, align 8
  %call666 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp667 = icmp eq i64 %312, %call666
  br i1 %cmp667, label %if.then.669, label %if.end.688

if.then.669:                                      ; preds = %do.end
  %313 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %arraydecay670 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %local_getcjmp, i32 0, i32 0
  %314 = load i64, i64* %prev_event.addr, align 8
  %315 = load i8*, i8** %used_mouse_menu.addr, align 8
  %call671 = call i64 @read_decoded_event_from_main_queue(%struct.timespec* %313, %struct.__jmp_buf_tag* %arraydecay670, i64 %314, i8* %315)
  store i64 %call671, i64* %c, align 8
  %316 = load i64, i64* %c, align 8
  %call672 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp673 = icmp eq i64 %316, %call672
  br i1 %cmp673, label %land.lhs.true.675, label %if.end.683

land.lhs.true.675:                                ; preds = %if.then.669
  %317 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool676 = icmp ne %struct.timespec* %317, null
  br i1 %tobool676, label %land.lhs.true.677, label %if.end.683

land.lhs.true.677:                                ; preds = %land.lhs.true.675
  %318 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %call678 = call { i64, i64 } @current_timespec()
  %319 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %320 = getelementptr { i64, i64 }, { i64, i64 }* %319, i32 0, i32 0
  %321 = extractvalue { i64, i64 } %call678, 0
  store i64 %321, i64* %320, align 8
  %322 = getelementptr { i64, i64 }, { i64, i64 }* %319, i32 0, i32 1
  %323 = extractvalue { i64, i64 } %call678, 1
  store i64 %323, i64* %322, align 8
  %324 = bitcast %struct.timespec* %318 to { i64, i64 }*
  %325 = getelementptr { i64, i64 }, { i64, i64 }* %324, i32 0, i32 0
  %326 = load i64, i64* %325, align 1
  %327 = getelementptr { i64, i64 }, { i64, i64 }* %324, i32 0, i32 1
  %328 = load i64, i64* %327, align 1
  %329 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %330 = getelementptr { i64, i64 }, { i64, i64 }* %329, i32 0, i32 0
  %331 = load i64, i64* %330, align 1
  %332 = getelementptr { i64, i64 }, { i64, i64 }* %329, i32 0, i32 1
  %333 = load i64, i64* %332, align 1
  %call679 = call i32 @timespec_cmp(i64 %326, i64 %328, i64 %331, i64 %333) #13
  %cmp680 = icmp sle i32 %call679, 0
  br i1 %cmp680, label %if.then.682, label %if.end.683

if.then.682:                                      ; preds = %land.lhs.true.677
  br label %exit

if.end.683:                                       ; preds = %land.lhs.true.677, %land.lhs.true.675, %if.then.669
  %334 = load i64, i64* %c, align 8
  %cmp684 = icmp eq i64 %334, -6
  br i1 %cmp684, label %if.then.686, label %if.end.687

if.then.686:                                      ; preds = %if.end.683
  %335 = load i64, i64* %c, align 8
  store i64 %335, i64* %retval
  br label %return

if.end.687:                                       ; preds = %if.end.683
  br label %if.end.688

if.end.688:                                       ; preds = %if.end.687, %do.end
  br label %non_reread

non_reread:                                       ; preds = %if.end.688, %if.end.338
  %336 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool689 = icmp ne %struct.timespec* %336, null
  br i1 %tobool689, label %if.end.691, label %if.then.690

if.then.690:                                      ; preds = %non_reread
  call void @timer_stop_idle()
  br label %if.end.691

if.end.691:                                       ; preds = %if.then.690, %non_reread
  br label %do.body.692

do.body.692:                                      ; preds = %if.end.691
  %337 = load volatile i8, i8* %polling_stopped_here, align 1
  %tobool693 = trunc i8 %337 to i1
  br i1 %tobool693, label %if.then.694, label %if.end.695

if.then.694:                                      ; preds = %do.body.692
  call void @start_polling()
  br label %if.end.695

if.end.695:                                       ; preds = %if.then.694, %do.body.692
  store volatile i8 0, i8* %polling_stopped_here, align 1
  br label %do.end.696

do.end.696:                                       ; preds = %if.end.695
  %338 = load i64, i64* %c, align 8
  %call697 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp698 = icmp eq i64 %338, %call697
  br i1 %cmp698, label %if.then.700, label %if.end.709

if.then.700:                                      ; preds = %do.end.696
  %339 = load i32, i32* %commandflag.addr, align 4
  %cmp701 = icmp sge i32 %339, 0
  br i1 %cmp701, label %land.lhs.true.703, label %if.end.708

land.lhs.true.703:                                ; preds = %if.then.700
  %340 = load i8, i8* @input_pending, align 1
  %tobool704 = trunc i8 %340 to i1
  br i1 %tobool704, label %if.end.708, label %land.lhs.true.705

land.lhs.true.705:                                ; preds = %land.lhs.true.703
  %call706 = call zeroext i1 @detect_input_pending_run_timers(i1 zeroext false)
  br i1 %call706, label %if.end.708, label %if.then.707

if.then.707:                                      ; preds = %land.lhs.true.705
  call void @redisplay()
  br label %if.end.708

if.end.708:                                       ; preds = %if.then.707, %land.lhs.true.705, %land.lhs.true.703, %if.then.700
  br label %wrong_kboard

if.end.709:                                       ; preds = %do.end.696
  %341 = load i64, i64* %c, align 8
  %call710 = call zeroext i1 @BUFFERP(i64 %341)
  br i1 %call710, label %if.then.711, label %if.end.712

if.then.711:                                      ; preds = %if.end.709
  br label %exit

if.end.712:                                       ; preds = %if.end.709
  %342 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  store i64 %342, i64* %save, align 8
  %call713 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call713, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %343 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  %call714 = call i64 @get_keymap(i64 %343, i1 zeroext false, i1 zeroext true)
  %344 = load i64, i64* %c, align 8
  %call715 = call i64 @access_keymap(i64 %call714, i64 %344, i1 zeroext false, i1 zeroext false, i1 zeroext true)
  store i64 %call715, i64* %tem, align 8
  %345 = load i64, i64* %save, align 8
  store i64 %345, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %346 = load i64, i64* %tem, align 8
  %call716 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp717 = icmp eq i64 %346, %call716
  br i1 %cmp717, label %if.end.743, label %if.then.719

if.then.719:                                      ; preds = %if.end.712
  %347 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %347, %struct.buffer** %prev_buffer, align 8
  %348 = load i64, i64* %c, align 8
  store i64 %348, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376), align 8
  %call720 = call i64 @builtin_lisp_symbol(i32 285)
  %349 = load i64, i64* %tem, align 8
  %call721 = call i64 @builtin_lisp_symbol(i32 0)
  %call722 = call i64 @Fvector(i64 1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376))
  %call723 = call i64 @builtin_lisp_symbol(i32 901)
  %call724 = call i64 @call4(i64 %call720, i64 %349, i64 %call721, i64 %call722, i64 %call723)
  %350 = load i64, i64* %c, align 8
  %and725 = and i64 %350, 7
  %conv726 = trunc i64 %and725 to i32
  %cmp727 = icmp eq i32 %conv726, 3
  br i1 %cmp727, label %land.lhs.true.729, label %if.end.738

land.lhs.true.729:                                ; preds = %if.then.719
  %351 = load i64, i64* %c, align 8
  %sub730 = sub nsw i64 %351, 3
  %352 = inttoptr i64 %sub730 to i8*
  %353 = bitcast i8* %352 to %struct.Lisp_Cons*
  %car731 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %353, i32 0, i32 0
  %354 = load i64, i64* %car731, align 8
  %call732 = call i64 @builtin_lisp_symbol(i32 840)
  %cmp733 = icmp eq i64 %354, %call732
  br i1 %cmp733, label %land.lhs.true.735, label %if.end.738

land.lhs.true.735:                                ; preds = %land.lhs.true.729
  %355 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool736 = icmp ne %struct.timespec* %355, null
  br i1 %tobool736, label %if.end.738, label %if.then.737

if.then.737:                                      ; preds = %land.lhs.true.735
  call void @timer_resume_idle()
  br label %if.end.738

if.end.738:                                       ; preds = %if.then.737, %land.lhs.true.735, %land.lhs.true.729, %if.then.719
  %356 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %357 = load %struct.buffer*, %struct.buffer** %prev_buffer, align 8
  %cmp739 = icmp ne %struct.buffer* %356, %357
  br i1 %cmp739, label %if.then.741, label %if.else.742

if.then.741:                                      ; preds = %if.end.738
  store i64 -6, i64* %c, align 8
  br label %exit

if.else.742:                                      ; preds = %if.end.738
  br label %retry

if.end.743:                                       ; preds = %if.end.712
  %358 = load i64, i64* %c, align 8
  %and744 = and i64 %358, 7
  %conv745 = trunc i64 %and744 to i32
  %and746 = and i32 %conv745, -5
  %cmp747 = icmp eq i32 %and746, 2
  br i1 %cmp747, label %if.then.749, label %if.end.815

if.then.749:                                      ; preds = %if.end.743
  %359 = load i64, i64* %c, align 8
  %shr750 = ashr i64 %359, 2
  %cmp751 = icmp eq i64 %shr750, -1
  br i1 %cmp751, label %if.then.753, label %if.end.754

if.then.753:                                      ; preds = %if.then.749
  br label %exit

if.end.754:                                       ; preds = %if.then.749
  %360 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_ = getelementptr inbounds %struct.kboard, %struct.kboard* %360, i32 0, i32 4
  %361 = load i64, i64* %Vkeyboard_translate_table_, align 8
  %call755 = call zeroext i1 @STRINGP(i64 %361)
  br i1 %call755, label %land.lhs.true.757, label %lor.lhs.false.774

land.lhs.true.757:                                ; preds = %if.end.754
  br i1 false, label %cond.true.758, label %cond.false.766

cond.true.758:                                    ; preds = %land.lhs.true.757
  %362 = load i64, i64* %c, align 8
  %shr759 = ashr i64 %362, 2
  %add760 = add nsw i64 %shr759, 0
  %363 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_761 = getelementptr inbounds %struct.kboard, %struct.kboard* %363, i32 0, i32 4
  %364 = load i64, i64* %Vkeyboard_translate_table_761, align 8
  %call762 = call i64 @SCHARS(i64 %364)
  %add763 = add nsw i64 %call762, 0
  %cmp764 = icmp slt i64 %add760, %add763
  br i1 %cmp764, label %if.then.806, label %lor.lhs.false.774

cond.false.766:                                   ; preds = %land.lhs.true.757
  %365 = load i64, i64* %c, align 8
  %shr767 = ashr i64 %365, 2
  %add768 = add i64 %shr767, 0
  %366 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_769 = getelementptr inbounds %struct.kboard, %struct.kboard* %366, i32 0, i32 4
  %367 = load i64, i64* %Vkeyboard_translate_table_769, align 8
  %call770 = call i64 @SCHARS(i64 %367)
  %add771 = add i64 %call770, 0
  %cmp772 = icmp ult i64 %add768, %add771
  br i1 %cmp772, label %if.then.806, label %lor.lhs.false.774

lor.lhs.false.774:                                ; preds = %cond.false.766, %cond.true.758, %if.end.754
  %368 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_775 = getelementptr inbounds %struct.kboard, %struct.kboard* %368, i32 0, i32 4
  %369 = load i64, i64* %Vkeyboard_translate_table_775, align 8
  %call776 = call zeroext i1 @VECTORP(i64 %369)
  br i1 %call776, label %land.lhs.true.778, label %lor.lhs.false.795

land.lhs.true.778:                                ; preds = %lor.lhs.false.774
  br i1 false, label %cond.true.779, label %cond.false.787

cond.true.779:                                    ; preds = %land.lhs.true.778
  %370 = load i64, i64* %c, align 8
  %shr780 = ashr i64 %370, 2
  %add781 = add nsw i64 %shr780, 0
  %371 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_782 = getelementptr inbounds %struct.kboard, %struct.kboard* %371, i32 0, i32 4
  %372 = load i64, i64* %Vkeyboard_translate_table_782, align 8
  %call783 = call i64 @ASIZE(i64 %372)
  %add784 = add nsw i64 %call783, 0
  %cmp785 = icmp slt i64 %add781, %add784
  br i1 %cmp785, label %if.then.806, label %lor.lhs.false.795

cond.false.787:                                   ; preds = %land.lhs.true.778
  %373 = load i64, i64* %c, align 8
  %shr788 = ashr i64 %373, 2
  %add789 = add i64 %shr788, 0
  %374 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_790 = getelementptr inbounds %struct.kboard, %struct.kboard* %374, i32 0, i32 4
  %375 = load i64, i64* %Vkeyboard_translate_table_790, align 8
  %call791 = call i64 @ASIZE(i64 %375)
  %add792 = add i64 %call791, 0
  %cmp793 = icmp ult i64 %add789, %add792
  br i1 %cmp793, label %if.then.806, label %lor.lhs.false.795

lor.lhs.false.795:                                ; preds = %cond.false.787, %cond.true.779, %lor.lhs.false.774
  %376 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_796 = getelementptr inbounds %struct.kboard, %struct.kboard* %376, i32 0, i32 4
  %377 = load i64, i64* %Vkeyboard_translate_table_796, align 8
  %call797 = call zeroext i1 @CHAR_TABLE_P(i64 %377)
  br i1 %call797, label %land.lhs.true.799, label %if.end.814

land.lhs.true.799:                                ; preds = %lor.lhs.false.795
  %378 = load i64, i64* %c, align 8
  %call800 = call zeroext i1 @NATNUMP(i64 %378)
  br i1 %call800, label %land.lhs.true.802, label %if.end.814

land.lhs.true.802:                                ; preds = %land.lhs.true.799
  %379 = load i64, i64* %c, align 8
  %shr803 = ashr i64 %379, 2
  %cmp804 = icmp sle i64 %shr803, 4194303
  br i1 %cmp804, label %if.then.806, label %if.end.814

if.then.806:                                      ; preds = %land.lhs.true.802, %cond.false.787, %cond.true.779, %cond.false.766, %cond.true.758
  %380 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vkeyboard_translate_table_807 = getelementptr inbounds %struct.kboard, %struct.kboard* %380, i32 0, i32 4
  %381 = load i64, i64* %Vkeyboard_translate_table_807, align 8
  %382 = load i64, i64* %c, align 8
  %call808 = call i64 @Faref(i64 %381, i64 %382)
  store i64 %call808, i64* %d, align 8
  %383 = load i64, i64* %d, align 8
  %call809 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp810 = icmp eq i64 %383, %call809
  br i1 %cmp810, label %if.end.813, label %if.then.812

if.then.812:                                      ; preds = %if.then.806
  %384 = load i64, i64* %d, align 8
  store i64 %384, i64* %c, align 8
  br label %if.end.813

if.end.813:                                       ; preds = %if.then.812, %if.then.806
  br label %if.end.814

if.end.814:                                       ; preds = %if.end.813, %land.lhs.true.802, %land.lhs.true.799, %lor.lhs.false.795
  br label %if.end.815

if.end.815:                                       ; preds = %if.end.814, %if.end.743
  %385 = load i64, i64* %c, align 8
  %and816 = and i64 %385, 7
  %conv817 = trunc i64 %and816 to i32
  %cmp818 = icmp eq i32 %conv817, 3
  br i1 %cmp818, label %land.lhs.true.820, label %if.end.866

land.lhs.true.820:                                ; preds = %if.end.815
  %386 = load i64, i64* %c, align 8
  %sub821 = sub nsw i64 %386, 3
  %387 = inttoptr i64 %sub821 to i8*
  %388 = bitcast i8* %387 to %struct.Lisp_Cons*
  %u822 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %388, i32 0, i32 1
  %cdr823 = bitcast %union.anon.12* %u822 to i64*
  %389 = load i64, i64* %cdr823, align 8
  %and824 = and i64 %389, 7
  %conv825 = trunc i64 %and824 to i32
  %cmp826 = icmp eq i32 %conv825, 3
  br i1 %cmp826, label %land.lhs.true.828, label %if.end.866

land.lhs.true.828:                                ; preds = %land.lhs.true.820
  %390 = load i64, i64* %c, align 8
  %call829 = call i64 @CDR_SAFE(i64 %390)
  %call830 = call i64 @CAR_SAFE(i64 %call829)
  %and831 = and i64 %call830, 7
  %conv832 = trunc i64 %and831 to i32
  %cmp833 = icmp eq i32 %conv832, 3
  br i1 %cmp833, label %land.lhs.true.835, label %if.end.866

land.lhs.true.835:                                ; preds = %land.lhs.true.828
  %391 = load i64, i64* %c, align 8
  %call836 = call i64 @CDR_SAFE(i64 %391)
  %call837 = call i64 @CAR_SAFE(i64 %call836)
  %sub838 = sub nsw i64 %call837, 3
  %392 = inttoptr i64 %sub838 to i8*
  %393 = bitcast i8* %392 to %struct.Lisp_Cons*
  %u839 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %393, i32 0, i32 1
  %cdr840 = bitcast %union.anon.12* %u839 to i64*
  %394 = load i64, i64* %cdr840, align 8
  %and841 = and i64 %394, 7
  %conv842 = trunc i64 %and841 to i32
  %cmp843 = icmp eq i32 %conv842, 3
  br i1 %cmp843, label %if.then.845, label %if.end.866

if.then.845:                                      ; preds = %land.lhs.true.835
  %395 = load i64, i64* %c, align 8
  %call846 = call i64 @CDR_SAFE(i64 %395)
  %call847 = call i64 @CAR_SAFE(i64 %call846)
  %call848 = call i64 @CDR_SAFE(i64 %call847)
  %call849 = call i64 @CAR_SAFE(i64 %call848)
  store i64 %call849, i64* %posn, align 8
  %396 = load i64, i64* %posn, align 8
  %call850 = call i64 @builtin_lisp_symbol(i32 651)
  %cmp851 = icmp eq i64 %396, %call850
  br i1 %cmp851, label %if.then.857, label %lor.lhs.false.853

lor.lhs.false.853:                                ; preds = %if.then.845
  %397 = load i64, i64* %posn, align 8
  %call854 = call i64 @builtin_lisp_symbol(i32 921)
  %cmp855 = icmp eq i64 %397, %call854
  br i1 %cmp855, label %if.then.857, label %if.end.865

if.then.857:                                      ; preds = %lor.lhs.false.853, %if.then.845
  %398 = load i64, i64* %c, align 8
  %call858 = call i64 @CDR_SAFE(i64 %398)
  %call859 = call i64 @CAR_SAFE(i64 %call858)
  %sub860 = sub nsw i64 %call859, 3
  %399 = inttoptr i64 %sub860 to i8*
  %400 = bitcast i8* %399 to %struct.Lisp_Cons*
  %u861 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %400, i32 0, i32 1
  %cdr862 = bitcast %union.anon.12* %u861 to i64*
  %401 = load i64, i64* %cdr862, align 8
  %402 = load i64, i64* %posn, align 8
  %call863 = call i64 @list1(i64 %402)
  call void @XSETCAR(i64 %401, i64 %call863)
  %403 = load i64, i64* %c, align 8
  store volatile i64 %403, i64* %also_record, align 8
  %404 = load i64, i64* %c, align 8
  %405 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %call864 = call i64 @Fcons(i64 %404, i64 %405)
  store i64 %call864, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %406 = load i64, i64* %posn, align 8
  store i64 %406, i64* %c, align 8
  br label %if.end.865

if.end.865:                                       ; preds = %if.then.857, %lor.lhs.false.853
  br label %if.end.866

if.end.866:                                       ; preds = %if.end.865, %land.lhs.true.835, %land.lhs.true.828, %land.lhs.true.820, %if.end.815
  %407 = load i64, i64* %c, align 8
  call void @record_char(i64 %407)
  store volatile i8 1, i8* %recorded, align 1
  %408 = load volatile i64, i64* %also_record, align 8
  %call867 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp868 = icmp eq i64 %408, %call867
  br i1 %cmp868, label %if.end.871, label %if.then.870

if.then.870:                                      ; preds = %if.end.866
  %409 = load volatile i64, i64* %also_record, align 8
  call void @record_char(i64 %409)
  br label %if.end.871

if.end.871:                                       ; preds = %if.then.870, %if.end.866
  %410 = load i64, i64* %c, align 8
  %and872 = and i64 %410, 7
  %conv873 = trunc i64 %and872 to i32
  %and874 = and i32 %conv873, -5
  %cmp875 = icmp eq i32 %and874, 2
  br i1 %cmp875, label %land.lhs.true.877, label %if.end.895

land.lhs.true.877:                                ; preds = %if.end.871
  %411 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 143), align 8
  %call878 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp879 = icmp eq i64 %411, %call878
  br i1 %cmp879, label %if.end.895, label %land.lhs.true.881

land.lhs.true.881:                                ; preds = %land.lhs.true.877
  %412 = load i64, i64* %c, align 8
  %shr882 = ashr i64 %412, 2
  %cmp883 = icmp sle i64 32, %shr882
  br i1 %cmp883, label %land.lhs.true.885, label %if.end.895

land.lhs.true.885:                                ; preds = %land.lhs.true.881
  %413 = load i64, i64* %c, align 8
  %shr886 = ashr i64 %413, 2
  %cmp887 = icmp slt i64 %shr886, 256
  br i1 %cmp887, label %land.lhs.true.889, label %if.end.895

land.lhs.true.889:                                ; preds = %land.lhs.true.885
  %414 = load i64, i64* %c, align 8
  %shr890 = ashr i64 %414, 2
  %cmp891 = icmp ne i64 %shr890, 127
  br i1 %cmp891, label %if.then.893, label %if.end.895

if.then.893:                                      ; preds = %land.lhs.true.889
  %call894 = call i64 @Fcurrent_message()
  store volatile i64 %call894, i64* %previous_echo_area_message, align 8
  %415 = load volatile i64, i64* %previous_echo_area_message, align 8
  store i64 %415, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 144), align 8
  br label %if.end.895

if.end.895:                                       ; preds = %if.then.893, %land.lhs.true.889, %land.lhs.true.885, %land.lhs.true.881, %land.lhs.true.877, %if.end.871
  %416 = load i64, i64* %c, align 8
  %and896 = and i64 %416, 7
  %conv897 = trunc i64 %and896 to i32
  %cmp898 = icmp eq i32 %conv897, 3
  br i1 %cmp898, label %lor.lhs.false.900, label %if.then.918

lor.lhs.false.900:                                ; preds = %if.end.895
  %call901 = call i64 @builtin_lisp_symbol(i32 516)
  %417 = load i64, i64* %c, align 8
  %sub902 = sub nsw i64 %417, 3
  %418 = inttoptr i64 %sub902 to i8*
  %419 = bitcast i8* %418 to %struct.Lisp_Cons*
  %car903 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %419, i32 0, i32 0
  %420 = load i64, i64* %car903, align 8
  %cmp904 = icmp eq i64 %call901, %420
  br i1 %cmp904, label %if.end.925, label %land.lhs.true.906

land.lhs.true.906:                                ; preds = %lor.lhs.false.900
  %call907 = call i64 @builtin_lisp_symbol(i32 895)
  %421 = load i64, i64* %c, align 8
  %sub908 = sub nsw i64 %421, 3
  %422 = inttoptr i64 %sub908 to i8*
  %423 = bitcast i8* %422 to %struct.Lisp_Cons*
  %car909 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %423, i32 0, i32 0
  %424 = load i64, i64* %car909, align 8
  %cmp910 = icmp eq i64 %call907, %424
  br i1 %cmp910, label %if.end.925, label %land.lhs.true.912

land.lhs.true.912:                                ; preds = %land.lhs.true.906
  %call913 = call i64 @builtin_lisp_symbol(i32 840)
  %425 = load i64, i64* %c, align 8
  %sub914 = sub nsw i64 %425, 3
  %426 = inttoptr i64 %sub914 to i8*
  %427 = bitcast i8* %426 to %struct.Lisp_Cons*
  %car915 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %427, i32 0, i32 0
  %428 = load i64, i64* %car915, align 8
  %cmp916 = icmp eq i64 %call913, %428
  br i1 %cmp916, label %if.end.925, label %if.then.918

if.then.918:                                      ; preds = %land.lhs.true.912, %if.end.895
  %429 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call919 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp920 = icmp eq i64 %429, %call919
  br i1 %cmp920, label %if.end.924, label %if.then.922

if.then.922:                                      ; preds = %if.then.918
  %call923 = call i64 @builtin_lisp_symbol(i32 355)
  call void @safe_run_hooks(i64 %call923)
  call void @clear_message(i1 zeroext true, i1 zeroext false)
  br label %if.end.924

if.end.924:                                       ; preds = %if.then.922, %if.then.918
  br label %if.end.925

if.end.925:                                       ; preds = %if.end.924, %land.lhs.true.912, %land.lhs.true.906, %lor.lhs.false.900
  br label %reread_for_input_method

reread_for_input_method:                          ; preds = %if.end.925, %if.end.142, %if.end.101
  br label %from_macro

from_macro:                                       ; preds = %reread_for_input_method, %if.end.173
  %430 = load i64, i64* %c, align 8
  %and926 = and i64 %430, 7
  %conv927 = trunc i64 %and926 to i32
  %and928 = and i32 %conv927, -5
  %cmp929 = icmp eq i32 %and928, 2
  br i1 %cmp929, label %land.lhs.true.931, label %if.end.1005

land.lhs.true.931:                                ; preds = %from_macro
  %431 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 143), align 8
  %call932 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp933 = icmp eq i64 %431, %call932
  br i1 %cmp933, label %if.end.1005, label %land.lhs.true.935

land.lhs.true.935:                                ; preds = %land.lhs.true.931
  %432 = load i64, i64* %prev_event.addr, align 8
  %call936 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp937 = icmp eq i64 %432, %call936
  br i1 %cmp937, label %land.lhs.true.939, label %if.end.1005

land.lhs.true.939:                                ; preds = %land.lhs.true.935
  %433 = load i64, i64* %c, align 8
  %shr940 = ashr i64 %433, 2
  %cmp941 = icmp sle i64 32, %shr940
  br i1 %cmp941, label %land.lhs.true.943, label %if.end.1005

land.lhs.true.943:                                ; preds = %land.lhs.true.939
  %434 = load i64, i64* %c, align 8
  %shr944 = ashr i64 %434, 2
  %cmp945 = icmp slt i64 %shr944, 256
  br i1 %cmp945, label %land.lhs.true.947, label %if.end.1005

land.lhs.true.947:                                ; preds = %land.lhs.true.943
  %435 = load i64, i64* %c, align 8
  %shr948 = ashr i64 %435, 2
  %cmp949 = icmp ne i64 %shr948, 127
  br i1 %cmp949, label %if.then.951, label %if.end.1005

if.then.951:                                      ; preds = %land.lhs.true.947
  %call952 = call i64 @SPECPDL_INDEX()
  store i64 %call952, i64* %count, align 8
  %436 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo953 = getelementptr inbounds %struct.kboard, %struct.kboard* %436, i32 0, i32 24
  %bf.load954 = load i8, i8* %immediate_echo953, align 1
  %bf.clear955 = and i8 %bf.load954, 1
  %bf.cast956 = trunc i8 %bf.clear955 to i1
  %frombool957 = zext i1 %bf.cast956 to i8
  store i8 %frombool957, i8* %saved_immediate_echo, align 1
  %437 = load %struct.kboard*, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  store %struct.kboard* %437, %struct.kboard** %saved_ok_to_echo, align 8
  %438 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %438, i32 0, i32 22
  %439 = load i64, i64* %echo_string_, align 8
  store i64 %439, i64* %saved_echo_string, align 8
  %440 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_prompt_ = getelementptr inbounds %struct.kboard, %struct.kboard* %440, i32 0, i32 25
  %441 = load i64, i64* %echo_prompt_, align 8
  store i64 %441, i64* %saved_echo_prompt, align 8
  %442 = load i64, i64* @this_command_key_count, align 8
  store i64 %442, i64* %key_count, align 8
  %443 = load i64, i64* @this_single_command_key_start, align 8
  store i64 %443, i64* %command_key_start, align 8
  %444 = load i64, i64* %key_count, align 8
  %cmp958 = icmp sgt i64 %444, 0
  br i1 %cmp958, label %if.then.960, label %if.else.962

if.then.960:                                      ; preds = %if.then.951
  %445 = load i64, i64* @this_command_keys, align 8
  %call961 = call i64 @Fcopy_sequence(i64 %445)
  store i64 %call961, i64* %keys, align 8
  br label %if.end.964

if.else.962:                                      ; preds = %if.then.951
  %call963 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call963, i64* %keys, align 8
  br label %if.end.964

if.end.964:                                       ; preds = %if.else.962, %if.then.960
  store i64 0, i64* @this_command_key_count, align 8
  store i64 0, i64* @this_single_command_key_start, align 8
  %446 = load i64, i64* getelementptr inbounds ([2 x i64], [2 x i64]* @echo_area_buffer, i32 0, i64 0), align 8
  %call965 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp966 = icmp eq i64 %446, %call965
  br i1 %cmp966, label %if.end.970, label %if.then.968

if.then.968:                                      ; preds = %if.end.964
  %call969 = call i64 @builtin_lisp_symbol(i32 355)
  call void @safe_run_hooks(i64 %call969)
  br label %if.end.970

if.end.970:                                       ; preds = %if.then.968, %if.end.964
  call void @clear_message(i1 zeroext true, i1 zeroext false)
  call void @echo_truncate(i64 0)
  %447 = load i64, i64* %map.addr, align 8
  %call971 = call i64 @get_keymap(i64 %447, i1 zeroext false, i1 zeroext false)
  %call972 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp973 = icmp eq i64 %call971, %call972
  br i1 %cmp973, label %if.then.975, label %if.end.978

if.then.975:                                      ; preds = %if.end.970
  %call976 = call i64 @builtin_lisp_symbol(i32 551)
  %call977 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call976, i64 %call977)
  br label %if.end.978

if.end.978:                                       ; preds = %if.then.975, %if.end.970
  %448 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 143), align 8
  %449 = load i64, i64* %c, align 8
  %call979 = call i64 @call1(i64 %448, i64 %449)
  store i64 %call979, i64* %tem, align 8
  %450 = load i64, i64* %count, align 8
  %451 = load i64, i64* %tem, align 8
  %call980 = call i64 @unbind_to(i64 %450, i64 %451)
  store i64 %call980, i64* %tem, align 8
  %452 = load i64, i64* %key_count, align 8
  store i64 %452, i64* @this_command_key_count, align 8
  %453 = load i64, i64* %command_key_start, align 8
  store i64 %453, i64* @this_single_command_key_start, align 8
  %454 = load i64, i64* %key_count, align 8
  %cmp981 = icmp sgt i64 %454, 0
  br i1 %cmp981, label %if.then.983, label %if.end.984

if.then.983:                                      ; preds = %if.end.978
  %455 = load i64, i64* %keys, align 8
  store i64 %455, i64* @this_command_keys, align 8
  br label %if.end.984

if.end.984:                                       ; preds = %if.then.983, %if.end.978
  call void @cancel_echoing()
  %456 = load %struct.kboard*, %struct.kboard** %saved_ok_to_echo, align 8
  store %struct.kboard* %456, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  %457 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %458 = load i64, i64* %saved_echo_string, align 8
  call void @kset_echo_string(%struct.kboard* %457, i64 %458)
  %459 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %460 = load i64, i64* %saved_echo_prompt, align 8
  call void @kset_echo_prompt(%struct.kboard* %459, i64 %460)
  %461 = load i8, i8* %saved_immediate_echo, align 1
  %tobool985 = trunc i8 %461 to i1
  br i1 %tobool985, label %if.then.986, label %if.end.987

if.then.986:                                      ; preds = %if.end.984
  call void @echo_now()
  br label %if.end.987

if.end.987:                                       ; preds = %if.then.986, %if.end.984
  %462 = load i64, i64* %tem, align 8
  %and988 = and i64 %462, 7
  %conv989 = trunc i64 %and988 to i32
  %cmp990 = icmp eq i32 %conv989, 3
  br i1 %cmp990, label %if.end.998, label %if.then.992

if.then.992:                                      ; preds = %if.end.987
  %463 = load volatile i64, i64* %previous_echo_area_message, align 8
  %call993 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp994 = icmp eq i64 %463, %call993
  br i1 %cmp994, label %if.end.997, label %if.then.996

if.then.996:                                      ; preds = %if.then.992
  %464 = load volatile i64, i64* %previous_echo_area_message, align 8
  call void @message_with_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.3, i32 0, i32 0), i64 %464, i1 zeroext false)
  br label %if.end.997

if.end.997:                                       ; preds = %if.then.996, %if.then.992
  br label %retry

if.end.998:                                       ; preds = %if.end.987
  %465 = load i64, i64* %tem, align 8
  %sub999 = sub nsw i64 %465, 3
  %466 = inttoptr i64 %sub999 to i8*
  %467 = bitcast i8* %466 to %struct.Lisp_Cons*
  %car1000 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %467, i32 0, i32 0
  %468 = load i64, i64* %car1000, align 8
  store i64 %468, i64* %c, align 8
  %469 = load i64, i64* %tem, align 8
  %sub1001 = sub nsw i64 %469, 3
  %470 = inttoptr i64 %sub1001 to i8*
  %471 = bitcast i8* %470 to %struct.Lisp_Cons*
  %u1002 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %471, i32 0, i32 1
  %cdr1003 = bitcast %union.anon.12* %u1002 to i64*
  %472 = load i64, i64* %cdr1003, align 8
  %473 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %call1004 = call i64 @nconc2(i64 %472, i64 %473)
  store i64 %call1004, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  br label %if.end.1005

if.end.1005:                                      ; preds = %if.end.998, %land.lhs.true.947, %land.lhs.true.943, %land.lhs.true.939, %land.lhs.true.935, %land.lhs.true.931, %from_macro
  %474 = load volatile i8, i8* %recorded, align 1
  %tobool1006 = trunc i8 %474 to i1
  br i1 %tobool1006, label %if.end.1008, label %if.then.1007

if.then.1007:                                     ; preds = %if.end.1005
  %475 = load i64, i64* %c, align 8
  call void @record_char(i64 %475)
  store volatile i8 1, i8* %recorded, align 1
  br label %if.end.1008

if.end.1008:                                      ; preds = %if.then.1007, %if.end.1005
  br label %reread_first

reread_first:                                     ; preds = %if.end.1008, %if.then.178, %if.end
  %476 = load i64, i64* %c, align 8
  %and1009 = and i64 %476, 7
  %conv1010 = trunc i64 %and1009 to i32
  %cmp1011 = icmp eq i32 %conv1010, 3
  br i1 %cmp1011, label %land.lhs.true.1013, label %if.end.1034

land.lhs.true.1013:                               ; preds = %reread_first
  %477 = load i64, i64* %c, align 8
  %sub1014 = sub nsw i64 %477, 3
  %478 = inttoptr i64 %sub1014 to i8*
  %479 = bitcast i8* %478 to %struct.Lisp_Cons*
  %car1015 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %479, i32 0, i32 0
  %480 = load i64, i64* %car1015, align 8
  %call1016 = call i64 @builtin_lisp_symbol(i32 516)
  %cmp1017 = icmp eq i64 %480, %call1016
  br i1 %cmp1017, label %if.then.1019, label %if.end.1034

if.then.1019:                                     ; preds = %land.lhs.true.1013
  %481 = load i64, i64* %c, align 8
  %sub1020 = sub nsw i64 %481, 3
  %482 = inttoptr i64 %sub1020 to i8*
  %483 = bitcast i8* %482 to %struct.Lisp_Cons*
  %u1021 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %483, i32 0, i32 1
  %cdr1022 = bitcast %union.anon.12* %u1021 to i64*
  %484 = load i64, i64* %cdr1022, align 8
  %call1023 = call i64 @Fcdr(i64 %484)
  store i64 %call1023, i64* %htem, align 8
  %485 = load i64, i64* %htem, align 8
  %call1024 = call i64 @Fcar(i64 %485)
  store i64 %call1024, i64* %help, align 8
  %486 = load i64, i64* %htem, align 8
  %call1025 = call i64 @Fcdr(i64 %486)
  store i64 %call1025, i64* %htem, align 8
  %487 = load i64, i64* %htem, align 8
  %call1026 = call i64 @Fcar(i64 %487)
  store i64 %call1026, i64* %window, align 8
  %488 = load i64, i64* %htem, align 8
  %call1027 = call i64 @Fcdr(i64 %488)
  store i64 %call1027, i64* %htem, align 8
  %489 = load i64, i64* %htem, align 8
  %call1028 = call i64 @Fcar(i64 %489)
  store i64 %call1028, i64* %object, align 8
  %490 = load i64, i64* %htem, align 8
  %call1029 = call i64 @Fcdr(i64 %490)
  store i64 %call1029, i64* %htem, align 8
  %491 = load i64, i64* %htem, align 8
  %call1030 = call i64 @Fcar(i64 %491)
  store i64 %call1030, i64* %position, align 8
  %492 = load i64, i64* %help, align 8
  %493 = load i64, i64* %window, align 8
  %494 = load i64, i64* %object, align 8
  %495 = load i64, i64* %position, align 8
  call void @show_help_echo(i64 %492, i64 %493, i64 %494, i64 %495)
  %496 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool1031 = icmp ne %struct.timespec* %496, null
  br i1 %tobool1031, label %if.end.1033, label %if.then.1032

if.then.1032:                                     ; preds = %if.then.1019
  call void @timer_resume_idle()
  br label %if.end.1033

if.end.1033:                                      ; preds = %if.then.1032, %if.then.1019
  br label %retry

if.end.1034:                                      ; preds = %land.lhs.true.1013, %reread_first
  %497 = load volatile i8, i8* %reread, align 1
  %tobool1035 = trunc i8 %497 to i1
  br i1 %tobool1035, label %lor.lhs.false.1036, label %land.lhs.true.1039

lor.lhs.false.1036:                               ; preds = %if.end.1034
  %498 = load i64, i64* @this_command_key_count, align 8
  %cmp1037 = icmp eq i64 %498, 0
  br i1 %cmp1037, label %land.lhs.true.1039, label %if.end.1069

land.lhs.true.1039:                               ; preds = %lor.lhs.false.1036, %if.end.1034
  %499 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool1040 = icmp ne %struct.timespec* %499, null
  br i1 %tobool1040, label %if.end.1069, label %if.then.1041

if.then.1041:                                     ; preds = %land.lhs.true.1039
  %500 = load i64, i64* %c, align 8
  %and1042 = and i64 %500, 7
  %conv1043 = trunc i64 %and1042 to i32
  %cmp1044 = icmp eq i32 %conv1043, 3
  br i1 %cmp1044, label %land.lhs.true.1046, label %if.then.1062

land.lhs.true.1046:                               ; preds = %if.then.1041
  %501 = load i64, i64* %c, align 8
  %and1047 = and i64 %501, 7
  %conv1048 = trunc i64 %and1047 to i32
  %cmp1049 = icmp eq i32 %conv1048, 3
  br i1 %cmp1049, label %cond.true.1051, label %cond.false.1054

cond.true.1051:                                   ; preds = %land.lhs.true.1046
  %502 = load i64, i64* %c, align 8
  %sub1052 = sub nsw i64 %502, 3
  %503 = inttoptr i64 %sub1052 to i8*
  %504 = bitcast i8* %503 to %struct.Lisp_Cons*
  %car1053 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %504, i32 0, i32 0
  %505 = load i64, i64* %car1053, align 8
  br label %cond.end.1055

cond.false.1054:                                  ; preds = %land.lhs.true.1046
  %506 = load i64, i64* %c, align 8
  br label %cond.end.1055

cond.end.1055:                                    ; preds = %cond.false.1054, %cond.true.1051
  %cond1056 = phi i64 [ %505, %cond.true.1051 ], [ %506, %cond.false.1054 ]
  %call1057 = call i64 @builtin_lisp_symbol(i32 382)
  %call1058 = call i64 @Fget(i64 %cond1056, i64 %call1057)
  %call1059 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp1060 = icmp eq i64 %call1058, %call1059
  br i1 %cmp1060, label %if.end.1063, label %if.then.1062

if.then.1062:                                     ; preds = %cond.end.1055, %if.then.1041
  %507 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  store %struct.kboard* %507, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  br label %if.end.1063

if.end.1063:                                      ; preds = %if.then.1062, %cond.end.1055
  %508 = load i64, i64* %c, align 8
  call void @add_command_key(i64 %508)
  %509 = load volatile i64, i64* %also_record, align 8
  %call1064 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp1065 = icmp eq i64 %509, %call1064
  br i1 %cmp1065, label %if.end.1068, label %if.then.1067

if.then.1067:                                     ; preds = %if.end.1063
  %510 = load volatile i64, i64* %also_record, align 8
  call void @add_command_key(i64 %510)
  br label %if.end.1068

if.end.1068:                                      ; preds = %if.then.1067, %if.end.1063
  call void @echo_update()
  br label %if.end.1069

if.end.1069:                                      ; preds = %if.end.1068, %land.lhs.true.1039, %lor.lhs.false.1036
  %511 = load i64, i64* %c, align 8
  store i64 %511, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376), align 8
  %512 = load i64, i64* @num_input_events, align 8
  %inc1070 = add i64 %512, 1
  store i64 %inc1070, i64* @num_input_events, align 8
  %513 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 123), align 8
  %call1071 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp1072 = icmp eq i64 %513, %call1071
  br i1 %cmp1072, label %if.end.1127, label %land.lhs.true.1074

land.lhs.true.1074:                               ; preds = %if.end.1069
  %514 = load i64, i64* %c, align 8
  %call1075 = call zeroext i1 @help_char_p(i64 %514)
  br i1 %call1075, label %if.then.1077, label %if.end.1127

if.then.1077:                                     ; preds = %land.lhs.true.1074
  %call1079 = call i64 @SPECPDL_INDEX()
  store i64 %call1079, i64* %count1078, align 8
  %call1080 = call i64 @builtin_lisp_symbol(i32 0)
  %call1081 = call i64 @Fcurrent_window_configuration(i64 %call1080)
  %515 = load i64, i64* @help_form_saved_window_configs, align 8
  %call1082 = call i64 @Fcons(i64 %call1081, i64 %515)
  store i64 %call1082, i64* @help_form_saved_window_configs, align 8
  call void @record_unwind_protect_void(void ()* @read_char_help_form_unwind)
  %call1083 = call i64 @builtin_lisp_symbol(i32 517)
  %call1084 = call i64 @call0(i64 %call1083)
  call void @cancel_echoing()
  br label %do.body.1085

do.body.1085:                                     ; preds = %do.cond, %if.then.1077
  %call1086 = call i64 @builtin_lisp_symbol(i32 0)
  %call1087 = call i64 @builtin_lisp_symbol(i32 0)
  %call1088 = call i64 @read_char(i32 0, i64 %call1086, i64 %call1087, i8* null, %struct.timespec* null)
  store i64 %call1088, i64* %c, align 8
  %516 = load i64, i64* %c, align 8
  %and1089 = and i64 %516, 7
  %conv1090 = trunc i64 %and1089 to i32
  %cmp1091 = icmp eq i32 %conv1090, 3
  br i1 %cmp1091, label %land.lhs.true.1093, label %if.end.1111

land.lhs.true.1093:                               ; preds = %do.body.1085
  %517 = load i64, i64* %c, align 8
  %and1094 = and i64 %517, 7
  %conv1095 = trunc i64 %and1094 to i32
  %cmp1096 = icmp eq i32 %conv1095, 3
  br i1 %cmp1096, label %cond.true.1098, label %cond.false.1101

cond.true.1098:                                   ; preds = %land.lhs.true.1093
  %518 = load i64, i64* %c, align 8
  %sub1099 = sub nsw i64 %518, 3
  %519 = inttoptr i64 %sub1099 to i8*
  %520 = bitcast i8* %519 to %struct.Lisp_Cons*
  %car1100 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %520, i32 0, i32 0
  %521 = load i64, i64* %car1100, align 8
  br label %cond.end.1102

cond.false.1101:                                  ; preds = %land.lhs.true.1093
  %522 = load i64, i64* %c, align 8
  br label %cond.end.1102

cond.end.1102:                                    ; preds = %cond.false.1101, %cond.true.1098
  %cond1103 = phi i64 [ %521, %cond.true.1098 ], [ %522, %cond.false.1101 ]
  %call1104 = call i64 @builtin_lisp_symbol(i32 382)
  %call1105 = call i64 @Fget(i64 %cond1103, i64 %call1104)
  %call1106 = call i64 @builtin_lisp_symbol(i32 685)
  %cmp1107 = icmp eq i64 %call1105, %call1106
  br i1 %cmp1107, label %if.then.1109, label %if.end.1111

if.then.1109:                                     ; preds = %cond.end.1102
  %523 = load i64, i64* @help_form_saved_window_configs, align 8
  %call1110 = call i64 @builtin_lisp_symbol(i32 0)
  call void @XSETCAR(i64 %523, i64 %call1110)
  br label %if.end.1111

if.end.1111:                                      ; preds = %if.then.1109, %cond.end.1102, %do.body.1085
  br label %do.cond

do.cond:                                          ; preds = %if.end.1111
  %524 = load i64, i64* %c, align 8
  %call1112 = call zeroext i1 @BUFFERP(i64 %524)
  br i1 %call1112, label %do.body.1085, label %do.end.1113

do.end.1113:                                      ; preds = %do.cond
  %525 = load i64, i64* %count1078, align 8
  %call1114 = call i64 @builtin_lisp_symbol(i32 0)
  %call1115 = call i64 @unbind_to(i64 %525, i64 %call1114)
  call void @redisplay()
  %526 = load i64, i64* %c, align 8
  %cmp1116 = icmp eq i64 %526, 130
  br i1 %cmp1116, label %if.then.1118, label %if.end.1126

if.then.1118:                                     ; preds = %do.end.1113
  call void @cancel_echoing()
  br label %do.body.1119

do.body.1119:                                     ; preds = %do.cond.1123, %if.then.1118
  %call1120 = call i64 @builtin_lisp_symbol(i32 0)
  %call1121 = call i64 @builtin_lisp_symbol(i32 0)
  %call1122 = call i64 @read_char(i32 0, i64 %call1120, i64 %call1121, i8* null, %struct.timespec* null)
  store i64 %call1122, i64* %c, align 8
  br label %do.cond.1123

do.cond.1123:                                     ; preds = %do.body.1119
  %527 = load i64, i64* %c, align 8
  %call1124 = call zeroext i1 @BUFFERP(i64 %527)
  br i1 %call1124, label %do.body.1119, label %do.end.1125

do.end.1125:                                      ; preds = %do.cond.1123
  br label %if.end.1126

if.end.1126:                                      ; preds = %do.end.1125, %do.end.1113
  br label %if.end.1127

if.end.1127:                                      ; preds = %if.end.1126, %land.lhs.true.1074, %if.end.1069
  br label %exit

exit:                                             ; preds = %if.end.1127, %if.then.753, %if.then.741, %if.then.711, %if.then.682, %if.end.463, %if.then.275, %if.then.156
  br label %do.body.1128

do.body.1128:                                     ; preds = %exit
  %528 = load volatile i8, i8* %polling_stopped_here, align 1
  %tobool1129 = trunc i8 %528 to i1
  br i1 %tobool1129, label %if.then.1130, label %if.end.1131

if.then.1130:                                     ; preds = %do.body.1128
  call void @start_polling()
  br label %if.end.1131

if.end.1131:                                      ; preds = %if.then.1130, %do.body.1128
  store volatile i8 0, i8* %polling_stopped_here, align 1
  br label %do.end.1133

do.end.1133:                                      ; preds = %if.end.1131
  %529 = load i8, i8* @input_pending, align 1
  %tobool1134 = trunc i8 %529 to i1
  %frombool1135 = zext i1 %tobool1134 to i8
  store i8 %frombool1135, i8* @input_was_pending, align 1
  %530 = load i64, i64* %c, align 8
  store i64 %530, i64* %retval
  br label %return

return:                                           ; preds = %do.end.1133, %if.then.686, %if.then.660, %if.then.562, %if.end.337, %if.then.270
  %531 = load i64, i64* %retval
  ret i64 %531
}

declare i64 @Faref(i64, i64) #1

declare i64 @make_natnum(i64) #1

; Function Attrs: nounwind uwtable
define zeroext i1 @detect_input_pending_run_timers(i1 zeroext %do_display) #0 {
entry:
  %do_display.addr = alloca i8, align 1
  %old_timers_run = alloca i32, align 4
  %frombool = zext i1 %do_display to i8
  store i8 %frombool, i8* %do_display.addr, align 1
  %0 = load i32, i32* @timers_run, align 4
  store i32 %0, i32* %old_timers_run, align 4
  %1 = load i8, i8* @input_pending, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call zeroext i1 @get_input_pending(i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32, i32* %old_timers_run, align 4
  %3 = load i32, i32* @timers_run, align 4
  %cmp = icmp ne i32 %2, %3
  br i1 %cmp, label %land.lhs.true, label %if.end.3

land.lhs.true:                                    ; preds = %if.end
  %4 = load i8, i8* %do_display.addr, align 1
  %tobool1 = trunc i8 %4 to i1
  br i1 %tobool1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %land.lhs.true
  call void @redisplay_preserve_echo_area(i32 8)
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %land.lhs.true, %if.end
  %5 = load i8, i8* @input_pending, align 1
  %tobool4 = trunc i8 %5 to i1
  ret i1 %tobool4
}

; Function Attrs: nounwind uwtable
define void @swallow_events(i1 zeroext %do_display) #0 {
entry:
  %do_display.addr = alloca i8, align 1
  %old_timers_run = alloca i32, align 4
  %frombool = zext i1 %do_display to i8
  store i8 %frombool, i8* %do_display.addr, align 1
  call void @process_special_events()
  %0 = load i32, i32* @timers_run, align 4
  store i32 %0, i32* %old_timers_run, align 4
  %call = call zeroext i1 @get_input_pending(i32 1)
  %1 = load i8, i8* @input_pending, align 1
  %tobool = trunc i8 %1 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load i32, i32* @timers_run, align 4
  %3 = load i32, i32* %old_timers_run, align 4
  %cmp = icmp ne i32 %2, %3
  br i1 %cmp, label %land.lhs.true.1, label %if.end

land.lhs.true.1:                                  ; preds = %land.lhs.true
  %4 = load i8, i8* %do_display.addr, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.1
  call void @redisplay_preserve_echo_area(i32 7)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.1, %land.lhs.true, %entry
  ret void
}

declare void @redisplay_preserve_echo_area(i32) #1

declare void @redisplay() #1

; Function Attrs: nounwind uwtable
define internal void @echo_dash() #0 {
entry:
  %last_char = alloca i64, align 8
  %prev_char = alloca i64, align 8
  %idx = alloca i64, align 8
  %dash = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 22
  %1 = load i64, i64* %echo_string_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %2, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end.5, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_1 = getelementptr inbounds %struct.kboard, %struct.kboard* %3, i32 0, i32 22
  %4 = load i64, i64* %echo_string_1, align 8
  %call2 = call i64 @SCHARS(i64 %4)
  %cmp3 = icmp eq i64 %call2, 0
  br i1 %cmp3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %land.lhs.true
  br label %return

if.end.5:                                         ; preds = %land.lhs.true, %if.end
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_prompt_ = getelementptr inbounds %struct.kboard, %struct.kboard* %5, i32 0, i32 25
  %6 = load i64, i64* %echo_prompt_, align 8
  %call6 = call zeroext i1 @STRINGP(i64 %6)
  br i1 %call6, label %land.lhs.true.7, label %if.end.14

land.lhs.true.7:                                  ; preds = %if.end.5
  %7 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_prompt_8 = getelementptr inbounds %struct.kboard, %struct.kboard* %7, i32 0, i32 25
  %8 = load i64, i64* %echo_prompt_8, align 8
  %call9 = call i64 @SCHARS(i64 %8)
  %9 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_10 = getelementptr inbounds %struct.kboard, %struct.kboard* %9, i32 0, i32 22
  %10 = load i64, i64* %echo_string_10, align 8
  %call11 = call i64 @SCHARS(i64 %10)
  %cmp12 = icmp eq i64 %call9, %call11
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %land.lhs.true.7
  br label %return

if.end.14:                                        ; preds = %land.lhs.true.7, %if.end.5
  %11 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_15 = getelementptr inbounds %struct.kboard, %struct.kboard* %11, i32 0, i32 22
  %12 = load i64, i64* %echo_string_15, align 8
  %call16 = call i64 @SCHARS(i64 %12)
  %cmp17 = icmp sgt i64 %call16, 1
  br i1 %cmp17, label %if.then.18, label %if.end.36

if.then.18:                                       ; preds = %if.end.14
  %13 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_19 = getelementptr inbounds %struct.kboard, %struct.kboard* %13, i32 0, i32 22
  %14 = load i64, i64* %echo_string_19, align 8
  %call20 = call i64 @SCHARS(i64 %14)
  %sub = sub nsw i64 %call20, 2
  %shl = shl i64 %sub, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %idx, align 8
  %15 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_21 = getelementptr inbounds %struct.kboard, %struct.kboard* %15, i32 0, i32 22
  %16 = load i64, i64* %echo_string_21, align 8
  %17 = load i64, i64* %idx, align 8
  %call22 = call i64 @Faref(i64 %16, i64 %17)
  store i64 %call22, i64* %prev_char, align 8
  %18 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_23 = getelementptr inbounds %struct.kboard, %struct.kboard* %18, i32 0, i32 22
  %19 = load i64, i64* %echo_string_23, align 8
  %call24 = call i64 @SCHARS(i64 %19)
  %sub25 = sub nsw i64 %call24, 1
  %shl26 = shl i64 %sub25, 2
  %add27 = add i64 %shl26, 2
  store i64 %add27, i64* %idx, align 8
  %20 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_28 = getelementptr inbounds %struct.kboard, %struct.kboard* %20, i32 0, i32 22
  %21 = load i64, i64* %echo_string_28, align 8
  %22 = load i64, i64* %idx, align 8
  %call29 = call i64 @Faref(i64 %21, i64 %22)
  store i64 %call29, i64* %last_char, align 8
  %23 = load i64, i64* %last_char, align 8
  %shr = ashr i64 %23, 2
  %cmp30 = icmp eq i64 %shr, 45
  br i1 %cmp30, label %land.lhs.true.31, label %if.end.35

land.lhs.true.31:                                 ; preds = %if.then.18
  %24 = load i64, i64* %prev_char, align 8
  %shr32 = ashr i64 %24, 2
  %cmp33 = icmp ne i64 %shr32, 32
  br i1 %cmp33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %land.lhs.true.31
  br label %return

if.end.35:                                        ; preds = %land.lhs.true.31, %if.then.18
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.end.14
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  store i64 1, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.191, i32 0, i32 0), i8** %data, align 8
  %s37 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %25 = bitcast %struct.Lisp_String* %s37 to i8*
  %call38 = call i64 @make_lisp_ptr(i8* %25, i32 4)
  store i64 %call38, i64* %dash, align 8
  %26 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %27 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_39 = getelementptr inbounds %struct.kboard, %struct.kboard* %27, i32 0, i32 22
  %28 = load i64, i64* %echo_string_39, align 8
  %29 = load i64, i64* %dash, align 8
  %call40 = call i64 @concat2(i64 %28, i64 %29)
  call void @kset_echo_string(%struct.kboard* %26, i64 %call40)
  call void @echo_now()
  br label %return

return:                                           ; preds = %if.end.36, %if.then.34, %if.then.13, %if.then.4, %if.then
  ret void
}

declare i64 @get_keymap(i64, i1 zeroext, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i64 @read_char_minibuf_menu_prompt(i32 %commandflag, i64 %map) #0 {
entry:
  %retval = alloca i64, align 8
  %commandflag.addr = alloca i32, align 4
  %map.addr = alloca i64, align 8
  %name = alloca i64, align 8
  %nlength = alloca i64, align 8
  %width = alloca i64, align 8
  %idx = alloca i64, align 8
  %nobindings = alloca i8, align 1
  %rest = alloca i64, align 8
  %vector = alloca i64, align 8
  %prompt_strings = alloca i64, align 8
  %notfirst = alloca i8, align 1
  %menu_strings = alloca i64, align 8
  %i = alloca i64, align 8
  %obj = alloca i64, align 8
  %orig_defn_macro = alloca i64, align 8
  %elt = alloca i64, align 8
  %event = alloca i64, align 8
  %tem = alloca i64, align 8
  %char_matches = alloca i8, align 1
  %upcased_event = alloca i64, align 8
  %downcased_event = alloca i64, align 8
  %desc = alloca i64, align 8
  %s = alloca i64, align 8
  %selected = alloca i64, align 8
  %radio_yes = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %radio_no = alloca i64, align 8
  %.compoundliteral93 = alloca %union.Aligned_String, align 8
  %check_yes = alloca i64, align 8
  %.compoundliteral101 = alloca %union.Aligned_String, align 8
  %check_no = alloca i64, align 8
  %.compoundliteral109 = alloca %union.Aligned_String, align 8
  %thiswidth = alloca i64, align 8
  store i32 %commandflag, i32* %commandflag.addr, align 4
  store i64 %map, i64* %map.addr, align 8
  %0 = load i64, i64* @selected_frame, align 8
  %call = call zeroext i1 @FRAMEP(i64 %0)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %1, 5
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %3, i32 0, i32 61
  %4 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp = icmp ne %struct.terminal* %4, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %5 = load i64, i64* @selected_frame, align 8
  %sub1 = sub nsw i64 %5, 5
  %6 = inttoptr i64 %sub1 to i8*
  %7 = bitcast i8* %6 to %struct.frame*
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %cond = phi %struct.frame* [ %7, %cond.true ], [ null, %8 ]
  %text_cols = getelementptr inbounds %struct.frame, %struct.frame* %cond, i32 0, i32 36
  %9 = load i32, i32* %text_cols, align 4
  %sub2 = sub nsw i32 %9, 4
  %conv = sext i32 %sub2 to i64
  store i64 %conv, i64* %width, align 8
  store i64 -1, i64* %idx, align 8
  store i8 1, i8* %nobindings, align 1
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call3, i64* %prompt_strings, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4, i64* %vector, align 8
  %10 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 469), align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %11 = load i64, i64* %map.addr, align 8
  %call6 = call i64 @get_keymap(i64 %11, i1 zeroext false, i1 zeroext true)
  store i64 %call6, i64* %map.addr, align 8
  %12 = load i64, i64* %map.addr, align 8
  %call7 = call i64 @Fkeymap_prompt(i64 %12)
  store i64 %call7, i64* %name, align 8
  %13 = load i64, i64* %name, align 8
  %call8 = call zeroext i1 @STRINGP(i64 %13)
  br i1 %call8, label %if.end.11, label %if.then.9

if.then.9:                                        ; preds = %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* %retval
  br label %return

if.end.11:                                        ; preds = %if.end
  %14 = load i64, i64* %name, align 8
  %15 = load i64, i64* %prompt_strings, align 8
  %call12 = call i64 @Fcons(i64 %14, i64 %15)
  store i64 %call12, i64* %prompt_strings, align 8
  %call13 = call i64 @build_unibyte_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.379, i32 0, i32 0))
  %16 = load i64, i64* %prompt_strings, align 8
  %call14 = call i64 @Fcons(i64 %call13, i64 %16)
  store i64 %call14, i64* %prompt_strings, align 8
  %17 = load i64, i64* %name, align 8
  %call15 = call i64 @SCHARS(i64 %17)
  %add = add nsw i64 %call15, 2
  store i64 %add, i64* %nlength, align 8
  %18 = load i64, i64* %map.addr, align 8
  store i64 %18, i64* %rest, align 8
  br label %while.body

while.body:                                       ; preds = %if.end.11, %if.end.259
  store i8 0, i8* %notfirst, align 1
  %19 = load i64, i64* %prompt_strings, align 8
  store i64 %19, i64* %menu_strings, align 8
  %20 = load i64, i64* %nlength, align 8
  store i64 %20, i64* %i, align 8
  br label %while.cond.16

while.cond.16:                                    ; preds = %if.end.218, %while.body
  %21 = load i64, i64* %i, align 8
  %22 = load i64, i64* %width, align 8
  %cmp17 = icmp slt i64 %21, %22
  br i1 %cmp17, label %while.body.19, label %while.end

while.body.19:                                    ; preds = %while.cond.16
  %23 = load i64, i64* %rest, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %23, %call20
  br i1 %cmp21, label %if.then.23, label %if.end.30

if.then.23:                                       ; preds = %while.body.19
  %24 = load i8, i8* %notfirst, align 1
  %tobool24 = trunc i8 %24 to i1
  br i1 %tobool24, label %if.then.28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.23
  %25 = load i8, i8* %nobindings, align 1
  %tobool26 = trunc i8 %25 to i1
  br i1 %tobool26, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %lor.lhs.false, %if.then.23
  br label %while.end

if.else:                                          ; preds = %lor.lhs.false
  %26 = load i64, i64* %map.addr, align 8
  store i64 %26, i64* %rest, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %while.body.19
  %27 = load i64, i64* %idx, align 8
  %cmp31 = icmp sge i64 %27, 0
  br i1 %cmp31, label %if.then.33, label %if.else.35

if.then.33:                                       ; preds = %if.end.30
  %28 = load i64, i64* %vector, align 8
  %29 = load i64, i64* %idx, align 8
  %call34 = call i64 @AREF(i64 %28, i64 %29)
  store i64 %call34, i64* %elt, align 8
  br label %if.end.37

if.else.35:                                       ; preds = %if.end.30
  %30 = load i64, i64* %rest, align 8
  %call36 = call i64 @Fcar_safe(i64 %30)
  store i64 %call36, i64* %elt, align 8
  br label %if.end.37

if.end.37:                                        ; preds = %if.else.35, %if.then.33
  %31 = load i64, i64* %idx, align 8
  %cmp38 = icmp slt i64 %31, 0
  br i1 %cmp38, label %land.lhs.true.40, label %if.else.45

land.lhs.true.40:                                 ; preds = %if.end.37
  %32 = load i64, i64* %elt, align 8
  %call41 = call zeroext i1 @VECTORP(i64 %32)
  br i1 %call41, label %if.then.43, label %if.else.45

if.then.43:                                       ; preds = %land.lhs.true.40
  %33 = load i64, i64* %rest, align 8
  %call44 = call i64 @Fcdr_safe(i64 %33)
  store i64 %call44, i64* %rest, align 8
  %34 = load i64, i64* %elt, align 8
  store i64 %34, i64* %vector, align 8
  store i64 0, i64* %idx, align 8
  br label %if.end.218

if.else.45:                                       ; preds = %land.lhs.true.40, %if.end.37
  %35 = load i64, i64* %idx, align 8
  %cmp46 = icmp slt i64 %35, 0
  br i1 %cmp46, label %if.then.48, label %if.else.51

if.then.48:                                       ; preds = %if.else.45
  %36 = load i64, i64* %elt, align 8
  %call49 = call i64 @Fcar_safe(i64 %36)
  store i64 %call49, i64* %event, align 8
  %37 = load i64, i64* %elt, align 8
  %call50 = call i64 @Fcdr_safe(i64 %37)
  store i64 %call50, i64* %elt, align 8
  br label %if.end.53

if.else.51:                                       ; preds = %if.else.45
  %38 = load i64, i64* %idx, align 8
  %shl = shl i64 %38, 2
  %add52 = add i64 %shl, 2
  store i64 %add52, i64* %event, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %if.else.51, %if.then.48
  %39 = load i64, i64* %event, align 8
  %and = and i64 %39, 7
  %conv54 = trunc i64 %and to i32
  %and55 = and i32 %conv54, -5
  %cmp56 = icmp eq i32 %and55, 2
  br i1 %cmp56, label %land.lhs.true.58, label %if.end.202

land.lhs.true.58:                                 ; preds = %if.end.53
  %40 = load i64, i64* %elt, align 8
  %call59 = call zeroext i1 @parse_menu_item(i64 %40, i32 -1)
  br i1 %call59, label %if.then.61, label %if.end.202

if.then.61:                                       ; preds = %land.lhs.true.58
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call62, i64* %desc, align 8
  %41 = load i64, i64* @item_properties, align 8
  %call63 = call i64 @AREF(i64 %41, i64 1)
  store i64 %call63, i64* %s, align 8
  %42 = load i64, i64* %event, align 8
  %call64 = call i64 @Fupcase(i64 %42)
  store i64 %call64, i64* %upcased_event, align 8
  %43 = load i64, i64* %event, align 8
  %call65 = call i64 @Fdowncase(i64 %43)
  store i64 %call65, i64* %downcased_event, align 8
  %44 = load i64, i64* %upcased_event, align 8
  %shr = ashr i64 %44, 2
  %45 = load i64, i64* %s, align 8
  %call66 = call zeroext i8 @SREF(i64 %45, i64 0)
  %conv67 = zext i8 %call66 to i64
  %cmp68 = icmp eq i64 %shr, %conv67
  br i1 %cmp68, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then.61
  %46 = load i64, i64* %downcased_event, align 8
  %shr70 = ashr i64 %46, 2
  %47 = load i64, i64* %s, align 8
  %call71 = call zeroext i8 @SREF(i64 %47, i64 0)
  %conv72 = zext i8 %call71 to i64
  %cmp73 = icmp eq i64 %shr70, %conv72
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then.61
  %48 = phi i1 [ true, %if.then.61 ], [ %cmp73, %lor.rhs ]
  %frombool = zext i1 %48 to i8
  store i8 %frombool, i8* %char_matches, align 1
  %49 = load i8, i8* %char_matches, align 1
  %tobool75 = trunc i8 %49 to i1
  br i1 %tobool75, label %if.end.79, label %if.then.76

if.then.76:                                       ; preds = %lor.end
  %50 = load i64, i64* %event, align 8
  %call77 = call i64 @builtin_lisp_symbol(i32 0)
  %call78 = call i64 @Fsingle_key_description(i64 %50, i64 %call77)
  store i64 %call78, i64* %desc, align 8
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.76, %lor.end
  %51 = load i64, i64* @item_properties, align 8
  %call80 = call i64 @AREF(i64 %51, i64 4)
  store i64 %call80, i64* %tem, align 8
  %52 = load i64, i64* %tem, align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 101)
  %cmp82 = icmp eq i64 %52, %call81
  br i1 %cmp82, label %if.then.88, label %lor.lhs.false.84

lor.lhs.false.84:                                 ; preds = %if.end.79
  %53 = load i64, i64* %tem, align 8
  %call85 = call i64 @builtin_lisp_symbol(i32 130)
  %cmp86 = icmp eq i64 %53, %call85
  br i1 %cmp86, label %if.then.88, label %if.end.138

if.then.88:                                       ; preds = %lor.lhs.false.84, %if.end.79
  %54 = load i64, i64* @item_properties, align 8
  %call89 = call i64 @AREF(i64 %54, i64 6)
  store i64 %call89, i64* %selected, align 8
  %s90 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s90, i32 0, i32 0
  store i64 4, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s90, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s90, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s90, i32 0, i32 3
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.380, i32 0, i32 0), i8** %data, align 8
  %s91 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %55 = bitcast %struct.Lisp_String* %s91 to i8*
  %call92 = call i64 @make_lisp_ptr(i8* %55, i32 4)
  store i64 %call92, i64* %radio_yes, align 8
  %s94 = bitcast %union.Aligned_String* %.compoundliteral93 to %struct.Lisp_String*
  %size95 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s94, i32 0, i32 0
  store i64 4, i64* %size95, align 8
  %size_byte96 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s94, i32 0, i32 1
  store i64 -1, i64* %size_byte96, align 8
  %intervals97 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s94, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals97, align 8
  %data98 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s94, i32 0, i32 3
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.381, i32 0, i32 0), i8** %data98, align 8
  %s99 = bitcast %union.Aligned_String* %.compoundliteral93 to %struct.Lisp_String*
  %56 = bitcast %struct.Lisp_String* %s99 to i8*
  %call100 = call i64 @make_lisp_ptr(i8* %56, i32 4)
  store i64 %call100, i64* %radio_no, align 8
  %s102 = bitcast %union.Aligned_String* %.compoundliteral101 to %struct.Lisp_String*
  %size103 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s102, i32 0, i32 0
  store i64 4, i64* %size103, align 8
  %size_byte104 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s102, i32 0, i32 1
  store i64 -1, i64* %size_byte104, align 8
  %intervals105 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s102, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals105, align 8
  %data106 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s102, i32 0, i32 3
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.382, i32 0, i32 0), i8** %data106, align 8
  %s107 = bitcast %union.Aligned_String* %.compoundliteral101 to %struct.Lisp_String*
  %57 = bitcast %struct.Lisp_String* %s107 to i8*
  %call108 = call i64 @make_lisp_ptr(i8* %57, i32 4)
  store i64 %call108, i64* %check_yes, align 8
  %s110 = bitcast %union.Aligned_String* %.compoundliteral109 to %struct.Lisp_String*
  %size111 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s110, i32 0, i32 0
  store i64 4, i64* %size111, align 8
  %size_byte112 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s110, i32 0, i32 1
  store i64 -1, i64* %size_byte112, align 8
  %intervals113 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s110, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals113, align 8
  %data114 = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s110, i32 0, i32 3
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.383, i32 0, i32 0), i8** %data114, align 8
  %s115 = bitcast %union.Aligned_String* %.compoundliteral109 to %struct.Lisp_String*
  %58 = bitcast %struct.Lisp_String* %s115 to i8*
  %call116 = call i64 @make_lisp_ptr(i8* %58, i32 4)
  store i64 %call116, i64* %check_no, align 8
  %59 = load i64, i64* %tem, align 8
  %call117 = call i64 @builtin_lisp_symbol(i32 101)
  %cmp118 = icmp eq i64 %59, %call117
  br i1 %cmp118, label %if.then.120, label %if.else.128

if.then.120:                                      ; preds = %if.then.88
  %60 = load i64, i64* %selected, align 8
  %call121 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp122 = icmp eq i64 %60, %call121
  br i1 %cmp122, label %cond.true.124, label %cond.false.125

cond.true.124:                                    ; preds = %if.then.120
  %61 = load i64, i64* %radio_yes, align 8
  br label %cond.end.126

cond.false.125:                                   ; preds = %if.then.120
  %62 = load i64, i64* %radio_no, align 8
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.125, %cond.true.124
  %cond127 = phi i64 [ %61, %cond.true.124 ], [ %62, %cond.false.125 ]
  store i64 %cond127, i64* %tem, align 8
  br label %if.end.136

if.else.128:                                      ; preds = %if.then.88
  %63 = load i64, i64* %selected, align 8
  %call129 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp130 = icmp eq i64 %63, %call129
  br i1 %cmp130, label %cond.true.132, label %cond.false.133

cond.true.132:                                    ; preds = %if.else.128
  %64 = load i64, i64* %check_yes, align 8
  br label %cond.end.134

cond.false.133:                                   ; preds = %if.else.128
  %65 = load i64, i64* %check_no, align 8
  br label %cond.end.134

cond.end.134:                                     ; preds = %cond.false.133, %cond.true.132
  %cond135 = phi i64 [ %64, %cond.true.132 ], [ %65, %cond.false.133 ]
  store i64 %cond135, i64* %tem, align 8
  br label %if.end.136

if.end.136:                                       ; preds = %cond.end.134, %cond.end.126
  %66 = load i64, i64* %tem, align 8
  %67 = load i64, i64* %s, align 8
  %call137 = call i64 @concat2(i64 %66, i64 %67)
  store i64 %call137, i64* %s, align 8
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.136, %lor.lhs.false.84
  %68 = load i64, i64* %s, align 8
  %call139 = call i64 @SCHARS(i64 %68)
  %69 = load i64, i64* %i, align 8
  %add140 = add nsw i64 %call139, %69
  %add141 = add nsw i64 %add140, 2
  %70 = load i8, i8* %char_matches, align 1
  %tobool142 = trunc i8 %70 to i1
  br i1 %tobool142, label %cond.true.144, label %cond.false.145

cond.true.144:                                    ; preds = %if.end.138
  br label %cond.end.148

cond.false.145:                                   ; preds = %if.end.138
  %71 = load i64, i64* %desc, align 8
  %call146 = call i64 @SCHARS(i64 %71)
  %add147 = add nsw i64 %call146, 3
  br label %cond.end.148

cond.end.148:                                     ; preds = %cond.false.145, %cond.true.144
  %cond149 = phi i64 [ 0, %cond.true.144 ], [ %add147, %cond.false.145 ]
  %add150 = add nsw i64 %add141, %cond149
  %72 = load i64, i64* %width, align 8
  %cmp151 = icmp slt i64 %add150, %72
  br i1 %cmp151, label %if.then.155, label %lor.lhs.false.153

lor.lhs.false.153:                                ; preds = %cond.end.148
  %73 = load i8, i8* %notfirst, align 1
  %tobool154 = trunc i8 %73 to i1
  br i1 %tobool154, label %if.else.198, label %if.then.155

if.then.155:                                      ; preds = %lor.lhs.false.153, %cond.end.148
  %74 = load i8, i8* %notfirst, align 1
  %tobool156 = trunc i8 %74 to i1
  br i1 %tobool156, label %if.then.157, label %if.end.161

if.then.157:                                      ; preds = %if.then.155
  %call158 = call i64 @build_unibyte_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.384, i32 0, i32 0))
  %75 = load i64, i64* %menu_strings, align 8
  %call159 = call i64 @Fcons(i64 %call158, i64 %75)
  store i64 %call159, i64* %menu_strings, align 8
  %76 = load i64, i64* %i, align 8
  %add160 = add nsw i64 %76, 2
  store i64 %add160, i64* %i, align 8
  br label %if.end.161

if.end.161:                                       ; preds = %if.then.157, %if.then.155
  store i8 1, i8* %notfirst, align 1
  store i8 0, i8* %nobindings, align 1
  %77 = load i8, i8* %char_matches, align 1
  %tobool162 = trunc i8 %77 to i1
  br i1 %tobool162, label %if.end.182, label %if.then.163

if.then.163:                                      ; preds = %if.end.161
  %78 = load i64, i64* %desc, align 8
  %call164 = call i64 @SCHARS(i64 %78)
  %79 = load i64, i64* %width, align 8
  %80 = load i64, i64* %i, align 8
  %sub165 = sub nsw i64 %79, %80
  %cmp166 = icmp slt i64 %call164, %sub165
  br i1 %cmp166, label %cond.true.168, label %cond.false.170

cond.true.168:                                    ; preds = %if.then.163
  %81 = load i64, i64* %desc, align 8
  %call169 = call i64 @SCHARS(i64 %81)
  br label %cond.end.172

cond.false.170:                                   ; preds = %if.then.163
  %82 = load i64, i64* %width, align 8
  %83 = load i64, i64* %i, align 8
  %sub171 = sub nsw i64 %82, %83
  br label %cond.end.172

cond.end.172:                                     ; preds = %cond.false.170, %cond.true.168
  %cond173 = phi i64 [ %call169, %cond.true.168 ], [ %sub171, %cond.false.170 ]
  store i64 %cond173, i64* %thiswidth, align 8
  %84 = load i64, i64* %desc, align 8
  %85 = load i64, i64* %thiswidth, align 8
  %shl174 = shl i64 %85, 2
  %add175 = add i64 %shl174, 2
  %call176 = call i64 @Fsubstring(i64 %84, i64 2, i64 %add175)
  %86 = load i64, i64* %menu_strings, align 8
  %call177 = call i64 @Fcons(i64 %call176, i64 %86)
  store i64 %call177, i64* %menu_strings, align 8
  %87 = load i64, i64* %thiswidth, align 8
  %88 = load i64, i64* %i, align 8
  %add178 = add nsw i64 %88, %87
  store i64 %add178, i64* %i, align 8
  %call179 = call i64 @build_unibyte_string(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.385, i32 0, i32 0))
  %89 = load i64, i64* %menu_strings, align 8
  %call180 = call i64 @Fcons(i64 %call179, i64 %89)
  store i64 %call180, i64* %menu_strings, align 8
  %90 = load i64, i64* %i, align 8
  %add181 = add nsw i64 %90, 3
  store i64 %add181, i64* %i, align 8
  br label %if.end.182

if.end.182:                                       ; preds = %cond.end.172, %if.end.161
  %91 = load i64, i64* %s, align 8
  %call183 = call i64 @SCHARS(i64 %91)
  %92 = load i64, i64* %width, align 8
  %93 = load i64, i64* %i, align 8
  %sub184 = sub nsw i64 %92, %93
  %cmp185 = icmp slt i64 %call183, %sub184
  br i1 %cmp185, label %cond.true.187, label %cond.false.189

cond.true.187:                                    ; preds = %if.end.182
  %94 = load i64, i64* %s, align 8
  %call188 = call i64 @SCHARS(i64 %94)
  br label %cond.end.191

cond.false.189:                                   ; preds = %if.end.182
  %95 = load i64, i64* %width, align 8
  %96 = load i64, i64* %i, align 8
  %sub190 = sub nsw i64 %95, %96
  br label %cond.end.191

cond.end.191:                                     ; preds = %cond.false.189, %cond.true.187
  %cond192 = phi i64 [ %call188, %cond.true.187 ], [ %sub190, %cond.false.189 ]
  store i64 %cond192, i64* %thiswidth, align 8
  %97 = load i64, i64* %s, align 8
  %98 = load i64, i64* %thiswidth, align 8
  %shl193 = shl i64 %98, 2
  %add194 = add i64 %shl193, 2
  %call195 = call i64 @Fsubstring(i64 %97, i64 2, i64 %add194)
  %99 = load i64, i64* %menu_strings, align 8
  %call196 = call i64 @Fcons(i64 %call195, i64 %99)
  store i64 %call196, i64* %menu_strings, align 8
  %100 = load i64, i64* %thiswidth, align 8
  %101 = load i64, i64* %i, align 8
  %add197 = add nsw i64 %101, %100
  store i64 %add197, i64* %i, align 8
  br label %if.end.201

if.else.198:                                      ; preds = %lor.lhs.false.153
  %call199 = call i64 @build_unibyte_string(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.386, i32 0, i32 0))
  %102 = load i64, i64* %menu_strings, align 8
  %call200 = call i64 @Fcons(i64 %call199, i64 %102)
  store i64 %call200, i64* %menu_strings, align 8
  br label %while.end

if.end.201:                                       ; preds = %cond.end.191
  br label %if.end.202

if.end.202:                                       ; preds = %if.end.201, %land.lhs.true.58, %if.end.53
  %103 = load i64, i64* %idx, align 8
  %cmp203 = icmp sge i64 %103, 0
  br i1 %cmp203, label %land.lhs.true.205, label %if.end.211

land.lhs.true.205:                                ; preds = %if.end.202
  %104 = load i64, i64* %idx, align 8
  %add206 = add nsw i64 %104, 1
  %105 = load i64, i64* %vector, align 8
  %call207 = call i64 @ASIZE(i64 %105)
  %cmp208 = icmp sge i64 %add206, %call207
  br i1 %cmp208, label %if.then.210, label %if.end.211

if.then.210:                                      ; preds = %land.lhs.true.205
  store i64 -1, i64* %idx, align 8
  br label %if.end.211

if.end.211:                                       ; preds = %if.then.210, %land.lhs.true.205, %if.end.202
  %106 = load i64, i64* %idx, align 8
  %cmp212 = icmp sge i64 %106, 0
  br i1 %cmp212, label %if.then.214, label %if.else.215

if.then.214:                                      ; preds = %if.end.211
  %107 = load i64, i64* %idx, align 8
  %inc = add nsw i64 %107, 1
  store i64 %inc, i64* %idx, align 8
  br label %if.end.217

if.else.215:                                      ; preds = %if.end.211
  %108 = load i64, i64* %rest, align 8
  %call216 = call i64 @Fcdr_safe(i64 %108)
  store i64 %call216, i64* %rest, align 8
  br label %if.end.217

if.end.217:                                       ; preds = %if.else.215, %if.then.214
  br label %if.end.218

if.end.218:                                       ; preds = %if.end.217, %if.then.43
  br label %while.cond.16

while.end:                                        ; preds = %if.else.198, %if.then.28, %while.cond.16
  %call219 = call i64 @intern(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.387, i32 0, i32 0))
  %109 = load i64, i64* %menu_strings, align 8
  %call220 = call i64 @Fnreverse(i64 %109)
  %call221 = call i64 @apply1(i64 %call219, i64 %call220)
  call void @message3_nolog(i64 %call221)
  %110 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %defining_kbd_macro_ = getelementptr inbounds %struct.kboard, %struct.kboard* %110, i32 0, i32 9
  %111 = load i64, i64* %defining_kbd_macro_, align 8
  store i64 %111, i64* %orig_defn_macro, align 8
  %112 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call222 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_defining_kbd_macro(%struct.kboard* %112, i64 %call222)
  br label %do.body

do.body:                                          ; preds = %do.cond, %while.end
  %113 = load i32, i32* %commandflag.addr, align 4
  %call223 = call i64 @builtin_lisp_symbol(i32 0)
  %call224 = call i64 @builtin_lisp_symbol(i32 901)
  %call225 = call i64 @read_char(i32 %113, i64 %call223, i64 %call224, i8* null, %struct.timespec* null)
  store i64 %call225, i64* %obj, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %114 = load i64, i64* %obj, align 8
  %call226 = call zeroext i1 @BUFFERP(i64 %114)
  br i1 %call226, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %115 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %116 = load i64, i64* %orig_defn_macro, align 8
  call void @kset_defining_kbd_macro(%struct.kboard* %115, i64 %116)
  %117 = load i64, i64* %obj, align 8
  %and227 = and i64 %117, 7
  %conv228 = trunc i64 %and227 to i32
  %and229 = and i32 %conv228, -5
  %cmp230 = icmp eq i32 %and229, 2
  br i1 %cmp230, label %lor.lhs.false.232, label %if.then.252

lor.lhs.false.232:                                ; preds = %do.end
  %118 = load i64, i64* %obj, align 8
  %shr233 = ashr i64 %118, 2
  %cmp234 = icmp eq i64 %shr233, -2
  br i1 %cmp234, label %if.then.252, label %lor.lhs.false.236

lor.lhs.false.236:                                ; preds = %lor.lhs.false.232
  %119 = load i64, i64* %obj, align 8
  %120 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 378), align 8
  %cmp237 = icmp eq i64 %119, %120
  br i1 %cmp237, label %if.end.259, label %land.lhs.true.239

land.lhs.true.239:                                ; preds = %lor.lhs.false.236
  %121 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 378), align 8
  %and240 = and i64 %121, 7
  %conv241 = trunc i64 %and240 to i32
  %and242 = and i32 %conv241, -5
  %cmp243 = icmp eq i32 %and242, 2
  br i1 %cmp243, label %lor.lhs.false.245, label %if.then.252

lor.lhs.false.245:                                ; preds = %land.lhs.true.239
  %122 = load i64, i64* %obj, align 8
  %123 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 378), align 8
  %shr246 = ashr i64 %123, 2
  %and247 = and i64 %shr246, 31
  %shl248 = shl i64 %and247, 2
  %add249 = add i64 %shl248, 2
  %cmp250 = icmp eq i64 %122, %add249
  br i1 %cmp250, label %if.end.259, label %if.then.252

if.then.252:                                      ; preds = %lor.lhs.false.245, %land.lhs.true.239, %lor.lhs.false.232, %do.end
  %124 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %defining_kbd_macro_253 = getelementptr inbounds %struct.kboard, %struct.kboard* %124, i32 0, i32 9
  %125 = load i64, i64* %defining_kbd_macro_253, align 8
  %call254 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp255 = icmp eq i64 %125, %call254
  br i1 %cmp255, label %if.end.258, label %if.then.257

if.then.257:                                      ; preds = %if.then.252
  %126 = load i64, i64* %obj, align 8
  call void @store_kbd_macro_char(i64 %126)
  br label %if.end.258

if.end.258:                                       ; preds = %if.then.257, %if.then.252
  %127 = load i64, i64* %obj, align 8
  store i64 %127, i64* %retval
  br label %return

if.end.259:                                       ; preds = %lor.lhs.false.245, %lor.lhs.false.236
  br label %while.body

return:                                           ; preds = %if.end.258, %if.then.9, %if.then
  %128 = load i64, i64* %retval
  ret i64 %128
}

; Function Attrs: nounwind returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) #5

; Function Attrs: nounwind uwtable
define internal void @restore_getcjmp(%struct.__jmp_buf_tag* %temp) #0 {
entry:
  %temp.addr = alloca %struct.__jmp_buf_tag*, align 8
  store %struct.__jmp_buf_tag* %temp, %struct.__jmp_buf_tag** %temp.addr, align 8
  %0 = load %struct.__jmp_buf_tag*, %struct.__jmp_buf_tag** %temp.addr, align 8
  %1 = bitcast %struct.__jmp_buf_tag* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast ([1 x %struct.__jmp_buf_tag]* @getcjmp to i8*), i8* %1, i64 200, i32 8, i1 false)
  ret void
}

; Function Attrs: nounwind
declare i32 @pthread_sigmask(i32, %struct.__sigset_t*, %struct.__sigset_t*) #6

; Function Attrs: nounwind uwtable
define internal void @kset_kbd_queue(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %kbd_queue_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 8
  store i64 %0, i64* %kbd_queue_, align 8
  ret void
}

declare void @XSETCDR(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @timer_start_idle() #0 {
entry:
  %coerce = alloca %struct.timespec, align 8
  %0 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %1 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call = call zeroext i1 @timespec_valid_p(i64 %0, i64 %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call { i64, i64 } @current_timespec()
  %2 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call1, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call1, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.timespec* @timer_idleness_start_time to i8*), i8* %7, i64 16, i32 8, i1 false)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.timespec* @timer_last_idleness_start_time to i8*), i8* bitcast (%struct.timespec* @timer_idleness_start_time to i8*), i64 16, i32 8, i1 false)
  %call2 = call i64 @intern(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.355, i32 0, i32 0))
  %call3 = call i64 @call0(i64 %call2)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @echo_keystrokes_p() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  %call = call double @XFLOAT_DATA(i64 %1)
  %cmp2 = fcmp ogt double %call, 0.000000e+00
  %conv3 = zext i1 %cmp2 to i32
  br label %cond.end.13

cond.false:                                       ; preds = %entry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  %and4 = and i64 %2, 7
  %conv5 = trunc i64 %and4 to i32
  %and6 = and i32 %conv5, -5
  %cmp7 = icmp eq i32 %and6, 2
  br i1 %cmp7, label %cond.true.9, label %cond.false.12

cond.true.9:                                      ; preds = %cond.false
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  %shr = ashr i64 %3, 2
  %cmp10 = icmp sgt i64 %shr, 0
  %conv11 = zext i1 %cmp10 to i32
  br label %cond.end

cond.false.12:                                    ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false.12, %cond.true.9
  %cond = phi i32 [ %conv11, %cond.true.9 ], [ 0, %cond.false.12 ]
  br label %cond.end.13

cond.end.13:                                      ; preds = %cond.end, %cond.true
  %cond14 = phi i32 [ %conv3, %cond.true ], [ %cond, %cond.end ]
  %tobool = icmp ne i32 %cond14, 0
  ret i1 %tobool
}

; Function Attrs: nounwind uwtable
define internal void @save_getcjmp(%struct.__jmp_buf_tag* %temp) #0 {
entry:
  %temp.addr = alloca %struct.__jmp_buf_tag*, align 8
  store %struct.__jmp_buf_tag* %temp, %struct.__jmp_buf_tag** %temp.addr, align 8
  %0 = load %struct.__jmp_buf_tag*, %struct.__jmp_buf_tag** %temp.addr, align 8
  %1 = bitcast %struct.__jmp_buf_tag* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* bitcast ([1 x %struct.__jmp_buf_tag]* @getcjmp to i8*), i64 200, i32 8, i1 false)
  ret void
}

declare i64 @Fdo_auto_save(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @read_char_x_menu_prompt(i64 %map, i64 %prev_event, i8* %used_mouse_menu) #0 {
entry:
  %retval = alloca i64, align 8
  %map.addr = alloca i64, align 8
  %prev_event.addr = alloca i64, align 8
  %used_mouse_menu.addr = alloca i8*, align 8
  %value = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %map, i64* %map.addr, align 8
  store i64 %prev_event, i64* %prev_event.addr, align 8
  store i8* %used_mouse_menu, i8** %used_mouse_menu.addr, align 8
  %0 = load i8*, i8** %used_mouse_menu.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %used_mouse_menu.addr, align 8
  store i8 0, i8* %1, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 469), align 1
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %if.end.3, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i64, i64* %prev_event.addr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.lhs.true, label %if.end.69

land.lhs.true:                                    ; preds = %if.end.3
  %4 = load i64, i64* %prev_event.addr, align 8
  %sub = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 0
  %7 = load i64, i64* %car, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 651)
  %cmp6 = icmp eq i64 %7, %call5
  br i1 %cmp6, label %if.end.69, label %land.lhs.true.8

land.lhs.true.8:                                  ; preds = %land.lhs.true
  %8 = load i64, i64* %prev_event.addr, align 8
  %sub9 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub9 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car10, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 921)
  %cmp12 = icmp eq i64 %11, %call11
  br i1 %cmp12, label %if.end.69, label %if.then.14

if.then.14:                                       ; preds = %land.lhs.true.8
  %12 = load i64, i64* %prev_event.addr, align 8
  %13 = load i64, i64* %map.addr, align 8
  %call15 = call i64 @get_keymap(i64 %13, i1 zeroext false, i1 zeroext true)
  %call16 = call i64 @Fx_popup_menu(i64 %12, i64 %call15)
  store i64 %call16, i64* %value, align 8
  %14 = load i64, i64* %value, align 8
  %and17 = and i64 %14, 7
  %conv18 = trunc i64 %and17 to i32
  %cmp19 = icmp eq i32 %conv18, 3
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %if.then.14
  %15 = load i64, i64* %value, align 8
  %sub22 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub22 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car23 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car23, align 8
  call void @record_menu_key(i64 %18)
  %19 = load i64, i64* %value, align 8
  %sub24 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub24 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %22 = load i64, i64* %cdr, align 8
  store i64 %22, i64* %tem, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.21
  %23 = load i64, i64* %tem, align 8
  %and25 = and i64 %23, 7
  %conv26 = trunc i64 %and25 to i32
  %cmp27 = icmp eq i32 %conv26, 3
  br i1 %cmp27, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load i64, i64* %tem, align 8
  %sub29 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub29 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %car30 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 0
  %27 = load i64, i64* %car30, align 8
  call void @record_menu_key(i64 %27)
  %28 = load i64, i64* %tem, align 8
  %sub31 = sub nsw i64 %28, 3
  %29 = inttoptr i64 %sub31 to i8*
  %30 = bitcast i8* %29 to %struct.Lisp_Cons*
  %car32 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %30, i32 0, i32 0
  %31 = load i64, i64* %car32, align 8
  %and33 = and i64 %31, 7
  %conv34 = trunc i64 %and33 to i32
  %cmp35 = icmp eq i32 %conv34, 0
  br i1 %cmp35, label %if.then.44, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %32 = load i64, i64* %tem, align 8
  %sub37 = sub nsw i64 %32, 3
  %33 = inttoptr i64 %sub37 to i8*
  %34 = bitcast i8* %33 to %struct.Lisp_Cons*
  %car38 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %34, i32 0, i32 0
  %35 = load i64, i64* %car38, align 8
  %and39 = and i64 %35, 7
  %conv40 = trunc i64 %and39 to i32
  %and41 = and i32 %conv40, -5
  %cmp42 = icmp eq i32 %and41, 2
  br i1 %cmp42, label %if.then.44, label %if.end.49

if.then.44:                                       ; preds = %lor.lhs.false, %for.body
  %36 = load i64, i64* %tem, align 8
  %37 = load i64, i64* %tem, align 8
  %sub45 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub45 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car46 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car46, align 8
  %call47 = call i64 @builtin_lisp_symbol(i32 343)
  %call48 = call i64 @Fcons(i64 %40, i64 %call47)
  call void @XSETCAR(i64 %36, i64 %call48)
  br label %if.end.49

if.end.49:                                        ; preds = %if.then.44, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end.49
  %41 = load i64, i64* %tem, align 8
  %sub50 = sub nsw i64 %41, 3
  %42 = inttoptr i64 %sub50 to i8*
  %43 = bitcast i8* %42 to %struct.Lisp_Cons*
  %u51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %43, i32 0, i32 1
  %cdr52 = bitcast %union.anon.12* %u51 to i64*
  %44 = load i64, i64* %cdr52, align 8
  store i64 %44, i64* %tem, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %45 = load i64, i64* %value, align 8
  %sub53 = sub nsw i64 %45, 3
  %46 = inttoptr i64 %sub53 to i8*
  %47 = bitcast i8* %46 to %struct.Lisp_Cons*
  %u54 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %47, i32 0, i32 1
  %cdr55 = bitcast %union.anon.12* %u54 to i64*
  %48 = load i64, i64* %cdr55, align 8
  %49 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %call56 = call i64 @nconc2(i64 %48, i64 %49)
  store i64 %call56, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %50 = load i64, i64* %value, align 8
  %sub57 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub57 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %car58 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 0
  %53 = load i64, i64* %car58, align 8
  store i64 %53, i64* %value, align 8
  br label %if.end.65

if.else:                                          ; preds = %if.then.14
  %54 = load i64, i64* %value, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp60 = icmp eq i64 %54, %call59
  br i1 %cmp60, label %if.then.62, label %if.end.64

if.then.62:                                       ; preds = %if.else
  %call63 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call63, i64* %value, align 8
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.62, %if.else
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %for.end
  %55 = load i8*, i8** %used_mouse_menu.addr, align 8
  %tobool66 = icmp ne i8* %55, null
  br i1 %tobool66, label %if.then.67, label %if.end.68

if.then.67:                                       ; preds = %if.end.65
  %56 = load i8*, i8** %used_mouse_menu.addr, align 8
  store i8 1, i8* %56, align 1
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.67, %if.end.65
  %57 = load i64, i64* %value, align 8
  store i64 %57, i64* %retval
  br label %return

if.end.69:                                        ; preds = %land.lhs.true.8, %land.lhs.true, %if.end.3
  %call70 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call70, i64* %retval
  br label %return

return:                                           ; preds = %if.end.69, %if.end.68, %if.then.2
  %58 = load i64, i64* %retval
  ret i64 %58
}

; Function Attrs: nounwind uwtable
define internal void @timer_stop_idle() #0 {
entry:
  %coerce = alloca %struct.timespec, align 8
  %call = call { i64, i64 } @invalid_timespec()
  %0 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call, 1
  store i64 %4, i64* %3, align 8
  %5 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.timespec* @timer_idleness_start_time to i8*), i8* %5, i64 16, i32 8, i1 false)
  ret void
}

declare void @maybe_gc() #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @readable_events(i32 %flags) #0 {
entry:
  %retval = alloca i1, align 1
  %flags.addr = alloca i32, align 4
  %coerce = alloca %struct.timespec, align 8
  %event = alloca %union.buffered_input_event*, align 8
  %kb = alloca %struct.kboard*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i32, i32* %flags.addr, align 4
  %and = and i32 %0, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call { i64, i64 } @timer_check()
  %1 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %7 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp = icmp ne %union.buffered_input_event* %6, %7
  br i1 %cmp, label %if.then.1, label %if.end.38

if.then.1:                                        ; preds = %if.end
  %8 = load i32, i32* %flags.addr, align 4
  %and2 = and i32 %8, 6
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.then.1
  %9 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %9, %union.buffered_input_event** %event, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then.4
  %10 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %cmp5 = icmp eq %union.buffered_input_event* %10, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %do.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %event, align 8
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.6, %do.body
  %11 = load i32, i32* %flags.addr, align 4
  %and8 = and i32 %11, 2
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %land.lhs.true, label %land.lhs.true.11

land.lhs.true:                                    ; preds = %if.end.7
  %12 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %13 = bitcast %union.buffered_input_event* %12 to i16*
  %bf.load = load i16, i16* %13, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp10 = icmp eq i32 %bf.cast, 22
  br i1 %cmp10, label %if.end.35, label %land.lhs.true.11

land.lhs.true.11:                                 ; preds = %land.lhs.true, %if.end.7
  %14 = load i32, i32* %flags.addr, align 4
  %and12 = and i32 %14, 4
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %land.lhs.true.14, label %land.lhs.true.27

land.lhs.true.14:                                 ; preds = %land.lhs.true.11
  %15 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %16 = bitcast %union.buffered_input_event* %15 to i16*
  %bf.load15 = load i16, i16* %16, align 8
  %bf.cast16 = zext i16 %bf.load15 to i32
  %cmp17 = icmp eq i32 %bf.cast16, 8
  br i1 %cmp17, label %land.lhs.true.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.14
  %17 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %18 = bitcast %union.buffered_input_event* %17 to i16*
  %bf.load18 = load i16, i16* %18, align 8
  %bf.cast19 = zext i16 %bf.load18 to i32
  %cmp20 = icmp eq i32 %bf.cast19, 9
  br i1 %cmp20, label %land.lhs.true.21, label %land.lhs.true.27

land.lhs.true.21:                                 ; preds = %lor.lhs.false, %land.lhs.true.14
  %19 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie = bitcast %union.buffered_input_event* %19 to %struct.input_event*
  %20 = bitcast %struct.input_event* %ie to i32*
  %bf.load22 = load i32, i32* %20, align 8
  %bf.lshr = lshr i32 %bf.load22, 16
  %cmp23 = icmp eq i32 %bf.lshr, 2
  br i1 %cmp23, label %land.lhs.true.24, label %land.lhs.true.27

land.lhs.true.24:                                 ; preds = %land.lhs.true.21
  %21 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie25 = bitcast %union.buffered_input_event* %21 to %struct.input_event*
  %modifiers = getelementptr inbounds %struct.input_event, %struct.input_event* %ie25, i32 0, i32 2
  %22 = load i32, i32* %modifiers, align 4
  %cmp26 = icmp eq i32 %22, 0
  br i1 %cmp26, label %if.end.35, label %land.lhs.true.27

land.lhs.true.27:                                 ; preds = %land.lhs.true.24, %land.lhs.true.21, %lor.lhs.false, %land.lhs.true.11
  %23 = load i32, i32* %flags.addr, align 4
  %and28 = and i32 %23, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %land.lhs.true.30, label %if.then.34

land.lhs.true.30:                                 ; preds = %land.lhs.true.27
  %24 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %25 = bitcast %union.buffered_input_event* %24 to i16*
  %bf.load31 = load i16, i16* %25, align 8
  %bf.cast32 = zext i16 %bf.load31 to i32
  %cmp33 = icmp eq i32 %bf.cast32, 12
  br i1 %cmp33, label %if.end.35, label %if.then.34

if.then.34:                                       ; preds = %land.lhs.true.30, %land.lhs.true.27
  store i1 true, i1* %retval
  br label %return

if.end.35:                                        ; preds = %land.lhs.true.30, %land.lhs.true.24, %land.lhs.true
  %26 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %incdec.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %26, i32 1
  store %union.buffered_input_event* %incdec.ptr, %union.buffered_input_event** %event, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end.35
  %27 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %28 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp36 = icmp ne %union.buffered_input_event* %27, %28
  br i1 %cmp36, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  br label %if.end.37

if.else:                                          ; preds = %if.then.1
  store i1 true, i1* %retval
  br label %return

if.end.37:                                        ; preds = %do.end
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.37, %if.end
  %29 = load i32, i32* %flags.addr, align 4
  %and39 = and i32 %29, 4
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.end.48, label %land.lhs.true.41

land.lhs.true.41:                                 ; preds = %if.end.38
  %30 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp43 = icmp eq i64 %30, %call42
  br i1 %cmp43, label %if.end.48, label %land.lhs.true.44

land.lhs.true.44:                                 ; preds = %land.lhs.true.41
  %call45 = call %struct.frame* @some_mouse_moved()
  %tobool46 = icmp ne %struct.frame* %call45, null
  br i1 %tobool46, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %land.lhs.true.44
  store i1 true, i1* %retval
  br label %return

if.end.48:                                        ; preds = %land.lhs.true.44, %land.lhs.true.41, %if.end.38
  %31 = load i8, i8* @single_kboard, align 1
  %tobool49 = trunc i8 %31 to i1
  br i1 %tobool49, label %if.then.50, label %if.else.54

if.then.50:                                       ; preds = %if.end.48
  %32 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %kbd_queue_has_data = getelementptr inbounds %struct.kboard, %struct.kboard* %32, i32 0, i32 23
  %33 = load i8, i8* %kbd_queue_has_data, align 1
  %tobool51 = trunc i8 %33 to i1
  br i1 %tobool51, label %if.then.52, label %if.end.53

if.then.52:                                       ; preds = %if.then.50
  store i1 true, i1* %retval
  br label %return

if.end.53:                                        ; preds = %if.then.50
  br label %if.end.60

if.else.54:                                       ; preds = %if.end.48
  %34 = load %struct.kboard*, %struct.kboard** @all_kboards, align 8
  store %struct.kboard* %34, %struct.kboard** %kb, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else.54
  %35 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %tobool55 = icmp ne %struct.kboard* %35, null
  br i1 %tobool55, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_has_data56 = getelementptr inbounds %struct.kboard, %struct.kboard* %36, i32 0, i32 23
  %37 = load i8, i8* %kbd_queue_has_data56, align 1
  %tobool57 = trunc i8 %37 to i1
  br i1 %tobool57, label %if.then.58, label %if.end.59

if.then.58:                                       ; preds = %for.body
  store i1 true, i1* %retval
  br label %return

if.end.59:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.59
  %38 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %38, i32 0, i32 0
  %39 = load %struct.kboard*, %struct.kboard** %next_kboard, align 8
  store %struct.kboard* %39, %struct.kboard** %kb, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.60

if.end.60:                                        ; preds = %for.end, %if.end.53
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %if.end.60, %if.then.58, %if.then.52, %if.then.47, %if.else, %if.then.34
  %40 = load i1, i1* %retval
  ret i1 %40
}

declare i64 @Fget(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @read_decoded_event_from_main_queue(%struct.timespec* %end_time, %struct.__jmp_buf_tag* %local_getcjmp, i64 %prev_event, i8* %used_mouse_menu) #0 {
entry:
  %retval = alloca i64, align 8
  %end_time.addr = alloca %struct.timespec*, align 8
  %local_getcjmp.addr = alloca %struct.__jmp_buf_tag*, align 8
  %prev_event.addr = alloca i64, align 8
  %used_mouse_menu.addr = alloca i8*, align 8
  %events = alloca [16 x i64], align 16
  %n = alloca i32, align 4
  %nextevt = alloca i64, align 8
  %frame = alloca %struct.frame*, align 8
  %terminal = alloca %struct.terminal*, align 8
  %meta_key = alloca i32, align 4
  %coding = alloca %struct.coding_system*, align 8
  %i = alloca i32, align 4
  %src = alloca [16 x i8], align 16
  %dest = alloca [80 x i8], align 16
  %i30 = alloca i32, align 4
  %p = alloca i8*, align 8
  store %struct.timespec* %end_time, %struct.timespec** %end_time.addr, align 8
  store %struct.__jmp_buf_tag* %local_getcjmp, %struct.__jmp_buf_tag** %local_getcjmp.addr, align 8
  store i64 %prev_event, i64* %prev_event.addr, align 8
  store i8* %used_mouse_menu, i8** %used_mouse_menu.addr, align 8
  store i32 0, i32* %n, align 4
  br label %while.body

while.body:                                       ; preds = %entry, %if.then.71
  %0 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %1 = load %struct.__jmp_buf_tag*, %struct.__jmp_buf_tag** %local_getcjmp.addr, align 8
  %2 = load i8*, i8** %used_mouse_menu.addr, align 8
  %call = call i64 @read_event_from_main_queue(%struct.timespec* %0, %struct.__jmp_buf_tag* %1, i8* %2)
  store i64 %call, i64* %nextevt, align 8
  %3 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %3, 5
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.frame*
  store %struct.frame* %5, %struct.frame** %frame, align 8
  %6 = load %struct.frame*, %struct.frame** %frame, align 8
  %terminal1 = getelementptr inbounds %struct.frame, %struct.frame* %6, i32 0, i32 61
  %7 = load %struct.terminal*, %struct.terminal** %terminal1, align 8
  store %struct.terminal* %7, %struct.terminal** %terminal, align 8
  %8 = load %struct.frame*, %struct.frame** %frame, align 8
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %8, i32 0, i32 26
  %9 = bitcast i48* %output_method to i64*
  %bf.load = load i64, i64* %9, align 8
  %bf.lshr = lshr i64 %bf.load, 23
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %while.body
  %10 = load i64, i64* %prev_event.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp3 = icmp eq i64 %10, %call2
  br i1 %cmp3, label %if.then, label %land.lhs.true.4

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %11 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %keyboard_coding = getelementptr inbounds %struct.terminal, %struct.terminal* %11, i32 0, i32 14
  %12 = load %struct.coding_system*, %struct.coding_system** %keyboard_coding, align 8
  %common_flags = getelementptr inbounds %struct.coding_system, %struct.coding_system* %12, i32 0, i32 1
  %bf.load5 = load i32, i32* %common_flags, align 8
  %bf.clear6 = and i32 %bf.load5, 16383
  %and = and i32 %bf.clear6, 1024
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true.4, %land.lhs.true, %while.body
  %13 = load i64, i64* %nextevt, align 8
  store i64 %13, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true.4
  %14 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %14, i32 0, i32 12
  %tty = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %15 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key7 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %15, i32 0, i32 73
  %16 = load i32, i32* %meta_key7, align 4
  store i32 %16, i32* %meta_key, align 4
  %17 = load i64, i64* %nextevt, align 8
  %18 = load i32, i32* %n, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %n, align 4
  %idxprom = sext i32 %18 to i64
  %arrayidx = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom
  store i64 %17, i64* %arrayidx, align 8
  %19 = load i64, i64* %nextevt, align 8
  %call8 = call zeroext i1 @NATNUMP(i64 %19)
  br i1 %call8, label %land.lhs.true.9, label %if.end.139

land.lhs.true.9:                                  ; preds = %if.else
  %20 = load i64, i64* %nextevt, align 8
  %shr = ashr i64 %20, 2
  %21 = load i32, i32* %meta_key, align 4
  %cmp10 = icmp eq i32 %21, 1
  %cond = select i1 %cmp10, i32 128, i32 256
  %conv = sext i32 %cond to i64
  %cmp11 = icmp slt i64 %shr, %conv
  br i1 %cmp11, label %if.then.13, label %if.end.139

if.then.13:                                       ; preds = %land.lhs.true.9
  %22 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %keyboard_coding14 = getelementptr inbounds %struct.terminal, %struct.terminal* %22, i32 0, i32 14
  %23 = load %struct.coding_system*, %struct.coding_system** %keyboard_coding14, align 8
  store %struct.coding_system* %23, %struct.coding_system** %coding, align 8
  %24 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %call15 = call zeroext i1 @raw_text_coding_system_p(%struct.coding_system* %24)
  br i1 %call15, label %if.then.16, label %if.else.29

if.then.16:                                       ; preds = %if.then.13
  %25 = load i32, i32* %meta_key, align 4
  %cmp17 = icmp ne i32 %25, 2
  br i1 %cmp17, label %if.then.19, label %if.end

if.then.19:                                       ; preds = %if.then.16
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.19
  %26 = load i32, i32* %i, align 4
  %27 = load i32, i32* %n, align 4
  %cmp20 = icmp slt i32 %26, %27
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %28 = load i32, i32* %i, align 4
  %idxprom22 = sext i32 %28 to i64
  %arrayidx23 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom22
  %29 = load i64, i64* %arrayidx23, align 8
  %shr24 = ashr i64 %29, 2
  %and25 = and i64 %shr24, -129
  %shl = shl i64 %and25, 2
  %add = add i64 %shl, 2
  %30 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %30 to i64
  %arrayidx27 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom26
  store i64 %add, i64* %arrayidx27, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %31 = load i32, i32* %i, align 4
  %inc28 = add nsw i32 %31, 1
  store i32 %inc28, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.then.16
  br label %if.end.138

if.else.29:                                       ; preds = %if.then.13
  store i32 0, i32* %i30, align 4
  br label %for.cond.31

for.cond.31:                                      ; preds = %for.inc.41, %if.else.29
  %32 = load i32, i32* %i30, align 4
  %33 = load i32, i32* %n, align 4
  %cmp32 = icmp slt i32 %32, %33
  br i1 %cmp32, label %for.body.34, label %for.end.43

for.body.34:                                      ; preds = %for.cond.31
  %34 = load i32, i32* %i30, align 4
  %idxprom35 = sext i32 %34 to i64
  %arrayidx36 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom35
  %35 = load i64, i64* %arrayidx36, align 8
  %shr37 = ashr i64 %35, 2
  %conv38 = trunc i64 %shr37 to i8
  %36 = load i32, i32* %i30, align 4
  %idxprom39 = sext i32 %36 to i64
  %arrayidx40 = getelementptr inbounds [16 x i8], [16 x i8]* %src, i32 0, i64 %idxprom39
  store i8 %conv38, i8* %arrayidx40, align 1
  br label %for.inc.41

for.inc.41:                                       ; preds = %for.body.34
  %37 = load i32, i32* %i30, align 4
  %inc42 = add nsw i32 %37, 1
  store i32 %inc42, i32* %i30, align 4
  br label %for.cond.31

for.end.43:                                       ; preds = %for.cond.31
  %38 = load i32, i32* %meta_key, align 4
  %cmp44 = icmp ne i32 %38, 2
  br i1 %cmp44, label %if.then.46, label %if.end.59

if.then.46:                                       ; preds = %for.end.43
  store i32 0, i32* %i30, align 4
  br label %for.cond.47

for.cond.47:                                      ; preds = %for.inc.56, %if.then.46
  %39 = load i32, i32* %i30, align 4
  %40 = load i32, i32* %n, align 4
  %cmp48 = icmp slt i32 %39, %40
  br i1 %cmp48, label %for.body.50, label %for.end.58

for.body.50:                                      ; preds = %for.cond.47
  %41 = load i32, i32* %i30, align 4
  %idxprom51 = sext i32 %41 to i64
  %arrayidx52 = getelementptr inbounds [16 x i8], [16 x i8]* %src, i32 0, i64 %idxprom51
  %42 = load i8, i8* %arrayidx52, align 1
  %conv53 = zext i8 %42 to i32
  %and54 = and i32 %conv53, -129
  %conv55 = trunc i32 %and54 to i8
  store i8 %conv55, i8* %arrayidx52, align 1
  br label %for.inc.56

for.inc.56:                                       ; preds = %for.body.50
  %43 = load i32, i32* %i30, align 4
  %inc57 = add nsw i32 %43, 1
  store i32 %inc57, i32* %i30, align 4
  br label %for.cond.47

for.end.58:                                       ; preds = %for.cond.47
  br label %if.end.59

if.end.59:                                        ; preds = %for.end.58, %for.end.43
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %dest, i32 0, i32 0
  %44 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %destination = getelementptr inbounds %struct.coding_system, %struct.coding_system* %44, i32 0, i32 22
  store i8* %arraydecay, i8** %destination, align 8
  %45 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %dst_bytes = getelementptr inbounds %struct.coding_system, %struct.coding_system* %45, i32 0, i32 20
  store i64 80, i64* %dst_bytes, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.59
  %arraydecay60 = getelementptr inbounds [16 x i8], [16 x i8]* %src, i32 0, i32 0
  %46 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %source = getelementptr inbounds %struct.coding_system, %struct.coding_system* %46, i32 0, i32 17
  store i8* %arraydecay60, i8** %source, align 8
  %47 = load i32, i32* %n, align 4
  %conv61 = sext i32 %47 to i64
  %48 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_bytes = getelementptr inbounds %struct.coding_system, %struct.coding_system* %48, i32 0, i32 15
  store i64 %conv61, i64* %src_bytes, align 8
  %49 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %src_chars = getelementptr inbounds %struct.coding_system, %struct.coding_system* %49, i32 0, i32 14
  store i64 %conv61, i64* %src_chars, align 8
  %50 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  %51 = load i32, i32* %n, align 4
  %conv63 = sext i32 %51 to i64
  %52 = load i32, i32* %n, align 4
  %conv64 = sext i32 %52 to i64
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  call void @decode_coding_object(%struct.coding_system* %50, i64 %call62, i64 0, i64 0, i64 %conv63, i64 %conv64, i64 %call65)
  br label %do.end

do.end:                                           ; preds = %do.body
  %53 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %produced_char = getelementptr inbounds %struct.coding_system, %struct.coding_system* %53, i32 0, i32 9
  %54 = load i64, i64* %produced_char, align 8
  %cmp66 = icmp eq i64 %54, 0
  br i1 %cmp66, label %if.then.68, label %if.else.73

if.then.68:                                       ; preds = %do.end
  %55 = load i32, i32* %n, align 4
  %cmp69 = icmp slt i32 %55, 16
  br i1 %cmp69, label %if.then.71, label %if.end.72

if.then.71:                                       ; preds = %if.then.68
  br label %while.body

if.end.72:                                        ; preds = %if.then.68
  br label %if.end.137

if.else.73:                                       ; preds = %do.end
  %56 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %destination74 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %56, i32 0, i32 22
  %57 = load i8*, i8** %destination74, align 8
  store i8* %57, i8** %p, align 8
  store i32 0, i32* %n, align 4
  br label %while.cond.75

while.cond.75:                                    ; preds = %cond.end.129, %if.else.73
  %58 = load i32, i32* %n, align 4
  %conv76 = sext i32 %58 to i64
  %59 = load %struct.coding_system*, %struct.coding_system** %coding, align 8
  %produced_char77 = getelementptr inbounds %struct.coding_system, %struct.coding_system* %59, i32 0, i32 9
  %60 = load i64, i64* %produced_char77, align 8
  %cmp78 = icmp slt i64 %conv76, %60
  br i1 %cmp78, label %while.body.80, label %while.end

while.body.80:                                    ; preds = %while.cond.75
  %61 = load i8*, i8** %p, align 8
  %arrayidx81 = getelementptr inbounds i8, i8* %61, i64 0
  %62 = load i8, i8* %arrayidx81, align 1
  %conv82 = zext i8 %62 to i32
  %and83 = and i32 %conv82, 128
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body.80
  %63 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %63, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %64 = load i8, i8* %63, align 1
  %conv85 = zext i8 %64 to i32
  br label %cond.end.129

cond.false:                                       ; preds = %while.body.80
  %65 = load i8*, i8** %p, align 8
  %arrayidx86 = getelementptr inbounds i8, i8* %65, i64 0
  %66 = load i8, i8* %arrayidx86, align 1
  %conv87 = zext i8 %66 to i32
  %and88 = and i32 %conv87, 32
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %cond.false.104, label %cond.true.90

cond.true.90:                                     ; preds = %cond.false
  %67 = load i8*, i8** %p, align 8
  %add.ptr = getelementptr inbounds i8, i8* %67, i64 2
  store i8* %add.ptr, i8** %p, align 8
  %68 = load i8*, i8** %p, align 8
  %arrayidx91 = getelementptr inbounds i8, i8* %68, i64 -2
  %69 = load i8, i8* %arrayidx91, align 1
  %conv92 = zext i8 %69 to i32
  %and93 = and i32 %conv92, 31
  %shl94 = shl i32 %and93, 6
  %70 = load i8*, i8** %p, align 8
  %arrayidx95 = getelementptr inbounds i8, i8* %70, i64 -1
  %71 = load i8, i8* %arrayidx95, align 1
  %conv96 = zext i8 %71 to i32
  %and97 = and i32 %conv96, 63
  %or = or i32 %shl94, %and97
  %72 = load i8*, i8** %p, align 8
  %arrayidx98 = getelementptr inbounds i8, i8* %72, i64 -2
  %73 = load i8, i8* %arrayidx98, align 1
  %conv99 = zext i8 %73 to i32
  %cmp100 = icmp slt i32 %conv99, 194
  %cond102 = select i1 %cmp100, i32 4194176, i32 0
  %or103 = or i32 %or, %cond102
  br label %cond.end.127

cond.false.104:                                   ; preds = %cond.false
  %74 = load i8*, i8** %p, align 8
  %arrayidx105 = getelementptr inbounds i8, i8* %74, i64 0
  %75 = load i8, i8* %arrayidx105, align 1
  %conv106 = zext i8 %75 to i32
  %and107 = and i32 %conv106, 16
  %tobool108 = icmp ne i32 %and107, 0
  br i1 %tobool108, label %cond.false.124, label %cond.true.109

cond.true.109:                                    ; preds = %cond.false.104
  %76 = load i8*, i8** %p, align 8
  %add.ptr110 = getelementptr inbounds i8, i8* %76, i64 3
  store i8* %add.ptr110, i8** %p, align 8
  %77 = load i8*, i8** %p, align 8
  %arrayidx111 = getelementptr inbounds i8, i8* %77, i64 -3
  %78 = load i8, i8* %arrayidx111, align 1
  %conv112 = zext i8 %78 to i32
  %and113 = and i32 %conv112, 15
  %shl114 = shl i32 %and113, 12
  %79 = load i8*, i8** %p, align 8
  %arrayidx115 = getelementptr inbounds i8, i8* %79, i64 -2
  %80 = load i8, i8* %arrayidx115, align 1
  %conv116 = zext i8 %80 to i32
  %and117 = and i32 %conv116, 63
  %shl118 = shl i32 %and117, 6
  %or119 = or i32 %shl114, %shl118
  %81 = load i8*, i8** %p, align 8
  %arrayidx120 = getelementptr inbounds i8, i8* %81, i64 -1
  %82 = load i8, i8* %arrayidx120, align 1
  %conv121 = zext i8 %82 to i32
  %and122 = and i32 %conv121, 63
  %or123 = or i32 %or119, %and122
  br label %cond.end

cond.false.124:                                   ; preds = %cond.false.104
  %83 = load i8*, i8** %p, align 8
  %call125 = call i32 @string_char(i8* %83, i8** %p, i32* null)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.124, %cond.true.109
  %cond126 = phi i32 [ %or123, %cond.true.109 ], [ %call125, %cond.false.124 ]
  br label %cond.end.127

cond.end.127:                                     ; preds = %cond.end, %cond.true.90
  %cond128 = phi i32 [ %or103, %cond.true.90 ], [ %cond126, %cond.end ]
  br label %cond.end.129

cond.end.129:                                     ; preds = %cond.end.127, %cond.true
  %cond130 = phi i32 [ %conv85, %cond.true ], [ %cond128, %cond.end.127 ]
  %conv131 = sext i32 %cond130 to i64
  %shl132 = shl i64 %conv131, 2
  %add133 = add i64 %shl132, 2
  %84 = load i32, i32* %n, align 4
  %inc134 = add nsw i32 %84, 1
  store i32 %inc134, i32* %n, align 4
  %idxprom135 = sext i32 %84 to i64
  %arrayidx136 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom135
  store i64 %add133, i64* %arrayidx136, align 8
  br label %while.cond.75

while.end:                                        ; preds = %while.cond.75
  br label %if.end.137

if.end.137:                                       ; preds = %while.end, %if.end.72
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137, %if.end
  br label %if.end.139

if.end.139:                                       ; preds = %if.end.138, %land.lhs.true.9, %if.else
  br label %while.cond.140

while.cond.140:                                   ; preds = %while.body.143, %if.end.139
  %85 = load i32, i32* %n, align 4
  %cmp141 = icmp sgt i32 %85, 1
  br i1 %cmp141, label %while.body.143, label %while.end.147

while.body.143:                                   ; preds = %while.cond.140
  %86 = load i32, i32* %n, align 4
  %dec = add nsw i32 %86, -1
  store i32 %dec, i32* %n, align 4
  %idxprom144 = sext i32 %dec to i64
  %arrayidx145 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 %idxprom144
  %87 = load i64, i64* %arrayidx145, align 8
  %88 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %call146 = call i64 @Fcons(i64 %87, i64 %88)
  store i64 %call146, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  br label %while.cond.140

while.end.147:                                    ; preds = %while.cond.140
  %arrayidx148 = getelementptr inbounds [16 x i64], [16 x i64]* %events, i32 0, i64 0
  %89 = load i64, i64* %arrayidx148, align 8
  store i64 %89, i64* %retval
  br label %return

return:                                           ; preds = %while.end.147, %if.then
  %90 = load i64, i64* %retval
  ret i64 %90
}

; Function Attrs: nounwind readonly
declare i32 @timespec_cmp(i64, i64, i64, i64) #7

declare { i64, i64 } @current_timespec() #1

declare zeroext i1 @BUFFERP(i64) #1

declare i64 @access_keymap(i64, i64, i1 zeroext, i1 zeroext, i1 zeroext) #1

declare i64 @call4(i64, i64, i64, i64, i64) #1

declare i64 @Fvector(i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal void @timer_resume_idle() #0 {
entry:
  %0 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %1 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call = call zeroext i1 @timespec_valid_p(i64 %0, i64 %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.timespec* @timer_idleness_start_time to i8*), i8* bitcast (%struct.timespec* @timer_last_idleness_start_time to i8*), i64 16, i32 8, i1 false)
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare i64 @SCHARS(i64) #1

declare zeroext i1 @VECTORP(i64) #1

declare i64 @ASIZE(i64) #1

declare zeroext i1 @CHAR_TABLE_P(i64) #1

declare zeroext i1 @NATNUMP(i64) #1

declare i64 @CDR_SAFE(i64) #1

declare void @XSETCAR(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @record_char(i64 %c) #0 {
entry:
  %c.addr = alloca i64, align 8
  %recorded = alloca i32, align 4
  %ev1 = alloca i64, align 8
  %ev2 = alloca i64, align 8
  %ev3 = alloca i64, align 8
  %ix1 = alloca i32, align 4
  %ix2 = alloca i32, align 4
  %ix3 = alloca i32, align 4
  %help = alloca i64, align 8
  %last_help = alloca i64, align 8
  %last_window = alloca i64, align 8
  %window = alloca i64, align 8
  %dribblee = alloca i64, align 8
  store i64 %c, i64* %c.addr, align 8
  store i32 0, i32* %recorded, align 4
  %0 = load i64, i64* %c.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.lhs.true, label %if.else.190

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %c.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call = call i64 @builtin_lisp_symbol(i32 516)
  %cmp2 = icmp eq i64 %4, %call
  br i1 %cmp2, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load i64, i64* %c.addr, align 8
  %sub4 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub4 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car5 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car5, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp7 = icmp eq i64 %8, %call6
  br i1 %cmp7, label %if.then, label %if.else.190

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %9 = load i32, i32* @recent_keys_index, align 4
  %sub9 = sub nsw i32 %9, 1
  store i32 %sub9, i32* %ix1, align 4
  %cmp10 = icmp slt i32 %sub9, 0
  br i1 %cmp10, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then
  store i32 299, i32* %ix1, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then
  %10 = load i64, i64* @recent_keys, align 8
  %11 = load i32, i32* %ix1, align 4
  %conv13 = sext i32 %11 to i64
  %call14 = call i64 @AREF(i64 %10, i64 %conv13)
  store i64 %call14, i64* %ev1, align 8
  %12 = load i32, i32* %ix1, align 4
  %sub15 = sub nsw i32 %12, 1
  store i32 %sub15, i32* %ix2, align 4
  %cmp16 = icmp slt i32 %sub15, 0
  br i1 %cmp16, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %if.end
  store i32 299, i32* %ix2, align 4
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.18, %if.end
  %13 = load i64, i64* @recent_keys, align 8
  %14 = load i32, i32* %ix2, align 4
  %conv20 = sext i32 %14 to i64
  %call21 = call i64 @AREF(i64 %13, i64 %conv20)
  store i64 %call21, i64* %ev2, align 8
  %15 = load i32, i32* %ix2, align 4
  %sub22 = sub nsw i32 %15, 1
  store i32 %sub22, i32* %ix3, align 4
  %cmp23 = icmp slt i32 %sub22, 0
  br i1 %cmp23, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %if.end.19
  store i32 299, i32* %ix3, align 4
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.25, %if.end.19
  %16 = load i64, i64* @recent_keys, align 8
  %17 = load i32, i32* %ix3, align 4
  %conv27 = sext i32 %17 to i64
  %call28 = call i64 @AREF(i64 %16, i64 %conv27)
  store i64 %call28, i64* %ev3, align 8
  %18 = load i64, i64* %c.addr, align 8
  %sub29 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub29 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %car30 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 0
  %21 = load i64, i64* %car30, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 516)
  %cmp32 = icmp eq i64 %21, %call31
  br i1 %cmp32, label %if.then.34, label %if.else.136

if.then.34:                                       ; preds = %if.end.26
  %22 = load i64, i64* %c.addr, align 8
  %sub35 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub35 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %25 = load i64, i64* %cdr, align 8
  %call36 = call i64 @Fcdr_safe(i64 %25)
  %call37 = call i64 @Fcar_safe(i64 %call36)
  store i64 %call37, i64* %help, align 8
  %26 = load i64, i64* %help, align 8
  %call38 = call zeroext i1 @STRINGP(i64 %26)
  br i1 %call38, label %if.else, label %if.then.39

if.then.39:                                       ; preds = %if.then.34
  store i32 1, i32* %recorded, align 4
  br label %if.end.135

if.else:                                          ; preds = %if.then.34
  %27 = load i64, i64* %ev1, align 8
  %and40 = and i64 %27, 7
  %conv41 = trunc i64 %and40 to i32
  %cmp42 = icmp eq i32 %conv41, 3
  br i1 %cmp42, label %land.lhs.true.44, label %if.else.59

land.lhs.true.44:                                 ; preds = %if.else
  %28 = load i64, i64* %ev1, align 8
  %sub45 = sub nsw i64 %28, 3
  %29 = inttoptr i64 %sub45 to i8*
  %30 = bitcast i8* %29 to %struct.Lisp_Cons*
  %car46 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %30, i32 0, i32 0
  %31 = load i64, i64* %car46, align 8
  %call47 = call i64 @builtin_lisp_symbol(i32 516)
  %cmp48 = icmp eq i64 %31, %call47
  br i1 %cmp48, label %land.lhs.true.50, label %if.else.59

land.lhs.true.50:                                 ; preds = %land.lhs.true.44
  %32 = load i64, i64* %ev1, align 8
  %sub51 = sub nsw i64 %32, 3
  %33 = inttoptr i64 %sub51 to i8*
  %34 = bitcast i8* %33 to %struct.Lisp_Cons*
  %u52 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %34, i32 0, i32 1
  %cdr53 = bitcast %union.anon.12* %u52 to i64*
  %35 = load i64, i64* %cdr53, align 8
  %call54 = call i64 @Fcdr_safe(i64 %35)
  %call55 = call i64 @Fcar_safe(i64 %call54)
  store i64 %call55, i64* %last_help, align 8
  %36 = load i64, i64* %last_help, align 8
  %37 = load i64, i64* %help, align 8
  %cmp56 = icmp eq i64 %36, %37
  br i1 %cmp56, label %if.then.58, label %if.else.59

if.then.58:                                       ; preds = %land.lhs.true.50
  store i32 1, i32* %recorded, align 4
  br label %if.end.134

if.else.59:                                       ; preds = %land.lhs.true.50, %land.lhs.true.44, %if.else
  %38 = load i64, i64* %ev1, align 8
  %and60 = and i64 %38, 7
  %conv61 = trunc i64 %and60 to i32
  %cmp62 = icmp eq i32 %conv61, 3
  br i1 %cmp62, label %land.lhs.true.64, label %if.else.90

land.lhs.true.64:                                 ; preds = %if.else.59
  %39 = load i64, i64* %ev1, align 8
  %sub65 = sub nsw i64 %39, 3
  %40 = inttoptr i64 %sub65 to i8*
  %41 = bitcast i8* %40 to %struct.Lisp_Cons*
  %car66 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %41, i32 0, i32 0
  %42 = load i64, i64* %car66, align 8
  %call67 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp68 = icmp eq i64 %42, %call67
  br i1 %cmp68, label %land.lhs.true.70, label %if.else.90

land.lhs.true.70:                                 ; preds = %land.lhs.true.64
  %43 = load i64, i64* %ev2, align 8
  %and71 = and i64 %43, 7
  %conv72 = trunc i64 %and71 to i32
  %cmp73 = icmp eq i32 %conv72, 3
  br i1 %cmp73, label %land.lhs.true.75, label %if.else.90

land.lhs.true.75:                                 ; preds = %land.lhs.true.70
  %44 = load i64, i64* %ev2, align 8
  %sub76 = sub nsw i64 %44, 3
  %45 = inttoptr i64 %sub76 to i8*
  %46 = bitcast i8* %45 to %struct.Lisp_Cons*
  %car77 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %46, i32 0, i32 0
  %47 = load i64, i64* %car77, align 8
  %call78 = call i64 @builtin_lisp_symbol(i32 516)
  %cmp79 = icmp eq i64 %47, %call78
  br i1 %cmp79, label %land.lhs.true.81, label %if.else.90

land.lhs.true.81:                                 ; preds = %land.lhs.true.75
  %48 = load i64, i64* %ev2, align 8
  %sub82 = sub nsw i64 %48, 3
  %49 = inttoptr i64 %sub82 to i8*
  %50 = bitcast i8* %49 to %struct.Lisp_Cons*
  %u83 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %50, i32 0, i32 1
  %cdr84 = bitcast %union.anon.12* %u83 to i64*
  %51 = load i64, i64* %cdr84, align 8
  %call85 = call i64 @Fcdr_safe(i64 %51)
  %call86 = call i64 @Fcar_safe(i64 %call85)
  store i64 %call86, i64* %last_help, align 8
  %52 = load i64, i64* %last_help, align 8
  %53 = load i64, i64* %help, align 8
  %cmp87 = icmp eq i64 %52, %53
  br i1 %cmp87, label %if.then.89, label %if.else.90

if.then.89:                                       ; preds = %land.lhs.true.81
  store i32 -1, i32* %recorded, align 4
  br label %if.end.133

if.else.90:                                       ; preds = %land.lhs.true.81, %land.lhs.true.75, %land.lhs.true.70, %land.lhs.true.64, %if.else.59
  %54 = load i64, i64* %ev1, align 8
  %and91 = and i64 %54, 7
  %conv92 = trunc i64 %and91 to i32
  %cmp93 = icmp eq i32 %conv92, 3
  br i1 %cmp93, label %land.lhs.true.95, label %if.end.132

land.lhs.true.95:                                 ; preds = %if.else.90
  %55 = load i64, i64* %ev1, align 8
  %sub96 = sub nsw i64 %55, 3
  %56 = inttoptr i64 %sub96 to i8*
  %57 = bitcast i8* %56 to %struct.Lisp_Cons*
  %car97 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %57, i32 0, i32 0
  %58 = load i64, i64* %car97, align 8
  %call98 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp99 = icmp eq i64 %58, %call98
  br i1 %cmp99, label %land.lhs.true.101, label %if.end.132

land.lhs.true.101:                                ; preds = %land.lhs.true.95
  %59 = load i64, i64* %ev2, align 8
  %and102 = and i64 %59, 7
  %conv103 = trunc i64 %and102 to i32
  %cmp104 = icmp eq i32 %conv103, 3
  br i1 %cmp104, label %land.lhs.true.106, label %if.end.132

land.lhs.true.106:                                ; preds = %land.lhs.true.101
  %60 = load i64, i64* %ev2, align 8
  %sub107 = sub nsw i64 %60, 3
  %61 = inttoptr i64 %sub107 to i8*
  %62 = bitcast i8* %61 to %struct.Lisp_Cons*
  %car108 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %62, i32 0, i32 0
  %63 = load i64, i64* %car108, align 8
  %call109 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp110 = icmp eq i64 %63, %call109
  br i1 %cmp110, label %land.lhs.true.112, label %if.end.132

land.lhs.true.112:                                ; preds = %land.lhs.true.106
  %64 = load i64, i64* %ev3, align 8
  %and113 = and i64 %64, 7
  %conv114 = trunc i64 %and113 to i32
  %cmp115 = icmp eq i32 %conv114, 3
  br i1 %cmp115, label %land.lhs.true.117, label %if.end.132

land.lhs.true.117:                                ; preds = %land.lhs.true.112
  %65 = load i64, i64* %ev3, align 8
  %sub118 = sub nsw i64 %65, 3
  %66 = inttoptr i64 %sub118 to i8*
  %67 = bitcast i8* %66 to %struct.Lisp_Cons*
  %car119 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %67, i32 0, i32 0
  %68 = load i64, i64* %car119, align 8
  %call120 = call i64 @builtin_lisp_symbol(i32 516)
  %cmp121 = icmp eq i64 %68, %call120
  br i1 %cmp121, label %land.lhs.true.123, label %if.end.132

land.lhs.true.123:                                ; preds = %land.lhs.true.117
  %69 = load i64, i64* %ev3, align 8
  %sub124 = sub nsw i64 %69, 3
  %70 = inttoptr i64 %sub124 to i8*
  %71 = bitcast i8* %70 to %struct.Lisp_Cons*
  %u125 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %71, i32 0, i32 1
  %cdr126 = bitcast %union.anon.12* %u125 to i64*
  %72 = load i64, i64* %cdr126, align 8
  %call127 = call i64 @Fcdr_safe(i64 %72)
  %call128 = call i64 @Fcar_safe(i64 %call127)
  store i64 %call128, i64* %last_help, align 8
  %73 = load i64, i64* %last_help, align 8
  %74 = load i64, i64* %help, align 8
  %cmp129 = icmp eq i64 %73, %74
  br i1 %cmp129, label %if.then.131, label %if.end.132

if.then.131:                                      ; preds = %land.lhs.true.123
  store i32 -2, i32* %recorded, align 4
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.131, %land.lhs.true.123, %land.lhs.true.117, %land.lhs.true.112, %land.lhs.true.106, %land.lhs.true.101, %land.lhs.true.95, %if.else.90
  br label %if.end.133

if.end.133:                                       ; preds = %if.end.132, %if.then.89
  br label %if.end.134

if.end.134:                                       ; preds = %if.end.133, %if.then.58
  br label %if.end.135

if.end.135:                                       ; preds = %if.end.134, %if.then.39
  br label %if.end.189

if.else.136:                                      ; preds = %if.end.26
  %75 = load i64, i64* %c.addr, align 8
  %sub137 = sub nsw i64 %75, 3
  %76 = inttoptr i64 %sub137 to i8*
  %77 = bitcast i8* %76 to %struct.Lisp_Cons*
  %car138 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %77, i32 0, i32 0
  %78 = load i64, i64* %car138, align 8
  %call139 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp140 = icmp eq i64 %78, %call139
  br i1 %cmp140, label %if.then.142, label %if.end.188

if.then.142:                                      ; preds = %if.else.136
  %79 = load i64, i64* %c.addr, align 8
  %sub143 = sub nsw i64 %79, 3
  %80 = inttoptr i64 %sub143 to i8*
  %81 = bitcast i8* %80 to %struct.Lisp_Cons*
  %u144 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %81, i32 0, i32 1
  %cdr145 = bitcast %union.anon.12* %u144 to i64*
  %82 = load i64, i64* %cdr145, align 8
  %call146 = call i64 @Fcar_safe(i64 %82)
  %call147 = call i64 @Fcar_safe(i64 %call146)
  store i64 %call147, i64* %window, align 8
  %83 = load i64, i64* %ev1, align 8
  %and148 = and i64 %83, 7
  %conv149 = trunc i64 %and148 to i32
  %cmp150 = icmp eq i32 %conv149, 3
  br i1 %cmp150, label %land.lhs.true.152, label %if.end.187

land.lhs.true.152:                                ; preds = %if.then.142
  %84 = load i64, i64* %ev1, align 8
  %sub153 = sub nsw i64 %84, 3
  %85 = inttoptr i64 %sub153 to i8*
  %86 = bitcast i8* %85 to %struct.Lisp_Cons*
  %car154 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %86, i32 0, i32 0
  %87 = load i64, i64* %car154, align 8
  %call155 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp156 = icmp eq i64 %87, %call155
  br i1 %cmp156, label %land.lhs.true.158, label %if.end.187

land.lhs.true.158:                                ; preds = %land.lhs.true.152
  %88 = load i64, i64* %ev1, align 8
  %sub159 = sub nsw i64 %88, 3
  %89 = inttoptr i64 %sub159 to i8*
  %90 = bitcast i8* %89 to %struct.Lisp_Cons*
  %u160 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %90, i32 0, i32 1
  %cdr161 = bitcast %union.anon.12* %u160 to i64*
  %91 = load i64, i64* %cdr161, align 8
  %call162 = call i64 @Fcar_safe(i64 %91)
  %call163 = call i64 @Fcar_safe(i64 %call162)
  store i64 %call163, i64* %last_window, align 8
  %92 = load i64, i64* %last_window, align 8
  %93 = load i64, i64* %window, align 8
  %cmp164 = icmp eq i64 %92, %93
  br i1 %cmp164, label %land.lhs.true.166, label %if.end.187

land.lhs.true.166:                                ; preds = %land.lhs.true.158
  %94 = load i64, i64* %ev2, align 8
  %and167 = and i64 %94, 7
  %conv168 = trunc i64 %and167 to i32
  %cmp169 = icmp eq i32 %conv168, 3
  br i1 %cmp169, label %land.lhs.true.171, label %if.end.187

land.lhs.true.171:                                ; preds = %land.lhs.true.166
  %95 = load i64, i64* %ev2, align 8
  %sub172 = sub nsw i64 %95, 3
  %96 = inttoptr i64 %sub172 to i8*
  %97 = bitcast i8* %96 to %struct.Lisp_Cons*
  %car173 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %97, i32 0, i32 0
  %98 = load i64, i64* %car173, align 8
  %call174 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp175 = icmp eq i64 %98, %call174
  br i1 %cmp175, label %land.lhs.true.177, label %if.end.187

land.lhs.true.177:                                ; preds = %land.lhs.true.171
  %99 = load i64, i64* %ev2, align 8
  %sub178 = sub nsw i64 %99, 3
  %100 = inttoptr i64 %sub178 to i8*
  %101 = bitcast i8* %100 to %struct.Lisp_Cons*
  %u179 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %101, i32 0, i32 1
  %cdr180 = bitcast %union.anon.12* %u179 to i64*
  %102 = load i64, i64* %cdr180, align 8
  %call181 = call i64 @Fcar_safe(i64 %102)
  %call182 = call i64 @Fcar_safe(i64 %call181)
  store i64 %call182, i64* %last_window, align 8
  %103 = load i64, i64* %last_window, align 8
  %104 = load i64, i64* %window, align 8
  %cmp183 = icmp eq i64 %103, %104
  br i1 %cmp183, label %if.then.185, label %if.end.187

if.then.185:                                      ; preds = %land.lhs.true.177
  %105 = load i64, i64* @recent_keys, align 8
  %106 = load i32, i32* %ix1, align 4
  %conv186 = sext i32 %106 to i64
  %107 = load i64, i64* %c.addr, align 8
  call void @ASET(i64 %105, i64 %conv186, i64 %107)
  store i32 1, i32* %recorded, align 4
  br label %if.end.187

if.end.187:                                       ; preds = %if.then.185, %land.lhs.true.177, %land.lhs.true.171, %land.lhs.true.166, %land.lhs.true.158, %land.lhs.true.152, %if.then.142
  br label %if.end.188

if.end.188:                                       ; preds = %if.end.187, %if.else.136
  br label %if.end.189

if.end.189:                                       ; preds = %if.end.188, %if.end.135
  br label %if.end.191

if.else.190:                                      ; preds = %lor.lhs.false, %entry
  %108 = load i64, i64* %c.addr, align 8
  call void @store_kbd_macro_char(i64 %108)
  br label %if.end.191

if.end.191:                                       ; preds = %if.else.190, %if.end.189
  %109 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call192 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp193 = icmp eq i64 %109, %call192
  br i1 %cmp193, label %if.then.195, label %if.end.227

if.then.195:                                      ; preds = %if.end.191
  %110 = load i32, i32* %recorded, align 4
  %tobool = icmp ne i32 %110, 0
  br i1 %tobool, label %if.else.204, label %if.then.196

if.then.196:                                      ; preds = %if.then.195
  %111 = load i32, i32* @total_keys, align 4
  %cmp197 = icmp slt i32 %111, 300
  %conv198 = zext i1 %cmp197 to i32
  %112 = load i32, i32* @total_keys, align 4
  %add = add nsw i32 %112, %conv198
  store i32 %add, i32* @total_keys, align 4
  %113 = load i64, i64* @recent_keys, align 8
  %114 = load i32, i32* @recent_keys_index, align 4
  %conv199 = sext i32 %114 to i64
  %115 = load i64, i64* %c.addr, align 8
  call void @ASET(i64 %113, i64 %conv199, i64 %115)
  %116 = load i32, i32* @recent_keys_index, align 4
  %inc = add nsw i32 %116, 1
  store i32 %inc, i32* @recent_keys_index, align 4
  %cmp200 = icmp sge i32 %inc, 300
  br i1 %cmp200, label %if.then.202, label %if.end.203

if.then.202:                                      ; preds = %if.then.196
  store i32 0, i32* @recent_keys_index, align 4
  br label %if.end.203

if.end.203:                                       ; preds = %if.then.202, %if.then.196
  br label %if.end.225

if.else.204:                                      ; preds = %if.then.195
  %117 = load i32, i32* %recorded, align 4
  %cmp205 = icmp slt i32 %117, 0
  br i1 %cmp205, label %if.then.207, label %if.end.224

if.then.207:                                      ; preds = %if.else.204
  br label %while.cond

while.cond:                                       ; preds = %if.end.221, %if.then.207
  %118 = load i32, i32* %recorded, align 4
  %inc208 = add nsw i32 %118, 1
  store i32 %inc208, i32* %recorded, align 4
  %cmp209 = icmp slt i32 %118, 0
  br i1 %cmp209, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %119 = load i32, i32* @total_keys, align 4
  %cmp211 = icmp sgt i32 %119, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %120 = phi i1 [ false, %while.cond ], [ %cmp211, %land.rhs ]
  br i1 %120, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %121 = load i32, i32* @total_keys, align 4
  %cmp213 = icmp slt i32 %121, 300
  br i1 %cmp213, label %if.then.215, label %if.end.216

if.then.215:                                      ; preds = %while.body
  %122 = load i32, i32* @total_keys, align 4
  %dec = add nsw i32 %122, -1
  store i32 %dec, i32* @total_keys, align 4
  br label %if.end.216

if.end.216:                                       ; preds = %if.then.215, %while.body
  %123 = load i32, i32* @recent_keys_index, align 4
  %dec217 = add nsw i32 %123, -1
  store i32 %dec217, i32* @recent_keys_index, align 4
  %cmp218 = icmp slt i32 %dec217, 0
  br i1 %cmp218, label %if.then.220, label %if.end.221

if.then.220:                                      ; preds = %if.end.216
  store i32 299, i32* @recent_keys_index, align 4
  br label %if.end.221

if.end.221:                                       ; preds = %if.then.220, %if.end.216
  %124 = load i64, i64* @recent_keys, align 8
  %125 = load i32, i32* @recent_keys_index, align 4
  %conv222 = sext i32 %125 to i64
  %call223 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %124, i64 %conv222, i64 %call223)
  br label %while.cond

while.end:                                        ; preds = %land.end
  br label %if.end.224

if.end.224:                                       ; preds = %while.end, %if.else.204
  br label %if.end.225

if.end.225:                                       ; preds = %if.end.224, %if.end.203
  %126 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  %inc226 = add nsw i64 %126, 1
  store i64 %inc226, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  br label %if.end.227

if.end.227:                                       ; preds = %if.end.225, %if.end.191
  %127 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %tobool228 = icmp ne %struct._IO_FILE* %127, null
  br i1 %tobool228, label %if.then.229, label %if.end.269

if.then.229:                                      ; preds = %if.end.227
  call void @block_input()
  %128 = load i64, i64* %c.addr, align 8
  %and230 = and i64 %128, 7
  %conv231 = trunc i64 %and230 to i32
  %and232 = and i32 %conv231, -5
  %cmp233 = icmp eq i32 %and232, 2
  br i1 %cmp233, label %if.then.235, label %if.else.247

if.then.235:                                      ; preds = %if.then.229
  %129 = load i64, i64* %c.addr, align 8
  %call236 = call i64 @XUINT(i64 %129)
  %cmp237 = icmp ult i64 %call236, 256
  br i1 %cmp237, label %if.then.239, label %if.else.243

if.then.239:                                      ; preds = %if.then.235
  %130 = load i64, i64* %c.addr, align 8
  %call240 = call i64 @XUINT(i64 %130)
  %conv241 = trunc i64 %call240 to i32
  %131 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call242 = call i32 @_IO_putc(i32 %conv241, %struct._IO_FILE* %131)
  br label %if.end.246

if.else.243:                                      ; preds = %if.then.235
  %132 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %133 = load i64, i64* %c.addr, align 8
  %call244 = call i64 @XUINT(i64 %133)
  %call245 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %132, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.354, i32 0, i32 0), i64 %call244)
  br label %if.end.246

if.end.246:                                       ; preds = %if.else.243, %if.then.239
  br label %if.end.267

if.else.247:                                      ; preds = %if.then.229
  %134 = load i64, i64* %c.addr, align 8
  %and248 = and i64 %134, 7
  %conv249 = trunc i64 %and248 to i32
  %cmp250 = icmp eq i32 %conv249, 3
  br i1 %cmp250, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.247
  %135 = load i64, i64* %c.addr, align 8
  %sub252 = sub nsw i64 %135, 3
  %136 = inttoptr i64 %sub252 to i8*
  %137 = bitcast i8* %136 to %struct.Lisp_Cons*
  %car253 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %137, i32 0, i32 0
  %138 = load i64, i64* %car253, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else.247
  %139 = load i64, i64* %c.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %138, %cond.true ], [ %139, %cond.false ]
  store i64 %cond, i64* %dribblee, align 8
  %140 = load i64, i64* %dribblee, align 8
  %and254 = and i64 %140, 7
  %conv255 = trunc i64 %and254 to i32
  %cmp256 = icmp eq i32 %conv255, 0
  br i1 %cmp256, label %if.then.258, label %if.end.266

if.then.258:                                      ; preds = %cond.end
  %141 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call259 = call i32 @_IO_putc(i32 60, %struct._IO_FILE* %141)
  %142 = load i64, i64* %dribblee, align 8
  %call260 = call i64 @SYMBOL_NAME(i64 %142)
  %call261 = call i8* @SDATA(i64 %call260)
  %143 = load i64, i64* %dribblee, align 8
  %call262 = call i64 @SYMBOL_NAME(i64 %143)
  %call263 = call i64 @SBYTES(i64 %call262)
  %144 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call264 = call i64 @fwrite(i8* %call261, i64 1, i64 %call263, %struct._IO_FILE* %144)
  %145 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call265 = call i32 @_IO_putc(i32 62, %struct._IO_FILE* %145)
  br label %if.end.266

if.end.266:                                       ; preds = %if.then.258, %cond.end
  br label %if.end.267

if.end.267:                                       ; preds = %if.end.266, %if.end.246
  %146 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call268 = call i32 @fflush(%struct._IO_FILE* %146)
  call void @unblock_input()
  br label %if.end.269

if.end.269:                                       ; preds = %if.end.267, %if.end.227
  ret void
}

declare i64 @Fcurrent_message() #1

declare i64 @Fcopy_sequence(i64) #1

; Function Attrs: nounwind uwtable
define internal void @echo_truncate(i64 %nchars) #0 {
entry:
  %nchars.addr = alloca i64, align 8
  store i64 %nchars, i64* %nchars.addr, align 8
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 22
  %1 = load i64, i64* %echo_string_, align 8
  %call = call zeroext i1 @STRINGP(i64 %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %3 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_1 = getelementptr inbounds %struct.kboard, %struct.kboard* %3, i32 0, i32 22
  %4 = load i64, i64* %echo_string_1, align 8
  %5 = load i64, i64* %nchars.addr, align 8
  %shl = shl i64 %5, 2
  %add = add i64 %shl, 2
  %call2 = call i64 @Fsubstring(i64 %4, i64 2, i64 %add)
  call void @kset_echo_string(%struct.kboard* %2, i64 %call2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i64, i64* %nchars.addr, align 8
  call void @truncate_echo_area(i64 %6)
  ret void
}

declare void @message_with_string(i8*, i64, i1 zeroext) #1

declare i64 @nconc2(i64, i64) #1

declare i64 @Fcdr(i64) #1

declare i64 @Fcar(i64) #1

; Function Attrs: nounwind uwtable
define internal void @add_command_key(i64 %key) #0 {
entry:
  %key.addr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* @this_command_key_count, align 8
  %1 = load i64, i64* @this_command_keys, align 8
  %call = call i64 @ASIZE(i64 %1)
  %cmp = icmp sge i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* @this_command_keys, align 8
  %call1 = call i64 @larger_vector(i64 %2, i64 1, i64 -1)
  store i64 %call1, i64* @this_command_keys, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i64, i64* @this_command_keys, align 8
  %4 = load i64, i64* @this_command_key_count, align 8
  %5 = load i64, i64* %key.addr, align 8
  call void @ASET(i64 %3, i64 %4, i64 %5)
  %6 = load i64, i64* @this_command_key_count, align 8
  %inc = add nsw i64 %6, 1
  store i64 %inc, i64* @this_command_key_count, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @echo_update() #0 {
entry:
  %i = alloca i64, align 8
  %prompt = alloca i64, align 8
  %prefix = alloca i64, align 8
  %c = alloca i64, align 8
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.then, label %if.end.28

if.then:                                          ; preds = %entry
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_prompt_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 25
  %2 = load i64, i64* %echo_prompt_, align 8
  store i64 %2, i64* %prompt, align 8
  %call = call i64 @builtin_lisp_symbol(i32 566)
  %call1 = call i64 @call0(i64 %call)
  store i64 %call1, i64* %prefix, align 8
  %3 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %4 = load i64, i64* %prompt, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %4, %call2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %5 = load i64, i64* %prefix, align 8
  br label %cond.end.8

cond.false:                                       ; preds = %if.then
  %6 = load i64, i64* %prefix, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %6, %call3
  br i1 %cmp4, label %cond.true.5, label %cond.false.6

cond.true.5:                                      ; preds = %cond.false
  %7 = load i64, i64* %prompt, align 8
  br label %cond.end

cond.false.6:                                     ; preds = %cond.false
  %8 = load i64, i64* %prompt, align 8
  %9 = load i64, i64* %prefix, align 8
  %call7 = call i64 @concat2(i64 %8, i64 %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.6, %cond.true.5
  %cond = phi i64 [ %7, %cond.true.5 ], [ %call7, %cond.false.6 ]
  br label %cond.end.8

cond.end.8:                                       ; preds = %cond.end, %cond.true
  %cond9 = phi i64 [ %5, %cond.true ], [ %cond, %cond.end ]
  call void @kset_echo_string(%struct.kboard* %3, i64 %cond9)
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end.8
  %10 = load i64, i64* %i, align 8
  %11 = load i64, i64* @this_command_key_count, align 8
  %cmp10 = icmp slt i64 %10, %11
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i64, i64* @this_command_keys, align 8
  %13 = load i64, i64* %i, align 8
  %call11 = call i64 @AREF(i64 %12, i64 %13)
  store i64 %call11, i64* %c, align 8
  %14 = load i64, i64* %c, align 8
  %and = and i64 %14, 7
  %conv = trunc i64 %and to i32
  %cmp12 = icmp eq i32 %conv, 3
  br i1 %cmp12, label %land.lhs.true, label %if.then.27

land.lhs.true:                                    ; preds = %for.body
  %15 = load i64, i64* %c, align 8
  %and14 = and i64 %15, 7
  %conv15 = trunc i64 %and14 to i32
  %cmp16 = icmp eq i32 %conv15, 3
  br i1 %cmp16, label %cond.true.18, label %cond.false.19

cond.true.18:                                     ; preds = %land.lhs.true
  %16 = load i64, i64* %c, align 8
  %sub = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 0
  %19 = load i64, i64* %car, align 8
  br label %cond.end.20

cond.false.19:                                    ; preds = %land.lhs.true
  %20 = load i64, i64* %c, align 8
  br label %cond.end.20

cond.end.20:                                      ; preds = %cond.false.19, %cond.true.18
  %cond21 = phi i64 [ %19, %cond.true.18 ], [ %20, %cond.false.19 ]
  %call22 = call i64 @builtin_lisp_symbol(i32 382)
  %call23 = call i64 @Fget(i64 %cond21, i64 %call22)
  %call24 = call i64 @builtin_lisp_symbol(i32 690)
  %cmp25 = icmp eq i64 %call23, %call24
  br i1 %cmp25, label %if.end, label %if.then.27

if.then.27:                                       ; preds = %cond.end.20, %for.body
  %21 = load i64, i64* %c, align 8
  call void @echo_add_key(i64 %21)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %cond.end.20
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, i64* %i, align 8
  %inc = add nsw i64 %22, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @echo_now()
  br label %if.end.28

if.end.28:                                        ; preds = %for.end, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @help_char_p(i64 %c) #0 {
entry:
  %retval = alloca i1, align 1
  %c.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  store i64 %c, i64* %c.addr, align 8
  %0 = load i64, i64* %c.addr, align 8
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 121), align 8
  %cmp = icmp eq i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 122), align 8
  store i64 %2, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i64, i64* %tail, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %cmp1 = icmp eq i32 %conv, 3
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %c.addr, align 8
  %5 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car, align 8
  %cmp3 = icmp eq i64 %4, %8
  br i1 %cmp3, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %for.body
  store i1 true, i1* %retval
  br label %return

if.end.6:                                         ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.6
  %9 = load i64, i64* %tail, align 8
  %sub7 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub7 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %12 = load i64, i64* %cdr, align 8
  store i64 %12, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.5, %if.then
  %13 = load i1, i1* %retval
  ret i1 %13
}

declare i64 @Fcurrent_window_configuration(i64) #1

; Function Attrs: nounwind uwtable
define internal void @read_char_help_form_unwind() #0 {
entry:
  %window_config = alloca i64, align 8
  %0 = load i64, i64* @help_form_saved_window_configs, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %window_config, align 8
  %4 = load i64, i64* @help_form_saved_window_configs, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  store i64 %7, i64* @help_form_saved_window_configs, align 8
  %8 = load i64, i64* %window_config, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %8, %call
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %9 = load i64, i64* %window_config, align 8
  %call2 = call i64 @Fset_window_configuration(i64 %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @kbd_buffer_store_event(%struct.input_event* %event) #0 {
entry:
  %event.addr = alloca %struct.input_event*, align 8
  store %struct.input_event* %event, %struct.input_event** %event.addr, align 8
  %0 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  call void @kbd_buffer_store_event_hold(%struct.input_event* %0, %struct.input_event* null)
  ret void
}

declare void @kbd_buffer_store_event_hold(%struct.input_event*, %struct.input_event*) #1

; Function Attrs: nounwind uwtable
define void @kbd_buffer_store_buffered_event(%union.buffered_input_event* %event, %struct.input_event* %hold_quit) #0 {
entry:
  %event.addr = alloca %union.buffered_input_event*, align 8
  %hold_quit.addr = alloca %struct.input_event*, align 8
  %c = alloca i32, align 4
  %kb = alloca %struct.kboard*, align 8
  %sp = alloca %union.buffered_input_event*, align 8
  %focus = alloca i64, align 8
  store %union.buffered_input_event* %event, %union.buffered_input_event** %event.addr, align 8
  store %struct.input_event* %hold_quit, %struct.input_event** %hold_quit.addr, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %1 = bitcast %union.buffered_input_event* %0 to i16*
  %bf.load = load i16, i16* %1, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp = icmp eq i32 %bf.cast, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @emacs_abort() #11
  unreachable

if.end:                                           ; preds = %entry
  %2 = load %struct.input_event*, %struct.input_event** %hold_quit.addr, align 8
  %tobool = icmp ne %struct.input_event* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end.4

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.input_event*, %struct.input_event** %hold_quit.addr, align 8
  %4 = bitcast %struct.input_event* %3 to i32*
  %bf.load1 = load i32, i32* %4, align 8
  %bf.clear = and i32 %bf.load1, 65535
  %cmp2 = icmp ne i32 %bf.clear, 0
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %land.lhs.true
  br label %if.end.154

if.end.4:                                         ; preds = %land.lhs.true, %if.end
  %5 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %6 = bitcast %union.buffered_input_event* %5 to i16*
  %bf.load5 = load i16, i16* %6, align 8
  %bf.cast6 = zext i16 %bf.load5 to i32
  %cmp7 = icmp eq i32 %bf.cast6, 1
  br i1 %cmp7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.end.4
  %7 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie = bitcast %union.buffered_input_event* %7 to %struct.input_event*
  %code = getelementptr inbounds %struct.input_event, %struct.input_event* %ie, i32 0, i32 1
  %8 = load i32, i32* %code, align 4
  %and = and i32 %8, 255
  store i32 %and, i32* %c, align 4
  %9 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie9 = bitcast %union.buffered_input_event* %9 to %struct.input_event*
  %modifiers = getelementptr inbounds %struct.input_event, %struct.input_event* %ie9, i32 0, i32 2
  %10 = load i32, i32* %modifiers, align 4
  %and10 = and i32 %10, 67108864
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.then.8
  %11 = load i32, i32* %c, align 4
  %call = call i32 @make_ctrl_char(i32 %11) #14
  store i32 %call, i32* %c, align 4
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.then.8
  %12 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie14 = bitcast %union.buffered_input_event* %12 to %struct.input_event*
  %modifiers15 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie14, i32 0, i32 2
  %13 = load i32, i32* %modifiers15, align 4
  %and16 = and i32 %13, 163577856
  %14 = load i32, i32* %c, align 4
  %or = or i32 %14, %and16
  store i32 %or, i32* %c, align 4
  %15 = load i32, i32* %c, align 4
  %16 = load i32, i32* @quit_char, align 4
  %cmp17 = icmp eq i32 %15, %16
  br i1 %cmp17, label %if.then.18, label %if.end.63

if.then.18:                                       ; preds = %if.end.13
  %17 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie19 = bitcast %union.buffered_input_event* %17 to %struct.input_event*
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %ie19, i32 0, i32 6
  %18 = load i64, i64* %frame_or_window, align 8
  %sub = sub nsw i64 %18, 5
  %19 = inttoptr i64 %sub to i8*
  %20 = bitcast i8* %19 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %20, i32 0, i32 61
  %21 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %21, i32 0, i32 10
  %22 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  store %struct.kboard* %22, %struct.kboard** %kb, align 8
  %23 = load i8, i8* @single_kboard, align 1
  %tobool20 = trunc i8 %23 to i1
  br i1 %tobool20, label %land.lhs.true.21, label %if.end.48

land.lhs.true.21:                                 ; preds = %if.then.18
  %24 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %25 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp22 = icmp ne %struct.kboard* %24, %25
  br i1 %cmp22, label %if.then.23, label %if.end.48

if.then.23:                                       ; preds = %land.lhs.true.21
  %26 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %27 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie24 = bitcast %union.buffered_input_event* %27 to %struct.input_event*
  %frame_or_window25 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie24, i32 0, i32 6
  %28 = load i64, i64* %frame_or_window25, align 8
  %call26 = call i64 @make_lispy_switch_frame(i64 %28)
  %29 = load i32, i32* %c, align 4
  %conv = sext i32 %29 to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  %call27 = call i64 @list2(i64 %call26, i64 %add)
  call void @kset_kbd_queue(%struct.kboard* %26, i64 %call27)
  %30 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_has_data = getelementptr inbounds %struct.kboard, %struct.kboard* %30, i32 0, i32 23
  store i8 1, i8* %kbd_queue_has_data, align 1
  %31 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %31, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.23
  %32 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %33 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp28 = icmp ne %union.buffered_input_event* %32, %33
  br i1 %cmp28, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %34 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %cmp30 = icmp eq %union.buffered_input_event* %34, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp30, label %if.then.32, label %if.end.33

if.then.32:                                       ; preds = %for.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %sp, align 8
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.32, %for.body
  %35 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %ie34 = bitcast %union.buffered_input_event* %35 to %struct.input_event*
  %call35 = call %struct.kboard* @event_to_kboard(%struct.input_event* %ie34)
  %36 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %cmp36 = icmp eq %struct.kboard* %call35, %36
  br i1 %cmp36, label %if.then.38, label %if.end.47

if.then.38:                                       ; preds = %if.end.33
  %37 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %ie39 = bitcast %union.buffered_input_event* %37 to %struct.input_event*
  %38 = bitcast %struct.input_event* %ie39 to i32*
  %bf.load40 = load i32, i32* %38, align 8
  %bf.clear41 = and i32 %bf.load40, -65536
  store i32 %bf.clear41, i32* %38, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  %39 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %ie43 = bitcast %union.buffered_input_event* %39 to %struct.input_event*
  %frame_or_window44 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie43, i32 0, i32 6
  store i64 %call42, i64* %frame_or_window44, align 8
  %call45 = call i64 @builtin_lisp_symbol(i32 0)
  %40 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %ie46 = bitcast %union.buffered_input_event* %40 to %struct.input_event*
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %ie46, i32 0, i32 7
  store i64 %call45, i64* %arg, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.38, %if.end.33
  br label %for.inc

for.inc:                                          ; preds = %if.end.47
  %41 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %incdec.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %41, i32 1
  store %union.buffered_input_event* %incdec.ptr, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.154

if.end.48:                                        ; preds = %land.lhs.true.21, %if.then.18
  %42 = load %struct.input_event*, %struct.input_event** %hold_quit.addr, align 8
  %tobool49 = icmp ne %struct.input_event* %42, null
  br i1 %tobool49, label %if.then.50, label %if.end.52

if.then.50:                                       ; preds = %if.end.48
  %43 = load %struct.input_event*, %struct.input_event** %hold_quit.addr, align 8
  %44 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie51 = bitcast %union.buffered_input_event* %44 to %struct.input_event*
  %45 = bitcast %struct.input_event* %43 to i8*
  %46 = bitcast %struct.input_event* %ie51 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %45, i8* %46, i64 56, i32 8, i1 false)
  br label %if.end.154

if.end.52:                                        ; preds = %if.end.48
  %47 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie53 = bitcast %union.buffered_input_event* %47 to %struct.input_event*
  %frame_or_window54 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie53, i32 0, i32 6
  %48 = load i64, i64* %frame_or_window54, align 8
  %sub55 = sub nsw i64 %48, 5
  %49 = inttoptr i64 %sub55 to i8*
  %50 = bitcast i8* %49 to %struct.frame*
  %focus_frame = getelementptr inbounds %struct.frame, %struct.frame* %50, i32 0, i32 4
  %51 = load i64, i64* %focus_frame, align 8
  store i64 %51, i64* %focus, align 8
  %52 = load i64, i64* %focus, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp57 = icmp eq i64 %52, %call56
  br i1 %cmp57, label %if.then.59, label %if.end.62

if.then.59:                                       ; preds = %if.end.52
  %53 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %ie60 = bitcast %union.buffered_input_event* %53 to %struct.input_event*
  %frame_or_window61 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie60, i32 0, i32 6
  %54 = load i64, i64* %frame_or_window61, align 8
  store i64 %54, i64* %focus, align 8
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.59, %if.end.52
  %55 = load i64, i64* %focus, align 8
  store i64 %55, i64* @internal_last_event_frame, align 8
  %56 = load i64, i64* %focus, align 8
  store i64 %56, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  call void @handle_interrupt(i1 zeroext false)
  br label %if.end.154

if.end.63:                                        ; preds = %if.end.13
  %57 = load i32, i32* %c, align 4
  %tobool64 = icmp ne i32 %57, 0
  br i1 %tobool64, label %land.lhs.true.65, label %if.end.69

land.lhs.true.65:                                 ; preds = %if.end.63
  %58 = load i32, i32* %c, align 4
  %59 = load i32, i32* @stop_character, align 4
  %cmp66 = icmp eq i32 %58, %59
  br i1 %cmp66, label %if.then.68, label %if.end.69

if.then.68:                                       ; preds = %land.lhs.true.65
  call void @sys_suspend()
  br label %if.end.154

if.end.69:                                        ; preds = %land.lhs.true.65, %if.end.63
  br label %if.end.86

if.else:                                          ; preds = %if.end.4
  %60 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %61 = bitcast %union.buffered_input_event* %60 to i16*
  %bf.load70 = load i16, i16* %61, align 8
  %bf.cast71 = zext i16 %bf.load70 to i32
  %cmp72 = icmp eq i32 %bf.cast71, 12
  br i1 %cmp72, label %land.lhs.true.74, label %if.end.85

land.lhs.true.74:                                 ; preds = %if.else
  %62 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %63 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp75 = icmp ne %union.buffered_input_event* %62, %63
  br i1 %cmp75, label %land.lhs.true.77, label %if.end.85

land.lhs.true.77:                                 ; preds = %land.lhs.true.74
  %64 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp78 = icmp eq %union.buffered_input_event* %64, getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0)
  br i1 %cmp78, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.77
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.77
  %65 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %add.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %65, i64 -1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %union.buffered_input_event* [ getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 4095), %cond.true ], [ %add.ptr, %cond.false ]
  %66 = bitcast %union.buffered_input_event* %cond to i16*
  %bf.load80 = load i16, i16* %66, align 8
  %bf.cast81 = zext i16 %bf.load80 to i32
  %cmp82 = icmp eq i32 %bf.cast81, 12
  br i1 %cmp82, label %if.then.84, label %if.end.85

if.then.84:                                       ; preds = %cond.end
  br label %if.end.154

if.end.85:                                        ; preds = %cond.end, %land.lhs.true.74, %if.else
  br label %if.end.86

if.end.86:                                        ; preds = %if.end.85, %if.end.69
  %67 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %sub.ptr.lhs.cast = ptrtoint %union.buffered_input_event* %67 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, ptrtoint ([4096 x %union.buffered_input_event]* @kbd_buffer to i64)
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 56
  %cmp87 = icmp eq i64 %sub.ptr.div, 4096
  br i1 %cmp87, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %if.end.86
  store volatile %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** @kbd_store_ptr, align 8
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.89, %if.end.86
  %68 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %add.ptr91 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %68, i64 -1
  %69 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp92 = icmp ne %union.buffered_input_event* %add.ptr91, %69
  br i1 %cmp92, label %if.then.94, label %if.end.103

if.then.94:                                       ; preds = %if.end.90
  %70 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %71 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %72 = bitcast %union.buffered_input_event* %70 to i8*
  %73 = bitcast %union.buffered_input_event* %71 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %72, i8* %73, i64 56, i32 8, i1 false)
  %74 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %incdec.ptr95 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %74, i32 1
  store volatile %union.buffered_input_event* %incdec.ptr95, %union.buffered_input_event** @kbd_store_ptr, align 8
  %call96 = call i32 @kbd_buffer_nr_stored()
  %cmp97 = icmp sgt i32 %call96, 2048
  br i1 %cmp97, label %land.lhs.true.99, label %if.end.102

land.lhs.true.99:                                 ; preds = %if.then.94
  %call100 = call zeroext i1 @kbd_on_hold_p()
  br i1 %call100, label %if.end.102, label %if.then.101

if.then.101:                                      ; preds = %land.lhs.true.99
  call void @hold_keyboard_input()
  call void @unrequest_sigio()
  call void @stop_polling()
  br label %if.end.102

if.end.102:                                       ; preds = %if.then.101, %land.lhs.true.99, %if.then.94
  br label %if.end.103

if.end.103:                                       ; preds = %if.end.102, %if.end.90
  %75 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296), align 8
  %call104 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp105 = icmp eq i64 %75, %call104
  br i1 %cmp105, label %if.end.154, label %land.lhs.true.107

land.lhs.true.107:                                ; preds = %if.end.103
  %76 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %77 = bitcast %union.buffered_input_event* %76 to i16*
  %bf.load108 = load i16, i16* %77, align 8
  %bf.cast109 = zext i16 %bf.load108 to i32
  %cmp110 = icmp ne i32 %bf.cast109, 22
  br i1 %cmp110, label %land.lhs.true.112, label %if.end.154

land.lhs.true.112:                                ; preds = %land.lhs.true.107
  %78 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %79 = bitcast %union.buffered_input_event* %78 to i16*
  %bf.load113 = load i16, i16* %79, align 8
  %bf.cast114 = zext i16 %bf.load113 to i32
  %cmp115 = icmp ne i32 %bf.cast114, 23
  br i1 %cmp115, label %land.lhs.true.117, label %if.end.154

land.lhs.true.117:                                ; preds = %land.lhs.true.112
  %80 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %81 = bitcast %union.buffered_input_event* %80 to i16*
  %bf.load118 = load i16, i16* %81, align 8
  %bf.cast119 = zext i16 %bf.load118 to i32
  %cmp120 = icmp ne i32 %bf.cast119, 20
  br i1 %cmp120, label %land.lhs.true.122, label %if.end.154

land.lhs.true.122:                                ; preds = %land.lhs.true.117
  %82 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %83 = bitcast %union.buffered_input_event* %82 to i16*
  %bf.load123 = load i16, i16* %83, align 8
  %bf.cast124 = zext i16 %bf.load123 to i32
  %cmp125 = icmp ne i32 %bf.cast124, 15
  br i1 %cmp125, label %land.lhs.true.127, label %if.end.154

land.lhs.true.127:                                ; preds = %land.lhs.true.122
  %84 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %85 = bitcast %union.buffered_input_event* %84 to i16*
  %bf.load128 = load i16, i16* %85, align 8
  %bf.cast129 = zext i16 %bf.load128 to i32
  %cmp130 = icmp ne i32 %bf.cast129, 16
  br i1 %cmp130, label %if.then.132, label %if.end.154

if.then.132:                                      ; preds = %land.lhs.true.127
  %86 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296), align 8
  store i64 %86, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %87 = load i8, i8* @immediate_quit, align 1
  %tobool133 = trunc i8 %87 to i1
  br i1 %tobool133, label %land.lhs.true.135, label %if.end.153

land.lhs.true.135:                                ; preds = %if.then.132
  %88 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp137 = icmp eq i64 %88, %call136
  br i1 %cmp137, label %if.then.139, label %if.end.153

if.then.139:                                      ; preds = %land.lhs.true.135
  store i8 0, i8* @immediate_quit, align 1
  br label %do.body

do.body:                                          ; preds = %if.then.139
  %89 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call140 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp141 = icmp eq i64 %89, %call140
  br i1 %cmp141, label %if.else.148, label %land.lhs.true.143

land.lhs.true.143:                                ; preds = %do.body
  %90 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call144 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp145 = icmp eq i64 %90, %call144
  br i1 %cmp145, label %if.then.147, label %if.else.148

if.then.147:                                      ; preds = %land.lhs.true.143
  call void @process_quit_flag()
  br label %if.end.152

if.else.148:                                      ; preds = %land.lhs.true.143, %do.body
  %91 = load volatile i8, i8* @pending_signals, align 1
  %tobool149 = trunc i8 %91 to i1
  br i1 %tobool149, label %if.then.150, label %if.end.151

if.then.150:                                      ; preds = %if.else.148
  call void @process_pending_signals()
  br label %if.end.151

if.end.151:                                       ; preds = %if.then.150, %if.else.148
  br label %if.end.152

if.end.152:                                       ; preds = %if.end.151, %if.then.147
  br label %do.end

do.end:                                           ; preds = %if.end.152
  br label %if.end.153

if.end.153:                                       ; preds = %do.end, %land.lhs.true.135, %if.then.132
  br label %if.end.154

if.end.154:                                       ; preds = %if.then.3, %for.end, %if.then.50, %if.end.62, %if.then.68, %if.then.84, %if.end.153, %land.lhs.true.127, %land.lhs.true.122, %land.lhs.true.117, %land.lhs.true.112, %land.lhs.true.107, %if.end.103
  ret void
}

declare i64 @list2(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_switch_frame(i64 %frame) #0 {
entry:
  %frame.addr = alloca i64, align 8
  store i64 %frame, i64* %frame.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 895)
  %0 = load i64, i64* %frame.addr, align 8
  %call1 = call i64 @list2(i64 %call, i64 %0)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal %struct.kboard* @event_to_kboard(%struct.input_event* %event) #0 {
entry:
  %retval = alloca %struct.kboard*, align 8
  %event.addr = alloca %struct.input_event*, align 8
  %obj = alloca i64, align 8
  store %struct.input_event* %event, %struct.input_event** %event.addr, align 8
  %0 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %1 = bitcast %struct.input_event* %0 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.clear = and i32 %bf.load, 65535
  %cmp = icmp eq i32 %bf.clear, 10
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %3 = bitcast %struct.input_event* %2 to i32*
  %bf.load1 = load i32, i32* %3, align 8
  %bf.clear2 = and i32 %bf.load1, 65535
  %cmp3 = icmp eq i32 %bf.clear2, 11
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.kboard* null, %struct.kboard** %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %4 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %4, i32 0, i32 6
  %5 = load i64, i64* %frame_or_window, align 8
  store i64 %5, i64* %obj, align 8
  %6 = load i64, i64* %obj, align 8
  %call = call zeroext i1 @WINDOWP(i64 %6)
  br i1 %call, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.else
  %7 = load i64, i64* %obj, align 8
  %call5 = call %struct.window* @XWINDOW(i64 %7)
  %frame = getelementptr inbounds %struct.window, %struct.window* %call5, i32 0, i32 1
  %8 = load i64, i64* %frame, align 8
  store i64 %8, i64* %obj, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.4, %if.else
  %9 = load i64, i64* %obj, align 8
  %call6 = call zeroext i1 @FRAMEP(i64 %9)
  br i1 %call6, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end
  %10 = load i64, i64* %obj, align 8
  %sub = sub nsw i64 %10, 5
  %11 = inttoptr i64 %sub to i8*
  %12 = bitcast i8* %11 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %12, i32 0, i32 61
  %13 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp7 = icmp ne %struct.terminal* %13, null
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %14 = load i64, i64* %obj, align 8
  %sub8 = sub nsw i64 %14, 5
  %15 = inttoptr i64 %sub8 to i8*
  %16 = bitcast i8* %15 to %struct.frame*
  %terminal9 = getelementptr inbounds %struct.frame, %struct.frame* %16, i32 0, i32 61
  %17 = load %struct.terminal*, %struct.terminal** %terminal9, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %17, i32 0, i32 10
  %18 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.kboard* [ %18, %cond.true ], [ null, %cond.false ]
  store %struct.kboard* %cond, %struct.kboard** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %19 = load %struct.kboard*, %struct.kboard** %retval
  ret %struct.kboard* %19
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #8

; Function Attrs: nounwind uwtable
define internal void @handle_interrupt(i1 zeroext %in_signal_handler) #0 {
entry:
  %in_signal_handler.addr = alloca i8, align 1
  %c = alloca i8, align 1
  %blocked = alloca %struct.__sigset_t, align 8
  %saved = alloca %struct.gl_state_s, align 8
  %count = alloca i32, align 4
  %frombool = zext i1 %in_signal_handler to i8
  store i8 %frombool, i8* %in_signal_handler.addr, align 1
  call void @cancel_echoing()
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.else.48, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call1 = call %struct.terminal* @get_named_terminal(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0))
  %tobool = icmp ne %struct.terminal* %call1, null
  br i1 %tobool, label %if.then, label %if.else.48

if.then:                                          ; preds = %land.lhs.true
  %1 = load i8, i8* %in_signal_handler.addr, align 1
  %tobool2 = trunc i8 %1 to i1
  br i1 %tobool2, label %if.end, label %if.then.3

if.then.3:                                        ; preds = %if.then
  %call4 = call i32 @sigemptyset(%struct.__sigset_t* %blocked) #8
  %call5 = call i32 @sigaddset(%struct.__sigset_t* %blocked, i32 2) #8
  %call6 = call i32 @pthread_sigmask(i32 0, %struct.__sigset_t* %blocked, %struct.__sigset_t* null) #8
  %2 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %call7 = call i32 @fflush(%struct._IO_FILE* %2)
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  call void @reset_all_sys_modes()
  call void @sys_suspend()
  %3 = load i8, i8* @gc_in_progress, align 1
  %tobool8 = trunc i8 %3 to i1
  br i1 %tobool8, label %if.else, label %if.then.9

if.then.9:                                        ; preds = %if.end
  call void @write_stdout(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.390, i32 0, i32 0))
  %call10 = call i32 @read_stdin()
  %conv = trunc i32 %call10 to i8
  store i8 %conv, i8* %c, align 1
  %4 = load i8, i8* %c, align 1
  %conv11 = sext i8 %4 to i32
  %cmp12 = icmp eq i32 %conv11, 121
  br i1 %cmp12, label %if.then.17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.9
  %5 = load i8, i8* %c, align 1
  %conv14 = sext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 89
  br i1 %cmp15, label %if.then.17, label %if.end.21

if.then.17:                                       ; preds = %lor.lhs.false, %if.then.9
  %call18 = call i64 @builtin_lisp_symbol(i32 901)
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @Fdo_auto_save(i64 %call18, i64 %call19)
  call void @write_stdout(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.391, i32 0, i32 0))
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.17, %lor.lhs.false
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.21
  %6 = load i8, i8* %c, align 1
  %conv22 = sext i8 %6 to i32
  %cmp23 = icmp ne i32 %conv22, 10
  br i1 %cmp23, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %call25 = call i32 @read_stdin()
  %conv26 = trunc i32 %call25 to i8
  store i8 %conv26, i8* %c, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.28

if.else:                                          ; preds = %if.end
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call27, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  call void @write_stdout(i8* getelementptr inbounds ([118 x i8], [118 x i8]* @.str.392, i32 0, i32 0))
  br label %if.end.28

if.end.28:                                        ; preds = %if.else, %while.end
  call void @write_stdout(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.393, i32 0, i32 0))
  %call29 = call i32 @read_stdin()
  %conv30 = trunc i32 %call29 to i8
  store i8 %conv30, i8* %c, align 1
  %7 = load i8, i8* %c, align 1
  %conv31 = sext i8 %7 to i32
  %cmp32 = icmp eq i32 %conv31, 121
  br i1 %cmp32, label %if.then.38, label %lor.lhs.false.34

lor.lhs.false.34:                                 ; preds = %if.end.28
  %8 = load i8, i8* %c, align 1
  %conv35 = sext i8 %8 to i32
  %cmp36 = icmp eq i32 %conv35, 89
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %lor.lhs.false.34, %if.end.28
  call void @emacs_abort() #11
  unreachable

if.end.39:                                        ; preds = %lor.lhs.false.34
  br label %while.cond.40

while.cond.40:                                    ; preds = %while.body.44, %if.end.39
  %9 = load i8, i8* %c, align 1
  %conv41 = sext i8 %9 to i32
  %cmp42 = icmp ne i32 %conv41, 10
  br i1 %cmp42, label %while.body.44, label %while.end.47

while.body.44:                                    ; preds = %while.cond.40
  %call45 = call i32 @read_stdin()
  %conv46 = trunc i32 %call45 to i8
  store i8 %conv46, i8* %c, align 1
  br label %while.cond.40

while.end.47:                                     ; preds = %while.cond.40
  call void @write_stdout(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.394, i32 0, i32 0))
  call void @init_all_sys_modes()
  br label %if.end.71

if.else.48:                                       ; preds = %land.lhs.true, %entry
  %10 = load i8, i8* @immediate_quit, align 1
  %tobool49 = trunc i8 %10 to i1
  br i1 %tobool49, label %land.lhs.true.51, label %if.else.60

land.lhs.true.51:                                 ; preds = %if.else.48
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %11, %call52
  br i1 %cmp53, label %if.then.55, label %if.else.60

if.then.55:                                       ; preds = %land.lhs.true.51
  store i8 0, i8* @immediate_quit, align 1
  %call56 = call i32 @pthread_sigmask(i32 2, %struct.__sigset_t* @empty_mask, %struct.__sigset_t* null) #8
  %12 = bitcast %struct.gl_state_s* %saved to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* bitcast (%struct.gl_state_s* @gl_state to i8*), i64 104, i32 8, i1 false)
  %call57 = call i64 @builtin_lisp_symbol(i32 782)
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  %call59 = call i64 @Fsignal(i64 %call57, i64 %call58)
  %13 = bitcast %struct.gl_state_s* %saved to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.gl_state_s* @gl_state to i8*), i8* %13, i64 104, i32 8, i1 false)
  br label %if.end.70

if.else.60:                                       ; preds = %land.lhs.true.51, %if.else.48
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call61 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp62 = icmp eq i64 %14, %call61
  br i1 %cmp62, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.60
  br label %cond.end

cond.false:                                       ; preds = %if.else.60
  %15 = load volatile i32, i32* @force_quit_count, align 4
  %add = add nsw i32 %15, 1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %add, %cond.false ]
  store i32 %cond, i32* %count, align 4
  %16 = load i32, i32* %count, align 4
  store volatile i32 %16, i32* @force_quit_count, align 4
  %17 = load i32, i32* %count, align 4
  %cmp64 = icmp eq i32 %17, 3
  br i1 %cmp64, label %if.then.66, label %if.end.68

if.then.66:                                       ; preds = %cond.end
  store i8 1, i8* @immediate_quit, align 1
  %call67 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call67, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.66, %cond.end
  %call69 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call69, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.68, %if.then.55
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %while.end.47
  %call72 = call i32 @pthread_sigmask(i32 2, %struct.__sigset_t* @empty_mask, %struct.__sigset_t* null) #8
  %18 = load i8, i8* @waiting_for_input, align 1
  %tobool73 = trunc i8 %18 to i1
  br i1 %tobool73, label %land.lhs.true.75, label %if.end.79

land.lhs.true.75:                                 ; preds = %if.end.71
  %19 = load i8, i8* @echoing, align 1
  %tobool76 = trunc i8 %19 to i1
  br i1 %tobool76, label %if.end.79, label %if.then.77

if.then.77:                                       ; preds = %land.lhs.true.75
  %20 = load i8, i8* %in_signal_handler.addr, align 1
  %tobool78 = trunc i8 %20 to i1
  call void @quit_throw_to_read_char(i1 zeroext %tobool78) #11
  unreachable

if.end.79:                                        ; preds = %land.lhs.true.75, %if.end.71
  ret void
}

declare void @sys_suspend() #1

; Function Attrs: nounwind uwtable
define internal i32 @kbd_buffer_nr_stored() #0 {
entry:
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %1 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp = icmp eq %union.buffered_input_event* %0, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end.10

cond.false:                                       ; preds = %entry
  %2 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %3 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp1 = icmp ult %union.buffered_input_event* %2, %3
  br i1 %cmp1, label %cond.true.2, label %cond.false.3

cond.true.2:                                      ; preds = %cond.false
  %4 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %5 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %sub.ptr.lhs.cast = ptrtoint %union.buffered_input_event* %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %union.buffered_input_event* %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 56
  br label %cond.end

cond.false.3:                                     ; preds = %cond.false
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %sub.ptr.rhs.cast4 = ptrtoint %union.buffered_input_event* %6 to i64
  %sub.ptr.sub5 = sub i64 ptrtoint (%union.buffered_input_event* getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096) to i64), %sub.ptr.rhs.cast4
  %sub.ptr.div6 = sdiv exact i64 %sub.ptr.sub5, 56
  %7 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %sub.ptr.lhs.cast7 = ptrtoint %union.buffered_input_event* %7 to i64
  %sub.ptr.sub8 = sub i64 %sub.ptr.lhs.cast7, ptrtoint ([4096 x %union.buffered_input_event]* @kbd_buffer to i64)
  %sub.ptr.div9 = sdiv exact i64 %sub.ptr.sub8, 56
  %add = add nsw i64 %sub.ptr.div6, %sub.ptr.div9
  br label %cond.end

cond.end:                                         ; preds = %cond.false.3, %cond.true.2
  %cond = phi i64 [ %sub.ptr.div, %cond.true.2 ], [ %add, %cond.false.3 ]
  br label %cond.end.10

cond.end.10:                                      ; preds = %cond.end, %cond.true
  %cond11 = phi i64 [ 0, %cond.true ], [ %cond, %cond.end ]
  %conv = trunc i64 %cond11 to i32
  ret i32 %conv
}

declare zeroext i1 @kbd_on_hold_p() #1

declare void @hold_keyboard_input() #1

declare void @unrequest_sigio() #1

; Function Attrs: nounwind uwtable
define void @kbd_buffer_unget_event(%struct.selection_input_event* %event) #0 {
entry:
  %event.addr = alloca %struct.selection_input_event*, align 8
  %kp = alloca %union.buffered_input_event*, align 8
  store %struct.selection_input_event* %event, %struct.selection_input_event** %event.addr, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %cmp = icmp eq %union.buffered_input_event* %0, getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0)
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %union.buffered_input_event* getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096), %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %add.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %1, i64 -1
  store %union.buffered_input_event* %add.ptr, %union.buffered_input_event** %kp, align 8
  %2 = load %union.buffered_input_event*, %union.buffered_input_event** %kp, align 8
  %3 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp1 = icmp ne %union.buffered_input_event* %2, %3
  br i1 %cmp1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %4 = load %union.buffered_input_event*, %union.buffered_input_event** %kp, align 8
  %sie = bitcast %union.buffered_input_event* %4 to %struct.selection_input_event*
  %5 = load %struct.selection_input_event*, %struct.selection_input_event** %event.addr, align 8
  %6 = bitcast %struct.selection_input_event* %sie to i8*
  %7 = bitcast %struct.selection_input_event* %5 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 56, i32 8, i1 false)
  %8 = load %union.buffered_input_event*, %union.buffered_input_event** %kp, align 8
  store %union.buffered_input_event* %8, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @gen_help_event(i64 %help, i64 %frame, i64 %window, i64 %object, i64 %pos) #0 {
entry:
  %help.addr = alloca i64, align 8
  %frame.addr = alloca i64, align 8
  %window.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %event = alloca %struct.input_event, align 8
  store i64 %help, i64* %help.addr, align 8
  store i64 %frame, i64* %frame.addr, align 8
  store i64 %window, i64* %window.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = bitcast %struct.input_event* %event to i32*
  %bf.load = load i32, i32* %0, align 8
  %bf.clear = and i32 %bf.load, -65536
  %bf.set = or i32 %bf.clear, 20
  store i32 %bf.set, i32* %0, align 8
  %1 = load i64, i64* %frame.addr, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 6
  store i64 %1, i64* %frame_or_window, align 8
  %2 = load i64, i64* %object.addr, align 8
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 7
  store i64 %2, i64* %arg, align 8
  %3 = load i64, i64* %window.addr, align 8
  %call = call zeroext i1 @WINDOWP(i64 %3)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, i64* %window.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load i64, i64* %frame.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ %5, %cond.false ]
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 3
  store i64 %cond, i64* %x, align 8
  %6 = load i64, i64* %help.addr, align 8
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 4
  store i64 %6, i64* %y, align 8
  %7 = load i64, i64* %pos.addr, align 8
  %call1 = call i64 @position_to_Time(i64 %7)
  %timestamp = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 5
  store i64 %call1, i64* %timestamp, align 8
  call void @kbd_buffer_store_event(%struct.input_event* %event)
  ret void
}

declare zeroext i1 @WINDOWP(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @position_to_Time(i64 %pos) #0 {
entry:
  %pos.addr = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define void @kbd_buffer_store_help_event(i64 %frame, i64 %help) #0 {
entry:
  %frame.addr = alloca i64, align 8
  %help.addr = alloca i64, align 8
  %event = alloca %struct.input_event, align 8
  store i64 %frame, i64* %frame.addr, align 8
  store i64 %help, i64* %help.addr, align 8
  %0 = bitcast %struct.input_event* %event to i32*
  %bf.load = load i32, i32* %0, align 8
  %bf.clear = and i32 %bf.load, -65536
  %bf.set = or i32 %bf.clear, 20
  store i32 %bf.set, i32* %0, align 8
  %1 = load i64, i64* %frame.addr, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 6
  store i64 %1, i64* %frame_or_window, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 7
  store i64 %call, i64* %arg, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 3
  store i64 %call1, i64* %x, align 8
  %2 = load i64, i64* %help.addr, align 8
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 4
  store i64 %2, i64* %y, align 8
  %timestamp = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 5
  store i64 0, i64* %timestamp, align 8
  call void @kbd_buffer_store_event(%struct.input_event* %event)
  ret void
}

; Function Attrs: nounwind uwtable
define void @discard_mouse_events() #0 {
entry:
  %sp = alloca %union.buffered_input_event*, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %0, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %2 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp = icmp ne %union.buffered_input_event* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %cmp1 = icmp eq %union.buffered_input_event* %3, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %4 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %5 = bitcast %union.buffered_input_event* %4 to i16*
  %bf.load = load i16, i16* %5, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp2 = icmp eq i32 %bf.cast, 5
  br i1 %cmp2, label %if.then.18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %7 = bitcast %union.buffered_input_event* %6 to i16*
  %bf.load3 = load i16, i16* %7, align 8
  %bf.cast4 = zext i16 %bf.load3 to i32
  %cmp5 = icmp eq i32 %bf.cast4, 6
  br i1 %cmp5, label %if.then.18, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %8 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %9 = bitcast %union.buffered_input_event* %8 to i16*
  %bf.load7 = load i16, i16* %9, align 8
  %bf.cast8 = zext i16 %bf.load7 to i32
  %cmp9 = icmp eq i32 %bf.cast8, 7
  br i1 %cmp9, label %if.then.18, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false.6
  %10 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %11 = bitcast %union.buffered_input_event* %10 to i16*
  %bf.load11 = load i16, i16* %11, align 8
  %bf.cast12 = zext i16 %bf.load11 to i32
  %cmp13 = icmp eq i32 %bf.cast12, 8
  br i1 %cmp13, label %if.then.18, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false.10
  %12 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %13 = bitcast %union.buffered_input_event* %12 to i16*
  %bf.load15 = load i16, i16* %13, align 8
  %bf.cast16 = zext i16 %bf.load15 to i32
  %cmp17 = icmp eq i32 %bf.cast16, 9
  br i1 %cmp17, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %lor.lhs.false.14, %lor.lhs.false.10, %lor.lhs.false.6, %lor.lhs.false, %if.end
  %14 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %15 = bitcast %union.buffered_input_event* %14 to i16*
  store i16 0, i16* %15, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.18, %lor.lhs.false.14
  br label %for.inc

for.inc:                                          ; preds = %if.end.19
  %16 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %incdec.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %16, i32 1
  store %union.buffered_input_event* %incdec.ptr, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @kbd_buffer_events_waiting() #0 {
entry:
  %sp = alloca %union.buffered_input_event*, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %0, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %2 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp = icmp ne %union.buffered_input_event* %1, %2
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %3 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %4 = bitcast %union.buffered_input_event* %3 to i16*
  %bf.load = load i16, i16* %4, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp1 = icmp eq i32 %bf.cast, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %5 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %5, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %cmp2 = icmp eq %union.buffered_input_event* %6, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %incdec.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %7, i32 1
  store %union.buffered_input_event* %incdec.ptr, %union.buffered_input_event** %sp, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %8 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  store %union.buffered_input_event* %8, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %9 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %10 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp3 = icmp ne %union.buffered_input_event* %9, %10
  br i1 %cmp3, label %land.rhs.4, label %land.end.8

land.rhs.4:                                       ; preds = %for.end
  %11 = load %union.buffered_input_event*, %union.buffered_input_event** %sp, align 8
  %12 = bitcast %union.buffered_input_event* %11 to i16*
  %bf.load5 = load i16, i16* %12, align 8
  %bf.cast6 = zext i16 %bf.load5 to i32
  %cmp7 = icmp ne i32 %bf.cast6, 0
  br label %land.end.8

land.end.8:                                       ; preds = %land.rhs.4, %for.end
  %13 = phi i1 [ false, %for.end ], [ %cmp7, %land.rhs.4 ]
  ret i1 %13
}

; Function Attrs: nounwind uwtable
define internal void @process_special_events() #0 {
entry:
  %event = alloca %union.buffered_input_event*, align 8
  %copy = alloca %struct.selection_input_event, align 8
  %beg = alloca %union.buffered_input_event*, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %0, %union.buffered_input_event** %event, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %2 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp = icmp ne %union.buffered_input_event* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %cmp1 = icmp eq %union.buffered_input_event* %3, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp1, label %if.then, label %if.end.4

if.then:                                          ; preds = %for.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %event, align 8
  %4 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %5 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp2 = icmp eq %union.buffered_input_event* %4, %5
  br i1 %cmp2, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  br label %for.end

if.end:                                           ; preds = %if.then
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %for.body
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %7 = bitcast %union.buffered_input_event* %6 to i16*
  %bf.load = load i16, i16* %7, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp5 = icmp eq i32 %bf.cast, 10
  br i1 %cmp5, label %if.then.9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.4
  %8 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %9 = bitcast %union.buffered_input_event* %8 to i16*
  %bf.load6 = load i16, i16* %9, align 8
  %bf.cast7 = zext i16 %bf.load6 to i32
  %cmp8 = icmp eq i32 %bf.cast7, 11
  br i1 %cmp8, label %if.then.9, label %if.end.36

if.then.9:                                        ; preds = %lor.lhs.false, %if.end.4
  %10 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %sie = bitcast %union.buffered_input_event* %10 to %struct.selection_input_event*
  %11 = bitcast %struct.selection_input_event* %copy to i8*
  %12 = bitcast %struct.selection_input_event* %sie to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 56, i32 8, i1 false)
  %13 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %cmp10 = icmp eq %union.buffered_input_event* %13, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.9
  br label %cond.end

cond.false:                                       ; preds = %if.then.9
  %14 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %union.buffered_input_event* [ getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %cond.true ], [ %14, %cond.false ]
  store %union.buffered_input_event* %cond, %union.buffered_input_event** %beg, align 8
  %15 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %16 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %cmp11 = icmp ugt %union.buffered_input_event* %15, %16
  br i1 %cmp11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %cond.end
  %17 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %add.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %17, i64 1
  %18 = bitcast %union.buffered_input_event* %add.ptr to i8*
  %19 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %20 = bitcast %union.buffered_input_event* %19 to i8*
  %21 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %22 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %sub.ptr.lhs.cast = ptrtoint %union.buffered_input_event* %21 to i64
  %sub.ptr.rhs.cast = ptrtoint %union.buffered_input_event* %22 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 56
  %mul = mul i64 %sub.ptr.div, 56
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %18, i8* %20, i64 %mul, i32 8, i1 false)
  br label %if.end.31

if.else:                                          ; preds = %cond.end
  %23 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %24 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %cmp13 = icmp ult %union.buffered_input_event* %23, %24
  br i1 %cmp13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %if.else
  %25 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %cmp15 = icmp ugt %union.buffered_input_event* %25, getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0)
  br i1 %cmp15, label %if.then.16, label %if.end.21

if.then.16:                                       ; preds = %if.then.14
  %26 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %sub.ptr.lhs.cast17 = ptrtoint %union.buffered_input_event* %26 to i64
  %sub.ptr.sub18 = sub i64 %sub.ptr.lhs.cast17, ptrtoint ([4096 x %union.buffered_input_event]* @kbd_buffer to i64)
  %sub.ptr.div19 = sdiv exact i64 %sub.ptr.sub18, 56
  %mul20 = mul i64 %sub.ptr.div19, 56
  call void @llvm.memmove.p0i8.p0i8.i64(i8* bitcast (%union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 1) to i8*), i8* bitcast ([4096 x %union.buffered_input_event]* @kbd_buffer to i8*), i64 %mul20, i32 8, i1 false)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.16, %if.then.14
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast ([4096 x %union.buffered_input_event]* @kbd_buffer to i8*), i8* bitcast (%union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 4095) to i8*), i64 56, i32 8, i1 false)
  %27 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %cmp22 = icmp ult %union.buffered_input_event* %27, getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 4095)
  br i1 %cmp22, label %if.then.23, label %if.end.29

if.then.23:                                       ; preds = %if.end.21
  %28 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %add.ptr24 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %28, i64 1
  %29 = bitcast %union.buffered_input_event* %add.ptr24 to i8*
  %30 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %31 = bitcast %union.buffered_input_event* %30 to i8*
  %32 = load %union.buffered_input_event*, %union.buffered_input_event** %beg, align 8
  %sub.ptr.rhs.cast25 = ptrtoint %union.buffered_input_event* %32 to i64
  %sub.ptr.sub26 = sub i64 ptrtoint (%union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 4095) to i64), %sub.ptr.rhs.cast25
  %sub.ptr.div27 = sdiv exact i64 %sub.ptr.sub26, 56
  %mul28 = mul i64 %sub.ptr.div27, 56
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %29, i8* %31, i64 %mul28, i32 8, i1 false)
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.23, %if.end.21
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %if.else
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %if.then.12
  %33 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %cmp32 = icmp eq %union.buffered_input_event* %33, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp32, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %if.end.31
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i64 1), %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.35

if.else.34:                                       ; preds = %if.end.31
  %34 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %34, i32 1
  store %union.buffered_input_event* %incdec.ptr, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.34, %if.then.33
  %call = call zeroext i1 @readable_events(i32 0)
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* @input_pending, align 1
  call void @x_handle_selection_event(%struct.selection_input_event* %copy)
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end.36
  %35 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %incdec.ptr37 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %35, i32 1
  store %union.buffered_input_event* %incdec.ptr37, %union.buffered_input_event** %event, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.3, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @get_input_pending(i32 %flags) #0 {
entry:
  %flags.addr = alloca i32, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %entry
  %1 = load i32, i32* %flags.addr, align 4
  %call1 = call zeroext i1 @readable_events(i32 %1)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %2 = phi i1 [ true, %entry ], [ %call1, %lor.rhs ]
  %frombool = zext i1 %2 to i8
  store i8 %frombool, i8* @input_pending, align 1
  %3 = load i8, i8* @input_pending, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %lor.end
  %4 = load i8, i8* @interrupt_input, align 1
  %tobool2 = trunc i8 %4 to i1
  br i1 %tobool2, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %land.lhs.true
  %5 = load i8, i8* @interrupts_deferred, align 1
  %tobool3 = trunc i8 %5 to i1
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %call4 = call i32 @gobble_input()
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %6, %call5
  br i1 %cmp6, label %lor.rhs.7, label %lor.end.9

lor.rhs.7:                                        ; preds = %if.then
  %7 = load i32, i32* %flags.addr, align 4
  %call8 = call zeroext i1 @readable_events(i32 %7)
  br label %lor.end.9

lor.end.9:                                        ; preds = %lor.rhs.7, %if.then
  %8 = phi i1 [ true, %if.then ], [ %call8, %lor.rhs.7 ]
  %frombool10 = zext i1 %8 to i8
  store i8 %frombool10, i8* @input_pending, align 1
  br label %if.end

if.end:                                           ; preds = %lor.end.9, %lor.lhs.false, %lor.end
  %9 = load i8, i8* @input_pending, align 1
  %tobool11 = trunc i8 %9 to i1
  ret i1 %tobool11
}

; Function Attrs: nounwind uwtable
define { i64, i64 } @timer_check() #0 {
entry:
  %retval = alloca %struct.timespec, align 8
  %nexttime = alloca %struct.timespec, align 8
  %timers = alloca i64, align 8
  %idle_timers = alloca i64, align 8
  %tem = alloca i64, align 8
  %coerce = alloca %struct.timespec, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  store i64 %0, i64* %tem, align 8
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 298), align 8
  %call1 = call i64 @Fcopy_sequence(i64 %1)
  store i64 %call1, i64* %timers, align 8
  %2 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %3 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call2 = call zeroext i1 @timespec_valid_p(i64 %2, i64 %3)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 297), align 8
  %call3 = call i64 @Fcopy_sequence(i64 %4)
  store i64 %call3, i64* %idle_timers, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4, i64* %idle_timers, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i64, i64* %tem, align 8
  store i64 %5, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end
  %6 = load i64, i64* %timers, align 8
  %7 = load i64, i64* %idle_timers, align 8
  %call5 = call { i64, i64 } @timer_check_2(i64 %6, i64 %7)
  %8 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %9 = getelementptr { i64, i64 }, { i64, i64 }* %8, i32 0, i32 0
  %10 = extractvalue { i64, i64 } %call5, 0
  store i64 %10, i64* %9, align 8
  %11 = getelementptr { i64, i64 }, { i64, i64 }* %8, i32 0, i32 1
  %12 = extractvalue { i64, i64 } %call5, 1
  store i64 %12, i64* %11, align 8
  %13 = bitcast %struct.timespec* %nexttime to i8*
  %14 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 16, i32 8, i1 false)
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %nexttime, i32 0, i32 0
  %15 = load i64, i64* %tv_sec, align 8
  %cmp = icmp eq i64 %15, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.cond
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %nexttime, i32 0, i32 1
  %16 = load i64, i64* %tv_nsec, align 8
  %cmp6 = icmp eq i64 %16, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.cond
  %17 = phi i1 [ false, %do.cond ], [ %cmp6, %land.rhs ]
  br i1 %17, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %18 = bitcast %struct.timespec* %retval to i8*
  %19 = bitcast %struct.timespec* %nexttime to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false)
  %20 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %21 = load { i64, i64 }, { i64, i64 }* %20, align 8
  ret { i64, i64 } %21
}

declare zeroext i1 @timespec_valid_p(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal { i64, i64 } @timer_check_2(i64 %timers, i64 %idle_timers) #0 {
entry:
  %retval = alloca %struct.timespec, align 8
  %timers.addr = alloca i64, align 8
  %idle_timers.addr = alloca i64, align 8
  %nexttime = alloca %struct.timespec, align 8
  %now = alloca %struct.timespec, align 8
  %idleness_now = alloca %struct.timespec, align 8
  %chosen_timer = alloca i64, align 8
  %coerce = alloca %struct.timespec, align 8
  %funcall = alloca i64, align 8
  %coerce20 = alloca %struct.timespec, align 8
  %coerce24 = alloca %struct.timespec, align 8
  %coerce26 = alloca %struct.timespec, align 8
  %timer = alloca i64, align 8
  %idle_timer = alloca i64, align 8
  %timer_time = alloca %struct.timespec, align 8
  %idle_timer_time = alloca %struct.timespec, align 8
  %difference = alloca %struct.timespec, align 8
  %timer_difference = alloca %struct.timespec, align 8
  %idle_timer_difference = alloca %struct.timespec, align 8
  %ripe = alloca i8, align 1
  %timer_ripe = alloca i8, align 1
  %idle_timer_ripe = alloca i8, align 1
  %coerce60 = alloca %struct.timespec, align 8
  %coerce63 = alloca %struct.timespec, align 8
  %coerce87 = alloca %struct.timespec, align 8
  %coerce90 = alloca %struct.timespec, align 8
  %count = alloca i64, align 8
  %old_deactivate_mark = alloca i64, align 8
  %coerce149 = alloca %struct.timespec, align 8
  store i64 %timers, i64* %timers.addr, align 8
  store i64 %idle_timers, i64* %idle_timers.addr, align 8
  %call = call { i64, i64 } @invalid_timespec()
  %0 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call, 1
  store i64 %4, i64* %3, align 8
  %5 = bitcast %struct.timespec* %nexttime to i8*
  %6 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 16, i32 8, i1 false)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %chosen_timer, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %7 = load i64, i64* @pending_funcalls, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %8 = load i64, i64* @pending_funcalls, align 8
  %sub = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car, align 8
  store i64 %11, i64* %funcall, align 8
  %12 = load i64, i64* @pending_funcalls, align 8
  %sub3 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub3 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %15 = load i64, i64* %cdr, align 8
  store i64 %15, i64* @pending_funcalls, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 175)
  %16 = load i64, i64* %funcall, align 8
  %sub5 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub5 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %car6 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 0
  %19 = load i64, i64* %car6, align 8
  %20 = load i64, i64* %funcall, align 8
  %sub7 = sub nsw i64 %20, 3
  %21 = inttoptr i64 %sub7 to i8*
  %22 = bitcast i8* %21 to %struct.Lisp_Cons*
  %u8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %22, i32 0, i32 1
  %cdr9 = bitcast %union.anon.12* %u8 to i64*
  %23 = load i64, i64* %cdr9, align 8
  %call10 = call i64 @safe_call2(i64 %call4, i64 %19, i64 %23)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %24 = load i64, i64* %timers.addr, align 8
  %and11 = and i64 %24, 7
  %conv12 = trunc i64 %and11 to i32
  %cmp13 = icmp eq i32 %conv12, 3
  br i1 %cmp13, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.end
  %25 = load i64, i64* %idle_timers.addr, align 8
  %and15 = and i64 %25, 7
  %conv16 = trunc i64 %and15 to i32
  %cmp17 = icmp eq i32 %conv16, 3
  br i1 %cmp17, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %while.end
  %call19 = call { i64, i64 } @current_timespec()
  %26 = bitcast %struct.timespec* %coerce20 to { i64, i64 }*
  %27 = getelementptr { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = extractvalue { i64, i64 } %call19, 0
  store i64 %28, i64* %27, align 8
  %29 = getelementptr { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = extractvalue { i64, i64 } %call19, 1
  store i64 %30, i64* %29, align 8
  %31 = bitcast %struct.timespec* %now to i8*
  %32 = bitcast %struct.timespec* %coerce20 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %31, i8* %32, i64 16, i32 8, i1 false)
  %33 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %34 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call21 = call zeroext i1 @timespec_valid_p(i64 %33, i64 %34)
  br i1 %call21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %35 = bitcast %struct.timespec* %now to { i64, i64 }*
  %36 = getelementptr { i64, i64 }, { i64, i64 }* %35, i32 0, i32 0
  %37 = load i64, i64* %36, align 1
  %38 = getelementptr { i64, i64 }, { i64, i64 }* %35, i32 0, i32 1
  %39 = load i64, i64* %38, align 1
  %40 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %41 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call23 = call { i64, i64 } @timespec_sub(i64 %37, i64 %39, i64 %40, i64 %41) #14
  %42 = bitcast %struct.timespec* %coerce24 to { i64, i64 }*
  %43 = getelementptr { i64, i64 }, { i64, i64 }* %42, i32 0, i32 0
  %44 = extractvalue { i64, i64 } %call23, 0
  store i64 %44, i64* %43, align 8
  %45 = getelementptr { i64, i64 }, { i64, i64 }* %42, i32 0, i32 1
  %46 = extractvalue { i64, i64 } %call23, 1
  store i64 %46, i64* %45, align 8
  %47 = bitcast %struct.timespec* %idleness_now to i8*
  %48 = bitcast %struct.timespec* %coerce24 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %47, i8* %48, i64 16, i32 8, i1 false)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call25 = call { i64, i64 } @make_timespec(i64 0, i64 0)
  %49 = bitcast %struct.timespec* %coerce26 to { i64, i64 }*
  %50 = getelementptr { i64, i64 }, { i64, i64 }* %49, i32 0, i32 0
  %51 = extractvalue { i64, i64 } %call25, 0
  store i64 %51, i64* %50, align 8
  %52 = getelementptr { i64, i64 }, { i64, i64 }* %49, i32 0, i32 1
  %53 = extractvalue { i64, i64 } %call25, 1
  store i64 %53, i64* %52, align 8
  %54 = bitcast %struct.timespec* %idleness_now to i8*
  %55 = bitcast %struct.timespec* %coerce26 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 16, i32 8, i1 false)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %lor.lhs.false
  br label %while.cond.27

while.cond.27:                                    ; preds = %if.then.74, %if.then.49, %if.end
  %56 = load i64, i64* %timers.addr, align 8
  %and28 = and i64 %56, 7
  %conv29 = trunc i64 %and28 to i32
  %cmp30 = icmp eq i32 %conv29, 3
  br i1 %cmp30, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond.27
  %57 = load i64, i64* %idle_timers.addr, align 8
  %and32 = and i64 %57, 7
  %conv33 = trunc i64 %and32 to i32
  %cmp34 = icmp eq i32 %conv33, 3
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond.27
  %58 = phi i1 [ true, %while.cond.27 ], [ %cmp34, %lor.rhs ]
  br i1 %58, label %while.body.36, label %while.end.151

while.body.36:                                    ; preds = %lor.end
  %call37 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call37, i64* %timer, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call38, i64* %idle_timer, align 8
  %call39 = call { i64, i64 } @invalid_timespec()
  %59 = bitcast %struct.timespec* %timer_difference to { i64, i64 }*
  %60 = getelementptr { i64, i64 }, { i64, i64 }* %59, i32 0, i32 0
  %61 = extractvalue { i64, i64 } %call39, 0
  store i64 %61, i64* %60, align 8
  %62 = getelementptr { i64, i64 }, { i64, i64 }* %59, i32 0, i32 1
  %63 = extractvalue { i64, i64 } %call39, 1
  store i64 %63, i64* %62, align 8
  %call40 = call { i64, i64 } @invalid_timespec()
  %64 = bitcast %struct.timespec* %idle_timer_difference to { i64, i64 }*
  %65 = getelementptr { i64, i64 }, { i64, i64 }* %64, i32 0, i32 0
  %66 = extractvalue { i64, i64 } %call40, 0
  store i64 %66, i64* %65, align 8
  %67 = getelementptr { i64, i64 }, { i64, i64 }* %64, i32 0, i32 1
  %68 = extractvalue { i64, i64 } %call40, 1
  store i64 %68, i64* %67, align 8
  store i8 0, i8* %timer_ripe, align 1
  store i8 0, i8* %idle_timer_ripe, align 1
  %69 = load i64, i64* %timers.addr, align 8
  %and41 = and i64 %69, 7
  %conv42 = trunc i64 %and41 to i32
  %cmp43 = icmp eq i32 %conv42, 3
  br i1 %cmp43, label %if.then.45, label %if.end.65

if.then.45:                                       ; preds = %while.body.36
  %70 = load i64, i64* %timers.addr, align 8
  %sub46 = sub nsw i64 %70, 3
  %71 = inttoptr i64 %sub46 to i8*
  %72 = bitcast i8* %71 to %struct.Lisp_Cons*
  %car47 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %72, i32 0, i32 0
  %73 = load i64, i64* %car47, align 8
  store i64 %73, i64* %timer, align 8
  %74 = load i64, i64* %timer, align 8
  %call48 = call zeroext i1 @decode_timer(i64 %74, %struct.timespec* %timer_time)
  br i1 %call48, label %if.end.53, label %if.then.49

if.then.49:                                       ; preds = %if.then.45
  %75 = load i64, i64* %timers.addr, align 8
  %sub50 = sub nsw i64 %75, 3
  %76 = inttoptr i64 %sub50 to i8*
  %77 = bitcast i8* %76 to %struct.Lisp_Cons*
  %u51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %77, i32 0, i32 1
  %cdr52 = bitcast %union.anon.12* %u51 to i64*
  %78 = load i64, i64* %cdr52, align 8
  store i64 %78, i64* %timers.addr, align 8
  br label %while.cond.27

if.end.53:                                        ; preds = %if.then.45
  %79 = bitcast %struct.timespec* %timer_time to { i64, i64 }*
  %80 = getelementptr { i64, i64 }, { i64, i64 }* %79, i32 0, i32 0
  %81 = load i64, i64* %80, align 1
  %82 = getelementptr { i64, i64 }, { i64, i64 }* %79, i32 0, i32 1
  %83 = load i64, i64* %82, align 1
  %84 = bitcast %struct.timespec* %now to { i64, i64 }*
  %85 = getelementptr { i64, i64 }, { i64, i64 }* %84, i32 0, i32 0
  %86 = load i64, i64* %85, align 1
  %87 = getelementptr { i64, i64 }, { i64, i64 }* %84, i32 0, i32 1
  %88 = load i64, i64* %87, align 1
  %call54 = call i32 @timespec_cmp(i64 %81, i64 %83, i64 %86, i64 %88) #13
  %cmp55 = icmp sle i32 %call54, 0
  %frombool = zext i1 %cmp55 to i8
  store i8 %frombool, i8* %timer_ripe, align 1
  %89 = load i8, i8* %timer_ripe, align 1
  %tobool = trunc i8 %89 to i1
  br i1 %tobool, label %cond.true.58, label %cond.false.61

cond.true.58:                                     ; preds = %if.end.53
  %90 = bitcast %struct.timespec* %now to { i64, i64 }*
  %91 = getelementptr { i64, i64 }, { i64, i64 }* %90, i32 0, i32 0
  %92 = load i64, i64* %91, align 1
  %93 = getelementptr { i64, i64 }, { i64, i64 }* %90, i32 0, i32 1
  %94 = load i64, i64* %93, align 1
  %95 = bitcast %struct.timespec* %timer_time to { i64, i64 }*
  %96 = getelementptr { i64, i64 }, { i64, i64 }* %95, i32 0, i32 0
  %97 = load i64, i64* %96, align 1
  %98 = getelementptr { i64, i64 }, { i64, i64 }* %95, i32 0, i32 1
  %99 = load i64, i64* %98, align 1
  %call59 = call { i64, i64 } @timespec_sub(i64 %92, i64 %94, i64 %97, i64 %99) #14
  %100 = bitcast %struct.timespec* %coerce60 to { i64, i64 }*
  %101 = getelementptr { i64, i64 }, { i64, i64 }* %100, i32 0, i32 0
  %102 = extractvalue { i64, i64 } %call59, 0
  store i64 %102, i64* %101, align 8
  %103 = getelementptr { i64, i64 }, { i64, i64 }* %100, i32 0, i32 1
  %104 = extractvalue { i64, i64 } %call59, 1
  store i64 %104, i64* %103, align 8
  %105 = bitcast %struct.timespec* %timer_difference to i8*
  %106 = bitcast %struct.timespec* %coerce60 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %105, i8* %106, i64 16, i32 8, i1 false)
  br label %cond.end.64

cond.false.61:                                    ; preds = %if.end.53
  %107 = bitcast %struct.timespec* %timer_time to { i64, i64 }*
  %108 = getelementptr { i64, i64 }, { i64, i64 }* %107, i32 0, i32 0
  %109 = load i64, i64* %108, align 1
  %110 = getelementptr { i64, i64 }, { i64, i64 }* %107, i32 0, i32 1
  %111 = load i64, i64* %110, align 1
  %112 = bitcast %struct.timespec* %now to { i64, i64 }*
  %113 = getelementptr { i64, i64 }, { i64, i64 }* %112, i32 0, i32 0
  %114 = load i64, i64* %113, align 1
  %115 = getelementptr { i64, i64 }, { i64, i64 }* %112, i32 0, i32 1
  %116 = load i64, i64* %115, align 1
  %call62 = call { i64, i64 } @timespec_sub(i64 %109, i64 %111, i64 %114, i64 %116) #14
  %117 = bitcast %struct.timespec* %coerce63 to { i64, i64 }*
  %118 = getelementptr { i64, i64 }, { i64, i64 }* %117, i32 0, i32 0
  %119 = extractvalue { i64, i64 } %call62, 0
  store i64 %119, i64* %118, align 8
  %120 = getelementptr { i64, i64 }, { i64, i64 }* %117, i32 0, i32 1
  %121 = extractvalue { i64, i64 } %call62, 1
  store i64 %121, i64* %120, align 8
  %122 = bitcast %struct.timespec* %timer_difference to i8*
  %123 = bitcast %struct.timespec* %coerce63 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %122, i8* %123, i64 16, i32 8, i1 false)
  br label %cond.end.64

cond.end.64:                                      ; preds = %cond.false.61, %cond.true.58
  br label %if.end.65

if.end.65:                                        ; preds = %cond.end.64, %while.body.36
  %124 = load i64, i64* %idle_timers.addr, align 8
  %and66 = and i64 %124, 7
  %conv67 = trunc i64 %and66 to i32
  %cmp68 = icmp eq i32 %conv67, 3
  br i1 %cmp68, label %if.then.70, label %if.end.92

if.then.70:                                       ; preds = %if.end.65
  %125 = load i64, i64* %idle_timers.addr, align 8
  %sub71 = sub nsw i64 %125, 3
  %126 = inttoptr i64 %sub71 to i8*
  %127 = bitcast i8* %126 to %struct.Lisp_Cons*
  %car72 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %127, i32 0, i32 0
  %128 = load i64, i64* %car72, align 8
  store i64 %128, i64* %idle_timer, align 8
  %129 = load i64, i64* %idle_timer, align 8
  %call73 = call zeroext i1 @decode_timer(i64 %129, %struct.timespec* %idle_timer_time)
  br i1 %call73, label %if.end.78, label %if.then.74

if.then.74:                                       ; preds = %if.then.70
  %130 = load i64, i64* %idle_timers.addr, align 8
  %sub75 = sub nsw i64 %130, 3
  %131 = inttoptr i64 %sub75 to i8*
  %132 = bitcast i8* %131 to %struct.Lisp_Cons*
  %u76 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %132, i32 0, i32 1
  %cdr77 = bitcast %union.anon.12* %u76 to i64*
  %133 = load i64, i64* %cdr77, align 8
  store i64 %133, i64* %idle_timers.addr, align 8
  br label %while.cond.27

if.end.78:                                        ; preds = %if.then.70
  %134 = bitcast %struct.timespec* %idle_timer_time to { i64, i64 }*
  %135 = getelementptr { i64, i64 }, { i64, i64 }* %134, i32 0, i32 0
  %136 = load i64, i64* %135, align 1
  %137 = getelementptr { i64, i64 }, { i64, i64 }* %134, i32 0, i32 1
  %138 = load i64, i64* %137, align 1
  %139 = bitcast %struct.timespec* %idleness_now to { i64, i64 }*
  %140 = getelementptr { i64, i64 }, { i64, i64 }* %139, i32 0, i32 0
  %141 = load i64, i64* %140, align 1
  %142 = getelementptr { i64, i64 }, { i64, i64 }* %139, i32 0, i32 1
  %143 = load i64, i64* %142, align 1
  %call79 = call i32 @timespec_cmp(i64 %136, i64 %138, i64 %141, i64 %143) #13
  %cmp80 = icmp sle i32 %call79, 0
  %frombool82 = zext i1 %cmp80 to i8
  store i8 %frombool82, i8* %idle_timer_ripe, align 1
  %144 = load i8, i8* %idle_timer_ripe, align 1
  %tobool83 = trunc i8 %144 to i1
  br i1 %tobool83, label %cond.true.85, label %cond.false.88

cond.true.85:                                     ; preds = %if.end.78
  %145 = bitcast %struct.timespec* %idleness_now to { i64, i64 }*
  %146 = getelementptr { i64, i64 }, { i64, i64 }* %145, i32 0, i32 0
  %147 = load i64, i64* %146, align 1
  %148 = getelementptr { i64, i64 }, { i64, i64 }* %145, i32 0, i32 1
  %149 = load i64, i64* %148, align 1
  %150 = bitcast %struct.timespec* %idle_timer_time to { i64, i64 }*
  %151 = getelementptr { i64, i64 }, { i64, i64 }* %150, i32 0, i32 0
  %152 = load i64, i64* %151, align 1
  %153 = getelementptr { i64, i64 }, { i64, i64 }* %150, i32 0, i32 1
  %154 = load i64, i64* %153, align 1
  %call86 = call { i64, i64 } @timespec_sub(i64 %147, i64 %149, i64 %152, i64 %154) #14
  %155 = bitcast %struct.timespec* %coerce87 to { i64, i64 }*
  %156 = getelementptr { i64, i64 }, { i64, i64 }* %155, i32 0, i32 0
  %157 = extractvalue { i64, i64 } %call86, 0
  store i64 %157, i64* %156, align 8
  %158 = getelementptr { i64, i64 }, { i64, i64 }* %155, i32 0, i32 1
  %159 = extractvalue { i64, i64 } %call86, 1
  store i64 %159, i64* %158, align 8
  %160 = bitcast %struct.timespec* %idle_timer_difference to i8*
  %161 = bitcast %struct.timespec* %coerce87 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %160, i8* %161, i64 16, i32 8, i1 false)
  br label %cond.end.91

cond.false.88:                                    ; preds = %if.end.78
  %162 = bitcast %struct.timespec* %idle_timer_time to { i64, i64 }*
  %163 = getelementptr { i64, i64 }, { i64, i64 }* %162, i32 0, i32 0
  %164 = load i64, i64* %163, align 1
  %165 = getelementptr { i64, i64 }, { i64, i64 }* %162, i32 0, i32 1
  %166 = load i64, i64* %165, align 1
  %167 = bitcast %struct.timespec* %idleness_now to { i64, i64 }*
  %168 = getelementptr { i64, i64 }, { i64, i64 }* %167, i32 0, i32 0
  %169 = load i64, i64* %168, align 1
  %170 = getelementptr { i64, i64 }, { i64, i64 }* %167, i32 0, i32 1
  %171 = load i64, i64* %170, align 1
  %call89 = call { i64, i64 } @timespec_sub(i64 %164, i64 %166, i64 %169, i64 %171) #14
  %172 = bitcast %struct.timespec* %coerce90 to { i64, i64 }*
  %173 = getelementptr { i64, i64 }, { i64, i64 }* %172, i32 0, i32 0
  %174 = extractvalue { i64, i64 } %call89, 0
  store i64 %174, i64* %173, align 8
  %175 = getelementptr { i64, i64 }, { i64, i64 }* %172, i32 0, i32 1
  %176 = extractvalue { i64, i64 } %call89, 1
  store i64 %176, i64* %175, align 8
  %177 = bitcast %struct.timespec* %idle_timer_difference to i8*
  %178 = bitcast %struct.timespec* %coerce90 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %177, i8* %178, i64 16, i32 8, i1 false)
  br label %cond.end.91

cond.end.91:                                      ; preds = %cond.false.88, %cond.true.85
  br label %if.end.92

if.end.92:                                        ; preds = %cond.end.91, %if.end.65
  %179 = bitcast %struct.timespec* %timer_difference to { i64, i64 }*
  %180 = getelementptr { i64, i64 }, { i64, i64 }* %179, i32 0, i32 0
  %181 = load i64, i64* %180, align 1
  %182 = getelementptr { i64, i64 }, { i64, i64 }* %179, i32 0, i32 1
  %183 = load i64, i64* %182, align 1
  %call93 = call zeroext i1 @timespec_valid_p(i64 %181, i64 %183)
  br i1 %call93, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end.92
  %184 = bitcast %struct.timespec* %idle_timer_difference to { i64, i64 }*
  %185 = getelementptr { i64, i64 }, { i64, i64 }* %184, i32 0, i32 0
  %186 = load i64, i64* %185, align 1
  %187 = getelementptr { i64, i64 }, { i64, i64 }* %184, i32 0, i32 1
  %188 = load i64, i64* %187, align 1
  %call95 = call zeroext i1 @timespec_valid_p(i64 %186, i64 %188)
  br i1 %call95, label %lor.lhs.false.96, label %if.then.120

lor.lhs.false.96:                                 ; preds = %land.lhs.true
  %189 = load i8, i8* %idle_timer_ripe, align 1
  %tobool97 = trunc i8 %189 to i1
  %conv98 = zext i1 %tobool97 to i32
  %190 = load i8, i8* %timer_ripe, align 1
  %tobool99 = trunc i8 %190 to i1
  %conv100 = zext i1 %tobool99 to i32
  %cmp101 = icmp slt i32 %conv98, %conv100
  br i1 %cmp101, label %if.then.120, label %lor.lhs.false.103

lor.lhs.false.103:                                ; preds = %lor.lhs.false.96
  %191 = load i8, i8* %idle_timer_ripe, align 1
  %tobool104 = trunc i8 %191 to i1
  %conv105 = zext i1 %tobool104 to i32
  %192 = load i8, i8* %timer_ripe, align 1
  %tobool106 = trunc i8 %192 to i1
  %conv107 = zext i1 %tobool106 to i32
  %cmp108 = icmp eq i32 %conv105, %conv107
  br i1 %cmp108, label %land.lhs.true.110, label %if.else

land.lhs.true.110:                                ; preds = %lor.lhs.false.103
  %193 = load i8, i8* %timer_ripe, align 1
  %tobool111 = trunc i8 %193 to i1
  br i1 %tobool111, label %cond.true.113, label %cond.false.115

cond.true.113:                                    ; preds = %land.lhs.true.110
  %194 = bitcast %struct.timespec* %idle_timer_difference to { i64, i64 }*
  %195 = getelementptr { i64, i64 }, { i64, i64 }* %194, i32 0, i32 0
  %196 = load i64, i64* %195, align 1
  %197 = getelementptr { i64, i64 }, { i64, i64 }* %194, i32 0, i32 1
  %198 = load i64, i64* %197, align 1
  %199 = bitcast %struct.timespec* %timer_difference to { i64, i64 }*
  %200 = getelementptr { i64, i64 }, { i64, i64 }* %199, i32 0, i32 0
  %201 = load i64, i64* %200, align 1
  %202 = getelementptr { i64, i64 }, { i64, i64 }* %199, i32 0, i32 1
  %203 = load i64, i64* %202, align 1
  %call114 = call i32 @timespec_cmp(i64 %196, i64 %198, i64 %201, i64 %203) #13
  br label %cond.end.117

cond.false.115:                                   ; preds = %land.lhs.true.110
  %204 = bitcast %struct.timespec* %timer_difference to { i64, i64 }*
  %205 = getelementptr { i64, i64 }, { i64, i64 }* %204, i32 0, i32 0
  %206 = load i64, i64* %205, align 1
  %207 = getelementptr { i64, i64 }, { i64, i64 }* %204, i32 0, i32 1
  %208 = load i64, i64* %207, align 1
  %209 = bitcast %struct.timespec* %idle_timer_difference to { i64, i64 }*
  %210 = getelementptr { i64, i64 }, { i64, i64 }* %209, i32 0, i32 0
  %211 = load i64, i64* %210, align 1
  %212 = getelementptr { i64, i64 }, { i64, i64 }* %209, i32 0, i32 1
  %213 = load i64, i64* %212, align 1
  %call116 = call i32 @timespec_cmp(i64 %206, i64 %208, i64 %211, i64 %213) #13
  br label %cond.end.117

cond.end.117:                                     ; preds = %cond.false.115, %cond.true.113
  %cond = phi i32 [ %call114, %cond.true.113 ], [ %call116, %cond.false.115 ]
  %cmp118 = icmp slt i32 %cond, 0
  br i1 %cmp118, label %if.then.120, label %if.else

if.then.120:                                      ; preds = %cond.end.117, %lor.lhs.false.96, %land.lhs.true
  %214 = load i64, i64* %timer, align 8
  store i64 %214, i64* %chosen_timer, align 8
  %215 = load i64, i64* %timers.addr, align 8
  %sub121 = sub nsw i64 %215, 3
  %216 = inttoptr i64 %sub121 to i8*
  %217 = bitcast i8* %216 to %struct.Lisp_Cons*
  %u122 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %217, i32 0, i32 1
  %cdr123 = bitcast %union.anon.12* %u122 to i64*
  %218 = load i64, i64* %cdr123, align 8
  store i64 %218, i64* %timers.addr, align 8
  %219 = bitcast %struct.timespec* %difference to i8*
  %220 = bitcast %struct.timespec* %timer_difference to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %219, i8* %220, i64 16, i32 8, i1 false)
  %221 = load i8, i8* %timer_ripe, align 1
  %tobool124 = trunc i8 %221 to i1
  %frombool125 = zext i1 %tobool124 to i8
  store i8 %frombool125, i8* %ripe, align 1
  br label %if.end.131

if.else:                                          ; preds = %cond.end.117, %lor.lhs.false.103, %if.end.92
  %222 = load i64, i64* %idle_timer, align 8
  store i64 %222, i64* %chosen_timer, align 8
  %223 = load i64, i64* %idle_timers.addr, align 8
  %sub126 = sub nsw i64 %223, 3
  %224 = inttoptr i64 %sub126 to i8*
  %225 = bitcast i8* %224 to %struct.Lisp_Cons*
  %u127 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %225, i32 0, i32 1
  %cdr128 = bitcast %union.anon.12* %u127 to i64*
  %226 = load i64, i64* %cdr128, align 8
  store i64 %226, i64* %idle_timers.addr, align 8
  %227 = bitcast %struct.timespec* %difference to i8*
  %228 = bitcast %struct.timespec* %idle_timer_difference to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %227, i8* %228, i64 16, i32 8, i1 false)
  %229 = load i8, i8* %idle_timer_ripe, align 1
  %tobool129 = trunc i8 %229 to i1
  %frombool130 = zext i1 %tobool129 to i8
  store i8 %frombool130, i8* %ripe, align 1
  br label %if.end.131

if.end.131:                                       ; preds = %if.else, %if.then.120
  %230 = load i8, i8* %ripe, align 1
  %tobool132 = trunc i8 %230 to i1
  br i1 %tobool132, label %if.then.133, label %if.else.150

if.then.133:                                      ; preds = %if.end.131
  %231 = load i64, i64* %chosen_timer, align 8
  %call134 = call i64 @AREF(i64 %231, i64 0)
  %call135 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp136 = icmp eq i64 %call134, %call135
  br i1 %cmp136, label %if.then.138, label %if.end.147

if.then.138:                                      ; preds = %if.then.133
  %call139 = call i64 @SPECPDL_INDEX()
  store i64 %call139, i64* %count, align 8
  %232 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  store i64 %232, i64* %old_deactivate_mark, align 8
  %233 = load i64, i64* %chosen_timer, align 8
  %call140 = call i64 @builtin_lisp_symbol(i32 901)
  call void @ASET(i64 %233, i64 0, i64 %call140)
  %call141 = call i64 @builtin_lisp_symbol(i32 546)
  %call142 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call141, i64 %call142)
  %call143 = call i64 @builtin_lisp_symbol(i32 918)
  %234 = load i64, i64* %chosen_timer, align 8
  %call144 = call i64 @call1(i64 %call143, i64 %234)
  %235 = load i64, i64* %old_deactivate_mark, align 8
  store i64 %235, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %236 = load i32, i32* @timers_run, align 4
  %inc = add i32 %236, 1
  store i32 %inc, i32* @timers_run, align 4
  %237 = load i64, i64* %count, align 8
  %call145 = call i64 @builtin_lisp_symbol(i32 0)
  %call146 = call i64 @unbind_to(i64 %237, i64 %call145)
  br label %if.end.147

if.end.147:                                       ; preds = %if.then.138, %if.then.133
  %call148 = call { i64, i64 } @make_timespec(i64 0, i64 0)
  %238 = bitcast %struct.timespec* %coerce149 to { i64, i64 }*
  %239 = getelementptr { i64, i64 }, { i64, i64 }* %238, i32 0, i32 0
  %240 = extractvalue { i64, i64 } %call148, 0
  store i64 %240, i64* %239, align 8
  %241 = getelementptr { i64, i64 }, { i64, i64 }* %238, i32 0, i32 1
  %242 = extractvalue { i64, i64 } %call148, 1
  store i64 %242, i64* %241, align 8
  %243 = bitcast %struct.timespec* %nexttime to i8*
  %244 = bitcast %struct.timespec* %coerce149 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %243, i8* %244, i64 16, i32 8, i1 false)
  br label %while.end.151

if.else.150:                                      ; preds = %if.end.131
  %245 = bitcast %struct.timespec* %retval to i8*
  %246 = bitcast %struct.timespec* %difference to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %245, i8* %246, i64 16, i32 8, i1 false)
  br label %return

while.end.151:                                    ; preds = %if.end.147, %lor.end
  %247 = bitcast %struct.timespec* %retval to i8*
  %248 = bitcast %struct.timespec* %nexttime to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %247, i8* %248, i64 16, i32 8, i1 false)
  br label %return

return:                                           ; preds = %while.end.151, %if.else.150
  %249 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %250 = load { i64, i64 }, { i64, i64 }* %249, align 8
  ret { i64, i64 } %250
}

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_idle_time() #0 {
entry:
  %retval = alloca i64, align 8
  %agg.tmp = alloca %struct.timespec, align 8
  %agg.tmp1 = alloca %struct.timespec, align 8
  %0 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %1 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call = call zeroext i1 @timespec_valid_p(i64 %0, i64 %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call { i64, i64 } @current_timespec()
  %2 = bitcast %struct.timespec* %agg.tmp1 to { i64, i64 }*
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call2, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call2, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.timespec* %agg.tmp1 to { i64, i64 }*
  %8 = getelementptr { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 1
  %10 = getelementptr { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 1
  %12 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 0), align 1
  %13 = load i64, i64* getelementptr ({ i64, i64 }, { i64, i64 }* bitcast (%struct.timespec* @timer_idleness_start_time to { i64, i64 }*), i32 0, i32 1), align 1
  %call3 = call { i64, i64 } @timespec_sub(i64 %9, i64 %11, i64 %12, i64 %13) #14
  %14 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %15 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call3, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call3, 1
  store i64 %18, i64* %17, align 8
  %19 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %20 = getelementptr { i64, i64 }, { i64, i64 }* %19, i32 0, i32 0
  %21 = load i64, i64* %20, align 1
  %22 = getelementptr { i64, i64 }, { i64, i64 }* %19, i32 0, i32 1
  %23 = load i64, i64* %22, align 1
  %call4 = call i64 @make_lisp_time(i64 %21, i64 %23)
  store i64 %call4, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %24 = load i64, i64* %retval
  ret i64 %24
}

declare i64 @make_lisp_time(i64, i64) #1

; Function Attrs: nounwind readnone
declare { i64, i64 } @timespec_sub(i64, i64, i64, i64) #9

; Function Attrs: nounwind uwtable
define i64 @parse_modifiers(i64 %symbol) #0 {
entry:
  %retval = alloca i64, align 8
  %symbol.addr = alloca i64, align 8
  %elements = alloca i64, align 8
  %end = alloca i64, align 8
  %modifiers = alloca i32, align 4
  %unmodified = alloca i64, align 8
  %mask = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %symbol.addr, align 8
  %shr = ashr i64 %1, 2
  %and3 = and i64 %shr, 4194303
  %2 = load i64, i64* %symbol.addr, align 8
  %shr4 = ashr i64 %2, 2
  %and5 = and i64 %shr4, 264241152
  %call = call i64 @list2i(i64 %and3, i64 %and5)
  store i64 %call, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i64, i64* %symbol.addr, align 8
  %and6 = and i64 %3, 7
  %conv7 = trunc i64 %and6 to i32
  %cmp8 = icmp eq i32 %conv7, 0
  br i1 %cmp8, label %if.end, label %if.then.10

if.then.10:                                       ; preds = %if.else
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call11, i64* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end.12

if.end.12:                                        ; preds = %if.end
  %4 = load i64, i64* %symbol.addr, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 383)
  %call14 = call i64 @Fget(i64 %4, i64 %call13)
  store i64 %call14, i64* %elements, align 8
  %5 = load i64, i64* %elements, align 8
  %and15 = and i64 %5, 7
  %conv16 = trunc i64 %and15 to i32
  %cmp17 = icmp eq i32 %conv16, 3
  br i1 %cmp17, label %if.then.19, label %if.else.20

if.then.19:                                       ; preds = %if.end.12
  %6 = load i64, i64* %elements, align 8
  store i64 %6, i64* %retval
  br label %return

if.else.20:                                       ; preds = %if.end.12
  %7 = load i64, i64* %symbol.addr, align 8
  %call21 = call i32 @parse_modifiers_uncached(i64 %7, i64* %end)
  store i32 %call21, i32* %modifiers, align 4
  %8 = load i64, i64* %symbol.addr, align 8
  %call22 = call i64 @SYMBOL_NAME(i64 %8)
  %call23 = call i8* @SSDATA(i64 %call22)
  %9 = load i64, i64* %end, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call23, i64 %9
  %10 = load i64, i64* %symbol.addr, align 8
  %call24 = call i64 @SYMBOL_NAME(i64 %10)
  %call25 = call i64 @SBYTES(i64 %call24)
  %11 = load i64, i64* %end, align 8
  %sub = sub nsw i64 %call25, %11
  %call26 = call i64 @make_string(i8* %add.ptr, i64 %sub)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @Fintern(i64 %call26, i64 %call27)
  store i64 %call28, i64* %unmodified, align 8
  %12 = load i32, i32* %modifiers, align 4
  %conv29 = sext i32 %12 to i64
  %and30 = and i64 %conv29, -4611686018427387904
  %tobool = icmp ne i64 %and30, 0
  br i1 %tobool, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %if.else.20
  call void @emacs_abort() #11
  unreachable

if.end.32:                                        ; preds = %if.else.20
  %13 = load i32, i32* %modifiers, align 4
  %conv33 = sext i32 %13 to i64
  %call34 = call i64 @make_natnum(i64 %conv33)
  store i64 %call34, i64* %mask, align 8
  %14 = load i64, i64* %unmodified, align 8
  %15 = load i64, i64* %mask, align 8
  %call35 = call i64 @list2(i64 %14, i64 %15)
  store i64 %call35, i64* %elements, align 8
  %16 = load i64, i64* %symbol.addr, align 8
  %call36 = call i64 @builtin_lisp_symbol(i32 383)
  %17 = load i64, i64* %elements, align 8
  %call37 = call i64 @Fput(i64 %16, i64 %call36, i64 %17)
  %18 = load i64, i64* %symbol.addr, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 384)
  %19 = load i64, i64* %unmodified, align 8
  %20 = load i32, i32* %modifiers, align 4
  %call39 = call i64 @lispy_modifier_list(i32 %20)
  %call40 = call i64 @Fcons(i64 %19, i64 %call39)
  %call41 = call i64 @Fput(i64 %18, i64 %call38, i64 %call40)
  %21 = load i64, i64* %elements, align 8
  store i64 %21, i64* %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then.19, %if.then.10, %if.then
  %22 = load i64, i64* %retval
  ret i64 %22
}

declare i64 @list2i(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @parse_modifiers_uncached(i64 %symbol, i64* %modifier_end) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %modifier_end.addr = alloca i64*, align 8
  %name = alloca i64, align 8
  %i = alloca i64, align 8
  %modifiers = alloca i32, align 4
  %this_mod_end = alloca i64, align 8
  %this_mod = alloca i32, align 4
  store i64 %symbol, i64* %symbol.addr, align 8
  store i64* %modifier_end, i64** %modifier_end.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  store i32 0, i32* %modifiers, align 4
  %4 = load i64, i64* %symbol.addr, align 8
  %call2 = call i64 @SYMBOL_NAME(i64 %4)
  store i64 %call2, i64* %name, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end.93, %cond.end
  %5 = load i64, i64* %i, align 8
  %6 = load i64, i64* %name, align 8
  %call3 = call i64 @SBYTES(i64 %6)
  %sub = sub nsw i64 %call3, 1
  %cmp4 = icmp slt i64 %5, %sub
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %this_mod_end, align 8
  store i32 0, i32* %this_mod, align 4
  %7 = load i64, i64* %name, align 8
  %8 = load i64, i64* %i, align 8
  %call6 = call zeroext i8 @SREF(i64 %7, i64 %8)
  %conv7 = zext i8 %call6 to i32
  switch i32 %conv7, label %sw.epilog [
    i32 65, label %sw.bb
    i32 67, label %sw.bb.8
    i32 72, label %sw.bb.10
    i32 77, label %sw.bb.12
    i32 83, label %sw.bb.14
    i32 115, label %sw.bb.16
    i32 100, label %sw.bb.18
    i32 116, label %sw.bb.53
    i32 117, label %sw.bb.67
  ]

sw.bb:                                            ; preds = %for.body
  %9 = load i64, i64* %i, align 8
  %add = add nsw i64 %9, 1
  store i64 %add, i64* %this_mod_end, align 8
  store i32 4194304, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.8:                                          ; preds = %for.body
  %10 = load i64, i64* %i, align 8
  %add9 = add nsw i64 %10, 1
  store i64 %add9, i64* %this_mod_end, align 8
  store i32 67108864, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.10:                                         ; preds = %for.body
  %11 = load i64, i64* %i, align 8
  %add11 = add nsw i64 %11, 1
  store i64 %add11, i64* %this_mod_end, align 8
  store i32 16777216, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.12:                                         ; preds = %for.body
  %12 = load i64, i64* %i, align 8
  %add13 = add nsw i64 %12, 1
  store i64 %add13, i64* %this_mod_end, align 8
  store i32 134217728, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.14:                                         ; preds = %for.body
  %13 = load i64, i64* %i, align 8
  %add15 = add nsw i64 %13, 1
  store i64 %add15, i64* %this_mod_end, align 8
  store i32 33554432, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.16:                                         ; preds = %for.body
  %14 = load i64, i64* %i, align 8
  %add17 = add nsw i64 %14, 1
  store i64 %add17, i64* %this_mod_end, align 8
  store i32 8388608, i32* %this_mod, align 4
  br label %sw.epilog

sw.bb.18:                                         ; preds = %for.body
  %15 = load i64, i64* %i, align 8
  %add19 = add nsw i64 %15, 4
  %add20 = add nsw i64 %add19, 1
  %16 = load i64, i64* %name, align 8
  %call21 = call i64 @SBYTES(i64 %16)
  %cmp22 = icmp sle i64 %add20, %call21
  br i1 %cmp22, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb.18
  %17 = load i64, i64* %name, align 8
  %call24 = call i8* @SDATA(i64 %17)
  %18 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call24, i64 %18
  %call25 = call i32 @memcmp(i8* %add.ptr, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0), i64 4) #13
  %tobool = icmp ne i32 %call25, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %19 = load i64, i64* %i, align 8
  %add26 = add nsw i64 %19, 4
  store i64 %add26, i64* %this_mod_end, align 8
  store i32 4, i32* %this_mod, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %sw.bb.18
  %20 = load i64, i64* %i, align 8
  %add27 = add nsw i64 %20, 4
  %add28 = add nsw i64 %add27, 1
  %21 = load i64, i64* %name, align 8
  %call29 = call i64 @SBYTES(i64 %21)
  %cmp30 = icmp sle i64 %add28, %call29
  br i1 %cmp30, label %land.lhs.true.32, label %if.end.39

land.lhs.true.32:                                 ; preds = %if.end
  %22 = load i64, i64* %name, align 8
  %call33 = call i8* @SDATA(i64 %22)
  %23 = load i64, i64* %i, align 8
  %add.ptr34 = getelementptr inbounds i8, i8* %call33, i64 %23
  %call35 = call i32 @memcmp(i8* %add.ptr34, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i64 4) #13
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.end.39, label %if.then.37

if.then.37:                                       ; preds = %land.lhs.true.32
  %24 = load i64, i64* %i, align 8
  %add38 = add nsw i64 %24, 4
  store i64 %add38, i64* %this_mod_end, align 8
  store i32 2, i32* %this_mod, align 4
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.37, %land.lhs.true.32, %if.end
  %25 = load i64, i64* %i, align 8
  %add40 = add nsw i64 %25, 6
  %add41 = add nsw i64 %add40, 1
  %26 = load i64, i64* %name, align 8
  %call42 = call i64 @SBYTES(i64 %26)
  %cmp43 = icmp sle i64 %add41, %call42
  br i1 %cmp43, label %land.lhs.true.45, label %if.end.52

land.lhs.true.45:                                 ; preds = %if.end.39
  %27 = load i64, i64* %name, align 8
  %call46 = call i8* @SDATA(i64 %27)
  %28 = load i64, i64* %i, align 8
  %add.ptr47 = getelementptr inbounds i8, i8* %call46, i64 %28
  %call48 = call i32 @memcmp(i8* %add.ptr47, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.15, i32 0, i32 0), i64 6) #13
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.end.52, label %if.then.50

if.then.50:                                       ; preds = %land.lhs.true.45
  %29 = load i64, i64* %i, align 8
  %add51 = add nsw i64 %29, 6
  store i64 %add51, i64* %this_mod_end, align 8
  store i32 16, i32* %this_mod, align 4
  br label %if.end.52

if.end.52:                                        ; preds = %if.then.50, %land.lhs.true.45, %if.end.39
  br label %sw.epilog

sw.bb.53:                                         ; preds = %for.body
  %30 = load i64, i64* %i, align 8
  %add54 = add nsw i64 %30, 6
  %add55 = add nsw i64 %add54, 1
  %31 = load i64, i64* %name, align 8
  %call56 = call i64 @SBYTES(i64 %31)
  %cmp57 = icmp sle i64 %add55, %call56
  br i1 %cmp57, label %land.lhs.true.59, label %if.end.66

land.lhs.true.59:                                 ; preds = %sw.bb.53
  %32 = load i64, i64* %name, align 8
  %call60 = call i8* @SDATA(i64 %32)
  %33 = load i64, i64* %i, align 8
  %add.ptr61 = getelementptr inbounds i8, i8* %call60, i64 %33
  %call62 = call i32 @memcmp(i8* %add.ptr61, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.16, i32 0, i32 0), i64 6) #13
  %tobool63 = icmp ne i32 %call62, 0
  br i1 %tobool63, label %if.end.66, label %if.then.64

if.then.64:                                       ; preds = %land.lhs.true.59
  %34 = load i64, i64* %i, align 8
  %add65 = add nsw i64 %34, 6
  store i64 %add65, i64* %this_mod_end, align 8
  store i32 32, i32* %this_mod, align 4
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.64, %land.lhs.true.59, %sw.bb.53
  br label %sw.epilog

sw.bb.67:                                         ; preds = %for.body
  %35 = load i64, i64* %i, align 8
  %add68 = add nsw i64 %35, 2
  %add69 = add nsw i64 %add68, 1
  %36 = load i64, i64* %name, align 8
  %call70 = call i64 @SBYTES(i64 %36)
  %cmp71 = icmp sle i64 %add69, %call70
  br i1 %cmp71, label %land.lhs.true.73, label %if.end.80

land.lhs.true.73:                                 ; preds = %sw.bb.67
  %37 = load i64, i64* %name, align 8
  %call74 = call i8* @SDATA(i64 %37)
  %38 = load i64, i64* %i, align 8
  %add.ptr75 = getelementptr inbounds i8, i8* %call74, i64 %38
  %call76 = call i32 @memcmp(i8* %add.ptr75, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0), i64 2) #13
  %tobool77 = icmp ne i32 %call76, 0
  br i1 %tobool77, label %if.end.80, label %if.then.78

if.then.78:                                       ; preds = %land.lhs.true.73
  %39 = load i64, i64* %i, align 8
  %add79 = add nsw i64 %39, 2
  store i64 %add79, i64* %this_mod_end, align 8
  store i32 1, i32* %this_mod, align 4
  br label %if.end.80

if.end.80:                                        ; preds = %if.then.78, %land.lhs.true.73, %sw.bb.67
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body, %if.end.80, %if.end.66, %if.end.52, %sw.bb.16, %sw.bb.14, %sw.bb.12, %sw.bb.10, %sw.bb.8, %sw.bb
  %40 = load i64, i64* %this_mod_end, align 8
  %cmp81 = icmp eq i64 %40, 0
  br i1 %cmp81, label %if.then.83, label %if.end.84

if.then.83:                                       ; preds = %sw.epilog
  br label %for.end

if.end.84:                                        ; preds = %sw.epilog
  %41 = load i64, i64* %this_mod_end, align 8
  %42 = load i64, i64* %name, align 8
  %call85 = call i64 @SBYTES(i64 %42)
  %cmp86 = icmp sge i64 %41, %call85
  br i1 %cmp86, label %if.then.92, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.84
  %43 = load i64, i64* %name, align 8
  %44 = load i64, i64* %this_mod_end, align 8
  %call88 = call zeroext i8 @SREF(i64 %43, i64 %44)
  %conv89 = zext i8 %call88 to i32
  %cmp90 = icmp ne i32 %conv89, 45
  br i1 %cmp90, label %if.then.92, label %if.end.93

if.then.92:                                       ; preds = %lor.lhs.false, %if.end.84
  br label %for.end

if.end.93:                                        ; preds = %lor.lhs.false
  %45 = load i32, i32* %this_mod, align 4
  %46 = load i32, i32* %modifiers, align 4
  %or = or i32 %46, %45
  store i32 %or, i32* %modifiers, align 4
  %47 = load i64, i64* %this_mod_end, align 8
  %add94 = add nsw i64 %47, 1
  store i64 %add94, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.92, %if.then.83, %for.cond
  %48 = load i32, i32* %modifiers, align 4
  %and95 = and i32 %48, 54
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.end.122, label %land.lhs.true.97

land.lhs.true.97:                                 ; preds = %for.end
  %49 = load i64, i64* %i, align 8
  %add98 = add nsw i64 %49, 7
  %50 = load i64, i64* %name, align 8
  %call99 = call i64 @SBYTES(i64 %50)
  %cmp100 = icmp eq i64 %add98, %call99
  br i1 %cmp100, label %land.lhs.true.102, label %if.end.122

land.lhs.true.102:                                ; preds = %land.lhs.true.97
  %51 = load i64, i64* %name, align 8
  %call103 = call i8* @SDATA(i64 %51)
  %52 = load i64, i64* %i, align 8
  %add.ptr104 = getelementptr inbounds i8, i8* %call103, i64 %52
  %call105 = call i32 @memcmp(i8* %add.ptr104, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.356, i32 0, i32 0), i64 6) #13
  %cmp106 = icmp eq i32 %call105, 0
  br i1 %cmp106, label %land.lhs.true.108, label %if.end.122

land.lhs.true.108:                                ; preds = %land.lhs.true.102
  %53 = load i64, i64* %name, align 8
  %54 = load i64, i64* %i, align 8
  %add109 = add nsw i64 %54, 6
  %call110 = call zeroext i8 @SREF(i64 %53, i64 %add109)
  %conv111 = zext i8 %call110 to i32
  %cmp112 = icmp sle i32 48, %conv111
  br i1 %cmp112, label %land.lhs.true.114, label %if.end.122

land.lhs.true.114:                                ; preds = %land.lhs.true.108
  %55 = load i64, i64* %name, align 8
  %56 = load i64, i64* %i, align 8
  %add115 = add nsw i64 %56, 6
  %call116 = call zeroext i8 @SREF(i64 %55, i64 %add115)
  %conv117 = zext i8 %call116 to i32
  %cmp118 = icmp sle i32 %conv117, 57
  br i1 %cmp118, label %if.then.120, label %if.end.122

if.then.120:                                      ; preds = %land.lhs.true.114
  %57 = load i32, i32* %modifiers, align 4
  %or121 = or i32 %57, 8
  store i32 %or121, i32* %modifiers, align 4
  br label %if.end.122

if.end.122:                                       ; preds = %if.then.120, %land.lhs.true.114, %land.lhs.true.108, %land.lhs.true.102, %land.lhs.true.97, %for.end
  %58 = load i32, i32* %modifiers, align 4
  %and123 = and i32 %58, 48
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.end.138, label %land.lhs.true.125

land.lhs.true.125:                                ; preds = %if.end.122
  %59 = load i64, i64* %i, align 8
  %add126 = add nsw i64 %59, 6
  %60 = load i64, i64* %name, align 8
  %call127 = call i64 @SBYTES(i64 %60)
  %cmp128 = icmp slt i64 %add126, %call127
  br i1 %cmp128, label %land.lhs.true.130, label %if.end.138

land.lhs.true.130:                                ; preds = %land.lhs.true.125
  %61 = load i64, i64* %name, align 8
  %call131 = call i8* @SDATA(i64 %61)
  %62 = load i64, i64* %i, align 8
  %add.ptr132 = getelementptr inbounds i8, i8* %call131, i64 %62
  %call133 = call i32 @memcmp(i8* %add.ptr132, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.357, i32 0, i32 0), i64 6) #13
  %cmp134 = icmp eq i32 %call133, 0
  br i1 %cmp134, label %if.then.136, label %if.end.138

if.then.136:                                      ; preds = %land.lhs.true.130
  %63 = load i32, i32* %modifiers, align 4
  %or137 = or i32 %63, 8
  store i32 %or137, i32* %modifiers, align 4
  br label %if.end.138

if.end.138:                                       ; preds = %if.then.136, %land.lhs.true.130, %land.lhs.true.125, %if.end.122
  %64 = load i64*, i64** %modifier_end.addr, align 8
  %tobool139 = icmp ne i64* %64, null
  br i1 %tobool139, label %if.then.140, label %if.end.141

if.then.140:                                      ; preds = %if.end.138
  %65 = load i64, i64* %i, align 8
  %66 = load i64*, i64** %modifier_end.addr, align 8
  store i64 %65, i64* %66, align 8
  br label %if.end.141

if.end.141:                                       ; preds = %if.then.140, %if.end.138
  %67 = load i32, i32* %modifiers, align 4
  ret i32 %67
}

declare i64 @Fintern(i64, i64) #1

declare i64 @make_string(i8*, i64) #1

declare i64 @SYMBOL_NAME(i64) #1

declare i64 @SBYTES(i64) #1

declare i64 @Fput(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @lispy_modifier_list(i32 %modifiers) #0 {
entry:
  %modifiers.addr = alloca i32, align 4
  %modifier_list = alloca i64, align 8
  %i = alloca i32, align 4
  store i32 %modifiers, i32* %modifiers.addr, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %modifier_list, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %shl = shl i32 1, %0
  %1 = load i32, i32* %modifiers.addr, align 4
  %cmp = icmp sle i32 %shl, %1
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %conv = sext i32 %2 to i64
  %cmp1 = icmp ult i64 %conv, 28
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %3 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %3, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %4 = load i32, i32* %modifiers.addr, align 4
  %5 = load i32, i32* %i, align 4
  %shl3 = shl i32 1, %5
  %and = and i32 %4, %shl3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %6 = load i64, i64* @modifier_symbols, align 8
  %7 = load i32, i32* %i, align 4
  %conv4 = sext i32 %7 to i64
  %call5 = call i64 @AREF(i64 %6, i64 %conv4)
  %8 = load i64, i64* %modifier_list, align 8
  %call6 = call i64 @Fcons(i64 %call5, i64 %8)
  store i64 %call6, i64* %modifier_list, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  %10 = load i64, i64* %modifier_list, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define i64 @Fevent_symbol_parse_modifiers(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %call = call i64 @parse_modifiers(i64 %0)
  %1 = load i64, i64* %symbol.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 384)
  %call2 = call i64 @Fget(i64 %1, i64 %call1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @reorder_modifiers(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %parsed = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %call = call i64 @parse_modifiers(i64 %0)
  store i64 %call, i64* %parsed, align 8
  %1 = load i64, i64* %parsed, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %4 = load i64, i64* %cdr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 0
  %7 = load i64, i64* %car, align 8
  %shr = ashr i64 %7, 2
  %conv = trunc i64 %shr to i32
  %8 = load i64, i64* %parsed, align 8
  %sub2 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub2 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car3 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car3, align 8
  %call4 = call i64 @apply_modifiers(i32 %conv, i64 %11)
  ret i64 %call4
}

; Function Attrs: nounwind uwtable
define internal i64 @apply_modifiers(i32 %modifiers, i64 %base) #0 {
entry:
  %retval = alloca i64, align 8
  %modifiers.addr = alloca i32, align 4
  %base.addr = alloca i64, align 8
  %cache = alloca i64, align 8
  %idx = alloca i64, align 8
  %entry1 = alloca i64, align 8
  %new_symbol = alloca i64, align 8
  %kind = alloca i64, align 8
  store i32 %modifiers, i32* %modifiers.addr, align 4
  store i64 %base, i64* %base.addr, align 8
  %0 = load i32, i32* %modifiers.addr, align 4
  %conv = sext i32 %0 to i64
  %and = and i64 %conv, 4611686018427387903
  %conv2 = trunc i64 %and to i32
  store i32 %conv2, i32* %modifiers.addr, align 4
  %1 = load i64, i64* %base.addr, align 8
  %and3 = and i64 %1, 7
  %conv4 = trunc i64 %and3 to i32
  %and5 = and i32 %conv4, -5
  %cmp = icmp eq i32 %and5, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %base.addr, align 8
  %shr = ashr i64 %2, 2
  %3 = load i32, i32* %modifiers.addr, align 4
  %conv7 = sext i32 %3 to i64
  %or = or i64 %shr, %conv7
  %shl = shl i64 %or, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %base.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 677)
  %call8 = call i64 @Fget(i64 %4, i64 %call)
  store i64 %call8, i64* %cache, align 8
  %5 = load i32, i32* %modifiers.addr, align 4
  %and9 = and i32 %5, -9
  %conv10 = sext i32 %and9 to i64
  %call11 = call i64 @make_natnum(i64 %conv10)
  store i64 %call11, i64* %idx, align 8
  %6 = load i64, i64* %idx, align 8
  %7 = load i64, i64* %cache, align 8
  %call12 = call i64 @assq_no_quit(i64 %6, i64 %7)
  store i64 %call12, i64* %entry1, align 8
  %8 = load i64, i64* %entry1, align 8
  %and13 = and i64 %8, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %if.then.17, label %if.else

if.then.17:                                       ; preds = %if.end
  %9 = load i64, i64* %entry1, align 8
  %sub = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %12 = load i64, i64* %cdr, align 8
  store i64 %12, i64* %new_symbol, align 8
  br label %if.end.31

if.else:                                          ; preds = %if.end
  %13 = load i32, i32* %modifiers.addr, align 4
  %14 = load i64, i64* %base.addr, align 8
  %call18 = call i64 @SYMBOL_NAME(i64 %14)
  %call19 = call i8* @SSDATA(i64 %call18)
  %15 = load i64, i64* %base.addr, align 8
  %call20 = call i64 @SYMBOL_NAME(i64 %15)
  %call21 = call i64 @SCHARS(i64 %call20)
  %conv22 = trunc i64 %call21 to i32
  %16 = load i64, i64* %base.addr, align 8
  %call23 = call i64 @SYMBOL_NAME(i64 %16)
  %call24 = call i64 @SBYTES(i64 %call23)
  %conv25 = trunc i64 %call24 to i32
  %call26 = call i64 @apply_modifiers_uncached(i32 %13, i8* %call19, i32 %conv22, i32 %conv25)
  store i64 %call26, i64* %new_symbol, align 8
  %17 = load i64, i64* %idx, align 8
  %18 = load i64, i64* %new_symbol, align 8
  %call27 = call i64 @Fcons(i64 %17, i64 %18)
  store i64 %call27, i64* %entry1, align 8
  %19 = load i64, i64* %base.addr, align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 677)
  %20 = load i64, i64* %entry1, align 8
  %21 = load i64, i64* %cache, align 8
  %call29 = call i64 @Fcons(i64 %20, i64 %21)
  %call30 = call i64 @Fput(i64 %19, i64 %call28, i64 %call29)
  br label %if.end.31

if.end.31:                                        ; preds = %if.else, %if.then.17
  %22 = load i64, i64* %new_symbol, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 382)
  %call33 = call i64 @Fget(i64 %22, i64 %call32)
  %call34 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp35 = icmp eq i64 %call33, %call34
  br i1 %cmp35, label %if.then.37, label %if.end.47

if.then.37:                                       ; preds = %if.end.31
  %23 = load i64, i64* %base.addr, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 382)
  %call39 = call i64 @Fget(i64 %23, i64 %call38)
  store i64 %call39, i64* %kind, align 8
  %24 = load i64, i64* %kind, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %24, %call40
  br i1 %cmp41, label %if.end.46, label %if.then.43

if.then.43:                                       ; preds = %if.then.37
  %25 = load i64, i64* %new_symbol, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 382)
  %26 = load i64, i64* %kind, align 8
  %call45 = call i64 @Fput(i64 %25, i64 %call44, i64 %26)
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.43, %if.then.37
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.46, %if.end.31
  %27 = load i64, i64* %new_symbol, align 8
  store i64 %27, i64* %retval
  br label %return

return:                                           ; preds = %if.end.47, %if.then
  %28 = load i64, i64* %retval
  ret i64 %28
}

; Function Attrs: nounwind uwtable
define i64 @Fevent_convert_list(i64 %event_desc) #0 {
entry:
  %retval = alloca i64, align 8
  %event_desc.addr = alloca i64, align 8
  %base = alloca i64, align 8
  %modifiers = alloca i32, align 4
  %rest = alloca i64, align 8
  %elt = alloca i64, align 8
  %this = alloca i32, align 4
  store i64 %event_desc, i64* %event_desc.addr, align 8
  store i32 0, i32* %modifiers, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %base, align 8
  %0 = load i64, i64* %event_desc.addr, align 8
  store i64 %0, i64* %rest, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.21, %entry
  %1 = load i64, i64* %rest, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  store i32 0, i32* %this, align 4
  %2 = load i64, i64* %rest, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %elt, align 8
  %6 = load i64, i64* %rest, align 8
  %sub2 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub2 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %rest, align 8
  %10 = load i64, i64* %elt, align 8
  %and3 = and i64 %10, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 0
  br i1 %cmp5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %while.body
  %11 = load i64, i64* %rest, align 8
  %and7 = and i64 %11, 7
  %conv8 = trunc i64 %and7 to i32
  %cmp9 = icmp eq i32 %conv8, 3
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %12 = load i64, i64* %elt, align 8
  %call11 = call i32 @parse_solitary_modifier(i64 %12)
  store i32 %call11, i32* %this, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %while.body
  %13 = load i32, i32* %this, align 4
  %cmp12 = icmp ne i32 %13, 0
  br i1 %cmp12, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %if.end
  %14 = load i32, i32* %this, align 4
  %15 = load i32, i32* %modifiers, align 4
  %or = or i32 %15, %14
  store i32 %or, i32* %modifiers, align 4
  br label %if.end.21

if.else:                                          ; preds = %if.end
  %16 = load i64, i64* %base, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %16, %call15
  br i1 %cmp16, label %if.else.19, label %if.then.18

if.then.18:                                       ; preds = %if.else
  call void (i8*, ...) @error(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.4, i32 0, i32 0)) #11
  unreachable

if.else.19:                                       ; preds = %if.else
  %17 = load i64, i64* %elt, align 8
  store i64 %17, i64* %base, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.else.19
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %if.then.14
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %18 = load i64, i64* %base, align 8
  %and22 = and i64 %18, 7
  %conv23 = trunc i64 %and22 to i32
  %cmp24 = icmp eq i32 %conv23, 0
  br i1 %cmp24, label %land.lhs.true.26, label %if.end.35

land.lhs.true.26:                                 ; preds = %while.end
  %19 = load i64, i64* %base, align 8
  %call27 = call i64 @SYMBOL_NAME(i64 %19)
  %call28 = call i64 @SCHARS(i64 %call27)
  %cmp29 = icmp eq i64 %call28, 1
  br i1 %cmp29, label %if.then.31, label %if.end.35

if.then.31:                                       ; preds = %land.lhs.true.26
  %20 = load i64, i64* %base, align 8
  %call32 = call i64 @SYMBOL_NAME(i64 %20)
  %call33 = call zeroext i8 @SREF(i64 %call32, i64 0)
  %conv34 = zext i8 %call33 to i64
  %shl = shl i64 %conv34, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %base, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.31, %land.lhs.true.26, %while.end
  %21 = load i64, i64* %base, align 8
  %and36 = and i64 %21, 7
  %conv37 = trunc i64 %and36 to i32
  %and38 = and i32 %conv37, -5
  %cmp39 = icmp eq i32 %and38, 2
  br i1 %cmp39, label %if.then.41, label %if.else.75

if.then.41:                                       ; preds = %if.end.35
  %22 = load i32, i32* %modifiers, align 4
  %and42 = and i32 %22, 33554432
  %cmp43 = icmp ne i32 %and42, 0
  br i1 %cmp43, label %land.lhs.true.45, label %if.end.58

land.lhs.true.45:                                 ; preds = %if.then.41
  %23 = load i64, i64* %base, align 8
  %shr = ashr i64 %23, 2
  %cmp46 = icmp sge i64 %shr, 97
  br i1 %cmp46, label %land.lhs.true.48, label %if.end.58

land.lhs.true.48:                                 ; preds = %land.lhs.true.45
  %24 = load i64, i64* %base, align 8
  %shr49 = ashr i64 %24, 2
  %cmp50 = icmp sle i64 %shr49, 122
  br i1 %cmp50, label %if.then.52, label %if.end.58

if.then.52:                                       ; preds = %land.lhs.true.48
  %25 = load i64, i64* %base, align 8
  %shr53 = ashr i64 %25, 2
  %sub54 = sub nsw i64 %shr53, 32
  %shl55 = shl i64 %sub54, 2
  %add56 = add i64 %shl55, 2
  store i64 %add56, i64* %base, align 8
  %26 = load i32, i32* %modifiers, align 4
  %and57 = and i32 %26, -33554433
  store i32 %and57, i32* %modifiers, align 4
  br label %if.end.58

if.end.58:                                        ; preds = %if.then.52, %land.lhs.true.48, %land.lhs.true.45, %if.then.41
  %27 = load i32, i32* %modifiers, align 4
  %and59 = and i32 %27, 67108864
  %tobool = icmp ne i32 %and59, 0
  br i1 %tobool, label %if.then.60, label %if.else.69

if.then.60:                                       ; preds = %if.end.58
  %28 = load i32, i32* %modifiers, align 4
  %and61 = and i32 %28, -67108865
  %29 = load i64, i64* %base, align 8
  %shr62 = ashr i64 %29, 2
  %conv63 = trunc i64 %shr62 to i32
  %call64 = call i32 @make_ctrl_char(i32 %conv63) #14
  %or65 = or i32 %and61, %call64
  %conv66 = sext i32 %or65 to i64
  %shl67 = shl i64 %conv66, 2
  %add68 = add i64 %shl67, 2
  store i64 %add68, i64* %retval
  br label %return

if.else.69:                                       ; preds = %if.end.58
  %30 = load i32, i32* %modifiers, align 4
  %conv70 = sext i32 %30 to i64
  %31 = load i64, i64* %base, align 8
  %shr71 = ashr i64 %31, 2
  %or72 = or i64 %conv70, %shr71
  %shl73 = shl i64 %or72, 2
  %add74 = add i64 %shl73, 2
  store i64 %add74, i64* %retval
  br label %return

if.else.75:                                       ; preds = %if.end.35
  %32 = load i64, i64* %base, align 8
  %and76 = and i64 %32, 7
  %conv77 = trunc i64 %and76 to i32
  %cmp78 = icmp eq i32 %conv77, 0
  br i1 %cmp78, label %if.then.80, label %if.else.82

if.then.80:                                       ; preds = %if.else.75
  %33 = load i32, i32* %modifiers, align 4
  %34 = load i64, i64* %base, align 8
  %call81 = call i64 @apply_modifiers(i32 %33, i64 %34)
  store i64 %call81, i64* %retval
  br label %return

if.else.82:                                       ; preds = %if.else.75
  call void (i8*, ...) @error(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.5, i32 0, i32 0)) #11
  unreachable

return:                                           ; preds = %if.then.80, %if.else.69, %if.then.60
  %35 = load i64, i64* %retval
  ret i64 %35
}

; Function Attrs: nounwind uwtable
define i32 @parse_solitary_modifier(i64 %symbol) #0 {
entry:
  %retval = alloca i32, align 4
  %symbol.addr = alloca i64, align 8
  %name = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %call = call i64 @SYMBOL_NAME(i64 %0)
  store i64 %call, i64* %name, align 8
  %1 = load i64, i64* %name, align 8
  %call1 = call zeroext i8 @SREF(i64 %1, i64 0)
  %conv = zext i8 %call1 to i32
  switch i32 %conv, label %sw.epilog [
    i32 65, label %sw.bb
    i32 97, label %sw.bb.4
    i32 67, label %sw.bb.12
    i32 99, label %sw.bb.18
    i32 72, label %sw.bb.37
    i32 104, label %sw.bb.43
    i32 77, label %sw.bb.53
    i32 109, label %sw.bb.59
    i32 83, label %sw.bb.69
    i32 115, label %sw.bb.75
    i32 100, label %sw.bb.99
    i32 116, label %sw.bb.127
    i32 117, label %sw.bb.137
  ]

sw.bb:                                            ; preds = %entry
  %2 = load i64, i64* %name, align 8
  %call2 = call i64 @SBYTES(i64 %2)
  %cmp = icmp eq i64 %call2, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i32 4194304, i32* %retval
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.bb.4:                                          ; preds = %entry
  %3 = load i64, i64* %name, align 8
  %call5 = call i64 @SBYTES(i64 %3)
  %cmp6 = icmp eq i64 3, %call5
  br i1 %cmp6, label %land.lhs.true, label %if.end.11

land.lhs.true:                                    ; preds = %sw.bb.4
  %4 = load i64, i64* %name, align 8
  %call8 = call i8* @SDATA(i64 %4)
  %call9 = call i32 @memcmp(i8* %call8, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.6, i32 0, i32 0), i64 3) #13
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.end.11, label %if.then.10

if.then.10:                                       ; preds = %land.lhs.true
  store i32 4194304, i32* %retval
  br label %return

if.end.11:                                        ; preds = %land.lhs.true, %sw.bb.4
  br label %sw.epilog

sw.bb.12:                                         ; preds = %entry
  %5 = load i64, i64* %name, align 8
  %call13 = call i64 @SBYTES(i64 %5)
  %cmp14 = icmp eq i64 %call13, 1
  br i1 %cmp14, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %sw.bb.12
  store i32 67108864, i32* %retval
  br label %return

if.end.17:                                        ; preds = %sw.bb.12
  br label %sw.epilog

sw.bb.18:                                         ; preds = %entry
  %6 = load i64, i64* %name, align 8
  %call19 = call i64 @SBYTES(i64 %6)
  %cmp20 = icmp eq i64 4, %call19
  br i1 %cmp20, label %land.lhs.true.22, label %if.end.27

land.lhs.true.22:                                 ; preds = %sw.bb.18
  %7 = load i64, i64* %name, align 8
  %call23 = call i8* @SDATA(i64 %7)
  %call24 = call i32 @memcmp(i8* %call23, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0), i64 4) #13
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end.27, label %if.then.26

if.then.26:                                       ; preds = %land.lhs.true.22
  store i32 67108864, i32* %retval
  br label %return

if.end.27:                                        ; preds = %land.lhs.true.22, %sw.bb.18
  %8 = load i64, i64* %name, align 8
  %call28 = call i64 @SBYTES(i64 %8)
  %cmp29 = icmp eq i64 7, %call28
  br i1 %cmp29, label %land.lhs.true.31, label %if.end.36

land.lhs.true.31:                                 ; preds = %if.end.27
  %9 = load i64, i64* %name, align 8
  %call32 = call i8* @SDATA(i64 %9)
  %call33 = call i32 @memcmp(i8* %call32, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.8, i32 0, i32 0), i64 7) #13
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.end.36, label %if.then.35

if.then.35:                                       ; preds = %land.lhs.true.31
  store i32 67108864, i32* %retval
  br label %return

if.end.36:                                        ; preds = %land.lhs.true.31, %if.end.27
  br label %sw.epilog

sw.bb.37:                                         ; preds = %entry
  %10 = load i64, i64* %name, align 8
  %call38 = call i64 @SBYTES(i64 %10)
  %cmp39 = icmp eq i64 %call38, 1
  br i1 %cmp39, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %sw.bb.37
  store i32 16777216, i32* %retval
  br label %return

if.end.42:                                        ; preds = %sw.bb.37
  br label %sw.epilog

sw.bb.43:                                         ; preds = %entry
  %11 = load i64, i64* %name, align 8
  %call44 = call i64 @SBYTES(i64 %11)
  %cmp45 = icmp eq i64 5, %call44
  br i1 %cmp45, label %land.lhs.true.47, label %if.end.52

land.lhs.true.47:                                 ; preds = %sw.bb.43
  %12 = load i64, i64* %name, align 8
  %call48 = call i8* @SDATA(i64 %12)
  %call49 = call i32 @memcmp(i8* %call48, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.9, i32 0, i32 0), i64 5) #13
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.end.52, label %if.then.51

if.then.51:                                       ; preds = %land.lhs.true.47
  store i32 16777216, i32* %retval
  br label %return

if.end.52:                                        ; preds = %land.lhs.true.47, %sw.bb.43
  br label %sw.epilog

sw.bb.53:                                         ; preds = %entry
  %13 = load i64, i64* %name, align 8
  %call54 = call i64 @SBYTES(i64 %13)
  %cmp55 = icmp eq i64 %call54, 1
  br i1 %cmp55, label %if.then.57, label %if.end.58

if.then.57:                                       ; preds = %sw.bb.53
  store i32 134217728, i32* %retval
  br label %return

if.end.58:                                        ; preds = %sw.bb.53
  br label %sw.epilog

sw.bb.59:                                         ; preds = %entry
  %14 = load i64, i64* %name, align 8
  %call60 = call i64 @SBYTES(i64 %14)
  %cmp61 = icmp eq i64 4, %call60
  br i1 %cmp61, label %land.lhs.true.63, label %if.end.68

land.lhs.true.63:                                 ; preds = %sw.bb.59
  %15 = load i64, i64* %name, align 8
  %call64 = call i8* @SDATA(i64 %15)
  %call65 = call i32 @memcmp(i8* %call64, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.10, i32 0, i32 0), i64 4) #13
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.end.68, label %if.then.67

if.then.67:                                       ; preds = %land.lhs.true.63
  store i32 134217728, i32* %retval
  br label %return

if.end.68:                                        ; preds = %land.lhs.true.63, %sw.bb.59
  br label %sw.epilog

sw.bb.69:                                         ; preds = %entry
  %16 = load i64, i64* %name, align 8
  %call70 = call i64 @SBYTES(i64 %16)
  %cmp71 = icmp eq i64 %call70, 1
  br i1 %cmp71, label %if.then.73, label %if.end.74

if.then.73:                                       ; preds = %sw.bb.69
  store i32 33554432, i32* %retval
  br label %return

if.end.74:                                        ; preds = %sw.bb.69
  br label %sw.epilog

sw.bb.75:                                         ; preds = %entry
  %17 = load i64, i64* %name, align 8
  %call76 = call i64 @SBYTES(i64 %17)
  %cmp77 = icmp eq i64 5, %call76
  br i1 %cmp77, label %land.lhs.true.79, label %if.end.84

land.lhs.true.79:                                 ; preds = %sw.bb.75
  %18 = load i64, i64* %name, align 8
  %call80 = call i8* @SDATA(i64 %18)
  %call81 = call i32 @memcmp(i8* %call80, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.11, i32 0, i32 0), i64 5) #13
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.end.84, label %if.then.83

if.then.83:                                       ; preds = %land.lhs.true.79
  store i32 33554432, i32* %retval
  br label %return

if.end.84:                                        ; preds = %land.lhs.true.79, %sw.bb.75
  %19 = load i64, i64* %name, align 8
  %call85 = call i64 @SBYTES(i64 %19)
  %cmp86 = icmp eq i64 5, %call85
  br i1 %cmp86, label %land.lhs.true.88, label %if.end.93

land.lhs.true.88:                                 ; preds = %if.end.84
  %20 = load i64, i64* %name, align 8
  %call89 = call i8* @SDATA(i64 %20)
  %call90 = call i32 @memcmp(i8* %call89, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12, i32 0, i32 0), i64 5) #13
  %tobool91 = icmp ne i32 %call90, 0
  br i1 %tobool91, label %if.end.93, label %if.then.92

if.then.92:                                       ; preds = %land.lhs.true.88
  store i32 8388608, i32* %retval
  br label %return

if.end.93:                                        ; preds = %land.lhs.true.88, %if.end.84
  %21 = load i64, i64* %name, align 8
  %call94 = call i64 @SBYTES(i64 %21)
  %cmp95 = icmp eq i64 %call94, 1
  br i1 %cmp95, label %if.then.97, label %if.end.98

if.then.97:                                       ; preds = %if.end.93
  store i32 8388608, i32* %retval
  br label %return

if.end.98:                                        ; preds = %if.end.93
  br label %sw.epilog

sw.bb.99:                                         ; preds = %entry
  %22 = load i64, i64* %name, align 8
  %call100 = call i64 @SBYTES(i64 %22)
  %cmp101 = icmp eq i64 4, %call100
  br i1 %cmp101, label %land.lhs.true.103, label %if.end.108

land.lhs.true.103:                                ; preds = %sw.bb.99
  %23 = load i64, i64* %name, align 8
  %call104 = call i8* @SDATA(i64 %23)
  %call105 = call i32 @memcmp(i8* %call104, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.13, i32 0, i32 0), i64 4) #13
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.end.108, label %if.then.107

if.then.107:                                      ; preds = %land.lhs.true.103
  store i32 4, i32* %retval
  br label %return

if.end.108:                                       ; preds = %land.lhs.true.103, %sw.bb.99
  %24 = load i64, i64* %name, align 8
  %call109 = call i64 @SBYTES(i64 %24)
  %cmp110 = icmp eq i64 4, %call109
  br i1 %cmp110, label %land.lhs.true.112, label %if.end.117

land.lhs.true.112:                                ; preds = %if.end.108
  %25 = load i64, i64* %name, align 8
  %call113 = call i8* @SDATA(i64 %25)
  %call114 = call i32 @memcmp(i8* %call113, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.14, i32 0, i32 0), i64 4) #13
  %tobool115 = icmp ne i32 %call114, 0
  br i1 %tobool115, label %if.end.117, label %if.then.116

if.then.116:                                      ; preds = %land.lhs.true.112
  store i32 2, i32* %retval
  br label %return

if.end.117:                                       ; preds = %land.lhs.true.112, %if.end.108
  %26 = load i64, i64* %name, align 8
  %call118 = call i64 @SBYTES(i64 %26)
  %cmp119 = icmp eq i64 6, %call118
  br i1 %cmp119, label %land.lhs.true.121, label %if.end.126

land.lhs.true.121:                                ; preds = %if.end.117
  %27 = load i64, i64* %name, align 8
  %call122 = call i8* @SDATA(i64 %27)
  %call123 = call i32 @memcmp(i8* %call122, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.15, i32 0, i32 0), i64 6) #13
  %tobool124 = icmp ne i32 %call123, 0
  br i1 %tobool124, label %if.end.126, label %if.then.125

if.then.125:                                      ; preds = %land.lhs.true.121
  store i32 16, i32* %retval
  br label %return

if.end.126:                                       ; preds = %land.lhs.true.121, %if.end.117
  br label %sw.epilog

sw.bb.127:                                        ; preds = %entry
  %28 = load i64, i64* %name, align 8
  %call128 = call i64 @SBYTES(i64 %28)
  %cmp129 = icmp eq i64 6, %call128
  br i1 %cmp129, label %land.lhs.true.131, label %if.end.136

land.lhs.true.131:                                ; preds = %sw.bb.127
  %29 = load i64, i64* %name, align 8
  %call132 = call i8* @SDATA(i64 %29)
  %call133 = call i32 @memcmp(i8* %call132, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.16, i32 0, i32 0), i64 6) #13
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %if.end.136, label %if.then.135

if.then.135:                                      ; preds = %land.lhs.true.131
  store i32 32, i32* %retval
  br label %return

if.end.136:                                       ; preds = %land.lhs.true.131, %sw.bb.127
  br label %sw.epilog

sw.bb.137:                                        ; preds = %entry
  %30 = load i64, i64* %name, align 8
  %call138 = call i64 @SBYTES(i64 %30)
  %cmp139 = icmp eq i64 2, %call138
  br i1 %cmp139, label %land.lhs.true.141, label %if.end.146

land.lhs.true.141:                                ; preds = %sw.bb.137
  %31 = load i64, i64* %name, align 8
  %call142 = call i8* @SDATA(i64 %31)
  %call143 = call i32 @memcmp(i8* %call142, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.17, i32 0, i32 0), i64 2) #13
  %tobool144 = icmp ne i32 %call143, 0
  br i1 %tobool144, label %if.end.146, label %if.then.145

if.then.145:                                      ; preds = %land.lhs.true.141
  store i32 1, i32* %retval
  br label %return

if.end.146:                                       ; preds = %land.lhs.true.141, %sw.bb.137
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end.146, %if.end.136, %if.end.126, %if.end.98, %if.end.74, %if.end.68, %if.end.58, %if.end.52, %if.end.42, %if.end.36, %if.end.17, %if.end.11, %if.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then.145, %if.then.135, %if.then.125, %if.then.116, %if.then.107, %if.then.97, %if.then.92, %if.then.83, %if.then.73, %if.then.67, %if.then.57, %if.then.51, %if.then.41, %if.then.35, %if.then.26, %if.then.16, %if.then.10, %if.then
  %32 = load i32, i32* %retval
  ret i32 %32
}

declare zeroext i8 @SREF(i64, i64) #1

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8*, i8*, i64) #7

declare i8* @SDATA(i64) #1

; Function Attrs: nounwind uwtable
define zeroext i1 @lucid_event_type_list_p(i64 %object) #0 {
entry:
  %retval = alloca i1, align 1
  %object.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %elt = alloca i64, align 8
  store i64 %object, i64* %object.addr, align 8
  %0 = load i64, i64* %object.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %object.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call = call i64 @builtin_lisp_symbol(i32 516)
  %cmp2 = icmp eq i64 %4, %call
  br i1 %cmp2, label %if.then.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i64, i64* %object.addr, align 8
  %sub4 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub4 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car5 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car5, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 1001)
  %cmp7 = icmp eq i64 %8, %call6
  br i1 %cmp7, label %if.then.21, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %lor.lhs.false
  %9 = load i64, i64* %object.addr, align 8
  %sub10 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub10 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car11, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 672)
  %cmp13 = icmp eq i64 %12, %call12
  br i1 %cmp13, label %if.then.21, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %lor.lhs.false.9
  %13 = load i64, i64* %object.addr, align 8
  %sub16 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub16 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car17 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car17, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 513)
  %cmp19 = icmp eq i64 %16, %call18
  br i1 %cmp19, label %if.then.21, label %if.end.22

if.then.21:                                       ; preds = %lor.lhs.false.15, %lor.lhs.false.9, %lor.lhs.false, %if.end
  store i1 false, i1* %retval
  br label %return

if.end.22:                                        ; preds = %lor.lhs.false.15
  %17 = load i64, i64* %object.addr, align 8
  store i64 %17, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.22
  %18 = load i64, i64* %tail, align 8
  %and23 = and i64 %18, 7
  %conv24 = trunc i64 %and23 to i32
  %cmp25 = icmp eq i32 %conv24, 3
  br i1 %cmp25, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load i64, i64* %tail, align 8
  %sub27 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub27 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %car28 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 0
  %22 = load i64, i64* %car28, align 8
  store i64 %22, i64* %elt, align 8
  %23 = load i64, i64* %elt, align 8
  %and29 = and i64 %23, 7
  %conv30 = trunc i64 %and29 to i32
  %and31 = and i32 %conv30, -5
  %cmp32 = icmp eq i32 %and31, 2
  br i1 %cmp32, label %if.end.40, label %lor.lhs.false.34

lor.lhs.false.34:                                 ; preds = %for.body
  %24 = load i64, i64* %elt, align 8
  %and35 = and i64 %24, 7
  %conv36 = trunc i64 %and35 to i32
  %cmp37 = icmp eq i32 %conv36, 0
  br i1 %cmp37, label %if.end.40, label %if.then.39

if.then.39:                                       ; preds = %lor.lhs.false.34
  store i1 false, i1* %retval
  br label %return

if.end.40:                                        ; preds = %lor.lhs.false.34, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.40
  %25 = load i64, i64* %tail, align 8
  %sub41 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub41 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %28 = load i64, i64* %cdr, align 8
  store i64 %28, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %29 = load i64, i64* %tail, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp43 = icmp eq i64 %29, %call42
  store i1 %cmp43, i1* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.39, %if.then.21, %if.then
  %30 = load i1, i1* %retval
  ret i1 %30
}

; Function Attrs: nounwind uwtable
define void @record_asynch_buffer_change() #0 {
entry:
  %event = alloca %struct.input_event, align 8
  %call = call i64 @Fwaiting_for_user_input_p()
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  br i1 %cmp, label %if.end.5, label %if.then

if.then:                                          ; preds = %entry
  %0 = bitcast %struct.input_event* %event to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 56, i32 8, i1 false)
  %1 = bitcast %struct.input_event* %event to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.clear = and i32 %bf.load, -65536
  %bf.set = or i32 %bf.clear, 12
  store i32 %bf.set, i32* %1, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 6
  store i64 %call2, i64* %frame_or_window, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %event, i32 0, i32 7
  store i64 %call3, i64* %arg, align 8
  %2 = load i8, i8* @interrupt_input, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.then
  call void @kbd_buffer_store_event(%struct.input_event* %event)
  br label %if.end

if.else:                                          ; preds = %if.then
  call void @stop_polling()
  call void @kbd_buffer_store_event(%struct.input_event* %event)
  call void @start_polling()
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.4
  br label %if.end.5

if.end.5:                                         ; preds = %if.end, %entry
  ret void
}

declare i64 @Fwaiting_for_user_input_p() #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #8

; Function Attrs: nounwind uwtable
define internal void @store_user_signal_events() #0 {
entry:
  %p = alloca %struct.user_signal_info*, align 8
  %buf = alloca %struct.input_event, align 8
  %buf_initialized = alloca i8, align 1
  store i8 0, i8* %buf_initialized, align 1
  %0 = load %struct.user_signal_info*, %struct.user_signal_info** @user_signals, align 8
  store %struct.user_signal_info* %0, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %tobool = icmp ne %struct.user_signal_info* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %npending = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %2, i32 0, i32 2
  %3 = load i32, i32* %npending, align 4
  %cmp = icmp sgt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end.6

if.then:                                          ; preds = %for.body
  %4 = load i8, i8* %buf_initialized, align 1
  %tobool1 = trunc i8 %4 to i1
  br i1 %tobool1, label %if.end, label %if.then.2

if.then.2:                                        ; preds = %if.then
  %5 = bitcast %struct.input_event* %buf to i8*
  call void @llvm.memset.p0i8.i64(i8* %5, i8 0, i64 56, i32 8, i1 false)
  %6 = bitcast %struct.input_event* %buf to i32*
  %bf.load = load i32, i32* %6, align 8
  %bf.clear = and i32 %bf.load, -65536
  %bf.set = or i32 %bf.clear, 19
  store i32 %bf.set, i32* %6, align 8
  %7 = load i64, i64* @selected_frame, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 6
  store i64 %7, i64* %frame_or_window, align 8
  store i8 1, i8* %buf_initialized, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.2, %if.then
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %8 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %sig = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %8, i32 0, i32 0
  %9 = load i32, i32* %sig, align 4
  %code = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 1
  store i32 %9, i32* %code, align 4
  call void @kbd_buffer_store_event(%struct.input_event* %buf)
  %10 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %npending3 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %10, i32 0, i32 2
  %11 = load i32, i32* %npending3, align 4
  %dec = add nsw i32 %11, -1
  store i32 %dec, i32* %npending3, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %12 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %npending4 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %12, i32 0, i32 2
  %13 = load i32, i32* %npending4, align 4
  %cmp5 = icmp sgt i32 %13, 0
  br i1 %cmp5, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  br label %if.end.6

if.end.6:                                         ; preds = %do.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.6
  %14 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %next = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %14, i32 0, i32 3
  %15 = load %struct.user_signal_info*, %struct.user_signal_info** %next, align 8
  store %struct.user_signal_info* %15, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: noreturn
declare void @terminate_due_to_signal(i32, i32) #2

declare i64 @make_lisp_ptr(i8*, i32) #1

declare i64 @Fdelete_terminal(i64, i64) #1

declare void @frame_make_pointer_visible(%struct.frame*) #1

; Function Attrs: nounwind uwtable
define i32 @tty_read_avail_input(%struct.terminal* %terminal, %struct.input_event* %hold_quit) #0 {
entry:
  %retval = alloca i32, align 4
  %terminal.addr = alloca %struct.terminal*, align 8
  %hold_quit.addr = alloca %struct.input_event*, align 8
  %cbuf = alloca [4095 x i8], align 16
  %n_to_read = alloca i32, align 4
  %i = alloca i32, align 4
  %tty = alloca %struct.tty_display_info*, align 8
  %nread = alloca i32, align 4
  %buffer_free = alloca i32, align 4
  %buf = alloca %struct.input_event, align 8
  store %struct.terminal* %terminal, %struct.terminal** %terminal.addr, align 8
  store %struct.input_event* %hold_quit, %struct.input_event** %hold_quit.addr, align 8
  %0 = load %struct.terminal*, %struct.terminal** %terminal.addr, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %0, i32 0, i32 12
  %tty1 = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %1 = load %struct.tty_display_info*, %struct.tty_display_info** %tty1, align 8
  store %struct.tty_display_info* %1, %struct.tty_display_info** %tty, align 8
  store i32 0, i32* %nread, align 4
  %call = call i32 @kbd_buffer_nr_stored()
  %sub = sub nsw i32 4096, %call
  %sub2 = sub nsw i32 %sub, 1
  store i32 %sub2, i32* %buffer_free, align 4
  %call3 = call zeroext i1 @kbd_on_hold_p()
  br i1 %call3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %buffer_free, align 4
  %cmp = icmp sle i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.terminal*, %struct.terminal** %terminal.addr, align 8
  %name = getelementptr inbounds %struct.terminal, %struct.terminal* %3, i32 0, i32 9
  %4 = load i8*, i8** %name, align 8
  %tobool = icmp ne i8* %4, null
  br i1 %tobool, label %if.end.5, label %if.then.4

if.then.4:                                        ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load %struct.terminal*, %struct.terminal** %terminal.addr, align 8
  %type = getelementptr inbounds %struct.terminal, %struct.terminal* %5, i32 0, i32 8
  %6 = load i32, i32* %type, align 4
  %cmp6 = icmp ne i32 %6, 1
  br i1 %cmp6, label %land.lhs.true, label %if.end.10

land.lhs.true:                                    ; preds = %if.end.5
  %7 = load %struct.terminal*, %struct.terminal** %terminal.addr, align 8
  %type7 = getelementptr inbounds %struct.terminal, %struct.terminal* %7, i32 0, i32 8
  %8 = load i32, i32* %type7, align 4
  %cmp8 = icmp ne i32 %8, 3
  br i1 %cmp8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %land.lhs.true
  call void @emacs_abort() #11
  unreachable

if.end.10:                                        ; preds = %land.lhs.true, %if.end.5
  %9 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %term_initted = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %9, i32 0, i32 7
  %bf.load = load i8, i8* %term_initted, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end.12, label %if.then.11

if.then.11:                                       ; preds = %if.end.10
  store i32 0, i32* %retval
  br label %return

if.end.12:                                        ; preds = %if.end.10
  %10 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %input = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %10, i32 0, i32 3
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %input, align 8
  %tobool13 = icmp ne %struct._IO_FILE* %11, null
  br i1 %tobool13, label %if.end.15, label %if.then.14

if.then.14:                                       ; preds = %if.end.12
  store i32 0, i32* %retval
  br label %return

if.end.15:                                        ; preds = %if.end.12
  %12 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %input16 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %12, i32 0, i32 3
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** %input16, align 8
  %call17 = call i32 @fileno(%struct._IO_FILE* %13) #8
  %call18 = call i32 (i32, i64, ...) @ioctl(i32 %call17, i64 21531, i32* %n_to_read) #8
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then.20, label %if.end.24

if.then.20:                                       ; preds = %if.end.15
  %14 = load i8, i8* @noninteractive, align 1
  %tobool21 = trunc i8 %14 to i1
  br i1 %tobool21, label %if.else, label %if.then.22

if.then.22:                                       ; preds = %if.then.20
  store i32 -2, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then.20
  store i32 0, i32* %n_to_read, align 4
  br label %if.end.23

if.end.23:                                        ; preds = %if.else
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.end.15
  %15 = load i32, i32* %n_to_read, align 4
  %cmp25 = icmp eq i32 %15, 0
  br i1 %cmp25, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %if.end.24
  store i32 0, i32* %retval
  br label %return

if.end.27:                                        ; preds = %if.end.24
  %16 = load i32, i32* %n_to_read, align 4
  %conv = sext i32 %16 to i64
  %cmp28 = icmp ugt i64 %conv, 4095
  br i1 %cmp28, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.end.27
  store i32 4095, i32* %n_to_read, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %if.end.27
  %17 = load i32, i32* %n_to_read, align 4
  %18 = load i32, i32* %buffer_free, align 4
  %cmp32 = icmp sgt i32 %17, %18
  br i1 %cmp32, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.end.31
  %19 = load i32, i32* %buffer_free, align 4
  store i32 %19, i32* %n_to_read, align 4
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.end.31
  br label %do.body

do.body:                                          ; preds = %if.end.35
  %20 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %input36 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %20, i32 0, i32 3
  %21 = load %struct._IO_FILE*, %struct._IO_FILE** %input36, align 8
  %call37 = call i32 @fileno(%struct._IO_FILE* %21) #8
  %arraydecay = getelementptr inbounds [4095 x i8], [4095 x i8]* %cbuf, i32 0, i32 0
  %22 = load i32, i32* %n_to_read, align 4
  %conv38 = sext i32 %22 to i64
  %call39 = call i64 @emacs_read(i32 %call37, i8* %arraydecay, i64 %conv38)
  %conv40 = trunc i64 %call39 to i32
  store i32 %conv40, i32* %nread, align 4
  %23 = load i32, i32* %nread, align 4
  %cmp41 = icmp eq i32 %23, -1
  br i1 %cmp41, label %land.lhs.true.43, label %if.end.48

land.lhs.true.43:                                 ; preds = %do.body
  %call44 = call i32* @__errno_location() #14
  %24 = load i32, i32* %call44, align 4
  %cmp45 = icmp eq i32 %24, 5
  br i1 %cmp45, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %land.lhs.true.43
  store i32 -2, i32* %retval
  br label %return

if.end.48:                                        ; preds = %land.lhs.true.43, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.48
  %25 = load i32, i32* %nread, align 4
  %cmp49 = icmp sle i32 %25, 0
  br i1 %cmp49, label %if.then.51, label %if.end.52

if.then.51:                                       ; preds = %do.end
  %26 = load i32, i32* %nread, align 4
  store i32 %26, i32* %retval
  br label %return

if.end.52:                                        ; preds = %do.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.52
  %27 = load i32, i32* %i, align 4
  %28 = load i32, i32* %nread, align 4
  %cmp53 = icmp slt i32 %27, %28
  br i1 %cmp53, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %29 = bitcast %struct.input_event* %buf to i8*
  call void @llvm.memset.p0i8.i64(i8* %29, i8 0, i64 56, i32 8, i1 false)
  %30 = bitcast %struct.input_event* %buf to i32*
  %bf.load55 = load i32, i32* %30, align 8
  %bf.clear56 = and i32 %bf.load55, -65536
  %bf.set = or i32 %bf.clear56, 1
  store i32 %bf.set, i32* %30, align 8
  %modifiers = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 2
  store i32 0, i32* %modifiers, align 4
  %31 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %31, i32 0, i32 73
  %32 = load i32, i32* %meta_key, align 4
  %cmp57 = icmp eq i32 %32, 1
  br i1 %cmp57, label %land.lhs.true.59, label %if.end.64

land.lhs.true.59:                                 ; preds = %for.body
  %33 = load i32, i32* %i, align 4
  %idxprom = sext i32 %33 to i64
  %arrayidx = getelementptr inbounds [4095 x i8], [4095 x i8]* %cbuf, i32 0, i64 %idxprom
  %34 = load i8, i8* %arrayidx, align 1
  %conv60 = zext i8 %34 to i32
  %and = and i32 %conv60, 128
  %tobool61 = icmp ne i32 %and, 0
  br i1 %tobool61, label %if.then.62, label %if.end.64

if.then.62:                                       ; preds = %land.lhs.true.59
  %modifiers63 = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 2
  store i32 134217728, i32* %modifiers63, align 4
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.62, %land.lhs.true.59, %for.body
  %35 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key65 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %35, i32 0, i32 73
  %36 = load i32, i32* %meta_key65, align 4
  %cmp66 = icmp ne i32 %36, 2
  br i1 %cmp66, label %if.then.68, label %if.end.74

if.then.68:                                       ; preds = %if.end.64
  %37 = load i32, i32* %i, align 4
  %idxprom69 = sext i32 %37 to i64
  %arrayidx70 = getelementptr inbounds [4095 x i8], [4095 x i8]* %cbuf, i32 0, i64 %idxprom69
  %38 = load i8, i8* %arrayidx70, align 1
  %conv71 = zext i8 %38 to i32
  %and72 = and i32 %conv71, -129
  %conv73 = trunc i32 %and72 to i8
  store i8 %conv73, i8* %arrayidx70, align 1
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.68, %if.end.64
  %39 = load i32, i32* %i, align 4
  %idxprom75 = sext i32 %39 to i64
  %arrayidx76 = getelementptr inbounds [4095 x i8], [4095 x i8]* %cbuf, i32 0, i64 %idxprom75
  %40 = load i8, i8* %arrayidx76, align 1
  %conv77 = zext i8 %40 to i32
  %code = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 1
  store i32 %conv77, i32* %code, align 4
  %41 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %top_frame = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %41, i32 0, i32 11
  %42 = load i64, i64* %top_frame, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 6
  store i64 %42, i64* %frame_or_window, align 8
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 7
  store i64 %call78, i64* %arg, align 8
  call void @kbd_buffer_store_event(%struct.input_event* %buf)
  %43 = bitcast %struct.input_event* %buf to i32*
  %bf.load79 = load i32, i32* %43, align 8
  %bf.clear80 = and i32 %bf.load79, 65535
  %cmp81 = icmp eq i32 %bf.clear80, 1
  br i1 %cmp81, label %land.lhs.true.83, label %if.end.88

land.lhs.true.83:                                 ; preds = %if.end.74
  %code84 = getelementptr inbounds %struct.input_event, %struct.input_event* %buf, i32 0, i32 1
  %44 = load i32, i32* %code84, align 4
  %45 = load i32, i32* @quit_char, align 4
  %cmp85 = icmp eq i32 %44, %45
  br i1 %cmp85, label %if.then.87, label %if.end.88

if.then.87:                                       ; preds = %land.lhs.true.83
  br label %for.end

if.end.88:                                        ; preds = %land.lhs.true.83, %if.end.74
  br label %for.inc

for.inc:                                          ; preds = %if.end.88
  %46 = load i32, i32* %i, align 4
  %inc = add nsw i32 %46, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then.87, %for.cond
  %47 = load i32, i32* %nread, align 4
  store i32 %47, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.51, %if.then.47, %if.then.26, %if.then.22, %if.then.14, %if.then.11, %if.then.4, %if.then
  %48 = load i32, i32* %retval
  ret i32 %48
}

; Function Attrs: nounwind
declare i32 @ioctl(i32, i64, ...) #6

; Function Attrs: nounwind
declare i32 @fileno(%struct._IO_FILE*) #6

declare i64 @emacs_read(i32, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #9

; Function Attrs: nounwind uwtable
define internal void @handle_async_input() #0 {
entry:
  %nread = alloca i32, align 4
  br label %while.body

while.body:                                       ; preds = %entry, %if.end
  %call = call i32 @gobble_input()
  store i32 %call, i32* %nread, align 4
  %0 = load i32, i32* %nread, align 4
  %cmp = icmp sle i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  br label %while.body

while.end:                                        ; preds = %if.then
  ret void
}

declare void @do_pending_atimers() #1

; Function Attrs: nounwind uwtable
define void @unblock_input_to(i32 %level) #0 {
entry:
  %level.addr = alloca i32, align 4
  store i32 %level, i32* %level.addr, align 4
  %0 = load i32, i32* %level.addr, align 4
  store volatile i32 %0, i32* @interrupt_input_blocked, align 4
  %1 = load i32, i32* %level.addr, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %3 = load i8, i8* @fatal_error_in_progress, align 1
  %tobool1 = trunc i8 %3 to i1
  br i1 %tobool1, label %if.end, label %if.then.2

if.then.2:                                        ; preds = %land.lhs.true
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.2, %land.lhs.true, %if.then
  br label %if.end.6

if.else:                                          ; preds = %entry
  %4 = load i32, i32* %level.addr, align 4
  %cmp3 = icmp slt i32 %4, 0
  br i1 %cmp3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.else
  call void @emacs_abort() #11
  unreachable

if.end.5:                                         ; preds = %if.else
  br label %if.end.6

if.end.6:                                         ; preds = %if.end.5, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @unblock_input() #0 {
entry:
  %0 = load volatile i32, i32* @interrupt_input_blocked, align 4
  %sub = sub nsw i32 %0, 1
  call void @unblock_input_to(i32 %sub)
  ret void
}

; Function Attrs: nounwind uwtable
define void @handle_input_available_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %coerce = alloca %struct.timespec, align 8
  store i32 %sig, i32* %sig.addr, align 4
  store volatile i8 1, i8* @pending_signals, align 1
  %0 = load %struct.timespec*, %struct.timespec** @input_available_clear_time, align 8
  %tobool = icmp ne %struct.timespec* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.timespec*, %struct.timespec** @input_available_clear_time, align 8
  %call = call { i64, i64 } @make_timespec(i64 0, i64 0)
  %2 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.timespec* %1 to i8*
  %8 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 16, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @add_user_signal(i32 %sig, i8* %name) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %name.addr = alloca i8*, align 8
  %action = alloca %struct.sigaction, align 8
  %p = alloca %struct.user_signal_info*, align 8
  store i32 %sig, i32* %sig.addr, align 4
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.user_signal_info*, %struct.user_signal_info** @user_signals, align 8
  store %struct.user_signal_info* %0, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %tobool = icmp ne %struct.user_signal_info* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %sig1 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %2, i32 0, i32 0
  %3 = load i32, i32* %sig1, align 4
  %4 = load i32, i32* %sig.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %next = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %5, i32 0, i32 3
  %6 = load %struct.user_signal_info*, %struct.user_signal_info** %next, align 8
  store %struct.user_signal_info* %6, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call = call noalias i8* @xmalloc(i64 32)
  %7 = bitcast i8* %call to %struct.user_signal_info*
  store %struct.user_signal_info* %7, %struct.user_signal_info** %p, align 8
  %8 = load i32, i32* %sig.addr, align 4
  %9 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %sig2 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %9, i32 0, i32 0
  store i32 %8, i32* %sig2, align 4
  %10 = load i8*, i8** %name.addr, align 8
  %call3 = call noalias i8* @xstrdup(i8* %10)
  %11 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %name4 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %11, i32 0, i32 1
  store i8* %call3, i8** %name4, align 8
  %12 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %npending = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %12, i32 0, i32 2
  store i32 0, i32* %npending, align 4
  %13 = load %struct.user_signal_info*, %struct.user_signal_info** @user_signals, align 8
  %14 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %next5 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %14, i32 0, i32 3
  store %struct.user_signal_info* %13, %struct.user_signal_info** %next5, align 8
  %15 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  store %struct.user_signal_info* %15, %struct.user_signal_info** @user_signals, align 8
  call void @emacs_sigaction_init(%struct.sigaction* %action, void (i32)* @deliver_user_signal)
  %16 = load i32, i32* %sig.addr, align 4
  %call6 = call i32 @sigaction(i32 %16, %struct.sigaction* %action, %struct.sigaction* null) #8
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

declare noalias i8* @xstrdup(i8*) #1

declare void @emacs_sigaction_init(%struct.sigaction*, void (i32)*) #1

; Function Attrs: nounwind uwtable
define internal void @deliver_user_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load i32, i32* %sig.addr, align 4
  call void @deliver_process_signal(i32 %0, void (i32)* @handle_user_signal)
  ret void
}

; Function Attrs: nounwind
declare i32 @sigaction(i32, %struct.sigaction*, %struct.sigaction*) #6

; Function Attrs: nounwind uwtable
define zeroext i1 @menu_separator_name_p(i8* %label) #0 {
entry:
  %retval = alloca i1, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  store i8* %label, i8** %label.addr, align 8
  %0 = load i8*, i8** %label.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i8*, i8** %label.addr, align 8
  %call = call i64 @strlen(i8* %1) #13
  %cmp = icmp ugt i64 %call, 3
  br i1 %cmp, label %land.lhs.true, label %if.else.15

land.lhs.true:                                    ; preds = %if.else
  %2 = load i8*, i8** %label.addr, align 8
  %call1 = call i32 @memcmp(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.18, i32 0, i32 0), i64 2) #13
  %cmp2 = icmp eq i32 %call1, 0
  br i1 %cmp2, label %land.lhs.true.3, label %if.else.15

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %3 = load i8*, i8** %label.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 2
  %4 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %4 to i32
  %cmp4 = icmp ne i32 %conv, 45
  br i1 %cmp4, label %if.then.6, label %if.else.15

if.then.6:                                        ; preds = %land.lhs.true.3
  %5 = load i8*, i8** %label.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %5, i64 2
  store i8* %add.ptr, i8** %label.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.6
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx7 = getelementptr inbounds [15 x i8*], [15 x i8*]* @separator_names, i32 0, i64 %idxprom
  %7 = load i8*, i8** %arrayidx7, align 8
  %tobool8 = icmp ne i8* %7, null
  br i1 %tobool8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i8*, i8** %label.addr, align 8
  %9 = load i32, i32* %i, align 4
  %idxprom9 = sext i32 %9 to i64
  %arrayidx10 = getelementptr inbounds [15 x i8*], [15 x i8*]* @separator_names, i32 0, i64 %idxprom9
  %10 = load i8*, i8** %arrayidx10, align 8
  %call11 = call i32 @strcmp(i8* %8, i8* %10) #13
  %cmp12 = icmp eq i32 %call11, 0
  br i1 %cmp12, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %for.body
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32, i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.22

if.else.15:                                       ; preds = %land.lhs.true.3, %land.lhs.true, %if.else
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else.15
  %12 = load i8*, i8** %label.addr, align 8
  %13 = load i8, i8* %12, align 1
  %conv16 = sext i8 %13 to i32
  %cmp17 = icmp eq i32 %conv16, 45
  br i1 %cmp17, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load i8*, i8** %label.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr, i8** %label.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %15 = load i8*, i8** %label.addr, align 8
  %16 = load i8, i8* %15, align 1
  %conv19 = sext i8 %16 to i32
  %cmp20 = icmp eq i32 %conv19, 0
  store i1 %cmp20, i1* %retval
  br label %return

if.end.22:                                        ; preds = %for.end
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.22
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %if.end.23, %while.end, %if.then.14, %if.then
  %17 = load i1, i1* %retval
  ret i1 %17
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #7

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #7

; Function Attrs: nounwind uwtable
define i64 @menu_bar_items(i64 %old) #0 {
entry:
  %old.addr = alloca i64, align 8
  %nmaps = alloca i64, align 8
  %maps = alloca i64*, align 8
  %mapsbuf = alloca [3 x i64], align 16
  %def = alloca i64, align 8
  %tail = alloca i64, align 8
  %mapno = alloca i64, align 8
  %oquit = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %tmaps = alloca i64*, align 8
  %nminor = alloca i64, align 8
  %tem = alloca i64, align 8
  %i = alloca i32, align 4
  %end = alloca i32, align 4
  %tem0 = alloca i64, align 8
  %tem1 = alloca i64, align 8
  %tem2 = alloca i64, align 8
  %tem3 = alloca i64, align 8
  %i140 = alloca i32, align 4
  store i64 %old, i64* %old.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  store i64 %0, i64* %oquit, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %1 = load i64, i64* %old.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call2
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %old.addr, align 8
  store i64 %2, i64* @menu_bar_items_vector, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fmake_vector(i64 98, i64 %call3)
  store i64 %call4, i64* @menu_bar_items_vector, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* @menu_bar_items_index, align 4
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %3, %call5
  br i1 %cmp6, label %if.else.21, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %4, %call7
  br i1 %cmp8, label %if.else.21, label %if.then.9

if.then.9:                                        ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %mapsbuf, i32 0, i32 0
  store i64* %arraydecay, i64** %maps, align 8
  store i64 0, i64* %nmaps, align 8
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %5, i32 0, i32 1
  %6 = load i64, i64* %Voverriding_terminal_local_map_, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %6, %call10
  br i1 %cmp11, label %if.end.14, label %if.then.12

if.then.12:                                       ; preds = %if.then.9
  %7 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_13 = getelementptr inbounds %struct.kboard, %struct.kboard* %7, i32 0, i32 1
  %8 = load i64, i64* %Voverriding_terminal_local_map_13, align 8
  %9 = load i64, i64* %nmaps, align 8
  %inc = add nsw i64 %9, 1
  store i64 %inc, i64* %nmaps, align 8
  %10 = load i64*, i64** %maps, align 8
  %arrayidx = getelementptr inbounds i64, i64* %10, i64 %9
  store i64 %8, i64* %arrayidx, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.12, %if.then.9
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %11, %call15
  br i1 %cmp16, label %if.end.20, label %if.then.17

if.then.17:                                       ; preds = %if.end.14
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %13 = load i64, i64* %nmaps, align 8
  %inc18 = add nsw i64 %13, 1
  store i64 %inc18, i64* %nmaps, align 8
  %14 = load i64*, i64** %maps, align 8
  %arrayidx19 = getelementptr inbounds i64, i64* %14, i64 %13
  store i64 %12, i64* %arrayidx19, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.17, %if.end.14
  br label %if.end.63

if.else.21:                                       ; preds = %land.lhs.true, %if.end
  %call22 = call i64 @current_minor_maps(i64** null, i64** %tmaps)
  store i64 %call22, i64* %nminor, align 8
  br label %do.body

do.body:                                          ; preds = %if.else.21
  %15 = load i64, i64* %nminor, align 8
  %add = add nsw i64 %15, 4
  %16 = load i64, i64* %sa_avail, align 8
  %div = udiv i64 %16, 8
  %div23 = udiv i64 %div, 1
  %cmp24 = icmp ule i64 %add, %div23
  br i1 %cmp24, label %if.then.25, label %if.else.29

if.then.25:                                       ; preds = %do.body
  %17 = load i64, i64* %nminor, align 8
  %add26 = add nsw i64 %17, 4
  %mul = mul i64 8, %add26
  %18 = load i64, i64* %sa_avail, align 8
  %sub = sub i64 %18, %mul
  store i64 %sub, i64* %sa_avail, align 8
  %19 = load i64, i64* %nminor, align 8
  %add27 = add nsw i64 %19, 4
  %mul28 = mul i64 8, %add27
  %20 = alloca i8, i64 %mul28
  %21 = bitcast i8* %20 to i64*
  store i64* %21, i64** %maps, align 8
  br label %if.end.32

if.else.29:                                       ; preds = %do.body
  %22 = load i64, i64* %nminor, align 8
  %add30 = add nsw i64 %22, 4
  %call31 = call noalias i8* @xnmalloc(i64 %add30, i64 8)
  %23 = bitcast i8* %call31 to i64*
  store i64* %23, i64** %maps, align 8
  store i8 1, i8* %sa_must_free, align 1
  %24 = load i64*, i64** %maps, align 8
  %25 = bitcast i64* %24 to i8*
  call void @record_unwind_protect_ptr(void (i8*)* @xfree, i8* %25)
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.29, %if.then.25
  br label %do.end

do.end:                                           ; preds = %if.end.32
  store i64 0, i64* %nmaps, align 8
  %26 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_33 = getelementptr inbounds %struct.kboard, %struct.kboard* %26, i32 0, i32 1
  %27 = load i64, i64* %Voverriding_terminal_local_map_33, align 8
  store i64 %27, i64* %tem, align 8
  %28 = load i64, i64* %tem, align 8
  %call34 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp35 = icmp eq i64 %28, %call34
  br i1 %cmp35, label %if.end.42, label %land.lhs.true.36

land.lhs.true.36:                                 ; preds = %do.end
  %29 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217), align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp38 = icmp eq i64 %29, %call37
  br i1 %cmp38, label %if.end.42, label %if.then.39

if.then.39:                                       ; preds = %land.lhs.true.36
  %30 = load i64, i64* %tem, align 8
  %31 = load i64, i64* %nmaps, align 8
  %inc40 = add nsw i64 %31, 1
  store i64 %inc40, i64* %nmaps, align 8
  %32 = load i64*, i64** %maps, align 8
  %arrayidx41 = getelementptr inbounds i64, i64* %32, i64 %31
  store i64 %30, i64* %arrayidx41, align 8
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.39, %land.lhs.true.36, %do.end
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %33, i32 0, i32 75
  %34 = load i64, i64* %pt, align 8
  %add43 = add nsw i64 %34, 0
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 589)
  %call45 = call i64 @get_local_map(i64 %add43, %struct.buffer* %35, i64 %call44)
  store i64 %call45, i64* %tem, align 8
  %36 = load i64, i64* %tem, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %36, %call46
  %lnot = xor i1 %cmp47, true
  br i1 %lnot, label %if.then.48, label %if.end.51

if.then.48:                                       ; preds = %if.end.42
  %37 = load i64, i64* %tem, align 8
  %38 = load i64, i64* %nmaps, align 8
  %inc49 = add nsw i64 %38, 1
  store i64 %inc49, i64* %nmaps, align 8
  %39 = load i64*, i64** %maps, align 8
  %arrayidx50 = getelementptr inbounds i64, i64* %39, i64 %38
  store i64 %37, i64* %arrayidx50, align 8
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.48, %if.end.42
  %40 = load i64, i64* %nminor, align 8
  %cmp52 = icmp ne i64 %40, 0
  br i1 %cmp52, label %if.then.53, label %if.end.56

if.then.53:                                       ; preds = %if.end.51
  %41 = load i64*, i64** %maps, align 8
  %42 = load i64, i64* %nmaps, align 8
  %add.ptr = getelementptr inbounds i64, i64* %41, i64 %42
  %43 = bitcast i64* %add.ptr to i8*
  %44 = load i64*, i64** %tmaps, align 8
  %45 = bitcast i64* %44 to i8*
  %46 = load i64, i64* %nminor, align 8
  %mul54 = mul i64 %46, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %43, i8* %45, i64 %mul54, i32 8, i1 false)
  %47 = load i64, i64* %nminor, align 8
  %48 = load i64, i64* %nmaps, align 8
  %add55 = add nsw i64 %48, %47
  store i64 %add55, i64* %nmaps, align 8
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.53, %if.end.51
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt57 = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 75
  %50 = load i64, i64* %pt57, align 8
  %add58 = add nsw i64 %50, 0
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 633)
  %call60 = call i64 @get_local_map(i64 %add58, %struct.buffer* %51, i64 %call59)
  %52 = load i64, i64* %nmaps, align 8
  %inc61 = add nsw i64 %52, 1
  store i64 %inc61, i64* %nmaps, align 8
  %53 = load i64*, i64** %maps, align 8
  %arrayidx62 = getelementptr inbounds i64, i64* %53, i64 %52
  store i64 %call60, i64* %arrayidx62, align 8
  br label %if.end.63

if.end.63:                                        ; preds = %if.end.56, %if.end.20
  %54 = load i64, i64* @current_global_map, align 8
  %55 = load i64, i64* %nmaps, align 8
  %inc64 = add nsw i64 %55, 1
  store i64 %inc64, i64* %nmaps, align 8
  %56 = load i64*, i64** %maps, align 8
  %arrayidx65 = getelementptr inbounds i64, i64* %56, i64 %55
  store i64 %54, i64* %arrayidx65, align 8
  %57 = load i64, i64* %nmaps, align 8
  %sub66 = sub nsw i64 %57, 1
  store i64 %sub66, i64* %mapno, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.63
  %58 = load i64, i64* %mapno, align 8
  %cmp67 = icmp sge i64 %58, 0
  br i1 %cmp67, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %59 = load i64, i64* %mapno, align 8
  %60 = load i64*, i64** %maps, align 8
  %arrayidx68 = getelementptr inbounds i64, i64* %60, i64 %59
  %61 = load i64, i64* %arrayidx68, align 8
  %call69 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp70 = icmp eq i64 %61, %call69
  br i1 %cmp70, label %if.end.82, label %if.then.71

if.then.71:                                       ; preds = %for.body
  %62 = load i64, i64* %mapno, align 8
  %63 = load i64*, i64** %maps, align 8
  %arrayidx72 = getelementptr inbounds i64, i64* %63, i64 %62
  %64 = load i64, i64* %arrayidx72, align 8
  %call73 = call i64 @builtin_lisp_symbol(i32 651)
  %call74 = call i64 @access_keymap(i64 %64, i64 %call73, i1 zeroext true, i1 zeroext false, i1 zeroext true)
  %call75 = call i64 @get_keymap(i64 %call74, i1 zeroext false, i1 zeroext true)
  store i64 %call75, i64* %def, align 8
  %65 = load i64, i64* %def, align 8
  %and = and i64 %65, 7
  %conv = trunc i64 %and to i32
  %cmp76 = icmp eq i32 %conv, 3
  br i1 %cmp76, label %if.then.78, label %if.end.81

if.then.78:                                       ; preds = %if.then.71
  %call79 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call79, i64* @menu_bar_one_keymap_changed_items, align 8
  %66 = load i64, i64* %def, align 8
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  call void @map_keymap_canonical(i64 %66, void (i64, i64, i64, i8*)* @menu_bar_item, i64 %call80, i8* null)
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.78, %if.then.71
  br label %if.end.82

if.end.82:                                        ; preds = %if.end.81, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.82
  %67 = load i64, i64* %mapno, align 8
  %dec = add nsw i64 %67, -1
  store i64 %dec, i64* %mapno, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %68 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 176), align 8
  store i64 %68, i64* %tail, align 8
  br label %for.cond.83

for.cond.83:                                      ; preds = %for.inc.137, %for.end
  %69 = load i64, i64* %tail, align 8
  %and84 = and i64 %69, 7
  %conv85 = trunc i64 %and84 to i32
  %cmp86 = icmp eq i32 %conv85, 3
  br i1 %cmp86, label %for.body.88, label %for.end.139

for.body.88:                                      ; preds = %for.cond.83
  %70 = load i32, i32* @menu_bar_items_index, align 4
  store i32 %70, i32* %end, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond.89

for.cond.89:                                      ; preds = %for.inc.134, %for.body.88
  %71 = load i32, i32* %i, align 4
  %72 = load i32, i32* %end, align 4
  %cmp90 = icmp slt i32 %71, %72
  br i1 %cmp90, label %for.body.92, label %for.end.136

for.body.92:                                      ; preds = %for.cond.89
  %73 = load i64, i64* %tail, align 8
  %sub93 = sub nsw i64 %73, 3
  %74 = inttoptr i64 %sub93 to i8*
  %75 = bitcast i8* %74 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %75, i32 0, i32 0
  %76 = load i64, i64* %car, align 8
  %77 = load i64, i64* @menu_bar_items_vector, align 8
  %78 = load i32, i32* %i, align 4
  %conv94 = sext i32 %78 to i64
  %call95 = call i64 @AREF(i64 %77, i64 %conv94)
  %cmp96 = icmp eq i64 %76, %call95
  br i1 %cmp96, label %if.then.98, label %if.end.133

if.then.98:                                       ; preds = %for.body.92
  %79 = load i64, i64* @menu_bar_items_vector, align 8
  %80 = load i32, i32* %i, align 4
  %add99 = add nsw i32 %80, 0
  %conv100 = sext i32 %add99 to i64
  %call101 = call i64 @AREF(i64 %79, i64 %conv100)
  store i64 %call101, i64* %tem0, align 8
  %81 = load i64, i64* @menu_bar_items_vector, align 8
  %82 = load i32, i32* %i, align 4
  %add102 = add nsw i32 %82, 1
  %conv103 = sext i32 %add102 to i64
  %call104 = call i64 @AREF(i64 %81, i64 %conv103)
  store i64 %call104, i64* %tem1, align 8
  %83 = load i64, i64* @menu_bar_items_vector, align 8
  %84 = load i32, i32* %i, align 4
  %add105 = add nsw i32 %84, 2
  %conv106 = sext i32 %add105 to i64
  %call107 = call i64 @AREF(i64 %83, i64 %conv106)
  store i64 %call107, i64* %tem2, align 8
  %85 = load i64, i64* @menu_bar_items_vector, align 8
  %86 = load i32, i32* %i, align 4
  %add108 = add nsw i32 %86, 3
  %conv109 = sext i32 %add108 to i64
  %call110 = call i64 @AREF(i64 %85, i64 %conv109)
  store i64 %call110, i64* %tem3, align 8
  %87 = load i32, i32* %end, align 4
  %88 = load i32, i32* %i, align 4
  %add111 = add nsw i32 %88, 4
  %cmp112 = icmp sgt i32 %87, %add111
  br i1 %cmp112, label %if.then.114, label %if.end.124

if.then.114:                                      ; preds = %if.then.98
  %89 = load i64, i64* @menu_bar_items_vector, align 8
  %90 = load i32, i32* %i, align 4
  %conv115 = sext i32 %90 to i64
  %call116 = call i64* @aref_addr(i64 %89, i64 %conv115)
  %91 = bitcast i64* %call116 to i8*
  %92 = load i64, i64* @menu_bar_items_vector, align 8
  %93 = load i32, i32* %i, align 4
  %add117 = add nsw i32 %93, 4
  %conv118 = sext i32 %add117 to i64
  %call119 = call i64* @aref_addr(i64 %92, i64 %conv118)
  %94 = bitcast i64* %call119 to i8*
  %95 = load i32, i32* %end, align 4
  %96 = load i32, i32* %i, align 4
  %sub120 = sub nsw i32 %95, %96
  %sub121 = sub nsw i32 %sub120, 4
  %mul122 = mul nsw i32 %sub121, 8
  %conv123 = sext i32 %mul122 to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %91, i8* %94, i64 %conv123, i32 8, i1 false)
  br label %if.end.124

if.end.124:                                       ; preds = %if.then.114, %if.then.98
  %97 = load i64, i64* @menu_bar_items_vector, align 8
  %98 = load i32, i32* %end, align 4
  %sub125 = sub nsw i32 %98, 4
  %conv126 = sext i32 %sub125 to i64
  %99 = load i64, i64* %tem0, align 8
  call void @ASET(i64 %97, i64 %conv126, i64 %99)
  %100 = load i64, i64* @menu_bar_items_vector, align 8
  %101 = load i32, i32* %end, align 4
  %sub127 = sub nsw i32 %101, 3
  %conv128 = sext i32 %sub127 to i64
  %102 = load i64, i64* %tem1, align 8
  call void @ASET(i64 %100, i64 %conv128, i64 %102)
  %103 = load i64, i64* @menu_bar_items_vector, align 8
  %104 = load i32, i32* %end, align 4
  %sub129 = sub nsw i32 %104, 2
  %conv130 = sext i32 %sub129 to i64
  %105 = load i64, i64* %tem2, align 8
  call void @ASET(i64 %103, i64 %conv130, i64 %105)
  %106 = load i64, i64* @menu_bar_items_vector, align 8
  %107 = load i32, i32* %end, align 4
  %sub131 = sub nsw i32 %107, 1
  %conv132 = sext i32 %sub131 to i64
  %108 = load i64, i64* %tem3, align 8
  call void @ASET(i64 %106, i64 %conv132, i64 %108)
  br label %for.end.136

if.end.133:                                       ; preds = %for.body.92
  br label %for.inc.134

for.inc.134:                                      ; preds = %if.end.133
  %109 = load i32, i32* %i, align 4
  %add135 = add nsw i32 %109, 4
  store i32 %add135, i32* %i, align 4
  br label %for.cond.89

for.end.136:                                      ; preds = %if.end.124, %for.cond.89
  br label %for.inc.137

for.inc.137:                                      ; preds = %for.end.136
  %110 = load i64, i64* %tail, align 8
  %sub138 = sub nsw i64 %110, 3
  %111 = inttoptr i64 %sub138 to i8*
  %112 = bitcast i8* %111 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %112, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %113 = load i64, i64* %cdr, align 8
  store i64 %113, i64* %tail, align 8
  br label %for.cond.83

for.end.139:                                      ; preds = %for.cond.83
  %114 = load i32, i32* @menu_bar_items_index, align 4
  store i32 %114, i32* %i140, align 4
  %115 = load i32, i32* %i140, align 4
  %add141 = add nsw i32 %115, 4
  %conv142 = sext i32 %add141 to i64
  %116 = load i64, i64* @menu_bar_items_vector, align 8
  %call143 = call i64 @ASIZE(i64 %116)
  %cmp144 = icmp sgt i64 %conv142, %call143
  br i1 %cmp144, label %if.then.146, label %if.end.148

if.then.146:                                      ; preds = %for.end.139
  %117 = load i64, i64* @menu_bar_items_vector, align 8
  %call147 = call i64 @larger_vector(i64 %117, i64 4, i64 -1)
  store i64 %call147, i64* @menu_bar_items_vector, align 8
  br label %if.end.148

if.end.148:                                       ; preds = %if.then.146, %for.end.139
  %118 = load i64, i64* @menu_bar_items_vector, align 8
  %119 = load i32, i32* %i140, align 4
  %conv149 = sext i32 %119 to i64
  %call150 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %118, i64 %conv149, i64 %call150)
  %120 = load i32, i32* %i140, align 4
  %inc151 = add nsw i32 %120, 1
  store i32 %inc151, i32* %i140, align 4
  %121 = load i64, i64* @menu_bar_items_vector, align 8
  %122 = load i32, i32* %i140, align 4
  %conv152 = sext i32 %122 to i64
  %call153 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %121, i64 %conv152, i64 %call153)
  %123 = load i32, i32* %i140, align 4
  %inc154 = add nsw i32 %123, 1
  store i32 %inc154, i32* %i140, align 4
  %124 = load i64, i64* @menu_bar_items_vector, align 8
  %125 = load i32, i32* %i140, align 4
  %conv155 = sext i32 %125 to i64
  %call156 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %124, i64 %conv155, i64 %call156)
  %126 = load i32, i32* %i140, align 4
  %inc157 = add nsw i32 %126, 1
  store i32 %inc157, i32* %i140, align 4
  %127 = load i64, i64* @menu_bar_items_vector, align 8
  %128 = load i32, i32* %i140, align 4
  %conv158 = sext i32 %128 to i64
  %call159 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %127, i64 %conv158, i64 %call159)
  %129 = load i32, i32* %i140, align 4
  %inc160 = add nsw i32 %129, 1
  store i32 %inc160, i32* %i140, align 4
  %130 = load i32, i32* %i140, align 4
  store i32 %130, i32* @menu_bar_items_index, align 4
  %131 = load i64, i64* %oquit, align 8
  store i64 %131, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  br label %do.body.161

do.body.161:                                      ; preds = %if.end.148
  %132 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %132 to i1
  br i1 %tobool, label %if.then.162, label %if.end.165

if.then.162:                                      ; preds = %do.body.161
  store i8 0, i8* %sa_must_free, align 1
  %133 = load i64, i64* %sa_count, align 8
  %call163 = call i64 @builtin_lisp_symbol(i32 0)
  %call164 = call i64 @unbind_to(i64 %133, i64 %call163)
  br label %if.end.165

if.end.165:                                       ; preds = %if.then.162, %do.body.161
  br label %do.end.166

do.end.166:                                       ; preds = %if.end.165
  %134 = load i64, i64* @menu_bar_items_vector, align 8
  ret i64 %134
}

declare i64 @Fmake_vector(i64, i64) #1

declare i64 @current_minor_maps(i64**, i64**) #1

declare noalias i8* @xnmalloc(i64, i64) #1

declare void @record_unwind_protect_ptr(void (i8*)*, i8*) #1

declare i64 @get_local_map(i64, %struct.buffer*, i64) #1

declare void @map_keymap_canonical(i64, void (i64, i64, i64, i8*)*, i64, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @menu_bar_item(i64 %key, i64 %item, i64 %dummy1, i8* %dummy2) #0 {
entry:
  %key.addr = alloca i64, align 8
  %item.addr = alloca i64, align 8
  %dummy1.addr = alloca i64, align 8
  %dummy2.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %parsed = alloca i8, align 1
  %tem = alloca i64, align 8
  %old = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %item, i64* %item.addr, align 8
  store i64 %dummy1, i64* %dummy1.addr, align 8
  store i8* %dummy2, i8** %dummy2.addr, align 8
  %0 = load i64, i64* %item.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 959)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end.19

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* @menu_bar_items_index, align 4
  %cmp1 = icmp slt i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* %key.addr, align 8
  %4 = load i64, i64* @menu_bar_items_vector, align 8
  %5 = load i32, i32* %i, align 4
  %conv = sext i32 %5 to i64
  %call2 = call i64 @AREF(i64 %4, i64 %conv)
  %cmp3 = icmp eq i64 %3, %call2
  br i1 %cmp3, label %if.then.5, label %if.end.17

if.then.5:                                        ; preds = %for.body
  %6 = load i32, i32* @menu_bar_items_index, align 4
  %7 = load i32, i32* %i, align 4
  %add = add nsw i32 %7, 4
  %cmp6 = icmp sgt i32 %6, %add
  br i1 %cmp6, label %if.then.8, label %if.end

if.then.8:                                        ; preds = %if.then.5
  %8 = load i64, i64* @menu_bar_items_vector, align 8
  %9 = load i32, i32* %i, align 4
  %conv9 = sext i32 %9 to i64
  %call10 = call i64* @aref_addr(i64 %8, i64 %conv9)
  %10 = bitcast i64* %call10 to i8*
  %11 = load i64, i64* @menu_bar_items_vector, align 8
  %12 = load i32, i32* %i, align 4
  %add11 = add nsw i32 %12, 4
  %conv12 = sext i32 %add11 to i64
  %call13 = call i64* @aref_addr(i64 %11, i64 %conv12)
  %13 = bitcast i64* %call13 to i8*
  %14 = load i32, i32* @menu_bar_items_index, align 4
  %15 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %14, %15
  %sub14 = sub nsw i32 %sub, 4
  %mul = mul nsw i32 %sub14, 8
  %conv15 = sext i32 %mul to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %10, i8* %13, i64 %conv15, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then.8, %if.then.5
  %16 = load i32, i32* @menu_bar_items_index, align 4
  %sub16 = sub nsw i32 %16, 4
  store i32 %sub16, i32* @menu_bar_items_index, align 4
  br label %if.end.17

if.end.17:                                        ; preds = %if.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.17
  %17 = load i32, i32* %i, align 4
  %add18 = add nsw i32 %17, 4
  store i32 %add18, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.19

if.end.19:                                        ; preds = %for.end, %entry
  %18 = load i64, i64* %key.addr, align 8
  %19 = load i64, i64* @menu_bar_one_keymap_changed_items, align 8
  %call20 = call i64 @Fmemq(i64 %18, i64 %19)
  store i64 %call20, i64* %tem, align 8
  %20 = load i64, i64* %tem, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %20, %call21
  br i1 %cmp22, label %lor.lhs.false, label %if.then.27

lor.lhs.false:                                    ; preds = %if.end.19
  %21 = load i64, i64* %item.addr, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp25 = icmp eq i64 %21, %call24
  br i1 %cmp25, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %lor.lhs.false, %if.end.19
  br label %if.end.83

if.end.28:                                        ; preds = %lor.lhs.false
  %22 = load i64, i64* %key.addr, align 8
  %23 = load i64, i64* @menu_bar_one_keymap_changed_items, align 8
  %call29 = call i64 @Fcons(i64 %22, i64 %23)
  store i64 %call29, i64* @menu_bar_one_keymap_changed_items, align 8
  %24 = load i64, i64* %item.addr, align 8
  %call30 = call zeroext i1 @parse_menu_item(i64 %24, i32 1)
  %frombool = zext i1 %call30 to i8
  store i8 %frombool, i8* %parsed, align 1
  %25 = load i8, i8* %parsed, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %if.end.32, label %if.then.31

if.then.31:                                       ; preds = %if.end.28
  br label %if.end.83

if.end.32:                                        ; preds = %if.end.28
  %26 = load i64, i64* @item_properties, align 8
  %call33 = call i64 @AREF(i64 %26, i64 2)
  store i64 %call33, i64* %item.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.34

for.cond.34:                                      ; preds = %for.inc.44, %if.end.32
  %27 = load i32, i32* %i, align 4
  %28 = load i32, i32* @menu_bar_items_index, align 4
  %cmp35 = icmp slt i32 %27, %28
  br i1 %cmp35, label %for.body.37, label %for.end.46

for.body.37:                                      ; preds = %for.cond.34
  %29 = load i64, i64* %key.addr, align 8
  %30 = load i64, i64* @menu_bar_items_vector, align 8
  %31 = load i32, i32* %i, align 4
  %conv38 = sext i32 %31 to i64
  %call39 = call i64 @AREF(i64 %30, i64 %conv38)
  %cmp40 = icmp eq i64 %29, %call39
  br i1 %cmp40, label %if.then.42, label %if.end.43

if.then.42:                                       ; preds = %for.body.37
  br label %for.end.46

if.end.43:                                        ; preds = %for.body.37
  br label %for.inc.44

for.inc.44:                                       ; preds = %if.end.43
  %32 = load i32, i32* %i, align 4
  %add45 = add nsw i32 %32, 4
  store i32 %add45, i32* %i, align 4
  br label %for.cond.34

for.end.46:                                       ; preds = %if.then.42, %for.cond.34
  %33 = load i32, i32* %i, align 4
  %34 = load i32, i32* @menu_bar_items_index, align 4
  %cmp47 = icmp eq i32 %33, %34
  br i1 %cmp47, label %if.then.49, label %if.else

if.then.49:                                       ; preds = %for.end.46
  %35 = load i32, i32* %i, align 4
  %add50 = add nsw i32 %35, 4
  %conv51 = sext i32 %add50 to i64
  %36 = load i64, i64* @menu_bar_items_vector, align 8
  %call52 = call i64 @ASIZE(i64 %36)
  %cmp53 = icmp sgt i64 %conv51, %call52
  br i1 %cmp53, label %if.then.55, label %if.end.57

if.then.55:                                       ; preds = %if.then.49
  %37 = load i64, i64* @menu_bar_items_vector, align 8
  %call56 = call i64 @larger_vector(i64 %37, i64 4, i64 -1)
  store i64 %call56, i64* @menu_bar_items_vector, align 8
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.55, %if.then.49
  %38 = load i64, i64* @menu_bar_items_vector, align 8
  %39 = load i32, i32* %i, align 4
  %conv58 = sext i32 %39 to i64
  %40 = load i64, i64* %key.addr, align 8
  call void @ASET(i64 %38, i64 %conv58, i64 %40)
  %41 = load i32, i32* %i, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %i, align 4
  %42 = load i64, i64* @menu_bar_items_vector, align 8
  %43 = load i32, i32* %i, align 4
  %conv59 = sext i32 %43 to i64
  %44 = load i64, i64* @item_properties, align 8
  %call60 = call i64 @AREF(i64 %44, i64 1)
  call void @ASET(i64 %42, i64 %conv59, i64 %call60)
  %45 = load i32, i32* %i, align 4
  %inc61 = add nsw i32 %45, 1
  store i32 %inc61, i32* %i, align 4
  %46 = load i64, i64* @menu_bar_items_vector, align 8
  %47 = load i32, i32* %i, align 4
  %conv62 = sext i32 %47 to i64
  %48 = load i64, i64* %item.addr, align 8
  %call63 = call i64 @list1(i64 %48)
  call void @ASET(i64 %46, i64 %conv62, i64 %call63)
  %49 = load i32, i32* %i, align 4
  %inc64 = add nsw i32 %49, 1
  store i32 %inc64, i32* %i, align 4
  %50 = load i64, i64* @menu_bar_items_vector, align 8
  %51 = load i32, i32* %i, align 4
  %conv65 = sext i32 %51 to i64
  call void @ASET(i64 %50, i64 %conv65, i64 2)
  %52 = load i32, i32* %i, align 4
  %inc66 = add nsw i32 %52, 1
  store i32 %inc66, i32* %i, align 4
  %53 = load i32, i32* %i, align 4
  store i32 %53, i32* @menu_bar_items_index, align 4
  br label %if.end.83

if.else:                                          ; preds = %for.end.46
  %54 = load i64, i64* @menu_bar_items_vector, align 8
  %55 = load i32, i32* %i, align 4
  %add67 = add nsw i32 %55, 2
  %conv68 = sext i32 %add67 to i64
  %call69 = call i64 @AREF(i64 %54, i64 %conv68)
  store i64 %call69, i64* %old, align 8
  %56 = load i64, i64* %item.addr, align 8
  %57 = load i64, i64* %item.addr, align 8
  %call70 = call i64 @get_keymap(i64 %57, i1 zeroext false, i1 zeroext false)
  %call71 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp72 = icmp eq i64 %call70, %call71
  br i1 %cmp72, label %cond.false, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %58 = load i64, i64* %old, align 8
  %sub74 = sub nsw i64 %58, 3
  %59 = inttoptr i64 %sub74 to i8*
  %60 = bitcast i8* %59 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %60, i32 0, i32 0
  %61 = load i64, i64* %car, align 8
  %call75 = call i64 @get_keymap(i64 %61, i1 zeroext false, i1 zeroext false)
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp77 = icmp eq i64 %call75, %call76
  br i1 %cmp77, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %62 = load i64, i64* %old, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.else
  %call79 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %62, %cond.true ], [ %call79, %cond.false ]
  %call80 = call i64 @Fcons(i64 %56, i64 %cond)
  store i64 %call80, i64* %item.addr, align 8
  %63 = load i64, i64* @menu_bar_items_vector, align 8
  %64 = load i32, i32* %i, align 4
  %add81 = add nsw i32 %64, 2
  %conv82 = sext i32 %add81 to i64
  %65 = load i64, i64* %item.addr, align 8
  call void @ASET(i64 %63, i64 %conv82, i64 %65)
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.27, %if.then.31, %cond.end, %if.end.57
  ret void
}

declare i64 @AREF(i64, i64) #1

declare i64* @aref_addr(i64, i64) #1

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #8

declare i64 @larger_vector(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @menu_item_eval_property(i64 %sexpr) #0 {
entry:
  %sexpr.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %sexpr, i64* %sexpr.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 548)
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call1, i64 %call2)
  %0 = load i64, i64* %sexpr.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 372)
  %call4 = call i64 @internal_condition_case_1(i64 (i64)* @eval_dyn, i64 %0, i64 %call3, i64 (i64)* @menu_item_eval_property_1)
  store i64 %call4, i64* %val, align 8
  %1 = load i64, i64* %count, align 8
  %2 = load i64, i64* %val, align 8
  %call5 = call i64 @unbind_to(i64 %1, i64 %2)
  ret i64 %call5
}

declare i64 @internal_condition_case_1(i64 (i64)*, i64, i64, i64 (i64)*) #1

; Function Attrs: nounwind uwtable
define internal i64 @eval_dyn(i64 %form) #0 {
entry:
  %form.addr = alloca i64, align 8
  store i64 %form, i64* %form.addr, align 8
  %0 = load i64, i64* %form.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @Feval(i64 %0, i64 %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @menu_item_eval_property_1(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %arg.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %arg.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call = call i64 @builtin_lisp_symbol(i32 782)
  %cmp2 = icmp eq i64 %4, %call
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call4 = call i64 @builtin_lisp_symbol(i32 782)
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @Fsignal(i64 %call4, i64 %call5)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call7
}

; Function Attrs: nounwind uwtable
define zeroext i1 @parse_menu_item(i64 %item, i32 %inmenubar) #0 {
entry:
  %retval = alloca i1, align 1
  %item.addr = alloca i64, align 8
  %inmenubar.addr = alloca i32, align 4
  %def = alloca i64, align 8
  %tem = alloca i64, align 8
  %item_string = alloca i64, align 8
  %start = alloca i64, align 8
  %filter = alloca i64, align 8
  %keyhint = alloca i64, align 8
  %i = alloca i32, align 4
  %help = alloca i64, align 8
  %type = alloca i64, align 8
  %keyeq = alloca i64, align 8
  %space_space = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %prefix = alloca i64, align 8
  %keys = alloca i64, align 8
  store i64 %item, i64* %item.addr, align 8
  store i32 %inmenubar, i32* %inmenubar.addr, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %filter, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %keyhint, align 8
  %0 = load i64, i64* %item.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* @item_properties, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %1, %call3
  br i1 %cmp4, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %call8 = call i64 @Fmake_vector(i64 38, i64 %call7)
  store i64 %call8, i64* @item_properties, align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.6, %if.end
  store i32 2, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.9
  %2 = load i32, i32* %i, align 4
  %cmp10 = icmp slt i32 %2, 8
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* @item_properties, align 8
  %4 = load i32, i32* %i, align 4
  %conv12 = sext i32 %4 to i64
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %3, i64 %conv12, i64 %call13)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = load i64, i64* @item_properties, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 901)
  call void @ASET(i64 %6, i64 8, i64 %call14)
  %7 = load i64, i64* @item_properties, align 8
  %8 = load i64, i64* %item.addr, align 8
  call void @ASET(i64 %7, i64 0, i64 %8)
  %9 = load i64, i64* %item.addr, align 8
  %sub = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car, align 8
  store i64 %12, i64* %item_string, align 8
  %13 = load i64, i64* %item.addr, align 8
  store i64 %13, i64* %start, align 8
  %14 = load i64, i64* %item.addr, align 8
  %sub15 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub15 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %17 = load i64, i64* %cdr, align 8
  store i64 %17, i64* %item.addr, align 8
  %18 = load i64, i64* %item_string, align 8
  %call16 = call zeroext i1 @STRINGP(i64 %18)
  br i1 %call16, label %if.then.17, label %if.else.83

if.then.17:                                       ; preds = %for.end
  %19 = load i64, i64* @item_properties, align 8
  %20 = load i64, i64* %item_string, align 8
  call void @ASET(i64 %19, i64 1, i64 %20)
  %21 = load i64, i64* %item.addr, align 8
  %and18 = and i64 %21, 7
  %conv19 = trunc i64 %and18 to i32
  %cmp20 = icmp eq i32 %conv19, 3
  br i1 %cmp20, label %land.lhs.true, label %if.end.33

land.lhs.true:                                    ; preds = %if.then.17
  %22 = load i64, i64* %item.addr, align 8
  %sub22 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub22 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car23 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car23, align 8
  %call24 = call zeroext i1 @STRINGP(i64 %25)
  br i1 %call24, label %if.then.26, label %if.end.33

if.then.26:                                       ; preds = %land.lhs.true
  %26 = load i64, i64* @item_properties, align 8
  %27 = load i64, i64* %item.addr, align 8
  %sub27 = sub nsw i64 %27, 3
  %28 = inttoptr i64 %sub27 to i8*
  %29 = bitcast i8* %28 to %struct.Lisp_Cons*
  %car28 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %29, i32 0, i32 0
  %30 = load i64, i64* %car28, align 8
  %call29 = call i64 @Fsubstitute_command_keys(i64 %30)
  call void @ASET(i64 %26, i64 7, i64 %call29)
  %31 = load i64, i64* %item.addr, align 8
  store i64 %31, i64* %start, align 8
  %32 = load i64, i64* %item.addr, align 8
  %sub30 = sub nsw i64 %32, 3
  %33 = inttoptr i64 %sub30 to i8*
  %34 = bitcast i8* %33 to %struct.Lisp_Cons*
  %u31 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %34, i32 0, i32 1
  %cdr32 = bitcast %union.anon.12* %u31 to i64*
  %35 = load i64, i64* %cdr32, align 8
  store i64 %35, i64* %item.addr, align 8
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.26, %land.lhs.true, %if.then.17
  %36 = load i64, i64* %item.addr, align 8
  %and34 = and i64 %36, 7
  %conv35 = trunc i64 %and34 to i32
  %cmp36 = icmp eq i32 %conv35, 3
  br i1 %cmp36, label %land.lhs.true.38, label %if.end.63

land.lhs.true.38:                                 ; preds = %if.end.33
  %37 = load i64, i64* %item.addr, align 8
  %sub39 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub39 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car40 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car40, align 8
  %and41 = and i64 %40, 7
  %conv42 = trunc i64 %and41 to i32
  %cmp43 = icmp eq i32 %conv42, 3
  br i1 %cmp43, label %land.lhs.true.45, label %if.end.63

land.lhs.true.45:                                 ; preds = %land.lhs.true.38
  %41 = load i64, i64* %item.addr, align 8
  %sub46 = sub nsw i64 %41, 3
  %42 = inttoptr i64 %sub46 to i8*
  %43 = bitcast i8* %42 to %struct.Lisp_Cons*
  %car47 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %43, i32 0, i32 0
  %44 = load i64, i64* %car47, align 8
  %sub48 = sub nsw i64 %44, 3
  %45 = inttoptr i64 %sub48 to i8*
  %46 = bitcast i8* %45 to %struct.Lisp_Cons*
  %car49 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %46, i32 0, i32 0
  %47 = load i64, i64* %car49, align 8
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp51 = icmp eq i64 %47, %call50
  br i1 %cmp51, label %if.then.59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.45
  %48 = load i64, i64* %item.addr, align 8
  %sub53 = sub nsw i64 %48, 3
  %49 = inttoptr i64 %sub53 to i8*
  %50 = bitcast i8* %49 to %struct.Lisp_Cons*
  %car54 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %50, i32 0, i32 0
  %51 = load i64, i64* %car54, align 8
  %sub55 = sub nsw i64 %51, 3
  %52 = inttoptr i64 %sub55 to i8*
  %53 = bitcast i8* %52 to %struct.Lisp_Cons*
  %car56 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %53, i32 0, i32 0
  %54 = load i64, i64* %car56, align 8
  %call57 = call zeroext i1 @VECTORP(i64 %54)
  br i1 %call57, label %if.then.59, label %if.end.63

if.then.59:                                       ; preds = %lor.lhs.false, %land.lhs.true.45
  %55 = load i64, i64* %item.addr, align 8
  %sub60 = sub nsw i64 %55, 3
  %56 = inttoptr i64 %sub60 to i8*
  %57 = bitcast i8* %56 to %struct.Lisp_Cons*
  %u61 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %57, i32 0, i32 1
  %cdr62 = bitcast %union.anon.12* %u61 to i64*
  %58 = load i64, i64* %cdr62, align 8
  store i64 %58, i64* %item.addr, align 8
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.59, %lor.lhs.false, %land.lhs.true.38, %if.end.33
  %59 = load i64, i64* @item_properties, align 8
  %60 = load i64, i64* %item.addr, align 8
  call void @ASET(i64 %59, i64 2, i64 %60)
  %61 = load i64, i64* %item.addr, align 8
  %and64 = and i64 %61, 7
  %conv65 = trunc i64 %and64 to i32
  %cmp66 = icmp eq i32 %conv65, 0
  br i1 %cmp66, label %if.then.68, label %if.end.82

if.then.68:                                       ; preds = %if.end.63
  %62 = load i64, i64* %item.addr, align 8
  %call69 = call i64 @builtin_lisp_symbol(i32 656)
  %call70 = call i64 @Fget(i64 %62, i64 %call69)
  store i64 %call70, i64* %tem, align 8
  %63 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 81), align 8
  %call71 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp72 = icmp eq i64 %63, %call71
  br i1 %cmp72, label %if.else, label %if.then.74

if.then.74:                                       ; preds = %if.then.68
  %64 = load i64, i64* @item_properties, align 8
  %call75 = call i64 @builtin_lisp_symbol(i32 901)
  call void @ASET(i64 %64, i64 8, i64 %call75)
  br label %if.end.81

if.else:                                          ; preds = %if.then.68
  %65 = load i64, i64* %tem, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp77 = icmp eq i64 %65, %call76
  br i1 %cmp77, label %if.end.80, label %if.then.79

if.then.79:                                       ; preds = %if.else
  %66 = load i64, i64* @item_properties, align 8
  %67 = load i64, i64* %tem, align 8
  call void @ASET(i64 %66, i64 8, i64 %67)
  br label %if.end.80

if.end.80:                                        ; preds = %if.then.79, %if.else
  br label %if.end.81

if.end.81:                                        ; preds = %if.end.80, %if.then.74
  br label %if.end.82

if.end.82:                                        ; preds = %if.end.81, %if.end.63
  br label %if.end.265

if.else.83:                                       ; preds = %for.end
  %68 = load i64, i64* %item_string, align 8
  %call84 = call i64 @builtin_lisp_symbol(i32 657)
  %cmp85 = icmp eq i64 %68, %call84
  br i1 %cmp85, label %land.lhs.true.87, label %if.else.263

land.lhs.true.87:                                 ; preds = %if.else.83
  %69 = load i64, i64* %item.addr, align 8
  %and88 = and i64 %69, 7
  %conv89 = trunc i64 %and88 to i32
  %cmp90 = icmp eq i32 %conv89, 3
  br i1 %cmp90, label %if.then.92, label %if.else.263

if.then.92:                                       ; preds = %land.lhs.true.87
  %70 = load i64, i64* @item_properties, align 8
  %71 = load i64, i64* %item.addr, align 8
  %sub93 = sub nsw i64 %71, 3
  %72 = inttoptr i64 %sub93 to i8*
  %73 = bitcast i8* %72 to %struct.Lisp_Cons*
  %car94 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %73, i32 0, i32 0
  %74 = load i64, i64* %car94, align 8
  call void @ASET(i64 %70, i64 1, i64 %74)
  %75 = load i64, i64* %item.addr, align 8
  %sub95 = sub nsw i64 %75, 3
  %76 = inttoptr i64 %sub95 to i8*
  %77 = bitcast i8* %76 to %struct.Lisp_Cons*
  %u96 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %77, i32 0, i32 1
  %cdr97 = bitcast %union.anon.12* %u96 to i64*
  %78 = load i64, i64* %cdr97, align 8
  store i64 %78, i64* %start, align 8
  %79 = load i64, i64* %start, align 8
  %and98 = and i64 %79, 7
  %conv99 = trunc i64 %and98 to i32
  %cmp100 = icmp eq i32 %conv99, 3
  br i1 %cmp100, label %if.then.102, label %if.else.255

if.then.102:                                      ; preds = %if.then.92
  %80 = load i64, i64* @item_properties, align 8
  %81 = load i64, i64* %start, align 8
  %sub103 = sub nsw i64 %81, 3
  %82 = inttoptr i64 %sub103 to i8*
  %83 = bitcast i8* %82 to %struct.Lisp_Cons*
  %car104 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %83, i32 0, i32 0
  %84 = load i64, i64* %car104, align 8
  call void @ASET(i64 %80, i64 2, i64 %84)
  %85 = load i64, i64* %start, align 8
  %sub105 = sub nsw i64 %85, 3
  %86 = inttoptr i64 %sub105 to i8*
  %87 = bitcast i8* %86 to %struct.Lisp_Cons*
  %u106 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %87, i32 0, i32 1
  %cdr107 = bitcast %union.anon.12* %u106 to i64*
  %88 = load i64, i64* %cdr107, align 8
  store i64 %88, i64* %item.addr, align 8
  %89 = load i64, i64* %item.addr, align 8
  %and108 = and i64 %89, 7
  %conv109 = trunc i64 %and108 to i32
  %cmp110 = icmp eq i32 %conv109, 3
  br i1 %cmp110, label %land.lhs.true.112, label %if.end.123

land.lhs.true.112:                                ; preds = %if.then.102
  %90 = load i64, i64* %item.addr, align 8
  %sub113 = sub nsw i64 %90, 3
  %91 = inttoptr i64 %sub113 to i8*
  %92 = bitcast i8* %91 to %struct.Lisp_Cons*
  %car114 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %92, i32 0, i32 0
  %93 = load i64, i64* %car114, align 8
  %and115 = and i64 %93, 7
  %conv116 = trunc i64 %and115 to i32
  %cmp117 = icmp eq i32 %conv116, 3
  br i1 %cmp117, label %if.then.119, label %if.end.123

if.then.119:                                      ; preds = %land.lhs.true.112
  %94 = load i64, i64* %item.addr, align 8
  %sub120 = sub nsw i64 %94, 3
  %95 = inttoptr i64 %sub120 to i8*
  %96 = bitcast i8* %95 to %struct.Lisp_Cons*
  %u121 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %96, i32 0, i32 1
  %cdr122 = bitcast %union.anon.12* %u121 to i64*
  %97 = load i64, i64* %cdr122, align 8
  store i64 %97, i64* %item.addr, align 8
  br label %if.end.123

if.end.123:                                       ; preds = %if.then.119, %land.lhs.true.112, %if.then.102
  br label %while.cond

while.cond:                                       ; preds = %if.end.251, %if.end.123
  %98 = load i64, i64* %item.addr, align 8
  %and124 = and i64 %98, 7
  %conv125 = trunc i64 %and124 to i32
  %cmp126 = icmp eq i32 %conv125, 3
  br i1 %cmp126, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %99 = load i64, i64* %item.addr, align 8
  %sub128 = sub nsw i64 %99, 3
  %100 = inttoptr i64 %sub128 to i8*
  %101 = bitcast i8* %100 to %struct.Lisp_Cons*
  %u129 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %101, i32 0, i32 1
  %cdr130 = bitcast %union.anon.12* %u129 to i64*
  %102 = load i64, i64* %cdr130, align 8
  %and131 = and i64 %102, 7
  %conv132 = trunc i64 %and131 to i32
  %cmp133 = icmp eq i32 %conv132, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %103 = phi i1 [ false, %while.cond ], [ %cmp133, %land.rhs ]
  br i1 %103, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %104 = load i64, i64* %item.addr, align 8
  %sub135 = sub nsw i64 %104, 3
  %105 = inttoptr i64 %sub135 to i8*
  %106 = bitcast i8* %105 to %struct.Lisp_Cons*
  %car136 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %106, i32 0, i32 0
  %107 = load i64, i64* %car136, align 8
  store i64 %107, i64* %tem, align 8
  %108 = load i64, i64* %item.addr, align 8
  %sub137 = sub nsw i64 %108, 3
  %109 = inttoptr i64 %sub137 to i8*
  %110 = bitcast i8* %109 to %struct.Lisp_Cons*
  %u138 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %110, i32 0, i32 1
  %cdr139 = bitcast %union.anon.12* %u138 to i64*
  %111 = load i64, i64* %cdr139, align 8
  store i64 %111, i64* %item.addr, align 8
  %112 = load i64, i64* %tem, align 8
  %call140 = call i64 @builtin_lisp_symbol(i32 37)
  %cmp141 = icmp eq i64 %112, %call140
  br i1 %cmp141, label %if.then.143, label %if.else.153

if.then.143:                                      ; preds = %while.body
  %113 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 81), align 8
  %call144 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp145 = icmp eq i64 %113, %call144
  br i1 %cmp145, label %if.else.149, label %if.then.147

if.then.147:                                      ; preds = %if.then.143
  %114 = load i64, i64* @item_properties, align 8
  %call148 = call i64 @builtin_lisp_symbol(i32 901)
  call void @ASET(i64 %114, i64 8, i64 %call148)
  br label %if.end.152

if.else.149:                                      ; preds = %if.then.143
  %115 = load i64, i64* @item_properties, align 8
  %116 = load i64, i64* %item.addr, align 8
  %sub150 = sub nsw i64 %116, 3
  %117 = inttoptr i64 %sub150 to i8*
  %118 = bitcast i8* %117 to %struct.Lisp_Cons*
  %car151 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %118, i32 0, i32 0
  %119 = load i64, i64* %car151, align 8
  call void @ASET(i64 %115, i64 8, i64 %119)
  br label %if.end.152

if.end.152:                                       ; preds = %if.else.149, %if.then.147
  br label %if.end.251

if.else.153:                                      ; preds = %while.body
  %120 = load i64, i64* %tem, align 8
  %call154 = call i64 @builtin_lisp_symbol(i32 135)
  %cmp155 = icmp eq i64 %120, %call154
  br i1 %cmp155, label %if.then.157, label %if.else.166

if.then.157:                                      ; preds = %if.else.153
  %121 = load i64, i64* %item.addr, align 8
  %sub158 = sub nsw i64 %121, 3
  %122 = inttoptr i64 %sub158 to i8*
  %123 = bitcast i8* %122 to %struct.Lisp_Cons*
  %car159 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %123, i32 0, i32 0
  %124 = load i64, i64* %car159, align 8
  %call160 = call i64 @menu_item_eval_property(i64 %124)
  store i64 %call160, i64* %tem, align 8
  %125 = load i64, i64* %tem, align 8
  %call161 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp162 = icmp eq i64 %125, %call161
  br i1 %cmp162, label %if.then.164, label %if.end.165

if.then.164:                                      ; preds = %if.then.157
  store i1 false, i1* %retval
  br label %return

if.end.165:                                       ; preds = %if.then.157
  br label %if.end.250

if.else.166:                                      ; preds = %if.else.153
  %126 = load i64, i64* %tem, align 8
  %call167 = call i64 @builtin_lisp_symbol(i32 59)
  %cmp168 = icmp eq i64 %126, %call167
  br i1 %cmp168, label %if.then.170, label %if.else.177

if.then.170:                                      ; preds = %if.else.166
  %127 = load i64, i64* %item.addr, align 8
  %sub171 = sub nsw i64 %127, 3
  %128 = inttoptr i64 %sub171 to i8*
  %129 = bitcast i8* %128 to %struct.Lisp_Cons*
  %car172 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %129, i32 0, i32 0
  %130 = load i64, i64* %car172, align 8
  store i64 %130, i64* %help, align 8
  %131 = load i64, i64* %help, align 8
  %call173 = call zeroext i1 @STRINGP(i64 %131)
  br i1 %call173, label %if.then.174, label %if.end.176

if.then.174:                                      ; preds = %if.then.170
  %132 = load i64, i64* %help, align 8
  %call175 = call i64 @Fsubstitute_command_keys(i64 %132)
  store i64 %call175, i64* %help, align 8
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.174, %if.then.170
  %133 = load i64, i64* @item_properties, align 8
  %134 = load i64, i64* %help, align 8
  call void @ASET(i64 %133, i64 7, i64 %134)
  br label %if.end.249

if.else.177:                                      ; preds = %if.else.166
  %135 = load i64, i64* %tem, align 8
  %call178 = call i64 @builtin_lisp_symbol(i32 42)
  %cmp179 = icmp eq i64 %135, %call178
  br i1 %cmp179, label %if.then.181, label %if.else.182

if.then.181:                                      ; preds = %if.else.177
  %136 = load i64, i64* %item.addr, align 8
  store i64 %136, i64* %filter, align 8
  br label %if.end.248

if.else.182:                                      ; preds = %if.else.177
  %137 = load i64, i64* %tem, align 8
  %call183 = call i64 @builtin_lisp_symbol(i32 70)
  %cmp184 = icmp eq i64 %137, %call183
  br i1 %cmp184, label %if.then.186, label %if.else.201

if.then.186:                                      ; preds = %if.else.182
  %138 = load i64, i64* %item.addr, align 8
  %sub187 = sub nsw i64 %138, 3
  %139 = inttoptr i64 %sub187 to i8*
  %140 = bitcast i8* %139 to %struct.Lisp_Cons*
  %car188 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %140, i32 0, i32 0
  %141 = load i64, i64* %car188, align 8
  store i64 %141, i64* %tem, align 8
  %142 = load i64, i64* %tem, align 8
  %and189 = and i64 %142, 7
  %conv190 = trunc i64 %and189 to i32
  %cmp191 = icmp eq i32 %conv190, 0
  br i1 %cmp191, label %if.then.199, label %lor.lhs.false.193

lor.lhs.false.193:                                ; preds = %if.then.186
  %143 = load i64, i64* %tem, align 8
  %call194 = call zeroext i1 @STRINGP(i64 %143)
  br i1 %call194, label %if.then.199, label %lor.lhs.false.196

lor.lhs.false.196:                                ; preds = %lor.lhs.false.193
  %144 = load i64, i64* %tem, align 8
  %call197 = call zeroext i1 @VECTORP(i64 %144)
  br i1 %call197, label %if.then.199, label %if.end.200

if.then.199:                                      ; preds = %lor.lhs.false.196, %lor.lhs.false.193, %if.then.186
  %145 = load i64, i64* %item.addr, align 8
  store i64 %145, i64* %keyhint, align 8
  br label %if.end.200

if.end.200:                                       ; preds = %if.then.199, %lor.lhs.false.196
  br label %if.end.247

if.else.201:                                      ; preds = %if.else.182
  %146 = load i64, i64* %tem, align 8
  %call202 = call i64 @builtin_lisp_symbol(i32 71)
  %cmp203 = icmp eq i64 %146, %call202
  br i1 %cmp203, label %if.then.205, label %if.else.217

if.then.205:                                      ; preds = %if.else.201
  %147 = load i64, i64* %item.addr, align 8
  %sub206 = sub nsw i64 %147, 3
  %148 = inttoptr i64 %sub206 to i8*
  %149 = bitcast i8* %148 to %struct.Lisp_Cons*
  %car207 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %149, i32 0, i32 0
  %150 = load i64, i64* %car207, align 8
  store i64 %150, i64* %tem, align 8
  %151 = load i64, i64* %tem, align 8
  %and208 = and i64 %151, 7
  %conv209 = trunc i64 %and208 to i32
  %cmp210 = icmp eq i32 %conv209, 3
  br i1 %cmp210, label %if.then.215, label %lor.lhs.false.212

lor.lhs.false.212:                                ; preds = %if.then.205
  %152 = load i64, i64* %tem, align 8
  %call213 = call zeroext i1 @STRINGP(i64 %152)
  br i1 %call213, label %if.then.215, label %if.end.216

if.then.215:                                      ; preds = %lor.lhs.false.212, %if.then.205
  %153 = load i64, i64* @item_properties, align 8
  %154 = load i64, i64* %tem, align 8
  call void @ASET(i64 %153, i64 5, i64 %154)
  br label %if.end.216

if.end.216:                                       ; preds = %if.then.215, %lor.lhs.false.212
  br label %if.end.246

if.else.217:                                      ; preds = %if.else.201
  %155 = load i64, i64* %tem, align 8
  %call218 = call i64 @builtin_lisp_symbol(i32 17)
  %cmp219 = icmp eq i64 %155, %call218
  br i1 %cmp219, label %land.lhs.true.221, label %if.end.245

land.lhs.true.221:                                ; preds = %if.else.217
  %156 = load i64, i64* %item.addr, align 8
  %sub222 = sub nsw i64 %156, 3
  %157 = inttoptr i64 %sub222 to i8*
  %158 = bitcast i8* %157 to %struct.Lisp_Cons*
  %car223 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %158, i32 0, i32 0
  %159 = load i64, i64* %car223, align 8
  %and224 = and i64 %159, 7
  %conv225 = trunc i64 %and224 to i32
  %cmp226 = icmp eq i32 %conv225, 3
  br i1 %cmp226, label %if.then.228, label %if.end.245

if.then.228:                                      ; preds = %land.lhs.true.221
  %160 = load i64, i64* %item.addr, align 8
  %sub229 = sub nsw i64 %160, 3
  %161 = inttoptr i64 %sub229 to i8*
  %162 = bitcast i8* %161 to %struct.Lisp_Cons*
  %car230 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %162, i32 0, i32 0
  %163 = load i64, i64* %car230, align 8
  store i64 %163, i64* %tem, align 8
  %164 = load i64, i64* %tem, align 8
  %sub231 = sub nsw i64 %164, 3
  %165 = inttoptr i64 %sub231 to i8*
  %166 = bitcast i8* %165 to %struct.Lisp_Cons*
  %car232 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %166, i32 0, i32 0
  %167 = load i64, i64* %car232, align 8
  store i64 %167, i64* %type, align 8
  %168 = load i64, i64* %type, align 8
  %call233 = call i64 @builtin_lisp_symbol(i32 130)
  %cmp234 = icmp eq i64 %168, %call233
  br i1 %cmp234, label %if.then.240, label %lor.lhs.false.236

lor.lhs.false.236:                                ; preds = %if.then.228
  %169 = load i64, i64* %type, align 8
  %call237 = call i64 @builtin_lisp_symbol(i32 101)
  %cmp238 = icmp eq i64 %169, %call237
  br i1 %cmp238, label %if.then.240, label %if.end.244

if.then.240:                                      ; preds = %lor.lhs.false.236, %if.then.228
  %170 = load i64, i64* @item_properties, align 8
  %171 = load i64, i64* %tem, align 8
  %sub241 = sub nsw i64 %171, 3
  %172 = inttoptr i64 %sub241 to i8*
  %173 = bitcast i8* %172 to %struct.Lisp_Cons*
  %u242 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %173, i32 0, i32 1
  %cdr243 = bitcast %union.anon.12* %u242 to i64*
  %174 = load i64, i64* %cdr243, align 8
  call void @ASET(i64 %170, i64 6, i64 %174)
  %175 = load i64, i64* @item_properties, align 8
  %176 = load i64, i64* %type, align 8
  call void @ASET(i64 %175, i64 4, i64 %176)
  br label %if.end.244

if.end.244:                                       ; preds = %if.then.240, %lor.lhs.false.236
  br label %if.end.245

if.end.245:                                       ; preds = %if.end.244, %land.lhs.true.221, %if.else.217
  br label %if.end.246

if.end.246:                                       ; preds = %if.end.245, %if.end.216
  br label %if.end.247

if.end.247:                                       ; preds = %if.end.246, %if.end.200
  br label %if.end.248

if.end.248:                                       ; preds = %if.end.247, %if.then.181
  br label %if.end.249

if.end.249:                                       ; preds = %if.end.248, %if.end.176
  br label %if.end.250

if.end.250:                                       ; preds = %if.end.249, %if.end.165
  br label %if.end.251

if.end.251:                                       ; preds = %if.end.250, %if.end.152
  %177 = load i64, i64* %item.addr, align 8
  %sub252 = sub nsw i64 %177, 3
  %178 = inttoptr i64 %sub252 to i8*
  %179 = bitcast i8* %178 to %struct.Lisp_Cons*
  %u253 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %179, i32 0, i32 1
  %cdr254 = bitcast %union.anon.12* %u253 to i64*
  %180 = load i64, i64* %cdr254, align 8
  store i64 %180, i64* %item.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  br label %if.end.262

if.else.255:                                      ; preds = %if.then.92
  %181 = load i32, i32* %inmenubar.addr, align 4
  %tobool = icmp ne i32 %181, 0
  br i1 %tobool, label %if.then.260, label %lor.lhs.false.256

lor.lhs.false.256:                                ; preds = %if.else.255
  %182 = load i64, i64* %start, align 8
  %call257 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp258 = icmp eq i64 %182, %call257
  br i1 %cmp258, label %if.end.261, label %if.then.260

if.then.260:                                      ; preds = %lor.lhs.false.256, %if.else.255
  store i1 false, i1* %retval
  br label %return

if.end.261:                                       ; preds = %lor.lhs.false.256
  br label %if.end.262

if.end.262:                                       ; preds = %if.end.261, %while.end
  br label %if.end.264

if.else.263:                                      ; preds = %land.lhs.true.87, %if.else.83
  store i1 false, i1* %retval
  br label %return

if.end.264:                                       ; preds = %if.end.262
  br label %if.end.265

if.end.265:                                       ; preds = %if.end.264, %if.end.82
  %183 = load i64, i64* @item_properties, align 8
  %call266 = call i64 @AREF(i64 %183, i64 1)
  store i64 %call266, i64* %item_string, align 8
  %184 = load i64, i64* %item_string, align 8
  %call267 = call zeroext i1 @STRINGP(i64 %184)
  br i1 %call267, label %if.end.273, label %if.then.268

if.then.268:                                      ; preds = %if.end.265
  %185 = load i64, i64* %item_string, align 8
  %call269 = call i64 @menu_item_eval_property(i64 %185)
  store i64 %call269, i64* %item_string, align 8
  %186 = load i64, i64* %item_string, align 8
  %call270 = call zeroext i1 @STRINGP(i64 %186)
  br i1 %call270, label %if.end.272, label %if.then.271

if.then.271:                                      ; preds = %if.then.268
  store i1 false, i1* %retval
  br label %return

if.end.272:                                       ; preds = %if.then.268
  %187 = load i64, i64* @item_properties, align 8
  %188 = load i64, i64* %item_string, align 8
  call void @ASET(i64 %187, i64 1, i64 %188)
  br label %if.end.273

if.end.273:                                       ; preds = %if.end.272, %if.end.265
  %189 = load i64, i64* @item_properties, align 8
  %call274 = call i64 @AREF(i64 %189, i64 2)
  store i64 %call274, i64* %def, align 8
  %190 = load i64, i64* %filter, align 8
  %call275 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp276 = icmp eq i64 %190, %call275
  br i1 %cmp276, label %if.end.285, label %if.then.278

if.then.278:                                      ; preds = %if.end.273
  %191 = load i64, i64* %filter, align 8
  %sub279 = sub nsw i64 %191, 3
  %192 = inttoptr i64 %sub279 to i8*
  %193 = bitcast i8* %192 to %struct.Lisp_Cons*
  %car280 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %193, i32 0, i32 0
  %194 = load i64, i64* %car280, align 8
  %call281 = call i64 @builtin_lisp_symbol(i32 783)
  %195 = load i64, i64* %def, align 8
  %call282 = call i64 @list2(i64 %call281, i64 %195)
  %call283 = call i64 @list2(i64 %194, i64 %call282)
  %call284 = call i64 @menu_item_eval_property(i64 %call283)
  store i64 %call284, i64* %def, align 8
  %196 = load i64, i64* @item_properties, align 8
  %197 = load i64, i64* %def, align 8
  call void @ASET(i64 %196, i64 2, i64 %197)
  br label %if.end.285

if.end.285:                                       ; preds = %if.then.278, %if.end.273
  %198 = load i64, i64* @item_properties, align 8
  %call286 = call i64 @AREF(i64 %198, i64 8)
  store i64 %call286, i64* %tem, align 8
  %199 = load i64, i64* %tem, align 8
  %call287 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp288 = icmp eq i64 %199, %call287
  br i1 %cmp288, label %if.end.299, label %if.then.290

if.then.290:                                      ; preds = %if.end.285
  %200 = load i64, i64* %tem, align 8
  %call291 = call i64 @menu_item_eval_property(i64 %200)
  store i64 %call291, i64* %tem, align 8
  %201 = load i32, i32* %inmenubar.addr, align 4
  %tobool292 = icmp ne i32 %201, 0
  br i1 %tobool292, label %land.lhs.true.293, label %if.end.298

land.lhs.true.293:                                ; preds = %if.then.290
  %202 = load i64, i64* %tem, align 8
  %call294 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp295 = icmp eq i64 %202, %call294
  br i1 %cmp295, label %if.then.297, label %if.end.298

if.then.297:                                      ; preds = %land.lhs.true.293
  store i1 false, i1* %retval
  br label %return

if.end.298:                                       ; preds = %land.lhs.true.293, %if.then.290
  %203 = load i64, i64* @item_properties, align 8
  %204 = load i64, i64* %tem, align 8
  call void @ASET(i64 %203, i64 8, i64 %204)
  br label %if.end.299

if.end.299:                                       ; preds = %if.end.298, %if.end.285
  %205 = load i64, i64* %def, align 8
  %call300 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp301 = icmp eq i64 %205, %call300
  br i1 %cmp301, label %if.then.303, label %if.end.305

if.then.303:                                      ; preds = %if.end.299
  %206 = load i32, i32* %inmenubar.addr, align 4
  %tobool304 = icmp ne i32 %206, 0
  %lnot = xor i1 %tobool304, true
  store i1 %lnot, i1* %retval
  br label %return

if.end.305:                                       ; preds = %if.end.299
  %207 = load i64, i64* @item_properties, align 8
  %call306 = call i64 @AREF(i64 %207, i64 2)
  store i64 %call306, i64* %def, align 8
  %208 = load i64, i64* %def, align 8
  %call307 = call i64 @get_keymap(i64 %208, i1 zeroext false, i1 zeroext true)
  store i64 %call307, i64* %tem, align 8
  %209 = load i64, i64* %tem, align 8
  %and308 = and i64 %209, 7
  %conv309 = trunc i64 %and308 to i32
  %cmp310 = icmp eq i32 %conv309, 3
  br i1 %cmp310, label %if.then.312, label %if.end.313

if.then.312:                                      ; preds = %if.end.305
  %210 = load i64, i64* @item_properties, align 8
  %211 = load i64, i64* %tem, align 8
  call void @ASET(i64 %210, i64 3, i64 %211)
  %212 = load i64, i64* @item_properties, align 8
  %213 = load i64, i64* %tem, align 8
  call void @ASET(i64 %212, i64 2, i64 %213)
  store i1 true, i1* %retval
  br label %return

if.end.313:                                       ; preds = %if.end.305
  %214 = load i32, i32* %inmenubar.addr, align 4
  %cmp314 = icmp sgt i32 %214, 0
  br i1 %cmp314, label %if.then.316, label %if.end.317

if.then.316:                                      ; preds = %if.end.313
  store i1 true, i1* %retval
  br label %return

if.end.317:                                       ; preds = %if.end.313
  %215 = load i64, i64* @item_properties, align 8
  %call318 = call i64 @AREF(i64 %215, i64 5)
  store i64 %call318, i64* %keyeq, align 8
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  store i64 2, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.19, i32 0, i32 0), i8** %data, align 8
  %s319 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %216 = bitcast %struct.Lisp_String* %s319 to i8*
  %call320 = call i64 @make_lisp_ptr(i8* %216, i32 4)
  store i64 %call320, i64* %space_space, align 8
  %217 = load i64, i64* %keyeq, align 8
  %call321 = call zeroext i1 @STRINGP(i64 %217)
  br i1 %call321, label %land.lhs.true.323, label %if.else.331

land.lhs.true.323:                                ; preds = %if.end.317
  %218 = load i64, i64* %keyhint, align 8
  %and324 = and i64 %218, 7
  %conv325 = trunc i64 %and324 to i32
  %cmp326 = icmp eq i32 %conv325, 3
  br i1 %cmp326, label %if.else.331, label %if.then.328

if.then.328:                                      ; preds = %land.lhs.true.323
  %219 = load i64, i64* %space_space, align 8
  %220 = load i64, i64* %keyeq, align 8
  %call329 = call i64 @Fsubstitute_command_keys(i64 %220)
  %call330 = call i64 @concat2(i64 %219, i64 %call329)
  store i64 %call330, i64* %keyeq, align 8
  br label %if.end.426

if.else.331:                                      ; preds = %land.lhs.true.323, %if.end.317
  %221 = load i64, i64* %keyeq, align 8
  store i64 %221, i64* %prefix, align 8
  %call332 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call332, i64* %keys, align 8
  %222 = load i64, i64* %prefix, align 8
  %and333 = and i64 %222, 7
  %conv334 = trunc i64 %and333 to i32
  %cmp335 = icmp eq i32 %conv334, 3
  br i1 %cmp335, label %if.then.337, label %if.else.343

if.then.337:                                      ; preds = %if.else.331
  %223 = load i64, i64* %prefix, align 8
  %sub338 = sub nsw i64 %223, 3
  %224 = inttoptr i64 %sub338 to i8*
  %225 = bitcast i8* %224 to %struct.Lisp_Cons*
  %car339 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %225, i32 0, i32 0
  %226 = load i64, i64* %car339, align 8
  store i64 %226, i64* %def, align 8
  %227 = load i64, i64* %prefix, align 8
  %sub340 = sub nsw i64 %227, 3
  %228 = inttoptr i64 %sub340 to i8*
  %229 = bitcast i8* %228 to %struct.Lisp_Cons*
  %u341 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %229, i32 0, i32 1
  %cdr342 = bitcast %union.anon.12* %u341 to i64*
  %230 = load i64, i64* %cdr342, align 8
  store i64 %230, i64* %prefix, align 8
  br label %if.end.345

if.else.343:                                      ; preds = %if.else.331
  %231 = load i64, i64* @item_properties, align 8
  %call344 = call i64 @AREF(i64 %231, i64 2)
  store i64 %call344, i64* %def, align 8
  br label %if.end.345

if.end.345:                                       ; preds = %if.else.343, %if.then.337
  %232 = load i64, i64* %keyhint, align 8
  %and346 = and i64 %232, 7
  %conv347 = trunc i64 %and346 to i32
  %cmp348 = icmp eq i32 %conv347, 3
  br i1 %cmp348, label %land.lhs.true.350, label %if.end.381

land.lhs.true.350:                                ; preds = %if.end.345
  %233 = load i64, i64* %keyhint, align 8
  %sub351 = sub nsw i64 %233, 3
  %234 = inttoptr i64 %sub351 to i8*
  %235 = bitcast i8* %234 to %struct.Lisp_Cons*
  %car352 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %235, i32 0, i32 0
  %236 = load i64, i64* %car352, align 8
  %call353 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp354 = icmp eq i64 %236, %call353
  br i1 %cmp354, label %if.end.381, label %if.then.356

if.then.356:                                      ; preds = %land.lhs.true.350
  %237 = load i64, i64* %keyhint, align 8
  %sub357 = sub nsw i64 %237, 3
  %238 = inttoptr i64 %sub357 to i8*
  %239 = bitcast i8* %238 to %struct.Lisp_Cons*
  %car358 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %239, i32 0, i32 0
  %240 = load i64, i64* %car358, align 8
  store i64 %240, i64* %keys, align 8
  %241 = load i64, i64* %keys, align 8
  %call359 = call i64 @builtin_lisp_symbol(i32 0)
  %call360 = call i64 @builtin_lisp_symbol(i32 0)
  %call361 = call i64 @builtin_lisp_symbol(i32 0)
  %call362 = call i64 @Fkey_binding(i64 %241, i64 %call359, i64 %call360, i64 %call361)
  store i64 %call362, i64* %tem, align 8
  %242 = load i64, i64* %tem, align 8
  %call363 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp364 = icmp eq i64 %242, %call363
  br i1 %cmp364, label %if.then.378, label %lor.lhs.false.366

lor.lhs.false.366:                                ; preds = %if.then.356
  %243 = load i64, i64* %tem, align 8
  %244 = load i64, i64* %def, align 8
  %cmp367 = icmp eq i64 %243, %244
  br i1 %cmp367, label %if.end.380, label %land.lhs.true.369

land.lhs.true.369:                                ; preds = %lor.lhs.false.366
  %245 = load i64, i64* %def, align 8
  %and370 = and i64 %245, 7
  %conv371 = trunc i64 %and370 to i32
  %cmp372 = icmp eq i32 %conv371, 0
  br i1 %cmp372, label %land.lhs.true.374, label %if.then.378

land.lhs.true.374:                                ; preds = %land.lhs.true.369
  %246 = load i64, i64* %tem, align 8
  %247 = load i64, i64* %def, align 8
  %sub375 = sub nsw i64 %247, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub375
  %248 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %248, i32 0, i32 3
  %249 = load i64, i64* %function, align 8
  %cmp376 = icmp eq i64 %246, %249
  br i1 %cmp376, label %if.end.380, label %if.then.378

if.then.378:                                      ; preds = %land.lhs.true.374, %land.lhs.true.369, %if.then.356
  %call379 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call379, i64* %keys, align 8
  br label %if.end.380

if.end.380:                                       ; preds = %if.then.378, %land.lhs.true.374, %lor.lhs.false.366
  br label %if.end.381

if.end.381:                                       ; preds = %if.end.380, %land.lhs.true.350, %if.end.345
  %250 = load i64, i64* %keys, align 8
  %call382 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp383 = icmp eq i64 %250, %call382
  br i1 %cmp383, label %if.then.385, label %if.end.391

if.then.385:                                      ; preds = %if.end.381
  %251 = load i64, i64* %def, align 8
  %call386 = call i64 @builtin_lisp_symbol(i32 0)
  %call387 = call i64 @builtin_lisp_symbol(i32 901)
  %call388 = call i64 @builtin_lisp_symbol(i32 0)
  %call389 = call i64 @builtin_lisp_symbol(i32 0)
  %call390 = call i64 @Fwhere_is_internal(i64 %251, i64 %call386, i64 %call387, i64 %call388, i64 %call389)
  store i64 %call390, i64* %keys, align 8
  br label %if.end.391

if.end.391:                                       ; preds = %if.then.385, %if.end.381
  %252 = load i64, i64* %keys, align 8
  %call392 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp393 = icmp eq i64 %252, %call392
  br i1 %cmp393, label %if.else.423, label %if.then.395

if.then.395:                                      ; preds = %if.end.391
  %253 = load i64, i64* %keys, align 8
  %call396 = call i64 @builtin_lisp_symbol(i32 0)
  %call397 = call i64 @Fkey_description(i64 %253, i64 %call396)
  store i64 %call397, i64* %tem, align 8
  %254 = load i64, i64* %prefix, align 8
  %and398 = and i64 %254, 7
  %conv399 = trunc i64 %and398 to i32
  %cmp400 = icmp eq i32 %conv399, 3
  br i1 %cmp400, label %if.then.402, label %if.end.421

if.then.402:                                      ; preds = %if.then.395
  %255 = load i64, i64* %prefix, align 8
  %sub403 = sub nsw i64 %255, 3
  %256 = inttoptr i64 %sub403 to i8*
  %257 = bitcast i8* %256 to %struct.Lisp_Cons*
  %car404 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %257, i32 0, i32 0
  %258 = load i64, i64* %car404, align 8
  %call405 = call zeroext i1 @STRINGP(i64 %258)
  br i1 %call405, label %if.then.406, label %if.end.410

if.then.406:                                      ; preds = %if.then.402
  %259 = load i64, i64* %prefix, align 8
  %sub407 = sub nsw i64 %259, 3
  %260 = inttoptr i64 %sub407 to i8*
  %261 = bitcast i8* %260 to %struct.Lisp_Cons*
  %car408 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %261, i32 0, i32 0
  %262 = load i64, i64* %car408, align 8
  %263 = load i64, i64* %tem, align 8
  %call409 = call i64 @concat2(i64 %262, i64 %263)
  store i64 %call409, i64* %tem, align 8
  br label %if.end.410

if.end.410:                                       ; preds = %if.then.406, %if.then.402
  %264 = load i64, i64* %prefix, align 8
  %sub411 = sub nsw i64 %264, 3
  %265 = inttoptr i64 %sub411 to i8*
  %266 = bitcast i8* %265 to %struct.Lisp_Cons*
  %u412 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %266, i32 0, i32 1
  %cdr413 = bitcast %union.anon.12* %u412 to i64*
  %267 = load i64, i64* %cdr413, align 8
  %call414 = call zeroext i1 @STRINGP(i64 %267)
  br i1 %call414, label %if.then.415, label %if.end.420

if.then.415:                                      ; preds = %if.end.410
  %268 = load i64, i64* %tem, align 8
  %269 = load i64, i64* %prefix, align 8
  %sub416 = sub nsw i64 %269, 3
  %270 = inttoptr i64 %sub416 to i8*
  %271 = bitcast i8* %270 to %struct.Lisp_Cons*
  %u417 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %271, i32 0, i32 1
  %cdr418 = bitcast %union.anon.12* %u417 to i64*
  %272 = load i64, i64* %cdr418, align 8
  %call419 = call i64 @concat2(i64 %268, i64 %272)
  store i64 %call419, i64* %tem, align 8
  br label %if.end.420

if.end.420:                                       ; preds = %if.then.415, %if.end.410
  br label %if.end.421

if.end.421:                                       ; preds = %if.end.420, %if.then.395
  %273 = load i64, i64* %space_space, align 8
  %274 = load i64, i64* %tem, align 8
  %call422 = call i64 @concat2(i64 %273, i64 %274)
  store i64 %call422, i64* %keyeq, align 8
  br label %if.end.425

if.else.423:                                      ; preds = %if.end.391
  %call424 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call424, i64* %keyeq, align 8
  br label %if.end.425

if.end.425:                                       ; preds = %if.else.423, %if.end.421
  br label %if.end.426

if.end.426:                                       ; preds = %if.end.425, %if.then.328
  %275 = load i64, i64* @item_properties, align 8
  %276 = load i64, i64* %keyeq, align 8
  call void @ASET(i64 %275, i64 5, i64 %276)
  %277 = load i64, i64* @item_properties, align 8
  %call427 = call i64 @AREF(i64 %277, i64 6)
  store i64 %call427, i64* %tem, align 8
  %278 = load i64, i64* %tem, align 8
  %call428 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp429 = icmp eq i64 %278, %call428
  br i1 %cmp429, label %if.end.433, label %if.then.431

if.then.431:                                      ; preds = %if.end.426
  %279 = load i64, i64* @item_properties, align 8
  %280 = load i64, i64* %tem, align 8
  %call432 = call i64 @menu_item_eval_property(i64 %280)
  call void @ASET(i64 %279, i64 6, i64 %call432)
  br label %if.end.433

if.end.433:                                       ; preds = %if.then.431, %if.end.426
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end.433, %if.then.316, %if.then.312, %if.then.303, %if.then.297, %if.then.271, %if.else.263, %if.then.260, %if.then.164, %if.then
  %281 = load i1, i1* %retval
  ret i1 %281
}

declare i64 @concat2(i64, i64) #1

declare i64 @Fkey_binding(i64, i64, i64, i64) #1

declare i64 @Fwhere_is_internal(i64, i64, i64, i64, i64) #1

declare i64 @Fkey_description(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @tool_bar_items(i64 %reuse, i32* %nitems) #0 {
entry:
  %reuse.addr = alloca i64, align 8
  %nitems.addr = alloca i32*, align 8
  %maps = alloca i64*, align 8
  %mapsbuf = alloca [3 x i64], align 16
  %nmaps = alloca i64, align 8
  %i = alloca i64, align 8
  %oquit = alloca i64, align 8
  %tmaps = alloca i64*, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %nminor = alloca i64, align 8
  %tem = alloca i64, align 8
  %keymap = alloca i64, align 8
  store i64 %reuse, i64* %reuse.addr, align 8
  store i32* %nitems, i32** %nitems.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i32*, i32** %nitems.addr, align 8
  store i32 0, i32* %0, align 4
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  store i64 %1, i64* %oquit, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %2 = load i64, i64* %reuse.addr, align 8
  call void @init_tool_bar_items(i64 %2)
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217), align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call2
  br i1 %cmp, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %4, %call3
  br i1 %cmp4, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %mapsbuf, i32 0, i32 0
  store i64* %arraydecay, i64** %maps, align 8
  store i64 0, i64* %nmaps, align 8
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %5, i32 0, i32 1
  %6 = load i64, i64* %Voverriding_terminal_local_map_, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %6, %call5
  br i1 %cmp6, label %if.end, label %if.then.7

if.then.7:                                        ; preds = %if.then
  %7 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_8 = getelementptr inbounds %struct.kboard, %struct.kboard* %7, i32 0, i32 1
  %8 = load i64, i64* %Voverriding_terminal_local_map_8, align 8
  %9 = load i64, i64* %nmaps, align 8
  %inc = add nsw i64 %9, 1
  store i64 %inc, i64* %nmaps, align 8
  %10 = load i64*, i64** %maps, align 8
  %arrayidx = getelementptr inbounds i64, i64* %10, i64 %9
  store i64 %8, i64* %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.7, %if.then
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %11, %call9
  br i1 %cmp10, label %if.end.14, label %if.then.11

if.then.11:                                       ; preds = %if.end
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  %13 = load i64, i64* %nmaps, align 8
  %inc12 = add nsw i64 %13, 1
  store i64 %inc12, i64* %nmaps, align 8
  %14 = load i64*, i64** %maps, align 8
  %arrayidx13 = getelementptr inbounds i64, i64* %14, i64 %13
  store i64 %12, i64* %arrayidx13, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.11, %if.end
  br label %if.end.56

if.else:                                          ; preds = %land.lhs.true, %entry
  %call15 = call i64 @current_minor_maps(i64** null, i64** %tmaps)
  store i64 %call15, i64* %nminor, align 8
  br label %do.body

do.body:                                          ; preds = %if.else
  %15 = load i64, i64* %nminor, align 8
  %add = add nsw i64 %15, 4
  %16 = load i64, i64* %sa_avail, align 8
  %div = udiv i64 %16, 8
  %div16 = udiv i64 %div, 1
  %cmp17 = icmp ule i64 %add, %div16
  br i1 %cmp17, label %if.then.18, label %if.else.22

if.then.18:                                       ; preds = %do.body
  %17 = load i64, i64* %nminor, align 8
  %add19 = add nsw i64 %17, 4
  %mul = mul i64 8, %add19
  %18 = load i64, i64* %sa_avail, align 8
  %sub = sub i64 %18, %mul
  store i64 %sub, i64* %sa_avail, align 8
  %19 = load i64, i64* %nminor, align 8
  %add20 = add nsw i64 %19, 4
  %mul21 = mul i64 8, %add20
  %20 = alloca i8, i64 %mul21
  %21 = bitcast i8* %20 to i64*
  store i64* %21, i64** %maps, align 8
  br label %if.end.25

if.else.22:                                       ; preds = %do.body
  %22 = load i64, i64* %nminor, align 8
  %add23 = add nsw i64 %22, 4
  %call24 = call noalias i8* @xnmalloc(i64 %add23, i64 8)
  %23 = bitcast i8* %call24 to i64*
  store i64* %23, i64** %maps, align 8
  store i8 1, i8* %sa_must_free, align 1
  %24 = load i64*, i64** %maps, align 8
  %25 = bitcast i64* %24 to i8*
  call void @record_unwind_protect_ptr(void (i8*)* @xfree, i8* %25)
  br label %if.end.25

if.end.25:                                        ; preds = %if.else.22, %if.then.18
  br label %do.end

do.end:                                           ; preds = %if.end.25
  store i64 0, i64* %nmaps, align 8
  %26 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Voverriding_terminal_local_map_26 = getelementptr inbounds %struct.kboard, %struct.kboard* %26, i32 0, i32 1
  %27 = load i64, i64* %Voverriding_terminal_local_map_26, align 8
  store i64 %27, i64* %tem, align 8
  %28 = load i64, i64* %tem, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %28, %call27
  br i1 %cmp28, label %if.end.35, label %land.lhs.true.29

land.lhs.true.29:                                 ; preds = %do.end
  %29 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217), align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %29, %call30
  br i1 %cmp31, label %if.end.35, label %if.then.32

if.then.32:                                       ; preds = %land.lhs.true.29
  %30 = load i64, i64* %tem, align 8
  %31 = load i64, i64* %nmaps, align 8
  %inc33 = add nsw i64 %31, 1
  store i64 %inc33, i64* %nmaps, align 8
  %32 = load i64*, i64** %maps, align 8
  %arrayidx34 = getelementptr inbounds i64, i64* %32, i64 %31
  store i64 %30, i64* %arrayidx34, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.32, %land.lhs.true.29, %do.end
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %33, i32 0, i32 75
  %34 = load i64, i64* %pt, align 8
  %add36 = add nsw i64 %34, 0
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 589)
  %call38 = call i64 @get_local_map(i64 %add36, %struct.buffer* %35, i64 %call37)
  store i64 %call38, i64* %tem, align 8
  %36 = load i64, i64* %tem, align 8
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp40 = icmp eq i64 %36, %call39
  %lnot = xor i1 %cmp40, true
  br i1 %lnot, label %if.then.41, label %if.end.44

if.then.41:                                       ; preds = %if.end.35
  %37 = load i64, i64* %tem, align 8
  %38 = load i64, i64* %nmaps, align 8
  %inc42 = add nsw i64 %38, 1
  store i64 %inc42, i64* %nmaps, align 8
  %39 = load i64*, i64** %maps, align 8
  %arrayidx43 = getelementptr inbounds i64, i64* %39, i64 %38
  store i64 %37, i64* %arrayidx43, align 8
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.41, %if.end.35
  %40 = load i64, i64* %nminor, align 8
  %cmp45 = icmp ne i64 %40, 0
  br i1 %cmp45, label %if.then.46, label %if.end.49

if.then.46:                                       ; preds = %if.end.44
  %41 = load i64*, i64** %maps, align 8
  %42 = load i64, i64* %nmaps, align 8
  %add.ptr = getelementptr inbounds i64, i64* %41, i64 %42
  %43 = bitcast i64* %add.ptr to i8*
  %44 = load i64*, i64** %tmaps, align 8
  %45 = bitcast i64* %44 to i8*
  %46 = load i64, i64* %nminor, align 8
  %mul47 = mul i64 %46, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %43, i8* %45, i64 %mul47, i32 8, i1 false)
  %47 = load i64, i64* %nminor, align 8
  %48 = load i64, i64* %nmaps, align 8
  %add48 = add nsw i64 %48, %47
  store i64 %add48, i64* %nmaps, align 8
  br label %if.end.49

if.end.49:                                        ; preds = %if.then.46, %if.end.44
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt50 = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 75
  %50 = load i64, i64* %pt50, align 8
  %add51 = add nsw i64 %50, 0
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 633)
  %call53 = call i64 @get_local_map(i64 %add51, %struct.buffer* %51, i64 %call52)
  %52 = load i64, i64* %nmaps, align 8
  %inc54 = add nsw i64 %52, 1
  store i64 %inc54, i64* %nmaps, align 8
  %53 = load i64*, i64** %maps, align 8
  %arrayidx55 = getelementptr inbounds i64, i64* %53, i64 %52
  store i64 %call53, i64* %arrayidx55, align 8
  br label %if.end.56

if.end.56:                                        ; preds = %if.end.49, %if.end.14
  %54 = load i64, i64* @current_global_map, align 8
  %55 = load i64, i64* %nmaps, align 8
  %inc57 = add nsw i64 %55, 1
  store i64 %inc57, i64* %nmaps, align 8
  %56 = load i64*, i64** %maps, align 8
  %arrayidx58 = getelementptr inbounds i64, i64* %56, i64 %55
  store i64 %54, i64* %arrayidx58, align 8
  %57 = load i64, i64* %nmaps, align 8
  %sub59 = sub nsw i64 %57, 1
  store i64 %sub59, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.56
  %58 = load i64, i64* %i, align 8
  %cmp60 = icmp sge i64 %58, 0
  br i1 %cmp60, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %59 = load i64, i64* %i, align 8
  %60 = load i64*, i64** %maps, align 8
  %arrayidx61 = getelementptr inbounds i64, i64* %60, i64 %59
  %61 = load i64, i64* %arrayidx61, align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp63 = icmp eq i64 %61, %call62
  br i1 %cmp63, label %if.end.74, label %if.then.64

if.then.64:                                       ; preds = %for.body
  %62 = load i64, i64* %i, align 8
  %63 = load i64*, i64** %maps, align 8
  %arrayidx65 = getelementptr inbounds i64, i64* %63, i64 %62
  %64 = load i64, i64* %arrayidx65, align 8
  %call66 = call i64 @builtin_lisp_symbol(i32 921)
  %call67 = call i64 @access_keymap(i64 %64, i64 %call66, i1 zeroext true, i1 zeroext false, i1 zeroext true)
  %call68 = call i64 @get_keymap(i64 %call67, i1 zeroext false, i1 zeroext true)
  store i64 %call68, i64* %keymap, align 8
  %65 = load i64, i64* %keymap, align 8
  %and = and i64 %65, 7
  %conv = trunc i64 %and to i32
  %cmp69 = icmp eq i32 %conv, 3
  br i1 %cmp69, label %if.then.71, label %if.end.73

if.then.71:                                       ; preds = %if.then.64
  %66 = load i64, i64* %keymap, align 8
  %call72 = call i64 @builtin_lisp_symbol(i32 0)
  call void @map_keymap(i64 %66, void (i64, i64, i64, i8*)* @process_tool_bar_item, i64 %call72, i8* null, i1 zeroext true)
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.71, %if.then.64
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.73, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.74
  %67 = load i64, i64* %i, align 8
  %dec = add nsw i64 %67, -1
  store i64 %dec, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %68 = load i64, i64* %oquit, align 8
  store i64 %68, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %69 = load i32, i32* @ntool_bar_items, align 4
  %div75 = sdiv i32 %69, 11
  %70 = load i32*, i32** %nitems.addr, align 8
  store i32 %div75, i32* %70, align 4
  br label %do.body.76

do.body.76:                                       ; preds = %for.end
  %71 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %71 to i1
  br i1 %tobool, label %if.then.77, label %if.end.80

if.then.77:                                       ; preds = %do.body.76
  store i8 0, i8* %sa_must_free, align 1
  %72 = load i64, i64* %sa_count, align 8
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  %call79 = call i64 @unbind_to(i64 %72, i64 %call78)
  br label %if.end.80

if.end.80:                                        ; preds = %if.then.77, %do.body.76
  br label %do.end.81

do.end.81:                                        ; preds = %if.end.80
  %73 = load i64, i64* @tool_bar_items_vector, align 8
  ret i64 %73
}

; Function Attrs: nounwind uwtable
define internal void @init_tool_bar_items(i64 %reuse) #0 {
entry:
  %reuse.addr = alloca i64, align 8
  store i64 %reuse, i64* %reuse.addr, align 8
  %0 = load i64, i64* %reuse.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %reuse.addr, align 8
  store i64 %1, i64* @tool_bar_items_vector, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @Fmake_vector(i64 258, i64 %call1)
  store i64 %call2, i64* @tool_bar_items_vector, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i32 0, i32* @ntool_bar_items, align 4
  ret void
}

declare void @map_keymap(i64, void (i64, i64, i64, i8*)*, i64, i8*, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define internal void @process_tool_bar_item(i64 %key, i64 %def, i64 %data, i8* %args) #0 {
entry:
  %key.addr = alloca i64, align 8
  %def.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %args.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %v = alloca i64*, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %def, i64* %def.addr, align 8
  store i64 %data, i64* %data.addr, align 8
  store i8* %args, i8** %args.addr, align 8
  %0 = load i64, i64* %def.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 959)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i32, i32* %i, align 4
  %2 = load i32, i32* @ntool_bar_items, align 4
  %cmp1 = icmp slt i32 %1, %2
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* @tool_bar_items_vector, align 8
  %call2 = call %struct.Lisp_Vector* @XVECTOR(i64 %3)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %4 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr inbounds i64, i64* %arraydecay, i64 %idx.ext
  store i64* %add.ptr, i64** %v, align 8
  %5 = load i64, i64* %key.addr, align 8
  %6 = load i64*, i64** %v, align 8
  %arrayidx = getelementptr inbounds i64, i64* %6, i64 0
  %7 = load i64, i64* %arrayidx, align 8
  %cmp3 = icmp eq i64 %5, %7
  br i1 %cmp3, label %if.then.4, label %if.end.10

if.then.4:                                        ; preds = %for.body
  %8 = load i32, i32* @ntool_bar_items, align 4
  %9 = load i32, i32* %i, align 4
  %add = add nsw i32 %9, 11
  %cmp5 = icmp sgt i32 %8, %add
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %if.then.4
  %10 = load i64*, i64** %v, align 8
  %11 = bitcast i64* %10 to i8*
  %12 = load i64*, i64** %v, align 8
  %add.ptr7 = getelementptr inbounds i64, i64* %12, i64 11
  %13 = bitcast i64* %add.ptr7 to i8*
  %14 = load i32, i32* @ntool_bar_items, align 4
  %15 = load i32, i32* %i, align 4
  %sub = sub nsw i32 %14, %15
  %sub8 = sub nsw i32 %sub, 11
  %mul = mul nsw i32 %sub8, 8
  %conv = sext i32 %mul to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %11, i8* %13, i64 %conv, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then.4
  %16 = load i32, i32* @ntool_bar_items, align 4
  %sub9 = sub nsw i32 %16, 11
  store i32 %sub9, i32* @ntool_bar_items, align 4
  br label %for.end

if.end.10:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.10
  %17 = load i32, i32* %i, align 4
  %add11 = add nsw i32 %17, 11
  store i32 %add11, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.end, %for.cond
  br label %if.end.15

if.else:                                          ; preds = %entry
  %18 = load i64, i64* %key.addr, align 8
  %19 = load i64, i64* %def.addr, align 8
  %call12 = call zeroext i1 @parse_tool_bar_item(i64 %18, i64 %19)
  br i1 %call12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %if.else
  call void @append_tool_bar_item()
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.13, %if.else
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.14, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fread_key_sequence(i64 %prompt, i64 %continue_echo, i64 %dont_downcase_last, i64 %can_return_switch_frame, i64 %cmd_loop) #0 {
entry:
  %prompt.addr = alloca i64, align 8
  %continue_echo.addr = alloca i64, align 8
  %dont_downcase_last.addr = alloca i64, align 8
  %can_return_switch_frame.addr = alloca i64, align 8
  %cmd_loop.addr = alloca i64, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  store i64 %continue_echo, i64* %continue_echo.addr, align 8
  store i64 %dont_downcase_last, i64* %dont_downcase_last.addr, align 8
  store i64 %can_return_switch_frame, i64* %can_return_switch_frame.addr, align 8
  store i64 %cmd_loop, i64* %cmd_loop.addr, align 8
  %0 = load i64, i64* %prompt.addr, align 8
  %1 = load i64, i64* %continue_echo.addr, align 8
  %2 = load i64, i64* %dont_downcase_last.addr, align 8
  %3 = load i64, i64* %can_return_switch_frame.addr, align 8
  %4 = load i64, i64* %cmd_loop.addr, align 8
  %call = call i64 @read_key_sequence_vs(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i1 zeroext true)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @read_key_sequence_vs(i64 %prompt, i64 %continue_echo, i64 %dont_downcase_last, i64 %can_return_switch_frame, i64 %cmd_loop, i1 zeroext %allow_string) #0 {
entry:
  %prompt.addr = alloca i64, align 8
  %continue_echo.addr = alloca i64, align 8
  %dont_downcase_last.addr = alloca i64, align 8
  %can_return_switch_frame.addr = alloca i64, align 8
  %cmd_loop.addr = alloca i64, align 8
  %allow_string.addr = alloca i8, align 1
  %keybuf = alloca [30 x i64], align 16
  %i = alloca i32, align 4
  %count = alloca i64, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  store i64 %continue_echo, i64* %continue_echo.addr, align 8
  store i64 %dont_downcase_last, i64* %dont_downcase_last.addr, align 8
  store i64 %can_return_switch_frame, i64* %can_return_switch_frame.addr, align 8
  store i64 %cmd_loop, i64* %cmd_loop.addr, align 8
  %frombool = zext i1 %allow_string to i8
  store i8 %frombool, i8* %allow_string.addr, align 1
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* %prompt.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %prompt.addr, align 8
  call void @CHECK_STRING(i64 %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %2, %call2
  br i1 %cmp3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %3, %call4
  br i1 %cmp5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.9

if.else:                                          ; preds = %land.lhs.true, %do.body
  %4 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %if.else
  br label %if.end.9

if.end.9:                                         ; preds = %if.end.8, %if.then.6
  br label %do.end

do.end:                                           ; preds = %if.end.9
  %call10 = call i64 @builtin_lisp_symbol(i32 550)
  %5 = load i64, i64* %cmd_loop.addr, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %5, %call11
  br i1 %cmp12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %call13 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call13, %cond.true ], [ %call14, %cond.false ]
  call void @specbind(i64 %call10, i64 %cond)
  %call15 = call i64 @builtin_lisp_symbol(i32 551)
  %6 = load i64, i64* %cmd_loop.addr, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %6, %call16
  br i1 %cmp17, label %cond.true.18, label %cond.false.20

cond.true.18:                                     ; preds = %cond.end
  %call19 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.22

cond.false.20:                                    ; preds = %cond.end
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.22

cond.end.22:                                      ; preds = %cond.false.20, %cond.true.18
  %cond23 = phi i64 [ %call19, %cond.true.18 ], [ %call21, %cond.false.20 ]
  call void @specbind(i64 %call15, i64 %cond23)
  %7 = load i64, i64* %continue_echo.addr, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp25 = icmp eq i64 %7, %call24
  br i1 %cmp25, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %cond.end.22
  store i64 0, i64* @this_command_key_count, align 8
  store i64 0, i64* @this_single_command_key_start, align 8
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.26, %cond.end.22
  %8 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 438), align 1
  %tobool28 = trunc i8 %8 to i1
  br i1 %tobool28, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %if.end.27
  call void @cancel_hourglass()
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.29, %if.end.27
  %arraydecay = getelementptr inbounds [30 x i64], [30 x i64]* %keybuf, i32 0, i32 0
  %9 = load i64, i64* %prompt.addr, align 8
  %10 = load i64, i64* %dont_downcase_last.addr, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp32 = icmp eq i64 %10, %call31
  %lnot = xor i1 %cmp32, true
  %11 = load i64, i64* %can_return_switch_frame.addr, align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp34 = icmp eq i64 %11, %call33
  %lnot35 = xor i1 %cmp34, true
  %call36 = call i32 @read_key_sequence(i64* %arraydecay, i32 30, i64 %9, i1 zeroext %lnot, i1 zeroext %lnot35, i1 zeroext false, i1 zeroext false)
  store i32 %call36, i32* %i, align 4
  %12 = load i32, i32* %i, align 4
  %cmp37 = icmp eq i32 %12, -1
  br i1 %cmp37, label %if.then.38, label %if.end.53

if.then.38:                                       ; preds = %if.end.30
  %call39 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call39, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %do.body.40

do.body.40:                                       ; preds = %if.then.38
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp42 = icmp eq i64 %13, %call41
  br i1 %cmp42, label %if.else.47, label %land.lhs.true.43

land.lhs.true.43:                                 ; preds = %do.body.40
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp45 = icmp eq i64 %14, %call44
  br i1 %cmp45, label %if.then.46, label %if.else.47

if.then.46:                                       ; preds = %land.lhs.true.43
  call void @process_quit_flag()
  br label %if.end.51

if.else.47:                                       ; preds = %land.lhs.true.43, %do.body.40
  %15 = load volatile i8, i8* @pending_signals, align 1
  %tobool48 = trunc i8 %15 to i1
  br i1 %tobool48, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.else.47
  call void @process_pending_signals()
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.49, %if.else.47
  br label %if.end.51

if.end.51:                                        ; preds = %if.end.50, %if.then.46
  br label %do.end.52

do.end.52:                                        ; preds = %if.end.51
  br label %if.end.53

if.end.53:                                        ; preds = %do.end.52, %if.end.30
  %16 = load i64, i64* %count, align 8
  %17 = load i8, i8* %allow_string.addr, align 1
  %tobool54 = trunc i8 %17 to i1
  %cond55 = select i1 %tobool54, i64 (i64, i64*)* @make_event_array, i64 (i64, i64*)* @Fvector
  %18 = load i32, i32* %i, align 4
  %conv = sext i32 %18 to i64
  %arraydecay56 = getelementptr inbounds [30 x i64], [30 x i64]* %keybuf, i32 0, i32 0
  %call57 = call i64 %cond55(i64 %conv, i64* %arraydecay56)
  %call58 = call i64 @unbind_to(i64 %16, i64 %call57)
  ret i64 %call58
}

; Function Attrs: nounwind uwtable
define i64 @Fread_key_sequence_vector(i64 %prompt, i64 %continue_echo, i64 %dont_downcase_last, i64 %can_return_switch_frame, i64 %cmd_loop) #0 {
entry:
  %prompt.addr = alloca i64, align 8
  %continue_echo.addr = alloca i64, align 8
  %dont_downcase_last.addr = alloca i64, align 8
  %can_return_switch_frame.addr = alloca i64, align 8
  %cmd_loop.addr = alloca i64, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  store i64 %continue_echo, i64* %continue_echo.addr, align 8
  store i64 %dont_downcase_last, i64* %dont_downcase_last.addr, align 8
  store i64 %can_return_switch_frame, i64* %can_return_switch_frame.addr, align 8
  store i64 %cmd_loop, i64* %cmd_loop.addr, align 8
  %0 = load i64, i64* %prompt.addr, align 8
  %1 = load i64, i64* %continue_echo.addr, align 8
  %2 = load i64, i64* %dont_downcase_last.addr, align 8
  %3 = load i64, i64* %can_return_switch_frame.addr, align 8
  %4 = load i64, i64* %cmd_loop.addr, align 8
  %call = call i64 @read_key_sequence_vs(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define zeroext i1 @detect_input_pending() #0 {
entry:
  %0 = load i8, i8* @input_pending, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call = call zeroext i1 @get_input_pending(i32 0)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %call, %lor.rhs ]
  ret i1 %1
}

; Function Attrs: nounwind uwtable
define zeroext i1 @detect_input_pending_ignore_squeezables() #0 {
entry:
  %0 = load i8, i8* @input_pending, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %call = call zeroext i1 @get_input_pending(i32 4)
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %1 = phi i1 [ true, %entry ], [ %call, %lor.rhs ]
  ret i1 %1
}

; Function Attrs: nounwind uwtable
define void @clear_input_pending() #0 {
entry:
  store i8 0, i8* @input_pending, align 1
  ret void
}

; Function Attrs: nounwind uwtable
define zeroext i1 @requeued_events_pending_p() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define i64 @Finput_pending_p(i64 %check_timers) #0 {
entry:
  %retval = alloca i64, align 8
  %check_timers.addr = alloca i64, align 8
  store i64 %check_timers, i64* %check_timers.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %1, %call
  br i1 %cmp2, label %lor.lhs.false.4, label %if.then

lor.lhs.false.4:                                  ; preds = %lor.lhs.false
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %2, %call5
  br i1 %cmp6, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false.4, %lor.lhs.false, %entry
  %call8 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call8, i64* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.4
  call void @process_special_events()
  %3 = load i64, i64* %check_timers.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %3, %call9
  %cond = select i1 %cmp10, i32 0, i32 1
  %or = or i32 %cond, 2
  %call12 = call zeroext i1 @get_input_pending(i32 %or)
  br i1 %call12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %call14 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond16 = phi i64 [ %call14, %cond.true ], [ %call15, %cond.false ]
  store i64 %cond16, i64* %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then
  %4 = load i64, i64* %retval
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @Frecent_keys(i64 %include_cmds) #0 {
entry:
  %retval = alloca i64, align 8
  %include_cmds.addr = alloca i64, align 8
  %cmds = alloca i8, align 1
  %es = alloca i64, align 8
  %i = alloca i32, align 4
  %e = alloca i64, align 8
  store i64 %include_cmds, i64* %include_cmds.addr, align 8
  %0 = load i64, i64* %include_cmds.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  %lnot = xor i1 %cmp, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %cmds, align 1
  %1 = load i32, i32* @total_keys, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %2 = load i8, i8* %cmds, align 1
  %tobool1 = trunc i8 %2 to i1
  br i1 %tobool1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i32, i32* @total_keys, align 4
  %cmp2 = icmp slt i32 %3, 300
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true, %entry
  %4 = load i32, i32* @total_keys, align 4
  %conv = sext i32 %4 to i64
  %5 = load i64, i64* @recent_keys, align 8
  %call3 = call %struct.Lisp_Vector* @XVECTOR(i64 %5)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call3, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %call4 = call i64 @Fvector(i64 %conv, i64* %arraydecay)
  store i64 %call4, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* %es, align 8
  %6 = load i32, i32* @total_keys, align 4
  %cmp6 = icmp slt i32 %6, 300
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %7 = load i32, i32* @recent_keys_index, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 0, %cond.true ], [ %7, %cond.false ]
  store i32 %cond, i32* %i, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %cond.end
  %8 = load i64, i64* @recent_keys, align 8
  %9 = load i32, i32* %i, align 4
  %conv8 = sext i32 %9 to i64
  %call9 = call i64 @AREF(i64 %8, i64 %conv8)
  store i64 %call9, i64* %e, align 8
  %10 = load i8, i8* %cmds, align 1
  %tobool10 = trunc i8 %10 to i1
  br i1 %tobool10, label %if.then.20, label %lor.lhs.false.12

lor.lhs.false.12:                                 ; preds = %do.body
  %11 = load i64, i64* %e, align 8
  %and = and i64 %11, 7
  %conv13 = trunc i64 %and to i32
  %cmp14 = icmp eq i32 %conv13, 3
  br i1 %cmp14, label %lor.lhs.false.16, label %if.then.20

lor.lhs.false.16:                                 ; preds = %lor.lhs.false.12
  %12 = load i64, i64* %e, align 8
  %sub = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 0
  %15 = load i64, i64* %car, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %15, %call17
  br i1 %cmp18, label %if.end, label %if.then.20

if.then.20:                                       ; preds = %lor.lhs.false.16, %lor.lhs.false.12, %do.body
  %16 = load i64, i64* %e, align 8
  %17 = load i64, i64* %es, align 8
  %call21 = call i64 @Fcons(i64 %16, i64 %17)
  store i64 %call21, i64* %es, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.20, %lor.lhs.false.16
  %18 = load i32, i32* %i, align 4
  %inc = add nsw i32 %18, 1
  store i32 %inc, i32* %i, align 4
  %cmp22 = icmp sge i32 %inc, 300
  br i1 %cmp22, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.24, %if.end
  br label %do.cond

do.cond:                                          ; preds = %if.end.25
  %19 = load i32, i32* %i, align 4
  %20 = load i32, i32* @recent_keys_index, align 4
  %cmp26 = icmp ne i32 %19, %20
  br i1 %cmp26, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %21 = load i64, i64* %es, align 8
  %call28 = call i64 @Fnreverse(i64 %21)
  store i64 %call28, i64* %es, align 8
  %call29 = call i64 @Fvconcat(i64 1, i64* %es)
  store i64 %call29, i64* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %22 = load i64, i64* %retval
  ret i64 %22
}

declare %struct.Lisp_Vector* @XVECTOR(i64) #1

declare i64 @Fnreverse(i64) #1

declare i64 @Fvconcat(i64, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @Fthis_command_keys() #0 {
entry:
  %0 = load i64, i64* @this_command_key_count, align 8
  %1 = load i64, i64* @this_command_keys, align 8
  %call = call %struct.Lisp_Vector* @XVECTOR(i64 %1)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %call1 = call i64 @make_event_array(i64 %0, i64* %arraydecay)
  ret i64 %call1
}

declare i64 @make_event_array(i64, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @Fthis_command_keys_vector() #0 {
entry:
  %0 = load i64, i64* @this_command_key_count, align 8
  %1 = load i64, i64* @this_command_keys, align 8
  %call = call %struct.Lisp_Vector* @XVECTOR(i64 %1)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %call1 = call i64 @Fvector(i64 %0, i64* %arraydecay)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Fthis_single_command_keys() #0 {
entry:
  %0 = load i64, i64* @this_command_key_count, align 8
  %1 = load i64, i64* @this_single_command_key_start, align 8
  %sub = sub nsw i64 %0, %1
  %2 = load i64, i64* @this_command_keys, align 8
  %call = call %struct.Lisp_Vector* @XVECTOR(i64 %2)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %3 = load i64, i64* @this_single_command_key_start, align 8
  %add.ptr = getelementptr inbounds i64, i64* %arraydecay, i64 %3
  %call1 = call i64 @Fvector(i64 %sub, i64* %add.ptr)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Fthis_single_command_raw_keys() #0 {
entry:
  %0 = load i32, i32* @raw_keybuf_count, align 4
  %conv = sext i32 %0 to i64
  %1 = load i64, i64* @raw_keybuf, align 8
  %call = call %struct.Lisp_Vector* @XVECTOR(i64 %1)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %call1 = call i64 @Fvector(i64 %conv, i64* %arraydecay)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Fclear_this_command_keys(i64 %keep_record) #0 {
entry:
  %keep_record.addr = alloca i64, align 8
  %i = alloca i32, align 4
  store i64 %keep_record, i64* %keep_record.addr, align 8
  store i64 0, i64* @this_command_key_count, align 8
  %0 = load i64, i64* %keep_record.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i32, i32* %i, align 4
  %conv = sext i32 %1 to i64
  %2 = load i64, i64* @recent_keys, align 8
  %call1 = call i64 @ASIZE(i64 %2)
  %cmp2 = icmp slt i64 %conv, %call1
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* @recent_keys, align 8
  %4 = load i32, i32* %i, align 4
  %conv4 = sext i32 %4 to i64
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %3, i64 %conv4, i64 %call5)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* @total_keys, align 4
  store i32 0, i32* @recent_keys_index, align 4
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call6
}

; Function Attrs: nounwind uwtable
define i64 @Frecursion_depth() #0 {
entry:
  %temp = alloca i64, align 8
  %sum = alloca i64, align 8
  %0 = load i64, i64* @command_loop_level, align 8
  %and = and i64 %0, 4611686018427387903
  %1 = load i64, i64* @minibuf_level, align 8
  %and1 = and i64 %1, 4611686018427387903
  %add = add nsw i64 %and, %and1
  store i64 %add, i64* %sum, align 8
  %2 = load i64, i64* %sum, align 8
  %shl = shl i64 %2, 2
  %add2 = add i64 %shl, 2
  store i64 %add2, i64* %temp, align 8
  %3 = load i64, i64* %temp, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define i64 @Fopen_dribble_file(i64 %file) #0 {
entry:
  %file.addr = alloca i64, align 8
  %fd = alloca i32, align 4
  %encfile = alloca i64, align 8
  store i64 %file, i64* %file.addr, align 8
  %0 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %tobool = icmp ne %struct._IO_FILE* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @block_input()
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %call = call i32 @fclose(%struct._IO_FILE* %1)
  call void @unblock_input()
  store %struct._IO_FILE* null, %struct._IO_FILE** @dribble, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %file.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call1
  br i1 %cmp, label %if.end.24, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %3 = load i64, i64* %file.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fexpand_file_name(i64 %3, i64 %call3)
  store i64 %call4, i64* %file.addr, align 8
  %4 = load i64, i64* %file.addr, align 8
  %call5 = call i64 @encode_file_name(i64 %4)
  store i64 %call5, i64* %encfile, align 8
  %5 = load i64, i64* %encfile, align 8
  %call6 = call i8* @SSDATA(i64 %5)
  %call7 = call i32 @emacs_open(i8* %call6, i32 193, i32 384)
  store i32 %call7, i32* %fd, align 4
  %6 = load i32, i32* %fd, align 4
  %cmp8 = icmp slt i32 %6, 0
  br i1 %cmp8, label %land.lhs.true, label %if.end.18

land.lhs.true:                                    ; preds = %if.then.2
  %call9 = call i32* @__errno_location() #14
  %7 = load i32, i32* %call9, align 4
  %cmp10 = icmp eq i32 %7, 17
  br i1 %cmp10, label %land.lhs.true.11, label %if.end.18

land.lhs.true.11:                                 ; preds = %land.lhs.true
  %8 = load i64, i64* %encfile, align 8
  %call12 = call i8* @SSDATA(i64 %8)
  %call13 = call i32 @unlink(i8* %call12) #8
  %cmp14 = icmp eq i32 %call13, 0
  br i1 %cmp14, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %land.lhs.true.11
  %9 = load i64, i64* %encfile, align 8
  %call16 = call i8* @SSDATA(i64 %9)
  %call17 = call i32 @emacs_open(i8* %call16, i32 193, i32 384)
  store i32 %call17, i32* %fd, align 4
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %land.lhs.true.11, %land.lhs.true, %if.then.2
  %10 = load i32, i32* %fd, align 4
  %cmp19 = icmp slt i32 %10, 0
  br i1 %cmp19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.18
  br label %cond.end

cond.false:                                       ; preds = %if.end.18
  %11 = load i32, i32* %fd, align 4
  %call20 = call %struct._IO_FILE* @fdopen(i32 %11, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.20, i32 0, i32 0)) #8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct._IO_FILE* [ null, %cond.true ], [ %call20, %cond.false ]
  store %struct._IO_FILE* %cond, %struct._IO_FILE** @dribble, align 8
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @dribble, align 8
  %cmp21 = icmp eq %struct._IO_FILE* %12, null
  br i1 %cmp21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %cond.end
  %13 = load i64, i64* %file.addr, align 8
  call void @report_file_error(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.21, i32 0, i32 0), i64 %13) #11
  unreachable

if.end.23:                                        ; preds = %cond.end
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.end
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call25
}

declare void @block_input() #1

declare i32 @fclose(%struct._IO_FILE*) #1

declare i64 @Fexpand_file_name(i64, i64) #1

declare i64 @encode_file_name(i64) #1

declare i32 @emacs_open(i8*, i32, i32) #1

; Function Attrs: nounwind
declare i32 @unlink(i8*) #6

; Function Attrs: nounwind
declare %struct._IO_FILE* @fdopen(i32, i8*) #6

; Function Attrs: noreturn
declare void @report_file_error(i8*, i64) #2

declare i64 @Fcancel_kbd_macro_events() #1

declare void @end_kbd_macro() #1

declare void @discard_tty_input() #1

; Function Attrs: nounwind uwtable
define i64 @Fsuspend_emacs(i64 %stuffstring) #0 {
entry:
  %stuffstring.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %old_height = alloca i32, align 4
  %old_width = alloca i32, align 4
  %width = alloca i32, align 4
  %height = alloca i32, align 4
  store i64 %stuffstring, i64* %stuffstring.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load %struct.tty_display_info*, %struct.tty_display_info** @tty_list, align 8
  %tobool = icmp ne %struct.tty_display_info* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.tty_display_info*, %struct.tty_display_info** @tty_list, align 8
  %next = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %1, i32 0, i32 0
  %2 = load %struct.tty_display_info*, %struct.tty_display_info** %next, align 8
  %tobool1 = icmp ne %struct.tty_display_info* %2, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void (i8*, ...) @error(i8* getelementptr inbounds ([68 x i8], [68 x i8]* @.str.22, i32 0, i32 0)) #11
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i64, i64* %stuffstring.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call2
  br i1 %cmp, label %if.end.4, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %4 = load i64, i64* %stuffstring.addr, align 8
  call void @CHECK_STRING(i64 %4)
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %if.end
  %call5 = call i64 @intern(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0))
  call void @run_hook(i64 %call5)
  %5 = load i64, i64* @selected_frame, align 8
  %call6 = call zeroext i1 @FRAMEP(i64 %5)
  br i1 %call6, label %land.lhs.true.7, label %cond.false

land.lhs.true.7:                                  ; preds = %if.end.4
  %6 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %6, 5
  %7 = inttoptr i64 %sub to i8*
  %8 = bitcast i8* %7 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %8, i32 0, i32 61
  %9 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp8 = icmp ne %struct.terminal* %9, null
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.7
  %10 = load i64, i64* @selected_frame, align 8
  %sub9 = sub nsw i64 %10, 5
  %11 = inttoptr i64 %sub9 to i8*
  %12 = bitcast i8* %11 to %struct.frame*
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.7, %if.end.4
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %13, %cond.true
  %cond = phi %struct.frame* [ %12, %cond.true ], [ null, %13 ]
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %cond, i32 0, i32 26
  %14 = bitcast i48* %output_method to i64*
  %bf.load = load i64, i64* %14, align 8
  %bf.lshr = lshr i64 %bf.load, 23
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp10 = icmp eq i32 %bf.cast, 1
  br i1 %cmp10, label %cond.true.27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %15 = load i64, i64* @selected_frame, align 8
  %call11 = call zeroext i1 @FRAMEP(i64 %15)
  br i1 %call11, label %land.lhs.true.12, label %cond.false.18

land.lhs.true.12:                                 ; preds = %lor.lhs.false
  %16 = load i64, i64* @selected_frame, align 8
  %sub13 = sub nsw i64 %16, 5
  %17 = inttoptr i64 %sub13 to i8*
  %18 = bitcast i8* %17 to %struct.frame*
  %terminal14 = getelementptr inbounds %struct.frame, %struct.frame* %18, i32 0, i32 61
  %19 = load %struct.terminal*, %struct.terminal** %terminal14, align 8
  %cmp15 = icmp ne %struct.terminal* %19, null
  br i1 %cmp15, label %cond.true.16, label %cond.false.18

cond.true.16:                                     ; preds = %land.lhs.true.12
  %20 = load i64, i64* @selected_frame, align 8
  %sub17 = sub nsw i64 %20, 5
  %21 = inttoptr i64 %sub17 to i8*
  %22 = bitcast i8* %21 to %struct.frame*
  br label %cond.end.19

cond.false.18:                                    ; preds = %land.lhs.true.12, %lor.lhs.false
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.19

cond.end.19:                                      ; preds = %23, %cond.true.16
  %cond20 = phi %struct.frame* [ %22, %cond.true.16 ], [ null, %23 ]
  %output_method21 = getelementptr inbounds %struct.frame, %struct.frame* %cond20, i32 0, i32 26
  %24 = bitcast i48* %output_method21 to i64*
  %bf.load22 = load i64, i64* %24, align 8
  %bf.lshr23 = lshr i64 %bf.load22, 23
  %bf.clear24 = and i64 %bf.lshr23, 7
  %bf.cast25 = trunc i64 %bf.clear24 to i32
  %cmp26 = icmp eq i32 %bf.cast25, 3
  br i1 %cmp26, label %cond.true.27, label %cond.false.39

cond.true.27:                                     ; preds = %cond.end.19, %cond.end
  %25 = load i64, i64* @selected_frame, align 8
  %call28 = call zeroext i1 @FRAMEP(i64 %25)
  br i1 %call28, label %land.lhs.true.29, label %cond.false.35

land.lhs.true.29:                                 ; preds = %cond.true.27
  %26 = load i64, i64* @selected_frame, align 8
  %sub30 = sub nsw i64 %26, 5
  %27 = inttoptr i64 %sub30 to i8*
  %28 = bitcast i8* %27 to %struct.frame*
  %terminal31 = getelementptr inbounds %struct.frame, %struct.frame* %28, i32 0, i32 61
  %29 = load %struct.terminal*, %struct.terminal** %terminal31, align 8
  %cmp32 = icmp ne %struct.terminal* %29, null
  br i1 %cmp32, label %cond.true.33, label %cond.false.35

cond.true.33:                                     ; preds = %land.lhs.true.29
  %30 = load i64, i64* @selected_frame, align 8
  %sub34 = sub nsw i64 %30, 5
  %31 = inttoptr i64 %sub34 to i8*
  %32 = bitcast i8* %31 to %struct.frame*
  br label %cond.end.36

cond.false.35:                                    ; preds = %land.lhs.true.29, %cond.true.27
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.36

cond.end.36:                                      ; preds = %33, %cond.true.33
  %cond37 = phi %struct.frame* [ %32, %cond.true.33 ], [ null, %33 ]
  %terminal38 = getelementptr inbounds %struct.frame, %struct.frame* %cond37, i32 0, i32 61
  %34 = load %struct.terminal*, %struct.terminal** %terminal38, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %34, i32 0, i32 12
  %tty = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %35 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  br label %cond.end.40

cond.false.39:                                    ; preds = %cond.end.19
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.40

cond.end.40:                                      ; preds = %36, %cond.end.36
  %cond41 = phi %struct.tty_display_info* [ %35, %cond.end.36 ], [ null, %36 ]
  %input = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %cond41, i32 0, i32 3
  %37 = load %struct._IO_FILE*, %struct._IO_FILE** %input, align 8
  %call42 = call i32 @fileno(%struct._IO_FILE* %37) #8
  call void @get_tty_size(i32 %call42, i32* %old_width, i32* %old_height)
  call void @reset_all_sys_modes()
  call void @record_unwind_protect_void(void ()* @init_all_sys_modes)
  %38 = load i64, i64* %stuffstring.addr, align 8
  call void @stuff_buffered_input(i64 %38)
  %39 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 426), align 1
  %tobool43 = trunc i8 %39 to i1
  br i1 %tobool43, label %if.then.44, label %if.else

if.then.44:                                       ; preds = %cond.end.40
  call void @sys_subshell()
  br label %if.end.45

if.else:                                          ; preds = %cond.end.40
  call void @sys_suspend()
  br label %if.end.45

if.end.45:                                        ; preds = %if.else, %if.then.44
  %40 = load i64, i64* %count, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %call47 = call i64 @unbind_to(i64 %40, i64 %call46)
  %41 = load i64, i64* @selected_frame, align 8
  %call48 = call zeroext i1 @FRAMEP(i64 %41)
  br i1 %call48, label %land.lhs.true.49, label %cond.false.55

land.lhs.true.49:                                 ; preds = %if.end.45
  %42 = load i64, i64* @selected_frame, align 8
  %sub50 = sub nsw i64 %42, 5
  %43 = inttoptr i64 %sub50 to i8*
  %44 = bitcast i8* %43 to %struct.frame*
  %terminal51 = getelementptr inbounds %struct.frame, %struct.frame* %44, i32 0, i32 61
  %45 = load %struct.terminal*, %struct.terminal** %terminal51, align 8
  %cmp52 = icmp ne %struct.terminal* %45, null
  br i1 %cmp52, label %cond.true.53, label %cond.false.55

cond.true.53:                                     ; preds = %land.lhs.true.49
  %46 = load i64, i64* @selected_frame, align 8
  %sub54 = sub nsw i64 %46, 5
  %47 = inttoptr i64 %sub54 to i8*
  %48 = bitcast i8* %47 to %struct.frame*
  br label %cond.end.56

cond.false.55:                                    ; preds = %land.lhs.true.49, %if.end.45
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.56

cond.end.56:                                      ; preds = %49, %cond.true.53
  %cond57 = phi %struct.frame* [ %48, %cond.true.53 ], [ null, %49 ]
  %output_method58 = getelementptr inbounds %struct.frame, %struct.frame* %cond57, i32 0, i32 26
  %50 = bitcast i48* %output_method58 to i64*
  %bf.load59 = load i64, i64* %50, align 8
  %bf.lshr60 = lshr i64 %bf.load59, 23
  %bf.clear61 = and i64 %bf.lshr60, 7
  %bf.cast62 = trunc i64 %bf.clear61 to i32
  %cmp63 = icmp eq i32 %bf.cast62, 1
  br i1 %cmp63, label %cond.true.81, label %lor.lhs.false.64

lor.lhs.false.64:                                 ; preds = %cond.end.56
  %51 = load i64, i64* @selected_frame, align 8
  %call65 = call zeroext i1 @FRAMEP(i64 %51)
  br i1 %call65, label %land.lhs.true.66, label %cond.false.72

land.lhs.true.66:                                 ; preds = %lor.lhs.false.64
  %52 = load i64, i64* @selected_frame, align 8
  %sub67 = sub nsw i64 %52, 5
  %53 = inttoptr i64 %sub67 to i8*
  %54 = bitcast i8* %53 to %struct.frame*
  %terminal68 = getelementptr inbounds %struct.frame, %struct.frame* %54, i32 0, i32 61
  %55 = load %struct.terminal*, %struct.terminal** %terminal68, align 8
  %cmp69 = icmp ne %struct.terminal* %55, null
  br i1 %cmp69, label %cond.true.70, label %cond.false.72

cond.true.70:                                     ; preds = %land.lhs.true.66
  %56 = load i64, i64* @selected_frame, align 8
  %sub71 = sub nsw i64 %56, 5
  %57 = inttoptr i64 %sub71 to i8*
  %58 = bitcast i8* %57 to %struct.frame*
  br label %cond.end.73

cond.false.72:                                    ; preds = %land.lhs.true.66, %lor.lhs.false.64
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.73

cond.end.73:                                      ; preds = %59, %cond.true.70
  %cond74 = phi %struct.frame* [ %58, %cond.true.70 ], [ null, %59 ]
  %output_method75 = getelementptr inbounds %struct.frame, %struct.frame* %cond74, i32 0, i32 26
  %60 = bitcast i48* %output_method75 to i64*
  %bf.load76 = load i64, i64* %60, align 8
  %bf.lshr77 = lshr i64 %bf.load76, 23
  %bf.clear78 = and i64 %bf.lshr77, 7
  %bf.cast79 = trunc i64 %bf.clear78 to i32
  %cmp80 = icmp eq i32 %bf.cast79, 3
  br i1 %cmp80, label %cond.true.81, label %cond.false.95

cond.true.81:                                     ; preds = %cond.end.73, %cond.end.56
  %61 = load i64, i64* @selected_frame, align 8
  %call82 = call zeroext i1 @FRAMEP(i64 %61)
  br i1 %call82, label %land.lhs.true.83, label %cond.false.89

land.lhs.true.83:                                 ; preds = %cond.true.81
  %62 = load i64, i64* @selected_frame, align 8
  %sub84 = sub nsw i64 %62, 5
  %63 = inttoptr i64 %sub84 to i8*
  %64 = bitcast i8* %63 to %struct.frame*
  %terminal85 = getelementptr inbounds %struct.frame, %struct.frame* %64, i32 0, i32 61
  %65 = load %struct.terminal*, %struct.terminal** %terminal85, align 8
  %cmp86 = icmp ne %struct.terminal* %65, null
  br i1 %cmp86, label %cond.true.87, label %cond.false.89

cond.true.87:                                     ; preds = %land.lhs.true.83
  %66 = load i64, i64* @selected_frame, align 8
  %sub88 = sub nsw i64 %66, 5
  %67 = inttoptr i64 %sub88 to i8*
  %68 = bitcast i8* %67 to %struct.frame*
  br label %cond.end.90

cond.false.89:                                    ; preds = %land.lhs.true.83, %cond.true.81
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.90

cond.end.90:                                      ; preds = %69, %cond.true.87
  %cond91 = phi %struct.frame* [ %68, %cond.true.87 ], [ null, %69 ]
  %terminal92 = getelementptr inbounds %struct.frame, %struct.frame* %cond91, i32 0, i32 61
  %70 = load %struct.terminal*, %struct.terminal** %terminal92, align 8
  %display_info93 = getelementptr inbounds %struct.terminal, %struct.terminal* %70, i32 0, i32 12
  %tty94 = bitcast %union.display_info* %display_info93 to %struct.tty_display_info**
  %71 = load %struct.tty_display_info*, %struct.tty_display_info** %tty94, align 8
  br label %cond.end.96

cond.false.95:                                    ; preds = %cond.end.73
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.96

cond.end.96:                                      ; preds = %72, %cond.end.90
  %cond97 = phi %struct.tty_display_info* [ %71, %cond.end.90 ], [ null, %72 ]
  %input98 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %cond97, i32 0, i32 3
  %73 = load %struct._IO_FILE*, %struct._IO_FILE** %input98, align 8
  %call99 = call i32 @fileno(%struct._IO_FILE* %73) #8
  call void @get_tty_size(i32 %call99, i32* %width, i32* %height)
  %74 = load i32, i32* %width, align 4
  %75 = load i32, i32* %old_width, align 4
  %cmp100 = icmp ne i32 %74, %75
  br i1 %cmp100, label %if.then.103, label %lor.lhs.false.101

lor.lhs.false.101:                                ; preds = %cond.end.96
  %76 = load i32, i32* %height, align 4
  %77 = load i32, i32* %old_height, align 4
  %cmp102 = icmp ne i32 %76, %77
  br i1 %cmp102, label %if.then.103, label %if.end.125

if.then.103:                                      ; preds = %lor.lhs.false.101, %cond.end.96
  %78 = load i64, i64* @selected_frame, align 8
  %call104 = call zeroext i1 @FRAMEP(i64 %78)
  br i1 %call104, label %land.lhs.true.105, label %cond.false.111

land.lhs.true.105:                                ; preds = %if.then.103
  %79 = load i64, i64* @selected_frame, align 8
  %sub106 = sub nsw i64 %79, 5
  %80 = inttoptr i64 %sub106 to i8*
  %81 = bitcast i8* %80 to %struct.frame*
  %terminal107 = getelementptr inbounds %struct.frame, %struct.frame* %81, i32 0, i32 61
  %82 = load %struct.terminal*, %struct.terminal** %terminal107, align 8
  %cmp108 = icmp ne %struct.terminal* %82, null
  br i1 %cmp108, label %cond.true.109, label %cond.false.111

cond.true.109:                                    ; preds = %land.lhs.true.105
  %83 = load i64, i64* @selected_frame, align 8
  %sub110 = sub nsw i64 %83, 5
  %84 = inttoptr i64 %sub110 to i8*
  %85 = bitcast i8* %84 to %struct.frame*
  br label %cond.end.112

cond.false.111:                                   ; preds = %land.lhs.true.105, %if.then.103
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.112

cond.end.112:                                     ; preds = %86, %cond.true.109
  %cond113 = phi %struct.frame* [ %85, %cond.true.109 ], [ null, %86 ]
  %87 = load i32, i32* %width, align 4
  %88 = load i32, i32* %height, align 4
  %89 = load i64, i64* @selected_frame, align 8
  %call114 = call zeroext i1 @FRAMEP(i64 %89)
  br i1 %call114, label %land.lhs.true.115, label %cond.false.121

land.lhs.true.115:                                ; preds = %cond.end.112
  %90 = load i64, i64* @selected_frame, align 8
  %sub116 = sub nsw i64 %90, 5
  %91 = inttoptr i64 %sub116 to i8*
  %92 = bitcast i8* %91 to %struct.frame*
  %terminal117 = getelementptr inbounds %struct.frame, %struct.frame* %92, i32 0, i32 61
  %93 = load %struct.terminal*, %struct.terminal** %terminal117, align 8
  %cmp118 = icmp ne %struct.terminal* %93, null
  br i1 %cmp118, label %cond.true.119, label %cond.false.121

cond.true.119:                                    ; preds = %land.lhs.true.115
  %94 = load i64, i64* @selected_frame, align 8
  %sub120 = sub nsw i64 %94, 5
  %95 = inttoptr i64 %sub120 to i8*
  %96 = bitcast i8* %95 to %struct.frame*
  br label %cond.end.122

cond.false.121:                                   ; preds = %land.lhs.true.115, %cond.end.112
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.122

cond.end.122:                                     ; preds = %97, %cond.true.119
  %cond123 = phi %struct.frame* [ %96, %cond.true.119 ], [ null, %97 ]
  %menu_bar_lines = getelementptr inbounds %struct.frame, %struct.frame* %cond123, i32 0, i32 57
  %98 = load i32, i32* %menu_bar_lines, align 4
  %sub124 = sub nsw i32 %88, %98
  call void @change_frame_size(%struct.frame* %cond113, i32 %87, i32 %sub124, i1 zeroext false, i1 zeroext false, i1 zeroext false, i1 zeroext false)
  br label %if.end.125

if.end.125:                                       ; preds = %cond.end.122, %lor.lhs.false.101
  %call126 = call i64 @intern(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.24, i32 0, i32 0))
  call void @run_hook(i64 %call126)
  %call127 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call127
}

declare void @get_tty_size(i32, i32*, i32*) #1

declare void @reset_all_sys_modes() #1

declare void @init_all_sys_modes() #1

; Function Attrs: nounwind uwtable
define void @stuff_buffered_input(i64 %stuffstring) #0 {
entry:
  %stuffstring.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %count = alloca i64, align 8
  store i64 %stuffstring, i64* %stuffstring.addr, align 8
  %0 = load i64, i64* %stuffstring.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %stuffstring.addr, align 8
  %call1 = call i8* @SDATA(i64 %1)
  store i8* %call1, i8** %p, align 8
  %2 = load i64, i64* %stuffstring.addr, align 8
  %call2 = call i64 @SBYTES(i64 %2)
  store i64 %call2, i64* %count, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %3 = load i64, i64* %count, align 8
  %dec = add nsw i64 %3, -1
  store i64 %dec, i64* %count, align 8
  %cmp = icmp sgt i64 %3, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %5 = load i8, i8* %4, align 1
  call void @stuff_char(i8 signext %5)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  call void @stuff_char(i8 signext 10)
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %7 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp3 = icmp ne %union.buffered_input_event* %6, %7
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %cmp4 = icmp eq %union.buffered_input_event* %8, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %for.body
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %for.body
  %9 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %10 = bitcast %union.buffered_input_event* %9 to i16*
  %bf.load = load i16, i16* %10, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp7 = icmp eq i32 %bf.cast, 1
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.6
  %11 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %ie = bitcast %union.buffered_input_event* %11 to %struct.input_event*
  %code = getelementptr inbounds %struct.input_event, %struct.input_event* %ie, i32 0, i32 1
  %12 = load i32, i32* %code, align 4
  %conv = trunc i32 %12 to i8
  call void @stuff_char(i8 signext %conv)
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.8, %if.end.6
  %13 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  call void @clear_event(%union.buffered_input_event* %13)
  br label %for.inc

for.inc:                                          ; preds = %if.end.9
  %14 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %incdec.ptr10 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %14, i32 1
  store %union.buffered_input_event* %incdec.ptr10, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i8 0, i8* @input_pending, align 1
  ret void
}

declare void @sys_subshell() #1

declare void @change_frame_size(%struct.frame*, i32, i32, i1 zeroext, i1 zeroext, i1 zeroext, i1 zeroext) #1

declare void @stuff_char(i8 signext) #1

; Function Attrs: nounwind uwtable
define internal void @clear_event(%union.buffered_input_event* %event) #0 {
entry:
  %event.addr = alloca %union.buffered_input_event*, align 8
  store %union.buffered_input_event* %event, %union.buffered_input_event** %event.addr, align 8
  %0 = load %union.buffered_input_event*, %union.buffered_input_event** %event.addr, align 8
  %1 = bitcast %union.buffered_input_event* %0 to i16*
  store i16 0, i16* %1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_waiting_for_input(%struct.timespec* %time_to_clear) #0 {
entry:
  %time_to_clear.addr = alloca %struct.timespec*, align 8
  store %struct.timespec* %time_to_clear, %struct.timespec** %time_to_clear.addr, align 8
  %0 = load %struct.timespec*, %struct.timespec** %time_to_clear.addr, align 8
  store %struct.timespec* %0, %struct.timespec** @input_available_clear_time, align 8
  store i8 1, i8* @waiting_for_input, align 1
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @quit_throw_to_read_char(i1 zeroext false) #11
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define internal void @quit_throw_to_read_char(i1 zeroext %from_signal) #3 {
entry:
  %from_signal.addr = alloca i8, align 1
  %frombool = zext i1 %from_signal to i8
  store i8 %frombool, i8* %from_signal.addr, align 1
  %0 = load i8, i8* %from_signal.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 594)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %2 = call i64 @Fkill_emacs(i64 %call1) #11
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  call void @clear_waiting_for_input()
  store i8 0, i8* @input_pending, align 1
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %3 = load i64, i64* @internal_last_event_frame, align 8
  %call3 = call zeroext i1 @FRAMEP(i64 %3)
  br i1 %call3, label %land.lhs.true.4, label %if.end.10

land.lhs.true.4:                                  ; preds = %if.end
  %4 = load i64, i64* @internal_last_event_frame, align 8
  %5 = load i64, i64* @selected_frame, align 8
  %cmp5 = icmp eq i64 %4, %5
  br i1 %cmp5, label %if.end.10, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true.4
  %6 = load i64, i64* @internal_last_event_frame, align 8
  %call7 = call i64 @make_lispy_switch_frame(i64 %6)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %call9 = call i64 @do_switch_frame(i64 %call7, i32 0, i32 0, i64 %call8)
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.6, %land.lhs.true.4, %if.end
  call void @_longjmp(%struct.__jmp_buf_tag* getelementptr inbounds ([1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* @getcjmp, i32 0, i32 0), i32 1) #15
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define void @clear_waiting_for_input() #0 {
entry:
  store i8 0, i8* @waiting_for_input, align 1
  store %struct.timespec* null, %struct.timespec** @input_available_clear_time, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fset_input_interrupt_mode(i64 %interrupt) #0 {
entry:
  %interrupt.addr = alloca i64, align 8
  %new_interrupt_input = alloca i8, align 1
  store i64 %interrupt, i64* %interrupt.addr, align 8
  %0 = load %struct.x_display_info*, %struct.x_display_info** @x_display_list, align 8
  %cmp = icmp ne %struct.x_display_info* %0, null
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8 1, i8* %new_interrupt_input, align 1
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load i64, i64* %interrupt.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp1 = icmp eq i64 %1, %call
  %lnot = xor i1 %cmp1, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %new_interrupt_input, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %2 = load i8, i8* %new_interrupt_input, align 1
  %tobool = trunc i8 %2 to i1
  %conv = zext i1 %tobool to i32
  %3 = load i8, i8* @interrupt_input, align 1
  %tobool2 = trunc i8 %3 to i1
  %conv3 = zext i1 %tobool2 to i32
  %cmp4 = icmp ne i32 %conv, %conv3
  br i1 %cmp4, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end
  call void @stop_polling()
  call void @reset_all_sys_modes()
  %4 = load i8, i8* %new_interrupt_input, align 1
  %tobool7 = trunc i8 %4 to i1
  %frombool8 = zext i1 %tobool7 to i8
  store i8 %frombool8, i8* @interrupt_input, align 1
  call void @init_all_sys_modes()
  store i32 1, i32* @poll_suppress_count, align 4
  call void @start_polling()
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.6, %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call10
}

; Function Attrs: nounwind uwtable
define i64 @Fset_output_flow_control(i64 %flow, i64 %terminal) #0 {
entry:
  %retval = alloca i64, align 8
  %flow.addr = alloca i64, align 8
  %terminal.addr = alloca i64, align 8
  %t = alloca %struct.terminal*, align 8
  %tty = alloca %struct.tty_display_info*, align 8
  store i64 %flow, i64* %flow.addr, align 8
  store i64 %terminal, i64* %terminal.addr, align 8
  %0 = load i64, i64* %terminal.addr, align 8
  %call = call %struct.terminal* @decode_tty_terminal(i64 %0)
  store %struct.terminal* %call, %struct.terminal** %t, align 8
  %1 = load %struct.terminal*, %struct.terminal** %t, align 8
  %tobool = icmp ne %struct.terminal* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.terminal*, %struct.terminal** %t, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %2, i32 0, i32 12
  %tty2 = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %3 = load %struct.tty_display_info*, %struct.tty_display_info** %tty2, align 8
  store %struct.tty_display_info* %3, %struct.tty_display_info** %tty, align 8
  %4 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %flow_control = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %4, i32 0, i32 75
  %bf.load = load i8, i8* %flow_control, align 4
  %bf.lshr = lshr i8 %bf.load, 1
  %bf.clear = and i8 %bf.lshr, 1
  %bf.cast = trunc i8 %bf.clear to i1
  %conv = zext i1 %bf.cast to i32
  %5 = load i64, i64* %flow.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %5, %call3
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %cmp5 = icmp ne i32 %conv, %lnot.ext
  br i1 %cmp5, label %if.then.7, label %if.end.17

if.then.7:                                        ; preds = %if.end
  %6 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @reset_sys_modes(%struct.tty_display_info* %6)
  %7 = load i64, i64* %flow.addr, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %7, %call8
  %lnot11 = xor i1 %cmp9, true
  %8 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %flow_control13 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %8, i32 0, i32 75
  %9 = zext i1 %lnot11 to i8
  %bf.load14 = load i8, i8* %flow_control13, align 4
  %bf.shl = shl i8 %9, 1
  %bf.clear15 = and i8 %bf.load14, -3
  %bf.set = or i8 %bf.clear15, %bf.shl
  store i8 %bf.set, i8* %flow_control13, align 4
  %tobool16 = trunc i8 %9 to i1
  %10 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @init_sys_modes(%struct.tty_display_info* %10)
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.7, %if.end
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call18, i64* %retval
  br label %return

return:                                           ; preds = %if.end.17, %if.then
  %11 = load i64, i64* %retval
  ret i64 %11
}

declare %struct.terminal* @decode_tty_terminal(i64) #1

declare void @reset_sys_modes(%struct.tty_display_info*) #1

declare void @init_sys_modes(%struct.tty_display_info*) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_input_meta_mode(i64 %meta, i64 %terminal) #0 {
entry:
  %retval = alloca i64, align 8
  %meta.addr = alloca i64, align 8
  %terminal.addr = alloca i64, align 8
  %t = alloca %struct.terminal*, align 8
  %tty = alloca %struct.tty_display_info*, align 8
  %new_meta = alloca i32, align 4
  store i64 %meta, i64* %meta.addr, align 8
  store i64 %terminal, i64* %terminal.addr, align 8
  %0 = load i64, i64* %terminal.addr, align 8
  %call = call %struct.terminal* @decode_tty_terminal(i64 %0)
  store %struct.terminal* %call, %struct.terminal** %t, align 8
  %1 = load %struct.terminal*, %struct.terminal** %t, align 8
  %tobool = icmp ne %struct.terminal* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.terminal*, %struct.terminal** %t, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %2, i32 0, i32 12
  %tty2 = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %3 = load %struct.tty_display_info*, %struct.tty_display_info** %tty2, align 8
  store %struct.tty_display_info* %3, %struct.tty_display_info** %tty, align 8
  %4 = load i64, i64* %meta.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %4, %call3
  br i1 %cmp, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.end
  store i32 0, i32* %new_meta, align 4
  br label %if.end.10

if.else:                                          ; preds = %if.end
  %5 = load i64, i64* %meta.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp6 = icmp eq i64 %5, %call5
  br i1 %cmp6, label %if.then.7, label %if.else.8

if.then.7:                                        ; preds = %if.else
  store i32 1, i32* %new_meta, align 4
  br label %if.end.9

if.else.8:                                        ; preds = %if.else
  store i32 2, i32* %new_meta, align 4
  br label %if.end.9

if.end.9:                                         ; preds = %if.else.8, %if.then.7
  br label %if.end.10

if.end.10:                                        ; preds = %if.end.9, %if.then.4
  %6 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %6, i32 0, i32 73
  %7 = load i32, i32* %meta_key, align 4
  %8 = load i32, i32* %new_meta, align 4
  %cmp11 = icmp ne i32 %7, %8
  br i1 %cmp11, label %if.then.12, label %if.end.14

if.then.12:                                       ; preds = %if.end.10
  %9 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @reset_sys_modes(%struct.tty_display_info* %9)
  %10 = load i32, i32* %new_meta, align 4
  %11 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key13 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %11, i32 0, i32 73
  store i32 %10, i32* %meta_key13, align 4
  %12 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @init_sys_modes(%struct.tty_display_info* %12)
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.12, %if.end.10
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* %retval
  br label %return

return:                                           ; preds = %if.end.14, %if.then
  %13 = load i64, i64* %retval
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define i64 @Fset_quit_char(i64 %quit) #0 {
entry:
  %retval = alloca i64, align 8
  %quit.addr = alloca i64, align 8
  %t = alloca %struct.terminal*, align 8
  %tty = alloca %struct.tty_display_info*, align 8
  store i64 %quit, i64* %quit.addr, align 8
  %call = call %struct.terminal* @get_named_terminal(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0))
  store %struct.terminal* %call, %struct.terminal** %t, align 8
  %0 = load %struct.terminal*, %struct.terminal** %t, align 8
  %tobool = icmp ne %struct.terminal* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.terminal*, %struct.terminal** %t, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %1, i32 0, i32 12
  %tty2 = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %2 = load %struct.tty_display_info*, %struct.tty_display_info** %tty2, align 8
  store %struct.tty_display_info* %2, %struct.tty_display_info** %tty, align 8
  %3 = load i64, i64* %quit.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call3
  br i1 %cmp, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %4 = load i64, i64* %quit.addr, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %and4 = and i32 %conv, -5
  %cmp5 = icmp eq i32 %and4, 2
  br i1 %cmp5, label %lor.lhs.false.7, label %if.then.14

lor.lhs.false.7:                                  ; preds = %lor.lhs.false
  %5 = load i64, i64* %quit.addr, align 8
  %shr = ashr i64 %5, 2
  %cmp8 = icmp slt i64 %shr, 0
  br i1 %cmp8, label %if.then.14, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false.7
  %6 = load i64, i64* %quit.addr, align 8
  %shr11 = ashr i64 %6, 2
  %cmp12 = icmp sgt i64 %shr11, 256
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %lor.lhs.false.10, %lor.lhs.false.7, %lor.lhs.false, %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.26, i32 0, i32 0)) #11
  unreachable

if.end.15:                                        ; preds = %lor.lhs.false.10
  %7 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @reset_sys_modes(%struct.tty_display_info* %7)
  %8 = load i64, i64* %quit.addr, align 8
  %shr16 = ashr i64 %8, 2
  %9 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %meta_key = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %9, i32 0, i32 73
  %10 = load i32, i32* %meta_key, align 4
  %cmp17 = icmp eq i32 %10, 0
  %cond = select i1 %cmp17, i32 127, i32 255
  %conv19 = sext i32 %cond to i64
  %and20 = and i64 %shr16, %conv19
  %conv21 = trunc i64 %and20 to i32
  store i32 %conv21, i32* @quit_char, align 4
  %11 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  call void @init_sys_modes(%struct.tty_display_info* %11)
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call22, i64* %retval
  br label %return

return:                                           ; preds = %if.end.15, %if.then
  %12 = load i64, i64* %retval
  ret i64 %12
}

declare %struct.terminal* @get_named_terminal(i8*) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_input_mode(i64 %interrupt, i64 %flow, i64 %meta, i64 %quit) #0 {
entry:
  %interrupt.addr = alloca i64, align 8
  %flow.addr = alloca i64, align 8
  %meta.addr = alloca i64, align 8
  %quit.addr = alloca i64, align 8
  store i64 %interrupt, i64* %interrupt.addr, align 8
  store i64 %flow, i64* %flow.addr, align 8
  store i64 %meta, i64* %meta.addr, align 8
  store i64 %quit, i64* %quit.addr, align 8
  %0 = load i64, i64* %interrupt.addr, align 8
  %call = call i64 @Fset_input_interrupt_mode(i64 %0)
  %1 = load i64, i64* %flow.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @Fset_output_flow_control(i64 %1, i64 %call1)
  %2 = load i64, i64* %meta.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fset_input_meta_mode(i64 %2, i64 %call3)
  %3 = load i64, i64* %quit.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call5
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %quit.addr, align 8
  %call6 = call i64 @Fset_quit_char(i64 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call7
}

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_input_mode() #0 {
entry:
  %sf = alloca %struct.frame*, align 8
  %interrupt = alloca i64, align 8
  %flow = alloca i64, align 8
  %meta = alloca i64, align 8
  %quit = alloca i64, align 8
  %0 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %0, 5
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.frame*
  store %struct.frame* %2, %struct.frame** %sf, align 8
  %3 = load i8, i8* @interrupt_input, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %call1, %cond.false ]
  store i64 %cond, i64* %interrupt, align 8
  %4 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %4, i32 0, i32 26
  %5 = bitcast i48* %output_method to i64*
  %bf.load = load i64, i64* %5, align 8
  %bf.lshr = lshr i64 %bf.load, 23
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %6 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method2 = getelementptr inbounds %struct.frame, %struct.frame* %6, i32 0, i32 26
  %7 = bitcast i48* %output_method2 to i64*
  %bf.load3 = load i64, i64* %7, align 8
  %bf.lshr4 = lshr i64 %bf.load3, 23
  %bf.clear5 = and i64 %bf.lshr4, 7
  %bf.cast6 = trunc i64 %bf.clear5 to i32
  %cmp7 = icmp eq i32 %bf.cast6, 1
  br i1 %cmp7, label %cond.true.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method8 = getelementptr inbounds %struct.frame, %struct.frame* %8, i32 0, i32 26
  %9 = bitcast i48* %output_method8 to i64*
  %bf.load9 = load i64, i64* %9, align 8
  %bf.lshr10 = lshr i64 %bf.load9, 23
  %bf.clear11 = and i64 %bf.lshr10, 7
  %bf.cast12 = trunc i64 %bf.clear11 to i32
  %cmp13 = icmp eq i32 %bf.cast12, 3
  br i1 %cmp13, label %cond.true.14, label %cond.false.15

cond.true.14:                                     ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.frame*, %struct.frame** %sf, align 8
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %10, i32 0, i32 61
  %11 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %11, i32 0, i32 12
  %tty = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %12 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  br label %cond.end.16

cond.false.15:                                    ; preds = %lor.lhs.false
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.16

cond.end.16:                                      ; preds = %13, %cond.true.14
  %cond17 = phi %struct.tty_display_info* [ %12, %cond.true.14 ], [ null, %13 ]
  %flow_control = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %cond17, i32 0, i32 75
  %bf.load18 = load i8, i8* %flow_control, align 4
  %bf.lshr19 = lshr i8 %bf.load18, 1
  %bf.clear20 = and i8 %bf.lshr19, 1
  %bf.cast21 = trunc i8 %bf.clear20 to i1
  br i1 %bf.cast21, label %cond.true.22, label %cond.false.24

cond.true.22:                                     ; preds = %cond.end.16
  %call23 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.26

cond.false.24:                                    ; preds = %cond.end.16
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.26

cond.end.26:                                      ; preds = %cond.false.24, %cond.true.22
  %cond27 = phi i64 [ %call23, %cond.true.22 ], [ %call25, %cond.false.24 ]
  store i64 %cond27, i64* %flow, align 8
  %14 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method28 = getelementptr inbounds %struct.frame, %struct.frame* %14, i32 0, i32 26
  %15 = bitcast i48* %output_method28 to i64*
  %bf.load29 = load i64, i64* %15, align 8
  %bf.lshr30 = lshr i64 %bf.load29, 23
  %bf.clear31 = and i64 %bf.lshr30, 7
  %bf.cast32 = trunc i64 %bf.clear31 to i32
  %cmp33 = icmp eq i32 %bf.cast32, 1
  br i1 %cmp33, label %cond.true.41, label %lor.lhs.false.34

lor.lhs.false.34:                                 ; preds = %cond.end.26
  %16 = load %struct.frame*, %struct.frame** %sf, align 8
  %output_method35 = getelementptr inbounds %struct.frame, %struct.frame* %16, i32 0, i32 26
  %17 = bitcast i48* %output_method35 to i64*
  %bf.load36 = load i64, i64* %17, align 8
  %bf.lshr37 = lshr i64 %bf.load36, 23
  %bf.clear38 = and i64 %bf.lshr37, 7
  %bf.cast39 = trunc i64 %bf.clear38 to i32
  %cmp40 = icmp eq i32 %bf.cast39, 3
  br i1 %cmp40, label %cond.true.41, label %cond.false.45

cond.true.41:                                     ; preds = %lor.lhs.false.34, %cond.end.26
  %18 = load %struct.frame*, %struct.frame** %sf, align 8
  %terminal42 = getelementptr inbounds %struct.frame, %struct.frame* %18, i32 0, i32 61
  %19 = load %struct.terminal*, %struct.terminal** %terminal42, align 8
  %display_info43 = getelementptr inbounds %struct.terminal, %struct.terminal* %19, i32 0, i32 12
  %tty44 = bitcast %union.display_info* %display_info43 to %struct.tty_display_info**
  %20 = load %struct.tty_display_info*, %struct.tty_display_info** %tty44, align 8
  br label %cond.end.46

cond.false.45:                                    ; preds = %lor.lhs.false.34
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.46

cond.end.46:                                      ; preds = %21, %cond.true.41
  %cond47 = phi %struct.tty_display_info* [ %20, %cond.true.41 ], [ null, %21 ]
  %meta_key = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %cond47, i32 0, i32 73
  %22 = load i32, i32* %meta_key, align 4
  %cmp48 = icmp eq i32 %22, 2
  br i1 %cmp48, label %cond.true.49, label %cond.false.50

cond.true.49:                                     ; preds = %cond.end.46
  br label %cond.end.108

cond.false.50:                                    ; preds = %cond.end.46
  %23 = load i64, i64* @selected_frame, align 8
  %call51 = call zeroext i1 @FRAMEP(i64 %23)
  br i1 %call51, label %land.lhs.true, label %cond.false.57

land.lhs.true:                                    ; preds = %cond.false.50
  %24 = load i64, i64* @selected_frame, align 8
  %sub52 = sub nsw i64 %24, 5
  %25 = inttoptr i64 %sub52 to i8*
  %26 = bitcast i8* %25 to %struct.frame*
  %terminal53 = getelementptr inbounds %struct.frame, %struct.frame* %26, i32 0, i32 61
  %27 = load %struct.terminal*, %struct.terminal** %terminal53, align 8
  %cmp54 = icmp ne %struct.terminal* %27, null
  br i1 %cmp54, label %cond.true.55, label %cond.false.57

cond.true.55:                                     ; preds = %land.lhs.true
  %28 = load i64, i64* @selected_frame, align 8
  %sub56 = sub nsw i64 %28, 5
  %29 = inttoptr i64 %sub56 to i8*
  %30 = bitcast i8* %29 to %struct.frame*
  br label %cond.end.58

cond.false.57:                                    ; preds = %land.lhs.true, %cond.false.50
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.58

cond.end.58:                                      ; preds = %31, %cond.true.55
  %cond59 = phi %struct.frame* [ %30, %cond.true.55 ], [ null, %31 ]
  %output_method60 = getelementptr inbounds %struct.frame, %struct.frame* %cond59, i32 0, i32 26
  %32 = bitcast i48* %output_method60 to i64*
  %bf.load61 = load i64, i64* %32, align 8
  %bf.lshr62 = lshr i64 %bf.load61, 23
  %bf.clear63 = and i64 %bf.lshr62, 7
  %bf.cast64 = trunc i64 %bf.clear63 to i32
  %cmp65 = icmp eq i32 %bf.cast64, 1
  br i1 %cmp65, label %cond.true.83, label %lor.lhs.false.66

lor.lhs.false.66:                                 ; preds = %cond.end.58
  %33 = load i64, i64* @selected_frame, align 8
  %call67 = call zeroext i1 @FRAMEP(i64 %33)
  br i1 %call67, label %land.lhs.true.68, label %cond.false.74

land.lhs.true.68:                                 ; preds = %lor.lhs.false.66
  %34 = load i64, i64* @selected_frame, align 8
  %sub69 = sub nsw i64 %34, 5
  %35 = inttoptr i64 %sub69 to i8*
  %36 = bitcast i8* %35 to %struct.frame*
  %terminal70 = getelementptr inbounds %struct.frame, %struct.frame* %36, i32 0, i32 61
  %37 = load %struct.terminal*, %struct.terminal** %terminal70, align 8
  %cmp71 = icmp ne %struct.terminal* %37, null
  br i1 %cmp71, label %cond.true.72, label %cond.false.74

cond.true.72:                                     ; preds = %land.lhs.true.68
  %38 = load i64, i64* @selected_frame, align 8
  %sub73 = sub nsw i64 %38, 5
  %39 = inttoptr i64 %sub73 to i8*
  %40 = bitcast i8* %39 to %struct.frame*
  br label %cond.end.75

cond.false.74:                                    ; preds = %land.lhs.true.68, %lor.lhs.false.66
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.75

cond.end.75:                                      ; preds = %41, %cond.true.72
  %cond76 = phi %struct.frame* [ %40, %cond.true.72 ], [ null, %41 ]
  %output_method77 = getelementptr inbounds %struct.frame, %struct.frame* %cond76, i32 0, i32 26
  %42 = bitcast i48* %output_method77 to i64*
  %bf.load78 = load i64, i64* %42, align 8
  %bf.lshr79 = lshr i64 %bf.load78, 23
  %bf.clear80 = and i64 %bf.lshr79, 7
  %bf.cast81 = trunc i64 %bf.clear80 to i32
  %cmp82 = icmp eq i32 %bf.cast81, 3
  br i1 %cmp82, label %cond.true.83, label %cond.false.97

cond.true.83:                                     ; preds = %cond.end.75, %cond.end.58
  %43 = load i64, i64* @selected_frame, align 8
  %call84 = call zeroext i1 @FRAMEP(i64 %43)
  br i1 %call84, label %land.lhs.true.85, label %cond.false.91

land.lhs.true.85:                                 ; preds = %cond.true.83
  %44 = load i64, i64* @selected_frame, align 8
  %sub86 = sub nsw i64 %44, 5
  %45 = inttoptr i64 %sub86 to i8*
  %46 = bitcast i8* %45 to %struct.frame*
  %terminal87 = getelementptr inbounds %struct.frame, %struct.frame* %46, i32 0, i32 61
  %47 = load %struct.terminal*, %struct.terminal** %terminal87, align 8
  %cmp88 = icmp ne %struct.terminal* %47, null
  br i1 %cmp88, label %cond.true.89, label %cond.false.91

cond.true.89:                                     ; preds = %land.lhs.true.85
  %48 = load i64, i64* @selected_frame, align 8
  %sub90 = sub nsw i64 %48, 5
  %49 = inttoptr i64 %sub90 to i8*
  %50 = bitcast i8* %49 to %struct.frame*
  br label %cond.end.92

cond.false.91:                                    ; preds = %land.lhs.true.85, %cond.true.83
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.92

cond.end.92:                                      ; preds = %51, %cond.true.89
  %cond93 = phi %struct.frame* [ %50, %cond.true.89 ], [ null, %51 ]
  %terminal94 = getelementptr inbounds %struct.frame, %struct.frame* %cond93, i32 0, i32 61
  %52 = load %struct.terminal*, %struct.terminal** %terminal94, align 8
  %display_info95 = getelementptr inbounds %struct.terminal, %struct.terminal* %52, i32 0, i32 12
  %tty96 = bitcast %union.display_info* %display_info95 to %struct.tty_display_info**
  %53 = load %struct.tty_display_info*, %struct.tty_display_info** %tty96, align 8
  br label %cond.end.98

cond.false.97:                                    ; preds = %cond.end.75
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.98

cond.end.98:                                      ; preds = %54, %cond.end.92
  %cond99 = phi %struct.tty_display_info* [ %53, %cond.end.92 ], [ null, %54 ]
  %meta_key100 = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %cond99, i32 0, i32 73
  %55 = load i32, i32* %meta_key100, align 4
  %cmp101 = icmp eq i32 %55, 1
  br i1 %cmp101, label %cond.true.102, label %cond.false.104

cond.true.102:                                    ; preds = %cond.end.98
  %call103 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.106

cond.false.104:                                   ; preds = %cond.end.98
  %call105 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.106

cond.end.106:                                     ; preds = %cond.false.104, %cond.true.102
  %cond107 = phi i64 [ %call103, %cond.true.102 ], [ %call105, %cond.false.104 ]
  br label %cond.end.108

cond.end.108:                                     ; preds = %cond.end.106, %cond.true.49
  %cond109 = phi i64 [ 2, %cond.true.49 ], [ %cond107, %cond.end.106 ]
  store i64 %cond109, i64* %meta, align 8
  br label %if.end

if.else:                                          ; preds = %cond.end
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call110, i64* %flow, align 8
  %call111 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call111, i64* %meta, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end.108
  %56 = load i32, i32* @quit_char, align 4
  %conv = sext i32 %56 to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %quit, align 8
  %57 = load i64, i64* %interrupt, align 8
  %58 = load i64, i64* %flow, align 8
  %59 = load i64, i64* %meta, align 8
  %60 = load i64, i64* %quit, align 8
  %call112 = call i64 @list4(i64 %57, i64 %58, i64 %59, i64 %60)
  ret i64 %call112
}

declare i64 @list4(i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fposn_at_x_y(i64 %x, i64 %y, i64 %frame_or_window, i64 %whole) #0 {
entry:
  %x.addr = alloca i64, align 8
  %y.addr = alloca i64, align 8
  %frame_or_window.addr = alloca i64, align 8
  %whole.addr = alloca i64, align 8
  %w = alloca %struct.window*, align 8
  store i64 %x, i64* %x.addr, align 8
  store i64 %y, i64* %y.addr, align 8
  store i64 %frame_or_window, i64* %frame_or_window.addr, align 8
  store i64 %whole, i64* %whole.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %x.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %x.addr, align 8
  %shr = ashr i64 %4, 2
  %cmp3 = icmp ne i64 %shr, -1
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %5 = load i64, i64* %x.addr, align 8
  call void @CHECK_NATNUM(i64 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %6 = load i64, i64* %y.addr, align 8
  call void @CHECK_NATNUM(i64 %6)
  %7 = load i64, i64* %frame_or_window.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %7, %call5
  br i1 %cmp6, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end
  %8 = load i64, i64* @selected_window, align 8
  store i64 %8, i64* %frame_or_window.addr, align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.8, %if.end
  %9 = load i64, i64* %frame_or_window.addr, align 8
  %call10 = call zeroext i1 @WINDOWP(i64 %9)
  br i1 %call10, label %if.then.11, label %if.end.36

if.then.11:                                       ; preds = %if.end.9
  %10 = load i64, i64* %frame_or_window.addr, align 8
  %call12 = call %struct.window* @decode_live_window(i64 %10)
  store %struct.window* %call12, %struct.window** %w, align 8
  %11 = load i64, i64* %x.addr, align 8
  %shr13 = ashr i64 %11, 2
  %12 = load %struct.window*, %struct.window** %w, align 8
  %frame = getelementptr inbounds %struct.window, %struct.window* %12, i32 0, i32 1
  %13 = load i64, i64* %frame, align 8
  %sub = sub nsw i64 %13, 5
  %14 = inttoptr i64 %sub to i8*
  %15 = bitcast i8* %14 to %struct.frame*
  %internal_border_width = getelementptr inbounds %struct.frame, %struct.frame* %15, i32 0, i32 51
  %16 = load i32, i32* %internal_border_width, align 4
  %17 = load %struct.window*, %struct.window** %w, align 8
  %pixel_left = getelementptr inbounds %struct.window, %struct.window* %17, i32 0, i32 30
  %18 = load i32, i32* %pixel_left, align 4
  %add = add nsw i32 %16, %18
  %conv14 = sext i32 %add to i64
  %add15 = add nsw i64 %shr13, %conv14
  %19 = load i64, i64* %whole.addr, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %19, %call16
  br i1 %cmp17, label %cond.true.19, label %cond.false.21

cond.true.19:                                     ; preds = %if.then.11
  %20 = load %struct.window*, %struct.window** %w, align 8
  %call20 = call i32 @window_box_left_offset(%struct.window* %20, i32 1)
  br label %cond.end.22

cond.false.21:                                    ; preds = %if.then.11
  br label %cond.end.22

cond.end.22:                                      ; preds = %cond.false.21, %cond.true.19
  %cond = phi i32 [ %call20, %cond.true.19 ], [ 0, %cond.false.21 ]
  %conv23 = sext i32 %cond to i64
  %add24 = add nsw i64 %add15, %conv23
  %shl = shl i64 %add24, 2
  %add25 = add i64 %shl, 2
  store i64 %add25, i64* %x.addr, align 8
  %21 = load i64, i64* %y.addr, align 8
  %shr26 = ashr i64 %21, 2
  %22 = load %struct.window*, %struct.window** %w, align 8
  %frame27 = getelementptr inbounds %struct.window, %struct.window* %22, i32 0, i32 1
  %23 = load i64, i64* %frame27, align 8
  %sub28 = sub nsw i64 %23, 5
  %24 = inttoptr i64 %sub28 to i8*
  %25 = bitcast i8* %24 to %struct.frame*
  %internal_border_width29 = getelementptr inbounds %struct.frame, %struct.frame* %25, i32 0, i32 51
  %26 = load i32, i32* %internal_border_width29, align 4
  %27 = load %struct.window*, %struct.window** %w, align 8
  %pixel_top = getelementptr inbounds %struct.window, %struct.window* %27, i32 0, i32 31
  %28 = load i32, i32* %pixel_top, align 4
  %add30 = add nsw i32 %26, %28
  %conv31 = sext i32 %add30 to i64
  %add32 = add nsw i64 %shr26, %conv31
  %shl33 = shl i64 %add32, 2
  %add34 = add i64 %shl33, 2
  store i64 %add34, i64* %y.addr, align 8
  %29 = load %struct.window*, %struct.window** %w, align 8
  %frame35 = getelementptr inbounds %struct.window, %struct.window* %29, i32 0, i32 1
  %30 = load i64, i64* %frame35, align 8
  store i64 %30, i64* %frame_or_window.addr, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %cond.end.22, %if.end.9
  %31 = load i64, i64* %frame_or_window.addr, align 8
  %call37 = call zeroext i1 @FRAMEP(i64 %31)
  br i1 %call37, label %land.lhs.true, label %cond.false.43

land.lhs.true:                                    ; preds = %if.end.36
  %32 = load i64, i64* %frame_or_window.addr, align 8
  %sub39 = sub nsw i64 %32, 5
  %33 = inttoptr i64 %sub39 to i8*
  %34 = bitcast i8* %33 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %34, i32 0, i32 61
  %35 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp40 = icmp ne %struct.terminal* %35, null
  br i1 %cmp40, label %cond.true.42, label %cond.false.43

cond.true.42:                                     ; preds = %land.lhs.true
  br label %cond.end.45

cond.false.43:                                    ; preds = %land.lhs.true, %if.end.36
  %call44 = call i64 @builtin_lisp_symbol(i32 458)
  %36 = load i64, i64* %frame_or_window.addr, align 8
  %37 = call i64 @wrong_type_argument(i64 %call44, i64 %36) #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.45

cond.end.45:                                      ; preds = %38, %cond.true.42
  %39 = load i64, i64* %frame_or_window.addr, align 8
  %sub46 = sub nsw i64 %39, 5
  %40 = inttoptr i64 %sub46 to i8*
  %41 = bitcast i8* %40 to %struct.frame*
  %42 = load i64, i64* %x.addr, align 8
  %43 = load i64, i64* %y.addr, align 8
  %call47 = call i64 @make_lispy_position(%struct.frame* %41, i64 %42, i64 %43, i64 0)
  ret i64 %call47
}

; Function Attrs: noreturn
declare i64 @wrong_type_argument(i64, i64) #2

declare void @CHECK_NATNUM(i64) #1

declare %struct.window* @decode_live_window(i64) #1

declare i32 @window_box_left_offset(%struct.window*, i32) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_position(%struct.frame* %f, i64 %x, i64 %y, i64 %t) #0 {
entry:
  %f.addr = alloca %struct.frame*, align 8
  %x.addr = alloca i64, align 8
  %y.addr = alloca i64, align 8
  %t.addr = alloca i64, align 8
  %part = alloca i32, align 4
  %posn = alloca i64, align 8
  %extra_info = alloca i64, align 8
  %xret = alloca i32, align 4
  %yret = alloca i32, align 4
  %window = alloca i64, align 8
  %w = alloca %struct.window*, align 8
  %string_info = alloca i64, align 8
  %textpos = alloca i64, align 8
  %col = alloca i32, align 4
  %row = alloca i32, align 4
  %dx = alloca i32, align 4
  %dy = alloca i32, align 4
  %width = alloca i32, align 4
  %height = alloca i32, align 4
  %object = alloca i64, align 8
  %wx = alloca i32, align 4
  %wy = alloca i32, align 4
  %string = alloca i64, align 8
  %charpos = alloca i64, align 8
  %string167 = alloca i64, align 8
  %charpos168 = alloca i64, align 8
  %string2 = alloca i64, align 8
  %object2 = alloca i64, align 8
  %p = alloca %struct.display_pos, align 8
  %dx2 = alloca i32, align 4
  %dy2 = alloca i32, align 4
  %width2 = alloca i32, align 4
  %height2 = alloca i32, align 4
  %x2 = alloca i32, align 4
  %y2 = alloca i32, align 4
  %image_map = alloca i64, align 8
  %hotspot = alloca i64, align 8
  store %struct.frame* %f, %struct.frame** %f.addr, align 8
  store i64 %x, i64* %x.addr, align 8
  store i64 %y, i64* %y.addr, align 8
  store i64 %t, i64* %t.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %posn, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %extra_info, align 8
  store i32 0, i32* %xret, align 4
  store i32 0, i32* %yret, align 4
  %0 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %tobool = icmp ne %struct.frame* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %2 = load i64, i64* %x.addr, align 8
  %shr = ashr i64 %2, 2
  %conv = trunc i64 %shr to i32
  %3 = load i64, i64* %y.addr, align 8
  %shr2 = ashr i64 %3, 2
  %conv3 = trunc i64 %shr2 to i32
  %call4 = call i64 @window_from_coordinates(%struct.frame* %1, i32 %conv, i32 %conv3, i32* %part, i1 zeroext false)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call4, %cond.true ], [ %call5, %cond.false ]
  store i64 %cond, i64* %window, align 8
  %4 = load i64, i64* %window, align 8
  %call6 = call zeroext i1 @WINDOWP(i64 %4)
  br i1 %call6, label %if.then, label %if.else.1033

if.then:                                          ; preds = %cond.end
  %5 = load i64, i64* %window, align 8
  %call7 = call %struct.window* @XWINDOW(i64 %5)
  store %struct.window* %call7, %struct.window** %w, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call8, i64* %string_info, align 8
  store i64 0, i64* %textpos, align 8
  store i32 -1, i32* %col, align 4
  store i32 -1, i32* %row, align 4
  store i32 -1, i32* %dx, align 4
  store i32 -1, i32* %dy, align 4
  store i32 -1, i32* %width, align 4
  store i32 -1, i32* %height, align 4
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call9, i64* %object, align 8
  %6 = load i64, i64* %x.addr, align 8
  %shr10 = ashr i64 %6, 2
  %7 = load %struct.window*, %struct.window** %w, align 8
  %frame = getelementptr inbounds %struct.window, %struct.window* %7, i32 0, i32 1
  %8 = load i64, i64* %frame, align 8
  %sub = sub nsw i64 %8, 5
  %9 = inttoptr i64 %sub to i8*
  %10 = bitcast i8* %9 to %struct.frame*
  %internal_border_width = getelementptr inbounds %struct.frame, %struct.frame* %10, i32 0, i32 51
  %11 = load i32, i32* %internal_border_width, align 4
  %12 = load %struct.window*, %struct.window** %w, align 8
  %pixel_left = getelementptr inbounds %struct.window, %struct.window* %12, i32 0, i32 30
  %13 = load i32, i32* %pixel_left, align 4
  %add = add nsw i32 %11, %13
  %conv11 = sext i32 %add to i64
  %sub12 = sub nsw i64 %shr10, %conv11
  %conv13 = trunc i64 %sub12 to i32
  store i32 %conv13, i32* %wx, align 4
  %14 = load i64, i64* %y.addr, align 8
  %shr14 = ashr i64 %14, 2
  %15 = load %struct.window*, %struct.window** %w, align 8
  %frame15 = getelementptr inbounds %struct.window, %struct.window* %15, i32 0, i32 1
  %16 = load i64, i64* %frame15, align 8
  %sub16 = sub nsw i64 %16, 5
  %17 = inttoptr i64 %sub16 to i8*
  %18 = bitcast i8* %17 to %struct.frame*
  %internal_border_width17 = getelementptr inbounds %struct.frame, %struct.frame* %18, i32 0, i32 51
  %19 = load i32, i32* %internal_border_width17, align 4
  %20 = load %struct.window*, %struct.window** %w, align 8
  %pixel_top = getelementptr inbounds %struct.window, %struct.window* %20, i32 0, i32 31
  %21 = load i32, i32* %pixel_top, align 4
  %add18 = add nsw i32 %19, %21
  %conv19 = sext i32 %add18 to i64
  %sub20 = sub nsw i64 %shr14, %conv19
  %conv21 = trunc i64 %sub20 to i32
  store i32 %conv21, i32* %wy, align 4
  %22 = load i32, i32* %part, align 4
  %cmp = icmp eq i32 %22, 1
  br i1 %cmp, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %if.then
  %23 = load i64, i64* %x.addr, align 8
  %shr24 = ashr i64 %23, 2
  %24 = load %struct.window*, %struct.window** %w, align 8
  %call25 = call i32 @window_box_left(%struct.window* %24, i32 1)
  %conv26 = sext i32 %call25 to i64
  %sub27 = sub nsw i64 %shr24, %conv26
  %conv28 = trunc i64 %sub27 to i32
  store i32 %conv28, i32* %xret, align 4
  %25 = load i32, i32* %wy, align 4
  %26 = load %struct.window*, %struct.window** %w, align 8
  %contents = getelementptr inbounds %struct.window, %struct.window* %26, i32 0, i32 10
  %27 = load i64, i64* %contents, align 8
  %call29 = call zeroext i1 @BUFFERP(i64 %27)
  br i1 %call29, label %cond.true.31, label %cond.false.98

cond.true.31:                                     ; preds = %if.then.23
  %28 = load %struct.window*, %struct.window** %w, align 8
  %mini = getelementptr inbounds %struct.window, %struct.window* %28, i32 0, i32 67
  %bf.load = load i16, i16* %mini, align 4
  %bf.clear = and i16 %bf.load, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %cond.false.138, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.true.31
  %29 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p = getelementptr inbounds %struct.window, %struct.window* %29, i32 0, i32 67
  %bf.load32 = load i16, i16* %pseudo_window_p, align 4
  %bf.lshr = lshr i16 %bf.load32, 11
  %bf.clear33 = and i16 %bf.lshr, 1
  %bf.cast34 = trunc i16 %bf.clear33 to i1
  br i1 %bf.cast34, label %cond.false.138, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %land.lhs.true
  %30 = load %struct.window*, %struct.window** %w, align 8
  %frame36 = getelementptr inbounds %struct.window, %struct.window* %30, i32 0, i32 1
  %31 = load i64, i64* %frame36, align 8
  %sub37 = sub nsw i64 %31, 5
  %32 = inttoptr i64 %sub37 to i8*
  %33 = bitcast i8* %32 to %struct.frame*
  %wants_modeline = getelementptr inbounds %struct.frame, %struct.frame* %33, i32 0, i32 26
  %34 = bitcast i48* %wants_modeline to i64*
  %bf.load38 = load i64, i64* %34, align 8
  %bf.lshr39 = lshr i64 %bf.load38, 14
  %bf.clear40 = and i64 %bf.lshr39, 1
  %bf.cast41 = trunc i64 %bf.clear40 to i1
  br i1 %bf.cast41, label %land.lhs.true.43, label %cond.false.138

land.lhs.true.43:                                 ; preds = %land.lhs.true.35
  %35 = load %struct.window*, %struct.window** %w, align 8
  %contents44 = getelementptr inbounds %struct.window, %struct.window* %35, i32 0, i32 10
  %36 = load i64, i64* %contents44, align 8
  %call45 = call %struct.buffer* @XBUFFER(i64 %36)
  %header_line_format_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call45, i32 0, i32 13
  %37 = load i64, i64* %header_line_format_, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %37, %call46
  br i1 %cmp47, label %cond.false.138, label %land.lhs.true.49

land.lhs.true.49:                                 ; preds = %land.lhs.true.43
  %38 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height = getelementptr inbounds %struct.window, %struct.window* %38, i32 0, i32 35
  %39 = load i32, i32* %pixel_height, align 4
  %40 = load %struct.window*, %struct.window** %w, align 8
  %contents50 = getelementptr inbounds %struct.window, %struct.window* %40, i32 0, i32 10
  %41 = load i64, i64* %contents50, align 8
  %call51 = call zeroext i1 @BUFFERP(i64 %41)
  br i1 %call51, label %cond.true.53, label %cond.false.85

cond.true.53:                                     ; preds = %land.lhs.true.49
  %42 = load %struct.window*, %struct.window** %w, align 8
  %mini54 = getelementptr inbounds %struct.window, %struct.window* %42, i32 0, i32 67
  %bf.load55 = load i16, i16* %mini54, align 4
  %bf.clear56 = and i16 %bf.load55, 1
  %bf.cast57 = trunc i16 %bf.clear56 to i1
  br i1 %bf.cast57, label %cond.false.90, label %land.lhs.true.58

land.lhs.true.58:                                 ; preds = %cond.true.53
  %43 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p59 = getelementptr inbounds %struct.window, %struct.window* %43, i32 0, i32 67
  %bf.load60 = load i16, i16* %pseudo_window_p59, align 4
  %bf.lshr61 = lshr i16 %bf.load60, 11
  %bf.clear62 = and i16 %bf.lshr61, 1
  %bf.cast63 = trunc i16 %bf.clear62 to i1
  br i1 %bf.cast63, label %cond.false.90, label %land.lhs.true.64

land.lhs.true.64:                                 ; preds = %land.lhs.true.58
  %44 = load %struct.window*, %struct.window** %w, align 8
  %frame65 = getelementptr inbounds %struct.window, %struct.window* %44, i32 0, i32 1
  %45 = load i64, i64* %frame65, align 8
  %sub66 = sub nsw i64 %45, 5
  %46 = inttoptr i64 %sub66 to i8*
  %47 = bitcast i8* %46 to %struct.frame*
  %wants_modeline67 = getelementptr inbounds %struct.frame, %struct.frame* %47, i32 0, i32 26
  %48 = bitcast i48* %wants_modeline67 to i64*
  %bf.load68 = load i64, i64* %48, align 8
  %bf.lshr69 = lshr i64 %bf.load68, 14
  %bf.clear70 = and i64 %bf.lshr69, 1
  %bf.cast71 = trunc i64 %bf.clear70 to i1
  br i1 %bf.cast71, label %land.lhs.true.73, label %cond.false.90

land.lhs.true.73:                                 ; preds = %land.lhs.true.64
  %49 = load %struct.window*, %struct.window** %w, align 8
  %contents74 = getelementptr inbounds %struct.window, %struct.window* %49, i32 0, i32 10
  %50 = load i64, i64* %contents74, align 8
  %call75 = call %struct.buffer* @XBUFFER(i64 %50)
  %mode_line_format_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call75, i32 0, i32 12
  %51 = load i64, i64* %mode_line_format_, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp77 = icmp eq i64 %51, %call76
  br i1 %cmp77, label %cond.false.90, label %land.lhs.true.79

land.lhs.true.79:                                 ; preds = %land.lhs.true.73
  %52 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height80 = getelementptr inbounds %struct.window, %struct.window* %52, i32 0, i32 35
  %53 = load i32, i32* %pixel_height80, align 4
  %54 = load %struct.window*, %struct.window** %w, align 8
  %frame81 = getelementptr inbounds %struct.window, %struct.window* %54, i32 0, i32 1
  %55 = load i64, i64* %frame81, align 8
  %sub82 = sub nsw i64 %55, 5
  %56 = inttoptr i64 %sub82 to i8*
  %57 = bitcast i8* %56 to %struct.frame*
  %line_height = getelementptr inbounds %struct.frame, %struct.frame* %57, i32 0, i32 60
  %58 = load i32, i32* %line_height, align 4
  %cmp83 = icmp sgt i32 %53, %58
  br i1 %cmp83, label %cond.true.86, label %cond.false.90

cond.false.85:                                    ; preds = %land.lhs.true.49
  br i1 false, label %cond.true.86, label %cond.false.90

cond.true.86:                                     ; preds = %cond.false.85, %land.lhs.true.79
  %59 = load %struct.window*, %struct.window** %w, align 8
  %frame87 = getelementptr inbounds %struct.window, %struct.window* %59, i32 0, i32 1
  %60 = load i64, i64* %frame87, align 8
  %sub88 = sub nsw i64 %60, 5
  %61 = inttoptr i64 %sub88 to i8*
  %62 = bitcast i8* %61 to %struct.frame*
  %line_height89 = getelementptr inbounds %struct.frame, %struct.frame* %62, i32 0, i32 60
  %63 = load i32, i32* %line_height89, align 4
  %mul = mul nsw i32 2, %63
  br label %cond.end.94

cond.false.90:                                    ; preds = %cond.false.85, %land.lhs.true.79, %land.lhs.true.73, %land.lhs.true.64, %land.lhs.true.58, %cond.true.53
  %64 = load %struct.window*, %struct.window** %w, align 8
  %frame91 = getelementptr inbounds %struct.window, %struct.window* %64, i32 0, i32 1
  %65 = load i64, i64* %frame91, align 8
  %sub92 = sub nsw i64 %65, 5
  %66 = inttoptr i64 %sub92 to i8*
  %67 = bitcast i8* %66 to %struct.frame*
  %line_height93 = getelementptr inbounds %struct.frame, %struct.frame* %67, i32 0, i32 60
  %68 = load i32, i32* %line_height93, align 4
  br label %cond.end.94

cond.end.94:                                      ; preds = %cond.false.90, %cond.true.86
  %cond95 = phi i32 [ %mul, %cond.true.86 ], [ %68, %cond.false.90 ]
  %cmp96 = icmp sgt i32 %39, %cond95
  br i1 %cmp96, label %cond.true.99, label %cond.false.138

cond.false.98:                                    ; preds = %if.then.23
  br i1 false, label %cond.true.99, label %cond.false.138

cond.true.99:                                     ; preds = %cond.false.98, %cond.end.94
  %69 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height = getelementptr inbounds %struct.window, %struct.window* %69, i32 0, i32 64
  %70 = load i32, i32* %header_line_height, align 4
  %cmp100 = icmp sge i32 %70, 0
  br i1 %cmp100, label %cond.true.102, label %cond.false.104

cond.true.102:                                    ; preds = %cond.true.99
  %71 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height103 = getelementptr inbounds %struct.window, %struct.window* %71, i32 0, i32 64
  %72 = load i32, i32* %header_line_height103, align 4
  br label %cond.end.136

cond.false.104:                                   ; preds = %cond.true.99
  %73 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix = getelementptr inbounds %struct.window, %struct.window* %73, i32 0, i32 24
  %74 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix, align 8
  %tobool105 = icmp ne %struct.glyph_matrix* %74, null
  br i1 %tobool105, label %land.lhs.true.106, label %cond.false.114

land.lhs.true.106:                                ; preds = %cond.false.104
  %75 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix107 = getelementptr inbounds %struct.window, %struct.window* %75, i32 0, i32 24
  %76 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix107, align 8
  %rows = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %76, i32 0, i32 1
  %77 = load %struct.glyph_row*, %struct.glyph_row** %rows, align 8
  %tobool108 = icmp ne %struct.glyph_row* %77, null
  br i1 %tobool108, label %cond.true.109, label %cond.false.114

cond.true.109:                                    ; preds = %land.lhs.true.106
  %78 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix110 = getelementptr inbounds %struct.window, %struct.window* %78, i32 0, i32 24
  %79 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix110, align 8
  %rows111 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %79, i32 0, i32 1
  %80 = load %struct.glyph_row*, %struct.glyph_row** %rows111, align 8
  %height112 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %80, i32 0, i32 7
  %81 = load i32, i32* %height112, align 4
  %tobool113 = icmp ne i32 %81, 0
  br i1 %tobool113, label %cond.true.115, label %cond.false.129

cond.false.114:                                   ; preds = %land.lhs.true.106, %cond.false.104
  br i1 false, label %cond.true.115, label %cond.false.129

cond.true.115:                                    ; preds = %cond.false.114, %cond.true.109
  %82 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix116 = getelementptr inbounds %struct.window, %struct.window* %82, i32 0, i32 24
  %83 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix116, align 8
  %tobool117 = icmp ne %struct.glyph_matrix* %83, null
  br i1 %tobool117, label %land.lhs.true.118, label %cond.false.126

land.lhs.true.118:                                ; preds = %cond.true.115
  %84 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix119 = getelementptr inbounds %struct.window, %struct.window* %84, i32 0, i32 24
  %85 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix119, align 8
  %rows120 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %85, i32 0, i32 1
  %86 = load %struct.glyph_row*, %struct.glyph_row** %rows120, align 8
  %tobool121 = icmp ne %struct.glyph_row* %86, null
  br i1 %tobool121, label %cond.true.122, label %cond.false.126

cond.true.122:                                    ; preds = %land.lhs.true.118
  %87 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix123 = getelementptr inbounds %struct.window, %struct.window* %87, i32 0, i32 24
  %88 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix123, align 8
  %rows124 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %88, i32 0, i32 1
  %89 = load %struct.glyph_row*, %struct.glyph_row** %rows124, align 8
  %height125 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %89, i32 0, i32 7
  %90 = load i32, i32* %height125, align 4
  br label %cond.end.127

cond.false.126:                                   ; preds = %land.lhs.true.118, %cond.true.115
  br label %cond.end.127

cond.end.127:                                     ; preds = %cond.false.126, %cond.true.122
  %cond128 = phi i32 [ %90, %cond.true.122 ], [ 0, %cond.false.126 ]
  br label %cond.end.133

cond.false.129:                                   ; preds = %cond.false.114, %cond.true.109
  %91 = load %struct.window*, %struct.window** %w, align 8
  %frame130 = getelementptr inbounds %struct.window, %struct.window* %91, i32 0, i32 1
  %92 = load i64, i64* %frame130, align 8
  %sub131 = sub nsw i64 %92, 5
  %93 = inttoptr i64 %sub131 to i8*
  %94 = bitcast i8* %93 to %struct.frame*
  %call132 = call i32 @estimate_mode_line_height(%struct.frame* %94, i32 5)
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.false.129, %cond.end.127
  %cond134 = phi i32 [ %cond128, %cond.end.127 ], [ %call132, %cond.false.129 ]
  %95 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height135 = getelementptr inbounds %struct.window, %struct.window* %95, i32 0, i32 64
  store i32 %cond134, i32* %header_line_height135, align 4
  br label %cond.end.136

cond.end.136:                                     ; preds = %cond.end.133, %cond.true.102
  %cond137 = phi i32 [ %72, %cond.true.102 ], [ %cond134, %cond.end.133 ]
  br label %cond.end.139

cond.false.138:                                   ; preds = %cond.false.98, %cond.end.94, %land.lhs.true.43, %land.lhs.true.35, %land.lhs.true, %cond.true.31
  br label %cond.end.139

cond.end.139:                                     ; preds = %cond.false.138, %cond.end.136
  %cond140 = phi i32 [ %cond137, %cond.end.136 ], [ 0, %cond.false.138 ]
  %sub141 = sub nsw i32 %25, %cond140
  store i32 %sub141, i32* %yret, align 4
  br label %if.end.859

if.else:                                          ; preds = %if.then
  %96 = load i32, i32* %part, align 4
  %cmp142 = icmp eq i32 %96, 2
  br i1 %cmp142, label %if.then.146, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %97 = load i32, i32* %part, align 4
  %cmp144 = icmp eq i32 %97, 4
  br i1 %cmp144, label %if.then.146, label %if.else.160

if.then.146:                                      ; preds = %lor.lhs.false, %if.else
  %98 = load i32, i32* %part, align 4
  %cmp147 = icmp eq i32 %98, 2
  br i1 %cmp147, label %cond.true.149, label %cond.false.151

cond.true.149:                                    ; preds = %if.then.146
  %call150 = call i64 @builtin_lisp_symbol(i32 672)
  br label %cond.end.153

cond.false.151:                                   ; preds = %if.then.146
  %call152 = call i64 @builtin_lisp_symbol(i32 513)
  br label %cond.end.153

cond.end.153:                                     ; preds = %cond.false.151, %cond.true.149
  %cond154 = phi i64 [ %call150, %cond.true.149 ], [ %call152, %cond.false.151 ]
  store i64 %cond154, i64* %posn, align 8
  %99 = load i32, i32* %wx, align 4
  store i32 %99, i32* %col, align 4
  %100 = load i32, i32* %wy, align 4
  store i32 %100, i32* %row, align 4
  %101 = load %struct.window*, %struct.window** %w, align 8
  %102 = load i32, i32* %part, align 4
  %call155 = call i64 @mode_line_string(%struct.window* %101, i32 %102, i32* %col, i32* %row, i64* %charpos, i64* %object, i32* %dx, i32* %dy, i32* %width, i32* %height)
  store i64 %call155, i64* %string, align 8
  %103 = load i64, i64* %string, align 8
  %call156 = call zeroext i1 @STRINGP(i64 %103)
  br i1 %call156, label %if.then.157, label %if.end

if.then.157:                                      ; preds = %cond.end.153
  %104 = load i64, i64* %string, align 8
  %105 = load i64, i64* %charpos, align 8
  %shl = shl i64 %105, 2
  %add158 = add i64 %shl, 2
  %call159 = call i64 @Fcons(i64 %104, i64 %add158)
  store i64 %call159, i64* %string_info, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.157, %cond.end.153
  store i64 -1, i64* %textpos, align 8
  %106 = load i32, i32* %wx, align 4
  store i32 %106, i32* %xret, align 4
  %107 = load i32, i32* %wy, align 4
  store i32 %107, i32* %yret, align 4
  br label %if.end.858

if.else.160:                                      ; preds = %lor.lhs.false
  %108 = load i32, i32* %part, align 4
  %cmp161 = icmp eq i32 %108, 7
  br i1 %cmp161, label %if.then.166, label %lor.lhs.false.163

lor.lhs.false.163:                                ; preds = %if.else.160
  %109 = load i32, i32* %part, align 4
  %cmp164 = icmp eq i32 %109, 8
  br i1 %cmp164, label %if.then.166, label %if.else.314

if.then.166:                                      ; preds = %lor.lhs.false.163, %if.else.160
  %110 = load i32, i32* %part, align 4
  %cmp169 = icmp eq i32 %110, 7
  br i1 %cmp169, label %cond.true.171, label %cond.false.173

cond.true.171:                                    ; preds = %if.then.166
  %call172 = call i64 @builtin_lisp_symbol(i32 609)
  br label %cond.end.175

cond.false.173:                                   ; preds = %if.then.166
  %call174 = call i64 @builtin_lisp_symbol(i32 815)
  br label %cond.end.175

cond.end.175:                                     ; preds = %cond.false.173, %cond.true.171
  %cond176 = phi i64 [ %call172, %cond.true.171 ], [ %call174, %cond.false.173 ]
  store i64 %cond176, i64* %posn, align 8
  %111 = load i32, i32* %wx, align 4
  store i32 %111, i32* %col, align 4
  %112 = load i32, i32* %wy, align 4
  store i32 %112, i32* %row, align 4
  %113 = load %struct.window*, %struct.window** %w, align 8
  %114 = load i32, i32* %part, align 4
  %call177 = call i64 @marginal_area_string(%struct.window* %113, i32 %114, i32* %col, i32* %row, i64* %charpos168, i64* %object, i32* %dx, i32* %dy, i32* %width, i32* %height)
  store i64 %call177, i64* %string167, align 8
  %115 = load i64, i64* %string167, align 8
  %call178 = call zeroext i1 @STRINGP(i64 %115)
  br i1 %call178, label %if.then.179, label %if.end.183

if.then.179:                                      ; preds = %cond.end.175
  %116 = load i64, i64* %string167, align 8
  %117 = load i64, i64* %charpos168, align 8
  %shl180 = shl i64 %117, 2
  %add181 = add i64 %shl180, 2
  %call182 = call i64 @Fcons(i64 %116, i64 %add181)
  store i64 %call182, i64* %string_info, align 8
  br label %if.end.183

if.end.183:                                       ; preds = %if.then.179, %cond.end.175
  %118 = load i32, i32* %wx, align 4
  store i32 %118, i32* %xret, align 4
  %119 = load i32, i32* %wy, align 4
  %120 = load %struct.window*, %struct.window** %w, align 8
  %contents184 = getelementptr inbounds %struct.window, %struct.window* %120, i32 0, i32 10
  %121 = load i64, i64* %contents184, align 8
  %call185 = call zeroext i1 @BUFFERP(i64 %121)
  br i1 %call185, label %cond.true.187, label %cond.false.267

cond.true.187:                                    ; preds = %if.end.183
  %122 = load %struct.window*, %struct.window** %w, align 8
  %mini188 = getelementptr inbounds %struct.window, %struct.window* %122, i32 0, i32 67
  %bf.load189 = load i16, i16* %mini188, align 4
  %bf.clear190 = and i16 %bf.load189, 1
  %bf.cast191 = trunc i16 %bf.clear190 to i1
  br i1 %bf.cast191, label %cond.false.310, label %land.lhs.true.192

land.lhs.true.192:                                ; preds = %cond.true.187
  %123 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p193 = getelementptr inbounds %struct.window, %struct.window* %123, i32 0, i32 67
  %bf.load194 = load i16, i16* %pseudo_window_p193, align 4
  %bf.lshr195 = lshr i16 %bf.load194, 11
  %bf.clear196 = and i16 %bf.lshr195, 1
  %bf.cast197 = trunc i16 %bf.clear196 to i1
  br i1 %bf.cast197, label %cond.false.310, label %land.lhs.true.198

land.lhs.true.198:                                ; preds = %land.lhs.true.192
  %124 = load %struct.window*, %struct.window** %w, align 8
  %frame199 = getelementptr inbounds %struct.window, %struct.window* %124, i32 0, i32 1
  %125 = load i64, i64* %frame199, align 8
  %sub200 = sub nsw i64 %125, 5
  %126 = inttoptr i64 %sub200 to i8*
  %127 = bitcast i8* %126 to %struct.frame*
  %wants_modeline201 = getelementptr inbounds %struct.frame, %struct.frame* %127, i32 0, i32 26
  %128 = bitcast i48* %wants_modeline201 to i64*
  %bf.load202 = load i64, i64* %128, align 8
  %bf.lshr203 = lshr i64 %bf.load202, 14
  %bf.clear204 = and i64 %bf.lshr203, 1
  %bf.cast205 = trunc i64 %bf.clear204 to i1
  br i1 %bf.cast205, label %land.lhs.true.207, label %cond.false.310

land.lhs.true.207:                                ; preds = %land.lhs.true.198
  %129 = load %struct.window*, %struct.window** %w, align 8
  %contents208 = getelementptr inbounds %struct.window, %struct.window* %129, i32 0, i32 10
  %130 = load i64, i64* %contents208, align 8
  %call209 = call %struct.buffer* @XBUFFER(i64 %130)
  %header_line_format_210 = getelementptr inbounds %struct.buffer, %struct.buffer* %call209, i32 0, i32 13
  %131 = load i64, i64* %header_line_format_210, align 8
  %call211 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp212 = icmp eq i64 %131, %call211
  br i1 %cmp212, label %cond.false.310, label %land.lhs.true.214

land.lhs.true.214:                                ; preds = %land.lhs.true.207
  %132 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height215 = getelementptr inbounds %struct.window, %struct.window* %132, i32 0, i32 35
  %133 = load i32, i32* %pixel_height215, align 4
  %134 = load %struct.window*, %struct.window** %w, align 8
  %contents216 = getelementptr inbounds %struct.window, %struct.window* %134, i32 0, i32 10
  %135 = load i64, i64* %contents216, align 8
  %call217 = call zeroext i1 @BUFFERP(i64 %135)
  br i1 %call217, label %cond.true.219, label %cond.false.253

cond.true.219:                                    ; preds = %land.lhs.true.214
  %136 = load %struct.window*, %struct.window** %w, align 8
  %mini220 = getelementptr inbounds %struct.window, %struct.window* %136, i32 0, i32 67
  %bf.load221 = load i16, i16* %mini220, align 4
  %bf.clear222 = and i16 %bf.load221, 1
  %bf.cast223 = trunc i16 %bf.clear222 to i1
  br i1 %bf.cast223, label %cond.false.259, label %land.lhs.true.224

land.lhs.true.224:                                ; preds = %cond.true.219
  %137 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p225 = getelementptr inbounds %struct.window, %struct.window* %137, i32 0, i32 67
  %bf.load226 = load i16, i16* %pseudo_window_p225, align 4
  %bf.lshr227 = lshr i16 %bf.load226, 11
  %bf.clear228 = and i16 %bf.lshr227, 1
  %bf.cast229 = trunc i16 %bf.clear228 to i1
  br i1 %bf.cast229, label %cond.false.259, label %land.lhs.true.230

land.lhs.true.230:                                ; preds = %land.lhs.true.224
  %138 = load %struct.window*, %struct.window** %w, align 8
  %frame231 = getelementptr inbounds %struct.window, %struct.window* %138, i32 0, i32 1
  %139 = load i64, i64* %frame231, align 8
  %sub232 = sub nsw i64 %139, 5
  %140 = inttoptr i64 %sub232 to i8*
  %141 = bitcast i8* %140 to %struct.frame*
  %wants_modeline233 = getelementptr inbounds %struct.frame, %struct.frame* %141, i32 0, i32 26
  %142 = bitcast i48* %wants_modeline233 to i64*
  %bf.load234 = load i64, i64* %142, align 8
  %bf.lshr235 = lshr i64 %bf.load234, 14
  %bf.clear236 = and i64 %bf.lshr235, 1
  %bf.cast237 = trunc i64 %bf.clear236 to i1
  br i1 %bf.cast237, label %land.lhs.true.239, label %cond.false.259

land.lhs.true.239:                                ; preds = %land.lhs.true.230
  %143 = load %struct.window*, %struct.window** %w, align 8
  %contents240 = getelementptr inbounds %struct.window, %struct.window* %143, i32 0, i32 10
  %144 = load i64, i64* %contents240, align 8
  %call241 = call %struct.buffer* @XBUFFER(i64 %144)
  %mode_line_format_242 = getelementptr inbounds %struct.buffer, %struct.buffer* %call241, i32 0, i32 12
  %145 = load i64, i64* %mode_line_format_242, align 8
  %call243 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp244 = icmp eq i64 %145, %call243
  br i1 %cmp244, label %cond.false.259, label %land.lhs.true.246

land.lhs.true.246:                                ; preds = %land.lhs.true.239
  %146 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height247 = getelementptr inbounds %struct.window, %struct.window* %146, i32 0, i32 35
  %147 = load i32, i32* %pixel_height247, align 4
  %148 = load %struct.window*, %struct.window** %w, align 8
  %frame248 = getelementptr inbounds %struct.window, %struct.window* %148, i32 0, i32 1
  %149 = load i64, i64* %frame248, align 8
  %sub249 = sub nsw i64 %149, 5
  %150 = inttoptr i64 %sub249 to i8*
  %151 = bitcast i8* %150 to %struct.frame*
  %line_height250 = getelementptr inbounds %struct.frame, %struct.frame* %151, i32 0, i32 60
  %152 = load i32, i32* %line_height250, align 4
  %cmp251 = icmp sgt i32 %147, %152
  br i1 %cmp251, label %cond.true.254, label %cond.false.259

cond.false.253:                                   ; preds = %land.lhs.true.214
  br i1 false, label %cond.true.254, label %cond.false.259

cond.true.254:                                    ; preds = %cond.false.253, %land.lhs.true.246
  %153 = load %struct.window*, %struct.window** %w, align 8
  %frame255 = getelementptr inbounds %struct.window, %struct.window* %153, i32 0, i32 1
  %154 = load i64, i64* %frame255, align 8
  %sub256 = sub nsw i64 %154, 5
  %155 = inttoptr i64 %sub256 to i8*
  %156 = bitcast i8* %155 to %struct.frame*
  %line_height257 = getelementptr inbounds %struct.frame, %struct.frame* %156, i32 0, i32 60
  %157 = load i32, i32* %line_height257, align 4
  %mul258 = mul nsw i32 2, %157
  br label %cond.end.263

cond.false.259:                                   ; preds = %cond.false.253, %land.lhs.true.246, %land.lhs.true.239, %land.lhs.true.230, %land.lhs.true.224, %cond.true.219
  %158 = load %struct.window*, %struct.window** %w, align 8
  %frame260 = getelementptr inbounds %struct.window, %struct.window* %158, i32 0, i32 1
  %159 = load i64, i64* %frame260, align 8
  %sub261 = sub nsw i64 %159, 5
  %160 = inttoptr i64 %sub261 to i8*
  %161 = bitcast i8* %160 to %struct.frame*
  %line_height262 = getelementptr inbounds %struct.frame, %struct.frame* %161, i32 0, i32 60
  %162 = load i32, i32* %line_height262, align 4
  br label %cond.end.263

cond.end.263:                                     ; preds = %cond.false.259, %cond.true.254
  %cond264 = phi i32 [ %mul258, %cond.true.254 ], [ %162, %cond.false.259 ]
  %cmp265 = icmp sgt i32 %133, %cond264
  br i1 %cmp265, label %cond.true.268, label %cond.false.310

cond.false.267:                                   ; preds = %if.end.183
  br i1 false, label %cond.true.268, label %cond.false.310

cond.true.268:                                    ; preds = %cond.false.267, %cond.end.263
  %163 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height269 = getelementptr inbounds %struct.window, %struct.window* %163, i32 0, i32 64
  %164 = load i32, i32* %header_line_height269, align 4
  %cmp270 = icmp sge i32 %164, 0
  br i1 %cmp270, label %cond.true.272, label %cond.false.274

cond.true.272:                                    ; preds = %cond.true.268
  %165 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height273 = getelementptr inbounds %struct.window, %struct.window* %165, i32 0, i32 64
  %166 = load i32, i32* %header_line_height273, align 4
  br label %cond.end.308

cond.false.274:                                   ; preds = %cond.true.268
  %167 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix275 = getelementptr inbounds %struct.window, %struct.window* %167, i32 0, i32 24
  %168 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix275, align 8
  %tobool276 = icmp ne %struct.glyph_matrix* %168, null
  br i1 %tobool276, label %land.lhs.true.277, label %cond.false.286

land.lhs.true.277:                                ; preds = %cond.false.274
  %169 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix278 = getelementptr inbounds %struct.window, %struct.window* %169, i32 0, i32 24
  %170 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix278, align 8
  %rows279 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %170, i32 0, i32 1
  %171 = load %struct.glyph_row*, %struct.glyph_row** %rows279, align 8
  %tobool280 = icmp ne %struct.glyph_row* %171, null
  br i1 %tobool280, label %cond.true.281, label %cond.false.286

cond.true.281:                                    ; preds = %land.lhs.true.277
  %172 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix282 = getelementptr inbounds %struct.window, %struct.window* %172, i32 0, i32 24
  %173 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix282, align 8
  %rows283 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %173, i32 0, i32 1
  %174 = load %struct.glyph_row*, %struct.glyph_row** %rows283, align 8
  %height284 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %174, i32 0, i32 7
  %175 = load i32, i32* %height284, align 4
  %tobool285 = icmp ne i32 %175, 0
  br i1 %tobool285, label %cond.true.287, label %cond.false.301

cond.false.286:                                   ; preds = %land.lhs.true.277, %cond.false.274
  br i1 false, label %cond.true.287, label %cond.false.301

cond.true.287:                                    ; preds = %cond.false.286, %cond.true.281
  %176 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix288 = getelementptr inbounds %struct.window, %struct.window* %176, i32 0, i32 24
  %177 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix288, align 8
  %tobool289 = icmp ne %struct.glyph_matrix* %177, null
  br i1 %tobool289, label %land.lhs.true.290, label %cond.false.298

land.lhs.true.290:                                ; preds = %cond.true.287
  %178 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix291 = getelementptr inbounds %struct.window, %struct.window* %178, i32 0, i32 24
  %179 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix291, align 8
  %rows292 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %179, i32 0, i32 1
  %180 = load %struct.glyph_row*, %struct.glyph_row** %rows292, align 8
  %tobool293 = icmp ne %struct.glyph_row* %180, null
  br i1 %tobool293, label %cond.true.294, label %cond.false.298

cond.true.294:                                    ; preds = %land.lhs.true.290
  %181 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix295 = getelementptr inbounds %struct.window, %struct.window* %181, i32 0, i32 24
  %182 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix295, align 8
  %rows296 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %182, i32 0, i32 1
  %183 = load %struct.glyph_row*, %struct.glyph_row** %rows296, align 8
  %height297 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %183, i32 0, i32 7
  %184 = load i32, i32* %height297, align 4
  br label %cond.end.299

cond.false.298:                                   ; preds = %land.lhs.true.290, %cond.true.287
  br label %cond.end.299

cond.end.299:                                     ; preds = %cond.false.298, %cond.true.294
  %cond300 = phi i32 [ %184, %cond.true.294 ], [ 0, %cond.false.298 ]
  br label %cond.end.305

cond.false.301:                                   ; preds = %cond.false.286, %cond.true.281
  %185 = load %struct.window*, %struct.window** %w, align 8
  %frame302 = getelementptr inbounds %struct.window, %struct.window* %185, i32 0, i32 1
  %186 = load i64, i64* %frame302, align 8
  %sub303 = sub nsw i64 %186, 5
  %187 = inttoptr i64 %sub303 to i8*
  %188 = bitcast i8* %187 to %struct.frame*
  %call304 = call i32 @estimate_mode_line_height(%struct.frame* %188, i32 5)
  br label %cond.end.305

cond.end.305:                                     ; preds = %cond.false.301, %cond.end.299
  %cond306 = phi i32 [ %cond300, %cond.end.299 ], [ %call304, %cond.false.301 ]
  %189 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height307 = getelementptr inbounds %struct.window, %struct.window* %189, i32 0, i32 64
  store i32 %cond306, i32* %header_line_height307, align 4
  br label %cond.end.308

cond.end.308:                                     ; preds = %cond.end.305, %cond.true.272
  %cond309 = phi i32 [ %166, %cond.true.272 ], [ %cond306, %cond.end.305 ]
  br label %cond.end.311

cond.false.310:                                   ; preds = %cond.false.267, %cond.end.263, %land.lhs.true.207, %land.lhs.true.198, %land.lhs.true.192, %cond.true.187
  br label %cond.end.311

cond.end.311:                                     ; preds = %cond.false.310, %cond.end.308
  %cond312 = phi i32 [ %cond309, %cond.end.308 ], [ 0, %cond.false.310 ]
  %sub313 = sub nsw i32 %119, %cond312
  store i32 %sub313, i32* %yret, align 4
  br label %if.end.857

if.else.314:                                      ; preds = %lor.lhs.false.163
  %190 = load i32, i32* %part, align 4
  %cmp315 = icmp eq i32 %190, 5
  br i1 %cmp315, label %if.then.317, label %if.else.460

if.then.317:                                      ; preds = %if.else.314
  %call318 = call i64 @builtin_lisp_symbol(i32 608)
  store i64 %call318, i64* %posn, align 8
  store i32 0, i32* %col, align 4
  %191 = load i32, i32* %wx, align 4
  store i32 %191, i32* %xret, align 4
  %192 = load i32, i32* %wx, align 4
  %193 = load %struct.window*, %struct.window** %w, align 8
  %fringes_outside_margins = getelementptr inbounds %struct.window, %struct.window* %193, i32 0, i32 67
  %bf.load319 = load i16, i16* %fringes_outside_margins, align 4
  %bf.lshr320 = lshr i16 %bf.load319, 12
  %bf.clear321 = and i16 %bf.lshr320, 1
  %bf.cast322 = trunc i16 %bf.clear321 to i1
  br i1 %bf.cast322, label %cond.true.324, label %cond.false.325

cond.true.324:                                    ; preds = %if.then.317
  br label %cond.end.327

cond.false.325:                                   ; preds = %if.then.317
  %194 = load %struct.window*, %struct.window** %w, align 8
  %call326 = call i32 @window_box_width(%struct.window* %194, i32 0)
  br label %cond.end.327

cond.end.327:                                     ; preds = %cond.false.325, %cond.true.324
  %cond328 = phi i32 [ 0, %cond.true.324 ], [ %call326, %cond.false.325 ]
  %sub329 = sub nsw i32 %192, %cond328
  store i32 %sub329, i32* %dx, align 4
  %195 = load i32, i32* %wy, align 4
  %196 = load %struct.window*, %struct.window** %w, align 8
  %contents330 = getelementptr inbounds %struct.window, %struct.window* %196, i32 0, i32 10
  %197 = load i64, i64* %contents330, align 8
  %call331 = call zeroext i1 @BUFFERP(i64 %197)
  br i1 %call331, label %cond.true.333, label %cond.false.413

cond.true.333:                                    ; preds = %cond.end.327
  %198 = load %struct.window*, %struct.window** %w, align 8
  %mini334 = getelementptr inbounds %struct.window, %struct.window* %198, i32 0, i32 67
  %bf.load335 = load i16, i16* %mini334, align 4
  %bf.clear336 = and i16 %bf.load335, 1
  %bf.cast337 = trunc i16 %bf.clear336 to i1
  br i1 %bf.cast337, label %cond.false.456, label %land.lhs.true.338

land.lhs.true.338:                                ; preds = %cond.true.333
  %199 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p339 = getelementptr inbounds %struct.window, %struct.window* %199, i32 0, i32 67
  %bf.load340 = load i16, i16* %pseudo_window_p339, align 4
  %bf.lshr341 = lshr i16 %bf.load340, 11
  %bf.clear342 = and i16 %bf.lshr341, 1
  %bf.cast343 = trunc i16 %bf.clear342 to i1
  br i1 %bf.cast343, label %cond.false.456, label %land.lhs.true.344

land.lhs.true.344:                                ; preds = %land.lhs.true.338
  %200 = load %struct.window*, %struct.window** %w, align 8
  %frame345 = getelementptr inbounds %struct.window, %struct.window* %200, i32 0, i32 1
  %201 = load i64, i64* %frame345, align 8
  %sub346 = sub nsw i64 %201, 5
  %202 = inttoptr i64 %sub346 to i8*
  %203 = bitcast i8* %202 to %struct.frame*
  %wants_modeline347 = getelementptr inbounds %struct.frame, %struct.frame* %203, i32 0, i32 26
  %204 = bitcast i48* %wants_modeline347 to i64*
  %bf.load348 = load i64, i64* %204, align 8
  %bf.lshr349 = lshr i64 %bf.load348, 14
  %bf.clear350 = and i64 %bf.lshr349, 1
  %bf.cast351 = trunc i64 %bf.clear350 to i1
  br i1 %bf.cast351, label %land.lhs.true.353, label %cond.false.456

land.lhs.true.353:                                ; preds = %land.lhs.true.344
  %205 = load %struct.window*, %struct.window** %w, align 8
  %contents354 = getelementptr inbounds %struct.window, %struct.window* %205, i32 0, i32 10
  %206 = load i64, i64* %contents354, align 8
  %call355 = call %struct.buffer* @XBUFFER(i64 %206)
  %header_line_format_356 = getelementptr inbounds %struct.buffer, %struct.buffer* %call355, i32 0, i32 13
  %207 = load i64, i64* %header_line_format_356, align 8
  %call357 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp358 = icmp eq i64 %207, %call357
  br i1 %cmp358, label %cond.false.456, label %land.lhs.true.360

land.lhs.true.360:                                ; preds = %land.lhs.true.353
  %208 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height361 = getelementptr inbounds %struct.window, %struct.window* %208, i32 0, i32 35
  %209 = load i32, i32* %pixel_height361, align 4
  %210 = load %struct.window*, %struct.window** %w, align 8
  %contents362 = getelementptr inbounds %struct.window, %struct.window* %210, i32 0, i32 10
  %211 = load i64, i64* %contents362, align 8
  %call363 = call zeroext i1 @BUFFERP(i64 %211)
  br i1 %call363, label %cond.true.365, label %cond.false.399

cond.true.365:                                    ; preds = %land.lhs.true.360
  %212 = load %struct.window*, %struct.window** %w, align 8
  %mini366 = getelementptr inbounds %struct.window, %struct.window* %212, i32 0, i32 67
  %bf.load367 = load i16, i16* %mini366, align 4
  %bf.clear368 = and i16 %bf.load367, 1
  %bf.cast369 = trunc i16 %bf.clear368 to i1
  br i1 %bf.cast369, label %cond.false.405, label %land.lhs.true.370

land.lhs.true.370:                                ; preds = %cond.true.365
  %213 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p371 = getelementptr inbounds %struct.window, %struct.window* %213, i32 0, i32 67
  %bf.load372 = load i16, i16* %pseudo_window_p371, align 4
  %bf.lshr373 = lshr i16 %bf.load372, 11
  %bf.clear374 = and i16 %bf.lshr373, 1
  %bf.cast375 = trunc i16 %bf.clear374 to i1
  br i1 %bf.cast375, label %cond.false.405, label %land.lhs.true.376

land.lhs.true.376:                                ; preds = %land.lhs.true.370
  %214 = load %struct.window*, %struct.window** %w, align 8
  %frame377 = getelementptr inbounds %struct.window, %struct.window* %214, i32 0, i32 1
  %215 = load i64, i64* %frame377, align 8
  %sub378 = sub nsw i64 %215, 5
  %216 = inttoptr i64 %sub378 to i8*
  %217 = bitcast i8* %216 to %struct.frame*
  %wants_modeline379 = getelementptr inbounds %struct.frame, %struct.frame* %217, i32 0, i32 26
  %218 = bitcast i48* %wants_modeline379 to i64*
  %bf.load380 = load i64, i64* %218, align 8
  %bf.lshr381 = lshr i64 %bf.load380, 14
  %bf.clear382 = and i64 %bf.lshr381, 1
  %bf.cast383 = trunc i64 %bf.clear382 to i1
  br i1 %bf.cast383, label %land.lhs.true.385, label %cond.false.405

land.lhs.true.385:                                ; preds = %land.lhs.true.376
  %219 = load %struct.window*, %struct.window** %w, align 8
  %contents386 = getelementptr inbounds %struct.window, %struct.window* %219, i32 0, i32 10
  %220 = load i64, i64* %contents386, align 8
  %call387 = call %struct.buffer* @XBUFFER(i64 %220)
  %mode_line_format_388 = getelementptr inbounds %struct.buffer, %struct.buffer* %call387, i32 0, i32 12
  %221 = load i64, i64* %mode_line_format_388, align 8
  %call389 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp390 = icmp eq i64 %221, %call389
  br i1 %cmp390, label %cond.false.405, label %land.lhs.true.392

land.lhs.true.392:                                ; preds = %land.lhs.true.385
  %222 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height393 = getelementptr inbounds %struct.window, %struct.window* %222, i32 0, i32 35
  %223 = load i32, i32* %pixel_height393, align 4
  %224 = load %struct.window*, %struct.window** %w, align 8
  %frame394 = getelementptr inbounds %struct.window, %struct.window* %224, i32 0, i32 1
  %225 = load i64, i64* %frame394, align 8
  %sub395 = sub nsw i64 %225, 5
  %226 = inttoptr i64 %sub395 to i8*
  %227 = bitcast i8* %226 to %struct.frame*
  %line_height396 = getelementptr inbounds %struct.frame, %struct.frame* %227, i32 0, i32 60
  %228 = load i32, i32* %line_height396, align 4
  %cmp397 = icmp sgt i32 %223, %228
  br i1 %cmp397, label %cond.true.400, label %cond.false.405

cond.false.399:                                   ; preds = %land.lhs.true.360
  br i1 false, label %cond.true.400, label %cond.false.405

cond.true.400:                                    ; preds = %cond.false.399, %land.lhs.true.392
  %229 = load %struct.window*, %struct.window** %w, align 8
  %frame401 = getelementptr inbounds %struct.window, %struct.window* %229, i32 0, i32 1
  %230 = load i64, i64* %frame401, align 8
  %sub402 = sub nsw i64 %230, 5
  %231 = inttoptr i64 %sub402 to i8*
  %232 = bitcast i8* %231 to %struct.frame*
  %line_height403 = getelementptr inbounds %struct.frame, %struct.frame* %232, i32 0, i32 60
  %233 = load i32, i32* %line_height403, align 4
  %mul404 = mul nsw i32 2, %233
  br label %cond.end.409

cond.false.405:                                   ; preds = %cond.false.399, %land.lhs.true.392, %land.lhs.true.385, %land.lhs.true.376, %land.lhs.true.370, %cond.true.365
  %234 = load %struct.window*, %struct.window** %w, align 8
  %frame406 = getelementptr inbounds %struct.window, %struct.window* %234, i32 0, i32 1
  %235 = load i64, i64* %frame406, align 8
  %sub407 = sub nsw i64 %235, 5
  %236 = inttoptr i64 %sub407 to i8*
  %237 = bitcast i8* %236 to %struct.frame*
  %line_height408 = getelementptr inbounds %struct.frame, %struct.frame* %237, i32 0, i32 60
  %238 = load i32, i32* %line_height408, align 4
  br label %cond.end.409

cond.end.409:                                     ; preds = %cond.false.405, %cond.true.400
  %cond410 = phi i32 [ %mul404, %cond.true.400 ], [ %238, %cond.false.405 ]
  %cmp411 = icmp sgt i32 %209, %cond410
  br i1 %cmp411, label %cond.true.414, label %cond.false.456

cond.false.413:                                   ; preds = %cond.end.327
  br i1 false, label %cond.true.414, label %cond.false.456

cond.true.414:                                    ; preds = %cond.false.413, %cond.end.409
  %239 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height415 = getelementptr inbounds %struct.window, %struct.window* %239, i32 0, i32 64
  %240 = load i32, i32* %header_line_height415, align 4
  %cmp416 = icmp sge i32 %240, 0
  br i1 %cmp416, label %cond.true.418, label %cond.false.420

cond.true.418:                                    ; preds = %cond.true.414
  %241 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height419 = getelementptr inbounds %struct.window, %struct.window* %241, i32 0, i32 64
  %242 = load i32, i32* %header_line_height419, align 4
  br label %cond.end.454

cond.false.420:                                   ; preds = %cond.true.414
  %243 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix421 = getelementptr inbounds %struct.window, %struct.window* %243, i32 0, i32 24
  %244 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix421, align 8
  %tobool422 = icmp ne %struct.glyph_matrix* %244, null
  br i1 %tobool422, label %land.lhs.true.423, label %cond.false.432

land.lhs.true.423:                                ; preds = %cond.false.420
  %245 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix424 = getelementptr inbounds %struct.window, %struct.window* %245, i32 0, i32 24
  %246 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix424, align 8
  %rows425 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %246, i32 0, i32 1
  %247 = load %struct.glyph_row*, %struct.glyph_row** %rows425, align 8
  %tobool426 = icmp ne %struct.glyph_row* %247, null
  br i1 %tobool426, label %cond.true.427, label %cond.false.432

cond.true.427:                                    ; preds = %land.lhs.true.423
  %248 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix428 = getelementptr inbounds %struct.window, %struct.window* %248, i32 0, i32 24
  %249 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix428, align 8
  %rows429 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %249, i32 0, i32 1
  %250 = load %struct.glyph_row*, %struct.glyph_row** %rows429, align 8
  %height430 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %250, i32 0, i32 7
  %251 = load i32, i32* %height430, align 4
  %tobool431 = icmp ne i32 %251, 0
  br i1 %tobool431, label %cond.true.433, label %cond.false.447

cond.false.432:                                   ; preds = %land.lhs.true.423, %cond.false.420
  br i1 false, label %cond.true.433, label %cond.false.447

cond.true.433:                                    ; preds = %cond.false.432, %cond.true.427
  %252 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix434 = getelementptr inbounds %struct.window, %struct.window* %252, i32 0, i32 24
  %253 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix434, align 8
  %tobool435 = icmp ne %struct.glyph_matrix* %253, null
  br i1 %tobool435, label %land.lhs.true.436, label %cond.false.444

land.lhs.true.436:                                ; preds = %cond.true.433
  %254 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix437 = getelementptr inbounds %struct.window, %struct.window* %254, i32 0, i32 24
  %255 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix437, align 8
  %rows438 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %255, i32 0, i32 1
  %256 = load %struct.glyph_row*, %struct.glyph_row** %rows438, align 8
  %tobool439 = icmp ne %struct.glyph_row* %256, null
  br i1 %tobool439, label %cond.true.440, label %cond.false.444

cond.true.440:                                    ; preds = %land.lhs.true.436
  %257 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix441 = getelementptr inbounds %struct.window, %struct.window* %257, i32 0, i32 24
  %258 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix441, align 8
  %rows442 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %258, i32 0, i32 1
  %259 = load %struct.glyph_row*, %struct.glyph_row** %rows442, align 8
  %height443 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %259, i32 0, i32 7
  %260 = load i32, i32* %height443, align 4
  br label %cond.end.445

cond.false.444:                                   ; preds = %land.lhs.true.436, %cond.true.433
  br label %cond.end.445

cond.end.445:                                     ; preds = %cond.false.444, %cond.true.440
  %cond446 = phi i32 [ %260, %cond.true.440 ], [ 0, %cond.false.444 ]
  br label %cond.end.451

cond.false.447:                                   ; preds = %cond.false.432, %cond.true.427
  %261 = load %struct.window*, %struct.window** %w, align 8
  %frame448 = getelementptr inbounds %struct.window, %struct.window* %261, i32 0, i32 1
  %262 = load i64, i64* %frame448, align 8
  %sub449 = sub nsw i64 %262, 5
  %263 = inttoptr i64 %sub449 to i8*
  %264 = bitcast i8* %263 to %struct.frame*
  %call450 = call i32 @estimate_mode_line_height(%struct.frame* %264, i32 5)
  br label %cond.end.451

cond.end.451:                                     ; preds = %cond.false.447, %cond.end.445
  %cond452 = phi i32 [ %cond446, %cond.end.445 ], [ %call450, %cond.false.447 ]
  %265 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height453 = getelementptr inbounds %struct.window, %struct.window* %265, i32 0, i32 64
  store i32 %cond452, i32* %header_line_height453, align 4
  br label %cond.end.454

cond.end.454:                                     ; preds = %cond.end.451, %cond.true.418
  %cond455 = phi i32 [ %242, %cond.true.418 ], [ %cond452, %cond.end.451 ]
  br label %cond.end.457

cond.false.456:                                   ; preds = %cond.false.413, %cond.end.409, %land.lhs.true.353, %land.lhs.true.344, %land.lhs.true.338, %cond.true.333
  br label %cond.end.457

cond.end.457:                                     ; preds = %cond.false.456, %cond.end.454
  %cond458 = phi i32 [ %cond455, %cond.end.454 ], [ 0, %cond.false.456 ]
  %sub459 = sub nsw i32 %195, %cond458
  store i32 %sub459, i32* %yret, align 4
  store i32 %sub459, i32* %dy, align 4
  br label %if.end.856

if.else.460:                                      ; preds = %if.else.314
  %266 = load i32, i32* %part, align 4
  %cmp461 = icmp eq i32 %266, 6
  br i1 %cmp461, label %if.then.463, label %if.else.611

if.then.463:                                      ; preds = %if.else.460
  %call464 = call i64 @builtin_lisp_symbol(i32 814)
  store i64 %call464, i64* %posn, align 8
  store i32 0, i32* %col, align 4
  %267 = load i32, i32* %wx, align 4
  store i32 %267, i32* %xret, align 4
  %268 = load i32, i32* %wx, align 4
  %269 = load %struct.window*, %struct.window** %w, align 8
  %call465 = call i32 @window_box_width(%struct.window* %269, i32 0)
  %sub466 = sub nsw i32 %268, %call465
  %270 = load %struct.window*, %struct.window** %w, align 8
  %call467 = call i32 @window_box_width(%struct.window* %270, i32 1)
  %sub468 = sub nsw i32 %sub466, %call467
  %271 = load %struct.window*, %struct.window** %w, align 8
  %fringes_outside_margins469 = getelementptr inbounds %struct.window, %struct.window* %271, i32 0, i32 67
  %bf.load470 = load i16, i16* %fringes_outside_margins469, align 4
  %bf.lshr471 = lshr i16 %bf.load470, 12
  %bf.clear472 = and i16 %bf.lshr471, 1
  %bf.cast473 = trunc i16 %bf.clear472 to i1
  br i1 %bf.cast473, label %cond.true.475, label %cond.false.477

cond.true.475:                                    ; preds = %if.then.463
  %272 = load %struct.window*, %struct.window** %w, align 8
  %call476 = call i32 @window_box_width(%struct.window* %272, i32 2)
  br label %cond.end.478

cond.false.477:                                   ; preds = %if.then.463
  br label %cond.end.478

cond.end.478:                                     ; preds = %cond.false.477, %cond.true.475
  %cond479 = phi i32 [ %call476, %cond.true.475 ], [ 0, %cond.false.477 ]
  %sub480 = sub nsw i32 %sub468, %cond479
  store i32 %sub480, i32* %dx, align 4
  %273 = load i32, i32* %wy, align 4
  %274 = load %struct.window*, %struct.window** %w, align 8
  %contents481 = getelementptr inbounds %struct.window, %struct.window* %274, i32 0, i32 10
  %275 = load i64, i64* %contents481, align 8
  %call482 = call zeroext i1 @BUFFERP(i64 %275)
  br i1 %call482, label %cond.true.484, label %cond.false.564

cond.true.484:                                    ; preds = %cond.end.478
  %276 = load %struct.window*, %struct.window** %w, align 8
  %mini485 = getelementptr inbounds %struct.window, %struct.window* %276, i32 0, i32 67
  %bf.load486 = load i16, i16* %mini485, align 4
  %bf.clear487 = and i16 %bf.load486, 1
  %bf.cast488 = trunc i16 %bf.clear487 to i1
  br i1 %bf.cast488, label %cond.false.607, label %land.lhs.true.489

land.lhs.true.489:                                ; preds = %cond.true.484
  %277 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p490 = getelementptr inbounds %struct.window, %struct.window* %277, i32 0, i32 67
  %bf.load491 = load i16, i16* %pseudo_window_p490, align 4
  %bf.lshr492 = lshr i16 %bf.load491, 11
  %bf.clear493 = and i16 %bf.lshr492, 1
  %bf.cast494 = trunc i16 %bf.clear493 to i1
  br i1 %bf.cast494, label %cond.false.607, label %land.lhs.true.495

land.lhs.true.495:                                ; preds = %land.lhs.true.489
  %278 = load %struct.window*, %struct.window** %w, align 8
  %frame496 = getelementptr inbounds %struct.window, %struct.window* %278, i32 0, i32 1
  %279 = load i64, i64* %frame496, align 8
  %sub497 = sub nsw i64 %279, 5
  %280 = inttoptr i64 %sub497 to i8*
  %281 = bitcast i8* %280 to %struct.frame*
  %wants_modeline498 = getelementptr inbounds %struct.frame, %struct.frame* %281, i32 0, i32 26
  %282 = bitcast i48* %wants_modeline498 to i64*
  %bf.load499 = load i64, i64* %282, align 8
  %bf.lshr500 = lshr i64 %bf.load499, 14
  %bf.clear501 = and i64 %bf.lshr500, 1
  %bf.cast502 = trunc i64 %bf.clear501 to i1
  br i1 %bf.cast502, label %land.lhs.true.504, label %cond.false.607

land.lhs.true.504:                                ; preds = %land.lhs.true.495
  %283 = load %struct.window*, %struct.window** %w, align 8
  %contents505 = getelementptr inbounds %struct.window, %struct.window* %283, i32 0, i32 10
  %284 = load i64, i64* %contents505, align 8
  %call506 = call %struct.buffer* @XBUFFER(i64 %284)
  %header_line_format_507 = getelementptr inbounds %struct.buffer, %struct.buffer* %call506, i32 0, i32 13
  %285 = load i64, i64* %header_line_format_507, align 8
  %call508 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp509 = icmp eq i64 %285, %call508
  br i1 %cmp509, label %cond.false.607, label %land.lhs.true.511

land.lhs.true.511:                                ; preds = %land.lhs.true.504
  %286 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height512 = getelementptr inbounds %struct.window, %struct.window* %286, i32 0, i32 35
  %287 = load i32, i32* %pixel_height512, align 4
  %288 = load %struct.window*, %struct.window** %w, align 8
  %contents513 = getelementptr inbounds %struct.window, %struct.window* %288, i32 0, i32 10
  %289 = load i64, i64* %contents513, align 8
  %call514 = call zeroext i1 @BUFFERP(i64 %289)
  br i1 %call514, label %cond.true.516, label %cond.false.550

cond.true.516:                                    ; preds = %land.lhs.true.511
  %290 = load %struct.window*, %struct.window** %w, align 8
  %mini517 = getelementptr inbounds %struct.window, %struct.window* %290, i32 0, i32 67
  %bf.load518 = load i16, i16* %mini517, align 4
  %bf.clear519 = and i16 %bf.load518, 1
  %bf.cast520 = trunc i16 %bf.clear519 to i1
  br i1 %bf.cast520, label %cond.false.556, label %land.lhs.true.521

land.lhs.true.521:                                ; preds = %cond.true.516
  %291 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p522 = getelementptr inbounds %struct.window, %struct.window* %291, i32 0, i32 67
  %bf.load523 = load i16, i16* %pseudo_window_p522, align 4
  %bf.lshr524 = lshr i16 %bf.load523, 11
  %bf.clear525 = and i16 %bf.lshr524, 1
  %bf.cast526 = trunc i16 %bf.clear525 to i1
  br i1 %bf.cast526, label %cond.false.556, label %land.lhs.true.527

land.lhs.true.527:                                ; preds = %land.lhs.true.521
  %292 = load %struct.window*, %struct.window** %w, align 8
  %frame528 = getelementptr inbounds %struct.window, %struct.window* %292, i32 0, i32 1
  %293 = load i64, i64* %frame528, align 8
  %sub529 = sub nsw i64 %293, 5
  %294 = inttoptr i64 %sub529 to i8*
  %295 = bitcast i8* %294 to %struct.frame*
  %wants_modeline530 = getelementptr inbounds %struct.frame, %struct.frame* %295, i32 0, i32 26
  %296 = bitcast i48* %wants_modeline530 to i64*
  %bf.load531 = load i64, i64* %296, align 8
  %bf.lshr532 = lshr i64 %bf.load531, 14
  %bf.clear533 = and i64 %bf.lshr532, 1
  %bf.cast534 = trunc i64 %bf.clear533 to i1
  br i1 %bf.cast534, label %land.lhs.true.536, label %cond.false.556

land.lhs.true.536:                                ; preds = %land.lhs.true.527
  %297 = load %struct.window*, %struct.window** %w, align 8
  %contents537 = getelementptr inbounds %struct.window, %struct.window* %297, i32 0, i32 10
  %298 = load i64, i64* %contents537, align 8
  %call538 = call %struct.buffer* @XBUFFER(i64 %298)
  %mode_line_format_539 = getelementptr inbounds %struct.buffer, %struct.buffer* %call538, i32 0, i32 12
  %299 = load i64, i64* %mode_line_format_539, align 8
  %call540 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp541 = icmp eq i64 %299, %call540
  br i1 %cmp541, label %cond.false.556, label %land.lhs.true.543

land.lhs.true.543:                                ; preds = %land.lhs.true.536
  %300 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height544 = getelementptr inbounds %struct.window, %struct.window* %300, i32 0, i32 35
  %301 = load i32, i32* %pixel_height544, align 4
  %302 = load %struct.window*, %struct.window** %w, align 8
  %frame545 = getelementptr inbounds %struct.window, %struct.window* %302, i32 0, i32 1
  %303 = load i64, i64* %frame545, align 8
  %sub546 = sub nsw i64 %303, 5
  %304 = inttoptr i64 %sub546 to i8*
  %305 = bitcast i8* %304 to %struct.frame*
  %line_height547 = getelementptr inbounds %struct.frame, %struct.frame* %305, i32 0, i32 60
  %306 = load i32, i32* %line_height547, align 4
  %cmp548 = icmp sgt i32 %301, %306
  br i1 %cmp548, label %cond.true.551, label %cond.false.556

cond.false.550:                                   ; preds = %land.lhs.true.511
  br i1 false, label %cond.true.551, label %cond.false.556

cond.true.551:                                    ; preds = %cond.false.550, %land.lhs.true.543
  %307 = load %struct.window*, %struct.window** %w, align 8
  %frame552 = getelementptr inbounds %struct.window, %struct.window* %307, i32 0, i32 1
  %308 = load i64, i64* %frame552, align 8
  %sub553 = sub nsw i64 %308, 5
  %309 = inttoptr i64 %sub553 to i8*
  %310 = bitcast i8* %309 to %struct.frame*
  %line_height554 = getelementptr inbounds %struct.frame, %struct.frame* %310, i32 0, i32 60
  %311 = load i32, i32* %line_height554, align 4
  %mul555 = mul nsw i32 2, %311
  br label %cond.end.560

cond.false.556:                                   ; preds = %cond.false.550, %land.lhs.true.543, %land.lhs.true.536, %land.lhs.true.527, %land.lhs.true.521, %cond.true.516
  %312 = load %struct.window*, %struct.window** %w, align 8
  %frame557 = getelementptr inbounds %struct.window, %struct.window* %312, i32 0, i32 1
  %313 = load i64, i64* %frame557, align 8
  %sub558 = sub nsw i64 %313, 5
  %314 = inttoptr i64 %sub558 to i8*
  %315 = bitcast i8* %314 to %struct.frame*
  %line_height559 = getelementptr inbounds %struct.frame, %struct.frame* %315, i32 0, i32 60
  %316 = load i32, i32* %line_height559, align 4
  br label %cond.end.560

cond.end.560:                                     ; preds = %cond.false.556, %cond.true.551
  %cond561 = phi i32 [ %mul555, %cond.true.551 ], [ %316, %cond.false.556 ]
  %cmp562 = icmp sgt i32 %287, %cond561
  br i1 %cmp562, label %cond.true.565, label %cond.false.607

cond.false.564:                                   ; preds = %cond.end.478
  br i1 false, label %cond.true.565, label %cond.false.607

cond.true.565:                                    ; preds = %cond.false.564, %cond.end.560
  %317 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height566 = getelementptr inbounds %struct.window, %struct.window* %317, i32 0, i32 64
  %318 = load i32, i32* %header_line_height566, align 4
  %cmp567 = icmp sge i32 %318, 0
  br i1 %cmp567, label %cond.true.569, label %cond.false.571

cond.true.569:                                    ; preds = %cond.true.565
  %319 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height570 = getelementptr inbounds %struct.window, %struct.window* %319, i32 0, i32 64
  %320 = load i32, i32* %header_line_height570, align 4
  br label %cond.end.605

cond.false.571:                                   ; preds = %cond.true.565
  %321 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix572 = getelementptr inbounds %struct.window, %struct.window* %321, i32 0, i32 24
  %322 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix572, align 8
  %tobool573 = icmp ne %struct.glyph_matrix* %322, null
  br i1 %tobool573, label %land.lhs.true.574, label %cond.false.583

land.lhs.true.574:                                ; preds = %cond.false.571
  %323 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix575 = getelementptr inbounds %struct.window, %struct.window* %323, i32 0, i32 24
  %324 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix575, align 8
  %rows576 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %324, i32 0, i32 1
  %325 = load %struct.glyph_row*, %struct.glyph_row** %rows576, align 8
  %tobool577 = icmp ne %struct.glyph_row* %325, null
  br i1 %tobool577, label %cond.true.578, label %cond.false.583

cond.true.578:                                    ; preds = %land.lhs.true.574
  %326 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix579 = getelementptr inbounds %struct.window, %struct.window* %326, i32 0, i32 24
  %327 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix579, align 8
  %rows580 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %327, i32 0, i32 1
  %328 = load %struct.glyph_row*, %struct.glyph_row** %rows580, align 8
  %height581 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %328, i32 0, i32 7
  %329 = load i32, i32* %height581, align 4
  %tobool582 = icmp ne i32 %329, 0
  br i1 %tobool582, label %cond.true.584, label %cond.false.598

cond.false.583:                                   ; preds = %land.lhs.true.574, %cond.false.571
  br i1 false, label %cond.true.584, label %cond.false.598

cond.true.584:                                    ; preds = %cond.false.583, %cond.true.578
  %330 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix585 = getelementptr inbounds %struct.window, %struct.window* %330, i32 0, i32 24
  %331 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix585, align 8
  %tobool586 = icmp ne %struct.glyph_matrix* %331, null
  br i1 %tobool586, label %land.lhs.true.587, label %cond.false.595

land.lhs.true.587:                                ; preds = %cond.true.584
  %332 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix588 = getelementptr inbounds %struct.window, %struct.window* %332, i32 0, i32 24
  %333 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix588, align 8
  %rows589 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %333, i32 0, i32 1
  %334 = load %struct.glyph_row*, %struct.glyph_row** %rows589, align 8
  %tobool590 = icmp ne %struct.glyph_row* %334, null
  br i1 %tobool590, label %cond.true.591, label %cond.false.595

cond.true.591:                                    ; preds = %land.lhs.true.587
  %335 = load %struct.window*, %struct.window** %w, align 8
  %current_matrix592 = getelementptr inbounds %struct.window, %struct.window* %335, i32 0, i32 24
  %336 = load %struct.glyph_matrix*, %struct.glyph_matrix** %current_matrix592, align 8
  %rows593 = getelementptr inbounds %struct.glyph_matrix, %struct.glyph_matrix* %336, i32 0, i32 1
  %337 = load %struct.glyph_row*, %struct.glyph_row** %rows593, align 8
  %height594 = getelementptr inbounds %struct.glyph_row, %struct.glyph_row* %337, i32 0, i32 7
  %338 = load i32, i32* %height594, align 4
  br label %cond.end.596

cond.false.595:                                   ; preds = %land.lhs.true.587, %cond.true.584
  br label %cond.end.596

cond.end.596:                                     ; preds = %cond.false.595, %cond.true.591
  %cond597 = phi i32 [ %338, %cond.true.591 ], [ 0, %cond.false.595 ]
  br label %cond.end.602

cond.false.598:                                   ; preds = %cond.false.583, %cond.true.578
  %339 = load %struct.window*, %struct.window** %w, align 8
  %frame599 = getelementptr inbounds %struct.window, %struct.window* %339, i32 0, i32 1
  %340 = load i64, i64* %frame599, align 8
  %sub600 = sub nsw i64 %340, 5
  %341 = inttoptr i64 %sub600 to i8*
  %342 = bitcast i8* %341 to %struct.frame*
  %call601 = call i32 @estimate_mode_line_height(%struct.frame* %342, i32 5)
  br label %cond.end.602

cond.end.602:                                     ; preds = %cond.false.598, %cond.end.596
  %cond603 = phi i32 [ %cond597, %cond.end.596 ], [ %call601, %cond.false.598 ]
  %343 = load %struct.window*, %struct.window** %w, align 8
  %header_line_height604 = getelementptr inbounds %struct.window, %struct.window* %343, i32 0, i32 64
  store i32 %cond603, i32* %header_line_height604, align 4
  br label %cond.end.605

cond.end.605:                                     ; preds = %cond.end.602, %cond.true.569
  %cond606 = phi i32 [ %320, %cond.true.569 ], [ %cond603, %cond.end.602 ]
  br label %cond.end.608

cond.false.607:                                   ; preds = %cond.false.564, %cond.end.560, %land.lhs.true.504, %land.lhs.true.495, %land.lhs.true.489, %cond.true.484
  br label %cond.end.608

cond.end.608:                                     ; preds = %cond.false.607, %cond.end.605
  %cond609 = phi i32 [ %cond606, %cond.end.605 ], [ 0, %cond.false.607 ]
  %sub610 = sub nsw i32 %273, %cond609
  store i32 %sub610, i32* %yret, align 4
  store i32 %sub610, i32* %dy, align 4
  br label %if.end.855

if.else.611:                                      ; preds = %if.else.460
  %344 = load i32, i32* %part, align 4
  %cmp612 = icmp eq i32 %344, 3
  br i1 %cmp612, label %if.then.614, label %if.else.616

if.then.614:                                      ; preds = %if.else.611
  %call615 = call i64 @builtin_lisp_symbol(i32 1001)
  store i64 %call615, i64* %posn, align 8
  store i32 1, i32* %width, align 4
  store i32 0, i32* %dx, align 4
  %345 = load i32, i32* %wx, align 4
  store i32 %345, i32* %xret, align 4
  %346 = load i32, i32* %wy, align 4
  store i32 %346, i32* %yret, align 4
  store i32 %346, i32* %dy, align 4
  br label %if.end.854

if.else.616:                                      ; preds = %if.else.611
  %347 = load i32, i32* %part, align 4
  %cmp617 = icmp eq i32 %347, 9
  br i1 %cmp617, label %if.then.619, label %if.else.714

if.then.619:                                      ; preds = %if.else.616
  %call620 = call i64 @builtin_lisp_symbol(i32 1002)
  store i64 %call620, i64* %posn, align 8
  %348 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p621 = getelementptr inbounds %struct.window, %struct.window* %348, i32 0, i32 67
  %bf.load622 = load i16, i16* %pseudo_window_p621, align 4
  %bf.lshr623 = lshr i16 %bf.load622, 11
  %bf.clear624 = and i16 %bf.lshr623, 1
  %bf.cast625 = trunc i16 %bf.clear624 to i1
  br i1 %bf.cast625, label %cond.true.627, label %cond.false.628

cond.true.627:                                    ; preds = %if.then.619
  br label %cond.end.656

cond.false.628:                                   ; preds = %if.then.619
  %349 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type = getelementptr inbounds %struct.window, %struct.window* %349, i32 0, i32 16
  %350 = load i64, i64* %vertical_scroll_bar_type, align 8
  %call629 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp630 = icmp eq i64 %350, %call629
  br i1 %cmp630, label %cond.true.632, label %cond.false.640

cond.true.632:                                    ; preds = %cond.false.628
  %351 = load %struct.window*, %struct.window** %w, align 8
  %frame633 = getelementptr inbounds %struct.window, %struct.window* %351, i32 0, i32 1
  %352 = load i64, i64* %frame633, align 8
  %sub634 = sub nsw i64 %352, 5
  %353 = inttoptr i64 %sub634 to i8*
  %354 = bitcast i8* %353 to %struct.frame*
  %vertical_scroll_bar_type635 = getelementptr inbounds %struct.frame, %struct.frame* %354, i32 0, i32 26
  %355 = bitcast i48* %vertical_scroll_bar_type635 to i64*
  %bf.load636 = load i64, i64* %355, align 8
  %bf.lshr637 = lshr i64 %bf.load636, 30
  %bf.clear638 = and i64 %bf.lshr637, 3
  %bf.cast639 = trunc i64 %bf.clear638 to i32
  br label %cond.end.654

cond.false.640:                                   ; preds = %cond.false.628
  %356 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type641 = getelementptr inbounds %struct.window, %struct.window* %356, i32 0, i32 16
  %357 = load i64, i64* %vertical_scroll_bar_type641, align 8
  %call642 = call i64 @builtin_lisp_symbol(i32 607)
  %cmp643 = icmp eq i64 %357, %call642
  br i1 %cmp643, label %cond.true.645, label %cond.false.646

cond.true.645:                                    ; preds = %cond.false.640
  br label %cond.end.652

cond.false.646:                                   ; preds = %cond.false.640
  %358 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type647 = getelementptr inbounds %struct.window, %struct.window* %358, i32 0, i32 16
  %359 = load i64, i64* %vertical_scroll_bar_type647, align 8
  %call648 = call i64 @builtin_lisp_symbol(i32 811)
  %cmp649 = icmp eq i64 %359, %call648
  %cond651 = select i1 %cmp649, i32 2, i32 0
  br label %cond.end.652

cond.end.652:                                     ; preds = %cond.false.646, %cond.true.645
  %cond653 = phi i32 [ 1, %cond.true.645 ], [ %cond651, %cond.false.646 ]
  br label %cond.end.654

cond.end.654:                                     ; preds = %cond.end.652, %cond.true.632
  %cond655 = phi i32 [ %bf.cast639, %cond.true.632 ], [ %cond653, %cond.end.652 ]
  br label %cond.end.656

cond.end.656:                                     ; preds = %cond.end.654, %cond.true.627
  %cond657 = phi i32 [ 0, %cond.true.627 ], [ %cond655, %cond.end.654 ]
  %cmp658 = icmp eq i32 %cond657, 1
  br i1 %cmp658, label %cond.true.701, label %lor.lhs.false.660

lor.lhs.false.660:                                ; preds = %cond.end.656
  %360 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p661 = getelementptr inbounds %struct.window, %struct.window* %360, i32 0, i32 67
  %bf.load662 = load i16, i16* %pseudo_window_p661, align 4
  %bf.lshr663 = lshr i16 %bf.load662, 11
  %bf.clear664 = and i16 %bf.lshr663, 1
  %bf.cast665 = trunc i16 %bf.clear664 to i1
  br i1 %bf.cast665, label %cond.true.667, label %cond.false.668

cond.true.667:                                    ; preds = %lor.lhs.false.660
  br label %cond.end.697

cond.false.668:                                   ; preds = %lor.lhs.false.660
  %361 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type669 = getelementptr inbounds %struct.window, %struct.window* %361, i32 0, i32 16
  %362 = load i64, i64* %vertical_scroll_bar_type669, align 8
  %call670 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp671 = icmp eq i64 %362, %call670
  br i1 %cmp671, label %cond.true.673, label %cond.false.681

cond.true.673:                                    ; preds = %cond.false.668
  %363 = load %struct.window*, %struct.window** %w, align 8
  %frame674 = getelementptr inbounds %struct.window, %struct.window* %363, i32 0, i32 1
  %364 = load i64, i64* %frame674, align 8
  %sub675 = sub nsw i64 %364, 5
  %365 = inttoptr i64 %sub675 to i8*
  %366 = bitcast i8* %365 to %struct.frame*
  %vertical_scroll_bar_type676 = getelementptr inbounds %struct.frame, %struct.frame* %366, i32 0, i32 26
  %367 = bitcast i48* %vertical_scroll_bar_type676 to i64*
  %bf.load677 = load i64, i64* %367, align 8
  %bf.lshr678 = lshr i64 %bf.load677, 30
  %bf.clear679 = and i64 %bf.lshr678, 3
  %bf.cast680 = trunc i64 %bf.clear679 to i32
  br label %cond.end.695

cond.false.681:                                   ; preds = %cond.false.668
  %368 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type682 = getelementptr inbounds %struct.window, %struct.window* %368, i32 0, i32 16
  %369 = load i64, i64* %vertical_scroll_bar_type682, align 8
  %call683 = call i64 @builtin_lisp_symbol(i32 607)
  %cmp684 = icmp eq i64 %369, %call683
  br i1 %cmp684, label %cond.true.686, label %cond.false.687

cond.true.686:                                    ; preds = %cond.false.681
  br label %cond.end.693

cond.false.687:                                   ; preds = %cond.false.681
  %370 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type688 = getelementptr inbounds %struct.window, %struct.window* %370, i32 0, i32 16
  %371 = load i64, i64* %vertical_scroll_bar_type688, align 8
  %call689 = call i64 @builtin_lisp_symbol(i32 811)
  %cmp690 = icmp eq i64 %371, %call689
  %cond692 = select i1 %cmp690, i32 2, i32 0
  br label %cond.end.693

cond.end.693:                                     ; preds = %cond.false.687, %cond.true.686
  %cond694 = phi i32 [ 1, %cond.true.686 ], [ %cond692, %cond.false.687 ]
  br label %cond.end.695

cond.end.695:                                     ; preds = %cond.end.693, %cond.true.673
  %cond696 = phi i32 [ %bf.cast680, %cond.true.673 ], [ %cond694, %cond.end.693 ]
  br label %cond.end.697

cond.end.697:                                     ; preds = %cond.end.695, %cond.true.667
  %cond698 = phi i32 [ 0, %cond.true.667 ], [ %cond696, %cond.end.695 ]
  %cmp699 = icmp eq i32 %cond698, 2
  br i1 %cmp699, label %cond.true.701, label %cond.false.711

cond.true.701:                                    ; preds = %cond.end.697, %cond.end.656
  %372 = load %struct.window*, %struct.window** %w, align 8
  %scroll_bar_width = getelementptr inbounds %struct.window, %struct.window* %372, i32 0, i32 61
  %373 = load i32, i32* %scroll_bar_width, align 4
  %cmp702 = icmp sge i32 %373, 0
  br i1 %cmp702, label %cond.true.704, label %cond.false.706

cond.true.704:                                    ; preds = %cond.true.701
  %374 = load %struct.window*, %struct.window** %w, align 8
  %scroll_bar_width705 = getelementptr inbounds %struct.window, %struct.window* %374, i32 0, i32 61
  %375 = load i32, i32* %scroll_bar_width705, align 4
  br label %cond.end.709

cond.false.706:                                   ; preds = %cond.true.701
  %376 = load %struct.window*, %struct.window** %w, align 8
  %frame707 = getelementptr inbounds %struct.window, %struct.window* %376, i32 0, i32 1
  %377 = load i64, i64* %frame707, align 8
  %sub708 = sub nsw i64 %377, 5
  %378 = inttoptr i64 %sub708 to i8*
  %379 = bitcast i8* %378 to %struct.frame*
  %config_scroll_bar_width = getelementptr inbounds %struct.frame, %struct.frame* %379, i32 0, i32 69
  %380 = load i32, i32* %config_scroll_bar_width, align 4
  br label %cond.end.709

cond.end.709:                                     ; preds = %cond.false.706, %cond.true.704
  %cond710 = phi i32 [ %375, %cond.true.704 ], [ %380, %cond.false.706 ]
  br label %cond.end.712

cond.false.711:                                   ; preds = %cond.end.697
  br label %cond.end.712

cond.end.712:                                     ; preds = %cond.false.711, %cond.end.709
  %cond713 = phi i32 [ %cond710, %cond.end.709 ], [ 0, %cond.false.711 ]
  store i32 %cond713, i32* %width, align 4
  %381 = load i32, i32* %wx, align 4
  store i32 %381, i32* %xret, align 4
  store i32 %381, i32* %dx, align 4
  %382 = load i32, i32* %wy, align 4
  store i32 %382, i32* %yret, align 4
  store i32 %382, i32* %dy, align 4
  br label %if.end.853

if.else.714:                                      ; preds = %if.else.616
  %383 = load i32, i32* %part, align 4
  %cmp715 = icmp eq i32 %383, 10
  br i1 %cmp715, label %if.then.717, label %if.else.769

if.then.717:                                      ; preds = %if.else.714
  %call718 = call i64 @builtin_lisp_symbol(i32 524)
  store i64 %call718, i64* %posn, align 8
  %384 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p719 = getelementptr inbounds %struct.window, %struct.window* %384, i32 0, i32 67
  %bf.load720 = load i16, i16* %pseudo_window_p719, align 4
  %bf.lshr721 = lshr i16 %bf.load720, 11
  %bf.clear722 = and i16 %bf.lshr721, 1
  %bf.cast723 = trunc i16 %bf.clear722 to i1
  br i1 %bf.cast723, label %cond.true.736, label %lor.lhs.false.725

lor.lhs.false.725:                                ; preds = %if.then.717
  %385 = load %struct.window*, %struct.window** %w, align 8
  %mini726 = getelementptr inbounds %struct.window, %struct.window* %385, i32 0, i32 67
  %bf.load727 = load i16, i16* %mini726, align 4
  %bf.clear728 = and i16 %bf.load727, 1
  %bf.cast729 = trunc i16 %bf.clear728 to i1
  br i1 %bf.cast729, label %land.lhs.true.731, label %cond.false.737

land.lhs.true.731:                                ; preds = %lor.lhs.false.725
  %386 = load %struct.window*, %struct.window** %w, align 8
  %prev = getelementptr inbounds %struct.window, %struct.window* %386, i32 0, i32 3
  %387 = load i64, i64* %prev, align 8
  %388 = load %struct.window*, %struct.window** %w, align 8
  %frame732 = getelementptr inbounds %struct.window, %struct.window* %388, i32 0, i32 1
  %389 = load i64, i64* %frame732, align 8
  %sub733 = sub nsw i64 %389, 5
  %390 = inttoptr i64 %sub733 to i8*
  %391 = bitcast i8* %390 to %struct.frame*
  %root_window = getelementptr inbounds %struct.frame, %struct.frame* %391, i32 0, i32 5
  %392 = load i64, i64* %root_window, align 8
  %cmp734 = icmp eq i64 %387, %392
  br i1 %cmp734, label %cond.true.736, label %cond.false.737

cond.true.736:                                    ; preds = %land.lhs.true.731, %if.then.717
  br i1 false, label %cond.true.756, label %cond.false.766

cond.false.737:                                   ; preds = %land.lhs.true.731, %lor.lhs.false.725
  %393 = load %struct.window*, %struct.window** %w, align 8
  %horizontal_scroll_bar_type = getelementptr inbounds %struct.window, %struct.window* %393, i32 0, i32 18
  %394 = load i64, i64* %horizontal_scroll_bar_type, align 8
  %call738 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp739 = icmp eq i64 %394, %call738
  br i1 %cmp739, label %cond.true.741, label %cond.false.749

cond.true.741:                                    ; preds = %cond.false.737
  %395 = load %struct.window*, %struct.window** %w, align 8
  %frame742 = getelementptr inbounds %struct.window, %struct.window* %395, i32 0, i32 1
  %396 = load i64, i64* %frame742, align 8
  %sub743 = sub nsw i64 %396, 5
  %397 = inttoptr i64 %sub743 to i8*
  %398 = bitcast i8* %397 to %struct.frame*
  %horizontal_scroll_bars = getelementptr inbounds %struct.frame, %struct.frame* %398, i32 0, i32 26
  %399 = bitcast i48* %horizontal_scroll_bars to i64*
  %bf.load744 = load i64, i64* %399, align 8
  %bf.lshr745 = lshr i64 %bf.load744, 32
  %bf.clear746 = and i64 %bf.lshr745, 1
  %bf.cast747 = trunc i64 %bf.clear746 to i1
  br i1 %bf.cast747, label %cond.true.756, label %cond.false.766

cond.false.749:                                   ; preds = %cond.false.737
  %400 = load %struct.window*, %struct.window** %w, align 8
  %horizontal_scroll_bar_type750 = getelementptr inbounds %struct.window, %struct.window* %400, i32 0, i32 18
  %401 = load i64, i64* %horizontal_scroll_bar_type750, align 8
  %call751 = call i64 @builtin_lisp_symbol(i32 213)
  %cmp752 = icmp eq i64 %401, %call751
  br i1 %cmp752, label %cond.true.754, label %cond.false.755

cond.true.754:                                    ; preds = %cond.false.749
  br i1 true, label %cond.true.756, label %cond.false.766

cond.false.755:                                   ; preds = %cond.false.749
  br i1 false, label %cond.true.756, label %cond.false.766

cond.true.756:                                    ; preds = %cond.false.755, %cond.true.754, %cond.true.741, %cond.true.736
  %402 = load %struct.window*, %struct.window** %w, align 8
  %scroll_bar_height = getelementptr inbounds %struct.window, %struct.window* %402, i32 0, i32 62
  %403 = load i32, i32* %scroll_bar_height, align 4
  %cmp757 = icmp sge i32 %403, 0
  br i1 %cmp757, label %cond.true.759, label %cond.false.761

cond.true.759:                                    ; preds = %cond.true.756
  %404 = load %struct.window*, %struct.window** %w, align 8
  %scroll_bar_height760 = getelementptr inbounds %struct.window, %struct.window* %404, i32 0, i32 62
  %405 = load i32, i32* %scroll_bar_height760, align 4
  br label %cond.end.764

cond.false.761:                                   ; preds = %cond.true.756
  %406 = load %struct.window*, %struct.window** %w, align 8
  %frame762 = getelementptr inbounds %struct.window, %struct.window* %406, i32 0, i32 1
  %407 = load i64, i64* %frame762, align 8
  %sub763 = sub nsw i64 %407, 5
  %408 = inttoptr i64 %sub763 to i8*
  %409 = bitcast i8* %408 to %struct.frame*
  %config_scroll_bar_height = getelementptr inbounds %struct.frame, %struct.frame* %409, i32 0, i32 71
  %410 = load i32, i32* %config_scroll_bar_height, align 4
  br label %cond.end.764

cond.end.764:                                     ; preds = %cond.false.761, %cond.true.759
  %cond765 = phi i32 [ %405, %cond.true.759 ], [ %410, %cond.false.761 ]
  br label %cond.end.767

cond.false.766:                                   ; preds = %cond.false.755, %cond.true.754, %cond.true.741, %cond.true.736
  br label %cond.end.767

cond.end.767:                                     ; preds = %cond.false.766, %cond.end.764
  %cond768 = phi i32 [ %cond765, %cond.end.764 ], [ 0, %cond.false.766 ]
  store i32 %cond768, i32* %width, align 4
  %411 = load i32, i32* %wx, align 4
  store i32 %411, i32* %xret, align 4
  store i32 %411, i32* %dx, align 4
  %412 = load i32, i32* %wy, align 4
  store i32 %412, i32* %yret, align 4
  store i32 %412, i32* %dy, align 4
  br label %if.end.852

if.else.769:                                      ; preds = %if.else.714
  %413 = load i32, i32* %part, align 4
  %cmp770 = icmp eq i32 %413, 11
  br i1 %cmp770, label %if.then.772, label %if.else.801

if.then.772:                                      ; preds = %if.else.769
  %call773 = call i64 @builtin_lisp_symbol(i32 812)
  store i64 %call773, i64* %posn, align 8
  %414 = load %struct.window*, %struct.window** %w, align 8
  %pixel_left774 = getelementptr inbounds %struct.window, %struct.window* %414, i32 0, i32 30
  %415 = load i32, i32* %pixel_left774, align 4
  %416 = load %struct.window*, %struct.window** %w, align 8
  %pixel_width = getelementptr inbounds %struct.window, %struct.window* %416, i32 0, i32 34
  %417 = load i32, i32* %pixel_width, align 4
  %add775 = add nsw i32 %415, %417
  %418 = load %struct.window*, %struct.window** %w, align 8
  %frame776 = getelementptr inbounds %struct.window, %struct.window* %418, i32 0, i32 1
  %419 = load i64, i64* %frame776, align 8
  %sub777 = sub nsw i64 %419, 5
  %420 = inttoptr i64 %sub777 to i8*
  %421 = bitcast i8* %420 to %struct.frame*
  %root_window778 = getelementptr inbounds %struct.frame, %struct.frame* %421, i32 0, i32 5
  %422 = load i64, i64* %root_window778, align 8
  %call779 = call %struct.window* @XWINDOW(i64 %422)
  %pixel_left780 = getelementptr inbounds %struct.window, %struct.window* %call779, i32 0, i32 30
  %423 = load i32, i32* %pixel_left780, align 4
  %424 = load %struct.window*, %struct.window** %w, align 8
  %frame781 = getelementptr inbounds %struct.window, %struct.window* %424, i32 0, i32 1
  %425 = load i64, i64* %frame781, align 8
  %sub782 = sub nsw i64 %425, 5
  %426 = inttoptr i64 %sub782 to i8*
  %427 = bitcast i8* %426 to %struct.frame*
  %root_window783 = getelementptr inbounds %struct.frame, %struct.frame* %427, i32 0, i32 5
  %428 = load i64, i64* %root_window783, align 8
  %call784 = call %struct.window* @XWINDOW(i64 %428)
  %pixel_width785 = getelementptr inbounds %struct.window, %struct.window* %call784, i32 0, i32 34
  %429 = load i32, i32* %pixel_width785, align 4
  %add786 = add nsw i32 %423, %429
  %cmp787 = icmp eq i32 %add775, %add786
  br i1 %cmp787, label %cond.true.795, label %lor.lhs.false.789

lor.lhs.false.789:                                ; preds = %if.then.772
  %430 = load %struct.window*, %struct.window** %w, align 8
  %mini790 = getelementptr inbounds %struct.window, %struct.window* %430, i32 0, i32 67
  %bf.load791 = load i16, i16* %mini790, align 4
  %bf.clear792 = and i16 %bf.load791, 1
  %bf.cast793 = trunc i16 %bf.clear792 to i1
  br i1 %bf.cast793, label %cond.true.795, label %cond.false.796

cond.true.795:                                    ; preds = %lor.lhs.false.789, %if.then.772
  br label %cond.end.799

cond.false.796:                                   ; preds = %lor.lhs.false.789
  %431 = load %struct.window*, %struct.window** %w, align 8
  %frame797 = getelementptr inbounds %struct.window, %struct.window* %431, i32 0, i32 1
  %432 = load i64, i64* %frame797, align 8
  %sub798 = sub nsw i64 %432, 5
  %433 = inttoptr i64 %sub798 to i8*
  %434 = bitcast i8* %433 to %struct.frame*
  %right_divider_width = getelementptr inbounds %struct.frame, %struct.frame* %434, i32 0, i32 52
  %435 = load i32, i32* %right_divider_width, align 4
  br label %cond.end.799

cond.end.799:                                     ; preds = %cond.false.796, %cond.true.795
  %cond800 = phi i32 [ 0, %cond.true.795 ], [ %435, %cond.false.796 ]
  store i32 %cond800, i32* %width, align 4
  %436 = load i32, i32* %wx, align 4
  store i32 %436, i32* %xret, align 4
  store i32 %436, i32* %dx, align 4
  %437 = load i32, i32* %wy, align 4
  store i32 %437, i32* %yret, align 4
  store i32 %437, i32* %dy, align 4
  br label %if.end.851

if.else.801:                                      ; preds = %if.else.769
  %438 = load i32, i32* %part, align 4
  %cmp802 = icmp eq i32 %438, 12
  br i1 %cmp802, label %if.then.804, label %if.end.850

if.then.804:                                      ; preds = %if.else.801
  %call805 = call i64 @builtin_lisp_symbol(i32 214)
  store i64 %call805, i64* %posn, align 8
  %439 = load %struct.window*, %struct.window** %w, align 8
  %pixel_top806 = getelementptr inbounds %struct.window, %struct.window* %439, i32 0, i32 31
  %440 = load i32, i32* %pixel_top806, align 4
  %441 = load %struct.window*, %struct.window** %w, align 8
  %pixel_height807 = getelementptr inbounds %struct.window, %struct.window* %441, i32 0, i32 35
  %442 = load i32, i32* %pixel_height807, align 4
  %add808 = add nsw i32 %440, %442
  %443 = load %struct.window*, %struct.window** %w, align 8
  %frame809 = getelementptr inbounds %struct.window, %struct.window* %443, i32 0, i32 1
  %444 = load i64, i64* %frame809, align 8
  %sub810 = sub nsw i64 %444, 5
  %445 = inttoptr i64 %sub810 to i8*
  %446 = bitcast i8* %445 to %struct.frame*
  %root_window811 = getelementptr inbounds %struct.frame, %struct.frame* %446, i32 0, i32 5
  %447 = load i64, i64* %root_window811, align 8
  %call812 = call %struct.window* @XWINDOW(i64 %447)
  %pixel_top813 = getelementptr inbounds %struct.window, %struct.window* %call812, i32 0, i32 31
  %448 = load i32, i32* %pixel_top813, align 4
  %449 = load %struct.window*, %struct.window** %w, align 8
  %frame814 = getelementptr inbounds %struct.window, %struct.window* %449, i32 0, i32 1
  %450 = load i64, i64* %frame814, align 8
  %sub815 = sub nsw i64 %450, 5
  %451 = inttoptr i64 %sub815 to i8*
  %452 = bitcast i8* %451 to %struct.frame*
  %root_window816 = getelementptr inbounds %struct.frame, %struct.frame* %452, i32 0, i32 5
  %453 = load i64, i64* %root_window816, align 8
  %call817 = call %struct.window* @XWINDOW(i64 %453)
  %pixel_height818 = getelementptr inbounds %struct.window, %struct.window* %call817, i32 0, i32 35
  %454 = load i32, i32* %pixel_height818, align 4
  %add819 = add nsw i32 %448, %454
  %cmp820 = icmp eq i32 %add808, %add819
  br i1 %cmp820, label %land.lhs.true.822, label %lor.lhs.false.830

land.lhs.true.822:                                ; preds = %if.then.804
  %455 = load %struct.window*, %struct.window** %w, align 8
  %frame823 = getelementptr inbounds %struct.window, %struct.window* %455, i32 0, i32 1
  %456 = load i64, i64* %frame823, align 8
  %sub824 = sub nsw i64 %456, 5
  %457 = inttoptr i64 %sub824 to i8*
  %458 = bitcast i8* %457 to %struct.frame*
  %root_window825 = getelementptr inbounds %struct.frame, %struct.frame* %458, i32 0, i32 5
  %459 = load i64, i64* %root_window825, align 8
  %call826 = call %struct.window* @XWINDOW(i64 %459)
  %next = getelementptr inbounds %struct.window, %struct.window* %call826, i32 0, i32 2
  %460 = load i64, i64* %next, align 8
  %call827 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp828 = icmp eq i64 %460, %call827
  br i1 %cmp828, label %cond.true.844, label %lor.lhs.false.830

lor.lhs.false.830:                                ; preds = %land.lhs.true.822, %if.then.804
  %461 = load %struct.window*, %struct.window** %w, align 8
  %prev831 = getelementptr inbounds %struct.window, %struct.window* %461, i32 0, i32 3
  %462 = load i64, i64* %prev831, align 8
  %463 = load %struct.window*, %struct.window** %w, align 8
  %frame832 = getelementptr inbounds %struct.window, %struct.window* %463, i32 0, i32 1
  %464 = load i64, i64* %frame832, align 8
  %sub833 = sub nsw i64 %464, 5
  %465 = inttoptr i64 %sub833 to i8*
  %466 = bitcast i8* %465 to %struct.frame*
  %root_window834 = getelementptr inbounds %struct.frame, %struct.frame* %466, i32 0, i32 5
  %467 = load i64, i64* %root_window834, align 8
  %cmp835 = icmp eq i64 %462, %467
  br i1 %cmp835, label %cond.true.844, label %lor.lhs.false.837

lor.lhs.false.837:                                ; preds = %lor.lhs.false.830
  %468 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p838 = getelementptr inbounds %struct.window, %struct.window* %468, i32 0, i32 67
  %bf.load839 = load i16, i16* %pseudo_window_p838, align 4
  %bf.lshr840 = lshr i16 %bf.load839, 11
  %bf.clear841 = and i16 %bf.lshr840, 1
  %bf.cast842 = trunc i16 %bf.clear841 to i1
  br i1 %bf.cast842, label %cond.true.844, label %cond.false.845

cond.true.844:                                    ; preds = %lor.lhs.false.837, %lor.lhs.false.830, %land.lhs.true.822
  br label %cond.end.848

cond.false.845:                                   ; preds = %lor.lhs.false.837
  %469 = load %struct.window*, %struct.window** %w, align 8
  %frame846 = getelementptr inbounds %struct.window, %struct.window* %469, i32 0, i32 1
  %470 = load i64, i64* %frame846, align 8
  %sub847 = sub nsw i64 %470, 5
  %471 = inttoptr i64 %sub847 to i8*
  %472 = bitcast i8* %471 to %struct.frame*
  %bottom_divider_width = getelementptr inbounds %struct.frame, %struct.frame* %472, i32 0, i32 53
  %473 = load i32, i32* %bottom_divider_width, align 4
  br label %cond.end.848

cond.end.848:                                     ; preds = %cond.false.845, %cond.true.844
  %cond849 = phi i32 [ 0, %cond.true.844 ], [ %473, %cond.false.845 ]
  store i32 %cond849, i32* %width, align 4
  %474 = load i32, i32* %wx, align 4
  store i32 %474, i32* %xret, align 4
  store i32 %474, i32* %dx, align 4
  %475 = load i32, i32* %wy, align 4
  store i32 %475, i32* %yret, align 4
  store i32 %475, i32* %dy, align 4
  br label %if.end.850

if.end.850:                                       ; preds = %cond.end.848, %if.else.801
  br label %if.end.851

if.end.851:                                       ; preds = %if.end.850, %cond.end.799
  br label %if.end.852

if.end.852:                                       ; preds = %if.end.851, %cond.end.767
  br label %if.end.853

if.end.853:                                       ; preds = %if.end.852, %cond.end.712
  br label %if.end.854

if.end.854:                                       ; preds = %if.end.853, %if.then.614
  br label %if.end.855

if.end.855:                                       ; preds = %if.end.854, %cond.end.608
  br label %if.end.856

if.end.856:                                       ; preds = %if.end.855, %cond.end.457
  br label %if.end.857

if.end.857:                                       ; preds = %if.end.856, %cond.end.311
  br label %if.end.858

if.end.858:                                       ; preds = %if.end.857, %if.end
  br label %if.end.859

if.end.859:                                       ; preds = %if.end.858, %cond.end.139
  %476 = load i64, i64* %textpos, align 8
  %tobool860 = icmp ne i64 %476, 0
  br i1 %tobool860, label %if.end.973, label %if.then.861

if.then.861:                                      ; preds = %if.end.859
  %call862 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call862, i64* %object2, align 8
  %477 = load i32, i32* %part, align 4
  %cmp863 = icmp eq i32 %477, 1
  br i1 %cmp863, label %cond.true.865, label %cond.false.867

cond.true.865:                                    ; preds = %if.then.861
  %478 = load i32, i32* %xret, align 4
  %conv866 = sext i32 %478 to i64
  br label %cond.end.925

cond.false.867:                                   ; preds = %if.then.861
  %479 = load i32, i32* %part, align 4
  %cmp868 = icmp eq i32 %479, 6
  br i1 %cmp868, label %cond.true.917, label %lor.lhs.false.870

lor.lhs.false.870:                                ; preds = %cond.false.867
  %480 = load i32, i32* %part, align 4
  %cmp871 = icmp eq i32 %480, 8
  br i1 %cmp871, label %cond.true.917, label %lor.lhs.false.873

lor.lhs.false.873:                                ; preds = %lor.lhs.false.870
  %481 = load i32, i32* %part, align 4
  %cmp874 = icmp eq i32 %481, 9
  br i1 %cmp874, label %land.lhs.true.876, label %cond.false.922

land.lhs.true.876:                                ; preds = %lor.lhs.false.873
  %482 = load %struct.window*, %struct.window** %w, align 8
  %pseudo_window_p877 = getelementptr inbounds %struct.window, %struct.window* %482, i32 0, i32 67
  %bf.load878 = load i16, i16* %pseudo_window_p877, align 4
  %bf.lshr879 = lshr i16 %bf.load878, 11
  %bf.clear880 = and i16 %bf.lshr879, 1
  %bf.cast881 = trunc i16 %bf.clear880 to i1
  br i1 %bf.cast881, label %cond.true.883, label %cond.false.884

cond.true.883:                                    ; preds = %land.lhs.true.876
  br label %cond.end.913

cond.false.884:                                   ; preds = %land.lhs.true.876
  %483 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type885 = getelementptr inbounds %struct.window, %struct.window* %483, i32 0, i32 16
  %484 = load i64, i64* %vertical_scroll_bar_type885, align 8
  %call886 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp887 = icmp eq i64 %484, %call886
  br i1 %cmp887, label %cond.true.889, label %cond.false.897

cond.true.889:                                    ; preds = %cond.false.884
  %485 = load %struct.window*, %struct.window** %w, align 8
  %frame890 = getelementptr inbounds %struct.window, %struct.window* %485, i32 0, i32 1
  %486 = load i64, i64* %frame890, align 8
  %sub891 = sub nsw i64 %486, 5
  %487 = inttoptr i64 %sub891 to i8*
  %488 = bitcast i8* %487 to %struct.frame*
  %vertical_scroll_bar_type892 = getelementptr inbounds %struct.frame, %struct.frame* %488, i32 0, i32 26
  %489 = bitcast i48* %vertical_scroll_bar_type892 to i64*
  %bf.load893 = load i64, i64* %489, align 8
  %bf.lshr894 = lshr i64 %bf.load893, 30
  %bf.clear895 = and i64 %bf.lshr894, 3
  %bf.cast896 = trunc i64 %bf.clear895 to i32
  br label %cond.end.911

cond.false.897:                                   ; preds = %cond.false.884
  %490 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type898 = getelementptr inbounds %struct.window, %struct.window* %490, i32 0, i32 16
  %491 = load i64, i64* %vertical_scroll_bar_type898, align 8
  %call899 = call i64 @builtin_lisp_symbol(i32 607)
  %cmp900 = icmp eq i64 %491, %call899
  br i1 %cmp900, label %cond.true.902, label %cond.false.903

cond.true.902:                                    ; preds = %cond.false.897
  br label %cond.end.909

cond.false.903:                                   ; preds = %cond.false.897
  %492 = load %struct.window*, %struct.window** %w, align 8
  %vertical_scroll_bar_type904 = getelementptr inbounds %struct.window, %struct.window* %492, i32 0, i32 16
  %493 = load i64, i64* %vertical_scroll_bar_type904, align 8
  %call905 = call i64 @builtin_lisp_symbol(i32 811)
  %cmp906 = icmp eq i64 %493, %call905
  %cond908 = select i1 %cmp906, i32 2, i32 0
  br label %cond.end.909

cond.end.909:                                     ; preds = %cond.false.903, %cond.true.902
  %cond910 = phi i32 [ 1, %cond.true.902 ], [ %cond908, %cond.false.903 ]
  br label %cond.end.911

cond.end.911:                                     ; preds = %cond.end.909, %cond.true.889
  %cond912 = phi i32 [ %bf.cast896, %cond.true.889 ], [ %cond910, %cond.end.909 ]
  br label %cond.end.913

cond.end.913:                                     ; preds = %cond.end.911, %cond.true.883
  %cond914 = phi i32 [ 0, %cond.true.883 ], [ %cond912, %cond.end.911 ]
  %cmp915 = icmp eq i32 %cond914, 2
  br i1 %cmp915, label %cond.true.917, label %cond.false.922

cond.true.917:                                    ; preds = %cond.end.913, %lor.lhs.false.870, %cond.false.867
  %494 = load i64, i64* %x.addr, align 8
  %shr918 = ashr i64 %494, 2
  %495 = load %struct.window*, %struct.window** %w, align 8
  %call919 = call i32 @window_box_left(%struct.window* %495, i32 1)
  %conv920 = sext i32 %call919 to i64
  %sub921 = sub nsw i64 %shr918, %conv920
  br label %cond.end.923

cond.false.922:                                   ; preds = %cond.end.913, %lor.lhs.false.873
  br label %cond.end.923

cond.end.923:                                     ; preds = %cond.false.922, %cond.true.917
  %cond924 = phi i64 [ %sub921, %cond.true.917 ], [ 0, %cond.false.922 ]
  br label %cond.end.925

cond.end.925:                                     ; preds = %cond.end.923, %cond.true.865
  %cond926 = phi i64 [ %conv866, %cond.true.865 ], [ %cond924, %cond.end.923 ]
  %conv927 = trunc i64 %cond926 to i32
  store i32 %conv927, i32* %x2, align 4
  %496 = load i32, i32* %wy, align 4
  store i32 %496, i32* %y2, align 4
  %497 = load %struct.window*, %struct.window** %w, align 8
  %call928 = call i64 @buffer_posn_from_coords(%struct.window* %497, i32* %x2, i32* %y2, %struct.display_pos* %p, i64* %object2, i32* %dx2, i32* %dy2, i32* %width2, i32* %height2)
  store i64 %call928, i64* %string2, align 8
  %pos = getelementptr inbounds %struct.display_pos, %struct.display_pos* %p, i32 0, i32 0
  %charpos929 = getelementptr inbounds %struct.text_pos, %struct.text_pos* %pos, i32 0, i32 0
  %498 = load i64, i64* %charpos929, align 8
  store i64 %498, i64* %textpos, align 8
  %499 = load i32, i32* %col, align 4
  %cmp930 = icmp slt i32 %499, 0
  br i1 %cmp930, label %if.then.932, label %if.end.933

if.then.932:                                      ; preds = %cond.end.925
  %500 = load i32, i32* %x2, align 4
  store i32 %500, i32* %col, align 4
  br label %if.end.933

if.end.933:                                       ; preds = %if.then.932, %cond.end.925
  %501 = load i32, i32* %row, align 4
  %cmp934 = icmp slt i32 %501, 0
  br i1 %cmp934, label %if.then.936, label %if.end.937

if.then.936:                                      ; preds = %if.end.933
  %502 = load i32, i32* %y2, align 4
  store i32 %502, i32* %row, align 4
  br label %if.end.937

if.end.937:                                       ; preds = %if.then.936, %if.end.933
  %503 = load i32, i32* %dx, align 4
  %cmp938 = icmp slt i32 %503, 0
  br i1 %cmp938, label %if.then.940, label %if.end.941

if.then.940:                                      ; preds = %if.end.937
  %504 = load i32, i32* %dx2, align 4
  store i32 %504, i32* %dx, align 4
  br label %if.end.941

if.end.941:                                       ; preds = %if.then.940, %if.end.937
  %505 = load i32, i32* %dy, align 4
  %cmp942 = icmp slt i32 %505, 0
  br i1 %cmp942, label %if.then.944, label %if.end.945

if.then.944:                                      ; preds = %if.end.941
  %506 = load i32, i32* %dy2, align 4
  store i32 %506, i32* %dy, align 4
  br label %if.end.945

if.end.945:                                       ; preds = %if.then.944, %if.end.941
  %507 = load i32, i32* %width, align 4
  %cmp946 = icmp slt i32 %507, 0
  br i1 %cmp946, label %if.then.948, label %if.end.949

if.then.948:                                      ; preds = %if.end.945
  %508 = load i32, i32* %width2, align 4
  store i32 %508, i32* %width, align 4
  br label %if.end.949

if.end.949:                                       ; preds = %if.then.948, %if.end.945
  %509 = load i32, i32* %height, align 4
  %cmp950 = icmp slt i32 %509, 0
  br i1 %cmp950, label %if.then.952, label %if.end.953

if.then.952:                                      ; preds = %if.end.949
  %510 = load i32, i32* %height2, align 4
  store i32 %510, i32* %height, align 4
  br label %if.end.953

if.end.953:                                       ; preds = %if.then.952, %if.end.949
  %511 = load i64, i64* %posn, align 8
  %call954 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp955 = icmp eq i64 %511, %call954
  br i1 %cmp955, label %if.then.957, label %if.end.967

if.then.957:                                      ; preds = %if.end.953
  %512 = load i64, i64* %textpos, align 8
  %shl958 = shl i64 %512, 2
  %add959 = add i64 %shl958, 2
  store i64 %add959, i64* %posn, align 8
  %513 = load i64, i64* %string2, align 8
  %call960 = call zeroext i1 @STRINGP(i64 %513)
  br i1 %call960, label %if.then.961, label %if.end.966

if.then.961:                                      ; preds = %if.then.957
  %514 = load i64, i64* %string2, align 8
  %string_pos = getelementptr inbounds %struct.display_pos, %struct.display_pos* %p, i32 0, i32 2
  %charpos962 = getelementptr inbounds %struct.text_pos, %struct.text_pos* %string_pos, i32 0, i32 0
  %515 = load i64, i64* %charpos962, align 8
  %shl963 = shl i64 %515, 2
  %add964 = add i64 %shl963, 2
  %call965 = call i64 @Fcons(i64 %514, i64 %add964)
  store i64 %call965, i64* %string_info, align 8
  br label %if.end.966

if.end.966:                                       ; preds = %if.then.961, %if.then.957
  br label %if.end.967

if.end.967:                                       ; preds = %if.end.966, %if.end.953
  %516 = load i64, i64* %object, align 8
  %call968 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp969 = icmp eq i64 %516, %call968
  br i1 %cmp969, label %if.then.971, label %if.end.972

if.then.971:                                      ; preds = %if.end.967
  %517 = load i64, i64* %object2, align 8
  store i64 %517, i64* %object, align 8
  br label %if.end.972

if.end.972:                                       ; preds = %if.then.971, %if.end.967
  br label %if.end.973

if.end.973:                                       ; preds = %if.end.972, %if.end.859
  %518 = load i64, i64* %object, align 8
  %call974 = call zeroext i1 @IMAGEP(i64 %518)
  br i1 %call974, label %if.then.975, label %if.end.998

if.then.975:                                      ; preds = %if.end.973
  %519 = load i64, i64* %object, align 8
  %sub976 = sub nsw i64 %519, 3
  %520 = inttoptr i64 %sub976 to i8*
  %521 = bitcast i8* %520 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %521, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %522 = load i64, i64* %cdr, align 8
  %call977 = call i64 @builtin_lisp_symbol(i32 79)
  %call978 = call i64 @Fplist_get(i64 %522, i64 %call977)
  store i64 %call978, i64* %image_map, align 8
  %523 = load i64, i64* %image_map, align 8
  %call979 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp980 = icmp eq i64 %523, %call979
  %lnot = xor i1 %cmp980, true
  br i1 %lnot, label %land.lhs.true.982, label %if.end.997

land.lhs.true.982:                                ; preds = %if.then.975
  %524 = load i64, i64* %image_map, align 8
  %525 = load i32, i32* %dx, align 4
  %526 = load i32, i32* %dy, align 4
  %call983 = call i64 @find_hot_spot(i64 %524, i32 %525, i32 %526)
  store i64 %call983, i64* %hotspot, align 8
  %527 = load i64, i64* %hotspot, align 8
  %and = and i64 %527, 7
  %conv984 = trunc i64 %and to i32
  %cmp985 = icmp eq i32 %conv984, 3
  br i1 %cmp985, label %land.lhs.true.987, label %if.end.997

land.lhs.true.987:                                ; preds = %land.lhs.true.982
  %528 = load i64, i64* %hotspot, align 8
  %sub988 = sub nsw i64 %528, 3
  %529 = inttoptr i64 %sub988 to i8*
  %530 = bitcast i8* %529 to %struct.Lisp_Cons*
  %u989 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %530, i32 0, i32 1
  %cdr990 = bitcast %union.anon.12* %u989 to i64*
  %531 = load i64, i64* %cdr990, align 8
  store i64 %531, i64* %hotspot, align 8
  %532 = load i64, i64* %hotspot, align 8
  %and991 = and i64 %532, 7
  %conv992 = trunc i64 %and991 to i32
  %cmp993 = icmp eq i32 %conv992, 3
  br i1 %cmp993, label %if.then.995, label %if.end.997

if.then.995:                                      ; preds = %land.lhs.true.987
  %533 = load i64, i64* %hotspot, align 8
  %sub996 = sub nsw i64 %533, 3
  %534 = inttoptr i64 %sub996 to i8*
  %535 = bitcast i8* %534 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %535, i32 0, i32 0
  %536 = load i64, i64* %car, align 8
  store i64 %536, i64* %posn, align 8
  br label %if.end.997

if.end.997:                                       ; preds = %if.then.995, %land.lhs.true.987, %land.lhs.true.982, %if.then.975
  br label %if.end.998

if.end.998:                                       ; preds = %if.end.997, %if.end.973
  %537 = load i64, i64* %object, align 8
  %538 = load i32, i32* %dx, align 4
  %conv999 = sext i32 %538 to i64
  %shl1000 = shl i64 %conv999, 2
  %add1001 = add i64 %shl1000, 2
  %539 = load i32, i32* %dy, align 4
  %conv1002 = sext i32 %539 to i64
  %shl1003 = shl i64 %conv1002, 2
  %add1004 = add i64 %shl1003, 2
  %call1005 = call i64 @Fcons(i64 %add1001, i64 %add1004)
  %540 = load i32, i32* %width, align 4
  %conv1006 = sext i32 %540 to i64
  %shl1007 = shl i64 %conv1006, 2
  %add1008 = add i64 %shl1007, 2
  %541 = load i32, i32* %height, align 4
  %conv1009 = sext i32 %541 to i64
  %shl1010 = shl i64 %conv1009, 2
  %add1011 = add i64 %shl1010, 2
  %call1012 = call i64 @Fcons(i64 %add1008, i64 %add1011)
  %call1013 = call i64 @list3(i64 %537, i64 %call1005, i64 %call1012)
  store i64 %call1013, i64* %extra_info, align 8
  %542 = load i64, i64* %string_info, align 8
  %543 = load i64, i64* %textpos, align 8
  %cmp1014 = icmp slt i64 %543, 0
  br i1 %cmp1014, label %cond.true.1016, label %cond.false.1018

cond.true.1016:                                   ; preds = %if.end.998
  %call1017 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.1021

cond.false.1018:                                  ; preds = %if.end.998
  %544 = load i64, i64* %textpos, align 8
  %shl1019 = shl i64 %544, 2
  %add1020 = add i64 %shl1019, 2
  br label %cond.end.1021

cond.end.1021:                                    ; preds = %cond.false.1018, %cond.true.1016
  %cond1022 = phi i64 [ %call1017, %cond.true.1016 ], [ %add1020, %cond.false.1018 ]
  %545 = load i32, i32* %col, align 4
  %conv1023 = sext i32 %545 to i64
  %shl1024 = shl i64 %conv1023, 2
  %add1025 = add i64 %shl1024, 2
  %546 = load i32, i32* %row, align 4
  %conv1026 = sext i32 %546 to i64
  %shl1027 = shl i64 %conv1026, 2
  %add1028 = add i64 %shl1027, 2
  %call1029 = call i64 @Fcons(i64 %add1025, i64 %add1028)
  %547 = load i64, i64* %extra_info, align 8
  %call1030 = call i64 @Fcons(i64 %call1029, i64 %547)
  %call1031 = call i64 @Fcons(i64 %cond1022, i64 %call1030)
  %call1032 = call i64 @Fcons(i64 %542, i64 %call1031)
  store i64 %call1032, i64* %extra_info, align 8
  br label %if.end.1045

if.else.1033:                                     ; preds = %cond.end
  %548 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %cmp1034 = icmp ne %struct.frame* %548, null
  br i1 %cmp1034, label %if.then.1036, label %if.else.1042

if.then.1036:                                     ; preds = %if.else.1033
  %549 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %550 = bitcast %struct.frame* %549 to i8*
  %call1037 = call i64 @make_lisp_ptr(i8* %550, i32 5)
  store i64 %call1037, i64* %window, align 8
  %551 = load i64, i64* %x.addr, align 8
  %shr1038 = ashr i64 %551, 2
  %conv1039 = trunc i64 %shr1038 to i32
  store i32 %conv1039, i32* %xret, align 4
  %552 = load i64, i64* %y.addr, align 8
  %shr1040 = ashr i64 %552, 2
  %conv1041 = trunc i64 %shr1040 to i32
  store i32 %conv1041, i32* %yret, align 4
  br label %if.end.1044

if.else.1042:                                     ; preds = %if.else.1033
  %call1043 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1043, i64* %window, align 8
  br label %if.end.1044

if.end.1044:                                      ; preds = %if.else.1042, %if.then.1036
  br label %if.end.1045

if.end.1045:                                      ; preds = %if.end.1044, %cond.end.1021
  %553 = load i64, i64* %window, align 8
  %554 = load i64, i64* %posn, align 8
  %555 = load i32, i32* %xret, align 4
  %conv1046 = sext i32 %555 to i64
  %shl1047 = shl i64 %conv1046, 2
  %add1048 = add i64 %shl1047, 2
  %556 = load i32, i32* %yret, align 4
  %conv1049 = sext i32 %556 to i64
  %shl1050 = shl i64 %conv1049, 2
  %add1051 = add i64 %shl1050, 2
  %call1052 = call i64 @Fcons(i64 %add1048, i64 %add1051)
  %557 = load i64, i64* %t.addr, align 8
  %shl1053 = shl i64 %557, 2
  %add1054 = add i64 %shl1053, 2
  %558 = load i64, i64* %extra_info, align 8
  %call1055 = call i64 @Fcons(i64 %add1054, i64 %558)
  %call1056 = call i64 @Fcons(i64 %call1052, i64 %call1055)
  %call1057 = call i64 @Fcons(i64 %554, i64 %call1056)
  %call1058 = call i64 @Fcons(i64 %553, i64 %call1057)
  ret i64 %call1058
}

; Function Attrs: nounwind uwtable
define i64 @Fposn_at_point(i64 %pos, i64 %window) #0 {
entry:
  %retval = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %window.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %x = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %window, i64* %window.addr, align 8
  %0 = load i64, i64* %window.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* @selected_window, align 8
  store i64 %1, i64* %window.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %pos.addr, align 8
  %3 = load i64, i64* %window.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  %call2 = call i64 @Fpos_visible_in_window_p(i64 %2, i64 %3, i64 %call1)
  store i64 %call2, i64* %tem, align 8
  %4 = load i64, i64* %tem, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %4, %call3
  br i1 %cmp4, label %if.end.15, label %if.then.5

if.then.5:                                        ; preds = %if.end
  %5 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car, align 8
  store i64 %8, i64* %x, align 8
  %9 = load i64, i64* %tem, align 8
  %sub6 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub6 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %12 = load i64, i64* %cdr, align 8
  %sub7 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub7 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %car8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 0
  %15 = load i64, i64* %car8, align 8
  store i64 %15, i64* %y, align 8
  %16 = load i64, i64* %x, align 8
  %shr = ashr i64 %16, 2
  %cmp9 = icmp slt i64 %shr, -1
  br i1 %cmp9, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.then.5
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call11, i64* %retval
  br label %return

if.end.12:                                        ; preds = %if.then.5
  %17 = load i64, i64* %x, align 8
  %18 = load i64, i64* %y, align 8
  %19 = load i64, i64* %window.addr, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %call14 = call i64 @Fposn_at_x_y(i64 %17, i64 %18, i64 %19, i64 %call13)
  store i64 %call14, i64* %tem, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.12, %if.end
  %20 = load i64, i64* %tem, align 8
  store i64 %20, i64* %retval
  br label %return

return:                                           ; preds = %if.end.15, %if.then.10
  %21 = load i64, i64* %retval
  ret i64 %21
}

declare i64 @Fpos_visible_in_window_p(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define %struct.kboard* @allocate_kboard(i64 %type) #0 {
entry:
  %type.addr = alloca i64, align 8
  %kb = alloca %struct.kboard*, align 8
  store i64 %type, i64* %type.addr, align 8
  %call = call noalias i8* @xmalloc(i64 200)
  %0 = bitcast i8* %call to %struct.kboard*
  store %struct.kboard* %0, %struct.kboard** %kb, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %2 = load i64, i64* %type.addr, align 8
  call void @init_kboard(%struct.kboard* %1, i64 %2)
  %3 = load %struct.kboard*, %struct.kboard** @all_kboards, align 8
  %4 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %4, i32 0, i32 0
  store %struct.kboard* %3, %struct.kboard** %next_kboard, align 8
  %5 = load %struct.kboard*, %struct.kboard** %kb, align 8
  store %struct.kboard* %5, %struct.kboard** @all_kboards, align 8
  %6 = load %struct.kboard*, %struct.kboard** %kb, align 8
  ret %struct.kboard* %6
}

; Function Attrs: nounwind uwtable
define internal void @init_kboard(%struct.kboard* %kb, i64 %type) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %type.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %type, i64* %type.addr, align 8
  %0 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_overriding_terminal_local_map(%struct.kboard* %0, i64 %call)
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_command(%struct.kboard* %1, i64 %call1)
  %2 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_real_last_command(%struct.kboard* %2, i64 %call2)
  %3 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_keyboard_translate_table(%struct.kboard* %3, i64 %call3)
  %4 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_repeatable_command(%struct.kboard* %4, i64 %call4)
  %5 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_prefix_arg(%struct.kboard* %5, i64 %call5)
  %6 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_prefix_arg(%struct.kboard* %6, i64 %call6)
  %7 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_kbd_queue(%struct.kboard* %7, i64 %call7)
  %8 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %kbd_queue_has_data = getelementptr inbounds %struct.kboard, %struct.kboard* %8, i32 0, i32 23
  store i8 0, i8* %kbd_queue_has_data, align 1
  %9 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %immediate_echo = getelementptr inbounds %struct.kboard, %struct.kboard* %9, i32 0, i32 24
  %bf.load = load i8, i8* %immediate_echo, align 1
  %bf.clear = and i8 %bf.load, -2
  store i8 %bf.clear, i8* %immediate_echo, align 1
  %10 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_echo_string(%struct.kboard* %10, i64 %call8)
  %11 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_echo_prompt(%struct.kboard* %11, i64 %call9)
  %12 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %kbd_macro_buffer = getelementptr inbounds %struct.kboard, %struct.kboard* %12, i32 0, i32 10
  store i64* null, i64** %kbd_macro_buffer, align 8
  %13 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %kbd_macro_bufsize = getelementptr inbounds %struct.kboard, %struct.kboard* %13, i32 0, i32 13
  store i64 0, i64* %kbd_macro_bufsize, align 8
  %14 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_defining_kbd_macro(%struct.kboard* %14, i64 %call10)
  %15 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_kbd_macro(%struct.kboard* %15, i64 %call11)
  %16 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %reference_count = getelementptr inbounds %struct.kboard, %struct.kboard* %16, i32 0, i32 21
  store i32 0, i32* %reference_count, align 4
  %17 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_system_key_alist(%struct.kboard* %17, i64 %call12)
  %18 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_system_key_syms(%struct.kboard* %18, i64 %call13)
  %19 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %20 = load i64, i64* %type.addr, align 8
  call void @kset_window_system(%struct.kboard* %19, i64 %20)
  %21 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %call15 = call i64 @Fmake_sparse_keymap(i64 %call14)
  call void @kset_input_decode_map(%struct.kboard* %21, i64 %call15)
  %22 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %call17 = call i64 @Fmake_sparse_keymap(i64 %call16)
  call void @kset_local_function_key_map(%struct.kboard* %22, i64 %call17)
  %23 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vlocal_function_key_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %23, i32 0, i32 18
  %24 = load i64, i64* %Vlocal_function_key_map_, align 8
  %25 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 113), align 8
  %call18 = call i64 @Fset_keymap_parent(i64 %24, i64 %25)
  %26 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_default_minibuffer_frame(%struct.kboard* %26, i64 %call19)
  ret void
}

; Function Attrs: nounwind uwtable
define void @delete_kboard(%struct.kboard* %kb) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %kbp = alloca %struct.kboard**, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store %struct.kboard** @all_kboards, %struct.kboard*** %kbp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load %struct.kboard**, %struct.kboard*** %kbp, align 8
  %1 = load %struct.kboard*, %struct.kboard** %0, align 8
  %2 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %cmp = icmp ne %struct.kboard* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.kboard**, %struct.kboard*** %kbp, align 8
  %4 = load %struct.kboard*, %struct.kboard** %3, align 8
  %cmp1 = icmp eq %struct.kboard* %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  call void @emacs_abort() #11
  unreachable

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load %struct.kboard**, %struct.kboard*** %kbp, align 8
  %6 = load %struct.kboard*, %struct.kboard** %5, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %6, i32 0, i32 0
  store %struct.kboard** %next_kboard, %struct.kboard*** %kbp, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %next_kboard2 = getelementptr inbounds %struct.kboard, %struct.kboard* %7, i32 0, i32 0
  %8 = load %struct.kboard*, %struct.kboard** %next_kboard2, align 8
  %9 = load %struct.kboard**, %struct.kboard*** %kbp, align 8
  store %struct.kboard* %8, %struct.kboard** %9, align 8
  %10 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %11 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp3 = icmp eq %struct.kboard* %10, %11
  br i1 %cmp3, label %land.lhs.true, label %if.end.12

land.lhs.true:                                    ; preds = %for.end
  %12 = load i64, i64* @selected_frame, align 8
  %call = call zeroext i1 @FRAMEP(i64 %12)
  br i1 %call, label %land.lhs.true.4, label %if.end.12

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %13 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %13, 5
  %14 = inttoptr i64 %sub to i8*
  %15 = bitcast i8* %14 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %15, i32 0, i32 61
  %16 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp5 = icmp ne %struct.terminal* %16, null
  br i1 %cmp5, label %if.then.6, label %if.end.12

if.then.6:                                        ; preds = %land.lhs.true.4
  %17 = load i64, i64* @selected_frame, align 8
  %sub7 = sub nsw i64 %17, 5
  %18 = inttoptr i64 %sub7 to i8*
  %19 = bitcast i8* %18 to %struct.frame*
  %terminal8 = getelementptr inbounds %struct.frame, %struct.frame* %19, i32 0, i32 61
  %20 = load %struct.terminal*, %struct.terminal** %terminal8, align 8
  %kboard = getelementptr inbounds %struct.terminal, %struct.terminal* %20, i32 0, i32 10
  %21 = load %struct.kboard*, %struct.kboard** %kboard, align 8
  store %struct.kboard* %21, %struct.kboard** @current_kboard, align 8
  store i8 0, i8* @single_kboard, align 1
  %22 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %23 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %cmp9 = icmp eq %struct.kboard* %22, %23
  br i1 %cmp9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.then.6
  call void @emacs_abort() #11
  unreachable

if.end.11:                                        ; preds = %if.then.6
  br label %if.end.12

if.end.12:                                        ; preds = %if.end.11, %land.lhs.true.4, %land.lhs.true, %for.end
  %24 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  call void @wipe_kboard(%struct.kboard* %24)
  %25 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %26 = bitcast %struct.kboard* %25 to i8*
  call void @xfree(i8* %26)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @wipe_kboard(%struct.kboard* %kb) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  %0 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %kbd_macro_buffer = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 10
  %1 = load i64*, i64** %kbd_macro_buffer, align 8
  %2 = bitcast i64* %1 to i8*
  call void @xfree(i8* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define void @init_keyboard() #0 {
entry:
  %coerce = alloca %struct.timespec, align 8
  %action = alloca %struct.sigaction, align 8
  %action9 = alloca %struct.sigaction, align 8
  store i64 -1, i64* @command_loop_level, align 8
  store i8 0, i8* @immediate_quit, align 1
  store i32 7, i32* @quit_char, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %call1 = call { i64, i64 } @invalid_timespec()
  %0 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call1, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call1, 1
  store i64 %4, i64* %3, align 8
  %5 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* bitcast (%struct.timespec* @timer_idleness_start_time to i8*), i8* %5, i64 16, i32 8, i1 false)
  store i32 0, i32* @total_keys, align 4
  store i32 0, i32* @recent_keys_index, align 4
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store volatile %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** @kbd_store_ptr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  store i8 0, i8* @input_pending, align 1
  store volatile i32 0, i32* @interrupt_input_blocked, align 4
  store volatile i8 0, i8* @pending_signals, align 1
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call3, i64* @internal_last_event_frame, align 8
  %6 = load i64, i64* @internal_last_event_frame, align 8
  store i64 %6, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  %7 = load %struct.kboard*, %struct.kboard** @initial_kboard, align 8
  store %struct.kboard* %7, %struct.kboard** @current_kboard, align 8
  %8 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  call void @wipe_kboard(%struct.kboard* %8)
  %9 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  call void @init_kboard(%struct.kboard* %9, i64 %call4)
  %10 = load i8, i8* @noninteractive, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @emacs_sigaction_init(%struct.sigaction* %action, void (i32)* @deliver_interrupt_signal)
  %call5 = call i32 @sigaction(i32 2, %struct.sigaction* %action, %struct.sigaction* null) #8
  %call6 = call i32 @sigaction(i32 3, %struct.sigaction* %action, %struct.sigaction* null) #8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load i8, i8* @noninteractive, align 1
  %tobool7 = trunc i8 %11 to i1
  br i1 %tobool7, label %if.end.11, label %if.then.8

if.then.8:                                        ; preds = %if.end
  call void @emacs_sigaction_init(%struct.sigaction* %action9, void (i32)* @deliver_input_available_signal)
  %call10 = call i32 @sigaction(i32 29, %struct.sigaction* %action9, %struct.sigaction* null) #8
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.8, %if.end
  store i8 1, i8* @interrupt_input, align 1
  %call12 = call i32 @pthread_sigmask(i32 2, %struct.__sigset_t* @empty_mask, %struct.__sigset_t* null) #8
  store %struct._IO_FILE* null, %struct._IO_FILE** @dribble, align 8
  %12 = load void ()*, void ()** @keyboard_init_hook, align 8
  %tobool13 = icmp ne void ()* %12, null
  br i1 %tobool13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.11
  %13 = load void ()*, void ()** @keyboard_init_hook, align 8
  call void %13()
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.14, %if.end.11
  store %struct.atimer* null, %struct.atimer** @poll_timer, align 8
  store i32 1, i32* @poll_suppress_count, align 4
  call void @start_polling()
  ret void
}

declare { i64, i64 } @invalid_timespec() #1

; Function Attrs: nounwind uwtable
define internal void @deliver_interrupt_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load i32, i32* %sig.addr, align 4
  call void @deliver_process_signal(i32 %0, void (i32)* @handle_interrupt_signal)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @deliver_input_available_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load i32, i32* %sig.addr, align 4
  call void @deliver_process_signal(i32 %0, void (i32)* @handle_input_available_signal)
  ret void
}

; Function Attrs: nounwind uwtable
define void @syms_of_keyboard() #0 {
entry:
  %i = alloca i32, align 4
  %p = alloca %struct.event_head*, align 8
  %var = alloca i64, align 8
  %kind = alloca i64, align 8
  %i31 = alloca i32, align 4
  %len = alloca i32, align 4
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* @pending_funcalls, align 8
  call void @staticpro(i64* @pending_funcalls)
  %call1 = call i64 @build_pure_c_string(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.27, i32 0, i32 0))
  store i64 %call1, i64* @Vlispy_mouse_stem, align 8
  call void @staticpro(i64* @Vlispy_mouse_stem)
  %call2 = call i64 @build_pure_c_string(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.28, i32 0, i32 0))
  store i64 %call2, i64* @regular_top_level_message, align 8
  %call3 = call i64 @build_pure_c_string(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.29, i32 0, i32 0))
  store i64 %call3, i64* @recover_top_level_message, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.30, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 146))
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load i64, i64* @regular_top_level_message, align 8
  store i64 %0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 146), align 8
  call void @staticpro(i64* @item_properties)
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4, i64* @item_properties, align 8
  call void @staticpro(i64* @tool_bar_item_properties)
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* @tool_bar_item_properties, align 8
  call void @staticpro(i64* @tool_bar_items_vector)
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call6, i64* @tool_bar_items_vector, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 550)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %call9 = call i64 @Fset(i64 %call7, i64 %call8)
  %call10 = call i64 @builtin_lisp_symbol(i32 551)
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %call12 = call i64 @Fset(i64 %call10, i64 %call11)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %1 = load i32, i32* %i, align 4
  %conv = sext i32 %1 to i64
  %cmp = icmp ult i64 %conv, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [9 x %struct.event_head], [9 x %struct.event_head]* @head_table, i32 0, i64 %idxprom
  store %struct.event_head* %arrayidx, %struct.event_head** %p, align 8
  %3 = load %struct.event_head*, %struct.event_head** %p, align 8
  %var14 = getelementptr inbounds %struct.event_head, %struct.event_head* %3, i32 0, i32 0
  %4 = load i16, i16* %var14, align 2
  %conv15 = sext i16 %4 to i32
  %call16 = call i64 @builtin_lisp_symbol(i32 %conv15)
  store i64 %call16, i64* %var, align 8
  %5 = load %struct.event_head*, %struct.event_head** %p, align 8
  %kind17 = getelementptr inbounds %struct.event_head, %struct.event_head* %5, i32 0, i32 1
  %6 = load i16, i16* %kind17, align 2
  %conv18 = sext i16 %6 to i32
  %call19 = call i64 @builtin_lisp_symbol(i32 %conv18)
  store i64 %call19, i64* %kind, align 8
  %7 = load i64, i64* %var, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 382)
  %8 = load i64, i64* %kind, align 8
  %call21 = call i64 @Fput(i64 %7, i64 %call20, i64 %8)
  %9 = load i64, i64* %var, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 384)
  %10 = load i64, i64* %var, align 8
  %call23 = call i64 @list1(i64 %10)
  %call24 = call i64 @Fput(i64 %9, i64 %call22, i64 %call23)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %call26 = call i64 @Fmake_vector(i64 22, i64 %call25)
  store i64 %call26, i64* @button_down_location, align 8
  call void @staticpro(i64* @button_down_location)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @Fmake_vector(i64 22, i64 %call27)
  store i64 %call28, i64* @mouse_syms, align 8
  call void @staticpro(i64* @mouse_syms)
  %call29 = call i64 @builtin_lisp_symbol(i32 0)
  %call30 = call i64 @Fmake_vector(i64 18, i64 %call29)
  store i64 %call30, i64* @wheel_syms, align 8
  call void @staticpro(i64* @wheel_syms)
  store i32 28, i32* %len, align 4
  %12 = load i32, i32* %len, align 4
  %conv32 = sext i32 %12 to i64
  %shl = shl i64 %conv32, 2
  %add = add i64 %shl, 2
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %call34 = call i64 @Fmake_vector(i64 %add, i64 %call33)
  store i64 %call34, i64* @modifier_symbols, align 8
  store i32 0, i32* %i31, align 4
  br label %for.cond.35

for.cond.35:                                      ; preds = %for.inc.45, %for.end
  %13 = load i32, i32* %i31, align 4
  %14 = load i32, i32* %len, align 4
  %cmp36 = icmp slt i32 %13, %14
  br i1 %cmp36, label %for.body.38, label %for.end.47

for.body.38:                                      ; preds = %for.cond.35
  %15 = load i32, i32* %i31, align 4
  %idxprom39 = sext i32 %15 to i64
  %arrayidx40 = getelementptr inbounds [28 x i8*], [28 x i8*]* @modifier_names, i32 0, i64 %idxprom39
  %16 = load i8*, i8** %arrayidx40, align 8
  %tobool = icmp ne i8* %16, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body.38
  %17 = load i64, i64* @modifier_symbols, align 8
  %18 = load i32, i32* %i31, align 4
  %conv41 = sext i32 %18 to i64
  %19 = load i32, i32* %i31, align 4
  %idxprom42 = sext i32 %19 to i64
  %arrayidx43 = getelementptr inbounds [28 x i8*], [28 x i8*]* @modifier_names, i32 0, i64 %idxprom42
  %20 = load i8*, i8** %arrayidx43, align 8
  %call44 = call i64 @intern_c_string(i8* %20)
  call void @ASET(i64 %17, i64 %conv41, i64 %call44)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body.38
  br label %for.inc.45

for.inc.45:                                       ; preds = %if.end
  %21 = load i32, i32* %i31, align 4
  %inc46 = add nsw i32 %21, 1
  store i32 %inc46, i32* %i31, align 4
  br label %for.cond.35

for.end.47:                                       ; preds = %for.cond.35
  call void @staticpro(i64* @modifier_symbols)
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %call49 = call i64 @Fmake_vector(i64 1202, i64 %call48)
  store i64 %call49, i64* @recent_keys, align 8
  call void @staticpro(i64* @recent_keys)
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %call51 = call i64 @Fmake_vector(i64 162, i64 %call50)
  store i64 %call51, i64* @this_command_keys, align 8
  call void @staticpro(i64* @this_command_keys)
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %call53 = call i64 @Fmake_vector(i64 122, i64 %call52)
  store i64 %call53, i64* @raw_keybuf, align 8
  call void @staticpro(i64* @raw_keybuf)
  %call54 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call54, i64* @accent_key_syms, align 8
  call void @staticpro(i64* @accent_key_syms)
  %call55 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call55, i64* @func_key_syms, align 8
  call void @staticpro(i64* @func_key_syms)
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call56, i64* @drag_n_drop_syms, align 8
  call void @staticpro(i64* @drag_n_drop_syms)
  %call57 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call57, i64* @unread_switch_frame, align 8
  call void @staticpro(i64* @unread_switch_frame)
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call58, i64* @internal_last_event_frame, align 8
  call void @staticpro(i64* @internal_last_event_frame)
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call59, i64* @read_key_sequence_cmd, align 8
  call void @staticpro(i64* @read_key_sequence_cmd)
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call60, i64* @read_key_sequence_remapped, align 8
  call void @staticpro(i64* @read_key_sequence_remapped)
  %call61 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call61, i64* @menu_bar_one_keymap_changed_items, align 8
  call void @staticpro(i64* @menu_bar_one_keymap_changed_items)
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call62, i64* @menu_bar_items_vector, align 8
  call void @staticpro(i64* @menu_bar_items_vector)
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call63, i64* @help_form_saved_window_configs, align 8
  call void @staticpro(i64* @help_form_saved_window_configs)
  call void @defsubr(%struct.Lisp_Subr* @Scurrent_idle_time)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sevent_symbol_parse_modifiers to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sevent_convert_list to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sread_key_sequence to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sread_key_sequence_vector to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Srecursive_edit)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Strack_mouse to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sinput_pending_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Srecent_keys to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sthis_command_keys)
  call void @defsubr(%struct.Lisp_Subr* @Sthis_command_keys_vector)
  call void @defsubr(%struct.Lisp_Subr* @Sthis_single_command_keys)
  call void @defsubr(%struct.Lisp_Subr* @Sthis_single_command_raw_keys)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sclear_this_command_keys to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssuspend_emacs to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sabort_recursive_edit)
  call void @defsubr(%struct.Lisp_Subr* @Sexit_recursive_edit)
  call void @defsubr(%struct.Lisp_Subr* @Srecursion_depth)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scommand_error_default_function to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Stop_level)
  call void @defsubr(%struct.Lisp_Subr* @Sdiscard_input)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sopen_dribble_file to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_input_interrupt_mode to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_output_flow_control to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_input_meta_mode to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_quit_char to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_input_mode to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Scurrent_input_mode)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sposn_at_point to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sposn_at_x_y to %struct.Lisp_Subr*))
  br label %do.body.64

do.body.64:                                       ; preds = %for.end.47
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.31, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.32, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 375))
  br label %do.end.65

do.end.65:                                        ; preds = %do.body.64
  br label %do.body.66

do.body.66:                                       ; preds = %do.end.65
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.33, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.34, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377))
  br label %do.end.67

do.end.67:                                        ; preds = %do.body.66
  br label %do.body.68

do.body.68:                                       ; preds = %do.end.67
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.35, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.36, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376))
  br label %do.end.69

do.end.69:                                        ; preds = %do.body.68
  br label %do.body.70

do.body.70:                                       ; preds = %do.end.69
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.37, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.38, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315))
  br label %do.end.71

do.end.71:                                        ; preds = %do.body.70
  %call72 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call72, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  br label %do.body.73

do.body.73:                                       ; preds = %do.end.71
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.39, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.40, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317))
  br label %do.end.74

do.end.74:                                        ; preds = %do.body.73
  %call75 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call75, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 317), align 8
  br label %do.body.76

do.body.76:                                       ; preds = %do.end.74
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.41, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.42, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316))
  br label %do.end.77

do.end.77:                                        ; preds = %do.body.76
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call78, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 316), align 8
  br label %do.body.79

do.body.79:                                       ; preds = %do.end.77
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.43, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.44, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 379))
  br label %do.end.80

do.end.80:                                        ; preds = %do.body.79
  store i64 110, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 379), align 8
  br label %do.body.81

do.body.81:                                       ; preds = %do.end.80
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.45, i32 0, i32 0), i32 16)
  br label %do.end.82

do.end.82:                                        ; preds = %do.body.81
  br label %do.body.83

do.body.83:                                       ; preds = %do.end.82
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.46, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.47, i32 0, i32 0), i32 24)
  br label %do.end.84

do.end.84:                                        ; preds = %do.body.83
  br label %do.body.85

do.body.85:                                       ; preds = %do.end.84
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.48, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.49, i32 0, i32 0), i32 40)
  br label %do.end.86

do.end.86:                                        ; preds = %do.body.85
  br label %do.body.87

do.body.87:                                       ; preds = %do.end.86
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.50, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.51, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293))
  br label %do.end.88

do.end.88:                                        ; preds = %do.body.87
  %call89 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call89, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 293), align 8
  br label %do.body.90

do.body.90:                                       ; preds = %do.end.88
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.52, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.53, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248))
  br label %do.end.91

do.end.91:                                        ; preds = %do.body.90
  %call92 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call92, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 248), align 8
  br label %do.body.93

do.body.93:                                       ; preds = %do.end.91
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.54, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.55, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 294))
  br label %do.end.94

do.end.94:                                        ; preds = %do.body.93
  %call95 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call95, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 294), align 8
  br label %do.body.96

do.body.96:                                       ; preds = %do.end.94
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.56, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.57, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 295))
  br label %do.end.97

do.end.97:                                        ; preds = %do.body.96
  %call98 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call98, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 295), align 8
  br label %do.body.99

do.body.99:                                       ; preds = %do.end.97
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.58, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 380))
  br label %do.end.100

do.end.100:                                       ; preds = %do.body.99
  store i64 300, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 380), align 8
  br label %do.body.101

do.body.101:                                      ; preds = %do.end.100
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.59, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.60, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 11))
  br label %do.end.102

do.end.102:                                       ; preds = %do.body.101
  %call103 = call i64 @make_natnum(i64 30)
  store i64 %call103, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 11), align 8
  br label %do.body.104

do.body.104:                                      ; preds = %do.end.102
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.61, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.62, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76))
  br label %do.end.105

do.end.105:                                       ; preds = %do.body.104
  store i64 6, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 76), align 8
  br label %do.body.106

do.body.106:                                      ; preds = %do.end.105
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd.63, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.64, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403))
  br label %do.end.107

do.end.107:                                       ; preds = %do.body.106
  store i64 2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 403), align 8
  br label %do.body.108

do.body.108:                                      ; preds = %do.end.107
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.65, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.66, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74))
  br label %do.end.109

do.end.109:                                       ; preds = %do.body.108
  store i64 2002, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  br label %do.body.110

do.body.110:                                      ; preds = %do.end.109
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd.67, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.68, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384))
  br label %do.end.111

do.end.111:                                       ; preds = %do.body.110
  store i64 3, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  br label %do.body.112

do.body.112:                                      ; preds = %do.end.111
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd.69, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.70, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 400))
  br label %do.end.113

do.end.113:                                       ; preds = %do.body.112
  store i64 0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 400), align 8
  br label %do.body.114

do.body.114:                                      ; preds = %do.end.113
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd.71, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.72, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401))
  br label %do.end.115

do.end.115:                                       ; preds = %do.body.114
  store i64 0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  br label %do.body.116

do.body.116:                                      ; preds = %do.end.115
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.73, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.74, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156))
  br label %do.end.117

do.end.117:                                       ; preds = %do.body.116
  %call118 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call118, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  br label %do.body.119

do.body.119:                                      ; preds = %do.end.117
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.75, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.76, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 311))
  br label %do.end.120

do.end.120:                                       ; preds = %do.body.119
  br label %do.body.121

do.body.121:                                      ; preds = %do.end.120
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.77, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.78, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 121))
  br label %do.end.122

do.end.122:                                       ; preds = %do.body.121
  store i64 34, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 121), align 8
  br label %do.body.123

do.body.123:                                      ; preds = %do.end.122
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.79, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.80, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 122))
  br label %do.end.124

do.end.124:                                       ; preds = %do.body.123
  %call125 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call125, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 122), align 8
  br label %do.body.126

do.body.126:                                      ; preds = %do.end.124
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.81, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.82, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 123))
  br label %do.end.127

do.end.127:                                       ; preds = %do.body.126
  %call128 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call128, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 123), align 8
  br label %do.body.129

do.body.129:                                      ; preds = %do.end.127
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.83, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.84, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 224))
  br label %do.end.130

do.end.130:                                       ; preds = %do.body.129
  %call131 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call131, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 224), align 8
  br label %do.body.132

do.body.132:                                      ; preds = %do.end.130
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.85, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 304))
  br label %do.end.133

do.end.133:                                       ; preds = %do.body.132
  %call134 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call134, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 304), align 8
  %call135 = call i64 @builtin_lisp_symbol(i32 930)
  %sub = sub nsw i64 %call135, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %22 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %23 = bitcast %struct.Lisp_Symbol* %22 to i16*
  %bf.load = load i16, i16* %23, align 8
  %bf.clear = and i16 %bf.load, -257
  store i16 %bf.clear, i16* %23, align 8
  br label %do.body.136

do.body.136:                                      ; preds = %do.end.133
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.87, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.88, i32 0, i32 0), i32 32)
  br label %do.end.137

do.end.137:                                       ; preds = %do.body.136
  br label %do.body.138

do.body.138:                                      ; preds = %do.end.137
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_keyboard.b_fwd, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.89, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 426))
  br label %do.end.139

do.end.139:                                       ; preds = %do.body.138
  store i8 0, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 426), align 1
  br label %do.body.140

do.body.140:                                      ; preds = %do.end.139
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_keyboard.b_fwd.90, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.91, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 469))
  br label %do.end.141

do.end.141:                                       ; preds = %do.body.140
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 469), align 1
  br label %do.body.142

do.body.142:                                      ; preds = %do.end.141
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.92, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.93, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 378))
  br label %do.end.143

do.end.143:                                       ; preds = %do.body.142
  store i64 130, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 378), align 8
  br label %do.body.144

do.body.144:                                      ; preds = %do.end.143
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_keyboard.i_fwd.94, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.95, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387))
  br label %do.end.145

do.end.145:                                       ; preds = %do.body.144
  store i64 0, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387), align 8
  br label %do.body.146

do.body.146:                                      ; preds = %do.end.145
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.96, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.97, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52))
  br label %do.end.147

do.end.147:                                       ; preds = %do.body.146
  %call148 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call148, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 52), align 8
  %call149 = call i64 @builtin_lisp_symbol(i32 319)
  %call150 = call i64 @Fmake_variable_buffer_local(i64 %call149)
  br label %do.body.151

do.body.151:                                      ; preds = %do.end.147
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.98, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.99, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 222))
  br label %do.end.152

do.end.152:                                       ; preds = %do.body.151
  %call153 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call153, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 222), align 8
  br label %do.body.154

do.body.154:                                      ; preds = %do.end.152
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.100, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.101, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 219))
  br label %do.end.155

do.end.155:                                       ; preds = %do.body.154
  %call156 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call156, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 219), align 8
  %call157 = call i64 @builtin_lisp_symbol(i32 355)
  %call158 = call i64 @builtin_lisp_symbol(i32 0)
  %call159 = call i64 @Fset(i64 %call157, i64 %call158)
  br label %do.body.160

do.body.160:                                      ; preds = %do.end.155
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.102, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.103, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 169))
  br label %do.end.161

do.end.161:                                       ; preds = %do.body.160
  %call162 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call162, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 169), align 8
  br label %do.body.163

do.body.163:                                      ; preds = %do.end.161
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.104, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.105, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 176))
  br label %do.end.164

do.end.164:                                       ; preds = %do.body.163
  %call165 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call165, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 176), align 8
  br label %do.body.166

do.body.166:                                      ; preds = %do.end.164
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.106, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.107, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 302))
  br label %do.end.167

do.end.167:                                       ; preds = %do.body.166
  %call168 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call168, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 302), align 8
  br label %do.body.169

do.body.169:                                      ; preds = %do.end.167
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.108, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.109, i32 0, i32 0), i32 8)
  br label %do.end.170

do.end.170:                                       ; preds = %do.body.169
  br label %do.body.171

do.body.171:                                      ; preds = %do.end.170
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.110, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.111, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216))
  br label %do.end.172

do.end.172:                                       ; preds = %do.body.171
  %call173 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call173, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 216), align 8
  br label %do.body.174

do.body.174:                                      ; preds = %do.end.172
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.112, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.113, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217))
  br label %do.end.175

do.end.175:                                       ; preds = %do.body.174
  %call176 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call176, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 217), align 8
  br label %do.body.177

do.body.177:                                      ; preds = %do.end.175
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.114, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.115, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274))
  br label %do.end.178

do.end.178:                                       ; preds = %do.body.177
  %call179 = call i64 @builtin_lisp_symbol(i32 589)
  %call180 = call i64 @list1(i64 %call179)
  store i64 %call180, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  br label %do.body.181

do.body.181:                                      ; preds = %do.end.178
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.116, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.117, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368))
  br label %do.end.182

do.end.182:                                       ; preds = %do.body.181
  br label %do.body.183

do.body.183:                                      ; preds = %do.end.182
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.118, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.119, i32 0, i32 0), i32 120)
  br label %do.end.184

do.end.184:                                       ; preds = %do.body.183
  br label %do.body.185

do.body.185:                                      ; preds = %do.end.184
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.120, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.121, i32 0, i32 0), i32 144)
  br label %do.end.186

do.end.186:                                       ; preds = %do.body.185
  br label %do.body.187

do.body.187:                                      ; preds = %do.end.186
  call void @defvar_kboard(%struct.Lisp_Kboard_Objfwd* @syms_of_keyboard.ko_fwd.122, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.123, i32 0, i32 0), i32 152)
  br label %do.end.188

do.end.188:                                       ; preds = %do.body.187
  br label %do.body.189

do.body.189:                                      ; preds = %do.end.188
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.124, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.125, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 113))
  br label %do.end.190

do.end.190:                                       ; preds = %do.body.189
  %call191 = call i64 @builtin_lisp_symbol(i32 0)
  %call192 = call i64 @Fmake_sparse_keymap(i64 %call191)
  store i64 %call192, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 113), align 8
  br label %do.body.193

do.body.193:                                      ; preds = %do.end.190
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.126, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.127, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 151))
  br label %do.end.194

do.end.194:                                       ; preds = %do.body.193
  %call195 = call i64 @builtin_lisp_symbol(i32 0)
  %call196 = call i64 @Fmake_sparse_keymap(i64 %call195)
  store i64 %call196, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 151), align 8
  br label %do.body.197

do.body.197:                                      ; preds = %do.end.194
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.128, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.129, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 65))
  br label %do.end.198

do.end.198:                                       ; preds = %do.body.197
  %call199 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call199, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 65), align 8
  br label %do.body.200

do.body.200:                                      ; preds = %do.end.198
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.130, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.131, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 64))
  br label %do.end.201

do.end.201:                                       ; preds = %do.body.200
  %call202 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call202, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 64), align 8
  br label %do.body.203

do.body.203:                                      ; preds = %do.end.201
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.132, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.133, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 67))
  br label %do.end.204

do.end.204:                                       ; preds = %do.body.203
  %call205 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call205, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 67), align 8
  br label %do.body.206

do.body.206:                                      ; preds = %do.end.204
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.134, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.135, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 298))
  br label %do.end.207

do.end.207:                                       ; preds = %do.body.206
  %call208 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call208, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 298), align 8
  br label %do.body.209

do.body.209:                                      ; preds = %do.end.207
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.136, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.137, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 297))
  br label %do.end.210

do.end.210:                                       ; preds = %do.body.209
  %call211 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call211, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 297), align 8
  br label %do.body.212

do.body.212:                                      ; preds = %do.end.210
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.138, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.139, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 143))
  br label %do.end.213

do.end.213:                                       ; preds = %do.body.212
  %call214 = call i64 @builtin_lisp_symbol(i32 624)
  store i64 %call214, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 143), align 8
  br label %do.body.215

do.body.215:                                      ; preds = %do.end.213
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.140, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.141, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 144))
  br label %do.end.216

do.end.216:                                       ; preds = %do.body.215
  %call217 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call217, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 144), align 8
  br label %do.body.218

do.body.218:                                      ; preds = %do.end.216
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.142, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.143, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 270))
  br label %do.end.219

do.end.219:                                       ; preds = %do.body.218
  %call220 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call220, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 270), align 8
  br label %do.body.221

do.body.221:                                      ; preds = %do.end.219
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.144, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.145, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 70))
  br label %do.end.222

do.end.222:                                       ; preds = %do.body.221
  %call223 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call223, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 70), align 8
  br label %do.body.224

do.body.224:                                      ; preds = %do.end.222
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.146, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.147, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 116))
  br label %do.end.225

do.end.225:                                       ; preds = %do.body.224
  %call226 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call226, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 116), align 8
  br label %do.body.227

do.body.227:                                      ; preds = %do.end.225
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.148, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.149, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 192))
  br label %do.end.228

do.end.228:                                       ; preds = %do.body.227
  store i64 10, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 192), align 8
  br label %do.body.229

do.body.229:                                      ; preds = %do.end.228
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.150, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.151, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296))
  br label %do.end.230

do.end.230:                                       ; preds = %do.body.229
  %call231 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call231, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296), align 8
  br label %do.body.232

do.body.232:                                      ; preds = %do.end.230
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.152, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.153, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 40))
  br label %do.end.233

do.end.233:                                       ; preds = %do.body.232
  %call234 = call i64 @intern(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.154, i32 0, i32 0))
  store i64 %call234, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 40), align 8
  br label %do.body.235

do.body.235:                                      ; preds = %do.end.233
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.155, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.156, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 81))
  br label %do.end.236

do.end.236:                                       ; preds = %do.body.235
  %call237 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call237, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 81), align 8
  br label %do.body.238

do.body.238:                                      ; preds = %do.end.236
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.157, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.158, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 263))
  br label %do.end.239

do.end.239:                                       ; preds = %do.body.238
  %call240 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call240, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 263), align 8
  br label %do.body.241

do.body.241:                                      ; preds = %do.end.239
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.159, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.160, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 258))
  br label %do.end.242

do.end.242:                                       ; preds = %do.body.241
  %call243 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call243, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 258), align 8
  br label %do.body.244

do.body.244:                                      ; preds = %do.end.242
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.161, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.162, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 266))
  br label %do.end.245

do.end.245:                                       ; preds = %do.body.244
  %call246 = call i64 @builtin_lisp_symbol(i32 508)
  %call247 = call i64 @builtin_lisp_symbol(i32 506)
  %call248 = call i64 @list2(i64 %call246, i64 %call247)
  store i64 %call248, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 266), align 8
  br label %do.body.249

do.body.249:                                      ; preds = %do.end.245
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_keyboard.o_fwd.163, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.164, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 55))
  br label %do.end.250

do.end.250:                                       ; preds = %do.body.249
  %call251 = call i64 @intern_c_string(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.165, i32 0, i32 0))
  store i64 %call251, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 55), align 8
  %call252 = call i64 @builtin_lisp_symbol(i32 901)
  %call253 = call %struct.kboard* @allocate_kboard(i64 %call252)
  store %struct.kboard* %call253, %struct.kboard** @initial_kboard, align 8
  ret void
}

declare void @staticpro(i64*) #1

declare i64 @build_pure_c_string(i8*) #1

declare void @defvar_lisp(%struct.Lisp_Objfwd*, i8*, i64*) #1

declare i64 @Fset(i64, i64) #1

declare i64 @intern_c_string(i8*) #1

declare void @defsubr(%struct.Lisp_Subr*) #1

declare void @defvar_kboard(%struct.Lisp_Kboard_Objfwd*, i8*, i32) #1

declare void @defvar_int(%struct.Lisp_Intfwd*, i8*, i64*) #1

declare void @defvar_bool(%struct.Lisp_Boolfwd*, i8*, i8*) #1

declare i64 @Fmake_variable_buffer_local(i64) #1

declare i64 @Fmake_sparse_keymap(i64) #1

; Function Attrs: nounwind uwtable
define void @keys_of_keyboard() #0 {
entry:
  %0 = load i64, i64* @global_map, align 8
  call void @initial_define_key(i64 %0, i32 26, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.166, i32 0, i32 0))
  %1 = load i64, i64* @control_x_map, align 8
  call void @initial_define_key(i64 %1, i32 26, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.166, i32 0, i32 0))
  %2 = load i64, i64* @meta_map, align 8
  call void @initial_define_key(i64 %2, i32 3, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.167, i32 0, i32 0))
  %3 = load i64, i64* @global_map, align 8
  call void @initial_define_key(i64 %3, i32 29, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.168, i32 0, i32 0))
  %4 = load i64, i64* @meta_map, align 8
  call void @initial_define_key(i64 %4, i32 120, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.169, i32 0, i32 0))
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %5, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.170, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.171, i32 0, i32 0))
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %6, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.172, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.172, i32 0, i32 0))
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %7, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.173, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.173, i32 0, i32 0))
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %8, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.175, i32 0, i32 0))
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %9, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.176, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.175, i32 0, i32 0))
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %10, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.177, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.178, i32 0, i32 0))
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %11, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.179, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.180, i32 0, i32 0))
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %12, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.181, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.175, i32 0, i32 0))
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %13, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.182, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.183, i32 0, i32 0))
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 274), align 8
  call void @initial_define_lispy_key(i64 %14, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.185, i32 0, i32 0))
  ret void
}

declare void @initial_define_key(i64, i32, i8*) #1

declare void @initial_define_lispy_key(i64, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define void @mark_kboards() #0 {
entry:
  %kb = alloca %struct.kboard*, align 8
  %p = alloca i64*, align 8
  %event = alloca %union.buffered_input_event*, align 8
  %0 = load %struct.kboard*, %struct.kboard** @all_kboards, align 8
  store %struct.kboard* %0, %struct.kboard** %kb, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.5, %entry
  %1 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %tobool = icmp ne %struct.kboard* %1, null
  br i1 %tobool, label %for.body, label %for.end.6

for.body:                                         ; preds = %for.cond
  %2 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_macro_buffer = getelementptr inbounds %struct.kboard, %struct.kboard* %2, i32 0, i32 10
  %3 = load i64*, i64** %kbd_macro_buffer, align 8
  %tobool1 = icmp ne i64* %3, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_macro_buffer2 = getelementptr inbounds %struct.kboard, %struct.kboard* %4, i32 0, i32 10
  %5 = load i64*, i64** %kbd_macro_buffer2, align 8
  store i64* %5, i64** %p, align 8
  br label %for.cond.3

for.cond.3:                                       ; preds = %for.inc, %if.then
  %6 = load i64*, i64** %p, align 8
  %7 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_macro_ptr = getelementptr inbounds %struct.kboard, %struct.kboard* %7, i32 0, i32 11
  %8 = load i64*, i64** %kbd_macro_ptr, align 8
  %cmp = icmp ult i64* %6, %8
  br i1 %cmp, label %for.body.4, label %for.end

for.body.4:                                       ; preds = %for.cond.3
  %9 = load i64*, i64** %p, align 8
  %10 = load i64, i64* %9, align 8
  call void @mark_object(i64 %10)
  br label %for.inc

for.inc:                                          ; preds = %for.body.4
  %11 = load i64*, i64** %p, align 8
  %incdec.ptr = getelementptr inbounds i64, i64* %11, i32 1
  store i64* %incdec.ptr, i64** %p, align 8
  br label %for.cond.3

for.end:                                          ; preds = %for.cond.3
  br label %if.end

if.end:                                           ; preds = %for.end, %for.body
  %12 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Voverriding_terminal_local_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %12, i32 0, i32 1
  %13 = load i64, i64* %Voverriding_terminal_local_map_, align 8
  call void @mark_object(i64 %13)
  %14 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vlast_command_ = getelementptr inbounds %struct.kboard, %struct.kboard* %14, i32 0, i32 2
  %15 = load i64, i64* %Vlast_command_, align 8
  call void @mark_object(i64 %15)
  %16 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vreal_last_command_ = getelementptr inbounds %struct.kboard, %struct.kboard* %16, i32 0, i32 3
  %17 = load i64, i64* %Vreal_last_command_, align 8
  call void @mark_object(i64 %17)
  %18 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vkeyboard_translate_table_ = getelementptr inbounds %struct.kboard, %struct.kboard* %18, i32 0, i32 4
  %19 = load i64, i64* %Vkeyboard_translate_table_, align 8
  call void @mark_object(i64 %19)
  %20 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vlast_repeatable_command_ = getelementptr inbounds %struct.kboard, %struct.kboard* %20, i32 0, i32 5
  %21 = load i64, i64* %Vlast_repeatable_command_, align 8
  call void @mark_object(i64 %21)
  %22 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vprefix_arg_ = getelementptr inbounds %struct.kboard, %struct.kboard* %22, i32 0, i32 6
  %23 = load i64, i64* %Vprefix_arg_, align 8
  call void @mark_object(i64 %23)
  %24 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vlast_prefix_arg_ = getelementptr inbounds %struct.kboard, %struct.kboard* %24, i32 0, i32 7
  %25 = load i64, i64* %Vlast_prefix_arg_, align 8
  call void @mark_object(i64 %25)
  %26 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_ = getelementptr inbounds %struct.kboard, %struct.kboard* %26, i32 0, i32 8
  %27 = load i64, i64* %kbd_queue_, align 8
  call void @mark_object(i64 %27)
  %28 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %defining_kbd_macro_ = getelementptr inbounds %struct.kboard, %struct.kboard* %28, i32 0, i32 9
  %29 = load i64, i64* %defining_kbd_macro_, align 8
  call void @mark_object(i64 %29)
  %30 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vlast_kbd_macro_ = getelementptr inbounds %struct.kboard, %struct.kboard* %30, i32 0, i32 14
  %31 = load i64, i64* %Vlast_kbd_macro_, align 8
  call void @mark_object(i64 %31)
  %32 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vsystem_key_alist_ = getelementptr inbounds %struct.kboard, %struct.kboard* %32, i32 0, i32 15
  %33 = load i64, i64* %Vsystem_key_alist_, align 8
  call void @mark_object(i64 %33)
  %34 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %system_key_syms_ = getelementptr inbounds %struct.kboard, %struct.kboard* %34, i32 0, i32 16
  %35 = load i64, i64* %system_key_syms_, align 8
  call void @mark_object(i64 %35)
  %36 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vwindow_system_ = getelementptr inbounds %struct.kboard, %struct.kboard* %36, i32 0, i32 17
  %37 = load i64, i64* %Vwindow_system_, align 8
  call void @mark_object(i64 %37)
  %38 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vinput_decode_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %38, i32 0, i32 19
  %39 = load i64, i64* %Vinput_decode_map_, align 8
  call void @mark_object(i64 %39)
  %40 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vlocal_function_key_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %40, i32 0, i32 18
  %41 = load i64, i64* %Vlocal_function_key_map_, align 8
  call void @mark_object(i64 %41)
  %42 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %Vdefault_minibuffer_frame_ = getelementptr inbounds %struct.kboard, %struct.kboard* %42, i32 0, i32 20
  %43 = load i64, i64* %Vdefault_minibuffer_frame_, align 8
  call void @mark_object(i64 %43)
  %44 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %44, i32 0, i32 22
  %45 = load i64, i64* %echo_string_, align 8
  call void @mark_object(i64 %45)
  %46 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %echo_prompt_ = getelementptr inbounds %struct.kboard, %struct.kboard* %46, i32 0, i32 25
  %47 = load i64, i64* %echo_prompt_, align 8
  call void @mark_object(i64 %47)
  br label %for.inc.5

for.inc.5:                                        ; preds = %if.end
  %48 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %next_kboard = getelementptr inbounds %struct.kboard, %struct.kboard* %48, i32 0, i32 0
  %49 = load %struct.kboard*, %struct.kboard** %next_kboard, align 8
  store %struct.kboard* %49, %struct.kboard** %kb, align 8
  br label %for.cond

for.end.6:                                        ; preds = %for.cond
  %50 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  store %union.buffered_input_event* %50, %union.buffered_input_event** %event, align 8
  br label %for.cond.7

for.cond.7:                                       ; preds = %for.inc.22, %for.end.6
  %51 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %52 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp8 = icmp ne %union.buffered_input_event* %51, %52
  br i1 %cmp8, label %for.body.9, label %for.end.24

for.body.9:                                       ; preds = %for.cond.7
  %53 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %cmp10 = icmp eq %union.buffered_input_event* %53, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %for.body.9
  store %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %union.buffered_input_event** %event, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.11, %for.body.9
  %54 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %55 = bitcast %union.buffered_input_event* %54 to i16*
  %bf.load = load i16, i16* %55, align 8
  %bf.cast = zext i16 %bf.load to i32
  %cmp13 = icmp ne i32 %bf.cast, 10
  br i1 %cmp13, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %if.end.12
  %56 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %57 = bitcast %union.buffered_input_event* %56 to i16*
  %bf.load14 = load i16, i16* %57, align 8
  %bf.cast15 = zext i16 %bf.load14 to i32
  %cmp16 = icmp ne i32 %bf.cast15, 11
  br i1 %cmp16, label %if.then.17, label %if.end.21

if.then.17:                                       ; preds = %land.lhs.true
  %58 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie = bitcast %union.buffered_input_event* %58 to %struct.input_event*
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %ie, i32 0, i32 3
  %59 = load i64, i64* %x, align 8
  call void @mark_object(i64 %59)
  %60 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie18 = bitcast %union.buffered_input_event* %60 to %struct.input_event*
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %ie18, i32 0, i32 4
  %61 = load i64, i64* %y, align 8
  call void @mark_object(i64 %61)
  %62 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie19 = bitcast %union.buffered_input_event* %62 to %struct.input_event*
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %ie19, i32 0, i32 6
  %63 = load i64, i64* %frame_or_window, align 8
  call void @mark_object(i64 %63)
  %64 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie20 = bitcast %union.buffered_input_event* %64 to %struct.input_event*
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %ie20, i32 0, i32 7
  %65 = load i64, i64* %arg, align 8
  call void @mark_object(i64 %65)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.17, %land.lhs.true, %if.end.12
  br label %for.inc.22

for.inc.22:                                       ; preds = %if.end.21
  %66 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %incdec.ptr23 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %66, i32 1
  store %union.buffered_input_event* %incdec.ptr23, %union.buffered_input_event** %event, align 8
  br label %for.cond.7

for.end.24:                                       ; preds = %for.cond.7
  ret void
}

declare void @mark_object(i64) #1

declare i64 @Fset_buffer(i64) #1

; Function Attrs: nounwind returns_twice
declare i32 @__sigsetjmp(%struct.__jmp_buf_tag*, i32) #5

declare void @init_eval() #1

declare i64 @internal_catch(i64, i64 (i64)*, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @command_loop_2(i64 %ignore) #0 {
entry:
  %ignore.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %ignore, i64* %ignore.addr, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %call = call i64 @builtin_lisp_symbol(i32 372)
  %call1 = call i64 @internal_condition_case(i64 ()* @command_loop_1, i64 %call, i64 (i64)* @cmd_error)
  store i64 %call1, i64* %val, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %0 = load i64, i64* %val, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call2
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define internal i64 @top_level_1(i64 %ignore) #0 {
entry:
  %ignore.addr = alloca i64, align 8
  store i64 %ignore, i64* %ignore.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 304), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 372)
  %call2 = call i64 @internal_condition_case(i64 ()* @top_level_2, i64 %call1, i64 (i64)* @cmd_error)
  br label %if.end.7

if.else:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %1, %call3
  br i1 %cmp4, label %if.else.6, label %if.then.5

if.then.5:                                        ; preds = %if.else
  call void @message1(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.188, i32 0, i32 0))
  br label %if.end

if.else.6:                                        ; preds = %if.else
  call void @message1(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.189, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else.6, %if.then.5
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %if.then
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call8
}

declare i64 @internal_condition_case(i64 ()*, i64, i64 (i64)*) #1

; Function Attrs: nounwind uwtable
define internal i64 @cmd_error(i64 %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %old_level = alloca i64, align 8
  %old_length = alloca i64, align 8
  %macroerror = alloca [50 x i8], align 16
  store i64 %data, i64* %data.addr, align 8
  %0 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 438), align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @cancel_hourglass()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, i64* @executing_kbd_macro, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.else.8, label %if.then.1

if.then.1:                                        ; preds = %if.end
  %2 = load i64, i64* @executing_kbd_macro_iterations, align 8
  %cmp2 = icmp eq i64 %2, 1
  br i1 %cmp2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.then.1
  %arraydecay = getelementptr inbounds [50 x i8], [50 x i8]* %macroerror, i32 0, i32 0
  %call4 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.186, i32 0, i32 0)) #8
  br label %if.end.7

if.else:                                          ; preds = %if.then.1
  %arraydecay5 = getelementptr inbounds [50 x i8], [50 x i8]* %macroerror, i32 0, i32 0
  %3 = load i64, i64* @executing_kbd_macro_iterations, align 8
  %call6 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay5, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.187, i32 0, i32 0), i64 %3) #8
  br label %if.end.7

if.end.7:                                         ; preds = %if.else, %if.then.3
  br label %if.end.10

if.else.8:                                        ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [50 x i8], [50 x i8]* %macroerror, i32 0, i32 0
  store i8 0, i8* %arraydecay9, align 1
  br label %if.end.10

if.end.10:                                        ; preds = %if.else.8, %if.end.7
  %call11 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call11, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 277), align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call12, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 276), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call13, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 86), align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call14, i64* @executing_kbd_macro, align 8
  %4 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_prefix_arg(%struct.kboard* %4, i64 %call15)
  %5 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  call void @kset_last_prefix_arg(%struct.kboard* %5, i64 %call16)
  call void @cancel_echoing()
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  store i64 %6, i64* %old_level, align 8
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 232), align 8
  store i64 %7, i64* %old_length, align 8
  %call17 = call i64 @make_natnum(i64 10)
  store i64 %call17, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  %call18 = call i64 @make_natnum(i64 10)
  store i64 %call18, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 232), align 8
  %8 = load i64, i64* %data.addr, align 8
  %arraydecay19 = getelementptr inbounds [50 x i8], [50 x i8]* %macroerror, i32 0, i32 0
  call void @cmd_error_internal(i64 %8, i8* %arraydecay19)
  %9 = load i64, i64* %old_level, align 8
  store i64 %9, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  %10 = load i64, i64* %old_length, align 8
  store i64 %10, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 232), align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call20, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call21, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  ret i64 2
}

; Function Attrs: nounwind
declare i32 @sprintf(i8*, i8*, ...) #6

; Function Attrs: nounwind uwtable
define internal i64 @top_level_2() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 304), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @Feval(i64 %0, i64 %call)
  ret i64 %call1
}

declare i64 @Feval(i64, i64) #1

declare void @message3_nolog(i64) #1

declare void @set_point(i64) #1

declare i64 @get_char_property_and_overlay(i64, i64, i64, i64*) #1

declare zeroext i1 @display_prop_intangible_p(i64, i64, i64, i64) #1

declare zeroext i1 @OVERLAYP(i64) #1

declare zeroext i1 @get_property_and_range(i64, i64, i64*, i64*, i64*, i64) #1

declare %struct.Lisp_Overlay* @XOVERLAY(i64) #1

declare i32 @XMISCTYPE(i64) #1

declare i64 @marker_position(i64) #1

declare i32 @invisible_prop(i64, i64) #1

declare i64 @Foverlay_get(i64, i64) #1

declare i64 @Fnext_single_char_property_change(i64, i64, i64, i64) #1

declare i64 @Fprevious_single_char_property_change(i64, i64, i64, i64) #1

declare i64 @Fget_pos_property(i64, i64, i64) #1

declare i64 @internal_condition_case_n(i64 (i64, i64*)*, i64, i64*, i64, i64 (i64, i64, i64*)*) #1

; Function Attrs: nounwind uwtable
define internal i64 @safe_run_hooks_1(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 1
  %1 = load i64, i64* %arrayidx, align 8
  %call = call i64 @call0(i64 %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @safe_run_hooks_error(i64 %error, i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %error.addr = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %format = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %hook = alloca i64, align 8
  %fun = alloca i64, align 8
  %.compoundliteral3 = alloca [4 x i64], align 8
  %val = alloca i64, align 8
  %found = alloca i8, align 1
  %newval = alloca i64, align 8
  store i64 %error, i64* %error.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  store i64 20, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.190, i32 0, i32 0), i8** %data, align 8
  %s1 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %0 = bitcast %struct.Lisp_String* %s1 to i8*
  %call = call i64 @make_lisp_ptr(i8* %0, i32 4)
  store i64 %call, i64* %format, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %1, i64 0
  %2 = load i64, i64* %arrayidx, align 8
  store i64 %2, i64* %hook, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx2 = getelementptr inbounds i64, i64* %3, i64 1
  %4 = load i64, i64* %arrayidx2, align 8
  store i64 %4, i64* %fun, align 8
  %arrayinit.begin = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral3, i64 0, i64 0
  %5 = load i64, i64* %format, align 8
  store i64 %5, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %6 = load i64, i64* %hook, align 8
  store i64 %6, i64* %arrayinit.element
  %arrayinit.element4 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %7 = load i64, i64* %fun, align 8
  store i64 %7, i64* %arrayinit.element4
  %arrayinit.element5 = getelementptr inbounds i64, i64* %arrayinit.element4, i64 1
  %8 = load i64, i64* %error.addr, align 8
  store i64 %8, i64* %arrayinit.element5
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral3, i32 0, i32 0
  %call6 = call i64 @Fmessage(i64 4, i64* %arraydecay)
  %9 = load i64, i64* %hook, align 8
  %and = and i64 %9, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end.58

if.then:                                          ; preds = %entry
  store i8 0, i8* %found, align 1
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call8, i64* %newval, align 8
  %10 = load i64, i64* %hook, align 8
  %call9 = call i64 @find_symbol_value(i64 %10)
  store i64 %call9, i64* %val, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %11 = load i64, i64* %val, align 8
  %and10 = and i64 %11, 7
  %conv11 = trunc i64 %and10 to i32
  %cmp12 = icmp eq i32 %conv11, 3
  br i1 %cmp12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i64, i64* %fun, align 8
  %13 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car, align 8
  %cmp14 = icmp eq i64 %12, %16
  br i1 %cmp14, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %for.body
  store i8 1, i8* %found, align 1
  br label %if.end

if.else:                                          ; preds = %for.body
  %17 = load i64, i64* %val, align 8
  %sub17 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub17 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %car18 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 0
  %20 = load i64, i64* %car18, align 8
  %21 = load i64, i64* %newval, align 8
  %call19 = call i64 @Fcons(i64 %20, i64 %21)
  store i64 %call19, i64* %newval, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.16
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %22 = load i64, i64* %val, align 8
  %sub20 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub20 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %25 = load i64, i64* %cdr, align 8
  store i64 %25, i64* %val, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = load i8, i8* %found, align 1
  %tobool = trunc i8 %26 to i1
  br i1 %tobool, label %if.then.21, label %if.end.24

if.then.21:                                       ; preds = %for.end
  %27 = load i64, i64* %hook, align 8
  %28 = load i64, i64* %newval, align 8
  %call22 = call i64 @Fnreverse(i64 %28)
  %call23 = call i64 @Fset(i64 %27, i64 %call22)
  store i64 %call23, i64* %retval
  br label %return

if.end.24:                                        ; preds = %for.end
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call25, i64* %newval, align 8
  %29 = load i64, i64* %hook, align 8
  %call26 = call i64 @Fdefault_boundp(i64 %29)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %call26, %call27
  br i1 %cmp28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.24
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.false:                                       ; preds = %if.end.24
  %30 = load i64, i64* %hook, align 8
  %call31 = call i64 @Fdefault_value(i64 %30)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call30, %cond.true ], [ %call31, %cond.false ]
  store i64 %cond, i64* %val, align 8
  br label %for.cond.32

for.cond.32:                                      ; preds = %for.inc.48, %cond.end
  %31 = load i64, i64* %val, align 8
  %and33 = and i64 %31, 7
  %conv34 = trunc i64 %and33 to i32
  %cmp35 = icmp eq i32 %conv34, 3
  br i1 %cmp35, label %for.body.37, label %for.end.52

for.body.37:                                      ; preds = %for.cond.32
  %32 = load i64, i64* %fun, align 8
  %33 = load i64, i64* %val, align 8
  %sub38 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub38 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %car39 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 0
  %36 = load i64, i64* %car39, align 8
  %cmp40 = icmp eq i64 %32, %36
  br i1 %cmp40, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %for.body.37
  store i8 1, i8* %found, align 1
  br label %if.end.47

if.else.43:                                       ; preds = %for.body.37
  %37 = load i64, i64* %val, align 8
  %sub44 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub44 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car45 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car45, align 8
  %41 = load i64, i64* %newval, align 8
  %call46 = call i64 @Fcons(i64 %40, i64 %41)
  store i64 %call46, i64* %newval, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.else.43, %if.then.42
  br label %for.inc.48

for.inc.48:                                       ; preds = %if.end.47
  %42 = load i64, i64* %val, align 8
  %sub49 = sub nsw i64 %42, 3
  %43 = inttoptr i64 %sub49 to i8*
  %44 = bitcast i8* %43 to %struct.Lisp_Cons*
  %u50 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %44, i32 0, i32 1
  %cdr51 = bitcast %union.anon.12* %u50 to i64*
  %45 = load i64, i64* %cdr51, align 8
  store i64 %45, i64* %val, align 8
  br label %for.cond.32

for.end.52:                                       ; preds = %for.cond.32
  %46 = load i8, i8* %found, align 1
  %tobool53 = trunc i8 %46 to i1
  br i1 %tobool53, label %if.then.54, label %if.end.57

if.then.54:                                       ; preds = %for.end.52
  %47 = load i64, i64* %hook, align 8
  %48 = load i64, i64* %newval, align 8
  %call55 = call i64 @Fnreverse(i64 %48)
  %call56 = call i64 @Fset_default(i64 %47, i64 %call55)
  store i64 %call56, i64* %retval
  br label %return

if.end.57:                                        ; preds = %for.end.52
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57, %entry
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call59, i64* %retval
  br label %return

return:                                           ; preds = %if.end.58, %if.then.54, %if.then.21
  %49 = load i64, i64* %retval
  ret i64 %49
}

declare i64 @Fmessage(i64, i64*) #1

declare i64 @find_symbol_value(i64) #1

declare i64 @Fdefault_boundp(i64) #1

declare i64 @Fdefault_value(i64) #1

declare i64 @Fset_default(i64, i64) #1

declare double @XFLOAT_DATA(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @read_event_from_main_queue(%struct.timespec* %end_time, %struct.__jmp_buf_tag* %local_getcjmp, i8* %used_mouse_menu) #0 {
entry:
  %retval = alloca i64, align 8
  %end_time.addr = alloca %struct.timespec*, align 8
  %local_getcjmp.addr = alloca %struct.__jmp_buf_tag*, align 8
  %used_mouse_menu.addr = alloca i8*, align 8
  %c = alloca i64, align 8
  %save_jump = alloca [1 x %struct.__jmp_buf_tag], align 16
  %kb = alloca %struct.kboard*, align 8
  %agg.tmp = alloca %struct.timespec, align 8
  %last = alloca i64, align 8
  store %struct.timespec* %end_time, %struct.timespec** %end_time.addr, align 8
  store %struct.__jmp_buf_tag* %local_getcjmp, %struct.__jmp_buf_tag** %local_getcjmp.addr, align 8
  store i8* %used_mouse_menu, i8** %used_mouse_menu.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %c, align 8
  br label %start

start:                                            ; preds = %if.then.42, %entry
  %0 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool = icmp ne %struct.timespec* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %start
  %1 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %call1 = call { i64, i64 } @current_timespec()
  %2 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 0
  %4 = extractvalue { i64, i64 } %call1, 0
  store i64 %4, i64* %3, align 8
  %5 = getelementptr { i64, i64 }, { i64, i64 }* %2, i32 0, i32 1
  %6 = extractvalue { i64, i64 } %call1, 1
  store i64 %6, i64* %5, align 8
  %7 = bitcast %struct.timespec* %1 to { i64, i64 }*
  %8 = getelementptr { i64, i64 }, { i64, i64 }* %7, i32 0, i32 0
  %9 = load i64, i64* %8, align 1
  %10 = getelementptr { i64, i64 }, { i64, i64 }* %7, i32 0, i32 1
  %11 = load i64, i64* %10, align 1
  %12 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %13 = getelementptr { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 1
  %15 = getelementptr { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 1
  %call2 = call i32 @timespec_cmp(i64 %9, i64 %11, i64 %14, i64 %16) #13
  %cmp = icmp sle i32 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %17 = load i64, i64* %c, align 8
  store i64 %17, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %start
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @save_getcjmp(%struct.__jmp_buf_tag* %arraydecay)
  %18 = load %struct.__jmp_buf_tag*, %struct.__jmp_buf_tag** %local_getcjmp.addr, align 8
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %18)
  %19 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool3 = icmp ne %struct.timespec* %19, null
  br i1 %tobool3, label %if.end.5, label %if.then.4

if.then.4:                                        ; preds = %if.end
  call void @timer_start_idle()
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.4, %if.end
  %20 = load i8*, i8** %used_mouse_menu.addr, align 8
  %21 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %call6 = call i64 @kbd_buffer_get_event(%struct.kboard** %kb, i8* %20, %struct.timespec* %21)
  store i64 %call6, i64* %c, align 8
  %arraydecay7 = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %save_jump, i32 0, i32 0
  call void @restore_getcjmp(%struct.__jmp_buf_tag* %arraydecay7)
  %22 = load i64, i64* %c, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %22, %call8
  br i1 %cmp9, label %if.end.44, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %if.end.5
  %23 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %24 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %cmp11 = icmp ne %struct.kboard* %23, %24
  br i1 %cmp11, label %if.then.12, label %if.end.44

if.then.12:                                       ; preds = %land.lhs.true.10
  %25 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_ = getelementptr inbounds %struct.kboard, %struct.kboard* %25, i32 0, i32 8
  %26 = load i64, i64* %kbd_queue_, align 8
  store i64 %26, i64* %last, align 8
  %27 = load i64, i64* %last, align 8
  %and = and i64 %27, 7
  %conv = trunc i64 %and to i32
  %cmp13 = icmp eq i32 %conv, 3
  br i1 %cmp13, label %if.then.15, label %if.end.31

if.then.15:                                       ; preds = %if.then.12
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.15
  %28 = load i64, i64* %last, align 8
  %sub = sub nsw i64 %28, 3
  %29 = inttoptr i64 %sub to i8*
  %30 = bitcast i8* %29 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %30, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %31 = load i64, i64* %cdr, align 8
  %and16 = and i64 %31, 7
  %conv17 = trunc i64 %and16 to i32
  %cmp18 = icmp eq i32 %conv17, 3
  br i1 %cmp18, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %32 = load i64, i64* %last, align 8
  %sub20 = sub nsw i64 %32, 3
  %33 = inttoptr i64 %sub20 to i8*
  %34 = bitcast i8* %33 to %struct.Lisp_Cons*
  %u21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %34, i32 0, i32 1
  %cdr22 = bitcast %union.anon.12* %u21 to i64*
  %35 = load i64, i64* %cdr22, align 8
  store i64 %35, i64* %last, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %36 = load i64, i64* %last, align 8
  %sub23 = sub nsw i64 %36, 3
  %37 = inttoptr i64 %sub23 to i8*
  %38 = bitcast i8* %37 to %struct.Lisp_Cons*
  %u24 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %38, i32 0, i32 1
  %cdr25 = bitcast %union.anon.12* %u24 to i64*
  %39 = load i64, i64* %cdr25, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp27 = icmp eq i64 %39, %call26
  br i1 %cmp27, label %if.end.30, label %if.then.29

if.then.29:                                       ; preds = %while.end
  call void @emacs_abort() #11
  unreachable

if.end.30:                                        ; preds = %while.end
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %if.then.12
  %40 = load i64, i64* %last, align 8
  %and32 = and i64 %40, 7
  %conv33 = trunc i64 %and32 to i32
  %cmp34 = icmp eq i32 %conv33, 3
  br i1 %cmp34, label %if.else, label %if.then.36

if.then.36:                                       ; preds = %if.end.31
  %41 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %42 = load i64, i64* %c, align 8
  %call37 = call i64 @list1(i64 %42)
  call void @kset_kbd_queue(%struct.kboard* %41, i64 %call37)
  br label %if.end.39

if.else:                                          ; preds = %if.end.31
  %43 = load i64, i64* %last, align 8
  %44 = load i64, i64* %c, align 8
  %call38 = call i64 @list1(i64 %44)
  call void @XSETCDR(i64 %43, i64 %call38)
  br label %if.end.39

if.end.39:                                        ; preds = %if.else, %if.then.36
  %45 = load %struct.kboard*, %struct.kboard** %kb, align 8
  %kbd_queue_has_data = getelementptr inbounds %struct.kboard, %struct.kboard* %45, i32 0, i32 23
  store i8 1, i8* %kbd_queue_has_data, align 1
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call40, i64* %c, align 8
  %46 = load i8, i8* @single_kboard, align 1
  %tobool41 = trunc i8 %46 to i1
  br i1 %tobool41, label %if.then.42, label %if.end.43

if.then.42:                                       ; preds = %if.end.39
  br label %start

if.end.43:                                        ; preds = %if.end.39
  %47 = load %struct.kboard*, %struct.kboard** %kb, align 8
  store %struct.kboard* %47, %struct.kboard** @current_kboard, align 8
  store i64 -6, i64* %retval
  br label %return

if.end.44:                                        ; preds = %land.lhs.true.10, %if.end.5
  %48 = load i8, i8* @noninteractive, align 1
  %tobool45 = trunc i8 %48 to i1
  br i1 %tobool45, label %land.lhs.true.47, label %if.end.57

land.lhs.true.47:                                 ; preds = %if.end.44
  %49 = load i64, i64* %c, align 8
  %and48 = and i64 %49, 7
  %conv49 = trunc i64 %and48 to i32
  %and50 = and i32 %conv49, -5
  %cmp51 = icmp eq i32 %and50, 2
  br i1 %cmp51, label %land.lhs.true.53, label %if.end.57

land.lhs.true.53:                                 ; preds = %land.lhs.true.47
  %50 = load i64, i64* %c, align 8
  %shr = ashr i64 %50, 2
  %cmp54 = icmp slt i64 %shr, 0
  br i1 %cmp54, label %if.then.56, label %if.end.57

if.then.56:                                       ; preds = %land.lhs.true.53
  %51 = call i64 @Fkill_emacs(i64 6) #11
  unreachable

if.end.57:                                        ; preds = %land.lhs.true.53, %land.lhs.true.47, %if.end.44
  %52 = load i64, i64* %c, align 8
  %and58 = and i64 %52, 7
  %conv59 = trunc i64 %and58 to i32
  %and60 = and i32 %conv59, -5
  %cmp61 = icmp eq i32 %and60, 2
  br i1 %cmp61, label %if.then.63, label %if.end.84

if.then.63:                                       ; preds = %if.end.57
  %53 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387), align 8
  %and64 = and i64 %53, 67108864
  %tobool65 = icmp ne i64 %and64, 0
  br i1 %tobool65, label %if.then.73, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.63
  %54 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387), align 8
  %and66 = and i64 %54, 127
  %cmp67 = icmp slt i64 %and66, 32
  br i1 %cmp67, label %land.lhs.true.69, label %if.end.78

land.lhs.true.69:                                 ; preds = %lor.lhs.false
  %55 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387), align 8
  %and70 = and i64 %55, 127
  %cmp71 = icmp ne i64 %and70, 0
  br i1 %cmp71, label %if.then.73, label %if.end.78

if.then.73:                                       ; preds = %land.lhs.true.69, %if.then.63
  %56 = load i64, i64* %c, align 8
  %shr74 = ashr i64 %56, 2
  %conv75 = trunc i64 %shr74 to i32
  %call76 = call i32 @make_ctrl_char(i32 %conv75) #14
  %conv77 = sext i32 %call76 to i64
  %shl = shl i64 %conv77, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %c, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.73, %land.lhs.true.69, %lor.lhs.false
  %57 = load i64, i64* %c, align 8
  %shr79 = ashr i64 %57, 2
  %58 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 387), align 8
  %and80 = and i64 %58, -65408
  %and81 = and i64 %and80, -67108865
  %or = or i64 %shr79, %and81
  %shl82 = shl i64 %or, 2
  %add83 = add i64 %shl82, 2
  store i64 %add83, i64* %c, align 8
  br label %if.end.84

if.end.84:                                        ; preds = %if.end.78, %if.end.57
  %59 = load i64, i64* %c, align 8
  store i64 %59, i64* %retval
  br label %return

return:                                           ; preds = %if.end.84, %if.end.43, %if.then
  %60 = load i64, i64* %retval
  ret i64 %60
}

declare zeroext i1 @raw_text_coding_system_p(%struct.coding_system*) #1

declare void @decode_coding_object(%struct.coding_system*, i64, i64, i64, i64, i64, i64) #1

declare i32 @string_char(i8*, i8**, i32*) #1

; Function Attrs: nounwind uwtable
define internal i64 @kbd_buffer_get_event(%struct.kboard** %kbp, i8* %used_mouse_menu, %struct.timespec* %end_time) #0 {
entry:
  %retval = alloca i64, align 8
  %kbp.addr = alloca %struct.kboard**, align 8
  %used_mouse_menu.addr = alloca i8*, align 8
  %end_time.addr = alloca %struct.timespec*, align 8
  %obj = alloca i64, align 8
  %now = alloca %struct.timespec, align 8
  %duration = alloca %struct.timespec, align 8
  %do_display = alloca i8, align 1
  %tty = alloca %struct.tty_display_info*, align 8
  %first = alloca i64, align 8
  %event = alloca %union.buffered_input_event*, align 8
  %copy = alloca %struct.selection_input_event, align 8
  %object = alloca i64, align 8
  %position = alloca i64, align 8
  %help = alloca i64, align 8
  %frame = alloca i64, align 8
  %window = alloca i64, align 8
  %frame290 = alloca i64, align 8
  %focus = alloca i64, align 8
  %di = alloca %struct.x_display_info*, align 8
  %frame320 = alloca i64, align 8
  %focused = alloca i8, align 1
  %frame345 = alloca i64, align 8
  %focus346 = alloca i64, align 8
  %f = alloca %struct.frame*, align 8
  %bar_window = alloca i64, align 8
  %part = alloca i32, align 4
  %x428 = alloca i64, align 8
  %y429 = alloca i64, align 8
  %t = alloca i64, align 8
  %frame446 = alloca i64, align 8
  store %struct.kboard** %kbp, %struct.kboard*** %kbp.addr, align 8
  store i8* %used_mouse_menu, i8** %used_mouse_menu.addr, align 8
  store %struct.timespec* %end_time, %struct.timespec** %end_time.addr, align 8
  %call = call zeroext i1 @kbd_on_hold_p()
  br i1 %call, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call i32 @kbd_buffer_nr_stored()
  %cmp = icmp slt i32 %call1, 1024
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @unhold_keyboard_input()
  call void @request_sigio()
  call void @start_polling()
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  br label %for.cond

for.cond:                                         ; preds = %if.end.138, %if.end
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp2 = icmp eq i32 %conv, 3
  br i1 %cmp2, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %for.cond
  br label %for.end

if.end.5:                                         ; preds = %for.cond
  %1 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %2 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp6 = icmp ne %union.buffered_input_event* %1, %2
  br i1 %cmp6, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.5
  br label %for.end

if.end.9:                                         ; preds = %if.end.5
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %3, %call10
  br i1 %cmp11, label %if.end.16, label %land.lhs.true.13

land.lhs.true.13:                                 ; preds = %if.end.9
  %call14 = call %struct.frame* @some_mouse_moved()
  %tobool = icmp ne %struct.frame* %call14, null
  br i1 %tobool, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %land.lhs.true.13
  br label %for.end

if.end.16:                                        ; preds = %land.lhs.true.13, %if.end.9
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %4, %call17
  br i1 %cmp18, label %if.end.21, label %if.then.20

if.then.20:                                       ; preds = %if.end.16
  call void @quit_throw_to_read_char(i1 zeroext false) #11
  unreachable

if.end.21:                                        ; preds = %if.end.16
  %call22 = call i32 @gobble_input()
  %5 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %6 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp23 = icmp ne %union.buffered_input_event* %5, %6
  br i1 %cmp23, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %if.end.21
  br label %for.end

if.end.26:                                        ; preds = %if.end.21
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %7, %call27
  br i1 %cmp28, label %if.end.34, label %land.lhs.true.30

land.lhs.true.30:                                 ; preds = %if.end.26
  %call31 = call %struct.frame* @some_mouse_moved()
  %tobool32 = icmp ne %struct.frame* %call31, null
  br i1 %tobool32, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %land.lhs.true.30
  br label %for.end

if.end.34:                                        ; preds = %land.lhs.true.30, %if.end.26
  %8 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %tobool35 = icmp ne %struct.timespec* %8, null
  br i1 %tobool35, label %if.then.36, label %if.else.51

if.then.36:                                       ; preds = %if.end.34
  %call37 = call { i64, i64 } @current_timespec()
  %9 = bitcast %struct.timespec* %now to { i64, i64 }*
  %10 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call37, 0
  store i64 %11, i64* %10, align 8
  %12 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call37, 1
  store i64 %13, i64* %12, align 8
  %14 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %15 = bitcast %struct.timespec* %14 to { i64, i64 }*
  %16 = getelementptr { i64, i64 }, { i64, i64 }* %15, i32 0, i32 0
  %17 = load i64, i64* %16, align 1
  %18 = getelementptr { i64, i64 }, { i64, i64 }* %15, i32 0, i32 1
  %19 = load i64, i64* %18, align 1
  %20 = bitcast %struct.timespec* %now to { i64, i64 }*
  %21 = getelementptr { i64, i64 }, { i64, i64 }* %20, i32 0, i32 0
  %22 = load i64, i64* %21, align 1
  %23 = getelementptr { i64, i64 }, { i64, i64 }* %20, i32 0, i32 1
  %24 = load i64, i64* %23, align 1
  %call38 = call i32 @timespec_cmp(i64 %17, i64 %19, i64 %22, i64 %24) #13
  %cmp39 = icmp sle i32 %call38, 0
  br i1 %cmp39, label %if.then.41, label %if.else

if.then.41:                                       ; preds = %if.then.36
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call42, i64* %retval
  br label %return

if.else:                                          ; preds = %if.then.36
  %25 = load %struct.timespec*, %struct.timespec** %end_time.addr, align 8
  %26 = bitcast %struct.timespec* %25 to { i64, i64 }*
  %27 = getelementptr { i64, i64 }, { i64, i64 }* %26, i32 0, i32 0
  %28 = load i64, i64* %27, align 1
  %29 = getelementptr { i64, i64 }, { i64, i64 }* %26, i32 0, i32 1
  %30 = load i64, i64* %29, align 1
  %31 = bitcast %struct.timespec* %now to { i64, i64 }*
  %32 = getelementptr { i64, i64 }, { i64, i64 }* %31, i32 0, i32 0
  %33 = load i64, i64* %32, align 1
  %34 = getelementptr { i64, i64 }, { i64, i64 }* %31, i32 0, i32 1
  %35 = load i64, i64* %34, align 1
  %call43 = call { i64, i64 } @timespec_sub(i64 %28, i64 %30, i64 %33, i64 %35) #14
  %36 = bitcast %struct.timespec* %duration to { i64, i64 }*
  %37 = getelementptr { i64, i64 }, { i64, i64 }* %36, i32 0, i32 0
  %38 = extractvalue { i64, i64 } %call43, 0
  store i64 %38, i64* %37, align 8
  %39 = getelementptr { i64, i64 }, { i64, i64 }* %36, i32 0, i32 1
  %40 = extractvalue { i64, i64 } %call43, 1
  store i64 %40, i64* %39, align 8
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %duration, i32 0, i32 0
  %41 = load i64, i64* %tv_sec, align 8
  %cmp44 = icmp slt i64 %41, 9223372036854775807
  br i1 %cmp44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %tv_sec46 = getelementptr inbounds %struct.timespec, %struct.timespec* %duration, i32 0, i32 0
  %42 = load i64, i64* %tv_sec46, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %42, %cond.true ], [ 9223372036854775807, %cond.false ]
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %duration, i32 0, i32 1
  %43 = load i64, i64* %tv_nsec, align 8
  %conv47 = trunc i64 %43 to i32
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %call49 = call i32 @wait_reading_process_output(i64 %cond, i32 %conv47, i32 -1, i1 zeroext true, i64 %call48, %struct.Lisp_Process* null, i32 0)
  br label %if.end.50

if.end.50:                                        ; preds = %cond.end
  br label %if.end.131

if.else.51:                                       ; preds = %if.end.34
  store i8 1, i8* %do_display, align 1
  %44 = load i64, i64* @selected_frame, align 8
  %call52 = call zeroext i1 @FRAMEP(i64 %44)
  br i1 %call52, label %land.lhs.true.54, label %cond.false.59

land.lhs.true.54:                                 ; preds = %if.else.51
  %45 = load i64, i64* @selected_frame, align 8
  %sub = sub nsw i64 %45, 5
  %46 = inttoptr i64 %sub to i8*
  %47 = bitcast i8* %46 to %struct.frame*
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %47, i32 0, i32 61
  %48 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp55 = icmp ne %struct.terminal* %48, null
  br i1 %cmp55, label %cond.true.57, label %cond.false.59

cond.true.57:                                     ; preds = %land.lhs.true.54
  %49 = load i64, i64* @selected_frame, align 8
  %sub58 = sub nsw i64 %49, 5
  %50 = inttoptr i64 %sub58 to i8*
  %51 = bitcast i8* %50 to %struct.frame*
  br label %cond.end.60

cond.false.59:                                    ; preds = %land.lhs.true.54, %if.else.51
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.60

cond.end.60:                                      ; preds = %52, %cond.true.57
  %cond61 = phi %struct.frame* [ %51, %cond.true.57 ], [ null, %52 ]
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %cond61, i32 0, i32 26
  %53 = bitcast i48* %output_method to i64*
  %bf.load = load i64, i64* %53, align 8
  %bf.lshr = lshr i64 %bf.load, 23
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp62 = icmp eq i32 %bf.cast, 1
  br i1 %cmp62, label %if.then.64, label %if.end.127

if.then.64:                                       ; preds = %cond.end.60
  %54 = load i64, i64* @selected_frame, align 8
  %call65 = call zeroext i1 @FRAMEP(i64 %54)
  br i1 %call65, label %land.lhs.true.67, label %cond.false.74

land.lhs.true.67:                                 ; preds = %if.then.64
  %55 = load i64, i64* @selected_frame, align 8
  %sub68 = sub nsw i64 %55, 5
  %56 = inttoptr i64 %sub68 to i8*
  %57 = bitcast i8* %56 to %struct.frame*
  %terminal69 = getelementptr inbounds %struct.frame, %struct.frame* %57, i32 0, i32 61
  %58 = load %struct.terminal*, %struct.terminal** %terminal69, align 8
  %cmp70 = icmp ne %struct.terminal* %58, null
  br i1 %cmp70, label %cond.true.72, label %cond.false.74

cond.true.72:                                     ; preds = %land.lhs.true.67
  %59 = load i64, i64* @selected_frame, align 8
  %sub73 = sub nsw i64 %59, 5
  %60 = inttoptr i64 %sub73 to i8*
  %61 = bitcast i8* %60 to %struct.frame*
  br label %cond.end.75

cond.false.74:                                    ; preds = %land.lhs.true.67, %if.then.64
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.75

cond.end.75:                                      ; preds = %62, %cond.true.72
  %cond76 = phi %struct.frame* [ %61, %cond.true.72 ], [ null, %62 ]
  %output_method77 = getelementptr inbounds %struct.frame, %struct.frame* %cond76, i32 0, i32 26
  %63 = bitcast i48* %output_method77 to i64*
  %bf.load78 = load i64, i64* %63, align 8
  %bf.lshr79 = lshr i64 %bf.load78, 23
  %bf.clear80 = and i64 %bf.lshr79, 7
  %bf.cast81 = trunc i64 %bf.clear80 to i32
  %cmp82 = icmp eq i32 %bf.cast81, 1
  br i1 %cmp82, label %cond.true.103, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end.75
  %64 = load i64, i64* @selected_frame, align 8
  %call84 = call zeroext i1 @FRAMEP(i64 %64)
  br i1 %call84, label %land.lhs.true.86, label %cond.false.93

land.lhs.true.86:                                 ; preds = %lor.lhs.false
  %65 = load i64, i64* @selected_frame, align 8
  %sub87 = sub nsw i64 %65, 5
  %66 = inttoptr i64 %sub87 to i8*
  %67 = bitcast i8* %66 to %struct.frame*
  %terminal88 = getelementptr inbounds %struct.frame, %struct.frame* %67, i32 0, i32 61
  %68 = load %struct.terminal*, %struct.terminal** %terminal88, align 8
  %cmp89 = icmp ne %struct.terminal* %68, null
  br i1 %cmp89, label %cond.true.91, label %cond.false.93

cond.true.91:                                     ; preds = %land.lhs.true.86
  %69 = load i64, i64* @selected_frame, align 8
  %sub92 = sub nsw i64 %69, 5
  %70 = inttoptr i64 %sub92 to i8*
  %71 = bitcast i8* %70 to %struct.frame*
  br label %cond.end.94

cond.false.93:                                    ; preds = %land.lhs.true.86, %lor.lhs.false
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.94

cond.end.94:                                      ; preds = %72, %cond.true.91
  %cond95 = phi %struct.frame* [ %71, %cond.true.91 ], [ null, %72 ]
  %output_method96 = getelementptr inbounds %struct.frame, %struct.frame* %cond95, i32 0, i32 26
  %73 = bitcast i48* %output_method96 to i64*
  %bf.load97 = load i64, i64* %73, align 8
  %bf.lshr98 = lshr i64 %bf.load97, 23
  %bf.clear99 = and i64 %bf.lshr98, 7
  %bf.cast100 = trunc i64 %bf.clear99 to i32
  %cmp101 = icmp eq i32 %bf.cast100, 3
  br i1 %cmp101, label %cond.true.103, label %cond.false.118

cond.true.103:                                    ; preds = %cond.end.94, %cond.end.75
  %74 = load i64, i64* @selected_frame, align 8
  %call104 = call zeroext i1 @FRAMEP(i64 %74)
  br i1 %call104, label %land.lhs.true.106, label %cond.false.113

land.lhs.true.106:                                ; preds = %cond.true.103
  %75 = load i64, i64* @selected_frame, align 8
  %sub107 = sub nsw i64 %75, 5
  %76 = inttoptr i64 %sub107 to i8*
  %77 = bitcast i8* %76 to %struct.frame*
  %terminal108 = getelementptr inbounds %struct.frame, %struct.frame* %77, i32 0, i32 61
  %78 = load %struct.terminal*, %struct.terminal** %terminal108, align 8
  %cmp109 = icmp ne %struct.terminal* %78, null
  br i1 %cmp109, label %cond.true.111, label %cond.false.113

cond.true.111:                                    ; preds = %land.lhs.true.106
  %79 = load i64, i64* @selected_frame, align 8
  %sub112 = sub nsw i64 %79, 5
  %80 = inttoptr i64 %sub112 to i8*
  %81 = bitcast i8* %80 to %struct.frame*
  br label %cond.end.114

cond.false.113:                                   ; preds = %land.lhs.true.106, %cond.true.103
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.114

cond.end.114:                                     ; preds = %82, %cond.true.111
  %cond115 = phi %struct.frame* [ %81, %cond.true.111 ], [ null, %82 ]
  %terminal116 = getelementptr inbounds %struct.frame, %struct.frame* %cond115, i32 0, i32 61
  %83 = load %struct.terminal*, %struct.terminal** %terminal116, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %83, i32 0, i32 12
  %tty117 = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %84 = load %struct.tty_display_info*, %struct.tty_display_info** %tty117, align 8
  br label %cond.end.119

cond.false.118:                                   ; preds = %cond.end.94
  call void @emacs_abort() #11
  unreachable
                                                  ; No predecessors!
  br label %cond.end.119

cond.end.119:                                     ; preds = %85, %cond.end.114
  %cond120 = phi %struct.tty_display_info* [ %84, %cond.end.114 ], [ null, %85 ]
  store %struct.tty_display_info* %cond120, %struct.tty_display_info** %tty, align 8
  %86 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %showing_menu = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %86, i32 0, i32 75
  %bf.load121 = load i8, i8* %showing_menu, align 4
  %bf.lshr122 = lshr i8 %bf.load121, 2
  %bf.clear123 = and i8 %bf.lshr122, 1
  %bf.cast124 = trunc i8 %bf.clear123 to i1
  br i1 %bf.cast124, label %if.then.125, label %if.end.126

if.then.125:                                      ; preds = %cond.end.119
  store i8 0, i8* %do_display, align 1
  br label %if.end.126

if.end.126:                                       ; preds = %if.then.125, %cond.end.119
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %cond.end.60
  %87 = load i8, i8* %do_display, align 1
  %tobool128 = trunc i8 %87 to i1
  %call129 = call i64 @builtin_lisp_symbol(i32 0)
  %call130 = call i32 @wait_reading_process_output(i64 0, i32 0, i32 -1, i1 zeroext %tobool128, i64 %call129, %struct.Lisp_Process* null, i32 0)
  br label %if.end.131

if.end.131:                                       ; preds = %if.end.127, %if.end.50
  %88 = load i8, i8* @interrupt_input, align 1
  %tobool132 = trunc i8 %88 to i1
  br i1 %tobool132, label %if.end.138, label %land.lhs.true.133

land.lhs.true.133:                                ; preds = %if.end.131
  %89 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %90 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp134 = icmp eq %union.buffered_input_event* %89, %90
  br i1 %cmp134, label %if.then.136, label %if.end.138

if.then.136:                                      ; preds = %land.lhs.true.133
  %call137 = call i32 @gobble_input()
  br label %if.end.138

if.end.138:                                       ; preds = %if.then.136, %land.lhs.true.133, %if.end.131
  br label %for.cond

for.end:                                          ; preds = %if.then.33, %if.then.25, %if.then.15, %if.then.8, %if.then.4
  %91 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %and139 = and i64 %91, 7
  %conv140 = trunc i64 %and139 to i32
  %cmp141 = icmp eq i32 %conv140, 3
  br i1 %cmp141, label %if.then.143, label %if.end.146

if.then.143:                                      ; preds = %for.end
  %92 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub144 = sub nsw i64 %92, 3
  %93 = inttoptr i64 %sub144 to i8*
  %94 = bitcast i8* %93 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %94, i32 0, i32 0
  %95 = load i64, i64* %car, align 8
  store i64 %95, i64* %first, align 8
  %96 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %sub145 = sub nsw i64 %96, 3
  %97 = inttoptr i64 %sub145 to i8*
  %98 = bitcast i8* %97 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %98, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %99 = load i64, i64* %cdr, align 8
  store i64 %99, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 315), align 8
  %100 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %101 = load %struct.kboard**, %struct.kboard*** %kbp.addr, align 8
  store %struct.kboard* %100, %struct.kboard** %101, align 8
  %102 = load i64, i64* %first, align 8
  store i64 %102, i64* %retval
  br label %return

if.end.146:                                       ; preds = %for.end
  %103 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %104 = load volatile %union.buffered_input_event*, %union.buffered_input_event** @kbd_store_ptr, align 8
  %cmp147 = icmp ne %union.buffered_input_event* %103, %104
  br i1 %cmp147, label %if.then.149, label %if.else.419

if.then.149:                                      ; preds = %if.end.146
  %105 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %cmp150 = icmp ult %union.buffered_input_event* %105, getelementptr inbounds (%union.buffered_input_event, %union.buffered_input_event* getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), i64 4096)
  br i1 %cmp150, label %cond.true.152, label %cond.false.153

cond.true.152:                                    ; preds = %if.then.149
  %106 = load %union.buffered_input_event*, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %cond.end.154

cond.false.153:                                   ; preds = %if.then.149
  br label %cond.end.154

cond.end.154:                                     ; preds = %cond.false.153, %cond.true.152
  %cond155 = phi %union.buffered_input_event* [ %106, %cond.true.152 ], [ getelementptr inbounds ([4096 x %union.buffered_input_event], [4096 x %union.buffered_input_event]* @kbd_buffer, i32 0, i32 0), %cond.false.153 ]
  store %union.buffered_input_event* %cond155, %union.buffered_input_event** %event, align 8
  %107 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie = bitcast %union.buffered_input_event* %107 to %struct.input_event*
  %call156 = call %struct.kboard* @event_to_kboard(%struct.input_event* %ie)
  %108 = load %struct.kboard**, %struct.kboard*** %kbp.addr, align 8
  store %struct.kboard* %call156, %struct.kboard** %108, align 8
  %109 = load %struct.kboard**, %struct.kboard*** %kbp.addr, align 8
  %110 = load %struct.kboard*, %struct.kboard** %109, align 8
  %cmp157 = icmp eq %struct.kboard* %110, null
  br i1 %cmp157, label %if.then.159, label %if.end.160

if.then.159:                                      ; preds = %cond.end.154
  %111 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %112 = load %struct.kboard**, %struct.kboard*** %kbp.addr, align 8
  store %struct.kboard* %111, %struct.kboard** %112, align 8
  br label %if.end.160

if.end.160:                                       ; preds = %if.then.159, %cond.end.154
  %call161 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call161, i64* %obj, align 8
  %113 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %114 = bitcast %union.buffered_input_event* %113 to i16*
  %bf.load162 = load i16, i16* %114, align 8
  %bf.cast163 = zext i16 %bf.load162 to i32
  %cmp164 = icmp eq i32 %bf.cast163, 10
  br i1 %cmp164, label %if.then.171, label %lor.lhs.false.166

lor.lhs.false.166:                                ; preds = %if.end.160
  %115 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %116 = bitcast %union.buffered_input_event* %115 to i16*
  %bf.load167 = load i16, i16* %116, align 8
  %bf.cast168 = zext i16 %bf.load167 to i32
  %cmp169 = icmp eq i32 %bf.cast168, 11
  br i1 %cmp169, label %if.then.171, label %if.else.173

if.then.171:                                      ; preds = %lor.lhs.false.166, %if.end.160
  %117 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %sie = bitcast %union.buffered_input_event* %117 to %struct.selection_input_event*
  %118 = bitcast %struct.selection_input_event* %copy to i8*
  %119 = bitcast %struct.selection_input_event* %sie to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %118, i8* %119, i64 56, i32 8, i1 false)
  %120 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %120, i64 1
  store %union.buffered_input_event* %add.ptr, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %call172 = call zeroext i1 @readable_events(i32 0)
  %frombool = zext i1 %call172 to i8
  store i8 %frombool, i8* @input_pending, align 1
  call void @x_handle_selection_event(%struct.selection_input_event* %copy)
  br label %if.end.418

if.else.173:                                      ; preds = %lor.lhs.false.166
  %121 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %122 = bitcast %union.buffered_input_event* %121 to i16*
  %bf.load174 = load i16, i16* %122, align 8
  %bf.cast175 = zext i16 %bf.load174 to i32
  %cmp176 = icmp eq i32 %bf.cast175, 13
  br i1 %cmp176, label %if.then.178, label %if.else.184

if.then.178:                                      ; preds = %if.else.173
  %call179 = call i64 @builtin_lisp_symbol(i32 334)
  %123 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie180 = bitcast %union.buffered_input_event* %123 to %struct.input_event*
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %ie180, i32 0, i32 6
  %124 = load i64, i64* %frame_or_window, align 8
  %call181 = call i64 @list1(i64 %124)
  %call182 = call i64 @list2(i64 %call179, i64 %call181)
  store i64 %call182, i64* %obj, align 8
  %125 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr183 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %125, i64 1
  store %union.buffered_input_event* %add.ptr183, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.417

if.else.184:                                      ; preds = %if.else.173
  %126 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %127 = bitcast %union.buffered_input_event* %126 to i16*
  %bf.load185 = load i16, i16* %127, align 8
  %bf.cast186 = zext i16 %bf.load185 to i32
  %cmp187 = icmp eq i32 %bf.cast186, 15
  br i1 %cmp187, label %if.then.189, label %if.else.196

if.then.189:                                      ; preds = %if.else.184
  %call190 = call i64 @builtin_lisp_symbol(i32 533)
  %128 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie191 = bitcast %union.buffered_input_event* %128 to %struct.input_event*
  %frame_or_window192 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie191, i32 0, i32 6
  %129 = load i64, i64* %frame_or_window192, align 8
  %call193 = call i64 @list1(i64 %129)
  %call194 = call i64 @list2(i64 %call190, i64 %call193)
  store i64 %call194, i64* %obj, align 8
  %130 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr195 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %130, i64 1
  store %union.buffered_input_event* %add.ptr195, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.416

if.else.196:                                      ; preds = %if.else.184
  %131 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %132 = bitcast %union.buffered_input_event* %131 to i16*
  %bf.load197 = load i16, i16* %132, align 8
  %bf.cast198 = zext i16 %bf.load197 to i32
  %cmp199 = icmp eq i32 %bf.cast198, 16
  br i1 %cmp199, label %if.then.201, label %if.else.208

if.then.201:                                      ; preds = %if.else.196
  %call202 = call i64 @builtin_lisp_symbol(i32 640)
  %133 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie203 = bitcast %union.buffered_input_event* %133 to %struct.input_event*
  %frame_or_window204 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie203, i32 0, i32 6
  %134 = load i64, i64* %frame_or_window204, align 8
  %call205 = call i64 @list1(i64 %134)
  %call206 = call i64 @list2(i64 %call202, i64 %call205)
  store i64 %call206, i64* %obj, align 8
  %135 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr207 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %135, i64 1
  store %union.buffered_input_event* %add.ptr207, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.415

if.else.208:                                      ; preds = %if.else.196
  %136 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %137 = bitcast %union.buffered_input_event* %136 to i16*
  %bf.load209 = load i16, i16* %137, align 8
  %bf.cast210 = zext i16 %bf.load209 to i32
  %cmp211 = icmp eq i32 %bf.cast210, 12
  br i1 %cmp211, label %if.then.213, label %if.else.216

if.then.213:                                      ; preds = %if.else.208
  %138 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %139 = bitcast %struct.buffer* %138 to i8*
  %call214 = call i64 @make_lisp_ptr(i8* %139, i32 5)
  store i64 %call214, i64* %obj, align 8
  %140 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr215 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %140, i64 1
  store %union.buffered_input_event* %add.ptr215, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.414

if.else.216:                                      ; preds = %if.else.208
  %141 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %142 = bitcast %union.buffered_input_event* %141 to i16*
  %bf.load217 = load i16, i16* %142, align 8
  %bf.cast218 = zext i16 %bf.load217 to i32
  %cmp219 = icmp eq i32 %bf.cast218, 17
  br i1 %cmp219, label %if.then.221, label %if.else.236

if.then.221:                                      ; preds = %if.else.216
  %143 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr222 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %143, i64 1
  store %union.buffered_input_event* %add.ptr222, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %call223 = call zeroext i1 @readable_events(i32 0)
  %frombool224 = zext i1 %call223 to i8
  store i8 %frombool224, i8* @input_pending, align 1
  %144 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie225 = bitcast %union.buffered_input_event* %144 to %struct.input_event*
  %frame_or_window226 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie225, i32 0, i32 6
  %145 = load i64, i64* %frame_or_window226, align 8
  %sub227 = sub nsw i64 %145, 5
  %146 = inttoptr i64 %sub227 to i8*
  %147 = bitcast i8* %146 to %struct.frame*
  %terminal228 = getelementptr inbounds %struct.frame, %struct.frame* %147, i32 0, i32 61
  %148 = load %struct.terminal*, %struct.terminal** %terminal228, align 8
  %cmp229 = icmp ne %struct.terminal* %148, null
  br i1 %cmp229, label %if.then.231, label %if.end.235

if.then.231:                                      ; preds = %if.then.221
  %149 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie232 = bitcast %union.buffered_input_event* %149 to %struct.input_event*
  %frame_or_window233 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie232, i32 0, i32 6
  %150 = load i64, i64* %frame_or_window233, align 8
  %sub234 = sub nsw i64 %150, 5
  %151 = inttoptr i64 %sub234 to i8*
  %152 = bitcast i8* %151 to %struct.frame*
  call void @x_activate_menubar(%struct.frame* %152)
  br label %if.end.235

if.end.235:                                       ; preds = %if.then.231, %if.then.221
  br label %if.end.413

if.else.236:                                      ; preds = %if.else.216
  %153 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %154 = bitcast %union.buffered_input_event* %153 to i16*
  %bf.load237 = load i16, i16* %154, align 8
  %bf.cast238 = zext i16 %bf.load237 to i32
  %cmp239 = icmp eq i32 %bf.cast238, 27
  br i1 %cmp239, label %if.then.241, label %if.else.245

if.then.241:                                      ; preds = %if.else.236
  %155 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie242 = bitcast %union.buffered_input_event* %155 to %struct.input_event*
  %call243 = call i64 @make_lispy_event(%struct.input_event* %ie242)
  store i64 %call243, i64* %obj, align 8
  %156 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr244 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %156, i64 1
  store %union.buffered_input_event* %add.ptr244, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.412

if.else.245:                                      ; preds = %if.else.236
  %157 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %158 = bitcast %union.buffered_input_event* %157 to i16*
  %bf.load246 = load i16, i16* %158, align 8
  %bf.cast247 = zext i16 %bf.load246 to i32
  %cmp248 = icmp eq i32 %bf.cast247, 25
  br i1 %cmp248, label %if.then.250, label %if.else.255

if.then.250:                                      ; preds = %if.else.245
  %call251 = call i64 @builtin_lisp_symbol(i32 827)
  %159 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie252 = bitcast %union.buffered_input_event* %159 to %struct.input_event*
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %ie252, i32 0, i32 7
  %160 = load i64, i64* %arg, align 8
  %call253 = call i64 @list2(i64 %call251, i64 %160)
  store i64 %call253, i64* %obj, align 8
  %161 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr254 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %161, i64 1
  store %union.buffered_input_event* %add.ptr254, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.411

if.else.255:                                      ; preds = %if.else.245
  %162 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %163 = bitcast %union.buffered_input_event* %162 to i16*
  %bf.load256 = load i16, i16* %163, align 8
  %bf.cast257 = zext i16 %bf.load256 to i32
  %cmp258 = icmp eq i32 %bf.cast257, 0
  br i1 %cmp258, label %if.then.260, label %if.else.262

if.then.260:                                      ; preds = %if.else.255
  %164 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr261 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %164, i64 1
  store %union.buffered_input_event* %add.ptr261, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.410

if.else.262:                                      ; preds = %if.else.255
  %165 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %166 = bitcast %union.buffered_input_event* %165 to i16*
  %bf.load263 = load i16, i16* %166, align 8
  %bf.cast264 = zext i16 %bf.load263 to i32
  %cmp265 = icmp eq i32 %bf.cast264, 20
  br i1 %cmp265, label %if.then.267, label %if.else.284

if.then.267:                                      ; preds = %if.else.262
  %167 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie268 = bitcast %union.buffered_input_event* %167 to %struct.input_event*
  %frame_or_window269 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie268, i32 0, i32 6
  %168 = load i64, i64* %frame_or_window269, align 8
  store i64 %168, i64* %frame, align 8
  %169 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie270 = bitcast %union.buffered_input_event* %169 to %struct.input_event*
  %arg271 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie270, i32 0, i32 7
  %170 = load i64, i64* %arg271, align 8
  store i64 %170, i64* %object, align 8
  %171 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie272 = bitcast %union.buffered_input_event* %171 to %struct.input_event*
  %timestamp = getelementptr inbounds %struct.input_event, %struct.input_event* %ie272, i32 0, i32 5
  %172 = load i64, i64* %timestamp, align 8
  %call273 = call i64 @Time_to_position(i64 %172)
  %shl = shl i64 %call273, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %position, align 8
  %173 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie274 = bitcast %union.buffered_input_event* %173 to %struct.input_event*
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %ie274, i32 0, i32 3
  %174 = load i64, i64* %x, align 8
  store i64 %174, i64* %window, align 8
  %175 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie275 = bitcast %union.buffered_input_event* %175 to %struct.input_event*
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %ie275, i32 0, i32 4
  %176 = load i64, i64* %y, align 8
  store i64 %176, i64* %help, align 8
  %177 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  call void @clear_event(%union.buffered_input_event* %177)
  %178 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr276 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %178, i64 1
  store %union.buffered_input_event* %add.ptr276, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  %179 = load i64, i64* %window, align 8
  %call277 = call zeroext i1 @WINDOWP(i64 %179)
  br i1 %call277, label %if.end.280, label %if.then.278

if.then.278:                                      ; preds = %if.then.267
  %call279 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call279, i64* %window, align 8
  br label %if.end.280

if.end.280:                                       ; preds = %if.then.278, %if.then.267
  %call281 = call i64 @builtin_lisp_symbol(i32 516)
  %180 = load i64, i64* %frame, align 8
  %181 = load i64, i64* %help, align 8
  %182 = load i64, i64* %window, align 8
  %183 = load i64, i64* %object, align 8
  %184 = load i64, i64* %position, align 8
  %call282 = call i64 @list5(i64 %180, i64 %181, i64 %182, i64 %183, i64 %184)
  %call283 = call i64 @Fcons(i64 %call281, i64 %call282)
  store i64 %call283, i64* %obj, align 8
  br label %if.end.409

if.else.284:                                      ; preds = %if.else.262
  %185 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %186 = bitcast %union.buffered_input_event* %185 to i16*
  %bf.load285 = load i16, i16* %186, align 8
  %bf.cast286 = zext i16 %bf.load285 to i32
  %cmp287 = icmp eq i32 %bf.cast286, 22
  br i1 %cmp287, label %if.then.289, label %if.else.314

if.then.289:                                      ; preds = %if.else.284
  %187 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie291 = bitcast %union.buffered_input_event* %187 to %struct.input_event*
  %frame_or_window292 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie291, i32 0, i32 6
  %188 = load i64, i64* %frame_or_window292, align 8
  store i64 %188, i64* %frame290, align 8
  %189 = load i64, i64* %frame290, align 8
  %sub293 = sub nsw i64 %189, 5
  %190 = inttoptr i64 %sub293 to i8*
  %191 = bitcast i8* %190 to %struct.frame*
  %focus_frame = getelementptr inbounds %struct.frame, %struct.frame* %191, i32 0, i32 4
  %192 = load i64, i64* %focus_frame, align 8
  store i64 %192, i64* %focus, align 8
  %193 = load i64, i64* %focus, align 8
  %call294 = call zeroext i1 @FRAMEP(i64 %193)
  br i1 %call294, label %if.then.295, label %if.end.296

if.then.295:                                      ; preds = %if.then.289
  %194 = load i64, i64* %focus, align 8
  store i64 %194, i64* %frame290, align 8
  br label %if.end.296

if.end.296:                                       ; preds = %if.then.295, %if.then.289
  %195 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie297 = bitcast %union.buffered_input_event* %195 to %struct.input_event*
  %arg298 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie297, i32 0, i32 7
  %196 = load i64, i64* %arg298, align 8
  %call299 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp300 = icmp eq i64 %196, %call299
  br i1 %cmp300, label %if.else.310, label %land.lhs.true.302

land.lhs.true.302:                                ; preds = %if.end.296
  %197 = load i64, i64* %frame290, align 8
  %198 = load i64, i64* @internal_last_event_frame, align 8
  %cmp303 = icmp eq i64 %197, %198
  br i1 %cmp303, label %if.else.310, label %land.lhs.true.305

land.lhs.true.305:                                ; preds = %land.lhs.true.302
  %199 = load i64, i64* %frame290, align 8
  %200 = load i64, i64* @selected_frame, align 8
  %cmp306 = icmp eq i64 %199, %200
  br i1 %cmp306, label %if.else.310, label %if.then.308

if.then.308:                                      ; preds = %land.lhs.true.305
  %201 = load i64, i64* %frame290, align 8
  %call309 = call i64 @make_lispy_switch_frame(i64 %201)
  store i64 %call309, i64* %obj, align 8
  br label %if.end.312

if.else.310:                                      ; preds = %land.lhs.true.305, %land.lhs.true.302, %if.end.296
  %202 = load i64, i64* %frame290, align 8
  %call311 = call i64 @make_lispy_focus_in(i64 %202)
  store i64 %call311, i64* %obj, align 8
  br label %if.end.312

if.end.312:                                       ; preds = %if.else.310, %if.then.308
  %203 = load i64, i64* %frame290, align 8
  store i64 %203, i64* @internal_last_event_frame, align 8
  %204 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr313 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %204, i64 1
  store %union.buffered_input_event* %add.ptr313, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.408

if.else.314:                                      ; preds = %if.else.284
  %205 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %206 = bitcast %union.buffered_input_event* %205 to i16*
  %bf.load315 = load i16, i16* %206, align 8
  %bf.cast316 = zext i16 %bf.load315 to i32
  %cmp317 = icmp eq i32 %bf.cast316, 23
  br i1 %cmp317, label %if.then.319, label %if.else.335

if.then.319:                                      ; preds = %if.else.314
  %207 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie321 = bitcast %union.buffered_input_event* %207 to %struct.input_event*
  %frame_or_window322 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie321, i32 0, i32 6
  %208 = load i64, i64* %frame_or_window322, align 8
  store i64 %208, i64* %frame320, align 8
  store i8 0, i8* %focused, align 1
  %209 = load %struct.x_display_info*, %struct.x_display_info** @x_display_list, align 8
  store %struct.x_display_info* %209, %struct.x_display_info** %di, align 8
  br label %for.cond.323

for.cond.323:                                     ; preds = %for.inc, %if.then.319
  %210 = load %struct.x_display_info*, %struct.x_display_info** %di, align 8
  %tobool324 = icmp ne %struct.x_display_info* %210, null
  br i1 %tobool324, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond.323
  %211 = load i8, i8* %focused, align 1
  %tobool325 = trunc i8 %211 to i1
  %lnot = xor i1 %tobool325, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.323
  %212 = phi i1 [ false, %for.cond.323 ], [ %lnot, %land.rhs ]
  br i1 %212, label %for.body, label %for.end.329

for.body:                                         ; preds = %land.end
  %213 = load %struct.x_display_info*, %struct.x_display_info** %di, align 8
  %x_highlight_frame = getelementptr inbounds %struct.x_display_info, %struct.x_display_info* %213, i32 0, i32 73
  %214 = load %struct.frame*, %struct.frame** %x_highlight_frame, align 8
  %cmp326 = icmp ne %struct.frame* %214, null
  %frombool328 = zext i1 %cmp326 to i8
  store i8 %frombool328, i8* %focused, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %215 = load %struct.x_display_info*, %struct.x_display_info** %di, align 8
  %next = getelementptr inbounds %struct.x_display_info, %struct.x_display_info* %215, i32 0, i32 0
  %216 = load %struct.x_display_info*, %struct.x_display_info** %next, align 8
  store %struct.x_display_info* %216, %struct.x_display_info** %di, align 8
  br label %for.cond.323

for.end.329:                                      ; preds = %land.end
  %217 = load i8, i8* %focused, align 1
  %tobool330 = trunc i8 %217 to i1
  br i1 %tobool330, label %if.end.333, label %if.then.331

if.then.331:                                      ; preds = %for.end.329
  %218 = load i64, i64* %frame320, align 8
  %call332 = call i64 @make_lispy_focus_out(i64 %218)
  store i64 %call332, i64* %obj, align 8
  br label %if.end.333

if.end.333:                                       ; preds = %if.then.331, %for.end.329
  %219 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr334 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %219, i64 1
  store %union.buffered_input_event* %add.ptr334, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.407

if.else.335:                                      ; preds = %if.else.314
  %220 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %221 = bitcast %union.buffered_input_event* %220 to i16*
  %bf.load336 = load i16, i16* %221, align 8
  %bf.cast337 = zext i16 %bf.load336 to i32
  %cmp338 = icmp eq i32 %bf.cast337, 26
  br i1 %cmp338, label %if.then.340, label %if.else.344

if.then.340:                                      ; preds = %if.else.335
  %222 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie341 = bitcast %union.buffered_input_event* %222 to %struct.input_event*
  %call342 = call i64 @make_lispy_event(%struct.input_event* %ie341)
  store i64 %call342, i64* %obj, align 8
  %223 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr343 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %223, i64 1
  store %union.buffered_input_event* %add.ptr343, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.406

if.else.344:                                      ; preds = %if.else.335
  %224 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie347 = bitcast %union.buffered_input_event* %224 to %struct.input_event*
  %frame_or_window348 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie347, i32 0, i32 6
  %225 = load i64, i64* %frame_or_window348, align 8
  store i64 %225, i64* %frame345, align 8
  %226 = load i64, i64* %frame345, align 8
  %and349 = and i64 %226, 7
  %conv350 = trunc i64 %and349 to i32
  %cmp351 = icmp eq i32 %conv350, 3
  br i1 %cmp351, label %if.then.353, label %if.else.356

if.then.353:                                      ; preds = %if.else.344
  %227 = load i64, i64* %frame345, align 8
  %sub354 = sub nsw i64 %227, 3
  %228 = inttoptr i64 %sub354 to i8*
  %229 = bitcast i8* %228 to %struct.Lisp_Cons*
  %car355 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %229, i32 0, i32 0
  %230 = load i64, i64* %car355, align 8
  store i64 %230, i64* %frame345, align 8
  br label %if.end.362

if.else.356:                                      ; preds = %if.else.344
  %231 = load i64, i64* %frame345, align 8
  %call357 = call zeroext i1 @WINDOWP(i64 %231)
  br i1 %call357, label %if.then.358, label %if.end.361

if.then.358:                                      ; preds = %if.else.356
  %232 = load i64, i64* %frame345, align 8
  %call359 = call %struct.window* @XWINDOW(i64 %232)
  %frame360 = getelementptr inbounds %struct.window, %struct.window* %call359, i32 0, i32 1
  %233 = load i64, i64* %frame360, align 8
  store i64 %233, i64* %frame345, align 8
  br label %if.end.361

if.end.361:                                       ; preds = %if.then.358, %if.else.356
  br label %if.end.362

if.end.362:                                       ; preds = %if.end.361, %if.then.353
  %234 = load i64, i64* %frame345, align 8
  %sub363 = sub nsw i64 %234, 5
  %235 = inttoptr i64 %sub363 to i8*
  %236 = bitcast i8* %235 to %struct.frame*
  %focus_frame364 = getelementptr inbounds %struct.frame, %struct.frame* %236, i32 0, i32 4
  %237 = load i64, i64* %focus_frame364, align 8
  store i64 %237, i64* %focus346, align 8
  %238 = load i64, i64* %focus346, align 8
  %call365 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp366 = icmp eq i64 %238, %call365
  br i1 %cmp366, label %if.end.369, label %if.then.368

if.then.368:                                      ; preds = %if.end.362
  %239 = load i64, i64* %focus346, align 8
  store i64 %239, i64* %frame345, align 8
  br label %if.end.369

if.end.369:                                       ; preds = %if.then.368, %if.end.362
  %240 = load i64, i64* %frame345, align 8
  %241 = load i64, i64* @internal_last_event_frame, align 8
  %cmp370 = icmp eq i64 %240, %241
  br i1 %cmp370, label %if.end.377, label %land.lhs.true.372

land.lhs.true.372:                                ; preds = %if.end.369
  %242 = load i64, i64* %frame345, align 8
  %243 = load i64, i64* @selected_frame, align 8
  %cmp373 = icmp eq i64 %242, %243
  br i1 %cmp373, label %if.end.377, label %if.then.375

if.then.375:                                      ; preds = %land.lhs.true.372
  %244 = load i64, i64* %frame345, align 8
  %call376 = call i64 @make_lispy_switch_frame(i64 %244)
  store i64 %call376, i64* %obj, align 8
  br label %if.end.377

if.end.377:                                       ; preds = %if.then.375, %land.lhs.true.372, %if.end.369
  %245 = load i64, i64* %frame345, align 8
  store i64 %245, i64* @internal_last_event_frame, align 8
  %246 = load i64, i64* %obj, align 8
  %call378 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp379 = icmp eq i64 %246, %call378
  br i1 %cmp379, label %if.then.381, label %if.end.405

if.then.381:                                      ; preds = %if.end.377
  %247 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie382 = bitcast %union.buffered_input_event* %247 to %struct.input_event*
  %call383 = call i64 @make_lispy_event(%struct.input_event* %ie382)
  store i64 %call383, i64* %obj, align 8
  %248 = load i8*, i8** %used_mouse_menu.addr, align 8
  %tobool384 = icmp ne i8* %248, null
  br i1 %tobool384, label %land.lhs.true.385, label %if.end.403

land.lhs.true.385:                                ; preds = %if.then.381
  %249 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie386 = bitcast %union.buffered_input_event* %249 to %struct.input_event*
  %frame_or_window387 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie386, i32 0, i32 6
  %250 = load i64, i64* %frame_or_window387, align 8
  %251 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %ie388 = bitcast %union.buffered_input_event* %251 to %struct.input_event*
  %arg389 = getelementptr inbounds %struct.input_event, %struct.input_event* %ie388, i32 0, i32 7
  %252 = load i64, i64* %arg389, align 8
  %cmp390 = icmp eq i64 %250, %252
  br i1 %cmp390, label %if.end.403, label %land.lhs.true.392

land.lhs.true.392:                                ; preds = %land.lhs.true.385
  %253 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %254 = bitcast %union.buffered_input_event* %253 to i16*
  %bf.load393 = load i16, i16* %254, align 8
  %bf.cast394 = zext i16 %bf.load393 to i32
  %cmp395 = icmp eq i32 %bf.cast394, 14
  br i1 %cmp395, label %if.then.402, label %lor.lhs.false.397

lor.lhs.false.397:                                ; preds = %land.lhs.true.392
  %255 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %256 = bitcast %union.buffered_input_event* %255 to i16*
  %bf.load398 = load i16, i16* %256, align 8
  %bf.cast399 = zext i16 %bf.load398 to i32
  %cmp400 = icmp eq i32 %bf.cast399, 21
  br i1 %cmp400, label %if.then.402, label %if.end.403

if.then.402:                                      ; preds = %lor.lhs.false.397, %land.lhs.true.392
  %257 = load i8*, i8** %used_mouse_menu.addr, align 8
  store i8 1, i8* %257, align 1
  br label %if.end.403

if.end.403:                                       ; preds = %if.then.402, %lor.lhs.false.397, %land.lhs.true.385, %if.then.381
  %258 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  call void @clear_event(%union.buffered_input_event* %258)
  %259 = load %union.buffered_input_event*, %union.buffered_input_event** %event, align 8
  %add.ptr404 = getelementptr inbounds %union.buffered_input_event, %union.buffered_input_event* %259, i64 1
  store %union.buffered_input_event* %add.ptr404, %union.buffered_input_event** @kbd_fetch_ptr, align 8
  br label %if.end.405

if.end.405:                                       ; preds = %if.end.403, %if.end.377
  br label %if.end.406

if.end.406:                                       ; preds = %if.end.405, %if.then.340
  br label %if.end.407

if.end.407:                                       ; preds = %if.end.406, %if.end.333
  br label %if.end.408

if.end.408:                                       ; preds = %if.end.407, %if.end.312
  br label %if.end.409

if.end.409:                                       ; preds = %if.end.408, %if.end.280
  br label %if.end.410

if.end.410:                                       ; preds = %if.end.409, %if.then.260
  br label %if.end.411

if.end.411:                                       ; preds = %if.end.410, %if.then.250
  br label %if.end.412

if.end.412:                                       ; preds = %if.end.411, %if.then.241
  br label %if.end.413

if.end.413:                                       ; preds = %if.end.412, %if.end.235
  br label %if.end.414

if.end.414:                                       ; preds = %if.end.413, %if.then.213
  br label %if.end.415

if.end.415:                                       ; preds = %if.end.414, %if.then.201
  br label %if.end.416

if.end.416:                                       ; preds = %if.end.415, %if.then.189
  br label %if.end.417

if.end.417:                                       ; preds = %if.end.416, %if.then.178
  br label %if.end.418

if.end.418:                                       ; preds = %if.end.417, %if.then.171
  br label %if.end.475

if.else.419:                                      ; preds = %if.end.146
  %260 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 368), align 8
  %call420 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp421 = icmp eq i64 %260, %call420
  br i1 %cmp421, label %if.else.473, label %land.lhs.true.423

land.lhs.true.423:                                ; preds = %if.else.419
  %call424 = call %struct.frame* @some_mouse_moved()
  %tobool425 = icmp ne %struct.frame* %call424, null
  br i1 %tobool425, label %if.then.426, label %if.else.473

if.then.426:                                      ; preds = %land.lhs.true.423
  %call427 = call %struct.frame* @some_mouse_moved()
  store %struct.frame* %call427, %struct.frame** %f, align 8
  %261 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %262 = load %struct.kboard**, %struct.kboard*** %kbp.addr, align 8
  store %struct.kboard* %261, %struct.kboard** %262, align 8
  %call430 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call430, i64* %x428, align 8
  %263 = load %struct.frame*, %struct.frame** %f, align 8
  %tobool431 = icmp ne %struct.frame* %263, null
  br i1 %tobool431, label %land.lhs.true.432, label %if.end.438

land.lhs.true.432:                                ; preds = %if.then.426
  %264 = load %struct.frame*, %struct.frame** %f, align 8
  %terminal433 = getelementptr inbounds %struct.frame, %struct.frame* %264, i32 0, i32 61
  %265 = load %struct.terminal*, %struct.terminal** %terminal433, align 8
  %mouse_position_hook = getelementptr inbounds %struct.terminal, %struct.terminal* %265, i32 0, i32 32
  %266 = load void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)*, void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)** %mouse_position_hook, align 8
  %tobool434 = icmp ne void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)* %266, null
  br i1 %tobool434, label %if.then.435, label %if.end.438

if.then.435:                                      ; preds = %land.lhs.true.432
  %267 = load %struct.frame*, %struct.frame** %f, align 8
  %terminal436 = getelementptr inbounds %struct.frame, %struct.frame* %267, i32 0, i32 61
  %268 = load %struct.terminal*, %struct.terminal** %terminal436, align 8
  %mouse_position_hook437 = getelementptr inbounds %struct.terminal, %struct.terminal* %268, i32 0, i32 32
  %269 = load void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)*, void (%struct.frame**, i32, i64*, i32*, i64*, i64*, i64*)** %mouse_position_hook437, align 8
  call void %269(%struct.frame** %f, i32 0, i64* %bar_window, i32* %part, i64* %x428, i64* %y429, i64* %t)
  br label %if.end.438

if.end.438:                                       ; preds = %if.then.435, %land.lhs.true.432, %if.then.426
  %call439 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call439, i64* %obj, align 8
  %270 = load i64, i64* %x428, align 8
  %call440 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp441 = icmp eq i64 %270, %call440
  br i1 %cmp441, label %if.end.462, label %land.lhs.true.443

land.lhs.true.443:                                ; preds = %if.end.438
  %271 = load %struct.frame*, %struct.frame** %f, align 8
  %tobool444 = icmp ne %struct.frame* %271, null
  br i1 %tobool444, label %if.then.445, label %if.end.462

if.then.445:                                      ; preds = %land.lhs.true.443
  %272 = load %struct.frame*, %struct.frame** %f, align 8
  %focus_frame447 = getelementptr inbounds %struct.frame, %struct.frame* %272, i32 0, i32 4
  %273 = load i64, i64* %focus_frame447, align 8
  store i64 %273, i64* %frame446, align 8
  %274 = load i64, i64* %frame446, align 8
  %call448 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp449 = icmp eq i64 %274, %call448
  br i1 %cmp449, label %if.then.451, label %if.end.453

if.then.451:                                      ; preds = %if.then.445
  %275 = load %struct.frame*, %struct.frame** %f, align 8
  %276 = bitcast %struct.frame* %275 to i8*
  %call452 = call i64 @make_lisp_ptr(i8* %276, i32 5)
  store i64 %call452, i64* %frame446, align 8
  br label %if.end.453

if.end.453:                                       ; preds = %if.then.451, %if.then.445
  %277 = load i64, i64* %frame446, align 8
  %278 = load i64, i64* @internal_last_event_frame, align 8
  %cmp454 = icmp eq i64 %277, %278
  br i1 %cmp454, label %if.end.461, label %land.lhs.true.456

land.lhs.true.456:                                ; preds = %if.end.453
  %279 = load i64, i64* %frame446, align 8
  %280 = load i64, i64* @selected_frame, align 8
  %cmp457 = icmp eq i64 %279, %280
  br i1 %cmp457, label %if.end.461, label %if.then.459

if.then.459:                                      ; preds = %land.lhs.true.456
  %281 = load i64, i64* %frame446, align 8
  %call460 = call i64 @make_lispy_switch_frame(i64 %281)
  store i64 %call460, i64* %obj, align 8
  br label %if.end.461

if.end.461:                                       ; preds = %if.then.459, %land.lhs.true.456, %if.end.453
  %282 = load i64, i64* %frame446, align 8
  store i64 %282, i64* @internal_last_event_frame, align 8
  br label %if.end.462

if.end.462:                                       ; preds = %if.end.461, %land.lhs.true.443, %if.end.438
  %283 = load i64, i64* %x428, align 8
  %call463 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp464 = icmp eq i64 %283, %call463
  br i1 %cmp464, label %if.end.472, label %land.lhs.true.466

land.lhs.true.466:                                ; preds = %if.end.462
  %284 = load i64, i64* %obj, align 8
  %call467 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp468 = icmp eq i64 %284, %call467
  br i1 %cmp468, label %if.then.470, label %if.end.472

if.then.470:                                      ; preds = %land.lhs.true.466
  %285 = load %struct.frame*, %struct.frame** %f, align 8
  %286 = load i64, i64* %bar_window, align 8
  %287 = load i32, i32* %part, align 4
  %288 = load i64, i64* %x428, align 8
  %289 = load i64, i64* %y429, align 8
  %290 = load i64, i64* %t, align 8
  %call471 = call i64 @make_lispy_movement(%struct.frame* %285, i64 %286, i32 %287, i64 %288, i64 %289, i64 %290)
  store i64 %call471, i64* %obj, align 8
  br label %if.end.472

if.end.472:                                       ; preds = %if.then.470, %land.lhs.true.466, %if.end.462
  br label %if.end.474

if.else.473:                                      ; preds = %land.lhs.true.423, %if.else.419
  call void @emacs_abort() #11
  unreachable

if.end.474:                                       ; preds = %if.end.472
  br label %if.end.475

if.end.475:                                       ; preds = %if.end.474, %if.end.418
  %call476 = call zeroext i1 @readable_events(i32 0)
  %frombool477 = zext i1 %call476 to i8
  store i8 %frombool477, i8* @input_pending, align 1
  %291 = load i64, i64* @internal_last_event_frame, align 8
  store i64 %291, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 156), align 8
  %292 = load i64, i64* %obj, align 8
  store i64 %292, i64* %retval
  br label %return

return:                                           ; preds = %if.end.475, %if.then.143, %if.then.41
  %293 = load i64, i64* %retval
  ret i64 %293
}

declare void @unhold_keyboard_input() #1

declare void @request_sigio() #1

declare i32 @wait_reading_process_output(i64, i32, i32, i1 zeroext, i64, %struct.Lisp_Process*, i32) #1

declare void @x_handle_selection_event(%struct.selection_input_event*) #1

declare void @x_activate_menubar(%struct.frame*) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_event(%struct.input_event* %event) #0 {
entry:
  %retval = alloca i64, align 8
  %event.addr = alloca %struct.input_event*, align 8
  %i = alloca i32, align 4
  %lispy_c = alloca i64, align 8
  %c = alloca i64, align 8
  %button = alloca i32, align 4
  %is_double = alloca i8, align 1
  %position = alloca i64, align 8
  %start_pos_ptr = alloca i64*, align 8
  %start_pos = alloca i64, align 8
  %f = alloca %struct.frame*, align 8
  %row = alloca i32, align 4
  %column = alloca i32, align 4
  %items = alloca i64, align 8
  %item = alloca i64, align 8
  %pos = alloca i64, align 8
  %string = alloca i64, align 8
  %incr = alloca i64, align 8
  %f184 = alloca %struct.frame*, align 8
  %fuzz = alloca i32, align 4
  %new_down = alloca i64, align 8
  %down = alloca i64, align 8
  %xdiff = alloca i64, align 8
  %ydiff = alloca i64, align 8
  %head = alloca i64, align 8
  %position412 = alloca i64, align 8
  %head413 = alloca i64, align 8
  %f414 = alloca %struct.frame*, align 8
  %fr = alloca %struct.frame*, align 8
  %fuzz427 = alloca i32, align 4
  %symbol_num = alloca i32, align 4
  %is_double428 = alloca i8, align 1
  %position589 = alloca i64, align 8
  %head590 = alloca i64, align 8
  %position618 = alloca i64, align 8
  %head619 = alloca i64, align 8
  %f647 = alloca %struct.frame*, align 8
  %head648 = alloca i64, align 8
  %position649 = alloca i64, align 8
  %files = alloca i64, align 8
  %name = alloca i8*, align 8
  store %struct.input_event* %event, %struct.input_event** %event.addr, align 8
  %0 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %1 = bitcast %struct.input_event* %0 to i32*
  %bf.load = load i32, i32* %1, align 8
  %bf.clear = and i32 %bf.load, 65535
  switch i32 %bf.clear, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb
    i32 3, label %sw.bb.24
    i32 5, label %sw.bb.90
    i32 6, label %sw.bb.411
    i32 7, label %sw.bb.411
    i32 8, label %sw.bb.588
    i32 9, label %sw.bb.617
    i32 18, label %sw.bb.646
    i32 14, label %sw.bb.667
    i32 24, label %sw.bb.677
    i32 21, label %sw.bb.682
    i32 19, label %sw.bb.703
    i32 25, label %sw.bb.710
    i32 27, label %sw.bb.712
    i32 26, label %sw.bb.716
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code = getelementptr inbounds %struct.input_event, %struct.input_event* %2, i32 0, i32 1
  %3 = load i32, i32* %code, align 4
  %conv = zext i32 %3 to i64
  store i64 %conv, i64* %c, align 8
  %4 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %5 = bitcast %struct.input_event* %4 to i32*
  %bf.load1 = load i32, i32* %5, align 8
  %bf.clear2 = and i32 %bf.load1, 65535
  %cmp = icmp eq i32 %bf.clear2, 1
  br i1 %cmp, label %if.then, label %if.end.10

if.then:                                          ; preds = %sw.bb
  %6 = load i64, i64* %c, align 8
  %and = and i64 %6, 255
  store i64 %and, i64* %c, align 8
  %7 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers = getelementptr inbounds %struct.input_event, %struct.input_event* %7, i32 0, i32 2
  %8 = load i32, i32* %modifiers, align 4
  %and4 = and i32 %8, 67108864
  %tobool = icmp ne i32 %and4, 0
  br i1 %tobool, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %9 = load i64, i64* %c, align 8
  %conv6 = trunc i64 %9 to i32
  %call = call i32 @make_ctrl_char(i32 %conv6) #14
  %conv7 = sext i32 %call to i64
  store i64 %conv7, i64* %c, align 8
  %10 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers8 = getelementptr inbounds %struct.input_event, %struct.input_event* %10, i32 0, i32 2
  %11 = load i32, i32* %modifiers8, align 4
  %and9 = and i32 %11, -67108865
  store i32 %and9, i32* %modifiers8, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.5, %if.then
  br label %if.end.10

if.end.10:                                        ; preds = %if.end, %sw.bb
  %12 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers11 = getelementptr inbounds %struct.input_event, %struct.input_event* %12, i32 0, i32 2
  %13 = load i32, i32* %modifiers11, align 4
  %and12 = and i32 %13, 230686720
  %conv13 = zext i32 %and12 to i64
  %14 = load i64, i64* %c, align 8
  %or = or i64 %14, %conv13
  store i64 %or, i64* %c, align 8
  %15 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code14 = getelementptr inbounds %struct.input_event, %struct.input_event* %15, i32 0, i32 1
  %16 = load i32, i32* %code14, align 4
  %cmp15 = icmp eq i32 %16, 32
  br i1 %cmp15, label %land.lhs.true, label %if.end.22

land.lhs.true:                                    ; preds = %if.end.10
  %17 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers17 = getelementptr inbounds %struct.input_event, %struct.input_event* %17, i32 0, i32 2
  %18 = load i32, i32* %modifiers17, align 4
  %and18 = and i32 %18, 33554432
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then.20, label %if.end.22

if.then.20:                                       ; preds = %land.lhs.true
  %19 = load i64, i64* %c, align 8
  %or21 = or i64 %19, 33554432
  store i64 %or21, i64* %c, align 8
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.20, %land.lhs.true, %if.end.10
  store i64 0, i64* @button_down_time, align 8
  %20 = load i64, i64* %c, align 8
  %call23 = call i64 @make_natnum(i64 %20)
  store i64 %call23, i64* %lispy_c, align 8
  %21 = load i64, i64* %lispy_c, align 8
  store i64 %21, i64* %retval
  br label %return

sw.bb.24:                                         ; preds = %entry
  store i64 0, i64* @button_down_time, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.24
  %22 = load i32, i32* %i, align 4
  %conv25 = sext i32 %22 to i64
  %cmp26 = icmp ult i64 %conv25, 20
  br i1 %cmp26, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code28 = getelementptr inbounds %struct.input_event, %struct.input_event* %23, i32 0, i32 1
  %24 = load i32, i32* %code28, align 4
  %25 = load i32, i32* %i, align 4
  %idxprom = sext i32 %25 to i64
  %arrayidx = getelementptr inbounds [20 x i32], [20 x i32]* @lispy_accent_codes, i32 0, i64 %idxprom
  %26 = load i32, i32* %arrayidx, align 4
  %cmp29 = icmp eq i32 %24, %26
  br i1 %cmp29, label %if.then.31, label %if.end.37

if.then.31:                                       ; preds = %for.body
  %27 = load i32, i32* %i, align 4
  %conv32 = sext i32 %27 to i64
  %28 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers33 = getelementptr inbounds %struct.input_event, %struct.input_event* %28, i32 0, i32 2
  %29 = load i32, i32* %modifiers33, align 4
  %call34 = call i64 @builtin_lisp_symbol(i32 478)
  %call35 = call i64 @builtin_lisp_symbol(i32 0)
  %call36 = call i64 @modify_event_symbol(i64 %conv32, i32 %29, i64 %call34, i64 %call35, i8** getelementptr inbounds ([20 x i8*], [20 x i8*]* @lispy_accent_keys, i32 0, i32 0), i64* @accent_key_syms, i64 20)
  store i64 %call36, i64* %retval
  br label %return

if.end.37:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.37
  %30 = load i32, i32* %i, align 4
  %inc = add nsw i32 %30, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %31 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code38 = getelementptr inbounds %struct.input_event, %struct.input_event* %31, i32 0, i32 1
  %32 = load i32, i32* %code38, align 4
  %cmp39 = icmp ult i32 %32, 65280
  br i1 %cmp39, label %land.lhs.true.41, label %if.end.52

land.lhs.true.41:                                 ; preds = %for.end
  %33 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code42 = getelementptr inbounds %struct.input_event, %struct.input_event* %33, i32 0, i32 1
  %34 = load i32, i32* %code42, align 4
  %cmp43 = icmp uge i32 %34, 65024
  br i1 %cmp43, label %if.then.45, label %if.end.52

if.then.45:                                       ; preds = %land.lhs.true.41
  %35 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code46 = getelementptr inbounds %struct.input_event, %struct.input_event* %35, i32 0, i32 1
  %36 = load i32, i32* %code46, align 4
  %sub = sub i32 %36, 65024
  %conv47 = zext i32 %sub to i64
  %37 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers48 = getelementptr inbounds %struct.input_event, %struct.input_event* %37, i32 0, i32 2
  %38 = load i32, i32* %modifiers48, align 4
  %call49 = call i64 @builtin_lisp_symbol(i32 478)
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %call51 = call i64 @modify_event_symbol(i64 %conv47, i32 %38, i64 %call49, i64 %call50, i8** getelementptr inbounds ([53 x i8*], [53 x i8*]* @iso_lispy_function_keys, i32 0, i32 0), i64* @func_key_syms, i64 53)
  store i64 %call51, i64* %retval
  br label %return

if.end.52:                                        ; preds = %land.lhs.true.41, %for.end
  %39 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code53 = getelementptr inbounds %struct.input_event, %struct.input_event* %39, i32 0, i32 1
  %40 = load i32, i32* %code53, align 4
  %cmp54 = icmp ule i32 65280, %40
  br i1 %cmp54, label %land.lhs.true.56, label %if.end.75

land.lhs.true.56:                                 ; preds = %if.end.52
  %41 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code57 = getelementptr inbounds %struct.input_event, %struct.input_event* %41, i32 0, i32 1
  %42 = load i32, i32* %code57, align 4
  %conv58 = zext i32 %42 to i64
  %cmp59 = icmp ult i64 %conv58, 65536
  br i1 %cmp59, label %land.lhs.true.61, label %if.end.75

land.lhs.true.61:                                 ; preds = %land.lhs.true.56
  %43 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code62 = getelementptr inbounds %struct.input_event, %struct.input_event* %43, i32 0, i32 1
  %44 = load i32, i32* %code62, align 4
  %sub63 = sub i32 %44, 65280
  %idxprom64 = zext i32 %sub63 to i64
  %arrayidx65 = getelementptr inbounds [256 x i8*], [256 x i8*]* @lispy_function_keys, i32 0, i64 %idxprom64
  %45 = load i8*, i8** %arrayidx65, align 8
  %tobool66 = icmp ne i8* %45, null
  br i1 %tobool66, label %if.then.67, label %if.end.75

if.then.67:                                       ; preds = %land.lhs.true.61
  %46 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code68 = getelementptr inbounds %struct.input_event, %struct.input_event* %46, i32 0, i32 1
  %47 = load i32, i32* %code68, align 4
  %sub69 = sub i32 %47, 65280
  %conv70 = zext i32 %sub69 to i64
  %48 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers71 = getelementptr inbounds %struct.input_event, %struct.input_event* %48, i32 0, i32 2
  %49 = load i32, i32* %modifiers71, align 4
  %call72 = call i64 @builtin_lisp_symbol(i32 478)
  %call73 = call i64 @builtin_lisp_symbol(i32 0)
  %call74 = call i64 @modify_event_symbol(i64 %conv70, i32 %49, i64 %call72, i64 %call73, i8** getelementptr inbounds ([256 x i8*], [256 x i8*]* @lispy_function_keys, i32 0, i32 0), i64* @func_key_syms, i64 256)
  store i64 %call74, i64* %retval
  br label %return

if.end.75:                                        ; preds = %land.lhs.true.61, %land.lhs.true.56, %if.end.52
  %50 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %system_key_syms_ = getelementptr inbounds %struct.kboard, %struct.kboard* %50, i32 0, i32 16
  %51 = load i64, i64* %system_key_syms_, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp77 = icmp eq i64 %51, %call76
  br i1 %cmp77, label %if.then.79, label %if.end.83

if.then.79:                                       ; preds = %if.end.75
  %52 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  %call81 = call i64 @builtin_lisp_symbol(i32 0)
  %call82 = call i64 @Fcons(i64 %call80, i64 %call81)
  call void @kset_system_key_syms(%struct.kboard* %52, i64 %call82)
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.79, %if.end.75
  %53 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code84 = getelementptr inbounds %struct.input_event, %struct.input_event* %53, i32 0, i32 1
  %54 = load i32, i32* %code84, align 4
  %conv85 = zext i32 %54 to i64
  %55 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers86 = getelementptr inbounds %struct.input_event, %struct.input_event* %55, i32 0, i32 2
  %56 = load i32, i32* %modifiers86, align 4
  %call87 = call i64 @builtin_lisp_symbol(i32 478)
  %57 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %Vsystem_key_alist_ = getelementptr inbounds %struct.kboard, %struct.kboard* %57, i32 0, i32 15
  %58 = load i64, i64* %Vsystem_key_alist_, align 8
  %59 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %system_key_syms_88 = getelementptr inbounds %struct.kboard, %struct.kboard* %59, i32 0, i32 16
  %call89 = call i64 @modify_event_symbol(i64 %conv85, i32 %56, i64 %call87, i64 %58, i8** null, i64* %system_key_syms_88, i64 9223372036854775807)
  store i64 %call89, i64* %retval
  br label %return

sw.bb.90:                                         ; preds = %entry
  %60 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code91 = getelementptr inbounds %struct.input_event, %struct.input_event* %60, i32 0, i32 1
  %61 = load i32, i32* %code91, align 4
  store i32 %61, i32* %button, align 4
  %call92 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call92, i64* %position, align 8
  %62 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %63 = bitcast %struct.input_event* %62 to i32*
  %bf.load93 = load i32, i32* %63, align 8
  %bf.clear94 = and i32 %bf.load93, 65535
  %cmp95 = icmp eq i32 %bf.clear94, 5
  br i1 %cmp95, label %if.then.97, label %if.end.168

if.then.97:                                       ; preds = %sw.bb.90
  %64 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %64, i32 0, i32 6
  %65 = load i64, i64* %frame_or_window, align 8
  %sub98 = sub nsw i64 %65, 5
  %66 = inttoptr i64 %sub98 to i8*
  %67 = bitcast i8* %66 to %struct.frame*
  store %struct.frame* %67, %struct.frame** %f, align 8
  %68 = load %struct.frame*, %struct.frame** %f, align 8
  %terminal = getelementptr inbounds %struct.frame, %struct.frame* %68, i32 0, i32 61
  %69 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %cmp99 = icmp ne %struct.terminal* %69, null
  br i1 %cmp99, label %if.end.103, label %if.then.101

if.then.101:                                      ; preds = %if.then.97
  %call102 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call102, i64* %retval
  br label %return

if.end.103:                                       ; preds = %if.then.97
  %70 = load %struct.frame*, %struct.frame** %f, align 8
  %call104 = call zeroext i1 @toolkit_menubar_in_use(%struct.frame* %70)
  br i1 %call104, label %if.end.163, label %if.then.105

if.then.105:                                      ; preds = %if.end.103
  %71 = load %struct.frame*, %struct.frame** %f, align 8
  %72 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %72, i32 0, i32 3
  %73 = load i64, i64* %x, align 8
  %shr = ashr i64 %73, 2
  %conv106 = trunc i64 %shr to i32
  %74 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %74, i32 0, i32 4
  %75 = load i64, i64* %y, align 8
  %shr107 = ashr i64 %75, 2
  %conv108 = trunc i64 %shr107 to i32
  call void @pixel_to_glyph_coords(%struct.frame* %71, i32 %conv106, i32 %conv108, i32* %column, i32* %row, %struct.XRectangle* null, i1 zeroext true)
  %76 = load i32, i32* %row, align 4
  %cmp109 = icmp sge i32 %76, 0
  br i1 %cmp109, label %land.lhs.true.111, label %if.end.162

land.lhs.true.111:                                ; preds = %if.then.105
  %77 = load i32, i32* %row, align 4
  %78 = load %struct.frame*, %struct.frame** %f, align 8
  %menu_bar_lines = getelementptr inbounds %struct.frame, %struct.frame* %78, i32 0, i32 57
  %79 = load i32, i32* %menu_bar_lines, align 4
  %cmp112 = icmp slt i32 %77, %79
  br i1 %cmp112, label %land.lhs.true.114, label %if.end.162

land.lhs.true.114:                                ; preds = %land.lhs.true.111
  %80 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers115 = getelementptr inbounds %struct.input_event, %struct.input_event* %80, i32 0, i32 2
  %81 = load i32, i32* %modifiers115, align 4
  %and116 = and i32 %81, 2
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then.118, label %if.end.162

if.then.118:                                      ; preds = %land.lhs.true.114
  %call119 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call119, i64* %item, align 8
  %82 = load %struct.frame*, %struct.frame** %f, align 8
  %menu_bar_items = getelementptr inbounds %struct.frame, %struct.frame* %82, i32 0, i32 11
  %83 = load i64, i64* %menu_bar_items, align 8
  store i64 %83, i64* %items, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.120

for.cond.120:                                     ; preds = %for.inc.151, %if.then.118
  %84 = load i32, i32* %i, align 4
  %conv121 = sext i32 %84 to i64
  %85 = load i64, i64* %items, align 8
  %call122 = call i64 @ASIZE(i64 %85)
  %cmp123 = icmp slt i64 %conv121, %call122
  br i1 %cmp123, label %for.body.125, label %for.end.153

for.body.125:                                     ; preds = %for.cond.120
  %86 = load i64, i64* %items, align 8
  %87 = load i32, i32* %i, align 4
  %add = add nsw i32 %87, 1
  %conv126 = sext i32 %add to i64
  %call127 = call i64 @AREF(i64 %86, i64 %conv126)
  store i64 %call127, i64* %string, align 8
  %88 = load i64, i64* %items, align 8
  %89 = load i32, i32* %i, align 4
  %add128 = add nsw i32 %89, 3
  %conv129 = sext i32 %add128 to i64
  %call130 = call i64 @AREF(i64 %88, i64 %conv129)
  store i64 %call130, i64* %pos, align 8
  %90 = load i64, i64* %string, align 8
  %call131 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp132 = icmp eq i64 %90, %call131
  br i1 %cmp132, label %if.then.134, label %if.end.135

if.then.134:                                      ; preds = %for.body.125
  br label %for.end.153

if.end.135:                                       ; preds = %for.body.125
  %91 = load i32, i32* %column, align 4
  %conv136 = sext i32 %91 to i64
  %92 = load i64, i64* %pos, align 8
  %shr137 = ashr i64 %92, 2
  %cmp138 = icmp sge i64 %conv136, %shr137
  br i1 %cmp138, label %land.lhs.true.140, label %if.end.150

land.lhs.true.140:                                ; preds = %if.end.135
  %93 = load i32, i32* %column, align 4
  %conv141 = sext i32 %93 to i64
  %94 = load i64, i64* %pos, align 8
  %shr142 = ashr i64 %94, 2
  %95 = load i64, i64* %string, align 8
  %call143 = call i64 @SCHARS(i64 %95)
  %add144 = add nsw i64 %shr142, %call143
  %cmp145 = icmp slt i64 %conv141, %add144
  br i1 %cmp145, label %if.then.147, label %if.end.150

if.then.147:                                      ; preds = %land.lhs.true.140
  %96 = load i64, i64* %items, align 8
  %97 = load i32, i32* %i, align 4
  %conv148 = sext i32 %97 to i64
  %call149 = call i64 @AREF(i64 %96, i64 %conv148)
  store i64 %call149, i64* %item, align 8
  br label %for.end.153

if.end.150:                                       ; preds = %land.lhs.true.140, %if.end.135
  br label %for.inc.151

for.inc.151:                                      ; preds = %if.end.150
  %98 = load i32, i32* %i, align 4
  %add152 = add nsw i32 %98, 4
  store i32 %add152, i32* %i, align 4
  br label %for.cond.120

for.end.153:                                      ; preds = %if.then.147, %if.then.134, %for.cond.120
  %99 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window154 = getelementptr inbounds %struct.input_event, %struct.input_event* %99, i32 0, i32 6
  %100 = load i64, i64* %frame_or_window154, align 8
  %call155 = call i64 @builtin_lisp_symbol(i32 651)
  %101 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x156 = getelementptr inbounds %struct.input_event, %struct.input_event* %101, i32 0, i32 3
  %102 = load i64, i64* %x156, align 8
  %103 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y157 = getelementptr inbounds %struct.input_event, %struct.input_event* %103, i32 0, i32 4
  %104 = load i64, i64* %y157, align 8
  %call158 = call i64 @Fcons(i64 %102, i64 %104)
  %105 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp = getelementptr inbounds %struct.input_event, %struct.input_event* %105, i32 0, i32 5
  %106 = load i64, i64* %timestamp, align 8
  %shl = shl i64 %106, 2
  %add159 = add i64 %shl, 2
  %call160 = call i64 @list4(i64 %100, i64 %call155, i64 %call158, i64 %add159)
  store i64 %call160, i64* %position, align 8
  %107 = load i64, i64* %item, align 8
  %108 = load i64, i64* %position, align 8
  %call161 = call i64 @list2(i64 %107, i64 %108)
  store i64 %call161, i64* %retval
  br label %return

if.end.162:                                       ; preds = %land.lhs.true.114, %land.lhs.true.111, %if.then.105
  br label %if.end.163

if.end.163:                                       ; preds = %if.end.162, %if.end.103
  %109 = load %struct.frame*, %struct.frame** %f, align 8
  %110 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x164 = getelementptr inbounds %struct.input_event, %struct.input_event* %110, i32 0, i32 3
  %111 = load i64, i64* %x164, align 8
  %112 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y165 = getelementptr inbounds %struct.input_event, %struct.input_event* %112, i32 0, i32 4
  %113 = load i64, i64* %y165, align 8
  %114 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp166 = getelementptr inbounds %struct.input_event, %struct.input_event* %114, i32 0, i32 5
  %115 = load i64, i64* %timestamp166, align 8
  %call167 = call i64 @make_lispy_position(%struct.frame* %109, i64 %111, i64 %113, i64 %115)
  store i64 %call167, i64* %position, align 8
  br label %if.end.168

if.end.168:                                       ; preds = %if.end.163, %sw.bb.90
  %116 = load i32, i32* %button, align 4
  %conv169 = sext i32 %116 to i64
  %117 = load i64, i64* @button_down_location, align 8
  %call170 = call i64 @ASIZE(i64 %117)
  %cmp171 = icmp sge i64 %conv169, %call170
  br i1 %cmp171, label %if.then.173, label %if.end.180

if.then.173:                                      ; preds = %if.end.168
  %118 = load i32, i32* %button, align 4
  %conv174 = sext i32 %118 to i64
  %119 = load i64, i64* @button_down_location, align 8
  %call175 = call i64 @ASIZE(i64 %119)
  %sub176 = sub nsw i64 %conv174, %call175
  %add177 = add nsw i64 %sub176, 1
  store i64 %add177, i64* %incr, align 8
  %120 = load i64, i64* @button_down_location, align 8
  %121 = load i64, i64* %incr, align 8
  %call178 = call i64 @larger_vector(i64 %120, i64 %121, i64 -1)
  store i64 %call178, i64* @button_down_location, align 8
  %122 = load i64, i64* @mouse_syms, align 8
  %123 = load i64, i64* %incr, align 8
  %call179 = call i64 @larger_vector(i64 %122, i64 %123, i64 -1)
  store i64 %call179, i64* @mouse_syms, align 8
  br label %if.end.180

if.end.180:                                       ; preds = %if.then.173, %if.end.168
  %124 = load i64, i64* @button_down_location, align 8
  %125 = load i32, i32* %button, align 4
  %conv181 = sext i32 %125 to i64
  %call182 = call i64* @aref_addr(i64 %124, i64 %conv181)
  store i64* %call182, i64** %start_pos_ptr, align 8
  %126 = load i64*, i64** %start_pos_ptr, align 8
  %127 = load i64, i64* %126, align 8
  store i64 %127, i64* %start_pos, align 8
  %call183 = call i64 @builtin_lisp_symbol(i32 0)
  %128 = load i64*, i64** %start_pos_ptr, align 8
  store i64 %call183, i64* %128, align 8
  %129 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window185 = getelementptr inbounds %struct.input_event, %struct.input_event* %129, i32 0, i32 6
  %130 = load i64, i64* %frame_or_window185, align 8
  %call186 = call zeroext i1 @WINDOWP(i64 %130)
  br i1 %call186, label %if.then.187, label %if.else

if.then.187:                                      ; preds = %if.end.180
  %131 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window188 = getelementptr inbounds %struct.input_event, %struct.input_event* %131, i32 0, i32 6
  %132 = load i64, i64* %frame_or_window188, align 8
  %call189 = call %struct.window* @XWINDOW(i64 %132)
  %frame = getelementptr inbounds %struct.window, %struct.window* %call189, i32 0, i32 1
  %133 = load i64, i64* %frame, align 8
  %sub190 = sub nsw i64 %133, 5
  %134 = inttoptr i64 %sub190 to i8*
  %135 = bitcast i8* %134 to %struct.frame*
  store %struct.frame* %135, %struct.frame** %f184, align 8
  br label %if.end.198

if.else:                                          ; preds = %if.end.180
  %136 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window191 = getelementptr inbounds %struct.input_event, %struct.input_event* %136, i32 0, i32 6
  %137 = load i64, i64* %frame_or_window191, align 8
  %call192 = call zeroext i1 @FRAMEP(i64 %137)
  br i1 %call192, label %if.then.193, label %if.else.196

if.then.193:                                      ; preds = %if.else
  %138 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window194 = getelementptr inbounds %struct.input_event, %struct.input_event* %138, i32 0, i32 6
  %139 = load i64, i64* %frame_or_window194, align 8
  %sub195 = sub nsw i64 %139, 5
  %140 = inttoptr i64 %sub195 to i8*
  %141 = bitcast i8* %140 to %struct.frame*
  store %struct.frame* %141, %struct.frame** %f184, align 8
  br label %if.end.197

if.else.196:                                      ; preds = %if.else
  call void @emacs_abort() #11
  unreachable

if.end.197:                                       ; preds = %if.then.193
  br label %if.end.198

if.end.198:                                       ; preds = %if.end.197, %if.then.187
  %142 = load %struct.frame*, %struct.frame** %f184, align 8
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %142, i32 0, i32 26
  %143 = bitcast i48* %output_method to i64*
  %bf.load199 = load i64, i64* %143, align 8
  %bf.lshr = lshr i64 %bf.load199, 23
  %bf.clear200 = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear200 to i32
  %cmp201 = icmp eq i32 %bf.cast, 2
  br i1 %cmp201, label %if.then.203, label %if.else.205

if.then.203:                                      ; preds = %if.end.198
  %144 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %conv204 = trunc i64 %144 to i32
  store i32 %conv204, i32* %fuzz, align 4
  br label %if.end.207

if.else.205:                                      ; preds = %if.end.198
  %145 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %div = sdiv i64 %145, 8
  %conv206 = trunc i64 %div to i32
  store i32 %conv206, i32* %fuzz, align 4
  br label %if.end.207

if.end.207:                                       ; preds = %if.else.205, %if.then.203
  %146 = load i32, i32* %button, align 4
  %147 = load i32, i32* @last_mouse_button, align 4
  %cmp208 = icmp eq i32 %146, %147
  br i1 %cmp208, label %land.lhs.true.210, label %land.end.266

land.lhs.true.210:                                ; preds = %if.end.207
  %148 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x211 = getelementptr inbounds %struct.input_event, %struct.input_event* %148, i32 0, i32 3
  %149 = load i64, i64* %x211, align 8
  %shr212 = ashr i64 %149, 2
  %150 = load i32, i32* @last_mouse_x, align 4
  %conv213 = sext i32 %150 to i64
  %sub214 = sub nsw i64 %shr212, %conv213
  %cmp215 = icmp slt i64 %sub214, 0
  br i1 %cmp215, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.210
  %151 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x217 = getelementptr inbounds %struct.input_event, %struct.input_event* %151, i32 0, i32 3
  %152 = load i64, i64* %x217, align 8
  %shr218 = ashr i64 %152, 2
  %153 = load i32, i32* @last_mouse_x, align 4
  %conv219 = sext i32 %153 to i64
  %sub220 = sub nsw i64 %shr218, %conv219
  %sub221 = sub nsw i64 0, %sub220
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.210
  %154 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x222 = getelementptr inbounds %struct.input_event, %struct.input_event* %154, i32 0, i32 3
  %155 = load i64, i64* %x222, align 8
  %shr223 = ashr i64 %155, 2
  %156 = load i32, i32* @last_mouse_x, align 4
  %conv224 = sext i32 %156 to i64
  %sub225 = sub nsw i64 %shr223, %conv224
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub221, %cond.true ], [ %sub225, %cond.false ]
  %157 = load i32, i32* %fuzz, align 4
  %conv226 = sext i32 %157 to i64
  %cmp227 = icmp sle i64 %cond, %conv226
  br i1 %cmp227, label %land.lhs.true.229, label %land.end.266

land.lhs.true.229:                                ; preds = %cond.end
  %158 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y230 = getelementptr inbounds %struct.input_event, %struct.input_event* %158, i32 0, i32 4
  %159 = load i64, i64* %y230, align 8
  %shr231 = ashr i64 %159, 2
  %160 = load i32, i32* @last_mouse_y, align 4
  %conv232 = sext i32 %160 to i64
  %sub233 = sub nsw i64 %shr231, %conv232
  %cmp234 = icmp slt i64 %sub233, 0
  br i1 %cmp234, label %cond.true.236, label %cond.false.242

cond.true.236:                                    ; preds = %land.lhs.true.229
  %161 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y237 = getelementptr inbounds %struct.input_event, %struct.input_event* %161, i32 0, i32 4
  %162 = load i64, i64* %y237, align 8
  %shr238 = ashr i64 %162, 2
  %163 = load i32, i32* @last_mouse_y, align 4
  %conv239 = sext i32 %163 to i64
  %sub240 = sub nsw i64 %shr238, %conv239
  %sub241 = sub nsw i64 0, %sub240
  br label %cond.end.247

cond.false.242:                                   ; preds = %land.lhs.true.229
  %164 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y243 = getelementptr inbounds %struct.input_event, %struct.input_event* %164, i32 0, i32 4
  %165 = load i64, i64* %y243, align 8
  %shr244 = ashr i64 %165, 2
  %166 = load i32, i32* @last_mouse_y, align 4
  %conv245 = sext i32 %166 to i64
  %sub246 = sub nsw i64 %shr244, %conv245
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.false.242, %cond.true.236
  %cond248 = phi i64 [ %sub241, %cond.true.236 ], [ %sub246, %cond.false.242 ]
  %167 = load i32, i32* %fuzz, align 4
  %conv249 = sext i32 %167 to i64
  %cmp250 = icmp sle i64 %cond248, %conv249
  br i1 %cmp250, label %land.lhs.true.252, label %land.end.266

land.lhs.true.252:                                ; preds = %cond.end.247
  %168 = load i64, i64* @button_down_time, align 8
  %cmp253 = icmp ne i64 %168, 0
  br i1 %cmp253, label %land.rhs, label %land.end.266

land.rhs:                                         ; preds = %land.lhs.true.252
  %169 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %call255 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp256 = icmp eq i64 %169, %call255
  br i1 %cmp256, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %170 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %call258 = call zeroext i1 @NATNUMP(i64 %170)
  br i1 %call258, label %land.rhs.260, label %land.end

land.rhs.260:                                     ; preds = %lor.rhs
  %171 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp261 = getelementptr inbounds %struct.input_event, %struct.input_event* %171, i32 0, i32 5
  %172 = load i64, i64* %timestamp261, align 8
  %173 = load i64, i64* @button_down_time, align 8
  %sub262 = sub i64 %172, %173
  %174 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %shr263 = ashr i64 %174, 2
  %cmp264 = icmp ult i64 %sub262, %shr263
  br label %land.end

land.end:                                         ; preds = %land.rhs.260, %lor.rhs
  %175 = phi i1 [ false, %lor.rhs ], [ %cmp264, %land.rhs.260 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.rhs
  %176 = phi i1 [ true, %land.rhs ], [ %175, %land.end ]
  br label %land.end.266

land.end.266:                                     ; preds = %lor.end, %land.lhs.true.252, %cond.end.247, %cond.end, %if.end.207
  %177 = phi i1 [ false, %land.lhs.true.252 ], [ false, %cond.end.247 ], [ false, %cond.end ], [ false, %if.end.207 ], [ %176, %lor.end ]
  %frombool = zext i1 %177 to i8
  store i8 %frombool, i8* %is_double, align 1
  %178 = load i32, i32* %button, align 4
  store i32 %178, i32* @last_mouse_button, align 4
  %179 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x267 = getelementptr inbounds %struct.input_event, %struct.input_event* %179, i32 0, i32 3
  %180 = load i64, i64* %x267, align 8
  %shr268 = ashr i64 %180, 2
  %conv269 = trunc i64 %shr268 to i32
  store i32 %conv269, i32* @last_mouse_x, align 4
  %181 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y270 = getelementptr inbounds %struct.input_event, %struct.input_event* %181, i32 0, i32 4
  %182 = load i64, i64* %y270, align 8
  %shr271 = ashr i64 %182, 2
  %conv272 = trunc i64 %shr271 to i32
  store i32 %conv272, i32* @last_mouse_y, align 4
  %183 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers273 = getelementptr inbounds %struct.input_event, %struct.input_event* %183, i32 0, i32 2
  %184 = load i32, i32* %modifiers273, align 4
  %and274 = and i32 %184, 2
  %tobool275 = icmp ne i32 %and274, 0
  br i1 %tobool275, label %if.then.276, label %if.else.289

if.then.276:                                      ; preds = %land.end.266
  %185 = load i8, i8* %is_double, align 1
  %tobool277 = trunc i8 %185 to i1
  br i1 %tobool277, label %if.then.278, label %if.else.285

if.then.278:                                      ; preds = %if.then.276
  %186 = load i32, i32* @double_click_count, align 4
  %inc279 = add nsw i32 %186, 1
  store i32 %inc279, i32* @double_click_count, align 4
  %187 = load i32, i32* @double_click_count, align 4
  %cmp280 = icmp sgt i32 %187, 2
  %cond282 = select i1 %cmp280, i32 32, i32 16
  %188 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers283 = getelementptr inbounds %struct.input_event, %struct.input_event* %188, i32 0, i32 2
  %189 = load i32, i32* %modifiers283, align 4
  %or284 = or i32 %189, %cond282
  store i32 %or284, i32* %modifiers283, align 4
  br label %if.end.286

if.else.285:                                      ; preds = %if.then.276
  store i32 1, i32* @double_click_count, align 4
  br label %if.end.286

if.end.286:                                       ; preds = %if.else.285, %if.then.278
  %190 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp287 = getelementptr inbounds %struct.input_event, %struct.input_event* %190, i32 0, i32 5
  %191 = load i64, i64* %timestamp287, align 8
  store i64 %191, i64* @button_down_time, align 8
  %192 = load i64, i64* %position, align 8
  %call288 = call i64 @Fcopy_alist(i64 %192)
  %193 = load i64*, i64** %start_pos_ptr, align 8
  store i64 %call288, i64* %193, align 8
  store i8 0, i8* @ignore_mouse_drag_p, align 1
  br label %if.end.389

if.else.289:                                      ; preds = %land.end.266
  %194 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers290 = getelementptr inbounds %struct.input_event, %struct.input_event* %194, i32 0, i32 2
  %195 = load i32, i32* %modifiers290, align 4
  %and291 = and i32 %195, 1
  %tobool292 = icmp ne i32 %and291, 0
  br i1 %tobool292, label %if.then.293, label %if.else.387

if.then.293:                                      ; preds = %if.else.289
  %196 = load i64, i64* %start_pos, align 8
  %and294 = and i64 %196, 7
  %conv295 = trunc i64 %and294 to i32
  %cmp296 = icmp eq i32 %conv295, 3
  br i1 %cmp296, label %if.end.300, label %if.then.298

if.then.298:                                      ; preds = %if.then.293
  %call299 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call299, i64* %retval
  br label %return

if.end.300:                                       ; preds = %if.then.293
  %197 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers301 = getelementptr inbounds %struct.input_event, %struct.input_event* %197, i32 0, i32 2
  %198 = load i32, i32* %modifiers301, align 4
  %and302 = and i32 %198, -2
  store i32 %and302, i32* %modifiers301, align 4
  %199 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  store i64 %199, i64* %xdiff, align 8
  %200 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  store i64 %200, i64* %ydiff, align 8
  %201 = load i64, i64* %start_pos, align 8
  %call303 = call i64 @Fcdr(i64 %201)
  %call304 = call i64 @Fcdr(i64 %call303)
  %call305 = call i64 @Fcar(i64 %call304)
  store i64 %call305, i64* %down, align 8
  %202 = load i64, i64* %position, align 8
  %call306 = call i64 @Fcdr(i64 %202)
  %call307 = call i64 @Fcdr(i64 %call306)
  %call308 = call i64 @Fcar(i64 %call307)
  store i64 %call308, i64* %new_down, align 8
  %203 = load i64, i64* %down, align 8
  %and309 = and i64 %203, 7
  %conv310 = trunc i64 %and309 to i32
  %cmp311 = icmp eq i32 %conv310, 3
  br i1 %cmp311, label %land.lhs.true.313, label %if.end.344

land.lhs.true.313:                                ; preds = %if.end.300
  %204 = load i64, i64* %down, align 8
  %sub314 = sub nsw i64 %204, 3
  %205 = inttoptr i64 %sub314 to i8*
  %206 = bitcast i8* %205 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %206, i32 0, i32 0
  %207 = load i64, i64* %car, align 8
  %and315 = and i64 %207, 7
  %conv316 = trunc i64 %and315 to i32
  %and317 = and i32 %conv316, -5
  %cmp318 = icmp eq i32 %and317, 2
  br i1 %cmp318, label %land.lhs.true.320, label %if.end.344

land.lhs.true.320:                                ; preds = %land.lhs.true.313
  %208 = load i64, i64* %down, align 8
  %sub321 = sub nsw i64 %208, 3
  %209 = inttoptr i64 %sub321 to i8*
  %210 = bitcast i8* %209 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %210, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %211 = load i64, i64* %cdr, align 8
  %and322 = and i64 %211, 7
  %conv323 = trunc i64 %and322 to i32
  %and324 = and i32 %conv323, -5
  %cmp325 = icmp eq i32 %and324, 2
  br i1 %cmp325, label %if.then.327, label %if.end.344

if.then.327:                                      ; preds = %land.lhs.true.320
  %212 = load i64, i64* %new_down, align 8
  %sub328 = sub nsw i64 %212, 3
  %213 = inttoptr i64 %sub328 to i8*
  %214 = bitcast i8* %213 to %struct.Lisp_Cons*
  %car329 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %214, i32 0, i32 0
  %215 = load i64, i64* %car329, align 8
  %shr330 = ashr i64 %215, 2
  %216 = load i64, i64* %down, align 8
  %sub331 = sub nsw i64 %216, 3
  %217 = inttoptr i64 %sub331 to i8*
  %218 = bitcast i8* %217 to %struct.Lisp_Cons*
  %car332 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %218, i32 0, i32 0
  %219 = load i64, i64* %car332, align 8
  %shr333 = ashr i64 %219, 2
  %sub334 = sub nsw i64 %shr330, %shr333
  store i64 %sub334, i64* %xdiff, align 8
  %220 = load i64, i64* %new_down, align 8
  %sub335 = sub nsw i64 %220, 3
  %221 = inttoptr i64 %sub335 to i8*
  %222 = bitcast i8* %221 to %struct.Lisp_Cons*
  %u336 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %222, i32 0, i32 1
  %cdr337 = bitcast %union.anon.12* %u336 to i64*
  %223 = load i64, i64* %cdr337, align 8
  %shr338 = ashr i64 %223, 2
  %224 = load i64, i64* %down, align 8
  %sub339 = sub nsw i64 %224, 3
  %225 = inttoptr i64 %sub339 to i8*
  %226 = bitcast i8* %225 to %struct.Lisp_Cons*
  %u340 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %226, i32 0, i32 1
  %cdr341 = bitcast %union.anon.12* %u340 to i64*
  %227 = load i64, i64* %cdr341, align 8
  %shr342 = ashr i64 %227, 2
  %sub343 = sub nsw i64 %shr338, %shr342
  store i64 %sub343, i64* %ydiff, align 8
  br label %if.end.344

if.end.344:                                       ; preds = %if.then.327, %land.lhs.true.320, %land.lhs.true.313, %if.end.300
  %228 = load i8, i8* @ignore_mouse_drag_p, align 1
  %tobool345 = trunc i8 %228 to i1
  br i1 %tobool345, label %if.then.346, label %if.else.349

if.then.346:                                      ; preds = %if.end.344
  %229 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers347 = getelementptr inbounds %struct.input_event, %struct.input_event* %229, i32 0, i32 2
  %230 = load i32, i32* %modifiers347, align 4
  %or348 = or i32 %230, 8
  store i32 %or348, i32* %modifiers347, align 4
  store i8 0, i8* @ignore_mouse_drag_p, align 1
  br label %if.end.377

if.else.349:                                      ; preds = %if.end.344
  %231 = load i64, i64* %xdiff, align 8
  %232 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %cmp350 = icmp slt i64 %231, %232
  br i1 %cmp350, label %land.lhs.true.352, label %if.else.373

land.lhs.true.352:                                ; preds = %if.else.349
  %233 = load i64, i64* %xdiff, align 8
  %234 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %sub353 = sub nsw i64 0, %234
  %cmp354 = icmp sgt i64 %233, %sub353
  br i1 %cmp354, label %land.lhs.true.356, label %if.else.373

land.lhs.true.356:                                ; preds = %land.lhs.true.352
  %235 = load i64, i64* %ydiff, align 8
  %236 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %cmp357 = icmp slt i64 %235, %236
  br i1 %cmp357, label %land.lhs.true.359, label %if.else.373

land.lhs.true.359:                                ; preds = %land.lhs.true.356
  %237 = load i64, i64* %ydiff, align 8
  %238 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %sub360 = sub nsw i64 0, %238
  %cmp361 = icmp sgt i64 %237, %sub360
  br i1 %cmp361, label %land.lhs.true.363, label %if.else.373

land.lhs.true.363:                                ; preds = %land.lhs.true.359
  %239 = load i64, i64* %start_pos, align 8
  %call364 = call i64 @Fcdr(i64 %239)
  %call365 = call i64 @Fcar(i64 %call364)
  %240 = load i64, i64* %position, align 8
  %call366 = call i64 @Fcdr(i64 %240)
  %call367 = call i64 @Fcar(i64 %call366)
  %cmp368 = icmp eq i64 %call365, %call367
  br i1 %cmp368, label %if.then.370, label %if.else.373

if.then.370:                                      ; preds = %land.lhs.true.363
  %241 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers371 = getelementptr inbounds %struct.input_event, %struct.input_event* %241, i32 0, i32 2
  %242 = load i32, i32* %modifiers371, align 4
  %or372 = or i32 %242, 8
  store i32 %or372, i32* %modifiers371, align 4
  br label %if.end.376

if.else.373:                                      ; preds = %land.lhs.true.363, %land.lhs.true.359, %land.lhs.true.356, %land.lhs.true.352, %if.else.349
  store i64 0, i64* @button_down_time, align 8
  %243 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers374 = getelementptr inbounds %struct.input_event, %struct.input_event* %243, i32 0, i32 2
  %244 = load i32, i32* %modifiers374, align 4
  %or375 = or i32 %244, 4
  store i32 %or375, i32* %modifiers374, align 4
  br label %if.end.376

if.end.376:                                       ; preds = %if.else.373, %if.then.370
  br label %if.end.377

if.end.377:                                       ; preds = %if.end.376, %if.then.346
  %245 = load i32, i32* @double_click_count, align 4
  %cmp378 = icmp sgt i32 %245, 1
  br i1 %cmp378, label %if.then.380, label %if.end.386

if.then.380:                                      ; preds = %if.end.377
  %246 = load i32, i32* @double_click_count, align 4
  %cmp381 = icmp sgt i32 %246, 2
  %cond383 = select i1 %cmp381, i32 32, i32 16
  %247 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers384 = getelementptr inbounds %struct.input_event, %struct.input_event* %247, i32 0, i32 2
  %248 = load i32, i32* %modifiers384, align 4
  %or385 = or i32 %248, %cond383
  store i32 %or385, i32* %modifiers384, align 4
  br label %if.end.386

if.end.386:                                       ; preds = %if.then.380, %if.end.377
  br label %if.end.388

if.else.387:                                      ; preds = %if.else.289
  call void @emacs_abort() #11
  unreachable

if.end.388:                                       ; preds = %if.end.386
  br label %if.end.389

if.end.389:                                       ; preds = %if.end.388, %if.end.286
  %249 = load i32, i32* %button, align 4
  %conv390 = sext i32 %249 to i64
  %250 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers391 = getelementptr inbounds %struct.input_event, %struct.input_event* %250, i32 0, i32 2
  %251 = load i32, i32* %modifiers391, align 4
  %call392 = call i64 @builtin_lisp_symbol(i32 685)
  %252 = load i64, i64* @Vlispy_mouse_stem, align 8
  %253 = load i64, i64* @mouse_syms, align 8
  %call393 = call i64 @ASIZE(i64 %253)
  %call394 = call i64 @modify_event_symbol(i64 %conv390, i32 %251, i64 %call392, i64 %252, i8** null, i64* @mouse_syms, i64 %call393)
  store i64 %call394, i64* %head, align 8
  %254 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers395 = getelementptr inbounds %struct.input_event, %struct.input_event* %254, i32 0, i32 2
  %255 = load i32, i32* %modifiers395, align 4
  %and396 = and i32 %255, 4
  %tobool397 = icmp ne i32 %and396, 0
  br i1 %tobool397, label %if.then.398, label %if.else.400

if.then.398:                                      ; preds = %if.end.389
  %256 = load i64, i64* %head, align 8
  %257 = load i64, i64* %start_pos, align 8
  %258 = load i64, i64* %position, align 8
  %call399 = call i64 @list3(i64 %256, i64 %257, i64 %258)
  store i64 %call399, i64* %retval
  br label %return

if.else.400:                                      ; preds = %if.end.389
  %259 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers401 = getelementptr inbounds %struct.input_event, %struct.input_event* %259, i32 0, i32 2
  %260 = load i32, i32* %modifiers401, align 4
  %and402 = and i32 %260, 48
  %tobool403 = icmp ne i32 %and402, 0
  br i1 %tobool403, label %if.then.404, label %if.else.409

if.then.404:                                      ; preds = %if.else.400
  %261 = load i64, i64* %head, align 8
  %262 = load i64, i64* %position, align 8
  %263 = load i32, i32* @double_click_count, align 4
  %conv405 = sext i32 %263 to i64
  %shl406 = shl i64 %conv405, 2
  %add407 = add i64 %shl406, 2
  %call408 = call i64 @list3(i64 %261, i64 %262, i64 %add407)
  store i64 %call408, i64* %retval
  br label %return

if.else.409:                                      ; preds = %if.else.400
  %264 = load i64, i64* %head, align 8
  %265 = load i64, i64* %position, align 8
  %call410 = call i64 @list2(i64 %264, i64 %265)
  store i64 %call410, i64* %retval
  br label %return

sw.bb.411:                                        ; preds = %entry, %entry
  %266 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window415 = getelementptr inbounds %struct.input_event, %struct.input_event* %266, i32 0, i32 6
  %267 = load i64, i64* %frame_or_window415, align 8
  %sub416 = sub nsw i64 %267, 5
  %268 = inttoptr i64 %sub416 to i8*
  %269 = bitcast i8* %268 to %struct.frame*
  store %struct.frame* %269, %struct.frame** %f414, align 8
  %270 = load %struct.frame*, %struct.frame** %f414, align 8
  %terminal417 = getelementptr inbounds %struct.frame, %struct.frame* %270, i32 0, i32 61
  %271 = load %struct.terminal*, %struct.terminal** %terminal417, align 8
  %cmp418 = icmp ne %struct.terminal* %271, null
  br i1 %cmp418, label %if.end.422, label %if.then.420

if.then.420:                                      ; preds = %sw.bb.411
  %call421 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call421, i64* %retval
  br label %return

if.end.422:                                       ; preds = %sw.bb.411
  %272 = load %struct.frame*, %struct.frame** %f414, align 8
  %273 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x423 = getelementptr inbounds %struct.input_event, %struct.input_event* %273, i32 0, i32 3
  %274 = load i64, i64* %x423, align 8
  %275 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y424 = getelementptr inbounds %struct.input_event, %struct.input_event* %275, i32 0, i32 4
  %276 = load i64, i64* %y424, align 8
  %277 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp425 = getelementptr inbounds %struct.input_event, %struct.input_event* %277, i32 0, i32 5
  %278 = load i64, i64* %timestamp425, align 8
  %call426 = call i64 @make_lispy_position(%struct.frame* %272, i64 %274, i64 %276, i64 %278)
  store i64 %call426, i64* %position412, align 8
  %279 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window429 = getelementptr inbounds %struct.input_event, %struct.input_event* %279, i32 0, i32 6
  %280 = load i64, i64* %frame_or_window429, align 8
  %call430 = call zeroext i1 @WINDOWP(i64 %280)
  br i1 %call430, label %if.then.431, label %if.else.436

if.then.431:                                      ; preds = %if.end.422
  %281 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window432 = getelementptr inbounds %struct.input_event, %struct.input_event* %281, i32 0, i32 6
  %282 = load i64, i64* %frame_or_window432, align 8
  %call433 = call %struct.window* @XWINDOW(i64 %282)
  %frame434 = getelementptr inbounds %struct.window, %struct.window* %call433, i32 0, i32 1
  %283 = load i64, i64* %frame434, align 8
  %sub435 = sub nsw i64 %283, 5
  %284 = inttoptr i64 %sub435 to i8*
  %285 = bitcast i8* %284 to %struct.frame*
  store %struct.frame* %285, %struct.frame** %fr, align 8
  br label %if.end.444

if.else.436:                                      ; preds = %if.end.422
  %286 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window437 = getelementptr inbounds %struct.input_event, %struct.input_event* %286, i32 0, i32 6
  %287 = load i64, i64* %frame_or_window437, align 8
  %call438 = call zeroext i1 @FRAMEP(i64 %287)
  br i1 %call438, label %if.then.439, label %if.else.442

if.then.439:                                      ; preds = %if.else.436
  %288 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window440 = getelementptr inbounds %struct.input_event, %struct.input_event* %288, i32 0, i32 6
  %289 = load i64, i64* %frame_or_window440, align 8
  %sub441 = sub nsw i64 %289, 5
  %290 = inttoptr i64 %sub441 to i8*
  %291 = bitcast i8* %290 to %struct.frame*
  store %struct.frame* %291, %struct.frame** %fr, align 8
  br label %if.end.443

if.else.442:                                      ; preds = %if.else.436
  call void @emacs_abort() #11
  unreachable

if.end.443:                                       ; preds = %if.then.439
  br label %if.end.444

if.end.444:                                       ; preds = %if.end.443, %if.then.431
  %292 = load %struct.frame*, %struct.frame** %fr, align 8
  %output_method445 = getelementptr inbounds %struct.frame, %struct.frame* %292, i32 0, i32 26
  %293 = bitcast i48* %output_method445 to i64*
  %bf.load446 = load i64, i64* %293, align 8
  %bf.lshr447 = lshr i64 %bf.load446, 23
  %bf.clear448 = and i64 %bf.lshr447, 7
  %bf.cast449 = trunc i64 %bf.clear448 to i32
  %cmp450 = icmp eq i32 %bf.cast449, 2
  br i1 %cmp450, label %cond.true.452, label %cond.false.453

cond.true.452:                                    ; preds = %if.end.444
  %294 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  br label %cond.end.455

cond.false.453:                                   ; preds = %if.end.444
  %295 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 384), align 8
  %div454 = sdiv i64 %295, 8
  br label %cond.end.455

cond.end.455:                                     ; preds = %cond.false.453, %cond.true.452
  %cond456 = phi i64 [ %294, %cond.true.452 ], [ %div454, %cond.false.453 ]
  %conv457 = trunc i64 %cond456 to i32
  store i32 %conv457, i32* %fuzz427, align 4
  %296 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers458 = getelementptr inbounds %struct.input_event, %struct.input_event* %296, i32 0, i32 2
  %297 = load i32, i32* %modifiers458, align 4
  %and459 = and i32 %297, 1
  %tobool460 = icmp ne i32 %and459, 0
  br i1 %tobool460, label %if.then.461, label %if.else.464

if.then.461:                                      ; preds = %cond.end.455
  %298 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers462 = getelementptr inbounds %struct.input_event, %struct.input_event* %298, i32 0, i32 2
  %299 = load i32, i32* %modifiers462, align 4
  %and463 = and i32 %299, -2
  store i32 %and463, i32* %modifiers462, align 4
  store i32 0, i32* %symbol_num, align 4
  br label %if.end.473

if.else.464:                                      ; preds = %cond.end.455
  %300 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers465 = getelementptr inbounds %struct.input_event, %struct.input_event* %300, i32 0, i32 2
  %301 = load i32, i32* %modifiers465, align 4
  %and466 = and i32 %301, 2
  %tobool467 = icmp ne i32 %and466, 0
  br i1 %tobool467, label %if.then.468, label %if.else.471

if.then.468:                                      ; preds = %if.else.464
  %302 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers469 = getelementptr inbounds %struct.input_event, %struct.input_event* %302, i32 0, i32 2
  %303 = load i32, i32* %modifiers469, align 4
  %and470 = and i32 %303, -3
  store i32 %and470, i32* %modifiers469, align 4
  store i32 1, i32* %symbol_num, align 4
  br label %if.end.472

if.else.471:                                      ; preds = %if.else.464
  call void @emacs_abort() #11
  unreachable

if.end.472:                                       ; preds = %if.then.468
  br label %if.end.473

if.end.473:                                       ; preds = %if.end.472, %if.then.461
  %304 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %305 = bitcast %struct.input_event* %304 to i32*
  %bf.load474 = load i32, i32* %305, align 8
  %bf.clear475 = and i32 %bf.load474, 65535
  %cmp476 = icmp eq i32 %bf.clear475, 7
  br i1 %cmp476, label %if.then.478, label %if.end.480

if.then.478:                                      ; preds = %if.end.473
  %306 = load i32, i32* %symbol_num, align 4
  %add479 = add nsw i32 %306, 2
  store i32 %add479, i32* %symbol_num, align 4
  br label %if.end.480

if.end.480:                                       ; preds = %if.then.478, %if.end.473
  %307 = load i32, i32* @last_mouse_button, align 4
  %308 = load i32, i32* %symbol_num, align 4
  %add481 = add nsw i32 1, %308
  %sub482 = sub nsw i32 0, %add481
  %cmp483 = icmp eq i32 %307, %sub482
  br i1 %cmp483, label %land.lhs.true.485, label %land.end.549

land.lhs.true.485:                                ; preds = %if.end.480
  %309 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x486 = getelementptr inbounds %struct.input_event, %struct.input_event* %309, i32 0, i32 3
  %310 = load i64, i64* %x486, align 8
  %shr487 = ashr i64 %310, 2
  %311 = load i32, i32* @last_mouse_x, align 4
  %conv488 = sext i32 %311 to i64
  %sub489 = sub nsw i64 %shr487, %conv488
  %cmp490 = icmp slt i64 %sub489, 0
  br i1 %cmp490, label %cond.true.492, label %cond.false.498

cond.true.492:                                    ; preds = %land.lhs.true.485
  %312 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x493 = getelementptr inbounds %struct.input_event, %struct.input_event* %312, i32 0, i32 3
  %313 = load i64, i64* %x493, align 8
  %shr494 = ashr i64 %313, 2
  %314 = load i32, i32* @last_mouse_x, align 4
  %conv495 = sext i32 %314 to i64
  %sub496 = sub nsw i64 %shr494, %conv495
  %sub497 = sub nsw i64 0, %sub496
  br label %cond.end.503

cond.false.498:                                   ; preds = %land.lhs.true.485
  %315 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x499 = getelementptr inbounds %struct.input_event, %struct.input_event* %315, i32 0, i32 3
  %316 = load i64, i64* %x499, align 8
  %shr500 = ashr i64 %316, 2
  %317 = load i32, i32* @last_mouse_x, align 4
  %conv501 = sext i32 %317 to i64
  %sub502 = sub nsw i64 %shr500, %conv501
  br label %cond.end.503

cond.end.503:                                     ; preds = %cond.false.498, %cond.true.492
  %cond504 = phi i64 [ %sub497, %cond.true.492 ], [ %sub502, %cond.false.498 ]
  %318 = load i32, i32* %fuzz427, align 4
  %conv505 = sext i32 %318 to i64
  %cmp506 = icmp sle i64 %cond504, %conv505
  br i1 %cmp506, label %land.lhs.true.508, label %land.end.549

land.lhs.true.508:                                ; preds = %cond.end.503
  %319 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y509 = getelementptr inbounds %struct.input_event, %struct.input_event* %319, i32 0, i32 4
  %320 = load i64, i64* %y509, align 8
  %shr510 = ashr i64 %320, 2
  %321 = load i32, i32* @last_mouse_y, align 4
  %conv511 = sext i32 %321 to i64
  %sub512 = sub nsw i64 %shr510, %conv511
  %cmp513 = icmp slt i64 %sub512, 0
  br i1 %cmp513, label %cond.true.515, label %cond.false.521

cond.true.515:                                    ; preds = %land.lhs.true.508
  %322 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y516 = getelementptr inbounds %struct.input_event, %struct.input_event* %322, i32 0, i32 4
  %323 = load i64, i64* %y516, align 8
  %shr517 = ashr i64 %323, 2
  %324 = load i32, i32* @last_mouse_y, align 4
  %conv518 = sext i32 %324 to i64
  %sub519 = sub nsw i64 %shr517, %conv518
  %sub520 = sub nsw i64 0, %sub519
  br label %cond.end.526

cond.false.521:                                   ; preds = %land.lhs.true.508
  %325 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y522 = getelementptr inbounds %struct.input_event, %struct.input_event* %325, i32 0, i32 4
  %326 = load i64, i64* %y522, align 8
  %shr523 = ashr i64 %326, 2
  %327 = load i32, i32* @last_mouse_y, align 4
  %conv524 = sext i32 %327 to i64
  %sub525 = sub nsw i64 %shr523, %conv524
  br label %cond.end.526

cond.end.526:                                     ; preds = %cond.false.521, %cond.true.515
  %cond527 = phi i64 [ %sub520, %cond.true.515 ], [ %sub525, %cond.false.521 ]
  %328 = load i32, i32* %fuzz427, align 4
  %conv528 = sext i32 %328 to i64
  %cmp529 = icmp sle i64 %cond527, %conv528
  br i1 %cmp529, label %land.lhs.true.531, label %land.end.549

land.lhs.true.531:                                ; preds = %cond.end.526
  %329 = load i64, i64* @button_down_time, align 8
  %cmp532 = icmp ne i64 %329, 0
  br i1 %cmp532, label %land.rhs.534, label %land.end.549

land.rhs.534:                                     ; preds = %land.lhs.true.531
  %330 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %call535 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp536 = icmp eq i64 %330, %call535
  br i1 %cmp536, label %lor.end.548, label %lor.rhs.538

lor.rhs.538:                                      ; preds = %land.rhs.534
  %331 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %call539 = call zeroext i1 @NATNUMP(i64 %331)
  br i1 %call539, label %land.rhs.541, label %land.end.547

land.rhs.541:                                     ; preds = %lor.rhs.538
  %332 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp542 = getelementptr inbounds %struct.input_event, %struct.input_event* %332, i32 0, i32 5
  %333 = load i64, i64* %timestamp542, align 8
  %334 = load i64, i64* @button_down_time, align 8
  %sub543 = sub i64 %333, %334
  %335 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 74), align 8
  %shr544 = ashr i64 %335, 2
  %cmp545 = icmp ult i64 %sub543, %shr544
  br label %land.end.547

land.end.547:                                     ; preds = %land.rhs.541, %lor.rhs.538
  %336 = phi i1 [ false, %lor.rhs.538 ], [ %cmp545, %land.rhs.541 ]
  br label %lor.end.548

lor.end.548:                                      ; preds = %land.end.547, %land.rhs.534
  %337 = phi i1 [ true, %land.rhs.534 ], [ %336, %land.end.547 ]
  br label %land.end.549

land.end.549:                                     ; preds = %lor.end.548, %land.lhs.true.531, %cond.end.526, %cond.end.503, %if.end.480
  %338 = phi i1 [ false, %land.lhs.true.531 ], [ false, %cond.end.526 ], [ false, %cond.end.503 ], [ false, %if.end.480 ], [ %337, %lor.end.548 ]
  %frombool550 = zext i1 %338 to i8
  store i8 %frombool550, i8* %is_double428, align 1
  %339 = load i8, i8* %is_double428, align 1
  %tobool551 = trunc i8 %339 to i1
  br i1 %tobool551, label %if.then.552, label %if.else.559

if.then.552:                                      ; preds = %land.end.549
  %340 = load i32, i32* @double_click_count, align 4
  %inc553 = add nsw i32 %340, 1
  store i32 %inc553, i32* @double_click_count, align 4
  %341 = load i32, i32* @double_click_count, align 4
  %cmp554 = icmp sgt i32 %341, 2
  %cond556 = select i1 %cmp554, i32 32, i32 16
  %342 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers557 = getelementptr inbounds %struct.input_event, %struct.input_event* %342, i32 0, i32 2
  %343 = load i32, i32* %modifiers557, align 4
  %or558 = or i32 %343, %cond556
  store i32 %or558, i32* %modifiers557, align 4
  br label %if.end.562

if.else.559:                                      ; preds = %land.end.549
  store i32 1, i32* @double_click_count, align 4
  %344 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers560 = getelementptr inbounds %struct.input_event, %struct.input_event* %344, i32 0, i32 2
  %345 = load i32, i32* %modifiers560, align 4
  %or561 = or i32 %345, 8
  store i32 %or561, i32* %modifiers560, align 4
  br label %if.end.562

if.end.562:                                       ; preds = %if.else.559, %if.then.552
  %346 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp563 = getelementptr inbounds %struct.input_event, %struct.input_event* %346, i32 0, i32 5
  %347 = load i64, i64* %timestamp563, align 8
  store i64 %347, i64* @button_down_time, align 8
  %348 = load i32, i32* %symbol_num, align 4
  %add564 = add nsw i32 1, %348
  %sub565 = sub nsw i32 0, %add564
  store i32 %sub565, i32* @last_mouse_button, align 4
  %349 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x566 = getelementptr inbounds %struct.input_event, %struct.input_event* %349, i32 0, i32 3
  %350 = load i64, i64* %x566, align 8
  %shr567 = ashr i64 %350, 2
  %conv568 = trunc i64 %shr567 to i32
  store i32 %conv568, i32* @last_mouse_x, align 4
  %351 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y569 = getelementptr inbounds %struct.input_event, %struct.input_event* %351, i32 0, i32 4
  %352 = load i64, i64* %y569, align 8
  %shr570 = ashr i64 %352, 2
  %conv571 = trunc i64 %shr570 to i32
  store i32 %conv571, i32* @last_mouse_y, align 4
  %353 = load i32, i32* %symbol_num, align 4
  %conv572 = sext i32 %353 to i64
  %354 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers573 = getelementptr inbounds %struct.input_event, %struct.input_event* %354, i32 0, i32 2
  %355 = load i32, i32* %modifiers573, align 4
  %call574 = call i64 @builtin_lisp_symbol(i32 685)
  %call575 = call i64 @builtin_lisp_symbol(i32 0)
  %356 = load i64, i64* @wheel_syms, align 8
  %call576 = call i64 @ASIZE(i64 %356)
  %call577 = call i64 @modify_event_symbol(i64 %conv572, i32 %355, i64 %call574, i64 %call575, i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @lispy_wheel_names, i32 0, i32 0), i64* @wheel_syms, i64 %call576)
  store i64 %call577, i64* %head413, align 8
  %357 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers578 = getelementptr inbounds %struct.input_event, %struct.input_event* %357, i32 0, i32 2
  %358 = load i32, i32* %modifiers578, align 4
  %and579 = and i32 %358, 48
  %tobool580 = icmp ne i32 %and579, 0
  br i1 %tobool580, label %if.then.581, label %if.else.586

if.then.581:                                      ; preds = %if.end.562
  %359 = load i64, i64* %head413, align 8
  %360 = load i64, i64* %position412, align 8
  %361 = load i32, i32* @double_click_count, align 4
  %conv582 = sext i32 %361 to i64
  %shl583 = shl i64 %conv582, 2
  %add584 = add i64 %shl583, 2
  %call585 = call i64 @list3(i64 %359, i64 %360, i64 %add584)
  store i64 %call585, i64* %retval
  br label %return

if.else.586:                                      ; preds = %if.end.562
  %362 = load i64, i64* %head413, align 8
  %363 = load i64, i64* %position412, align 8
  %call587 = call i64 @list2(i64 %362, i64 %363)
  store i64 %call587, i64* %retval
  br label %return

sw.bb.588:                                        ; preds = %entry
  %364 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %call591 = call i64 @builtin_lisp_symbol(i32 1002)
  %call592 = call i64 @make_scroll_bar_position(%struct.input_event* %364, i64 %call591)
  store i64 %call592, i64* %position589, align 8
  %365 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers593 = getelementptr inbounds %struct.input_event, %struct.input_event* %365, i32 0, i32 2
  %366 = load i32, i32* %modifiers593, align 4
  %or594 = or i32 %366, 8
  store i32 %or594, i32* %modifiers593, align 4
  %367 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers595 = getelementptr inbounds %struct.input_event, %struct.input_event* %367, i32 0, i32 2
  %368 = load i32, i32* %modifiers595, align 4
  %and596 = and i32 %368, -2
  store i32 %and596, i32* %modifiers595, align 4
  %369 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code597 = getelementptr inbounds %struct.input_event, %struct.input_event* %369, i32 0, i32 1
  %370 = load i32, i32* %code597, align 4
  %conv598 = zext i32 %370 to i64
  %371 = load i64, i64* @mouse_syms, align 8
  %call599 = call i64 @ASIZE(i64 %371)
  %cmp600 = icmp sge i64 %conv598, %call599
  br i1 %cmp600, label %if.then.602, label %if.end.609

if.then.602:                                      ; preds = %sw.bb.588
  %372 = load i64, i64* @mouse_syms, align 8
  %373 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code603 = getelementptr inbounds %struct.input_event, %struct.input_event* %373, i32 0, i32 1
  %374 = load i32, i32* %code603, align 4
  %conv604 = zext i32 %374 to i64
  %375 = load i64, i64* @mouse_syms, align 8
  %call605 = call i64 @ASIZE(i64 %375)
  %sub606 = sub nsw i64 %conv604, %call605
  %add607 = add nsw i64 %sub606, 1
  %call608 = call i64 @larger_vector(i64 %372, i64 %add607, i64 -1)
  store i64 %call608, i64* @mouse_syms, align 8
  br label %if.end.609

if.end.609:                                       ; preds = %if.then.602, %sw.bb.588
  %376 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code610 = getelementptr inbounds %struct.input_event, %struct.input_event* %376, i32 0, i32 1
  %377 = load i32, i32* %code610, align 4
  %conv611 = zext i32 %377 to i64
  %378 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers612 = getelementptr inbounds %struct.input_event, %struct.input_event* %378, i32 0, i32 2
  %379 = load i32, i32* %modifiers612, align 4
  %call613 = call i64 @builtin_lisp_symbol(i32 685)
  %380 = load i64, i64* @Vlispy_mouse_stem, align 8
  %381 = load i64, i64* @mouse_syms, align 8
  %call614 = call i64 @ASIZE(i64 %381)
  %call615 = call i64 @modify_event_symbol(i64 %conv611, i32 %379, i64 %call613, i64 %380, i8** null, i64* @mouse_syms, i64 %call614)
  store i64 %call615, i64* %head590, align 8
  %382 = load i64, i64* %head590, align 8
  %383 = load i64, i64* %position589, align 8
  %call616 = call i64 @list2(i64 %382, i64 %383)
  store i64 %call616, i64* %retval
  br label %return

sw.bb.617:                                        ; preds = %entry
  %384 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %call620 = call i64 @builtin_lisp_symbol(i32 524)
  %call621 = call i64 @make_scroll_bar_position(%struct.input_event* %384, i64 %call620)
  store i64 %call621, i64* %position618, align 8
  %385 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers622 = getelementptr inbounds %struct.input_event, %struct.input_event* %385, i32 0, i32 2
  %386 = load i32, i32* %modifiers622, align 4
  %or623 = or i32 %386, 8
  store i32 %or623, i32* %modifiers622, align 4
  %387 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers624 = getelementptr inbounds %struct.input_event, %struct.input_event* %387, i32 0, i32 2
  %388 = load i32, i32* %modifiers624, align 4
  %and625 = and i32 %388, -2
  store i32 %and625, i32* %modifiers624, align 4
  %389 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code626 = getelementptr inbounds %struct.input_event, %struct.input_event* %389, i32 0, i32 1
  %390 = load i32, i32* %code626, align 4
  %conv627 = zext i32 %390 to i64
  %391 = load i64, i64* @mouse_syms, align 8
  %call628 = call i64 @ASIZE(i64 %391)
  %cmp629 = icmp sge i64 %conv627, %call628
  br i1 %cmp629, label %if.then.631, label %if.end.638

if.then.631:                                      ; preds = %sw.bb.617
  %392 = load i64, i64* @mouse_syms, align 8
  %393 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code632 = getelementptr inbounds %struct.input_event, %struct.input_event* %393, i32 0, i32 1
  %394 = load i32, i32* %code632, align 4
  %conv633 = zext i32 %394 to i64
  %395 = load i64, i64* @mouse_syms, align 8
  %call634 = call i64 @ASIZE(i64 %395)
  %sub635 = sub nsw i64 %conv633, %call634
  %add636 = add nsw i64 %sub635, 1
  %call637 = call i64 @larger_vector(i64 %392, i64 %add636, i64 -1)
  store i64 %call637, i64* @mouse_syms, align 8
  br label %if.end.638

if.end.638:                                       ; preds = %if.then.631, %sw.bb.617
  %396 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code639 = getelementptr inbounds %struct.input_event, %struct.input_event* %396, i32 0, i32 1
  %397 = load i32, i32* %code639, align 4
  %conv640 = zext i32 %397 to i64
  %398 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers641 = getelementptr inbounds %struct.input_event, %struct.input_event* %398, i32 0, i32 2
  %399 = load i32, i32* %modifiers641, align 4
  %call642 = call i64 @builtin_lisp_symbol(i32 685)
  %400 = load i64, i64* @Vlispy_mouse_stem, align 8
  %401 = load i64, i64* @mouse_syms, align 8
  %call643 = call i64 @ASIZE(i64 %401)
  %call644 = call i64 @modify_event_symbol(i64 %conv640, i32 %399, i64 %call642, i64 %400, i8** null, i64* @mouse_syms, i64 %call643)
  store i64 %call644, i64* %head619, align 8
  %402 = load i64, i64* %head619, align 8
  %403 = load i64, i64* %position618, align 8
  %call645 = call i64 @list2(i64 %402, i64 %403)
  store i64 %call645, i64* %retval
  br label %return

sw.bb.646:                                        ; preds = %entry
  %404 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window650 = getelementptr inbounds %struct.input_event, %struct.input_event* %404, i32 0, i32 6
  %405 = load i64, i64* %frame_or_window650, align 8
  %sub651 = sub nsw i64 %405, 5
  %406 = inttoptr i64 %sub651 to i8*
  %407 = bitcast i8* %406 to %struct.frame*
  store %struct.frame* %407, %struct.frame** %f647, align 8
  %408 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg = getelementptr inbounds %struct.input_event, %struct.input_event* %408, i32 0, i32 7
  %409 = load i64, i64* %arg, align 8
  store i64 %409, i64* %files, align 8
  %410 = load %struct.frame*, %struct.frame** %f647, align 8
  %terminal652 = getelementptr inbounds %struct.frame, %struct.frame* %410, i32 0, i32 61
  %411 = load %struct.terminal*, %struct.terminal** %terminal652, align 8
  %cmp653 = icmp ne %struct.terminal* %411, null
  br i1 %cmp653, label %if.end.657, label %if.then.655

if.then.655:                                      ; preds = %sw.bb.646
  %call656 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call656, i64* %retval
  br label %return

if.end.657:                                       ; preds = %sw.bb.646
  %412 = load %struct.frame*, %struct.frame** %f647, align 8
  %413 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %x658 = getelementptr inbounds %struct.input_event, %struct.input_event* %413, i32 0, i32 3
  %414 = load i64, i64* %x658, align 8
  %415 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %y659 = getelementptr inbounds %struct.input_event, %struct.input_event* %415, i32 0, i32 4
  %416 = load i64, i64* %y659, align 8
  %417 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %timestamp660 = getelementptr inbounds %struct.input_event, %struct.input_event* %417, i32 0, i32 5
  %418 = load i64, i64* %timestamp660, align 8
  %call661 = call i64 @make_lispy_position(%struct.frame* %412, i64 %414, i64 %416, i64 %418)
  store i64 %call661, i64* %position649, align 8
  %419 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers662 = getelementptr inbounds %struct.input_event, %struct.input_event* %419, i32 0, i32 2
  %420 = load i32, i32* %modifiers662, align 4
  %call663 = call i64 @builtin_lisp_symbol(i32 353)
  %call664 = call i64 @builtin_lisp_symbol(i32 0)
  %call665 = call i64 @modify_event_symbol(i64 0, i32 %420, i64 %call663, i64 %call664, i8** getelementptr inbounds ([1 x i8*], [1 x i8*]* @lispy_drag_n_drop_names, i32 0, i32 0), i64* @drag_n_drop_syms, i64 1)
  store i64 %call665, i64* %head648, align 8
  %421 = load i64, i64* %head648, align 8
  %422 = load i64, i64* %position649, align 8
  %423 = load i64, i64* %files, align 8
  %call666 = call i64 @list3(i64 %421, i64 %422, i64 %423)
  store i64 %call666, i64* %retval
  br label %return

sw.bb.667:                                        ; preds = %entry
  %424 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg668 = getelementptr inbounds %struct.input_event, %struct.input_event* %424, i32 0, i32 7
  %425 = load i64, i64* %arg668, align 8
  %426 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window669 = getelementptr inbounds %struct.input_event, %struct.input_event* %426, i32 0, i32 6
  %427 = load i64, i64* %frame_or_window669, align 8
  %cmp670 = icmp eq i64 %425, %427
  br i1 %cmp670, label %if.then.672, label %if.end.675

if.then.672:                                      ; preds = %sw.bb.667
  %call673 = call i64 @builtin_lisp_symbol(i32 651)
  %call674 = call i64 @list1(i64 %call673)
  store i64 %call674, i64* %retval
  br label %return

if.end.675:                                       ; preds = %sw.bb.667
  %428 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg676 = getelementptr inbounds %struct.input_event, %struct.input_event* %428, i32 0, i32 7
  %429 = load i64, i64* %arg676, align 8
  store i64 %429, i64* %retval
  br label %return

sw.bb.677:                                        ; preds = %entry
  %call678 = call i64 @builtin_lisp_symbol(i32 840)
  %430 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window679 = getelementptr inbounds %struct.input_event, %struct.input_event* %430, i32 0, i32 6
  %431 = load i64, i64* %frame_or_window679, align 8
  %call680 = call i64 @list1(i64 %431)
  %call681 = call i64 @list2(i64 %call678, i64 %call680)
  store i64 %call681, i64* %retval
  br label %return

sw.bb.682:                                        ; preds = %entry
  %432 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg683 = getelementptr inbounds %struct.input_event, %struct.input_event* %432, i32 0, i32 7
  %433 = load i64, i64* %arg683, align 8
  %434 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window684 = getelementptr inbounds %struct.input_event, %struct.input_event* %434, i32 0, i32 6
  %435 = load i64, i64* %frame_or_window684, align 8
  %cmp685 = icmp eq i64 %433, %435
  br i1 %cmp685, label %if.then.687, label %if.else.690

if.then.687:                                      ; preds = %sw.bb.682
  %call688 = call i64 @builtin_lisp_symbol(i32 921)
  %call689 = call i64 @list1(i64 %call688)
  store i64 %call689, i64* %retval
  br label %return

if.else.690:                                      ; preds = %sw.bb.682
  %436 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg691 = getelementptr inbounds %struct.input_event, %struct.input_event* %436, i32 0, i32 7
  %437 = load i64, i64* %arg691, align 8
  %and692 = and i64 %437, 7
  %conv693 = trunc i64 %and692 to i32
  %cmp694 = icmp eq i32 %conv693, 0
  br i1 %cmp694, label %if.then.696, label %if.end.700

if.then.696:                                      ; preds = %if.else.690
  %438 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %modifiers697 = getelementptr inbounds %struct.input_event, %struct.input_event* %438, i32 0, i32 2
  %439 = load i32, i32* %modifiers697, align 4
  %440 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg698 = getelementptr inbounds %struct.input_event, %struct.input_event* %440, i32 0, i32 7
  %441 = load i64, i64* %arg698, align 8
  %call699 = call i64 @apply_modifiers(i32 %439, i64 %441)
  store i64 %call699, i64* %retval
  br label %return

if.end.700:                                       ; preds = %if.else.690
  br label %if.end.701

if.end.701:                                       ; preds = %if.end.700
  %442 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg702 = getelementptr inbounds %struct.input_event, %struct.input_event* %442, i32 0, i32 7
  %443 = load i64, i64* %arg702, align 8
  store i64 %443, i64* %retval
  br label %return

sw.bb.703:                                        ; preds = %entry
  %444 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %code704 = getelementptr inbounds %struct.input_event, %struct.input_event* %444, i32 0, i32 1
  %445 = load i32, i32* %code704, align 4
  %call705 = call i8* @find_user_signal_name(i32 %445)
  store i8* %call705, i8** %name, align 8
  %446 = load i8*, i8** %name, align 8
  %tobool706 = icmp ne i8* %446, null
  br i1 %tobool706, label %if.end.708, label %if.then.707

if.then.707:                                      ; preds = %sw.bb.703
  call void @emacs_abort() #11
  unreachable

if.end.708:                                       ; preds = %sw.bb.703
  %447 = load i8*, i8** %name, align 8
  %call709 = call i64 @intern(i8* %447)
  store i64 %call709, i64* %retval
  br label %return

sw.bb.710:                                        ; preds = %entry
  %call711 = call i64 @builtin_lisp_symbol(i32 827)
  store i64 %call711, i64* %retval
  br label %return

sw.bb.712:                                        ; preds = %entry
  %call713 = call i64 @builtin_lisp_symbol(i32 423)
  %448 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg714 = getelementptr inbounds %struct.input_event, %struct.input_event* %448, i32 0, i32 7
  %449 = load i64, i64* %arg714, align 8
  %call715 = call i64 @Fcons(i64 %call713, i64 %449)
  store i64 %call715, i64* %retval
  br label %return

sw.bb.716:                                        ; preds = %entry
  %call717 = call i64 @builtin_lisp_symbol(i32 292)
  %450 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %arg718 = getelementptr inbounds %struct.input_event, %struct.input_event* %450, i32 0, i32 7
  %451 = load i64, i64* %arg718, align 8
  %452 = load %struct.input_event*, %struct.input_event** %event.addr, align 8
  %frame_or_window719 = getelementptr inbounds %struct.input_event, %struct.input_event* %452, i32 0, i32 6
  %453 = load i64, i64* %frame_or_window719, align 8
  %call720 = call i64 @list3(i64 %call717, i64 %451, i64 %453)
  store i64 %call720, i64* %retval
  br label %return

sw.default:                                       ; preds = %entry
  call void @emacs_abort() #11
  unreachable

return:                                           ; preds = %sw.bb.716, %sw.bb.712, %sw.bb.710, %if.end.708, %if.end.701, %if.then.696, %if.then.687, %sw.bb.677, %if.end.675, %if.then.672, %if.end.657, %if.then.655, %if.end.638, %if.end.609, %if.else.586, %if.then.581, %if.then.420, %if.else.409, %if.then.404, %if.then.398, %if.then.298, %for.end.153, %if.then.101, %if.end.83, %if.then.67, %if.then.45, %if.then.31, %if.end.22
  %454 = load i64, i64* %retval
  ret i64 %454
}

; Function Attrs: nounwind uwtable
define internal i64 @Time_to_position(i64 %encoded_pos) #0 {
entry:
  %retval = alloca i64, align 8
  %encoded_pos.addr = alloca i64, align 8
  %encoded_pos_min = alloca i64, align 8
  %notpos = alloca i64, align 8
  store i64 %encoded_pos, i64* %encoded_pos.addr, align 8
  %0 = load i64, i64* %encoded_pos.addr, align 8
  %cmp = icmp ule i64 %0, 2305843009213693951
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %encoded_pos.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i64 -2305843009213693952, i64* %encoded_pos_min, align 8
  %2 = load i64, i64* %encoded_pos.addr, align 8
  %sub = sub i64 -1, %2
  store i64 %sub, i64* %notpos, align 8
  %3 = load i64, i64* %notpos, align 8
  %sub1 = sub nsw i64 -1, %3
  store i64 %sub1, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, i64* %retval
  ret i64 %4
}

declare i64 @list5(i64, i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_focus_in(i64 %frame) #0 {
entry:
  %frame.addr = alloca i64, align 8
  store i64 %frame, i64* %frame.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 437)
  %0 = load i64, i64* %frame.addr, align 8
  %call1 = call i64 @list2(i64 %call, i64 %0)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_focus_out(i64 %frame) #0 {
entry:
  %frame.addr = alloca i64, align 8
  store i64 %frame, i64* %frame.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 438)
  %0 = load i64, i64* %frame.addr, align 8
  %call1 = call i64 @list2(i64 %call, i64 %0)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @make_lispy_movement(%struct.frame* %frame, i64 %bar_window, i32 %part, i64 %x, i64 %y, i64 %t) #0 {
entry:
  %retval = alloca i64, align 8
  %frame.addr = alloca %struct.frame*, align 8
  %bar_window.addr = alloca i64, align 8
  %part.addr = alloca i32, align 4
  %x.addr = alloca i64, align 8
  %y.addr = alloca i64, align 8
  %t.addr = alloca i64, align 8
  %part_sym = alloca i64, align 8
  %position = alloca i64, align 8
  store %struct.frame* %frame, %struct.frame** %frame.addr, align 8
  store i64 %bar_window, i64* %bar_window.addr, align 8
  store i32 %part, i32* %part.addr, align 4
  store i64 %x, i64* %x.addr, align 8
  store i64 %y, i64* %y.addr, align 8
  store i64 %t, i64* %t.addr, align 8
  %0 = load %struct.frame*, %struct.frame** %frame.addr, align 8
  %tobool = icmp ne %struct.frame* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %bar_window.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load i32, i32* %part.addr, align 4
  %idxprom = zext i32 %2 to i64
  %arrayidx = getelementptr inbounds [19 x i16], [19 x i16]* @scroll_bar_parts, i32 0, i64 %idxprom
  %3 = load i16, i16* %arrayidx, align 2
  %conv = sext i16 %3 to i32
  %call1 = call i64 @builtin_lisp_symbol(i32 %conv)
  store i64 %call1, i64* %part_sym, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 834)
  %4 = load i64, i64* %bar_window.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 1002)
  %5 = load i64, i64* %x.addr, align 8
  %6 = load i64, i64* %y.addr, align 8
  %call4 = call i64 @Fcons(i64 %5, i64 %6)
  %7 = load i64, i64* %t.addr, align 8
  %shl = shl i64 %7, 2
  %add = add i64 %shl, 2
  %8 = load i64, i64* %part_sym, align 8
  %call5 = call i64 @list5(i64 %4, i64 %call3, i64 %call4, i64 %add, i64 %8)
  %call6 = call i64 @list2(i64 %call2, i64 %call5)
  store i64 %call6, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %9 = load %struct.frame*, %struct.frame** %frame.addr, align 8
  %10 = load i64, i64* %x.addr, align 8
  %11 = load i64, i64* %y.addr, align 8
  %12 = load i64, i64* %t.addr, align 8
  %call7 = call i64 @make_lispy_position(%struct.frame* %9, i64 %10, i64 %11, i64 %12)
  store i64 %call7, i64* %position, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 690)
  %13 = load i64, i64* %position, align 8
  %call9 = call i64 @list2(i64 %call8, i64 %13)
  store i64 %call9, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %14 = load i64, i64* %retval
  ret i64 %14
}

; Function Attrs: nounwind uwtable
define internal i64 @modify_event_symbol(i64 %symbol_num, i32 %modifiers, i64 %symbol_kind, i64 %name_alist_or_stem, i8** %name_table, i64* %symbol_table, i64 %table_size) #0 {
entry:
  %retval = alloca i64, align 8
  %symbol_num.addr = alloca i64, align 8
  %modifiers.addr = alloca i32, align 4
  %symbol_kind.addr = alloca i64, align 8
  %name_alist_or_stem.addr = alloca i64, align 8
  %name_table.addr = alloca i8**, align 8
  %symbol_table.addr = alloca i64*, align 8
  %table_size.addr = alloca i64, align 8
  %value = alloca i64, align 8
  %symbol_int = alloca i64, align 8
  %size = alloca i64, align 8
  %buf = alloca i8*, align 8
  %len = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %name = alloca i8*, align 8
  %buf74 = alloca [25 x i8], align 16
  store i64 %symbol_num, i64* %symbol_num.addr, align 8
  store i32 %modifiers, i32* %modifiers.addr, align 4
  store i64 %symbol_kind, i64* %symbol_kind.addr, align 8
  store i64 %name_alist_or_stem, i64* %name_alist_or_stem.addr, align 8
  store i8** %name_table, i8*** %name_table.addr, align 8
  store i64* %symbol_table, i64** %symbol_table.addr, align 8
  store i64 %table_size, i64* %table_size.addr, align 8
  %0 = load i64, i64* %symbol_num.addr, align 8
  %and = and i64 %0, 16777215
  %shl = shl i64 %and, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %symbol_int, align 8
  %1 = load i64, i64* %symbol_num.addr, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64, i64* %symbol_num.addr, align 8
  %3 = load i64, i64* %table_size.addr, align 8
  %cmp1 = icmp sge i64 %2, %3
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load i64*, i64** %symbol_table.addr, align 8
  %5 = load i64, i64* %4, align 8
  %and2 = and i64 %5, 7
  %conv = trunc i64 %and2 to i32
  %cmp3 = icmp eq i32 %conv, 3
  br i1 %cmp3, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.end
  %6 = load i64, i64* %symbol_int, align 8
  %7 = load i64*, i64** %symbol_table.addr, align 8
  %8 = load i64, i64* %7, align 8
  %call6 = call i64 @assq_no_quit(i64 %6, i64 %8)
  %call7 = call i64 @Fcdr(i64 %call6)
  store i64 %call7, i64* %value, align 8
  br label %if.end.19

if.else:                                          ; preds = %if.end
  %9 = load i64*, i64** %symbol_table.addr, align 8
  %10 = load i64, i64* %9, align 8
  %call8 = call zeroext i1 @VECTORP(i64 %10)
  br i1 %call8, label %lor.lhs.false.9, label %if.then.13

lor.lhs.false.9:                                  ; preds = %if.else
  %11 = load i64*, i64** %symbol_table.addr, align 8
  %12 = load i64, i64* %11, align 8
  %call10 = call i64 @ASIZE(i64 %12)
  %13 = load i64, i64* %table_size.addr, align 8
  %cmp11 = icmp ne i64 %call10, %13
  br i1 %cmp11, label %if.then.13, label %if.end.17

if.then.13:                                       ; preds = %lor.lhs.false.9, %if.else
  %14 = load i64, i64* %table_size.addr, align 8
  %call14 = call i64 @make_natnum(i64 %14)
  store i64 %call14, i64* %size, align 8
  %15 = load i64, i64* %size, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %call16 = call i64 @Fmake_vector(i64 %15, i64 %call15)
  %16 = load i64*, i64** %symbol_table.addr, align 8
  store i64 %call16, i64* %16, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.13, %lor.lhs.false.9
  %17 = load i64*, i64** %symbol_table.addr, align 8
  %18 = load i64, i64* %17, align 8
  %19 = load i64, i64* %symbol_num.addr, align 8
  %call18 = call i64 @AREF(i64 %18, i64 %19)
  store i64 %call18, i64* %value, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.17, %if.then.5
  %20 = load i64, i64* %value, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %20, %call20
  br i1 %cmp21, label %if.then.23, label %if.end.92

if.then.23:                                       ; preds = %if.end.19
  %21 = load i64, i64* %name_alist_or_stem.addr, align 8
  %and24 = and i64 %21, 7
  %conv25 = trunc i64 %and24 to i32
  %cmp26 = icmp eq i32 %conv25, 3
  br i1 %cmp26, label %if.then.28, label %if.else.31

if.then.28:                                       ; preds = %if.then.23
  %22 = load i64, i64* %symbol_int, align 8
  %23 = load i64, i64* %name_alist_or_stem.addr, align 8
  %call29 = call i64 @Fassq(i64 %22, i64 %23)
  %call30 = call i64 @Fcdr_safe(i64 %call29)
  store i64 %call30, i64* %value, align 8
  br label %if.end.58

if.else.31:                                       ; preds = %if.then.23
  %24 = load i64, i64* %name_alist_or_stem.addr, align 8
  %call32 = call zeroext i1 @STRINGP(i64 %24)
  br i1 %call32, label %if.then.33, label %if.else.49

if.then.33:                                       ; preds = %if.else.31
  %25 = load i64, i64* %name_alist_or_stem.addr, align 8
  %call34 = call i64 @SBYTES(i64 %25)
  %add35 = add i64 %call34, 2
  %add36 = add i64 %add35, 20
  store i64 %add36, i64* %len, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call37 = call i64 @SPECPDL_INDEX()
  store i64 %call37, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %26 = load i64, i64* %len, align 8
  %27 = load i64, i64* %sa_avail, align 8
  %cmp38 = icmp sle i64 %26, %27
  br i1 %cmp38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.33
  %28 = load i64, i64* %len, align 8
  %29 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %29, %28
  store i64 %sub, i64* %sa_avail, align 8
  %30 = load i64, i64* %len, align 8
  %31 = alloca i8, i64 %30
  br label %cond.end

cond.false:                                       ; preds = %if.then.33
  store i8 1, i8* %sa_must_free, align 1
  %32 = load i64, i64* %len, align 8
  %call40 = call i8* @record_xmalloc(i64 %32)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %31, %cond.true ], [ %call40, %cond.false ]
  store i8* %cond, i8** %buf, align 8
  %33 = load i8*, i8** %buf, align 8
  %34 = load i64, i64* %name_alist_or_stem.addr, align 8
  %call41 = call i8* @SDATA(i64 %34)
  %35 = load i64, i64* %symbol_int, align 8
  %shr = ashr i64 %35, 2
  %add42 = add nsw i64 %shr, 1
  %call43 = call i64 (i8*, i8*, ...) @esprintf(i8* %33, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.192, i32 0, i32 0), i8* %call41, i64 %add42)
  %36 = load i8*, i8** %buf, align 8
  %call44 = call i64 @intern(i8* %36)
  store i64 %call44, i64* %value, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %37 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %37 to i1
  br i1 %tobool, label %if.then.45, label %if.end.48

if.then.45:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %38 = load i64, i64* %sa_count, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %call47 = call i64 @unbind_to(i64 %38, i64 %call46)
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.45, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.48
  br label %if.end.57

if.else.49:                                       ; preds = %if.else.31
  %39 = load i8**, i8*** %name_table.addr, align 8
  %cmp50 = icmp ne i8** %39, null
  br i1 %cmp50, label %land.lhs.true, label %if.end.56

land.lhs.true:                                    ; preds = %if.else.49
  %40 = load i64, i64* %symbol_num.addr, align 8
  %41 = load i8**, i8*** %name_table.addr, align 8
  %arrayidx = getelementptr inbounds i8*, i8** %41, i64 %40
  %42 = load i8*, i8** %arrayidx, align 8
  %tobool52 = icmp ne i8* %42, null
  br i1 %tobool52, label %if.then.53, label %if.end.56

if.then.53:                                       ; preds = %land.lhs.true
  %43 = load i64, i64* %symbol_num.addr, align 8
  %44 = load i8**, i8*** %name_table.addr, align 8
  %arrayidx54 = getelementptr inbounds i8*, i8** %44, i64 %43
  %45 = load i8*, i8** %arrayidx54, align 8
  %call55 = call i64 @intern(i8* %45)
  store i64 %call55, i64* %value, align 8
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.53, %land.lhs.true, %if.else.49
  br label %if.end.57

if.end.57:                                        ; preds = %if.end.56, %do.end
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.57, %if.then.28
  %46 = load i64, i64* %value, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp60 = icmp eq i64 %46, %call59
  br i1 %cmp60, label %if.then.62, label %if.end.69

if.then.62:                                       ; preds = %if.end.58
  %47 = load i64, i64* %symbol_num.addr, align 8
  %conv63 = trunc i64 %47 to i32
  %call64 = call i8* @x_get_keysym_name(i32 %conv63)
  store i8* %call64, i8** %name, align 8
  %48 = load i8*, i8** %name, align 8
  %tobool65 = icmp ne i8* %48, null
  br i1 %tobool65, label %if.then.66, label %if.end.68

if.then.66:                                       ; preds = %if.then.62
  %49 = load i8*, i8** %name, align 8
  %call67 = call i64 @intern(i8* %49)
  store i64 %call67, i64* %value, align 8
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.66, %if.then.62
  br label %if.end.69

if.end.69:                                        ; preds = %if.end.68, %if.end.58
  %50 = load i64, i64* %value, align 8
  %call70 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp71 = icmp eq i64 %50, %call70
  br i1 %cmp71, label %if.then.73, label %if.end.78

if.then.73:                                       ; preds = %if.end.69
  %arraydecay = getelementptr inbounds [25 x i8], [25 x i8]* %buf74, i32 0, i32 0
  %51 = load i64, i64* %symbol_num.addr, align 8
  %call75 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.193, i32 0, i32 0), i64 %51) #8
  %arraydecay76 = getelementptr inbounds [25 x i8], [25 x i8]* %buf74, i32 0, i32 0
  %call77 = call i64 @intern(i8* %arraydecay76)
  store i64 %call77, i64* %value, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.73, %if.end.69
  %52 = load i64*, i64** %symbol_table.addr, align 8
  %53 = load i64, i64* %52, align 8
  %and79 = and i64 %53, 7
  %conv80 = trunc i64 %and79 to i32
  %cmp81 = icmp eq i32 %conv80, 3
  br i1 %cmp81, label %if.then.83, label %if.else.86

if.then.83:                                       ; preds = %if.end.78
  %54 = load i64, i64* %symbol_int, align 8
  %55 = load i64, i64* %value, align 8
  %call84 = call i64 @Fcons(i64 %54, i64 %55)
  %56 = load i64*, i64** %symbol_table.addr, align 8
  %57 = load i64, i64* %56, align 8
  %call85 = call i64 @Fcons(i64 %call84, i64 %57)
  %58 = load i64*, i64** %symbol_table.addr, align 8
  store i64 %call85, i64* %58, align 8
  br label %if.end.87

if.else.86:                                       ; preds = %if.end.78
  %59 = load i64*, i64** %symbol_table.addr, align 8
  %60 = load i64, i64* %59, align 8
  %61 = load i64, i64* %symbol_num.addr, align 8
  %62 = load i64, i64* %value, align 8
  call void @ASET(i64 %60, i64 %61, i64 %62)
  br label %if.end.87

if.end.87:                                        ; preds = %if.else.86, %if.then.83
  %63 = load i32, i32* %modifiers.addr, align 4
  %and88 = and i32 %63, 8
  %64 = load i64, i64* %value, align 8
  %call89 = call i64 @apply_modifiers(i32 %and88, i64 %64)
  %65 = load i64, i64* %value, align 8
  %call90 = call i64 @builtin_lisp_symbol(i32 382)
  %66 = load i64, i64* %symbol_kind.addr, align 8
  %call91 = call i64 @Fput(i64 %65, i64 %call90, i64 %66)
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.87, %if.end.19
  %67 = load i32, i32* %modifiers.addr, align 4
  %68 = load i64, i64* %value, align 8
  %call93 = call i64 @apply_modifiers(i32 %67, i64 %68)
  store i64 %call93, i64* %retval
  br label %return

return:                                           ; preds = %if.end.92, %if.then
  %69 = load i64, i64* %retval
  ret i64 %69
}

; Function Attrs: nounwind uwtable
define internal void @kset_system_key_syms(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %system_key_syms_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 16
  store i64 %0, i64* %system_key_syms_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @toolkit_menubar_in_use(%struct.frame* %f) #0 {
entry:
  %f.addr = alloca %struct.frame*, align 8
  store %struct.frame* %f, %struct.frame** %f.addr, align 8
  %0 = load %struct.frame*, %struct.frame** %f.addr, align 8
  %output_method = getelementptr inbounds %struct.frame, %struct.frame* %0, i32 0, i32 26
  %1 = bitcast i48* %output_method to i64*
  %bf.load = load i64, i64* %1, align 8
  %bf.lshr = lshr i64 %bf.load, 23
  %bf.clear = and i64 %bf.lshr, 7
  %bf.cast = trunc i64 %bf.clear to i32
  %cmp = icmp eq i32 %bf.cast, 2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  ret i1 %lnot1
}

declare void @pixel_to_glyph_coords(%struct.frame*, i32, i32, i32*, i32*, %struct.XRectangle*, i1 zeroext) #1

declare i64 @Fcopy_alist(i64) #1

declare i64 @list3(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @make_scroll_bar_position(%struct.input_event* %ev, i64 %type) #0 {
entry:
  %ev.addr = alloca %struct.input_event*, align 8
  %type.addr = alloca i64, align 8
  store %struct.input_event* %ev, %struct.input_event** %ev.addr, align 8
  store i64 %type, i64* %type.addr, align 8
  %0 = load %struct.input_event*, %struct.input_event** %ev.addr, align 8
  %frame_or_window = getelementptr inbounds %struct.input_event, %struct.input_event* %0, i32 0, i32 6
  %1 = load i64, i64* %frame_or_window, align 8
  %2 = load i64, i64* %type.addr, align 8
  %3 = load %struct.input_event*, %struct.input_event** %ev.addr, align 8
  %x = getelementptr inbounds %struct.input_event, %struct.input_event* %3, i32 0, i32 3
  %4 = load i64, i64* %x, align 8
  %5 = load %struct.input_event*, %struct.input_event** %ev.addr, align 8
  %y = getelementptr inbounds %struct.input_event, %struct.input_event* %5, i32 0, i32 4
  %6 = load i64, i64* %y, align 8
  %call = call i64 @Fcons(i64 %4, i64 %6)
  %7 = load %struct.input_event*, %struct.input_event** %ev.addr, align 8
  %timestamp = getelementptr inbounds %struct.input_event, %struct.input_event* %7, i32 0, i32 5
  %8 = load i64, i64* %timestamp, align 8
  %shl = shl i64 %8, 2
  %add = add i64 %shl, 2
  %9 = load %struct.input_event*, %struct.input_event** %ev.addr, align 8
  %10 = bitcast %struct.input_event* %9 to i32*
  %bf.load = load i32, i32* %10, align 8
  %bf.lshr = lshr i32 %bf.load, 16
  %idxprom = zext i32 %bf.lshr to i64
  %arrayidx = getelementptr inbounds [19 x i16], [19 x i16]* @scroll_bar_parts, i32 0, i64 %idxprom
  %11 = load i16, i16* %arrayidx, align 2
  %conv = sext i16 %11 to i32
  %call1 = call i64 @builtin_lisp_symbol(i32 %conv)
  %call2 = call i64 @list5(i64 %1, i64 %2, i64 %call, i64 %add, i64 %call1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i8* @find_user_signal_name(i32 %sig) #0 {
entry:
  %retval = alloca i8*, align 8
  %sig.addr = alloca i32, align 4
  %p = alloca %struct.user_signal_info*, align 8
  store i32 %sig, i32* %sig.addr, align 4
  %0 = load %struct.user_signal_info*, %struct.user_signal_info** @user_signals, align 8
  store %struct.user_signal_info* %0, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %tobool = icmp ne %struct.user_signal_info* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %sig1 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %2, i32 0, i32 0
  %3 = load i32, i32* %sig1, align 4
  %4 = load i32, i32* %sig.addr, align 4
  %cmp = icmp eq i32 %3, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %5 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %name = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %5, i32 0, i32 1
  %6 = load i8*, i8** %name, align 8
  store i8* %6, i8** %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %next = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %7, i32 0, i32 3
  %8 = load %struct.user_signal_info*, %struct.user_signal_info** %next, align 8
  store %struct.user_signal_info* %8, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %9 = load i8*, i8** %retval
  ret i8* %9
}

declare i64 @assq_no_quit(i64, i64) #1

declare i64 @Fcdr_safe(i64) #1

declare i64 @Fassq(i64, i64) #1

declare i8* @record_xmalloc(i64) #1

declare i64 @esprintf(i8*, i8*, ...) #1

declare i8* @x_get_keysym_name(i32) #1

declare i64 @Fsubstring(i64, i64, i64) #1

declare void @truncate_echo_area(i64) #1

; Function Attrs: nounwind uwtable
define internal void @echo_add_key(i64 %c) #0 {
entry:
  %c.addr = alloca i64, align 8
  %initbuf = alloca [122 x i8], align 16
  %size = alloca i64, align 8
  %buffer = alloca i8*, align 8
  %ptr = alloca i8*, align 8
  %echo_string = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %name = alloca i64, align 8
  %nbytes = alloca i64, align 8
  %offset = alloca i64, align 8
  %len = alloca i32, align 4
  %offset67 = alloca i64, align 8
  store i64 %c, i64* %c.addr, align 8
  store i64 122, i64* %size, align 8
  %arraydecay = getelementptr inbounds [122 x i8], [122 x i8]* %initbuf, i32 0, i32 0
  store i8* %arraydecay, i8** %buffer, align 8
  %0 = load i8*, i8** %buffer, align 8
  store i8* %0, i8** %ptr, align 8
  %1 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 22
  %2 = load i64, i64* %echo_string_, align 8
  store i64 %2, i64* %echo_string, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %3 = load i64, i64* %echo_string, align 8
  %call1 = call zeroext i1 @STRINGP(i64 %3)
  br i1 %call1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load i64, i64* %echo_string, align 8
  %call2 = call i64 @SCHARS(i64 %4)
  %cmp = icmp sgt i64 %call2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load i8*, i8** %ptr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr, i8** %ptr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %5, i64 0
  store i8 32, i8* %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %6 = load i64, i64* %c.addr, align 8
  %and = and i64 %6, 7
  %conv = trunc i64 %and to i32
  %cmp3 = icmp eq i32 %conv, 3
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load i64, i64* %c.addr, align 8
  %sub = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 0
  %10 = load i64, i64* %car, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %11 = load i64, i64* %c.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %c.addr, align 8
  %12 = load i64, i64* %c.addr, align 8
  %and5 = and i64 %12, 7
  %conv6 = trunc i64 %and5 to i32
  %and7 = and i32 %conv6, -5
  %cmp8 = icmp eq i32 %and7, 2
  br i1 %cmp8, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %cond.end
  %13 = load i64, i64* %c.addr, align 8
  %shr = ashr i64 %13, 2
  %14 = load i8*, i8** %ptr, align 8
  %call11 = call i8* @push_key_description(i64 %shr, i8* %14)
  store i8* %call11, i8** %ptr, align 8
  br label %if.end.48

if.else:                                          ; preds = %cond.end
  %15 = load i64, i64* %c.addr, align 8
  %and12 = and i64 %15, 7
  %conv13 = trunc i64 %and12 to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %if.then.16, label %if.end.47

if.then.16:                                       ; preds = %if.else
  %16 = load i64, i64* %c.addr, align 8
  %call17 = call i64 @SYMBOL_NAME(i64 %16)
  store i64 %call17, i64* %name, align 8
  %17 = load i64, i64* %name, align 8
  %call18 = call i64 @SBYTES(i64 %17)
  store i64 %call18, i64* %nbytes, align 8
  %18 = load i64, i64* %size, align 8
  %19 = load i8*, i8** %ptr, align 8
  %20 = load i8*, i8** %buffer, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %19 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %20 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub19 = sub nsw i64 %18, %sub.ptr.sub
  %21 = load i64, i64* %nbytes, align 8
  %cmp20 = icmp slt i64 %sub19, %21
  br i1 %cmp20, label %if.then.22, label %if.end.42

if.then.22:                                       ; preds = %if.then.16
  %22 = load i8*, i8** %ptr, align 8
  %23 = load i8*, i8** %buffer, align 8
  %sub.ptr.lhs.cast23 = ptrtoint i8* %22 to i64
  %sub.ptr.rhs.cast24 = ptrtoint i8* %23 to i64
  %sub.ptr.sub25 = sub i64 %sub.ptr.lhs.cast23, %sub.ptr.rhs.cast24
  store i64 %sub.ptr.sub25, i64* %offset, align 8
  %24 = load i64, i64* %size, align 8
  %mul = mul nsw i64 2, %24
  %25 = load i64, i64* %size, align 8
  %26 = load i64, i64* %nbytes, align 8
  %add = add nsw i64 %25, %26
  %cmp26 = icmp sgt i64 %mul, %add
  br i1 %cmp26, label %cond.true.28, label %cond.false.30

cond.true.28:                                     ; preds = %if.then.22
  %27 = load i64, i64* %size, align 8
  %mul29 = mul nsw i64 2, %27
  br label %cond.end.32

cond.false.30:                                    ; preds = %if.then.22
  %28 = load i64, i64* %size, align 8
  %29 = load i64, i64* %nbytes, align 8
  %add31 = add nsw i64 %28, %29
  br label %cond.end.32

cond.end.32:                                      ; preds = %cond.false.30, %cond.true.28
  %cond33 = phi i64 [ %mul29, %cond.true.28 ], [ %add31, %cond.false.30 ]
  store i64 %cond33, i64* %size, align 8
  %30 = load i64, i64* %size, align 8
  %31 = load i64, i64* %sa_avail, align 8
  %cmp34 = icmp sle i64 %30, %31
  br i1 %cmp34, label %cond.true.36, label %cond.false.38

cond.true.36:                                     ; preds = %cond.end.32
  %32 = load i64, i64* %size, align 8
  %33 = load i64, i64* %sa_avail, align 8
  %sub37 = sub nsw i64 %33, %32
  store i64 %sub37, i64* %sa_avail, align 8
  %34 = load i64, i64* %size, align 8
  %35 = alloca i8, i64 %34
  br label %cond.end.40

cond.false.38:                                    ; preds = %cond.end.32
  store i8 1, i8* %sa_must_free, align 1
  %36 = load i64, i64* %size, align 8
  %call39 = call i8* @record_xmalloc(i64 %36)
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.38, %cond.true.36
  %cond41 = phi i8* [ %35, %cond.true.36 ], [ %call39, %cond.false.38 ]
  store i8* %cond41, i8** %buffer, align 8
  %37 = load i8*, i8** %buffer, align 8
  %38 = load i64, i64* %offset, align 8
  %add.ptr = getelementptr inbounds i8, i8* %37, i64 %38
  store i8* %add.ptr, i8** %ptr, align 8
  br label %if.end.42

if.end.42:                                        ; preds = %cond.end.40, %if.then.16
  %39 = load i64, i64* %name, align 8
  %call43 = call i8* @SDATA(i64 %39)
  %40 = load i8*, i8** %ptr, align 8
  %41 = load i64, i64* %nbytes, align 8
  %42 = load i64, i64* %name, align 8
  %call44 = call zeroext i1 @STRING_MULTIBYTE(i64 %42)
  %call45 = call i64 @copy_text(i8* %call43, i8* %40, i64 %41, i1 zeroext %call44, i1 zeroext true)
  %43 = load i8*, i8** %ptr, align 8
  %add.ptr46 = getelementptr inbounds i8, i8* %43, i64 %call45
  store i8* %add.ptr46, i8** %ptr, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.42, %if.else
  br label %if.end.48

if.end.48:                                        ; preds = %if.end.47, %if.then.10
  %44 = load i64, i64* %echo_string, align 8
  %call49 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp50 = icmp eq i64 %44, %call49
  br i1 %cmp50, label %land.lhs.true.55, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.48
  %45 = load i64, i64* %echo_string, align 8
  %call52 = call i64 @SCHARS(i64 %45)
  %cmp53 = icmp eq i64 %call52, 0
  br i1 %cmp53, label %land.lhs.true.55, label %if.end.85

land.lhs.true.55:                                 ; preds = %lor.lhs.false, %if.end.48
  %46 = load i64, i64* %c.addr, align 8
  %call56 = call zeroext i1 @help_char_p(i64 %46)
  br i1 %call56, label %if.then.58, label %if.end.85

if.then.58:                                       ; preds = %land.lhs.true.55
  store i32 29, i32* %len, align 4
  %47 = load i64, i64* %size, align 8
  %48 = load i8*, i8** %ptr, align 8
  %49 = load i8*, i8** %buffer, align 8
  %sub.ptr.lhs.cast59 = ptrtoint i8* %48 to i64
  %sub.ptr.rhs.cast60 = ptrtoint i8* %49 to i64
  %sub.ptr.sub61 = sub i64 %sub.ptr.lhs.cast59, %sub.ptr.rhs.cast60
  %sub62 = sub nsw i64 %47, %sub.ptr.sub61
  %50 = load i32, i32* %len, align 4
  %conv63 = sext i32 %50 to i64
  %cmp64 = icmp slt i64 %sub62, %conv63
  br i1 %cmp64, label %if.then.66, label %if.end.82

if.then.66:                                       ; preds = %if.then.58
  %51 = load i8*, i8** %ptr, align 8
  %52 = load i8*, i8** %buffer, align 8
  %sub.ptr.lhs.cast68 = ptrtoint i8* %51 to i64
  %sub.ptr.rhs.cast69 = ptrtoint i8* %52 to i64
  %sub.ptr.sub70 = sub i64 %sub.ptr.lhs.cast68, %sub.ptr.rhs.cast69
  store i64 %sub.ptr.sub70, i64* %offset67, align 8
  %53 = load i32, i32* %len, align 4
  %conv71 = sext i32 %53 to i64
  %54 = load i64, i64* %size, align 8
  %add72 = add nsw i64 %54, %conv71
  store i64 %add72, i64* %size, align 8
  %55 = load i64, i64* %size, align 8
  %56 = load i64, i64* %sa_avail, align 8
  %cmp73 = icmp sle i64 %55, %56
  br i1 %cmp73, label %cond.true.75, label %cond.false.77

cond.true.75:                                     ; preds = %if.then.66
  %57 = load i64, i64* %size, align 8
  %58 = load i64, i64* %sa_avail, align 8
  %sub76 = sub nsw i64 %58, %57
  store i64 %sub76, i64* %sa_avail, align 8
  %59 = load i64, i64* %size, align 8
  %60 = alloca i8, i64 %59
  br label %cond.end.79

cond.false.77:                                    ; preds = %if.then.66
  store i8 1, i8* %sa_must_free, align 1
  %61 = load i64, i64* %size, align 8
  %call78 = call i8* @record_xmalloc(i64 %61)
  br label %cond.end.79

cond.end.79:                                      ; preds = %cond.false.77, %cond.true.75
  %cond80 = phi i8* [ %60, %cond.true.75 ], [ %call78, %cond.false.77 ]
  store i8* %cond80, i8** %buffer, align 8
  %62 = load i8*, i8** %buffer, align 8
  %63 = load i64, i64* %offset67, align 8
  %add.ptr81 = getelementptr inbounds i8, i8* %62, i64 %63
  store i8* %add.ptr81, i8** %ptr, align 8
  br label %if.end.82

if.end.82:                                        ; preds = %cond.end.79, %if.then.58
  %64 = load i8*, i8** %ptr, align 8
  %65 = load i32, i32* %len, align 4
  %conv83 = sext i32 %65 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %64, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @echo_add_key.text, i32 0, i32 0), i64 %conv83, i32 1, i1 false)
  %66 = load i32, i32* %len, align 4
  %67 = load i8*, i8** %ptr, align 8
  %idx.ext = sext i32 %66 to i64
  %add.ptr84 = getelementptr inbounds i8, i8* %67, i64 %idx.ext
  store i8* %add.ptr84, i8** %ptr, align 8
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.82, %land.lhs.true.55, %lor.lhs.false
  %68 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %69 = load i64, i64* %echo_string, align 8
  %70 = load i8*, i8** %buffer, align 8
  %71 = load i8*, i8** %ptr, align 8
  %72 = load i8*, i8** %buffer, align 8
  %sub.ptr.lhs.cast86 = ptrtoint i8* %71 to i64
  %sub.ptr.rhs.cast87 = ptrtoint i8* %72 to i64
  %sub.ptr.sub88 = sub i64 %sub.ptr.lhs.cast86, %sub.ptr.rhs.cast87
  %call89 = call i64 @make_string(i8* %70, i64 %sub.ptr.sub88)
  %call90 = call i64 @concat2(i64 %69, i64 %call89)
  call void @kset_echo_string(%struct.kboard* %68, i64 %call90)
  br label %do.body

do.body:                                          ; preds = %if.end.85
  %73 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %73 to i1
  br i1 %tobool, label %if.then.91, label %if.end.94

if.then.91:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %74 = load i64, i64* %sa_count, align 8
  %call92 = call i64 @builtin_lisp_symbol(i32 0)
  %call93 = call i64 @unbind_to(i64 %74, i64 %call92)
  br label %if.end.94

if.end.94:                                        ; preds = %if.then.91, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.94
  ret void
}

declare i8* @push_key_description(i64, i8*) #1

declare i64 @copy_text(i8*, i8*, i64, i1 zeroext, i1 zeroext) #1

declare zeroext i1 @STRING_MULTIBYTE(i64) #1

declare i64 @Fset_window_configuration(i64) #1

declare i64 @Fcar_safe(i64) #1

declare void @store_kbd_macro_char(i64) #1

declare i64 @XUINT(i64) #1

declare i32 @_IO_putc(i32, %struct._IO_FILE*) #1

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...) #1

declare i64 @fwrite(i8*, i64, i64, %struct._IO_FILE*) #1

declare i32 @fflush(%struct._IO_FILE*) #1

declare i64 @safe_call2(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @decode_timer(i64 %timer, %struct.timespec* %result) #0 {
entry:
  %retval = alloca i1, align 1
  %timer.addr = alloca i64, align 8
  %result.addr = alloca %struct.timespec*, align 8
  %vec = alloca i64*, align 8
  %t = alloca %struct.lisp_time, align 8
  %coerce = alloca %struct.timespec, align 8
  store i64 %timer, i64* %timer.addr, align 8
  store %struct.timespec* %result, %struct.timespec** %result.addr, align 8
  %0 = load i64, i64* %timer.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %timer.addr, align 8
  %call1 = call i64 @ASIZE(i64 %1)
  %cmp = icmp eq i64 %call1, 9
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %2 = load i64, i64* %timer.addr, align 8
  %call2 = call %struct.Lisp_Vector* @XVECTOR(i64 %2)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call2, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  store i64* %arraydecay, i64** %vec, align 8
  %3 = load i64*, i64** %vec, align 8
  %arrayidx = getelementptr inbounds i64, i64* %3, i64 0
  %4 = load i64, i64* %arrayidx, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %4, %call3
  br i1 %cmp4, label %if.end.6, label %if.then.5

if.then.5:                                        ; preds = %if.end
  store i1 false, i1* %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %5 = load i64*, i64** %vec, align 8
  %arrayidx7 = getelementptr inbounds i64, i64* %5, i64 2
  %6 = load i64, i64* %arrayidx7, align 8
  %and = and i64 %6, 7
  %conv = trunc i64 %and to i32
  %and8 = and i32 %conv, -5
  %cmp9 = icmp eq i32 %and8, 2
  br i1 %cmp9, label %if.end.12, label %if.then.11

if.then.11:                                       ; preds = %if.end.6
  store i1 false, i1* %retval
  br label %return

if.end.12:                                        ; preds = %if.end.6
  %7 = load i64*, i64** %vec, align 8
  %arrayidx13 = getelementptr inbounds i64, i64* %7, i64 1
  %8 = load i64, i64* %arrayidx13, align 8
  %9 = load i64*, i64** %vec, align 8
  %arrayidx14 = getelementptr inbounds i64, i64* %9, i64 2
  %10 = load i64, i64* %arrayidx14, align 8
  %11 = load i64*, i64** %vec, align 8
  %arrayidx15 = getelementptr inbounds i64, i64* %11, i64 3
  %12 = load i64, i64* %arrayidx15, align 8
  %13 = load i64*, i64** %vec, align 8
  %arrayidx16 = getelementptr inbounds i64, i64* %13, i64 8
  %14 = load i64, i64* %arrayidx16, align 8
  %call17 = call i32 @decode_time_components(i64 %8, i64 %10, i64 %12, i64 %14, %struct.lisp_time* %t, double* null)
  %cmp18 = icmp sle i32 %call17, 0
  br i1 %cmp18, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.end.12
  store i1 false, i1* %retval
  br label %return

if.end.21:                                        ; preds = %if.end.12
  %15 = load %struct.timespec*, %struct.timespec** %result.addr, align 8
  %call22 = call { i64, i64 } @lisp_to_timespec(%struct.lisp_time* byval align 8 %t)
  %16 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %17 = getelementptr { i64, i64 }, { i64, i64 }* %16, i32 0, i32 0
  %18 = extractvalue { i64, i64 } %call22, 0
  store i64 %18, i64* %17, align 8
  %19 = getelementptr { i64, i64 }, { i64, i64 }* %16, i32 0, i32 1
  %20 = extractvalue { i64, i64 } %call22, 1
  store i64 %20, i64* %19, align 8
  %21 = bitcast %struct.timespec* %15 to i8*
  %22 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* %22, i64 16, i32 8, i1 false)
  %23 = load %struct.timespec*, %struct.timespec** %result.addr, align 8
  %24 = bitcast %struct.timespec* %23 to { i64, i64 }*
  %25 = getelementptr { i64, i64 }, { i64, i64 }* %24, i32 0, i32 0
  %26 = load i64, i64* %25, align 1
  %27 = getelementptr { i64, i64 }, { i64, i64 }* %24, i32 0, i32 1
  %28 = load i64, i64* %27, align 1
  %call23 = call zeroext i1 @timespec_valid_p(i64 %26, i64 %28)
  store i1 %call23, i1* %retval
  br label %return

return:                                           ; preds = %if.end.21, %if.then.20, %if.then.11, %if.then.5, %if.then
  %29 = load i1, i1* %retval
  ret i1 %29
}

declare i32 @decode_time_components(i64, i64, i64, i64, %struct.lisp_time*, double*) #1

declare { i64, i64 } @lisp_to_timespec(%struct.lisp_time* byval align 8) #1

; Function Attrs: nounwind uwtable
define internal i64 @apply_modifiers_uncached(i32 %modifiers, i8* %base, i32 %base_len, i32 %base_len_byte) #0 {
entry:
  %modifiers.addr = alloca i32, align 4
  %base.addr = alloca i8*, align 8
  %base_len.addr = alloca i32, align 4
  %base_len_byte.addr = alloca i32, align 4
  %new_mods = alloca [40 x i8], align 16
  %mod_len = alloca i32, align 4
  %p = alloca i8*, align 8
  %new_name = alloca i64, align 8
  store i32 %modifiers, i32* %modifiers.addr, align 4
  store i8* %base, i8** %base.addr, align 8
  store i32 %base_len, i32* %base_len.addr, align 4
  store i32 %base_len_byte, i32* %base_len_byte.addr, align 4
  %arraydecay = getelementptr inbounds [40 x i8], [40 x i8]* %new_mods, i32 0, i32 0
  store i8* %arraydecay, i8** %p, align 8
  %0 = load i32, i32* %modifiers.addr, align 4
  %and = and i32 %0, 4194304
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %1, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  store i8 65, i8* %1, align 1
  %2 = load i8*, i8** %p, align 8
  %incdec.ptr1 = getelementptr inbounds i8, i8* %2, i32 1
  store i8* %incdec.ptr1, i8** %p, align 8
  store i8 45, i8* %2, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %modifiers.addr, align 4
  %and2 = and i32 %3, 67108864
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then.4, label %if.end.7

if.then.4:                                        ; preds = %if.end
  %4 = load i8*, i8** %p, align 8
  %incdec.ptr5 = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr5, i8** %p, align 8
  store i8 67, i8* %4, align 1
  %5 = load i8*, i8** %p, align 8
  %incdec.ptr6 = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr6, i8** %p, align 8
  store i8 45, i8* %5, align 1
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.4, %if.end
  %6 = load i32, i32* %modifiers.addr, align 4
  %and8 = and i32 %6, 16777216
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then.10, label %if.end.13

if.then.10:                                       ; preds = %if.end.7
  %7 = load i8*, i8** %p, align 8
  %incdec.ptr11 = getelementptr inbounds i8, i8* %7, i32 1
  store i8* %incdec.ptr11, i8** %p, align 8
  store i8 72, i8* %7, align 1
  %8 = load i8*, i8** %p, align 8
  %incdec.ptr12 = getelementptr inbounds i8, i8* %8, i32 1
  store i8* %incdec.ptr12, i8** %p, align 8
  store i8 45, i8* %8, align 1
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.10, %if.end.7
  %9 = load i32, i32* %modifiers.addr, align 4
  %and14 = and i32 %9, 134217728
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %if.end.13
  %10 = load i8*, i8** %p, align 8
  %incdec.ptr17 = getelementptr inbounds i8, i8* %10, i32 1
  store i8* %incdec.ptr17, i8** %p, align 8
  store i8 77, i8* %10, align 1
  %11 = load i8*, i8** %p, align 8
  %incdec.ptr18 = getelementptr inbounds i8, i8* %11, i32 1
  store i8* %incdec.ptr18, i8** %p, align 8
  store i8 45, i8* %11, align 1
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %if.end.13
  %12 = load i32, i32* %modifiers.addr, align 4
  %and20 = and i32 %12, 33554432
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then.22, label %if.end.25

if.then.22:                                       ; preds = %if.end.19
  %13 = load i8*, i8** %p, align 8
  %incdec.ptr23 = getelementptr inbounds i8, i8* %13, i32 1
  store i8* %incdec.ptr23, i8** %p, align 8
  store i8 83, i8* %13, align 1
  %14 = load i8*, i8** %p, align 8
  %incdec.ptr24 = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr24, i8** %p, align 8
  store i8 45, i8* %14, align 1
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.22, %if.end.19
  %15 = load i32, i32* %modifiers.addr, align 4
  %and26 = and i32 %15, 8388608
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.28, label %if.end.31

if.then.28:                                       ; preds = %if.end.25
  %16 = load i8*, i8** %p, align 8
  %incdec.ptr29 = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr29, i8** %p, align 8
  store i8 115, i8* %16, align 1
  %17 = load i8*, i8** %p, align 8
  %incdec.ptr30 = getelementptr inbounds i8, i8* %17, i32 1
  store i8* %incdec.ptr30, i8** %p, align 8
  store i8 45, i8* %17, align 1
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.28, %if.end.25
  %18 = load i32, i32* %modifiers.addr, align 4
  %and32 = and i32 %18, 16
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.end.31
  %19 = load i8*, i8** %p, align 8
  %call = call i8* @stpcpy(i8* %19, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.358, i32 0, i32 0)) #8
  store i8* %call, i8** %p, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.end.31
  %20 = load i32, i32* %modifiers.addr, align 4
  %and36 = and i32 %20, 32
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.38, label %if.end.40

if.then.38:                                       ; preds = %if.end.35
  %21 = load i8*, i8** %p, align 8
  %call39 = call i8* @stpcpy(i8* %21, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.359, i32 0, i32 0)) #8
  store i8* %call39, i8** %p, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.38, %if.end.35
  %22 = load i32, i32* %modifiers.addr, align 4
  %and41 = and i32 %22, 1
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.45

if.then.43:                                       ; preds = %if.end.40
  %23 = load i8*, i8** %p, align 8
  %call44 = call i8* @stpcpy(i8* %23, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.360, i32 0, i32 0)) #8
  store i8* %call44, i8** %p, align 8
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.43, %if.end.40
  %24 = load i32, i32* %modifiers.addr, align 4
  %and46 = and i32 %24, 2
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then.48, label %if.end.50

if.then.48:                                       ; preds = %if.end.45
  %25 = load i8*, i8** %p, align 8
  %call49 = call i8* @stpcpy(i8* %25, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.361, i32 0, i32 0)) #8
  store i8* %call49, i8** %p, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.48, %if.end.45
  %26 = load i32, i32* %modifiers.addr, align 4
  %and51 = and i32 %26, 4
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.then.53, label %if.end.55

if.then.53:                                       ; preds = %if.end.50
  %27 = load i8*, i8** %p, align 8
  %call54 = call i8* @stpcpy(i8* %27, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.362, i32 0, i32 0)) #8
  store i8* %call54, i8** %p, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.53, %if.end.50
  %28 = load i8*, i8** %p, align 8
  store i8 0, i8* %28, align 1
  %29 = load i8*, i8** %p, align 8
  %arraydecay56 = getelementptr inbounds [40 x i8], [40 x i8]* %new_mods, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %29 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay56 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  store i32 %conv, i32* %mod_len, align 4
  %30 = load i32, i32* %mod_len, align 4
  %31 = load i32, i32* %base_len.addr, align 4
  %add = add nsw i32 %30, %31
  %conv57 = sext i32 %add to i64
  %32 = load i32, i32* %mod_len, align 4
  %33 = load i32, i32* %base_len_byte.addr, align 4
  %add58 = add nsw i32 %32, %33
  %conv59 = sext i32 %add58 to i64
  %call60 = call i64 @make_uninit_multibyte_string(i64 %conv57, i64 %conv59)
  store i64 %call60, i64* %new_name, align 8
  %34 = load i64, i64* %new_name, align 8
  %call61 = call i8* @SDATA(i64 %34)
  %35 = bitcast [40 x i8]* %new_mods to i8*
  %36 = load i32, i32* %mod_len, align 4
  %conv62 = sext i32 %36 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call61, i8* %35, i64 %conv62, i32 1, i1 false)
  %37 = load i64, i64* %new_name, align 8
  %call63 = call i8* @SDATA(i64 %37)
  %38 = load i32, i32* %mod_len, align 4
  %idx.ext = sext i32 %38 to i64
  %add.ptr = getelementptr inbounds i8, i8* %call63, i64 %idx.ext
  %39 = load i8*, i8** %base.addr, align 8
  %40 = load i32, i32* %base_len_byte.addr, align 4
  %conv64 = sext i32 %40 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %39, i64 %conv64, i32 1, i1 false)
  %41 = load i64, i64* %new_name, align 8
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  %call66 = call i64 @Fintern(i64 %41, i64 %call65)
  ret i64 %call66
}

; Function Attrs: nounwind
declare i8* @stpcpy(i8*, i8*) #6

declare i64 @make_uninit_multibyte_string(i64, i64) #1

declare void @deliver_process_signal(i32, void (i32)*) #1

; Function Attrs: nounwind uwtable
define internal void @handle_user_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %p = alloca %struct.user_signal_info*, align 8
  %special_event_name = alloca i8*, align 8
  %coerce = alloca %struct.timespec, align 8
  store i32 %sig, i32* %sig.addr, align 4
  store i8* null, i8** %special_event_name, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 55), align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 55), align 8
  %call = call i64 @SYMBOL_NAME(i64 %1)
  %call2 = call i8* @SSDATA(i64 %call)
  store i8* %call2, i8** %special_event_name, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.user_signal_info*, %struct.user_signal_info** @user_signals, align 8
  store %struct.user_signal_info* %2, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %tobool = icmp ne %struct.user_signal_info* %3, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %sig3 = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %4, i32 0, i32 0
  %5 = load i32, i32* %sig3, align 4
  %6 = load i32, i32* %sig.addr, align 4
  %cmp4 = icmp eq i32 %5, %6
  br i1 %cmp4, label %if.then.6, label %if.end.22

if.then.6:                                        ; preds = %for.body
  %7 = load i8*, i8** %special_event_name, align 8
  %tobool7 = icmp ne i8* %7, null
  br i1 %tobool7, label %land.lhs.true, label %if.end.14

land.lhs.true:                                    ; preds = %if.then.6
  %8 = load i8*, i8** %special_event_name, align 8
  %9 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %name = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %9, i32 0, i32 1
  %10 = load i8*, i8** %name, align 8
  %call8 = call i32 @strcmp(i8* %8, i8* %10) #13
  %cmp9 = icmp eq i32 %call8, 0
  br i1 %cmp9, label %if.then.11, label %if.end.14

if.then.11:                                       ; preds = %land.lhs.true
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 433), align 1
  %call12 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call12, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call13, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  br label %for.end

if.end.14:                                        ; preds = %land.lhs.true, %if.then.6
  %11 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %npending = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %11, i32 0, i32 2
  %12 = load i32, i32* %npending, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %npending, align 4
  %13 = load i8, i8* @interrupt_input, align 1
  %tobool15 = trunc i8 %13 to i1
  br i1 %tobool15, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %if.end.14
  %14 = load i32, i32* %sig.addr, align 4
  call void @handle_input_available_signal(i32 %14)
  br label %if.end.21

if.else:                                          ; preds = %if.end.14
  %15 = load %struct.timespec*, %struct.timespec** @input_available_clear_time, align 8
  %tobool17 = icmp ne %struct.timespec* %15, null
  br i1 %tobool17, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.else
  %16 = load %struct.timespec*, %struct.timespec** @input_available_clear_time, align 8
  %call19 = call { i64, i64 } @make_timespec(i64 0, i64 0)
  %17 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %18 = getelementptr { i64, i64 }, { i64, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i64, i64 } %call19, 0
  store i64 %19, i64* %18, align 8
  %20 = getelementptr { i64, i64 }, { i64, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i64, i64 } %call19, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.timespec* %16 to i8*
  %23 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 16, i32 8, i1 false)
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.18, %if.else
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %if.then.16
  br label %for.end

if.end.22:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.22
  %24 = load %struct.user_signal_info*, %struct.user_signal_info** %p, align 8
  %next = getelementptr inbounds %struct.user_signal_info, %struct.user_signal_info* %24, i32 0, i32 3
  %25 = load %struct.user_signal_info*, %struct.user_signal_info** %next, align 8
  store %struct.user_signal_info* %25, %struct.user_signal_info** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %if.end.21, %if.then.11, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @parse_tool_bar_item(i64 %key, i64 %item) #0 {
entry:
  %retval = alloca i1, align 1
  %key.addr = alloca i64, align 8
  %item.addr = alloca i64, align 8
  %filter = alloca i64, align 8
  %caption = alloca i64, align 8
  %i = alloca i32, align 4
  %have_label = alloca i8, align 1
  %ikey = alloca i64, align 8
  %value = alloca i64, align 8
  %bad_label = alloca i8*, align 8
  %type = alloca i64, align 8
  %selected = alloca i64, align 8
  %tkey = alloca i64, align 8
  %tcapt = alloca i64, align 8
  %label = alloca i8*, align 8
  %capt = alloca i8*, align 8
  %max_lbl = alloca i64, align 8
  %buf = alloca i8*, align 8
  %new_lbl = alloca i64, align 8
  %caption_len = alloca i64, align 8
  %j = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %item, i64* %item.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %filter, align 8
  store i8 0, i8* %have_label, align 1
  %0 = load i64, i64* %item.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %item.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call2 = call zeroext i1 @STRINGP(i64 %4)
  br i1 %call2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.end
  %5 = load i64, i64* %item.addr, align 8
  %sub4 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub4 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car5 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car5, align 8
  %call6 = call i64 @list1(i64 %8)
  store i64 %call6, i64* %item.addr, align 8
  br label %if.end.19

if.else:                                          ; preds = %if.end
  %9 = load i64, i64* %item.addr, align 8
  %sub7 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub7 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car8, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 657)
  %cmp10 = icmp eq i64 %12, %call9
  br i1 %cmp10, label %lor.lhs.false, label %if.then.17

lor.lhs.false:                                    ; preds = %if.else
  %13 = load i64, i64* %item.addr, align 8
  %sub12 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub12 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %16 = load i64, i64* %cdr, align 8
  store i64 %16, i64* %item.addr, align 8
  %17 = load i64, i64* %item.addr, align 8
  %and13 = and i64 %17, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  %lnot = xor i1 %cmp15, true
  br i1 %lnot, label %if.then.17, label %if.end.18

if.then.17:                                       ; preds = %lor.lhs.false, %if.else
  store i1 false, i1* %retval
  br label %return

if.end.18:                                        ; preds = %lor.lhs.false
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %if.then.3
  %18 = load i64, i64* @tool_bar_item_properties, align 8
  %call20 = call zeroext i1 @VECTORP(i64 %18)
  br i1 %call20, label %if.then.21, label %if.else.26

if.then.21:                                       ; preds = %if.end.19
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.21
  %19 = load i32, i32* %i, align 4
  %cmp22 = icmp slt i32 %19, 11
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load i32, i32* %i, align 4
  %conv24 = sext i32 %20 to i64
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_prop(i64 %conv24, i64 %call25)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load i32, i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.29

if.else.26:                                       ; preds = %if.end.19
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @Fmake_vector(i64 46, i64 %call27)
  store i64 %call28, i64* @tool_bar_item_properties, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else.26, %for.end
  %22 = load i64, i64* %key.addr, align 8
  call void @set_prop(i64 0, i64 %22)
  %call30 = call i64 @builtin_lisp_symbol(i32 901)
  call void @set_prop(i64 1, i64 %call30)
  %23 = load i64, i64* %item.addr, align 8
  %sub31 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub31 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %car32 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 0
  %26 = load i64, i64* %car32, align 8
  store i64 %26, i64* %caption, align 8
  %27 = load i64, i64* %caption, align 8
  %call33 = call zeroext i1 @STRINGP(i64 %27)
  br i1 %call33, label %if.end.39, label %if.then.34

if.then.34:                                       ; preds = %if.end.29
  %28 = load i64, i64* %caption, align 8
  %call35 = call i64 @menu_item_eval_property(i64 %28)
  store i64 %call35, i64* %caption, align 8
  %29 = load i64, i64* %caption, align 8
  %call36 = call zeroext i1 @STRINGP(i64 %29)
  br i1 %call36, label %if.end.38, label %if.then.37

if.then.37:                                       ; preds = %if.then.34
  store i1 false, i1* %retval
  br label %return

if.end.38:                                        ; preds = %if.then.34
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.end.29
  %30 = load i64, i64* %caption, align 8
  call void @set_prop(i64 3, i64 %30)
  %31 = load i64, i64* %item.addr, align 8
  %sub40 = sub nsw i64 %31, 3
  %32 = inttoptr i64 %sub40 to i8*
  %33 = bitcast i8* %32 to %struct.Lisp_Cons*
  %u41 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %33, i32 0, i32 1
  %cdr42 = bitcast %union.anon.12* %u41 to i64*
  %34 = load i64, i64* %cdr42, align 8
  store i64 %34, i64* %item.addr, align 8
  %35 = load i64, i64* %item.addr, align 8
  %and43 = and i64 %35, 7
  %conv44 = trunc i64 %and43 to i32
  %cmp45 = icmp eq i32 %conv44, 3
  br i1 %cmp45, label %if.end.53, label %if.then.47

if.then.47:                                       ; preds = %if.end.39
  %36 = load i64, i64* %caption, align 8
  %call48 = call i8* @SSDATA(i64 %36)
  %call49 = call zeroext i1 @menu_separator_name_p(i8* %call48)
  br i1 %call49, label %if.then.50, label %if.end.52

if.then.50:                                       ; preds = %if.then.47
  %call51 = call i64 @builtin_lisp_symbol(i32 901)
  call void @set_prop(i64 6, i64 %call51)
  store i1 true, i1* %retval
  br label %return

if.end.52:                                        ; preds = %if.then.47
  store i1 false, i1* %retval
  br label %return

if.end.53:                                        ; preds = %if.end.39
  %37 = load i64, i64* %item.addr, align 8
  %sub54 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub54 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car55 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car55, align 8
  call void @set_prop(i64 5, i64 %40)
  %41 = load i64, i64* %item.addr, align 8
  %sub56 = sub nsw i64 %41, 3
  %42 = inttoptr i64 %sub56 to i8*
  %43 = bitcast i8* %42 to %struct.Lisp_Cons*
  %u57 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %43, i32 0, i32 1
  %cdr58 = bitcast %union.anon.12* %u57 to i64*
  %44 = load i64, i64* %cdr58, align 8
  store i64 %44, i64* %item.addr, align 8
  %45 = load i64, i64* %item.addr, align 8
  %and59 = and i64 %45, 7
  %conv60 = trunc i64 %and59 to i32
  %cmp61 = icmp eq i32 %conv60, 3
  br i1 %cmp61, label %land.lhs.true, label %if.end.73

land.lhs.true:                                    ; preds = %if.end.53
  %46 = load i64, i64* %item.addr, align 8
  %sub63 = sub nsw i64 %46, 3
  %47 = inttoptr i64 %sub63 to i8*
  %48 = bitcast i8* %47 to %struct.Lisp_Cons*
  %car64 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %48, i32 0, i32 0
  %49 = load i64, i64* %car64, align 8
  %and65 = and i64 %49, 7
  %conv66 = trunc i64 %and65 to i32
  %cmp67 = icmp eq i32 %conv66, 3
  br i1 %cmp67, label %if.then.69, label %if.end.73

if.then.69:                                       ; preds = %land.lhs.true
  %50 = load i64, i64* %item.addr, align 8
  %sub70 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub70 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %u71 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 1
  %cdr72 = bitcast %union.anon.12* %u71 to i64*
  %53 = load i64, i64* %cdr72, align 8
  store i64 %53, i64* %item.addr, align 8
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.69, %land.lhs.true, %if.end.53
  br label %for.cond.74

for.cond.74:                                      ; preds = %for.inc.194, %if.end.73
  %54 = load i64, i64* %item.addr, align 8
  %and75 = and i64 %54, 7
  %conv76 = trunc i64 %and75 to i32
  %cmp77 = icmp eq i32 %conv76, 3
  br i1 %cmp77, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond.74
  %55 = load i64, i64* %item.addr, align 8
  %sub79 = sub nsw i64 %55, 3
  %56 = inttoptr i64 %sub79 to i8*
  %57 = bitcast i8* %56 to %struct.Lisp_Cons*
  %u80 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %57, i32 0, i32 1
  %cdr81 = bitcast %union.anon.12* %u80 to i64*
  %58 = load i64, i64* %cdr81, align 8
  %and82 = and i64 %58, 7
  %conv83 = trunc i64 %and82 to i32
  %cmp84 = icmp eq i32 %conv83, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.74
  %59 = phi i1 [ false, %for.cond.74 ], [ %cmp84, %land.rhs ]
  br i1 %59, label %for.body.86, label %for.end.201

for.body.86:                                      ; preds = %land.end
  %60 = load i64, i64* %item.addr, align 8
  %sub87 = sub nsw i64 %60, 3
  %61 = inttoptr i64 %sub87 to i8*
  %62 = bitcast i8* %61 to %struct.Lisp_Cons*
  %car88 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %62, i32 0, i32 0
  %63 = load i64, i64* %car88, align 8
  store i64 %63, i64* %ikey, align 8
  %64 = load i64, i64* %item.addr, align 8
  %sub89 = sub nsw i64 %64, 3
  %65 = inttoptr i64 %sub89 to i8*
  %66 = bitcast i8* %65 to %struct.Lisp_Cons*
  %u90 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %66, i32 0, i32 1
  %cdr91 = bitcast %union.anon.12* %u90 to i64*
  %67 = load i64, i64* %cdr91, align 8
  %sub92 = sub nsw i64 %67, 3
  %68 = inttoptr i64 %sub92 to i8*
  %69 = bitcast i8* %68 to %struct.Lisp_Cons*
  %car93 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %69, i32 0, i32 0
  %70 = load i64, i64* %car93, align 8
  store i64 %70, i64* %value, align 8
  %71 = load i64, i64* %ikey, align 8
  %call94 = call i64 @builtin_lisp_symbol(i32 37)
  %cmp95 = icmp eq i64 %71, %call94
  br i1 %cmp95, label %if.then.97, label %if.else.105

if.then.97:                                       ; preds = %for.body.86
  %72 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 81), align 8
  %call98 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp99 = icmp eq i64 %72, %call98
  br i1 %cmp99, label %if.else.103, label %if.then.101

if.then.101:                                      ; preds = %if.then.97
  %call102 = call i64 @builtin_lisp_symbol(i32 901)
  call void @set_prop(i64 1, i64 %call102)
  br label %if.end.104

if.else.103:                                      ; preds = %if.then.97
  %73 = load i64, i64* %value, align 8
  call void @set_prop(i64 1, i64 %73)
  br label %if.end.104

if.end.104:                                       ; preds = %if.else.103, %if.then.101
  br label %if.end.193

if.else.105:                                      ; preds = %for.body.86
  %74 = load i64, i64* %ikey, align 8
  %call106 = call i64 @builtin_lisp_symbol(i32 135)
  %cmp107 = icmp eq i64 %74, %call106
  br i1 %cmp107, label %if.then.109, label %if.else.116

if.then.109:                                      ; preds = %if.else.105
  %75 = load i64, i64* %value, align 8
  %call110 = call i64 @menu_item_eval_property(i64 %75)
  %call111 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp112 = icmp eq i64 %call110, %call111
  br i1 %cmp112, label %if.then.114, label %if.end.115

if.then.114:                                      ; preds = %if.then.109
  store i1 false, i1* %retval
  br label %return

if.end.115:                                       ; preds = %if.then.109
  br label %if.end.192

if.else.116:                                      ; preds = %if.else.105
  %76 = load i64, i64* %ikey, align 8
  %call117 = call i64 @builtin_lisp_symbol(i32 59)
  %cmp118 = icmp eq i64 %76, %call117
  br i1 %cmp118, label %if.then.120, label %if.else.121

if.then.120:                                      ; preds = %if.else.116
  %77 = load i64, i64* %value, align 8
  call void @set_prop(i64 7, i64 %77)
  br label %if.end.191

if.else.121:                                      ; preds = %if.else.116
  %78 = load i64, i64* %ikey, align 8
  %call122 = call i64 @builtin_lisp_symbol(i32 134)
  %cmp123 = icmp eq i64 %78, %call122
  br i1 %cmp123, label %if.then.125, label %if.else.126

if.then.125:                                      ; preds = %if.else.121
  %79 = load i64, i64* %value, align 8
  call void @set_prop(i64 10, i64 %79)
  br label %if.end.190

if.else.126:                                      ; preds = %if.else.121
  %80 = load i64, i64* %ikey, align 8
  %call127 = call i64 @builtin_lisp_symbol(i32 72)
  %cmp128 = icmp eq i64 %80, %call127
  br i1 %cmp128, label %if.then.130, label %if.else.134

if.then.130:                                      ; preds = %if.else.126
  store i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.377, i32 0, i32 0), i8** %bad_label, align 8
  %81 = load i64, i64* %value, align 8
  %call131 = call zeroext i1 @STRINGP(i64 %81)
  br i1 %call131, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.130
  %82 = load i64, i64* %value, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.130
  %83 = load i8*, i8** %bad_label, align 8
  %call133 = call i64 @build_string(i8* %83)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %82, %cond.true ], [ %call133, %cond.false ]
  call void @set_prop(i64 9, i64 %cond)
  store i8 1, i8* %have_label, align 1
  br label %if.end.189

if.else.134:                                      ; preds = %if.else.126
  %84 = load i64, i64* %ikey, align 8
  %call135 = call i64 @builtin_lisp_symbol(i32 42)
  %cmp136 = icmp eq i64 %84, %call135
  br i1 %cmp136, label %if.then.138, label %if.else.139

if.then.138:                                      ; preds = %if.else.134
  %85 = load i64, i64* %value, align 8
  store i64 %85, i64* %filter, align 8
  br label %if.end.188

if.else.139:                                      ; preds = %if.else.134
  %86 = load i64, i64* %ikey, align 8
  %call140 = call i64 @builtin_lisp_symbol(i32 17)
  %cmp141 = icmp eq i64 %86, %call140
  br i1 %cmp141, label %land.lhs.true.143, label %if.else.163

land.lhs.true.143:                                ; preds = %if.else.139
  %87 = load i64, i64* %value, align 8
  %and144 = and i64 %87, 7
  %conv145 = trunc i64 %and144 to i32
  %cmp146 = icmp eq i32 %conv145, 3
  br i1 %cmp146, label %if.then.148, label %if.else.163

if.then.148:                                      ; preds = %land.lhs.true.143
  %88 = load i64, i64* %value, align 8
  %sub149 = sub nsw i64 %88, 3
  %89 = inttoptr i64 %sub149 to i8*
  %90 = bitcast i8* %89 to %struct.Lisp_Cons*
  %car150 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %90, i32 0, i32 0
  %91 = load i64, i64* %car150, align 8
  store i64 %91, i64* %type, align 8
  %92 = load i64, i64* %value, align 8
  %sub151 = sub nsw i64 %92, 3
  %93 = inttoptr i64 %sub151 to i8*
  %94 = bitcast i8* %93 to %struct.Lisp_Cons*
  %u152 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %94, i32 0, i32 1
  %cdr153 = bitcast %union.anon.12* %u152 to i64*
  %95 = load i64, i64* %cdr153, align 8
  store i64 %95, i64* %selected, align 8
  %96 = load i64, i64* %type, align 8
  %call154 = call i64 @builtin_lisp_symbol(i32 130)
  %cmp155 = icmp eq i64 %96, %call154
  br i1 %cmp155, label %if.then.161, label %lor.lhs.false.157

lor.lhs.false.157:                                ; preds = %if.then.148
  %97 = load i64, i64* %type, align 8
  %call158 = call i64 @builtin_lisp_symbol(i32 101)
  %cmp159 = icmp eq i64 %97, %call158
  br i1 %cmp159, label %if.then.161, label %if.end.162

if.then.161:                                      ; preds = %lor.lhs.false.157, %if.then.148
  %98 = load i64, i64* %selected, align 8
  call void @set_prop(i64 2, i64 %98)
  %99 = load i64, i64* %type, align 8
  call void @set_prop(i64 6, i64 %99)
  br label %if.end.162

if.end.162:                                       ; preds = %if.then.161, %lor.lhs.false.157
  br label %if.end.187

if.else.163:                                      ; preds = %land.lhs.true.143, %if.else.139
  %100 = load i64, i64* %ikey, align 8
  %call164 = call i64 @builtin_lisp_symbol(i32 65)
  %cmp165 = icmp eq i64 %100, %call164
  br i1 %cmp165, label %land.lhs.true.167, label %if.else.180

land.lhs.true.167:                                ; preds = %if.else.163
  %101 = load i64, i64* %value, align 8
  %and168 = and i64 %101, 7
  %conv169 = trunc i64 %and168 to i32
  %cmp170 = icmp eq i32 %conv169, 3
  br i1 %cmp170, label %if.then.179, label %lor.lhs.false.172

lor.lhs.false.172:                                ; preds = %land.lhs.true.167
  %102 = load i64, i64* %value, align 8
  %call173 = call zeroext i1 @VECTORP(i64 %102)
  br i1 %call173, label %land.lhs.true.175, label %if.else.180

land.lhs.true.175:                                ; preds = %lor.lhs.false.172
  %103 = load i64, i64* %value, align 8
  %call176 = call i64 @ASIZE(i64 %103)
  %cmp177 = icmp eq i64 %call176, 4
  br i1 %cmp177, label %if.then.179, label %if.else.180

if.then.179:                                      ; preds = %land.lhs.true.175, %land.lhs.true.167
  %104 = load i64, i64* %value, align 8
  call void @set_prop(i64 4, i64 %104)
  br label %if.end.186

if.else.180:                                      ; preds = %land.lhs.true.175, %lor.lhs.false.172, %if.else.163
  %105 = load i64, i64* %ikey, align 8
  %call181 = call i64 @builtin_lisp_symbol(i32 112)
  %cmp182 = icmp eq i64 %105, %call181
  br i1 %cmp182, label %if.then.184, label %if.end.185

if.then.184:                                      ; preds = %if.else.180
  %106 = load i64, i64* %value, align 8
  call void @set_prop(i64 8, i64 %106)
  br label %if.end.185

if.end.185:                                       ; preds = %if.then.184, %if.else.180
  br label %if.end.186

if.end.186:                                       ; preds = %if.end.185, %if.then.179
  br label %if.end.187

if.end.187:                                       ; preds = %if.end.186, %if.end.162
  br label %if.end.188

if.end.188:                                       ; preds = %if.end.187, %if.then.138
  br label %if.end.189

if.end.189:                                       ; preds = %if.end.188, %cond.end
  br label %if.end.190

if.end.190:                                       ; preds = %if.end.189, %if.then.125
  br label %if.end.191

if.end.191:                                       ; preds = %if.end.190, %if.then.120
  br label %if.end.192

if.end.192:                                       ; preds = %if.end.191, %if.end.115
  br label %if.end.193

if.end.193:                                       ; preds = %if.end.192, %if.end.104
  br label %for.inc.194

for.inc.194:                                      ; preds = %if.end.193
  %107 = load i64, i64* %item.addr, align 8
  %sub195 = sub nsw i64 %107, 3
  %108 = inttoptr i64 %sub195 to i8*
  %109 = bitcast i8* %108 to %struct.Lisp_Cons*
  %u196 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %109, i32 0, i32 1
  %cdr197 = bitcast %union.anon.12* %u196 to i64*
  %110 = load i64, i64* %cdr197, align 8
  %sub198 = sub nsw i64 %110, 3
  %111 = inttoptr i64 %sub198 to i8*
  %112 = bitcast i8* %111 to %struct.Lisp_Cons*
  %u199 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %112, i32 0, i32 1
  %cdr200 = bitcast %union.anon.12* %u199 to i64*
  %113 = load i64, i64* %cdr200, align 8
  store i64 %113, i64* %item.addr, align 8
  br label %for.cond.74

for.end.201:                                      ; preds = %land.end
  %114 = load i8, i8* %have_label, align 1
  %tobool = trunc i8 %114 to i1
  br i1 %tobool, label %if.end.301, label %if.then.202

if.then.202:                                      ; preds = %for.end.201
  %115 = load i64, i64* @tool_bar_item_properties, align 8
  %call203 = call i64 @AREF(i64 %115, i64 0)
  store i64 %call203, i64* %tkey, align 8
  %116 = load i64, i64* @tool_bar_item_properties, align 8
  %call204 = call i64 @AREF(i64 %116, i64 3)
  store i64 %call204, i64* %tcapt, align 8
  %117 = load i64, i64* %tkey, align 8
  %and205 = and i64 %117, 7
  %conv206 = trunc i64 %and205 to i32
  %cmp207 = icmp eq i32 %conv206, 0
  br i1 %cmp207, label %cond.true.209, label %cond.false.212

cond.true.209:                                    ; preds = %if.then.202
  %118 = load i64, i64* %tkey, align 8
  %call210 = call i64 @SYMBOL_NAME(i64 %118)
  %call211 = call i8* @SSDATA(i64 %call210)
  br label %cond.end.213

cond.false.212:                                   ; preds = %if.then.202
  br label %cond.end.213

cond.end.213:                                     ; preds = %cond.false.212, %cond.true.209
  %cond214 = phi i8* [ %call211, %cond.true.209 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), %cond.false.212 ]
  store i8* %cond214, i8** %label, align 8
  %119 = load i64, i64* %tcapt, align 8
  %call215 = call zeroext i1 @STRINGP(i64 %119)
  br i1 %call215, label %cond.true.217, label %cond.false.219

cond.true.217:                                    ; preds = %cond.end.213
  %120 = load i64, i64* %tcapt, align 8
  %call218 = call i8* @SSDATA(i64 %120)
  br label %cond.end.220

cond.false.219:                                   ; preds = %cond.end.213
  br label %cond.end.220

cond.end.220:                                     ; preds = %cond.false.219, %cond.true.217
  %cond221 = phi i8* [ %call218, %cond.true.217 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), %cond.false.219 ]
  store i8* %cond221, i8** %capt, align 8
  %121 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 414), align 8
  %cmp222 = icmp slt i64 %121, 1152921504606846975
  br i1 %cmp222, label %cond.true.224, label %cond.false.225

cond.true.224:                                    ; preds = %cond.end.220
  %122 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 414), align 8
  br label %cond.end.226

cond.false.225:                                   ; preds = %cond.end.220
  br label %cond.end.226

cond.end.226:                                     ; preds = %cond.false.225, %cond.true.224
  %cond227 = phi i64 [ %122, %cond.true.224 ], [ 1152921504606846975, %cond.false.225 ]
  %cmp228 = icmp sgt i64 0, %cond227
  br i1 %cmp228, label %cond.true.230, label %cond.false.231

cond.true.230:                                    ; preds = %cond.end.226
  br label %cond.end.238

cond.false.231:                                   ; preds = %cond.end.226
  %123 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 414), align 8
  %cmp232 = icmp slt i64 %123, 1152921504606846975
  br i1 %cmp232, label %cond.true.234, label %cond.false.235

cond.true.234:                                    ; preds = %cond.false.231
  %124 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 414), align 8
  br label %cond.end.236

cond.false.235:                                   ; preds = %cond.false.231
  br label %cond.end.236

cond.end.236:                                     ; preds = %cond.false.235, %cond.true.234
  %cond237 = phi i64 [ %124, %cond.true.234 ], [ 1152921504606846975, %cond.false.235 ]
  br label %cond.end.238

cond.end.238:                                     ; preds = %cond.end.236, %cond.true.230
  %cond239 = phi i64 [ 0, %cond.true.230 ], [ %cond237, %cond.end.236 ]
  %mul = mul nsw i64 2, %cond239
  store i64 %mul, i64* %max_lbl, align 8
  %125 = load i64, i64* %max_lbl, align 8
  %add = add nsw i64 %125, 1
  %call240 = call noalias i8* @xmalloc(i64 %add)
  store i8* %call240, i8** %buf, align 8
  %126 = load i8*, i8** %capt, align 8
  %call241 = call i64 @strlen(i8* %126) #13
  store i64 %call241, i64* %caption_len, align 8
  %127 = load i64, i64* %caption_len, align 8
  %128 = load i64, i64* %max_lbl, align 8
  %cmp242 = icmp sle i64 %127, %128
  br i1 %cmp242, label %land.lhs.true.244, label %if.end.260

land.lhs.true.244:                                ; preds = %cond.end.238
  %129 = load i8*, i8** %capt, align 8
  %arrayidx = getelementptr inbounds i8, i8* %129, i64 0
  %130 = load i8, i8* %arrayidx, align 1
  %conv245 = sext i8 %130 to i32
  %cmp246 = icmp ne i32 %conv245, 0
  br i1 %cmp246, label %if.then.248, label %if.end.260

if.then.248:                                      ; preds = %land.lhs.true.244
  %131 = load i8*, i8** %buf, align 8
  %132 = load i8*, i8** %capt, align 8
  %call249 = call i8* @strcpy(i8* %131, i8* %132) #8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.248
  %133 = load i64, i64* %caption_len, align 8
  %cmp250 = icmp sgt i64 %133, 0
  br i1 %cmp250, label %land.rhs.252, label %land.end.258

land.rhs.252:                                     ; preds = %while.cond
  %134 = load i64, i64* %caption_len, align 8
  %sub253 = sub nsw i64 %134, 1
  %135 = load i8*, i8** %buf, align 8
  %arrayidx254 = getelementptr inbounds i8, i8* %135, i64 %sub253
  %136 = load i8, i8* %arrayidx254, align 1
  %conv255 = sext i8 %136 to i32
  %cmp256 = icmp eq i32 %conv255, 46
  br label %land.end.258

land.end.258:                                     ; preds = %land.rhs.252, %while.cond
  %137 = phi i1 [ false, %while.cond ], [ %cmp256, %land.rhs.252 ]
  br i1 %137, label %while.body, label %while.end

while.body:                                       ; preds = %land.end.258
  %138 = load i64, i64* %caption_len, align 8
  %dec = add nsw i64 %138, -1
  store i64 %dec, i64* %caption_len, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end.258
  %139 = load i64, i64* %caption_len, align 8
  %140 = load i8*, i8** %buf, align 8
  %arrayidx259 = getelementptr inbounds i8, i8* %140, i64 %139
  store i8 0, i8* %arrayidx259, align 1
  %141 = load i8*, i8** %buf, align 8
  store i8* %141, i8** %capt, align 8
  store i8* %141, i8** %label, align 8
  br label %if.end.260

if.end.260:                                       ; preds = %while.end, %land.lhs.true.244, %cond.end.238
  %142 = load i8*, i8** %label, align 8
  %call261 = call i64 @strlen(i8* %142) #13
  %143 = load i64, i64* %max_lbl, align 8
  %cmp262 = icmp ule i64 %call261, %143
  br i1 %cmp262, label %land.lhs.true.264, label %if.else.291

land.lhs.true.264:                                ; preds = %if.end.260
  %144 = load i8*, i8** %label, align 8
  %arrayidx265 = getelementptr inbounds i8, i8* %144, i64 0
  %145 = load i8, i8* %arrayidx265, align 1
  %conv266 = sext i8 %145 to i32
  %cmp267 = icmp ne i32 %conv266, 0
  br i1 %cmp267, label %if.then.269, label %if.else.291

if.then.269:                                      ; preds = %land.lhs.true.264
  %146 = load i8*, i8** %label, align 8
  %147 = load i8*, i8** %buf, align 8
  %cmp270 = icmp ne i8* %146, %147
  br i1 %cmp270, label %if.then.272, label %if.end.274

if.then.272:                                      ; preds = %if.then.269
  %148 = load i8*, i8** %buf, align 8
  %149 = load i8*, i8** %label, align 8
  %call273 = call i8* @strcpy(i8* %148, i8* %149) #8
  br label %if.end.274

if.end.274:                                       ; preds = %if.then.272, %if.then.269
  store i64 0, i64* %j, align 8
  br label %for.cond.275

for.cond.275:                                     ; preds = %for.inc.288, %if.end.274
  %150 = load i64, i64* %j, align 8
  %151 = load i8*, i8** %buf, align 8
  %arrayidx276 = getelementptr inbounds i8, i8* %151, i64 %150
  %152 = load i8, i8* %arrayidx276, align 1
  %conv277 = sext i8 %152 to i32
  %cmp278 = icmp ne i32 %conv277, 0
  br i1 %cmp278, label %for.body.280, label %for.end.290

for.body.280:                                     ; preds = %for.cond.275
  %153 = load i64, i64* %j, align 8
  %154 = load i8*, i8** %buf, align 8
  %arrayidx281 = getelementptr inbounds i8, i8* %154, i64 %153
  %155 = load i8, i8* %arrayidx281, align 1
  %conv282 = sext i8 %155 to i32
  %cmp283 = icmp eq i32 %conv282, 45
  br i1 %cmp283, label %if.then.285, label %if.end.287

if.then.285:                                      ; preds = %for.body.280
  %156 = load i64, i64* %j, align 8
  %157 = load i8*, i8** %buf, align 8
  %arrayidx286 = getelementptr inbounds i8, i8* %157, i64 %156
  store i8 32, i8* %arrayidx286, align 1
  br label %if.end.287

if.end.287:                                       ; preds = %if.then.285, %for.body.280
  br label %for.inc.288

for.inc.288:                                      ; preds = %if.end.287
  %158 = load i64, i64* %j, align 8
  %inc289 = add nsw i64 %158, 1
  store i64 %inc289, i64* %j, align 8
  br label %for.cond.275

for.end.290:                                      ; preds = %for.cond.275
  %159 = load i8*, i8** %buf, align 8
  store i8* %159, i8** %label, align 8
  br label %if.end.292

if.else.291:                                      ; preds = %land.lhs.true.264, %if.end.260
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.378, i32 0, i32 0), i8** %label, align 8
  br label %if.end.292

if.end.292:                                       ; preds = %if.else.291, %for.end.290
  %160 = load i8*, i8** %label, align 8
  %call293 = call i64 @build_string(i8* %160)
  %call294 = call i64 @Fupcase_initials(i64 %call293)
  store i64 %call294, i64* %new_lbl, align 8
  %161 = load i64, i64* %new_lbl, align 8
  %call295 = call i64 @SCHARS(i64 %161)
  %162 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 414), align 8
  %cmp296 = icmp sle i64 %call295, %162
  br i1 %cmp296, label %if.then.298, label %if.else.299

if.then.298:                                      ; preds = %if.end.292
  %163 = load i64, i64* %new_lbl, align 8
  call void @set_prop(i64 9, i64 %163)
  br label %if.end.300

if.else.299:                                      ; preds = %if.end.292
  %164 = load i64, i64* @empty_unibyte_string, align 8
  call void @set_prop(i64 9, i64 %164)
  br label %if.end.300

if.end.300:                                       ; preds = %if.else.299, %if.then.298
  %165 = load i8*, i8** %buf, align 8
  call void @xfree(i8* %165)
  br label %if.end.301

if.end.301:                                       ; preds = %if.end.300, %for.end.201
  %166 = load i64, i64* %filter, align 8
  %call302 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp303 = icmp eq i64 %166, %call302
  br i1 %cmp303, label %if.end.311, label %if.then.305

if.then.305:                                      ; preds = %if.end.301
  %167 = load i64, i64* %filter, align 8
  %call306 = call i64 @builtin_lisp_symbol(i32 783)
  %168 = load i64, i64* @tool_bar_item_properties, align 8
  %call307 = call i64 @AREF(i64 %168, i64 5)
  %call308 = call i64 @list2(i64 %call306, i64 %call307)
  %call309 = call i64 @list2(i64 %167, i64 %call308)
  %call310 = call i64 @menu_item_eval_property(i64 %call309)
  call void @set_prop(i64 5, i64 %call310)
  br label %if.end.311

if.end.311:                                       ; preds = %if.then.305, %if.end.301
  %169 = load i64, i64* @tool_bar_item_properties, align 8
  %call312 = call i64 @AREF(i64 %169, i64 5)
  %call313 = call i64 @get_keymap(i64 %call312, i1 zeroext false, i1 zeroext true)
  %and314 = and i64 %call313, 7
  %conv315 = trunc i64 %and314 to i32
  %cmp316 = icmp eq i32 %conv315, 3
  br i1 %cmp316, label %if.then.318, label %if.end.319

if.then.318:                                      ; preds = %if.end.311
  store i1 false, i1* %retval
  br label %return

if.end.319:                                       ; preds = %if.end.311
  %170 = load i64, i64* @tool_bar_item_properties, align 8
  %call320 = call i64 @AREF(i64 %170, i64 1)
  %call321 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp322 = icmp eq i64 %call320, %call321
  br i1 %cmp322, label %if.end.327, label %if.then.324

if.then.324:                                      ; preds = %if.end.319
  %171 = load i64, i64* @tool_bar_item_properties, align 8
  %call325 = call i64 @AREF(i64 %171, i64 1)
  %call326 = call i64 @menu_item_eval_property(i64 %call325)
  call void @set_prop(i64 1, i64 %call326)
  br label %if.end.327

if.end.327:                                       ; preds = %if.then.324, %if.end.319
  %172 = load i64, i64* @tool_bar_item_properties, align 8
  %call328 = call i64 @AREF(i64 %172, i64 2)
  %call329 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp330 = icmp eq i64 %call328, %call329
  br i1 %cmp330, label %if.end.335, label %if.then.332

if.then.332:                                      ; preds = %if.end.327
  %173 = load i64, i64* @tool_bar_item_properties, align 8
  %call333 = call i64 @AREF(i64 %173, i64 2)
  %call334 = call i64 @menu_item_eval_property(i64 %call333)
  call void @set_prop(i64 2, i64 %call334)
  br label %if.end.335

if.end.335:                                       ; preds = %if.then.332, %if.end.327
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end.335, %if.then.318, %if.then.114, %if.end.52, %if.then.50, %if.then.37, %if.then.17, %if.then
  %174 = load i1, i1* %retval
  ret i1 %174
}

; Function Attrs: nounwind uwtable
define internal void @append_tool_bar_item() #0 {
entry:
  %incr = alloca i64, align 8
  %0 = load i32, i32* @ntool_bar_items, align 4
  %conv = sext i32 %0 to i64
  %1 = load i64, i64* @tool_bar_items_vector, align 8
  %call = call i64 @ASIZE(i64 %1)
  %sub = sub nsw i64 %call, 11
  %sub1 = sub nsw i64 %conv, %sub
  store i64 %sub1, i64* %incr, align 8
  %2 = load i64, i64* %incr, align 8
  %cmp = icmp sgt i64 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* @tool_bar_items_vector, align 8
  %4 = load i64, i64* %incr, align 8
  %call3 = call i64 @larger_vector(i64 %3, i64 %4, i64 -1)
  store i64 %call3, i64* @tool_bar_items_vector, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, i64* @tool_bar_items_vector, align 8
  %6 = load i32, i32* @ntool_bar_items, align 4
  %conv4 = sext i32 %6 to i64
  %7 = load i64, i64* @tool_bar_item_properties, align 8
  %call5 = call %struct.Lisp_Vector* @XVECTOR(i64 %7)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  call void @vcopy(i64 %5, i64 %conv4, i64* %arraydecay, i64 11)
  %8 = load i32, i32* @ntool_bar_items, align 4
  %add = add nsw i32 %8, 11
  store i32 %add, i32* @ntool_bar_items, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_prop(i64 %idx, i64 %val) #0 {
entry:
  %idx.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store i64 %idx, i64* %idx.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* @tool_bar_item_properties, align 8
  %1 = load i64, i64* %idx.addr, align 8
  %2 = load i64, i64* %val.addr, align 8
  call void @ASET(i64 %0, i64 %1, i64 %2)
  ret void
}

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8*) #6

declare i64 @Fupcase_initials(i64) #1

declare void @vcopy(i64, i64, i64*, i64) #1

declare i64 @Fx_popup_menu(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @record_menu_key(i64 %c) #0 {
entry:
  %c.addr = alloca i64, align 8
  store i64 %c, i64* %c.addr, align 8
  call void @clear_message(i1 zeroext true, i1 zeroext false)
  %0 = load i64, i64* %c.addr, align 8
  call void @record_char(i64 %0)
  store %struct.kboard* null, %struct.kboard** @ok_to_echo_at_next_pause, align 8
  %1 = load i64, i64* %c.addr, align 8
  call void @add_command_key(i64 %1)
  call void @echo_update()
  %2 = load i64, i64* %c.addr, align 8
  store i64 %2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376), align 8
  %3 = load i64, i64* @num_input_events, align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* @num_input_events, align 8
  ret void
}

declare i64 @Fkeymap_prompt(i64) #1

declare i64 @build_unibyte_string(i8*) #1

declare i64 @Fupcase(i64) #1

declare i64 @Fdowncase(i64) #1

declare i64 @Fsingle_key_description(i64, i64) #1

declare i64 @apply1(i64, i64) #1

declare void @kset_defining_kbd_macro(%struct.kboard*, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @echo_length() #0 {
entry:
  %0 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_ = getelementptr inbounds %struct.kboard, %struct.kboard* %0, i32 0, i32 22
  %1 = load i64, i64* %echo_string_, align 8
  %call = call zeroext i1 @STRINGP(i64 %1)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.kboard*, %struct.kboard** @current_kboard, align 8
  %echo_string_1 = getelementptr inbounds %struct.kboard, %struct.kboard* %2, i32 0, i32 22
  %3 = load i64, i64* %echo_string_1, align 8
  %call2 = call i64 @SCHARS(i64 %3)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ 0, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define internal i64 @active_maps(i64 %first_event) #0 {
entry:
  %first_event.addr = alloca i64, align 8
  %position = alloca i64, align 8
  store i64 %first_event, i64* %first_event.addr, align 8
  %0 = load i64, i64* %first_event.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, i64* %first_event.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 1
  %cdr = bitcast %union.anon.12* %u to i64*
  %4 = load i64, i64* %cdr, align 8
  %call = call i64 @CAR_SAFE(i64 %4)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %position, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 589)
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  %5 = load i64, i64* %position, align 8
  %call5 = call i64 @Fcurrent_active_maps(i64 %call4, i64 %5)
  %call6 = call i64 @Fcons(i64 %call3, i64 %call5)
  ret i64 %call6
}

declare void @record_unwind_current_buffer() #1

; Function Attrs: nounwind uwtable
define internal i64 @follow_key(i64 %keymap, i64 %key) #0 {
entry:
  %keymap.addr = alloca i64, align 8
  %key.addr = alloca i64, align 8
  store i64 %keymap, i64* %keymap.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* %keymap.addr, align 8
  %call = call i64 @get_keymap(i64 %0, i1 zeroext false, i1 zeroext true)
  %1 = load i64, i64* %key.addr, align 8
  %call1 = call i64 @access_keymap(i64 %call, i64 %1, i1 zeroext true, i1 zeroext false, i1 zeroext true)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @keyremap_step(i64* %keybuf, i32 %bufsize, %struct.keyremap* %fkey, i32 %input, i1 zeroext %doit, i32* %diff, i64 %prompt) #0 {
entry:
  %retval = alloca i1, align 1
  %keybuf.addr = alloca i64*, align 8
  %bufsize.addr = alloca i32, align 4
  %fkey.addr = alloca %struct.keyremap*, align 8
  %input.addr = alloca i32, align 4
  %doit.addr = alloca i8, align 1
  %diff.addr = alloca i32*, align 8
  %prompt.addr = alloca i64, align 8
  %next = alloca i64, align 8
  %key = alloca i64, align 8
  %len = alloca i32, align 4
  %i = alloca i32, align 4
  store i64* %keybuf, i64** %keybuf.addr, align 8
  store i32 %bufsize, i32* %bufsize.addr, align 4
  store %struct.keyremap* %fkey, %struct.keyremap** %fkey.addr, align 8
  store i32 %input, i32* %input.addr, align 4
  %frombool = zext i1 %doit to i8
  store i8 %frombool, i8* %doit.addr, align 1
  store i32* %diff, i32** %diff.addr, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  %0 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end = getelementptr inbounds %struct.keyremap, %struct.keyremap* %0, i32 0, i32 3
  %1 = load volatile i32, i32* %end, align 4
  %inc = add nsw i32 %1, 1
  store volatile i32 %inc, i32* %end, align 4
  %idxprom = sext i32 %1 to i64
  %2 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %2, i64 %idxprom
  %3 = load i64, i64* %arrayidx, align 8
  store i64 %3, i64* %key, align 8
  %4 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %parent = getelementptr inbounds %struct.keyremap, %struct.keyremap* %4, i32 0, i32 0
  %5 = load volatile i64, i64* %parent, align 8
  %call = call i64 @get_keymap(i64 %5, i1 zeroext false, i1 zeroext false)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  br i1 %cmp, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %6 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %map = getelementptr inbounds %struct.keyremap, %struct.keyremap* %6, i32 0, i32 1
  %7 = load volatile i64, i64* %map, align 8
  %8 = load i64, i64* %key, align 8
  %9 = load i64, i64* %prompt.addr, align 8
  %10 = load i8, i8* %doit.addr, align 1
  %tobool = trunc i8 %10 to i1
  %call2 = call i64 @access_keymap_keyremap(i64 %7, i64 %8, i64 %9, i1 zeroext %tobool)
  store i64 %call2, i64* %next, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call3, i64* %next, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load i64, i64* %next, align 8
  %call4 = call zeroext i1 @VECTORP(i64 %11)
  br i1 %call4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %12 = load i64, i64* %next, align 8
  %call5 = call zeroext i1 @STRINGP(i64 %12)
  br i1 %call5, label %land.lhs.true, label %if.end.65

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.end
  %13 = load i8, i8* %doit.addr, align 1
  %tobool6 = trunc i8 %13 to i1
  br i1 %tobool6, label %if.then.7, label %if.end.65

if.then.7:                                        ; preds = %land.lhs.true
  %14 = load i64, i64* %next, align 8
  %call8 = call i64 @Flength(i64 %14)
  %shr = ashr i64 %call8, 2
  %conv = trunc i64 %shr to i32
  store i32 %conv, i32* %len, align 4
  %15 = load i32, i32* %len, align 4
  %16 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end9 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %16, i32 0, i32 3
  %17 = load volatile i32, i32* %end9, align 4
  %18 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %start = getelementptr inbounds %struct.keyremap, %struct.keyremap* %18, i32 0, i32 2
  %19 = load volatile i32, i32* %start, align 4
  %sub = sub nsw i32 %17, %19
  %sub10 = sub nsw i32 %15, %sub
  %20 = load i32*, i32** %diff.addr, align 8
  store i32 %sub10, i32* %20, align 4
  %21 = load i32, i32* %bufsize.addr, align 4
  %22 = load i32, i32* %input.addr, align 4
  %sub11 = sub nsw i32 %21, %22
  %23 = load i32*, i32** %diff.addr, align 8
  %24 = load i32, i32* %23, align 4
  %cmp12 = icmp sle i32 %sub11, %24
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.then.7
  call void (i8*, ...) @error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.388, i32 0, i32 0)) #11
  unreachable

if.end.15:                                        ; preds = %if.then.7
  %25 = load i32*, i32** %diff.addr, align 8
  %26 = load i32, i32* %25, align 4
  %cmp16 = icmp slt i32 %26, 0
  br i1 %cmp16, label %if.then.18, label %if.else.27

if.then.18:                                       ; preds = %if.end.15
  %27 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end19 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %27, i32 0, i32 3
  %28 = load volatile i32, i32* %end19, align 4
  store i32 %28, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.18
  %29 = load i32, i32* %i, align 4
  %30 = load i32, i32* %input.addr, align 4
  %cmp20 = icmp slt i32 %29, %30
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %31 = load i32, i32* %i, align 4
  %idxprom22 = sext i32 %31 to i64
  %32 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx23 = getelementptr inbounds i64, i64* %32, i64 %idxprom22
  %33 = load i64, i64* %arrayidx23, align 8
  %34 = load i32, i32* %i, align 4
  %35 = load i32*, i32** %diff.addr, align 8
  %36 = load i32, i32* %35, align 4
  %add = add nsw i32 %34, %36
  %idxprom24 = sext i32 %add to i64
  %37 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx25 = getelementptr inbounds i64, i64* %37, i64 %idxprom24
  store i64 %33, i64* %arrayidx25, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %38 = load i32, i32* %i, align 4
  %inc26 = add nsw i32 %38, 1
  store i32 %inc26, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.45

if.else.27:                                       ; preds = %if.end.15
  %39 = load i32*, i32** %diff.addr, align 8
  %40 = load i32, i32* %39, align 4
  %cmp28 = icmp sgt i32 %40, 0
  br i1 %cmp28, label %if.then.30, label %if.end.44

if.then.30:                                       ; preds = %if.else.27
  %41 = load i32, i32* %input.addr, align 4
  %sub31 = sub nsw i32 %41, 1
  store i32 %sub31, i32* %i, align 4
  br label %for.cond.32

for.cond.32:                                      ; preds = %for.inc.42, %if.then.30
  %42 = load i32, i32* %i, align 4
  %43 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end33 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %43, i32 0, i32 3
  %44 = load volatile i32, i32* %end33, align 4
  %cmp34 = icmp sge i32 %42, %44
  br i1 %cmp34, label %for.body.36, label %for.end.43

for.body.36:                                      ; preds = %for.cond.32
  %45 = load i32, i32* %i, align 4
  %idxprom37 = sext i32 %45 to i64
  %46 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx38 = getelementptr inbounds i64, i64* %46, i64 %idxprom37
  %47 = load i64, i64* %arrayidx38, align 8
  %48 = load i32, i32* %i, align 4
  %49 = load i32*, i32** %diff.addr, align 8
  %50 = load i32, i32* %49, align 4
  %add39 = add nsw i32 %48, %50
  %idxprom40 = sext i32 %add39 to i64
  %51 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx41 = getelementptr inbounds i64, i64* %51, i64 %idxprom40
  store i64 %47, i64* %arrayidx41, align 8
  br label %for.inc.42

for.inc.42:                                       ; preds = %for.body.36
  %52 = load i32, i32* %i, align 4
  %dec = add nsw i32 %52, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond.32

for.end.43:                                       ; preds = %for.cond.32
  br label %if.end.44

if.end.44:                                        ; preds = %for.end.43, %if.else.27
  br label %if.end.45

if.end.45:                                        ; preds = %if.end.44, %for.end
  store i32 0, i32* %i, align 4
  br label %for.cond.46

for.cond.46:                                      ; preds = %for.inc.57, %if.end.45
  %53 = load i32, i32* %i, align 4
  %54 = load i32, i32* %len, align 4
  %cmp47 = icmp slt i32 %53, %54
  br i1 %cmp47, label %for.body.49, label %for.end.59

for.body.49:                                      ; preds = %for.cond.46
  %55 = load i64, i64* %next, align 8
  %56 = load i32, i32* %i, align 4
  %conv50 = sext i32 %56 to i64
  %shl = shl i64 %conv50, 2
  %add51 = add i64 %shl, 2
  %call52 = call i64 @Faref(i64 %55, i64 %add51)
  %57 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %start53 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %57, i32 0, i32 2
  %58 = load volatile i32, i32* %start53, align 4
  %59 = load i32, i32* %i, align 4
  %add54 = add nsw i32 %58, %59
  %idxprom55 = sext i32 %add54 to i64
  %60 = load i64*, i64** %keybuf.addr, align 8
  %arrayidx56 = getelementptr inbounds i64, i64* %60, i64 %idxprom55
  store i64 %call52, i64* %arrayidx56, align 8
  br label %for.inc.57

for.inc.57:                                       ; preds = %for.body.49
  %61 = load i32, i32* %i, align 4
  %inc58 = add nsw i32 %61, 1
  store i32 %inc58, i32* %i, align 4
  br label %for.cond.46

for.end.59:                                       ; preds = %for.cond.46
  %62 = load i32*, i32** %diff.addr, align 8
  %63 = load i32, i32* %62, align 4
  %64 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end60 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %64, i32 0, i32 3
  %65 = load volatile i32, i32* %end60, align 4
  %add61 = add nsw i32 %65, %63
  store volatile i32 %add61, i32* %end60, align 4
  %66 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %start62 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %66, i32 0, i32 2
  store volatile i32 %add61, i32* %start62, align 4
  %67 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %parent63 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %67, i32 0, i32 0
  %68 = load volatile i64, i64* %parent63, align 8
  %69 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %map64 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %69, i32 0, i32 1
  store volatile i64 %68, i64* %map64, align 8
  store i1 true, i1* %retval
  br label %return

if.end.65:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %70 = load i64, i64* %next, align 8
  %call66 = call i64 @get_keymap(i64 %70, i1 zeroext false, i1 zeroext true)
  %71 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %map67 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %71, i32 0, i32 1
  store volatile i64 %call66, i64* %map67, align 8
  %72 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %map68 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %72, i32 0, i32 1
  %73 = load volatile i64, i64* %map68, align 8
  %and = and i64 %73, 7
  %conv69 = trunc i64 %and to i32
  %cmp70 = icmp eq i32 %conv69, 3
  br i1 %cmp70, label %if.end.78, label %if.then.72

if.then.72:                                       ; preds = %if.end.65
  %74 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %start73 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %74, i32 0, i32 2
  %75 = load volatile i32, i32* %start73, align 4
  %inc74 = add nsw i32 %75, 1
  store volatile i32 %inc74, i32* %start73, align 4
  %76 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %end75 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %76, i32 0, i32 3
  store volatile i32 %inc74, i32* %end75, align 4
  %77 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %parent76 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %77, i32 0, i32 0
  %78 = load volatile i64, i64* %parent76, align 8
  %79 = load %struct.keyremap*, %struct.keyremap** %fkey.addr, align 8
  %map77 = getelementptr inbounds %struct.keyremap, %struct.keyremap* %79, i32 0, i32 1
  store volatile i64 %78, i64* %map77, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.72, %if.end.65
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %if.end.78, %for.end.59
  %80 = load i1, i1* %retval
  ret i1 %80
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @test_undefined(i64 %binding) #0 {
entry:
  %binding.addr = alloca i64, align 8
  store i64 %binding, i64* %binding.addr, align 8
  %0 = load i64, i64* %binding.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %binding.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 959)
  %cmp2 = icmp eq i64 %1, %call1
  br i1 %cmp2, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i64, i64* %binding.addr, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp3 = icmp eq i32 %conv, 0
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %3 = load i64, i64* %binding.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %call7 = call i64 @Fcommand_remapping(i64 %3, i64 %call5, i64 %call6)
  %call8 = call i64 @builtin_lisp_symbol(i32 959)
  %cmp9 = icmp eq i64 %call7, %call8
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %4 = phi i1 [ false, %lor.rhs ], [ %cmp9, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %lor.lhs.false, %entry
  %5 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %4, %land.end ]
  ret i1 %5
}

declare zeroext i1 @uppercasep(i32) #1

declare i32 @downcase(i32) #1

declare %struct.Lisp_Char_Table* @XCHAR_TABLE(i64) #1

declare i64 @Fcommand_remapping(i64, i64, i64) #1

declare i64 @Fcurrent_active_maps(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @access_keymap_keyremap(i64 %map, i64 %key, i64 %prompt, i1 zeroext %do_funcall) #0 {
entry:
  %map.addr = alloca i64, align 8
  %key.addr = alloca i64, align 8
  %prompt.addr = alloca i64, align 8
  %do_funcall.addr = alloca i8, align 1
  %next = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %map, i64* %map.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  %frombool = zext i1 %do_funcall to i8
  store i8 %frombool, i8* %do_funcall.addr, align 1
  %0 = load i64, i64* %map.addr, align 8
  %1 = load i64, i64* %key.addr, align 8
  %call = call i64 @access_keymap(i64 %0, i64 %1, i1 zeroext true, i1 zeroext false, i1 zeroext true)
  store i64 %call, i64* %next, align 8
  %2 = load i64, i64* %next, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, i64* %next, align 8
  %call2 = call i64 @Ffboundp(i64 %3)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %call2, %call3
  br i1 %cmp4, label %if.end, label %land.lhs.true.6

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %4 = load i64, i64* %next, align 8
  %sub = sub nsw i64 %4, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %5 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %5, i32 0, i32 3
  %6 = load i64, i64* %function, align 8
  %call7 = call zeroext i1 @ARRAYP(i64 %6)
  br i1 %call7, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.6
  %7 = load i64, i64* %next, align 8
  %sub9 = sub nsw i64 %7, 0
  %add.ptr10 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub9
  %8 = bitcast i8* %add.ptr10 to %struct.Lisp_Symbol*
  %function11 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %8, i32 0, i32 3
  %9 = load i64, i64* %function11, align 8
  %call12 = call i64 @get_keymap(i64 %9, i1 zeroext false, i1 zeroext false)
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %call12, %call13
  br i1 %cmp14, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true.6
  %10 = load i64, i64* %next, align 8
  %sub16 = sub nsw i64 %10, 0
  %add.ptr17 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub16
  %11 = bitcast i8* %add.ptr17 to %struct.Lisp_Symbol*
  %function18 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %11, i32 0, i32 3
  %12 = load i64, i64* %function18, align 8
  %13 = load i64, i64* %next, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @Fautoload_do_load(i64 %12, i64 %13, i64 %call19)
  store i64 %call20, i64* %next, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %land.lhs.true, %entry
  %14 = load i8, i8* %do_funcall.addr, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %land.lhs.true.22, label %if.end.40

land.lhs.true.22:                                 ; preds = %if.end
  %15 = load i64, i64* %next, align 8
  %call23 = call zeroext i1 @FUNCTIONP(i64 %15)
  br i1 %call23, label %if.then.25, label %if.end.40

if.then.25:                                       ; preds = %land.lhs.true.22
  %16 = load i64, i64* %next, align 8
  store i64 %16, i64* %tem, align 8
  %17 = load i64, i64* %next, align 8
  %18 = load i64, i64* %prompt.addr, align 8
  %call26 = call i64 @call1(i64 %17, i64 %18)
  store i64 %call26, i64* %next, align 8
  %19 = load i64, i64* %next, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %19, %call27
  br i1 %cmp28, label %if.end.39, label %lor.lhs.false.30

lor.lhs.false.30:                                 ; preds = %if.then.25
  %20 = load i64, i64* %next, align 8
  %call31 = call zeroext i1 @VECTORP(i64 %20)
  br i1 %call31, label %if.end.39, label %lor.lhs.false.33

lor.lhs.false.33:                                 ; preds = %lor.lhs.false.30
  %21 = load i64, i64* %next, align 8
  %call34 = call zeroext i1 @STRINGP(i64 %21)
  br i1 %call34, label %if.end.39, label %if.then.36

if.then.36:                                       ; preds = %lor.lhs.false.33
  %22 = load i64, i64* %tem, align 8
  %call37 = call i64 @SYMBOL_NAME(i64 %22)
  %call38 = call i8* @SSDATA(i64 %call37)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.389, i32 0, i32 0), i8* %call38) #11
  unreachable

if.end.39:                                        ; preds = %lor.lhs.false.33, %lor.lhs.false.30, %if.then.25
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %land.lhs.true.22, %if.end
  %23 = load i64, i64* %next, align 8
  ret i64 %23
}

declare zeroext i1 @ARRAYP(i64) #1

declare i64 @Fautoload_do_load(i64, i64, i64) #1

; Function Attrs: nounwind
declare i32 @sigemptyset(%struct.__sigset_t*) #6

; Function Attrs: nounwind
declare i32 @sigaddset(%struct.__sigset_t*, i32) #6

; Function Attrs: nounwind uwtable
define internal void @write_stdout(i8* %msg) #0 {
entry:
  %msg.addr = alloca i8*, align 8
  %__x = alloca i64, align 8
  store i8* %msg, i8** %msg.addr, align 8
  %0 = load i8*, i8** %msg.addr, align 8
  %1 = load i8*, i8** %msg.addr, align 8
  %call = call i64 @strlen(i8* %1) #13
  %call1 = call i64 @write(i32 1, i8* %0, i64 %call)
  store i64 %call1, i64* %__x, align 8
  %2 = load i64, i64* %__x, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @read_stdin() #0 {
entry:
  %c = alloca i8, align 1
  %call = call i64 @read(i32 0, i8* %c, i64 1)
  %cmp = icmp eq i64 %call, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %0 = load i8, i8* %c, align 1
  %conv = sext i8 %0 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv, %cond.true ], [ -1, %cond.false ]
  ret i32 %cond
}

declare i64 @write(i32, i8*, i64) #1

declare i64 @read(i32, i8*, i64) #1

declare i64 @do_switch_frame(i64, i32, i32, i64) #1

; Function Attrs: noreturn nounwind
declare void @_longjmp(%struct.__jmp_buf_tag*, i32) #10

declare i64 @window_from_coordinates(%struct.frame*, i32, i32, i32*, i1 zeroext) #1

declare i32 @window_box_left(%struct.window*, i32) #1

declare i32 @estimate_mode_line_height(%struct.frame*, i32) #1

declare i64 @mode_line_string(%struct.window*, i32, i32*, i32*, i64*, i64*, i32*, i32*, i32*, i32*) #1

declare i64 @marginal_area_string(%struct.window*, i32, i32*, i32*, i64*, i64*, i32*, i32*, i32*, i32*) #1

declare i32 @window_box_width(%struct.window*, i32) #1

declare i64 @buffer_posn_from_coords(%struct.window*, i32*, i32*, %struct.display_pos*, i64*, i32*, i32*, i32*, i32*) #1

declare zeroext i1 @IMAGEP(i64) #1

declare i64 @Fplist_get(i64, i64) #1

declare i64 @find_hot_spot(i64, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal void @kset_overriding_terminal_local_map(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Voverriding_terminal_local_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 1
  store i64 %0, i64* %Voverriding_terminal_local_map_, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @kset_keyboard_translate_table(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vkeyboard_translate_table_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 4
  store i64 %0, i64* %Vkeyboard_translate_table_, align 8
  ret void
}

declare void @kset_last_kbd_macro(%struct.kboard*, i64) #1

declare void @kset_system_key_alist(%struct.kboard*, i64) #1

declare void @kset_window_system(%struct.kboard*, i64) #1

declare void @kset_input_decode_map(%struct.kboard*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @kset_local_function_key_map(%struct.kboard* %kb, i64 %val) #0 {
entry:
  %kb.addr = alloca %struct.kboard*, align 8
  %val.addr = alloca i64, align 8
  store %struct.kboard* %kb, %struct.kboard** %kb.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %struct.kboard*, %struct.kboard** %kb.addr, align 8
  %Vlocal_function_key_map_ = getelementptr inbounds %struct.kboard, %struct.kboard* %1, i32 0, i32 18
  store i64 %0, i64* %Vlocal_function_key_map_, align 8
  ret void
}

declare i64 @Fset_keymap_parent(i64, i64) #1

declare void @kset_default_minibuffer_frame(%struct.kboard*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @handle_interrupt_signal(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %terminal = alloca %struct.terminal*, align 8
  store i32 %sig, i32* %sig.addr, align 4
  %call = call %struct.terminal* @get_named_terminal(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.25, i32 0, i32 0))
  store %struct.terminal* %call, %struct.terminal** %terminal, align 8
  %0 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %tobool = icmp ne %struct.terminal* %0, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 594)
  store i64 %call1, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load %struct.terminal*, %struct.terminal** %terminal, align 8
  %display_info = getelementptr inbounds %struct.terminal, %struct.terminal* %1, i32 0, i32 12
  %tty = bitcast %union.display_info* %display_info to %struct.tty_display_info**
  %2 = load %struct.tty_display_info*, %struct.tty_display_info** %tty, align 8
  %top_frame = getelementptr inbounds %struct.tty_display_info, %struct.tty_display_info* %2, i32 0, i32 11
  %3 = load i64, i64* %top_frame, align 8
  store i64 %3, i64* @internal_last_event_frame, align 8
  call void @handle_interrupt(i1 zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind returns_twice "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind }
attributes #9 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { noreturn }
attributes #12 = { nounwind returns_twice }
attributes #13 = { nounwind readonly }
attributes #14 = { nounwind readnone }
attributes #15 = { noreturn nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
