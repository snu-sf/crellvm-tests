; ModuleID = './plug-ins/script-fu/tinyscheme/scheme.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.num = type { i8, %union.anon.0 }
%union.anon.0 = type { i64 }
%struct.op_code_info = type { %struct.cell* (%struct.scheme*, i32)*, i8*, i32, i32, i8* }
%struct.cell = type { i32, %union.anon }
%union.anon = type { %struct.anon }
%struct.anon = type { i8*, i32 }
%struct.scheme = type { i8* (i64)*, void (i8*)*, i32, i32, [50 x i8*], [50 x %struct.cell*], i32, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, i32, i32, %struct.cell, %struct.cell*, %struct.cell, %struct.cell*, %struct.cell, %struct.cell*, %struct.cell, %struct.cell*, %struct.cell, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, i64, %struct.cell*, %struct.cell*, %struct.cell*, %struct.cell*, [64 x %struct.port], [64 x i32], i32, i32, i8, i8, [1024 x i8], [1024 x i8], %struct._IO_FILE*, i32, i32, %struct.cell*, i32, i8*, i64, %struct.scheme_interface*, i8*, i32, [2 x i32], i32 }
%struct.port = type { i8, %union.anon.1 }
%union.anon.1 = type { %struct.anon.2 }
%struct.anon.2 = type { %struct._IO_FILE*, i32, i32, i8* }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.scheme_interface = type { void (%struct.scheme*, %struct.cell*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i64)*, %struct.cell* (%struct.scheme*, double)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*, i8*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, %struct.cell* (%struct.scheme*, %struct.cell*)*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, void (%struct.scheme*, i8*)*, void (%struct.scheme*, i32)*, {}*, {}*, i8* (%struct.cell*)*, {}*, { i8, i64 } (%struct.cell*)*, i64 (%struct.cell*)*, double (%struct.cell*)*, {}*, {}*, {}*, i32 (%struct.cell*)*, i32 (%struct.scheme*, %struct.cell*)*, {}*, i32 (%struct.scheme*, %struct.cell*)*, i64 (%struct.cell*)*, void (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, i32)*, %struct.cell* (%struct.cell*, i32, %struct.cell*)*, {}*, {}*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, {}*, i8* (%struct.cell*)*, {}*, {}*, {}*, i8* (%struct.cell*)*, {}*, {}*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, {}*, {}*, {}*, {}*, void (%struct.cell*)*, void (%struct.scheme*, %struct._IO_FILE*)*, void (%struct.scheme*, i8*)* }
%struct.anon.5 = type { i32 (%struct.cell*)*, i8* }
%struct.anon.4 = type { %struct.cell*, %struct.cell* }
%struct.anon.3 = type { i8*, i8*, i8* }
%struct.scheme_registerable = type { %struct.cell* (%struct.scheme*, %struct.cell*)*, i8* }

@ts_output_handler = internal global void (i32, i8*, i32, i8*)* null, align 8
@ts_output_data = internal global i8* null, align 8
@.str = private unnamed_addr constant [11 x i8] c"gensym-%ld\00", align 1
@num_zero = internal global %struct.num zeroinitializer, align 8
@num_one = internal global %struct.num zeroinitializer, align 8
@.str.1 = private unnamed_addr constant [5 x i8] c"else\00", align 1
@.str.2 = private unnamed_addr constant [7 x i8] c"lambda\00", align 1
@.str.3 = private unnamed_addr constant [6 x i8] c"quote\00", align 1
@.str.4 = private unnamed_addr constant [7 x i8] c"define\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@.str.6 = private unnamed_addr constant [6 x i8] c"begin\00", align 1
@.str.7 = private unnamed_addr constant [5 x i8] c"set!\00", align 1
@.str.8 = private unnamed_addr constant [4 x i8] c"let\00", align 1
@.str.9 = private unnamed_addr constant [5 x i8] c"let*\00", align 1
@.str.10 = private unnamed_addr constant [7 x i8] c"letrec\00", align 1
@.str.11 = private unnamed_addr constant [5 x i8] c"cond\00", align 1
@.str.12 = private unnamed_addr constant [6 x i8] c"delay\00", align 1
@.str.13 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@.str.14 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@.str.15 = private unnamed_addr constant [12 x i8] c"cons-stream\00", align 1
@.str.16 = private unnamed_addr constant [6 x i8] c"macro\00", align 1
@.str.17 = private unnamed_addr constant [5 x i8] c"case\00", align 1
@dispatch_table = internal global [181 x %struct.op_code_info] [%struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.26, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.28, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.29, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.31, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.32, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.33, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.34, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_0, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.36, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.37, i32 0, i32 0), i32 1, i32 65535, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_1, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.38, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.39, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.41, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.44, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.45, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.46, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.47, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.48, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.49, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.50, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.52, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.53, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.55, i32 0, i32 0), i32 0, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.56, i32 0, i32 0), i32 1, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.57, i32 0, i32 0), i32 0, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.58, i32 0, i32 0), i32 1, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.59, i32 0, i32 0), i32 1, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.60, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.61, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.60, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.62, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.60, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.63, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.64, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.65, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.64, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.66, i32 0, i32 0), i32 2, i32 2, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.67, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.68, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.69, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.68, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.70, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.72, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.30, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.73, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.74, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.75, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.76, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.77, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.79, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.80, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.82, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.83, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.84, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.85, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.86, i32 0, i32 0), i32 3, i32 3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.87, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.88, i32 0, i32 0), i32 0, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.89, i32 0, i32 0), i32 2, i32 3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.85, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.90, i32 0, i32 0), i32 0, i32 65535, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.91, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.92, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.93, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.94, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.95, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.96, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.97, i32 0, i32 0), i32 3, i32 3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.98, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.99, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.100, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.101, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.102, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.103, i32 0, i32 0), i32 2, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.104, i32 0, i32 0), i32 2, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.105, i32 0, i32 0), i32 2, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.106, i32 0, i32 0), i32 2, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.107, i32 0, i32 0), i32 2, i32 65535, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.108, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.109, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.110, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.111, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.112, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.113, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.114, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.115, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.116, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.117, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.118, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.119, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.120, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.121, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.122, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.123, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.124, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.125, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.126, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.127, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.128, i32 0, i32 0), i32 2, i32 2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.129, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.78, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.130, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.131, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.132, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.133, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.134, i32 0, i32 0), i32 1, i32 2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.131, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.135, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.136, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.137, i32 0, i32 0), i32 1, i32 65535, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.138, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.139, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.140, i32 0, i32 0), i32 1, i32 65535, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.141, i32 0, i32 0), i32 0, i32 65535, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.142, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.143, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.144, i32 0, i32 0), i32 0, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.145, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.40, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.146, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.147, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.148, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.149, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.150, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.151, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.152, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.153, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.154, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.27, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.155, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.136, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.156, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.158, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.136, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.159, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_4, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.160, i32 0, i32 0), i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.161, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.162, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.163, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.164, i32 0, i32 0), i32 0, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.165, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.157, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.166, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.136, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_5, i8* null, i32 0, i32 0, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.167, i32 0, i32 0), i32 1, i32 1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.139, i32 0, i32 0) }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_6, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.168, i32 0, i32 0), i32 2, i32 2, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_6, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.169, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_6, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.170, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info { %struct.cell* (%struct.scheme*, i32)* @opexe_6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.171, i32 0, i32 0), i32 1, i32 1, i8* null }, %struct.op_code_info zeroinitializer], align 16
@.str.18 = private unnamed_addr constant [11 x i8] c"quasiquote\00", align 1
@.str.19 = private unnamed_addr constant [8 x i8] c"unquote\00", align 1
@.str.20 = private unnamed_addr constant [17 x i8] c"unquote-splicing\00", align 1
@.str.21 = private unnamed_addr constant [3 x i8] c"=>\00", align 1
@.str.22 = private unnamed_addr constant [13 x i8] c"*colon-hook*\00", align 1
@.str.23 = private unnamed_addr constant [13 x i8] c"*error-hook*\00", align 1
@.str.24 = private unnamed_addr constant [13 x i8] c"*sharp-hook*\00", align 1
@.str.25 = private unnamed_addr constant [15 x i8] c"*compile-hook*\00", align 1
@stdin = external global %struct._IO_FILE*, align 8
@stdout = external global %struct._IO_FILE*, align 8
@vtbl = internal global { void (%struct.scheme*, %struct.cell*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i64)*, %struct.cell* (%struct.scheme*, double)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*, i8*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, %struct.cell* (%struct.scheme*, %struct.cell*)*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, void (%struct.scheme*, i8*)*, void (%struct.scheme*, i32)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, { i8, i64 } (%struct.cell*)*, i64 (%struct.cell*)*, double (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.scheme*, %struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.scheme*, %struct.cell*)*, i64 (%struct.cell*)*, void (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, i32)*, %struct.cell* (%struct.cell*, i32, %struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, void (%struct.cell*)*, void (%struct.scheme*, %struct._IO_FILE*)*, void (%struct.scheme*, i8*)* } { void (%struct.scheme*, %struct.cell*, %struct.cell*, %struct.cell*)* @scheme_define, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)* @s_cons, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)* @s_immutable_cons, %struct.cell* (%struct.scheme*, i32)* @reserve_cells, %struct.cell* (%struct.scheme*, i64)* @mk_integer, %struct.cell* (%struct.scheme*, double)* @mk_real, %struct.cell* (%struct.scheme*, i8*)* @mk_symbol, %struct.cell* (%struct.scheme*)* @gensym, %struct.cell* (%struct.scheme*, i8*)* @mk_string, %struct.cell* (%struct.scheme*, i8*, i32)* @mk_counted_string, %struct.cell* (%struct.scheme*, i32)* @mk_character, %struct.cell* (%struct.scheme*, i32)* @mk_vector, %struct.cell* (%struct.scheme*, %struct.cell* (%struct.scheme*, %struct.cell*)*)* @mk_foreign_func, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)* @mk_closure, void (%struct.scheme*, i8*)* @putstr, void (%struct.scheme*, i32)* @putcharacter, i32 (%struct.cell*)* @is_string, i32 (%struct.cell*)* @string_length, i8* (%struct.cell*)* @string_value, i32 (%struct.cell*)* @is_number, { i8, i64 } (%struct.cell*)* @nvalue, i64 (%struct.cell*)* @ivalue, double (%struct.cell*)* @rvalue, i32 (%struct.cell*)* @is_integer, i32 (%struct.cell*)* @is_real, i32 (%struct.cell*)* @is_character, i32 (%struct.cell*)* @charvalue, i32 (%struct.scheme*, %struct.cell*)* @is_list, i32 (%struct.cell*)* @is_vector, i32 (%struct.scheme*, %struct.cell*)* @list_length, i64 (%struct.cell*)* @ivalue, void (%struct.cell*, %struct.cell*)* @fill_vector, %struct.cell* (%struct.cell*, i32)* @vector_elem, %struct.cell* (%struct.cell*, i32, %struct.cell*)* @set_vector_elem, i32 (%struct.cell*)* @is_port, i32 (%struct.cell*)* @is_pair, %struct.cell* (%struct.cell*)* @pair_car, %struct.cell* (%struct.cell*)* @pair_cdr, %struct.cell* (%struct.cell*, %struct.cell*)* @set_car, %struct.cell* (%struct.cell*, %struct.cell*)* @set_cdr, i32 (%struct.cell*)* @is_symbol, i8* (%struct.cell*)* @symname, i32 (%struct.cell*)* @is_syntax, i32 (%struct.cell*)* @is_proc, i32 (%struct.cell*)* @is_foreign, i8* (%struct.cell*)* @syntaxname, i32 (%struct.cell*)* @is_closure, i32 (%struct.cell*)* @is_macro, %struct.cell* (%struct.cell*)* @closure_code, %struct.cell* (%struct.cell*)* @closure_env, i32 (%struct.cell*)* @is_continuation, i32 (%struct.cell*)* @is_promise, i32 (%struct.cell*)* @is_environment, i32 (%struct.cell*)* @is_immutable, void (%struct.cell*)* @setimmutable, void (%struct.scheme*, %struct._IO_FILE*)* @scheme_load_file, void (%struct.scheme*, i8*)* @scheme_load_string }, align 8
@.str.26 = private unnamed_addr constant [5 x i8] c"load\00", align 1
@.str.27 = private unnamed_addr constant [2 x i8] c"\02\00", align 1
@.str.28 = private unnamed_addr constant [7 x i8] c"gensym\00", align 1
@.str.29 = private unnamed_addr constant [8 x i8] c"tracing\00", align 1
@.str.30 = private unnamed_addr constant [2 x i8] c"\0E\00", align 1
@.str.31 = private unnamed_addr constant [13 x i8] c"make-closure\00", align 1
@.str.32 = private unnamed_addr constant [3 x i8] c"\08\07\00", align 1
@.str.33 = private unnamed_addr constant [9 x i8] c"defined?\00", align 1
@.str.34 = private unnamed_addr constant [3 x i8] c"\03\07\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"eval\00", align 1
@.str.36 = private unnamed_addr constant [3 x i8] c"\01\07\00", align 1
@.str.37 = private unnamed_addr constant [6 x i8] c"apply\00", align 1
@.str.38 = private unnamed_addr constant [31 x i8] c"call-with-current-continuation\00", align 1
@.str.39 = private unnamed_addr constant [15 x i8] c"inexact->exact\00", align 1
@.str.40 = private unnamed_addr constant [2 x i8] c"\0C\00", align 1
@.str.41 = private unnamed_addr constant [4 x i8] c"exp\00", align 1
@.str.42 = private unnamed_addr constant [4 x i8] c"log\00", align 1
@.str.43 = private unnamed_addr constant [4 x i8] c"sin\00", align 1
@.str.44 = private unnamed_addr constant [4 x i8] c"cos\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"tan\00", align 1
@.str.46 = private unnamed_addr constant [5 x i8] c"asin\00", align 1
@.str.47 = private unnamed_addr constant [5 x i8] c"acos\00", align 1
@.str.48 = private unnamed_addr constant [5 x i8] c"atan\00", align 1
@.str.49 = private unnamed_addr constant [5 x i8] c"sqrt\00", align 1
@.str.50 = private unnamed_addr constant [5 x i8] c"expt\00", align 1
@.str.51 = private unnamed_addr constant [6 x i8] c"floor\00", align 1
@.str.52 = private unnamed_addr constant [8 x i8] c"ceiling\00", align 1
@.str.53 = private unnamed_addr constant [9 x i8] c"truncate\00", align 1
@.str.54 = private unnamed_addr constant [6 x i8] c"round\00", align 1
@.str.55 = private unnamed_addr constant [2 x i8] c"+\00", align 1
@.str.56 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.57 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@.str.58 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.59 = private unnamed_addr constant [9 x i8] c"quotient\00", align 1
@.str.60 = private unnamed_addr constant [2 x i8] c"\0D\00", align 1
@.str.61 = private unnamed_addr constant [10 x i8] c"remainder\00", align 1
@.str.62 = private unnamed_addr constant [7 x i8] c"modulo\00", align 1
@.str.63 = private unnamed_addr constant [4 x i8] c"car\00", align 1
@.str.64 = private unnamed_addr constant [2 x i8] c"\08\00", align 1
@.str.65 = private unnamed_addr constant [4 x i8] c"cdr\00", align 1
@.str.66 = private unnamed_addr constant [5 x i8] c"cons\00", align 1
@.str.67 = private unnamed_addr constant [9 x i8] c"set-car!\00", align 1
@.str.68 = private unnamed_addr constant [3 x i8] c"\08\01\00", align 1
@.str.69 = private unnamed_addr constant [9 x i8] c"set-cdr!\00", align 1
@.str.70 = private unnamed_addr constant [14 x i8] c"char->integer\00", align 1
@.str.71 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.72 = private unnamed_addr constant [14 x i8] c"integer->char\00", align 1
@.str.73 = private unnamed_addr constant [12 x i8] c"char-upcase\00", align 1
@.str.74 = private unnamed_addr constant [14 x i8] c"char-downcase\00", align 1
@.str.75 = private unnamed_addr constant [15 x i8] c"symbol->string\00", align 1
@.str.76 = private unnamed_addr constant [2 x i8] c"\03\00", align 1
@.str.77 = private unnamed_addr constant [13 x i8] c"atom->string\00", align 1
@.str.78 = private unnamed_addr constant [2 x i8] c"\01\00", align 1
@.str.79 = private unnamed_addr constant [15 x i8] c"string->symbol\00", align 1
@.str.80 = private unnamed_addr constant [13 x i8] c"string->atom\00", align 1
@.str.81 = private unnamed_addr constant [12 x i8] c"make-string\00", align 1
@.str.82 = private unnamed_addr constant [3 x i8] c"\0E\0A\00", align 1
@.str.83 = private unnamed_addr constant [14 x i8] c"string-length\00", align 1
@.str.84 = private unnamed_addr constant [11 x i8] c"string-ref\00", align 1
@.str.85 = private unnamed_addr constant [3 x i8] c"\02\0E\00", align 1
@.str.86 = private unnamed_addr constant [12 x i8] c"string-set!\00", align 1
@.str.87 = private unnamed_addr constant [4 x i8] c"\02\0E\0A\00", align 1
@.str.88 = private unnamed_addr constant [14 x i8] c"string-append\00", align 1
@.str.89 = private unnamed_addr constant [10 x i8] c"substring\00", align 1
@.str.90 = private unnamed_addr constant [7 x i8] c"vector\00", align 1
@.str.91 = private unnamed_addr constant [12 x i8] c"make-vector\00", align 1
@.str.92 = private unnamed_addr constant [3 x i8] c"\0E\01\00", align 1
@.str.93 = private unnamed_addr constant [14 x i8] c"vector-length\00", align 1
@.str.94 = private unnamed_addr constant [2 x i8] c"\0B\00", align 1
@.str.95 = private unnamed_addr constant [11 x i8] c"vector-ref\00", align 1
@.str.96 = private unnamed_addr constant [3 x i8] c"\0B\0E\00", align 1
@.str.97 = private unnamed_addr constant [12 x i8] c"vector-set!\00", align 1
@.str.98 = private unnamed_addr constant [4 x i8] c"\0B\0E\01\00", align 1
@.str.99 = private unnamed_addr constant [4 x i8] c"not\00", align 1
@.str.100 = private unnamed_addr constant [9 x i8] c"boolean?\00", align 1
@.str.101 = private unnamed_addr constant [12 x i8] c"eof-object?\00", align 1
@.str.102 = private unnamed_addr constant [6 x i8] c"null?\00", align 1
@.str.103 = private unnamed_addr constant [2 x i8] c"=\00", align 1
@.str.104 = private unnamed_addr constant [2 x i8] c"<\00", align 1
@.str.105 = private unnamed_addr constant [2 x i8] c">\00", align 1
@.str.106 = private unnamed_addr constant [3 x i8] c"<=\00", align 1
@.str.107 = private unnamed_addr constant [3 x i8] c">=\00", align 1
@.str.108 = private unnamed_addr constant [8 x i8] c"symbol?\00", align 1
@.str.109 = private unnamed_addr constant [8 x i8] c"number?\00", align 1
@.str.110 = private unnamed_addr constant [8 x i8] c"string?\00", align 1
@.str.111 = private unnamed_addr constant [9 x i8] c"integer?\00", align 1
@.str.112 = private unnamed_addr constant [6 x i8] c"real?\00", align 1
@.str.113 = private unnamed_addr constant [6 x i8] c"char?\00", align 1
@.str.114 = private unnamed_addr constant [17 x i8] c"char-alphabetic?\00", align 1
@.str.115 = private unnamed_addr constant [14 x i8] c"char-numeric?\00", align 1
@.str.116 = private unnamed_addr constant [17 x i8] c"char-whitespace?\00", align 1
@.str.117 = private unnamed_addr constant [17 x i8] c"char-upper-case?\00", align 1
@.str.118 = private unnamed_addr constant [17 x i8] c"char-lower-case?\00", align 1
@.str.119 = private unnamed_addr constant [6 x i8] c"port?\00", align 1
@.str.120 = private unnamed_addr constant [12 x i8] c"input-port?\00", align 1
@.str.121 = private unnamed_addr constant [13 x i8] c"output-port?\00", align 1
@.str.122 = private unnamed_addr constant [11 x i8] c"procedure?\00", align 1
@.str.123 = private unnamed_addr constant [6 x i8] c"pair?\00", align 1
@.str.124 = private unnamed_addr constant [6 x i8] c"list?\00", align 1
@.str.125 = private unnamed_addr constant [13 x i8] c"environment?\00", align 1
@.str.126 = private unnamed_addr constant [8 x i8] c"vector?\00", align 1
@.str.127 = private unnamed_addr constant [4 x i8] c"eq?\00", align 1
@.str.128 = private unnamed_addr constant [5 x i8] c"eqv?\00", align 1
@.str.129 = private unnamed_addr constant [6 x i8] c"force\00", align 1
@.str.130 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@.str.131 = private unnamed_addr constant [3 x i8] c"\01\06\00", align 1
@.str.132 = private unnamed_addr constant [11 x i8] c"write-char\00", align 1
@.str.133 = private unnamed_addr constant [3 x i8] c"\0A\06\00", align 1
@.str.134 = private unnamed_addr constant [8 x i8] c"display\00", align 1
@.str.135 = private unnamed_addr constant [8 x i8] c"newline\00", align 1
@.str.136 = private unnamed_addr constant [2 x i8] c"\06\00", align 1
@.str.137 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@.str.138 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@.str.139 = private unnamed_addr constant [2 x i8] c"\09\00", align 1
@.str.140 = private unnamed_addr constant [6 x i8] c"list*\00", align 1
@.str.141 = private unnamed_addr constant [7 x i8] c"append\00", align 1
@.str.142 = private unnamed_addr constant [5 x i8] c"quit\00", align 1
@.str.143 = private unnamed_addr constant [3 x i8] c"gc\00", align 1
@.str.144 = private unnamed_addr constant [11 x i8] c"gc-verbose\00", align 1
@.str.145 = private unnamed_addr constant [12 x i8] c"new-segment\00", align 1
@.str.146 = private unnamed_addr constant [7 x i8] c"oblist\00", align 1
@.str.147 = private unnamed_addr constant [19 x i8] c"current-input-port\00", align 1
@.str.148 = private unnamed_addr constant [20 x i8] c"current-output-port\00", align 1
@.str.149 = private unnamed_addr constant [16 x i8] c"open-input-file\00", align 1
@.str.150 = private unnamed_addr constant [17 x i8] c"open-output-file\00", align 1
@.str.151 = private unnamed_addr constant [23 x i8] c"open-input-output-file\00", align 1
@.str.152 = private unnamed_addr constant [18 x i8] c"open-input-string\00", align 1
@.str.153 = private unnamed_addr constant [25 x i8] c"open-input-output-string\00", align 1
@.str.154 = private unnamed_addr constant [19 x i8] c"open-output-string\00", align 1
@.str.155 = private unnamed_addr constant [18 x i8] c"get-output-string\00", align 1
@.str.156 = private unnamed_addr constant [17 x i8] c"close-input-port\00", align 1
@.str.157 = private unnamed_addr constant [2 x i8] c"\05\00", align 1
@.str.158 = private unnamed_addr constant [18 x i8] c"close-output-port\00", align 1
@.str.159 = private unnamed_addr constant [24 x i8] c"interaction-environment\00", align 1
@.str.160 = private unnamed_addr constant [20 x i8] c"current-environment\00", align 1
@.str.161 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@.str.162 = private unnamed_addr constant [10 x i8] c"read-char\00", align 1
@.str.163 = private unnamed_addr constant [10 x i8] c"peek-char\00", align 1
@.str.164 = private unnamed_addr constant [12 x i8] c"char-ready?\00", align 1
@.str.165 = private unnamed_addr constant [15 x i8] c"set-input-port\00", align 1
@.str.166 = private unnamed_addr constant [16 x i8] c"set-output-port\00", align 1
@.str.167 = private unnamed_addr constant [7 x i8] c"length\00", align 1
@.str.168 = private unnamed_addr constant [5 x i8] c"assq\00", align 1
@.str.169 = private unnamed_addr constant [17 x i8] c"get-closure-code\00", align 1
@.str.170 = private unnamed_addr constant [9 x i8] c"closure?\00", align 1
@.str.171 = private unnamed_addr constant [7 x i8] c"macro?\00", align 1
@.str.172 = private unnamed_addr constant [12 x i8] c"Loading %s\0A\00", align 1
@.str.173 = private unnamed_addr constant [15 x i8] c"unable to open\00", align 1
@.str.174 = private unnamed_addr constant [5 x i8] c"ts> \00", align 1
@.str.175 = private unnamed_addr constant [9 x i8] c"\0AGives: \00", align 1
@.str.176 = private unnamed_addr constant [8 x i8] c"\0AEval: \00", align 1
@.str.177 = private unnamed_addr constant [24 x i8] c"eval: unbound variable:\00", align 1
@.str.178 = private unnamed_addr constant [12 x i8] c"\0AApply to: \00", align 1
@.str.179 = private unnamed_addr constant [21 x i8] c"not enough arguments\00", align 1
@.str.180 = private unnamed_addr constant [39 x i8] c"syntax error in closure: not a symbol:\00", align 1
@.str.181 = private unnamed_addr constant [17 x i8] c"illegal function\00", align 1
@.str.182 = private unnamed_addr constant [34 x i8] c"define: unable to alter immutable\00", align 1
@.str.183 = private unnamed_addr constant [25 x i8] c"variable is not a symbol\00", align 1
@.str.184 = private unnamed_addr constant [41 x i8] c"set!: unable to alter immutable variable\00", align 1
@.str.185 = private unnamed_addr constant [24 x i8] c"set!: unbound variable:\00", align 1
@.str.186 = private unnamed_addr constant [36 x i8] c"Bad syntax of binding spec in let :\00", align 1
@.str.187 = private unnamed_addr constant [31 x i8] c"Bad syntax of binding in let :\00", align 1
@.str.188 = private unnamed_addr constant [37 x i8] c"Bad syntax of binding spec in let* :\00", align 1
@.str.189 = private unnamed_addr constant [21 x i8] c"%d: illegal operator\00", align 1
@.str.190 = private unnamed_addr constant [3 x i8] c"rb\00", align 1
@.str.191 = private unnamed_addr constant [10 x i8] c"<unknown>\00", align 1
@.str.192 = private unnamed_addr constant [13 x i8] c"(%s : %i) %s\00", align 1
@.str.193 = private unnamed_addr constant [4 x i8] c" \0A\09\00", align 1
@.str.194 = private unnamed_addr constant [9 x i8] c" tfodxb\5C\00", align 1
@utf8_length = internal constant [64 x i8] c"\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\03\03\03\03\03\03\03\03\04\04\04\04\05\05\00\00", align 16
@.str.195 = private unnamed_addr constant [39 x i8] c"Bad syntax of binding spec in letrec :\00", align 1
@.str.196 = private unnamed_addr constant [21 x i8] c"syntax error in cond\00", align 1
@.str.197 = private unnamed_addr constant [30 x i8] c"inexact->exact: not integral:\00", align 1
@.str.198 = private unnamed_addr constant [20 x i8] c"/: division by zero\00", align 1
@.str.199 = private unnamed_addr constant [27 x i8] c"quotient: division by zero\00", align 1
@.str.200 = private unnamed_addr constant [28 x i8] c"remainder: division by zero\00", align 1
@.str.201 = private unnamed_addr constant [25 x i8] c"modulo: division by zero\00", align 1
@.str.202 = private unnamed_addr constant [41 x i8] c"set-car!: unable to alter immutable pair\00", align 1
@.str.203 = private unnamed_addr constant [41 x i8] c"set-cdr!: unable to alter immutable pair\00", align 1
@.str.204 = private unnamed_addr constant [27 x i8] c"atom->string: not an atom:\00", align 1
@.str.205 = private unnamed_addr constant [27 x i8] c"string-ref: out of bounds:\00", align 1
@.str.206 = private unnamed_addr constant [47 x i8] c"string-set!: unable to alter immutable string:\00", align 1
@.str.207 = private unnamed_addr constant [28 x i8] c"string-set!: out of bounds:\00", align 1
@.str.208 = private unnamed_addr constant [40 x i8] c"string-set!: No memory to alter string:\00", align 1
@.str.209 = private unnamed_addr constant [42 x i8] c"string-set!: No memory to append strings:\00", align 1
@.str.210 = private unnamed_addr constant [32 x i8] c"substring: start out of bounds:\00", align 1
@.str.211 = private unnamed_addr constant [30 x i8] c"substring: end out of bounds:\00", align 1
@.str.212 = private unnamed_addr constant [45 x i8] c"string-set!: No memory to extract substring:\00", align 1
@.str.213 = private unnamed_addr constant [27 x i8] c"vector: not a proper list:\00", align 1
@.str.214 = private unnamed_addr constant [27 x i8] c"vector-ref: out of bounds:\00", align 1
@.str.215 = private unnamed_addr constant [47 x i8] c"vector-set!: unable to alter immutable vector:\00", align 1
@.str.216 = private unnamed_addr constant [28 x i8] c"vector-set!: out of bounds:\00", align 1
@.str.217 = private unnamed_addr constant [2 x i8] c"t\00", align 1
@.str.218 = private unnamed_addr constant [2 x i8] c"f\00", align 1
@.str.219 = private unnamed_addr constant [4 x i8] c"0%s\00", align 1
@.str.220 = private unnamed_addr constant [4 x i8] c"%lo\00", align 1
@.str.221 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@.str.222 = private unnamed_addr constant [5 x i8] c"0x%s\00", align 1
@.str.223 = private unnamed_addr constant [4 x i8] c"%lx\00", align 1
@.str.224 = private unnamed_addr constant [6 x i8] c"space\00", align 1
@.str.225 = private unnamed_addr constant [7 x i8] c"return\00", align 1
@.str.226 = private unnamed_addr constant [4 x i8] c"tab\00", align 1
@.str.227 = private unnamed_addr constant [3 x i8] c"%x\00", align 1
@.str.228 = private unnamed_addr constant [3 x i8] c"::\00", align 1
@.str.229 = private unnamed_addr constant [3 x i8] c"()\00", align 1
@.str.230 = private unnamed_addr constant [3 x i8] c"#t\00", align 1
@.str.231 = private unnamed_addr constant [3 x i8] c"#f\00", align 1
@.str.232 = private unnamed_addr constant [7 x i8] c"#<EOF>\00", align 1
@.str.233 = private unnamed_addr constant [8 x i8] c"#<PORT>\00", align 1
@.str.234 = private unnamed_addr constant [6 x i8] c"%.10g\00", align 1
@.str.235 = private unnamed_addr constant [3 x i8] c".e\00", align 1
@.str.236 = private unnamed_addr constant [8 x i8] c"#\5Cspace\00", align 1
@.str.237 = private unnamed_addr constant [10 x i8] c"#\5Cnewline\00", align 1
@.str.238 = private unnamed_addr constant [9 x i8] c"#\5Creturn\00", align 1
@.str.239 = private unnamed_addr constant [6 x i8] c"#\5Ctab\00", align 1
@.str.240 = private unnamed_addr constant [6 x i8] c"#\5Cx%x\00", align 1
@.str.241 = private unnamed_addr constant [5 x i8] c"#\5C%c\00", align 1
@.str.242 = private unnamed_addr constant [20 x i8] c"#<%s PROCEDURE %ld>\00", align 1
@.str.243 = private unnamed_addr constant [9 x i8] c"#<MACRO>\00", align 1
@.str.244 = private unnamed_addr constant [11 x i8] c"#<CLOSURE>\00", align 1
@.str.245 = private unnamed_addr constant [11 x i8] c"#<PROMISE>\00", align 1
@.str.246 = private unnamed_addr constant [25 x i8] c"#<FOREIGN PROCEDURE %ld>\00", align 1
@.str.247 = private unnamed_addr constant [16 x i8] c"#<CONTINUATION>\00", align 1
@.str.248 = private unnamed_addr constant [9 x i8] c"#<ERROR>\00", align 1
@g_utf8_skip = external constant i8*, align 8
@.str.249 = private unnamed_addr constant [9 x i8] c"ILLEGAL!\00", align 1
@.str.250 = private unnamed_addr constant [5 x i8] c" -- \00", align 1
@.str.251 = private unnamed_addr constant [8 x i8] c"Error: \00", align 1
@.str.252 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.253 = private unnamed_addr constant [28 x i8] c"non-list argument to append\00", align 1
@.str.254 = private unnamed_addr constant [39 x i8] c"new-segment: argument must be a number\00", align 1
@.str.255 = private unnamed_addr constant [4 x i8] c"a+b\00", align 1
@.str.256 = private unnamed_addr constant [3 x i8] c"wb\00", align 1
@.str.257 = private unnamed_addr constant [23 x i8] c"unmatched parentheses:\00", align 1
@.str.258 = private unnamed_addr constant [25 x i8] c"read: not an input port:\00", align 1
@.str.259 = private unnamed_addr constant [37 x i8] c"syntax error: illegal dot expression\00", align 1
@.str.260 = private unnamed_addr constant [8 x i8] c"();\09\0A\0D \00", align 1
@.str.261 = private unnamed_addr constant [21 x i8] c"Error reading string\00", align 1
@.str.262 = private unnamed_addr constant [27 x i8] c"undefined sharp expression\00", align 1
@.str.263 = private unnamed_addr constant [28 x i8] c"syntax error: illegal token\00", align 1
@.str.264 = private unnamed_addr constant [3 x i8] c"#(\00", align 1
@.str.265 = private unnamed_addr constant [15 x i8] c"#<ENVIRONMENT>\00", align 1
@.str.266 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@.str.267 = private unnamed_addr constant [2 x i8] c"`\00", align 1
@.str.268 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.269 = private unnamed_addr constant [3 x i8] c",@\00", align 1
@.str.270 = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.271 = private unnamed_addr constant [4 x i8] c" . \00", align 1
@.str.272 = private unnamed_addr constant [2 x i8] c")\00", align 1
@.str.273 = private unnamed_addr constant [20 x i8] c"length: not a list:\00", align 1
@.str.274 = private unnamed_addr constant [34 x i8] c"unable to handle non pair element\00", align 1
@.str.275 = private unnamed_addr constant [6 x i8] c"gc...\00", align 1
@.str.276 = private unnamed_addr constant [33 x i8] c"done: %ld cells were recovered.\0A\00", align 1
@.str.277 = private unnamed_addr constant [27 x i8] c"%s: needs%s %d argument(s)\00", align 1
@.str.278 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.279 = private unnamed_addr constant [10 x i8] c" at least\00", align 1
@.str.280 = private unnamed_addr constant [9 x i8] c" at most\00", align 1
@tests = internal global [15 x %struct.anon.5] [%struct.anon.5 zeroinitializer, %struct.anon.5 { i32 (%struct.cell*)* @is_any, i8* null }, %struct.anon.5 { i32 (%struct.cell*)* @is_string, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.283, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_symbol, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.284, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_port, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.285, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_inport, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.286, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_outport, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.287, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_environment, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.288, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_pair, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.289, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* null, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.290, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_character, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.291, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_vector, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.90, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_number, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.292, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_integer, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.293, i32 0, i32 0) }, %struct.anon.5 { i32 (%struct.cell*)* @is_nonneg, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.294, i32 0, i32 0) }], align 16
@.str.281 = private unnamed_addr constant [28 x i8] c"%s: argument %d must be: %s\00", align 1
@stderr = external global %struct._IO_FILE*, align 8
@.str.282 = private unnamed_addr constant [12 x i8] c"No memory!\0A\00", align 1
@.str.283 = private unnamed_addr constant [7 x i8] c"string\00", align 1
@.str.284 = private unnamed_addr constant [7 x i8] c"symbol\00", align 1
@.str.285 = private unnamed_addr constant [5 x i8] c"port\00", align 1
@.str.286 = private unnamed_addr constant [11 x i8] c"input port\00", align 1
@.str.287 = private unnamed_addr constant [12 x i8] c"output port\00", align 1
@.str.288 = private unnamed_addr constant [12 x i8] c"environment\00", align 1
@.str.289 = private unnamed_addr constant [5 x i8] c"pair\00", align 1
@.str.290 = private unnamed_addr constant [12 x i8] c"pair or '()\00", align 1
@.str.291 = private unnamed_addr constant [10 x i8] c"character\00", align 1
@.str.292 = private unnamed_addr constant [7 x i8] c"number\00", align 1
@.str.293 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.294 = private unnamed_addr constant [21 x i8] c"non-negative integer\00", align 1

; Function Attrs: nounwind uwtable
define void @ts_register_output_func(void (i32, i8*, i32, i8*)* %func, i8* %user_data) #0 {
entry:
  %func.addr = alloca void (i32, i8*, i32, i8*)*, align 8
  %user_data.addr = alloca i8*, align 8
  store void (i32, i8*, i32, i8*)* %func, void (i32, i8*, i32, i8*)** %func.addr, align 8
  store i8* %user_data, i8** %user_data.addr, align 8
  %0 = load void (i32, i8*, i32, i8*)*, void (i32, i8*, i32, i8*)** %func.addr, align 8
  store void (i32, i8*, i32, i8*)* %0, void (i32, i8*, i32, i8*)** @ts_output_handler, align 8
  %1 = load i8*, i8** %user_data.addr, align 8
  store i8* %1, i8** @ts_output_data, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @ts_output_string(i32 %type, i8* %string, i32 %len) #0 {
entry:
  %type.addr = alloca i32, align 4
  %string.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  store i8* %string, i8** %string.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32, i32* %len.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %string.addr, align 8
  %call = call i64 @strlen(i8* %1) #6
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %len.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load void (i32, i8*, i32, i8*)*, void (i32, i8*, i32, i8*)** @ts_output_handler, align 8
  %tobool = icmp ne void (i32, i8*, i32, i8*)* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.end.4

land.lhs.true:                                    ; preds = %if.end
  %3 = load i32, i32* %len.addr, align 4
  %cmp1 = icmp sgt i32 %3, 0
  br i1 %cmp1, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %land.lhs.true
  %4 = load void (i32, i8*, i32, i8*)*, void (i32, i8*, i32, i8*)** @ts_output_handler, align 8
  %5 = load i32, i32* %type.addr, align 4
  %6 = load i8*, i8** %string.addr, align 8
  %7 = load i32, i32* %len.addr, align 4
  %8 = load i8*, i8** @ts_output_data, align 8
  call void %4(i32 %5, i8* %6, i32 %7, i8* %8)
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %land.lhs.true, %if.end
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #1

; Function Attrs: nounwind uwtable
define i32 @is_string(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_vector(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 11
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_number(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 2
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_integer(%struct.cell* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @is_number(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call1 = call i32 @num_is_integer(%struct.cell* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %2 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call3 = call i64 @ivalue(%struct.cell* %2)
  %conv = sitofp i64 %call3 to double
  %3 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call4 = call double @rvalue(%struct.cell* %3)
  %cmp = fcmp oeq double %conv, %call4
  br i1 %cmp, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %lor.lhs.false, %if.end
  store i32 1, i32* %retval
  br label %return

if.end.7:                                         ; preds = %lor.lhs.false
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6, %if.then
  %4 = load i32, i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @num_is_integer(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 0
  %1 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i64 @ivalue(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @num_is_integer(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %2 = load i64, i64* %ivalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_number2 = bitcast %union.anon* %_object1 to %struct.num*
  %value3 = getelementptr inbounds %struct.num, %struct.num* %_number2, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value3 to double*
  %4 = load double, double* %rvalue, align 8
  %conv = fptosi double %4 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %conv, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define double @rvalue(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @num_is_integer(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value to double*
  %2 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_number2 = bitcast %union.anon* %_object1 to %struct.num*
  %value3 = getelementptr inbounds %struct.num, %struct.num* %_number2, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value3 to i64*
  %4 = load i64, i64* %ivalue, align 8
  %conv = sitofp i64 %4 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %2, %cond.true ], [ %conv, %cond.false ]
  ret double %cond
}

; Function Attrs: nounwind uwtable
define i32 @is_real(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @is_number(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 0
  %2 = load i8, i8* %is_fixnum, align 1
  %tobool1 = icmp ne i8 %2, 0
  %lnot = xor i1 %tobool1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define i32 @is_character(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 9
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @string_length(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 1
  %1 = load i32, i32* %_length, align 4
  ret i32 %1
}

; Function Attrs: nounwind uwtable
define i8* @string_value(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %1 = load i8*, i8** %_svalue, align 8
  ret i8* %1
}

; Function Attrs: nounwind uwtable
define { i8, i64 } @nvalue(%struct.cell* %p) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %1 = bitcast %struct.num* %retval to i8*
  %2 = bitcast %struct.num* %_number to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 16, i32 8, i1 false)
  %3 = bitcast %struct.num* %retval to { i8, i64 }*
  %4 = load { i8, i64 }, { i8, i64 }* %3, align 8
  ret { i8, i64 } %4
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define i32 @charvalue(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %1 = load i64, i64* %ivalue, align 8
  %conv = trunc i64 %1 to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_port(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 10
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_inport(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @is_port(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %2 = load %struct.port*, %struct.port** %_port, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %2, i32 0, i32 0
  %3 = load i8, i8* %kind, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 16
  %tobool1 = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define i32 @is_outport(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i32 @is_port(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %2 = load %struct.port*, %struct.port** %_port, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %2, i32 0, i32 0
  %3 = load i8, i8* %kind, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 32
  %tobool1 = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %4 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  %land.ext = zext i1 %4 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define i32 @is_pair(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 5
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.cell* @pair_car(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %1 = load %struct.cell*, %struct.cell** %_car, align 8
  ret %struct.cell* %1
}

; Function Attrs: nounwind uwtable
define %struct.cell* @pair_cdr(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %1 = load %struct.cell*, %struct.cell** %_cdr, align 8
  ret %struct.cell* %1
}

; Function Attrs: nounwind uwtable
define %struct.cell* @set_car(%struct.cell* %p, %struct.cell* %q) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  %q.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  store %struct.cell* %q, %struct.cell** %q.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %q.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %0, %struct.cell** %_car, align 8
  ret %struct.cell* %0
}

; Function Attrs: nounwind uwtable
define %struct.cell* @set_cdr(%struct.cell* %p, %struct.cell* %q) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  %q.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  store %struct.cell* %q, %struct.cell** %q.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %q.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  store %struct.cell* %0, %struct.cell** %_cdr, align 8
  ret %struct.cell* %0
}

; Function Attrs: nounwind uwtable
define i32 @is_symbol(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 3
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i8* @symname(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %1 = load %struct.cell*, %struct.cell** %_car, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_string = bitcast %union.anon* %_object1 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %2 = load i8*, i8** %_svalue, align 8
  ret i8* %2
}

; Function Attrs: nounwind uwtable
define i32 @is_syntax(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 4096
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define i32 @is_proc(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 4
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_foreign(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 8
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i8* @syntaxname(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %1 = load %struct.cell*, %struct.cell** %_car, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_string = bitcast %union.anon* %_object1 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %2 = load i8*, i8** %_svalue, align 8
  ret i8* %2
}

; Function Attrs: nounwind uwtable
define i32 @is_closure(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 6
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_macro(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 12
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define %struct.cell* @closure_code(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %1 = load %struct.cell*, %struct.cell** %_car, align 8
  ret %struct.cell* %1
}

; Function Attrs: nounwind uwtable
define %struct.cell* @closure_env(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %1 = load %struct.cell*, %struct.cell** %_cdr, align 8
  ret %struct.cell* %1
}

; Function Attrs: nounwind uwtable
define i32 @is_continuation(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 7
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_promise(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 13
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_environment(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 31
  %cmp = icmp eq i32 %and, 14
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @is_immutable(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %and = and i32 %1, 8192
  ret i32 %and
}

; Function Attrs: nounwind uwtable
define void @setimmutable(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 0
  %1 = load i32, i32* %_flag, align 4
  %or = or i32 %1, 8192
  store i32 %or, i32* %_flag, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cell* @_cons(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b, i32 %immutable) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %immutable.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  store i32 %immutable, i32* %immutable.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %3 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 0
  store i32 5, i32* %_flag, align 4
  %4 = load i32, i32* %immutable.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  call void @setimmutable(%struct.cell* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %6, %struct.cell** %_car, align 8
  %8 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 1
  store %struct.cell* %8, %struct.cell** %_cdr, align 8
  %10 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %10
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @get_cell(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %cell = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call = call %struct.cell* @get_cell_x(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2)
  store %struct.cell* %call, %struct.cell** %cell, align 8
  %3 = load %struct.cell*, %struct.cell** %cell, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 0
  store i32 5, i32* %_flag, align 4
  %4 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %5 = load %struct.cell*, %struct.cell** %cell, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %4, %struct.cell** %_car, align 8
  %6 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %cell, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 1
  store %struct.cell* %6, %struct.cell** %_cdr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %9 = load %struct.cell*, %struct.cell** %cell, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  %11 = load %struct.cell*, %struct.cell** %NIL, align 8
  call void @push_recent_alloc(%struct.scheme* %8, %struct.cell* %9, %struct.cell* %11)
  %12 = load %struct.cell*, %struct.cell** %cell, align 8
  ret %struct.cell* %12
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_foreign_func(%struct.scheme* %sc, %struct.cell* (%struct.scheme*, %struct.cell*)* %f) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %f.addr = alloca %struct.cell* (%struct.scheme*, %struct.cell*)*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* (%struct.scheme*, %struct.cell*)* %f, %struct.cell* (%struct.scheme*, %struct.cell*)** %f.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16392, i32* %_flag, align 4
  %6 = load %struct.cell* (%struct.scheme*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*)** %f.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_ff = bitcast %union.anon* %_object to %struct.cell* (%struct.scheme*, %struct.cell*)**
  store %struct.cell* (%struct.scheme*, %struct.cell*)* %6, %struct.cell* (%struct.scheme*, %struct.cell*)** %_ff, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_character(%struct.scheme* %sc, i32 %c) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %c.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16393, i32* %_flag, align 4
  %6 = load i32, i32* %c.addr, align 4
  %conv = zext i32 %6 to i64
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  store i64 %conv, i64* %ivalue, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_number3 = bitcast %union.anon* %_object2 to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number3, i32 0, i32 0
  store i8 1, i8* %is_fixnum, align 1
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_integer(%struct.scheme* %sc, i64 %num) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %num.addr = alloca i64, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i64 %num, i64* %num.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16386, i32* %_flag, align 4
  %6 = load i64, i64* %num.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  store i64 %6, i64* %ivalue, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_number3 = bitcast %union.anon* %_object2 to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number3, i32 0, i32 0
  store i8 1, i8* %is_fixnum, align 1
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_real(%struct.scheme* %sc, double %n) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %n.addr = alloca double, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store double %n, double* %n.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16386, i32* %_flag, align 4
  %6 = load double, double* %n.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value to double*
  store double %6, double* %rvalue, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_number3 = bitcast %union.anon* %_object2 to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number3, i32 0, i32 0
  store i8 0, i8* %is_fixnum, align 1
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define %struct.cell* @foreign_error(%struct.scheme* %sc, i8* %s, %struct.cell* %a) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %s.addr = alloca i8*, align 8
  %a.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load i8*, i8** %s.addr, align 8
  %call = call %struct.cell* @mk_string(%struct.scheme* %1, i8* %2)
  %3 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call1 = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %call, %struct.cell* %3, i32 0)
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %foreign_error = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 11
  store %struct.cell* %call1, %struct.cell** %foreign_error, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 19
  %6 = load %struct.cell*, %struct.cell** %T, align 8
  ret %struct.cell* %6
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_string(%struct.scheme* %sc, i8* %str) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %str.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %str.addr, align 8
  %2 = load i8*, i8** %str.addr, align 8
  %call = call i64 @g_utf8_strlen(i8* %2, i64 -1) #6
  %conv = trunc i64 %call to i32
  %call1 = call %struct.cell* @mk_counted_string(%struct.scheme* %0, i8* %1, i32 %conv)
  ret %struct.cell* %call1
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_counted_string(%struct.scheme* %sc, i8* %str, i32 %len) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %str.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %str, i8** %str.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16385, i32* %_flag, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load i32, i32* %len.addr, align 4
  %8 = load i8*, i8** %str.addr, align 8
  %call2 = call i8* @store_string(%struct.scheme* %6, i32 %7, i8* %8, i32 0)
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  store i8* %call2, i8** %_svalue, align 8
  %10 = load i32, i32* %len.addr, align 4
  %11 = load %struct.cell*, %struct.cell** %x, align 8
  %_object3 = getelementptr inbounds %struct.cell, %struct.cell* %11, i32 0, i32 1
  %_string4 = bitcast %union.anon* %_object3 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string4, i32 0, i32 1
  store i32 %10, i32* %_length, align 4
  %12 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %12
}

; Function Attrs: nounwind readonly
declare i64 @g_utf8_strlen(i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i8* @store_string(%struct.scheme* %sc, i32 %char_cnt, i8* %str, i32 %fill) #0 {
entry:
  %retval = alloca i8*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %char_cnt.addr = alloca i32, align 4
  %str.addr = alloca i8*, align 8
  %fill.addr = alloca i32, align 4
  %len = alloca i32, align 4
  %i = alloca i32, align 4
  %utf8 = alloca [7 x i8], align 1
  %q = alloca i8*, align 8
  %q2 = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %char_cnt, i32* %char_cnt.addr, align 4
  store i8* %str, i8** %str.addr, align 8
  store i32 %fill, i32* %fill.addr, align 4
  %0 = load i8*, i8** %str.addr, align 8
  %cmp = icmp ne i8* %0, null
  br i1 %cmp, label %if.then, label %if.else.12

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %str.addr, align 8
  %2 = load i32, i32* %char_cnt.addr, align 4
  %conv = sext i32 %2 to i64
  %call = call i8* @g_utf8_offset_to_pointer(i8* %1, i64 %conv) #6
  store i8* %call, i8** %q2, align 8
  %3 = load i8*, i8** %str.addr, align 8
  %call1 = call i32 @g_utf8_validate(i8* %3, i64 -1, i8** %q)
  %4 = load i8*, i8** %q, align 8
  %5 = load i8*, i8** %q2, align 8
  %cmp2 = icmp ule i8* %4, %5
  br i1 %cmp2, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.then
  %6 = load i8*, i8** %q, align 8
  %7 = load i8*, i8** %str.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv5 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv5, i32* %len, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %8 = load i8*, i8** %q2, align 8
  %9 = load i8*, i8** %str.addr, align 8
  %sub.ptr.lhs.cast6 = ptrtoint i8* %8 to i64
  %sub.ptr.rhs.cast7 = ptrtoint i8* %9 to i64
  %sub.ptr.sub8 = sub i64 %sub.ptr.lhs.cast6, %sub.ptr.rhs.cast7
  %conv9 = trunc i64 %sub.ptr.sub8 to i32
  store i32 %conv9, i32* %len, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.4
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 0
  %11 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %12 = load i32, i32* %len, align 4
  %add = add nsw i32 %12, 1
  %conv10 = sext i32 %add to i64
  %call11 = call i8* %11(i64 %conv10)
  store i8* %call11, i8** %q, align 8
  br label %if.end.18

if.else.12:                                       ; preds = %entry
  %13 = load i32, i32* %fill.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i32 0
  %call13 = call i32 @g_unichar_to_utf8(i32 %13, i8* %arraydecay)
  store i32 %call13, i32* %len, align 4
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc14 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 0
  %15 = load i8* (i64)*, i8* (i64)** %malloc14, align 8
  %16 = load i32, i32* %char_cnt.addr, align 4
  %17 = load i32, i32* %len, align 4
  %mul = mul nsw i32 %16, %17
  %add15 = add nsw i32 %mul, 1
  %conv16 = sext i32 %add15 to i64
  %call17 = call i8* %15(i64 %conv16)
  store i8* %call17, i8** %q, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.else.12, %if.end
  %18 = load i8*, i8** %q, align 8
  %cmp19 = icmp eq i8* %18, null
  br i1 %cmp19, label %if.then.21, label %if.end.23

if.then.21:                                       ; preds = %if.end.18
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 48
  store i8 1, i8* %no_memory, align 1
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 50
  %arraydecay22 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  store i8* %arraydecay22, i8** %retval
  br label %return

if.end.23:                                        ; preds = %if.end.18
  %21 = load i8*, i8** %str.addr, align 8
  %cmp24 = icmp ne i8* %21, null
  br i1 %cmp24, label %if.then.26, label %if.else.28

if.then.26:                                       ; preds = %if.end.23
  %22 = load i8*, i8** %q, align 8
  %23 = load i8*, i8** %str.addr, align 8
  %24 = load i32, i32* %len, align 4
  %conv27 = sext i32 %24 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %22, i8* %23, i64 %conv27, i32 1, i1 false)
  %25 = load i32, i32* %len, align 4
  %idxprom = sext i32 %25 to i64
  %26 = load i8*, i8** %q, align 8
  %arrayidx = getelementptr inbounds i8, i8* %26, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  br label %if.end.32

if.else.28:                                       ; preds = %if.end.23
  %27 = load i8*, i8** %q, align 8
  store i8* %27, i8** %q2, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else.28
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* %char_cnt.addr, align 4
  %cmp29 = icmp slt i32 %28, %29
  br i1 %cmp29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load i8*, i8** %q2, align 8
  %31 = bitcast [7 x i8]* %utf8 to i8*
  %32 = load i32, i32* %len, align 4
  %conv31 = sext i32 %32 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %30, i8* %31, i64 %conv31, i32 1, i1 false)
  %33 = load i32, i32* %len, align 4
  %34 = load i8*, i8** %q2, align 8
  %idx.ext = sext i32 %33 to i64
  %add.ptr = getelementptr inbounds i8, i8* %34, i64 %idx.ext
  store i8* %add.ptr, i8** %q2, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %35 = load i32, i32* %i, align 4
  %inc = add nsw i32 %35, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %36 = load i8*, i8** %q2, align 8
  store i8 0, i8* %36, align 1
  br label %if.end.32

if.end.32:                                        ; preds = %for.end, %if.then.26
  %37 = load i8*, i8** %q, align 8
  store i8* %37, i8** %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then.21
  %38 = load i8*, i8** %retval
  ret i8* %38
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_empty_string(%struct.scheme* %sc, i32 %len, i32 %fill) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %len.addr = alloca i32, align 4
  %fill.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store i32 %fill, i32* %fill.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16385, i32* %_flag, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load i32, i32* %len.addr, align 4
  %8 = load i32, i32* %fill.addr, align 4
  %call2 = call i8* @store_string(%struct.scheme* %6, i32 %7, i8* null, i32 %8)
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  store i8* %call2, i8** %_svalue, align 8
  %10 = load i32, i32* %len.addr, align 4
  %11 = load %struct.cell*, %struct.cell** %x, align 8
  %_object3 = getelementptr inbounds %struct.cell, %struct.cell* %11, i32 0, i32 1
  %_string4 = bitcast %union.anon* %_object3 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string4, i32 0, i32 1
  store i32 %10, i32* %_length, align 4
  %12 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %12
}

; Function Attrs: nounwind uwtable
define %struct.cell* @mk_symbol(%struct.scheme* %sc, i8* %name) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %name.addr = alloca i8*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %name.addr, align 8
  %call = call %struct.cell* @oblist_find_by_name(%struct.scheme* %0, i8* %1)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %2 = load %struct.cell*, %struct.cell** %x, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %2, %4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load i8*, i8** %name.addr, align 8
  %call1 = call %struct.cell* @oblist_add_by_name(%struct.scheme* %6, i8* %7)
  store %struct.cell* %call1, %struct.cell** %x, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %8, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @oblist_find_by_name(%struct.scheme* %sc, i8* %name) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %name.addr = alloca i8*, align 8
  %location = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %s = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 24
  %2 = load %struct.cell*, %struct.cell** %oblist, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %3 = load i64, i64* %ivalue, align 8
  %conv = trunc i64 %3 to i32
  %call = call i32 @hash_fn(i8* %0, i32 %conv)
  store i32 %call, i32* %location, align 4
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist1 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 24
  %5 = load %struct.cell*, %struct.cell** %oblist1, align 8
  %6 = load i32, i32* %location, align 4
  %call2 = call %struct.cell* @vector_elem(%struct.cell* %5, i32 %6)
  store %struct.cell* %call2, %struct.cell** %x, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 17
  %9 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %7, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.cell*, %struct.cell** %x, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %10, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object4 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %11 = load %struct.cell*, %struct.cell** %_car, align 8
  %call5 = call i8* @symname(%struct.cell* %11)
  store i8* %call5, i8** %s, align 8
  %12 = load i8*, i8** %name.addr, align 8
  %13 = load i8*, i8** %s, align 8
  %call6 = call i32 @utf8_stricmp(i8* %12, i8* %13)
  %cmp7 = icmp eq i32 %call6, 0
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %14 = load %struct.cell*, %struct.cell** %x, align 8
  %_object9 = getelementptr inbounds %struct.cell, %struct.cell* %14, i32 0, i32 1
  %_cons10 = bitcast %union.anon* %_object9 to %struct.anon.4*
  %_car11 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons10, i32 0, i32 0
  %15 = load %struct.cell*, %struct.cell** %_car11, align 8
  store %struct.cell* %15, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load %struct.cell*, %struct.cell** %x, align 8
  %_object12 = getelementptr inbounds %struct.cell, %struct.cell* %16, i32 0, i32 1
  %_cons13 = bitcast %union.anon* %_object12 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons13, i32 0, i32 1
  %17 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %17, %struct.cell** %x, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL14 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 17
  %19 = load %struct.cell*, %struct.cell** %NIL14, align 8
  store %struct.cell* %19, %struct.cell** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %20 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %20
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @oblist_add_by_name(%struct.scheme* %sc, i8* %name) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %name.addr = alloca i8*, align 8
  %x = alloca %struct.cell*, align 8
  %location = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load i8*, i8** %name.addr, align 8
  %call = call %struct.cell* @mk_string(%struct.scheme* %1, i8* %2)
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL, align 8
  %call1 = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %call, %struct.cell* %4, i32 1)
  store %struct.cell* %call1, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 3, i32* %_flag, align 4
  %6 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %7 = load %struct.cell*, %struct.cell** %_car, align 8
  call void @setimmutable(%struct.cell* %7)
  %8 = load i8*, i8** %name.addr, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 24
  %10 = load %struct.cell*, %struct.cell** %oblist, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %10, i32 0, i32 1
  %_number = bitcast %union.anon* %_object2 to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %11 = load i64, i64* %ivalue, align 8
  %conv = trunc i64 %11 to i32
  %call3 = call i32 @hash_fn(i8* %8, i32 %conv)
  store i32 %call3, i32* %location, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist4 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 24
  %13 = load %struct.cell*, %struct.cell** %oblist4, align 8
  %14 = load i32, i32* %location, align 4
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %16 = load %struct.cell*, %struct.cell** %x, align 8
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist5 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 24
  %18 = load %struct.cell*, %struct.cell** %oblist5, align 8
  %19 = load i32, i32* %location, align 4
  %call6 = call %struct.cell* @vector_elem(%struct.cell* %18, i32 %19)
  %call7 = call %struct.cell* @_cons(%struct.scheme* %15, %struct.cell* %16, %struct.cell* %call6, i32 1)
  %call8 = call %struct.cell* @set_vector_elem(%struct.cell* %13, i32 %14, %struct.cell* %call7)
  %20 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %20
}

; Function Attrs: nounwind uwtable
define %struct.cell* @gensym(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %x = alloca %struct.cell*, align 8
  %name = alloca [40 x i8], align 16
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gensym_cnt = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 57
  %1 = load i64, i64* %gensym_cnt, align 8
  %cmp = icmp slt i64 %1, 9223372036854775807
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %arraydecay = getelementptr inbounds [40 x i8], [40 x i8]* %name, i32 0, i32 0
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gensym_cnt1 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 57
  %3 = load i64, i64* %gensym_cnt1, align 8
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 40, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str, i32 0, i32 0), i64 %3) #2
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %arraydecay2 = getelementptr inbounds [40 x i8], [40 x i8]* %name, i32 0, i32 0
  %call3 = call %struct.cell* @oblist_find_by_name(%struct.scheme* %4, i8* %arraydecay2)
  store %struct.cell* %call3, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 17
  %7 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp4 = icmp ne %struct.cell* %5, %7
  br i1 %cmp4, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  br label %for.inc

if.else:                                          ; preds = %for.body
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %arraydecay5 = getelementptr inbounds [40 x i8], [40 x i8]* %name, i32 0, i32 0
  %call6 = call %struct.cell* @oblist_add_by_name(%struct.scheme* %8, i8* %arraydecay5)
  store %struct.cell* %call6, %struct.cell** %x, align 8
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %9, %struct.cell** %retval
  br label %return

for.inc:                                          ; preds = %if.then
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gensym_cnt7 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 57
  %11 = load i64, i64* %gensym_cnt7, align 8
  %inc = add nsw i64 %11, 1
  store i64 %inc, i64* %gensym_cnt7, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL8 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 17
  %13 = load %struct.cell*, %struct.cell** %NIL8, align 8
  store %struct.cell* %13, %struct.cell** %retval
  br label %return

return:                                           ; preds = %for.end, %if.else
  %14 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %14
}

; Function Attrs: nounwind
declare i32 @snprintf(i8*, i64, i8*, ...) #3

; Function Attrs: nounwind uwtable
define void @putcharacter(%struct.scheme* %sc, i32 %c) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %c.addr = alloca i32, align 4
  %utf8 = alloca [7 x i8], align 1
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i32 0
  %call = call i32 @g_unichar_to_utf8(i32 %0, i8* %arraydecay)
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %arraydecay1 = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i32 0
  call void @putchars(%struct.scheme* %1, i8* %arraydecay1, i32 1)
  ret void
}

declare i32 @g_unichar_to_utf8(i32, i8*) #4

; Function Attrs: nounwind uwtable
define internal void @putchars(%struct.scheme* %sc, i8* %chars, i32 %char_cnt) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %chars.addr = alloca i8*, align 8
  %char_cnt.addr = alloca i32, align 4
  %free_bytes = alloca i32, align 4
  %l = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %chars, i8** %chars.addr, align 8
  store i32 %char_cnt, i32* %char_cnt.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 40
  %1 = load %struct.cell*, %struct.cell** %outport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %2 = load %struct.port*, %struct.port** %_port, align 8
  store %struct.port* %2, %struct.port** %pt, align 8
  %3 = load i32, i32* %char_cnt.addr, align 4
  %cmp = icmp sle i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end.78

if.end:                                           ; preds = %entry
  %4 = load i8*, i8** %chars.addr, align 8
  %5 = load i32, i32* %char_cnt.addr, align 4
  %conv = sext i32 %5 to i64
  %call = call i8* @g_utf8_offset_to_pointer(i8* %4, i64 %conv) #6
  %6 = load i8*, i8** %chars.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %call to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv1 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv1, i32* %char_cnt.addr, align 4
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 0
  %8 = load i8, i8* %kind, align 1
  %conv2 = zext i8 %8 to i32
  %and = and i32 %conv2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.3, label %if.else.17

if.then.3:                                        ; preds = %if.end
  %9 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %9, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %cmp4 = icmp eq %struct._IO_FILE* %10, %11
  br i1 %cmp4, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.then.3
  %12 = load i8*, i8** %chars.addr, align 8
  %13 = load i32, i32* %char_cnt.addr, align 4
  call void @ts_output_string(i32 0, i8* %12, i32 %13)
  br label %if.end.16

if.else:                                          ; preds = %if.then.3
  %14 = load i8*, i8** %chars.addr, align 8
  %15 = load i32, i32* %char_cnt.addr, align 4
  %conv7 = sext i32 %15 to i64
  %16 = load %struct.port*, %struct.port** %pt, align 8
  %rep8 = getelementptr inbounds %struct.port, %struct.port* %16, i32 0, i32 1
  %stdio9 = bitcast %union.anon.1* %rep8 to %struct.anon.2*
  %file10 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio9, i32 0, i32 0
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** %file10, align 8
  %call11 = call i64 @fwrite(i8* %14, i64 1, i64 %conv7, %struct._IO_FILE* %17)
  %18 = load %struct.port*, %struct.port** %pt, align 8
  %rep12 = getelementptr inbounds %struct.port, %struct.port* %18, i32 0, i32 1
  %stdio13 = bitcast %union.anon.1* %rep12 to %struct.anon.2*
  %file14 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio13, i32 0, i32 0
  %19 = load %struct._IO_FILE*, %struct._IO_FILE** %file14, align 8
  %call15 = call i32 @fflush(%struct._IO_FILE* %19)
  br label %if.end.16

if.end.16:                                        ; preds = %if.else, %if.then.6
  br label %if.end.78

if.else.17:                                       ; preds = %if.end
  %20 = load %struct.port*, %struct.port** %pt, align 8
  %rep18 = getelementptr inbounds %struct.port, %struct.port* %20, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep18 to %struct.anon.3*
  %past_the_end = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 1
  %21 = load i8*, i8** %past_the_end, align 8
  %22 = load %struct.port*, %struct.port** %pt, align 8
  %rep19 = getelementptr inbounds %struct.port, %struct.port* %22, i32 0, i32 1
  %string20 = bitcast %union.anon.1* %rep19 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string20, i32 0, i32 2
  %23 = load i8*, i8** %curr, align 8
  %cmp21 = icmp ne i8* %21, %23
  br i1 %cmp21, label %if.then.23, label %if.else.43

if.then.23:                                       ; preds = %if.else.17
  %24 = load %struct.port*, %struct.port** %pt, align 8
  %rep24 = getelementptr inbounds %struct.port, %struct.port* %24, i32 0, i32 1
  %string25 = bitcast %union.anon.1* %rep24 to %struct.anon.3*
  %past_the_end26 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string25, i32 0, i32 1
  %25 = load i8*, i8** %past_the_end26, align 8
  %26 = load %struct.port*, %struct.port** %pt, align 8
  %rep27 = getelementptr inbounds %struct.port, %struct.port* %26, i32 0, i32 1
  %string28 = bitcast %union.anon.1* %rep27 to %struct.anon.3*
  %curr29 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string28, i32 0, i32 2
  %27 = load i8*, i8** %curr29, align 8
  %sub.ptr.lhs.cast30 = ptrtoint i8* %25 to i64
  %sub.ptr.rhs.cast31 = ptrtoint i8* %27 to i64
  %sub.ptr.sub32 = sub i64 %sub.ptr.lhs.cast30, %sub.ptr.rhs.cast31
  %conv33 = trunc i64 %sub.ptr.sub32 to i32
  store i32 %conv33, i32* %free_bytes, align 4
  %28 = load i32, i32* %char_cnt.addr, align 4
  %29 = load i32, i32* %free_bytes, align 4
  %cmp34 = icmp sle i32 %28, %29
  br i1 %cmp34, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.23
  %30 = load i32, i32* %char_cnt.addr, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then.23
  %31 = load i32, i32* %free_bytes, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %30, %cond.true ], [ %31, %cond.false ]
  store i32 %cond, i32* %l, align 4
  %32 = load %struct.port*, %struct.port** %pt, align 8
  %rep36 = getelementptr inbounds %struct.port, %struct.port* %32, i32 0, i32 1
  %string37 = bitcast %union.anon.1* %rep36 to %struct.anon.3*
  %curr38 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string37, i32 0, i32 2
  %33 = load i8*, i8** %curr38, align 8
  %34 = load i8*, i8** %chars.addr, align 8
  %35 = load i32, i32* %l, align 4
  %conv39 = sext i32 %35 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %33, i8* %34, i64 %conv39, i32 1, i1 false)
  %36 = load i32, i32* %l, align 4
  %37 = load %struct.port*, %struct.port** %pt, align 8
  %rep40 = getelementptr inbounds %struct.port, %struct.port* %37, i32 0, i32 1
  %string41 = bitcast %union.anon.1* %rep40 to %struct.anon.3*
  %curr42 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string41, i32 0, i32 2
  %38 = load i8*, i8** %curr42, align 8
  %idx.ext = sext i32 %36 to i64
  %add.ptr = getelementptr inbounds i8, i8* %38, i64 %idx.ext
  store i8* %add.ptr, i8** %curr42, align 8
  br label %if.end.77

if.else.43:                                       ; preds = %if.else.17
  %39 = load %struct.port*, %struct.port** %pt, align 8
  %kind44 = getelementptr inbounds %struct.port, %struct.port* %39, i32 0, i32 0
  %40 = load i8, i8* %kind44, align 1
  %conv45 = zext i8 %40 to i32
  %and46 = and i32 %conv45, 4
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %land.lhs.true, label %if.end.76

land.lhs.true:                                    ; preds = %if.else.43
  %41 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %42 = load %struct.port*, %struct.port** %pt, align 8
  %call48 = call i32 @realloc_port_string(%struct.scheme* %41, %struct.port* %42)
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.then.50, label %if.end.76

if.then.50:                                       ; preds = %land.lhs.true
  %43 = load %struct.port*, %struct.port** %pt, align 8
  %rep51 = getelementptr inbounds %struct.port, %struct.port* %43, i32 0, i32 1
  %string52 = bitcast %union.anon.1* %rep51 to %struct.anon.3*
  %past_the_end53 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string52, i32 0, i32 1
  %44 = load i8*, i8** %past_the_end53, align 8
  %45 = load %struct.port*, %struct.port** %pt, align 8
  %rep54 = getelementptr inbounds %struct.port, %struct.port* %45, i32 0, i32 1
  %string55 = bitcast %union.anon.1* %rep54 to %struct.anon.3*
  %curr56 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string55, i32 0, i32 2
  %46 = load i8*, i8** %curr56, align 8
  %sub.ptr.lhs.cast57 = ptrtoint i8* %44 to i64
  %sub.ptr.rhs.cast58 = ptrtoint i8* %46 to i64
  %sub.ptr.sub59 = sub i64 %sub.ptr.lhs.cast57, %sub.ptr.rhs.cast58
  %conv60 = trunc i64 %sub.ptr.sub59 to i32
  store i32 %conv60, i32* %free_bytes, align 4
  %47 = load i32, i32* %char_cnt.addr, align 4
  %48 = load i32, i32* %free_bytes, align 4
  %cmp61 = icmp sle i32 %47, %48
  br i1 %cmp61, label %cond.true.63, label %cond.false.64

cond.true.63:                                     ; preds = %if.then.50
  %49 = load i32, i32* %char_cnt.addr, align 4
  br label %cond.end.65

cond.false.64:                                    ; preds = %if.then.50
  %50 = load i32, i32* %free_bytes, align 4
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.false.64, %cond.true.63
  %cond66 = phi i32 [ %49, %cond.true.63 ], [ %50, %cond.false.64 ]
  store i32 %cond66, i32* %l, align 4
  %51 = load %struct.port*, %struct.port** %pt, align 8
  %rep67 = getelementptr inbounds %struct.port, %struct.port* %51, i32 0, i32 1
  %string68 = bitcast %union.anon.1* %rep67 to %struct.anon.3*
  %curr69 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string68, i32 0, i32 2
  %52 = load i8*, i8** %curr69, align 8
  %53 = load i8*, i8** %chars.addr, align 8
  %54 = load i32, i32* %char_cnt.addr, align 4
  %conv70 = sext i32 %54 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %52, i8* %53, i64 %conv70, i32 1, i1 false)
  %55 = load i32, i32* %l, align 4
  %56 = load %struct.port*, %struct.port** %pt, align 8
  %rep71 = getelementptr inbounds %struct.port, %struct.port* %56, i32 0, i32 1
  %string72 = bitcast %union.anon.1* %rep71 to %struct.anon.3*
  %curr73 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string72, i32 0, i32 2
  %57 = load i8*, i8** %curr73, align 8
  %idx.ext74 = sext i32 %55 to i64
  %add.ptr75 = getelementptr inbounds i8, i8* %57, i64 %idx.ext74
  store i8* %add.ptr75, i8** %curr73, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %cond.end.65, %land.lhs.true, %if.else.43
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.76, %cond.end
  br label %if.end.78

if.end.78:                                        ; preds = %if.then, %if.end.77, %if.end.16
  ret void
}

; Function Attrs: nounwind uwtable
define void @putstr(%struct.scheme* %sc, i8* %s) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %s.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %s.addr, align 8
  %2 = load i8*, i8** %s.addr, align 8
  %call = call i64 @g_utf8_strlen(i8* %2, i64 -1) #6
  %conv = trunc i64 %call to i32
  call void @putchars(%struct.scheme* %0, i8* %1, i32 %conv)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @eqv(%struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %agg.tmp = alloca %struct.num, align 8
  %agg.tmp20 = alloca %struct.num, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call = call i32 @is_string(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else.7

if.then:                                          ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call1 = call i32 @is_string(%struct.cell* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.then
  %2 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %3 = load i8*, i8** %_svalue, align 8
  %4 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_string5 = bitcast %union.anon* %_object4 to %struct.anon*
  %_svalue6 = getelementptr inbounds %struct.anon, %struct.anon* %_string5, i32 0, i32 0
  %5 = load i8*, i8** %_svalue6, align 8
  %cmp = icmp eq i8* %3, %5
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then
  store i32 0, i32* %retval
  br label %return

if.else.7:                                        ; preds = %entry
  %6 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call8 = call i32 @is_number(%struct.cell* %6)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then.10, label %if.else.24

if.then.10:                                       ; preds = %if.else.7
  %7 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call11 = call i32 @is_number(%struct.cell* %7)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then.13, label %if.end.23

if.then.13:                                       ; preds = %if.then.10
  %8 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call14 = call i32 @num_is_integer(%struct.cell* %8)
  %9 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call15 = call i32 @num_is_integer(%struct.cell* %9)
  %cmp16 = icmp eq i32 %call14, %call15
  br i1 %cmp16, label %if.then.18, label %if.end

if.then.18:                                       ; preds = %if.then.13
  %10 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call19 = call { i8, i64 } @nvalue(%struct.cell* %10)
  %11 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %12 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 0
  %13 = extractvalue { i8, i64 } %call19, 0
  store i8 %13, i8* %12, align 8
  %14 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 1
  %15 = extractvalue { i8, i64 } %call19, 1
  store i64 %15, i64* %14, align 8
  %16 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call21 = call { i8, i64 } @nvalue(%struct.cell* %16)
  %17 = bitcast %struct.num* %agg.tmp20 to { i8, i64 }*
  %18 = getelementptr { i8, i64 }, { i8, i64 }* %17, i32 0, i32 0
  %19 = extractvalue { i8, i64 } %call21, 0
  store i8 %19, i8* %18, align 8
  %20 = getelementptr { i8, i64 }, { i8, i64 }* %17, i32 0, i32 1
  %21 = extractvalue { i8, i64 } %call21, 1
  store i64 %21, i64* %20, align 8
  %22 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %23 = getelementptr { i8, i64 }, { i8, i64 }* %22, i32 0, i32 0
  %24 = load i8, i8* %23, align 1
  %25 = getelementptr { i8, i64 }, { i8, i64 }* %22, i32 0, i32 1
  %26 = load i64, i64* %25, align 1
  %27 = bitcast %struct.num* %agg.tmp20 to { i8, i64 }*
  %28 = getelementptr { i8, i64 }, { i8, i64 }* %27, i32 0, i32 0
  %29 = load i8, i8* %28, align 1
  %30 = getelementptr { i8, i64 }, { i8, i64 }* %27, i32 0, i32 1
  %31 = load i64, i64* %30, align 1
  %call22 = call i32 @num_eq(i8 %24, i64 %26, i8 %29, i64 %31)
  store i32 %call22, i32* %retval
  br label %return

if.end:                                           ; preds = %if.then.13
  br label %if.end.23

if.end.23:                                        ; preds = %if.end, %if.then.10
  store i32 0, i32* %retval
  br label %return

if.else.24:                                       ; preds = %if.else.7
  %32 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call25 = call i32 @is_character(%struct.cell* %32)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %if.then.27, label %if.else.36

if.then.27:                                       ; preds = %if.else.24
  %33 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call28 = call i32 @is_character(%struct.cell* %33)
  %tobool29 = icmp ne i32 %call28, 0
  br i1 %tobool29, label %if.then.30, label %if.else.35

if.then.30:                                       ; preds = %if.then.27
  %34 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call31 = call i32 @charvalue(%struct.cell* %34)
  %35 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call32 = call i32 @charvalue(%struct.cell* %35)
  %cmp33 = icmp eq i32 %call31, %call32
  %conv34 = zext i1 %cmp33 to i32
  store i32 %conv34, i32* %retval
  br label %return

if.else.35:                                       ; preds = %if.then.27
  store i32 0, i32* %retval
  br label %return

if.else.36:                                       ; preds = %if.else.24
  %36 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call37 = call i32 @is_port(%struct.cell* %36)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then.39, label %if.else.46

if.then.39:                                       ; preds = %if.else.36
  %37 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call40 = call i32 @is_port(%struct.cell* %37)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then.42, label %if.else.45

if.then.42:                                       ; preds = %if.then.39
  %38 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %39 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %cmp43 = icmp eq %struct.cell* %38, %39
  %conv44 = zext i1 %cmp43 to i32
  store i32 %conv44, i32* %retval
  br label %return

if.else.45:                                       ; preds = %if.then.39
  store i32 0, i32* %retval
  br label %return

if.else.46:                                       ; preds = %if.else.36
  %40 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call47 = call i32 @is_proc(%struct.cell* %40)
  %tobool48 = icmp ne i32 %call47, 0
  br i1 %tobool48, label %if.then.49, label %if.else.58

if.then.49:                                       ; preds = %if.else.46
  %41 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call50 = call i32 @is_proc(%struct.cell* %41)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.then.52, label %if.else.57

if.then.52:                                       ; preds = %if.then.49
  %42 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call53 = call i64 @ivalue(%struct.cell* %42)
  %43 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call54 = call i64 @ivalue(%struct.cell* %43)
  %cmp55 = icmp eq i64 %call53, %call54
  %conv56 = zext i1 %cmp55 to i32
  store i32 %conv56, i32* %retval
  br label %return

if.else.57:                                       ; preds = %if.then.49
  store i32 0, i32* %retval
  br label %return

if.else.58:                                       ; preds = %if.else.46
  %44 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %45 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %cmp59 = icmp eq %struct.cell* %44, %45
  %conv60 = zext i1 %cmp59 to i32
  store i32 %conv60, i32* %retval
  br label %return

return:                                           ; preds = %if.else.58, %if.else.57, %if.then.52, %if.else.45, %if.then.42, %if.else.35, %if.then.30, %if.end.23, %if.then.18, %if.else, %if.then.3
  %46 = load i32, i32* %retval
  ret i32 %46
}

; Function Attrs: nounwind uwtable
define internal i32 @num_eq(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca i32, align 4
  %is_fixnum = alloca i32, align 4
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum1, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum2 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum2, align 1
  %conv3 = sext i8 %7 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool4, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, i32* %is_fixnum, align 4
  %9 = load i32, i32* %is_fixnum, align 4
  %tobool5 = icmp ne i32 %9, 0
  br i1 %tobool5, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value6 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue7 = bitcast %union.anon.0* %value6 to i64*
  %11 = load i64, i64* %ivalue7, align 8
  %cmp = icmp eq i64 %10, %11
  %conv8 = zext i1 %cmp to i32
  store i32 %conv8, i32* %ret, align 4
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum9 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum9, align 1
  %tobool10 = icmp ne i8 %12, 0
  br i1 %tobool10, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value11 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value11 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue13 = bitcast %union.anon.0* %value12 to i64*
  %14 = load i64, i64* %ivalue13, align 8
  %conv14 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv14, %cond.false ]
  %is_fixnum15 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum15, align 1
  %tobool16 = icmp ne i8 %15, 0
  br i1 %tobool16, label %cond.false.20, label %cond.true.17

cond.true.17:                                     ; preds = %cond.end
  %value18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue19 = bitcast %union.anon.0* %value18 to double*
  %16 = load double, double* %rvalue19, align 8
  br label %cond.end.24

cond.false.20:                                    ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue22 = bitcast %union.anon.0* %value21 to i64*
  %17 = load i64, i64* %ivalue22, align 8
  %conv23 = sitofp i64 %17 to double
  br label %cond.end.24

cond.end.24:                                      ; preds = %cond.false.20, %cond.true.17
  %cond25 = phi double [ %16, %cond.true.17 ], [ %conv23, %cond.false.20 ]
  %cmp26 = fcmp oeq double %cond, %cond25
  %conv27 = zext i1 %cmp26 to i32
  store i32 %conv27, i32* %ret, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end.24, %if.then
  %18 = load i32, i32* %ret, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define i32 @list_length(%struct.scheme* %sc, %struct.cell* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca %struct.cell*, align 8
  %i = alloca i32, align 4
  %slow = alloca %struct.cell*, align 8
  %fast = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  store i32 0, i32* %i, align 4
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  store %struct.cell* %0, %struct.cell** %fast, align 8
  store %struct.cell* %0, %struct.cell** %slow, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end.21
  %1 = load %struct.cell*, %struct.cell** %fast, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %4 = load i32, i32* %i, align 4
  store i32 %4, i32* %retval
  br label %return

if.end:                                           ; preds = %while.body
  %5 = load %struct.cell*, %struct.cell** %fast, align 8
  %call = call i32 @is_pair(%struct.cell* %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end.2, label %if.then.1

if.then.1:                                        ; preds = %if.end
  %6 = load i32, i32* %i, align 4
  %sub = sub nsw i32 -2, %6
  store i32 %sub, i32* %retval
  br label %return

if.end.2:                                         ; preds = %if.end
  %7 = load %struct.cell*, %struct.cell** %fast, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %8 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %8, %struct.cell** %fast, align 8
  %9 = load i32, i32* %i, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %i, align 4
  %10 = load %struct.cell*, %struct.cell** %fast, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 17
  %12 = load %struct.cell*, %struct.cell** %NIL3, align 8
  %cmp4 = icmp eq %struct.cell* %10, %12
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end.2
  %13 = load i32, i32* %i, align 4
  store i32 %13, i32* %retval
  br label %return

if.end.6:                                         ; preds = %if.end.2
  %14 = load %struct.cell*, %struct.cell** %fast, align 8
  %call7 = call i32 @is_pair(%struct.cell* %14)
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.end.11, label %if.then.9

if.then.9:                                        ; preds = %if.end.6
  %15 = load i32, i32* %i, align 4
  %sub10 = sub nsw i32 -2, %15
  store i32 %sub10, i32* %retval
  br label %return

if.end.11:                                        ; preds = %if.end.6
  %16 = load i32, i32* %i, align 4
  %inc12 = add nsw i32 %16, 1
  store i32 %inc12, i32* %i, align 4
  %17 = load %struct.cell*, %struct.cell** %fast, align 8
  %_object13 = getelementptr inbounds %struct.cell, %struct.cell* %17, i32 0, i32 1
  %_cons14 = bitcast %union.anon* %_object13 to %struct.anon.4*
  %_cdr15 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons14, i32 0, i32 1
  %18 = load %struct.cell*, %struct.cell** %_cdr15, align 8
  store %struct.cell* %18, %struct.cell** %fast, align 8
  %19 = load %struct.cell*, %struct.cell** %slow, align 8
  %_object16 = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_cons17 = bitcast %union.anon* %_object16 to %struct.anon.4*
  %_cdr18 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons17, i32 0, i32 1
  %20 = load %struct.cell*, %struct.cell** %_cdr18, align 8
  store %struct.cell* %20, %struct.cell** %slow, align 8
  %21 = load %struct.cell*, %struct.cell** %fast, align 8
  %22 = load %struct.cell*, %struct.cell** %slow, align 8
  %cmp19 = icmp eq %struct.cell* %21, %22
  br i1 %cmp19, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.end.11
  store i32 -1, i32* %retval
  br label %return

if.end.21:                                        ; preds = %if.end.11
  br label %while.body

return:                                           ; preds = %if.then.20, %if.then.9, %if.then.5, %if.then.1, %if.then
  %23 = load i32, i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define %struct.scheme* @scheme_init_new() #0 {
entry:
  %retval = alloca %struct.scheme*, align 8
  %sc = alloca %struct.scheme*, align 8
  %call = call noalias i8* @malloc(i64 5640) #2
  %0 = bitcast i8* %call to %struct.scheme*
  store %struct.scheme* %0, %struct.scheme** %sc, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc, align 8
  %call1 = call i32 @scheme_init(%struct.scheme* %1)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc, align 8
  %3 = bitcast %struct.scheme* %2 to i8*
  call void @free(i8* %3) #2
  store %struct.scheme* null, %struct.scheme** %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc, align 8
  store %struct.scheme* %4, %struct.scheme** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %5 = load %struct.scheme*, %struct.scheme** %retval
  ret %struct.scheme* %5
}

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) #3

; Function Attrs: nounwind uwtable
define i32 @scheme_init(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @scheme_init_custom_alloc(%struct.scheme* %0, i8* (i64)* @malloc, void (i8*)* @free)
  ret i32 %call
}

; Function Attrs: nounwind
declare void @free(i8*) #3

; Function Attrs: nounwind uwtable
define %struct.scheme* @scheme_init_new_custom_alloc(i8* (i64)* %malloc, void (i8*)* %free) #0 {
entry:
  %retval = alloca %struct.scheme*, align 8
  %malloc.addr = alloca i8* (i64)*, align 8
  %free.addr = alloca void (i8*)*, align 8
  %sc = alloca %struct.scheme*, align 8
  store i8* (i64)* %malloc, i8* (i64)** %malloc.addr, align 8
  store void (i8*)* %free, void (i8*)** %free.addr, align 8
  %0 = load i8* (i64)*, i8* (i64)** %malloc.addr, align 8
  %call = call i8* %0(i64 5640)
  %1 = bitcast i8* %call to %struct.scheme*
  store %struct.scheme* %1, %struct.scheme** %sc, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc, align 8
  %3 = load i8* (i64)*, i8* (i64)** %malloc.addr, align 8
  %4 = load void (i8*)*, void (i8*)** %free.addr, align 8
  %call1 = call i32 @scheme_init_custom_alloc(%struct.scheme* %2, i8* (i64)* %3, void (i8*)* %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %5 = load void (i8*)*, void (i8*)** %free.addr, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc, align 8
  %7 = bitcast %struct.scheme* %6 to i8*
  call void %5(i8* %7)
  store %struct.scheme* null, %struct.scheme** %retval
  br label %return

if.else:                                          ; preds = %entry
  %8 = load %struct.scheme*, %struct.scheme** %sc, align 8
  store %struct.scheme* %8, %struct.scheme** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %9 = load %struct.scheme*, %struct.scheme** %retval
  ret %struct.scheme* %9
}

; Function Attrs: nounwind uwtable
define i32 @scheme_init_custom_alloc(%struct.scheme* %sc, i8* (i64)* %malloc, void (i8*)* %free) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %malloc.addr = alloca i8* (i64)*, align 8
  %free.addr = alloca void (i8*)*, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* (i64)* %malloc, i8* (i64)** %malloc.addr, align 8
  store void (i8*)* %free, void (i8*)** %free.addr, align 8
  store i32 181, i32* %n, align 4
  store i8 1, i8* getelementptr inbounds (%struct.num, %struct.num* @num_zero, i32 0, i32 0), align 1
  store i64 0, i64* getelementptr inbounds (%struct.num, %struct.num* @num_zero, i32 0, i32 1, i32 0), align 8
  store i8 1, i8* getelementptr inbounds (%struct.num, %struct.num* @num_one, i32 0, i32 0), align 1
  store i64 1, i64* getelementptr inbounds (%struct.num, %struct.num* @num_one, i32 0, i32 1, i32 0), align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %vptr = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 58
  store %struct.scheme_interface* bitcast ({ void (%struct.scheme*, %struct.cell*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i64)*, %struct.cell* (%struct.scheme*, double)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*)*, %struct.cell* (%struct.scheme*, i8*)*, %struct.cell* (%struct.scheme*, i8*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, %struct.cell* (%struct.scheme*, %struct.cell*)*)*, %struct.cell* (%struct.scheme*, %struct.cell*, %struct.cell*)*, void (%struct.scheme*, i8*)*, void (%struct.scheme*, i32)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, { i8, i64 } (%struct.cell*)*, i64 (%struct.cell*)*, double (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.scheme*, %struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.scheme*, %struct.cell*)*, i64 (%struct.cell*)*, void (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, i32)*, %struct.cell* (%struct.cell*, i32, %struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, %struct.cell* (%struct.cell*, %struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i8* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, %struct.cell* (%struct.cell*)*, %struct.cell* (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, i32 (%struct.cell*)*, void (%struct.cell*)*, void (%struct.scheme*, %struct._IO_FILE*)*, void (%struct.scheme*, i8*)* }* @vtbl to %struct.scheme_interface*), %struct.scheme_interface** %vptr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gensym_cnt = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 57
  store i64 0, i64* %gensym_cnt, align 8
  %2 = load i8* (i64)*, i8* (i64)** %malloc.addr, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 0
  store i8* (i64)* %2, i8* (i64)** %malloc1, align 8
  %4 = load void (i8*)*, void (i8*)** %free.addr, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free2 = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 1
  store void (i8*)* %4, void (i8*)** %free2, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 6
  store i32 -1, i32* %last_cell_seg, align 4
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_sink = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 14
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 15
  store %struct.cell* %_sink, %struct.cell** %sink, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 16
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  store %struct.cell* %_NIL, %struct.cell** %NIL, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_HASHT = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 18
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 19
  store %struct.cell* %_HASHT, %struct.cell** %T, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_HASHF = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 20
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 21
  store %struct.cell* %_HASHF, %struct.cell** %F, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 22
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 23
  store %struct.cell* %_EOF_OBJ, %struct.cell** %EOF_OBJ, align 8
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %_NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 16
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 37
  store %struct.cell* %_NIL3, %struct.cell** %free_cell, align 8
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 38
  store i64 0, i64* %fcells, align 8
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 48
  store i8 0, i8* %no_memory, align 1
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL4 = getelementptr inbounds %struct.scheme, %struct.scheme* %21, i32 0, i32 17
  %22 = load %struct.cell*, %struct.cell** %NIL4, align 8
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 39
  store %struct.cell* %22, %struct.cell** %inport, align 8
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL5 = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 17
  %25 = load %struct.cell*, %struct.cell** %NIL5, align 8
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 40
  store %struct.cell* %25, %struct.cell** %outport, align 8
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL6 = getelementptr inbounds %struct.scheme, %struct.scheme* %27, i32 0, i32 17
  %28 = load %struct.cell*, %struct.cell** %NIL6, align 8
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport = getelementptr inbounds %struct.scheme, %struct.scheme* %29, i32 0, i32 41
  store %struct.cell* %28, %struct.cell** %save_inport, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL7 = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 17
  %31 = load %struct.cell*, %struct.cell** %NIL7, align 8
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 42
  store %struct.cell* %31, %struct.cell** %loadport, align 8
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 46
  store i32 0, i32* %nesting, align 4
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %34, i32 0, i32 12
  store i32 0, i32* %interactive_repl, align 4
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_output = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 13
  store i32 0, i32* %print_output, align 4
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @alloc_cellseg(%struct.scheme* %36, i32 3)
  %cmp = icmp ne i32 %call, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory8 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 48
  store i8 1, i8* %no_memory8, align 1
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 47
  store i8 0, i8* %gc_verbose, align 1
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_initialize(%struct.scheme* %39)
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL9 = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 17
  %41 = load %struct.cell*, %struct.cell** %NIL9, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 9
  store %struct.cell* %41, %struct.cell** %code, align 8
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing = getelementptr inbounds %struct.scheme, %struct.scheme* %43, i32 0, i32 3
  store i32 0, i32* %tracing, align 4
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %bc_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %44, i32 0, i32 62
  store i32 0, i32* %bc_flag, align 4
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL10 = getelementptr inbounds %struct.scheme, %struct.scheme* %45, i32 0, i32 17
  %46 = load %struct.cell*, %struct.cell** %NIL10, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %46, i32 0, i32 0
  store i32 49152, i32* %_flag, align 4
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL11 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 17
  %48 = load %struct.cell*, %struct.cell** %NIL11, align 8
  %49 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL12 = getelementptr inbounds %struct.scheme, %struct.scheme* %49, i32 0, i32 17
  %50 = load %struct.cell*, %struct.cell** %NIL12, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %50, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  store %struct.cell* %48, %struct.cell** %_cdr, align 8
  %51 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL13 = getelementptr inbounds %struct.scheme, %struct.scheme* %51, i32 0, i32 17
  %52 = load %struct.cell*, %struct.cell** %NIL13, align 8
  %_object14 = getelementptr inbounds %struct.cell, %struct.cell* %52, i32 0, i32 1
  %_cons15 = bitcast %union.anon* %_object14 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons15, i32 0, i32 0
  store %struct.cell* %48, %struct.cell** %_car, align 8
  %53 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T16 = getelementptr inbounds %struct.scheme, %struct.scheme* %53, i32 0, i32 19
  %54 = load %struct.cell*, %struct.cell** %T16, align 8
  %_flag17 = getelementptr inbounds %struct.cell, %struct.cell* %54, i32 0, i32 0
  store i32 49152, i32* %_flag17, align 4
  %55 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T18 = getelementptr inbounds %struct.scheme, %struct.scheme* %55, i32 0, i32 19
  %56 = load %struct.cell*, %struct.cell** %T18, align 8
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T19 = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 19
  %58 = load %struct.cell*, %struct.cell** %T19, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %58, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr22 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  store %struct.cell* %56, %struct.cell** %_cdr22, align 8
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T23 = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 19
  %60 = load %struct.cell*, %struct.cell** %T23, align 8
  %_object24 = getelementptr inbounds %struct.cell, %struct.cell* %60, i32 0, i32 1
  %_cons25 = bitcast %union.anon* %_object24 to %struct.anon.4*
  %_car26 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons25, i32 0, i32 0
  store %struct.cell* %56, %struct.cell** %_car26, align 8
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F27 = getelementptr inbounds %struct.scheme, %struct.scheme* %61, i32 0, i32 21
  %62 = load %struct.cell*, %struct.cell** %F27, align 8
  %_flag28 = getelementptr inbounds %struct.cell, %struct.cell* %62, i32 0, i32 0
  store i32 49152, i32* %_flag28, align 4
  %63 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F29 = getelementptr inbounds %struct.scheme, %struct.scheme* %63, i32 0, i32 21
  %64 = load %struct.cell*, %struct.cell** %F29, align 8
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F30 = getelementptr inbounds %struct.scheme, %struct.scheme* %65, i32 0, i32 21
  %66 = load %struct.cell*, %struct.cell** %F30, align 8
  %_object31 = getelementptr inbounds %struct.cell, %struct.cell* %66, i32 0, i32 1
  %_cons32 = bitcast %union.anon* %_object31 to %struct.anon.4*
  %_cdr33 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons32, i32 0, i32 1
  store %struct.cell* %64, %struct.cell** %_cdr33, align 8
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F34 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 21
  %68 = load %struct.cell*, %struct.cell** %F34, align 8
  %_object35 = getelementptr inbounds %struct.cell, %struct.cell* %68, i32 0, i32 1
  %_cons36 = bitcast %union.anon* %_object35 to %struct.anon.4*
  %_car37 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons36, i32 0, i32 0
  store %struct.cell* %64, %struct.cell** %_car37, align 8
  %69 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink38 = getelementptr inbounds %struct.scheme, %struct.scheme* %69, i32 0, i32 15
  %70 = load %struct.cell*, %struct.cell** %sink38, align 8
  %_flag39 = getelementptr inbounds %struct.cell, %struct.cell* %70, i32 0, i32 0
  store i32 32773, i32* %_flag39, align 4
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL40 = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 17
  %72 = load %struct.cell*, %struct.cell** %NIL40, align 8
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink41 = getelementptr inbounds %struct.scheme, %struct.scheme* %73, i32 0, i32 15
  %74 = load %struct.cell*, %struct.cell** %sink41, align 8
  %_object42 = getelementptr inbounds %struct.cell, %struct.cell* %74, i32 0, i32 1
  %_cons43 = bitcast %union.anon* %_object42 to %struct.anon.4*
  %_car44 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons43, i32 0, i32 0
  store %struct.cell* %72, %struct.cell** %_car44, align 8
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL45 = getelementptr inbounds %struct.scheme, %struct.scheme* %75, i32 0, i32 17
  %76 = load %struct.cell*, %struct.cell** %NIL45, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 26
  store %struct.cell* %76, %struct.cell** %c_nest, align 8
  %78 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call46 = call %struct.cell* @oblist_initial_value(%struct.scheme* %78)
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 24
  store %struct.cell* %call46, %struct.cell** %oblist, align 8
  %80 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL47 = getelementptr inbounds %struct.scheme, %struct.scheme* %81, i32 0, i32 17
  %82 = load %struct.cell*, %struct.cell** %NIL47, align 8
  call void @new_frame_in_env(%struct.scheme* %80, %struct.cell* %82)
  %83 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %83, i32 0, i32 8
  %84 = load %struct.cell*, %struct.cell** %envir, align 8
  %85 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %85, i32 0, i32 25
  store %struct.cell* %84, %struct.cell** %global_env, align 8
  %86 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call48 = call %struct.cell* @mk_symbol(%struct.scheme* %86, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.1, i32 0, i32 0))
  store %struct.cell* %call48, %struct.cell** %x, align 8
  %87 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %88 = load %struct.cell*, %struct.cell** %x, align 8
  %89 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T49 = getelementptr inbounds %struct.scheme, %struct.scheme* %89, i32 0, i32 19
  %90 = load %struct.cell*, %struct.cell** %T49, align 8
  call void @new_slot_in_env(%struct.scheme* %87, %struct.cell* %88, %struct.cell* %90)
  %91 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %91, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))
  %92 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %92, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0))
  %93 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %93, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.4, i32 0, i32 0))
  %94 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %94, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0))
  %95 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %95, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.6, i32 0, i32 0))
  %96 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %96, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.7, i32 0, i32 0))
  %97 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %97, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.8, i32 0, i32 0))
  %98 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %98, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.9, i32 0, i32 0))
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %99, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.10, i32 0, i32 0))
  %100 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %100, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.11, i32 0, i32 0))
  %101 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %101, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12, i32 0, i32 0))
  %102 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %102, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.13, i32 0, i32 0))
  %103 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %103, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %104 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %104, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.15, i32 0, i32 0))
  %105 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %105, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.16, i32 0, i32 0))
  %106 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @assign_syntax(%struct.scheme* %106, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.17, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %107 = load i32, i32* %i, align 4
  %108 = load i32, i32* %n, align 4
  %cmp50 = icmp slt i32 %107, %108
  br i1 %cmp50, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %109 = load i32, i32* %i, align 4
  %idxprom = sext i32 %109 to i64
  %arrayidx = getelementptr inbounds [181 x %struct.op_code_info], [181 x %struct.op_code_info]* @dispatch_table, i32 0, i64 %idxprom
  %name = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %arrayidx, i32 0, i32 1
  %110 = load i8*, i8** %name, align 8
  %cmp51 = icmp ne i8* %110, null
  br i1 %cmp51, label %if.then.52, label %if.end.56

if.then.52:                                       ; preds = %for.body
  %111 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %112 = load i32, i32* %i, align 4
  %113 = load i32, i32* %i, align 4
  %idxprom53 = sext i32 %113 to i64
  %arrayidx54 = getelementptr inbounds [181 x %struct.op_code_info], [181 x %struct.op_code_info]* @dispatch_table, i32 0, i64 %idxprom53
  %name55 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %arrayidx54, i32 0, i32 1
  %114 = load i8*, i8** %name55, align 8
  call void @assign_proc(%struct.scheme* %111, i32 %112, i8* %114)
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.52, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.56
  %115 = load i32, i32* %i, align 4
  %inc = add nsw i32 %115, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %116 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call57 = call %struct.cell* @mk_symbol(%struct.scheme* %116, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))
  %117 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA = getelementptr inbounds %struct.scheme, %struct.scheme* %117, i32 0, i32 27
  store %struct.cell* %call57, %struct.cell** %LAMBDA, align 8
  %118 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call58 = call %struct.cell* @mk_symbol(%struct.scheme* %118, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.3, i32 0, i32 0))
  %119 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %119, i32 0, i32 28
  store %struct.cell* %call58, %struct.cell** %QUOTE, align 8
  %120 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call59 = call %struct.cell* @mk_symbol(%struct.scheme* %120, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.18, i32 0, i32 0))
  %121 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QQUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %121, i32 0, i32 29
  store %struct.cell* %call59, %struct.cell** %QQUOTE, align 8
  %122 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call60 = call %struct.cell* @mk_symbol(%struct.scheme* %122, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.19, i32 0, i32 0))
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %123, i32 0, i32 30
  store %struct.cell* %call60, %struct.cell** %UNQUOTE, align 8
  %124 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call61 = call %struct.cell* @mk_symbol(%struct.scheme* %124, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.20, i32 0, i32 0))
  %125 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTESP = getelementptr inbounds %struct.scheme, %struct.scheme* %125, i32 0, i32 31
  store %struct.cell* %call61, %struct.cell** %UNQUOTESP, align 8
  %126 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call62 = call %struct.cell* @mk_symbol(%struct.scheme* %126, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.21, i32 0, i32 0))
  %127 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %FEED_TO = getelementptr inbounds %struct.scheme, %struct.scheme* %127, i32 0, i32 32
  store %struct.cell* %call62, %struct.cell** %FEED_TO, align 8
  %128 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call63 = call %struct.cell* @mk_symbol(%struct.scheme* %128, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.22, i32 0, i32 0))
  %129 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %COLON_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %129, i32 0, i32 33
  store %struct.cell* %call63, %struct.cell** %COLON_HOOK, align 8
  %130 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call64 = call %struct.cell* @mk_symbol(%struct.scheme* %130, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.23, i32 0, i32 0))
  %131 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %ERROR_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %131, i32 0, i32 34
  store %struct.cell* %call64, %struct.cell** %ERROR_HOOK, align 8
  %132 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call65 = call %struct.cell* @mk_symbol(%struct.scheme* %132, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.24, i32 0, i32 0))
  %133 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %SHARP_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %133, i32 0, i32 35
  store %struct.cell* %call65, %struct.cell** %SHARP_HOOK, align 8
  %134 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call66 = call %struct.cell* @mk_symbol(%struct.scheme* %134, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0))
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %COMPILE_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %135, i32 0, i32 36
  store %struct.cell* %call66, %struct.cell** %COMPILE_HOOK, align 8
  %136 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory67 = getelementptr inbounds %struct.scheme, %struct.scheme* %136, i32 0, i32 48
  %137 = load i8, i8* %no_memory67, align 1
  %tobool = icmp ne i8 %137, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %138 = load i32, i32* %retval
  ret i32 %138
}

; Function Attrs: nounwind uwtable
define internal i32 @alloc_cellseg(%struct.scheme* %sc, i32 %n) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %n.addr = alloca i32, align 4
  %newp = alloca %struct.cell*, align 8
  %last = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  %cp = alloca i8*, align 8
  %i = alloca i64, align 8
  %k = alloca i32, align 4
  %adj = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  store i32 32, i32* %adj, align 4
  %0 = load i32, i32* %adj, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ult i64 %conv, 24
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 24, i32* %adj, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %k, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.92, %if.end
  %1 = load i32, i32* %k, align 4
  %2 = load i32, i32* %n.addr, align 4
  %cmp2 = icmp slt i32 %1, %2
  br i1 %cmp2, label %for.body, label %for.end.94

for.body:                                         ; preds = %for.cond
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 6
  %4 = load i32, i32* %last_cell_seg, align 4
  %cmp4 = icmp sge i32 %4, 49
  br i1 %cmp4, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %for.body
  %5 = load i32, i32* %k, align 4
  store i32 %5, i32* %retval
  br label %return

if.end.7:                                         ; preds = %for.body
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 0
  %7 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %8 = load i32, i32* %adj, align 4
  %conv8 = sext i32 %8 to i64
  %add = add i64 600000, %conv8
  %call = call i8* %7(i64 %add)
  store i8* %call, i8** %cp, align 8
  %9 = load i8*, i8** %cp, align 8
  %cmp9 = icmp eq i8* %9, null
  br i1 %cmp9, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %if.end.7
  %10 = load i32, i32* %k, align 4
  store i32 %10, i32* %retval
  br label %return

if.end.12:                                        ; preds = %if.end.7
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg13 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 6
  %12 = load i32, i32* %last_cell_seg13, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %last_cell_seg13, align 4
  %conv14 = sext i32 %inc to i64
  store i64 %conv14, i64* %i, align 8
  %13 = load i8*, i8** %cp, align 8
  %14 = load i64, i64* %i, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %alloc_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 4
  %arrayidx = getelementptr inbounds [50 x i8*], [50 x i8*]* %alloc_seg, i32 0, i64 %14
  store i8* %13, i8** %arrayidx, align 8
  %16 = load i8*, i8** %cp, align 8
  %17 = ptrtoint i8* %16 to i64
  %18 = load i32, i32* %adj, align 4
  %conv15 = sext i32 %18 to i64
  %rem = urem i64 %17, %conv15
  %cmp16 = icmp ne i64 %rem, 0
  br i1 %cmp16, label %if.then.18, label %if.end.22

if.then.18:                                       ; preds = %if.end.12
  %19 = load i32, i32* %adj, align 4
  %conv19 = sext i32 %19 to i64
  %20 = load i8*, i8** %cp, align 8
  %21 = ptrtoint i8* %20 to i64
  %22 = load i32, i32* %adj, align 4
  %conv20 = sext i32 %22 to i64
  %div = udiv i64 %21, %conv20
  %add21 = add i64 %div, 1
  %mul = mul i64 %conv19, %add21
  %23 = inttoptr i64 %mul to i8*
  store i8* %23, i8** %cp, align 8
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.18, %if.end.12
  %24 = load i8*, i8** %cp, align 8
  %25 = bitcast i8* %24 to %struct.cell*
  store %struct.cell* %25, %struct.cell** %newp, align 8
  %26 = load %struct.cell*, %struct.cell** %newp, align 8
  %27 = load i64, i64* %i, align 8
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 5
  %arrayidx23 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg, i32 0, i64 %27
  store %struct.cell* %26, %struct.cell** %arrayidx23, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.22
  %29 = load i64, i64* %i, align 8
  %cmp24 = icmp sgt i64 %29, 0
  br i1 %cmp24, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %30 = load i64, i64* %i, align 8
  %sub = sub nsw i64 %30, 1
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg26 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 5
  %arrayidx27 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg26, i32 0, i64 %sub
  %32 = load %struct.cell*, %struct.cell** %arrayidx27, align 8
  %33 = load i64, i64* %i, align 8
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg28 = getelementptr inbounds %struct.scheme, %struct.scheme* %34, i32 0, i32 5
  %arrayidx29 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg28, i32 0, i64 %33
  %35 = load %struct.cell*, %struct.cell** %arrayidx29, align 8
  %cmp30 = icmp ugt %struct.cell* %32, %35
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %36 = phi i1 [ false, %while.cond ], [ %cmp30, %land.rhs ]
  br i1 %36, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %37 = load i64, i64* %i, align 8
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg32 = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 5
  %arrayidx33 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg32, i32 0, i64 %37
  %39 = load %struct.cell*, %struct.cell** %arrayidx33, align 8
  store %struct.cell* %39, %struct.cell** %p, align 8
  %40 = load i64, i64* %i, align 8
  %sub34 = sub nsw i64 %40, 1
  %41 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg35 = getelementptr inbounds %struct.scheme, %struct.scheme* %41, i32 0, i32 5
  %arrayidx36 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg35, i32 0, i64 %sub34
  %42 = load %struct.cell*, %struct.cell** %arrayidx36, align 8
  %43 = load i64, i64* %i, align 8
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg37 = getelementptr inbounds %struct.scheme, %struct.scheme* %44, i32 0, i32 5
  %arrayidx38 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg37, i32 0, i64 %43
  store %struct.cell* %42, %struct.cell** %arrayidx38, align 8
  %45 = load %struct.cell*, %struct.cell** %p, align 8
  %46 = load i64, i64* %i, align 8
  %dec = add nsw i64 %46, -1
  store i64 %dec, i64* %i, align 8
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg39 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 5
  %arrayidx40 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg39, i32 0, i64 %dec
  store %struct.cell* %45, %struct.cell** %arrayidx40, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 38
  %49 = load i64, i64* %fcells, align 8
  %add41 = add nsw i64 %49, 25000
  store i64 %add41, i64* %fcells, align 8
  %50 = load %struct.cell*, %struct.cell** %newp, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %50, i64 25000
  %add.ptr42 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 -1
  store %struct.cell* %add.ptr42, %struct.cell** %last, align 8
  %51 = load %struct.cell*, %struct.cell** %newp, align 8
  store %struct.cell* %51, %struct.cell** %p, align 8
  br label %for.cond.43

for.cond.43:                                      ; preds = %for.inc, %while.end
  %52 = load %struct.cell*, %struct.cell** %p, align 8
  %53 = load %struct.cell*, %struct.cell** %last, align 8
  %cmp44 = icmp ule %struct.cell* %52, %53
  br i1 %cmp44, label %for.body.46, label %for.end

for.body.46:                                      ; preds = %for.cond.43
  %54 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %54, i32 0, i32 0
  store i32 0, i32* %_flag, align 4
  %55 = load %struct.cell*, %struct.cell** %p, align 8
  %add.ptr47 = getelementptr inbounds %struct.cell, %struct.cell* %55, i64 1
  %56 = load %struct.cell*, %struct.cell** %p, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %56, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  store %struct.cell* %add.ptr47, %struct.cell** %_cdr, align 8
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 17
  %58 = load %struct.cell*, %struct.cell** %NIL, align 8
  %59 = load %struct.cell*, %struct.cell** %p, align 8
  %_object48 = getelementptr inbounds %struct.cell, %struct.cell* %59, i32 0, i32 1
  %_cons49 = bitcast %union.anon* %_object48 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons49, i32 0, i32 0
  store %struct.cell* %58, %struct.cell** %_car, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body.46
  %60 = load %struct.cell*, %struct.cell** %p, align 8
  %incdec.ptr = getelementptr inbounds %struct.cell, %struct.cell* %60, i32 1
  store %struct.cell* %incdec.ptr, %struct.cell** %p, align 8
  br label %for.cond.43

for.end:                                          ; preds = %for.cond.43
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %61, i32 0, i32 37
  %62 = load %struct.cell*, %struct.cell** %free_cell, align 8
  %63 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL50 = getelementptr inbounds %struct.scheme, %struct.scheme* %63, i32 0, i32 17
  %64 = load %struct.cell*, %struct.cell** %NIL50, align 8
  %cmp51 = icmp eq %struct.cell* %62, %64
  br i1 %cmp51, label %if.then.56, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.end
  %65 = load %struct.cell*, %struct.cell** %p, align 8
  %66 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell53 = getelementptr inbounds %struct.scheme, %struct.scheme* %66, i32 0, i32 37
  %67 = load %struct.cell*, %struct.cell** %free_cell53, align 8
  %cmp54 = icmp ult %struct.cell* %65, %67
  br i1 %cmp54, label %if.then.56, label %if.else

if.then.56:                                       ; preds = %lor.lhs.false, %for.end
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell57 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 37
  %69 = load %struct.cell*, %struct.cell** %free_cell57, align 8
  %70 = load %struct.cell*, %struct.cell** %last, align 8
  %_object58 = getelementptr inbounds %struct.cell, %struct.cell* %70, i32 0, i32 1
  %_cons59 = bitcast %union.anon* %_object58 to %struct.anon.4*
  %_cdr60 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons59, i32 0, i32 1
  store %struct.cell* %69, %struct.cell** %_cdr60, align 8
  %71 = load %struct.cell*, %struct.cell** %newp, align 8
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell61 = getelementptr inbounds %struct.scheme, %struct.scheme* %72, i32 0, i32 37
  store %struct.cell* %71, %struct.cell** %free_cell61, align 8
  br label %if.end.91

if.else:                                          ; preds = %lor.lhs.false
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell62 = getelementptr inbounds %struct.scheme, %struct.scheme* %73, i32 0, i32 37
  %74 = load %struct.cell*, %struct.cell** %free_cell62, align 8
  store %struct.cell* %74, %struct.cell** %p, align 8
  br label %while.cond.63

while.cond.63:                                    ; preds = %while.body.77, %if.else
  %75 = load %struct.cell*, %struct.cell** %p, align 8
  %_object64 = getelementptr inbounds %struct.cell, %struct.cell* %75, i32 0, i32 1
  %_cons65 = bitcast %union.anon* %_object64 to %struct.anon.4*
  %_cdr66 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons65, i32 0, i32 1
  %76 = load %struct.cell*, %struct.cell** %_cdr66, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL67 = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 17
  %78 = load %struct.cell*, %struct.cell** %NIL67, align 8
  %cmp68 = icmp ne %struct.cell* %76, %78
  br i1 %cmp68, label %land.rhs.70, label %land.end.76

land.rhs.70:                                      ; preds = %while.cond.63
  %79 = load %struct.cell*, %struct.cell** %newp, align 8
  %80 = load %struct.cell*, %struct.cell** %p, align 8
  %_object71 = getelementptr inbounds %struct.cell, %struct.cell* %80, i32 0, i32 1
  %_cons72 = bitcast %union.anon* %_object71 to %struct.anon.4*
  %_cdr73 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons72, i32 0, i32 1
  %81 = load %struct.cell*, %struct.cell** %_cdr73, align 8
  %cmp74 = icmp ugt %struct.cell* %79, %81
  br label %land.end.76

land.end.76:                                      ; preds = %land.rhs.70, %while.cond.63
  %82 = phi i1 [ false, %while.cond.63 ], [ %cmp74, %land.rhs.70 ]
  br i1 %82, label %while.body.77, label %while.end.81

while.body.77:                                    ; preds = %land.end.76
  %83 = load %struct.cell*, %struct.cell** %p, align 8
  %_object78 = getelementptr inbounds %struct.cell, %struct.cell* %83, i32 0, i32 1
  %_cons79 = bitcast %union.anon* %_object78 to %struct.anon.4*
  %_cdr80 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons79, i32 0, i32 1
  %84 = load %struct.cell*, %struct.cell** %_cdr80, align 8
  store %struct.cell* %84, %struct.cell** %p, align 8
  br label %while.cond.63

while.end.81:                                     ; preds = %land.end.76
  %85 = load %struct.cell*, %struct.cell** %p, align 8
  %_object82 = getelementptr inbounds %struct.cell, %struct.cell* %85, i32 0, i32 1
  %_cons83 = bitcast %union.anon* %_object82 to %struct.anon.4*
  %_cdr84 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons83, i32 0, i32 1
  %86 = load %struct.cell*, %struct.cell** %_cdr84, align 8
  %87 = load %struct.cell*, %struct.cell** %last, align 8
  %_object85 = getelementptr inbounds %struct.cell, %struct.cell* %87, i32 0, i32 1
  %_cons86 = bitcast %union.anon* %_object85 to %struct.anon.4*
  %_cdr87 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons86, i32 0, i32 1
  store %struct.cell* %86, %struct.cell** %_cdr87, align 8
  %88 = load %struct.cell*, %struct.cell** %newp, align 8
  %89 = load %struct.cell*, %struct.cell** %p, align 8
  %_object88 = getelementptr inbounds %struct.cell, %struct.cell* %89, i32 0, i32 1
  %_cons89 = bitcast %union.anon* %_object88 to %struct.anon.4*
  %_cdr90 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons89, i32 0, i32 1
  store %struct.cell* %88, %struct.cell** %_cdr90, align 8
  br label %if.end.91

if.end.91:                                        ; preds = %while.end.81, %if.then.56
  br label %for.inc.92

for.inc.92:                                       ; preds = %if.end.91
  %90 = load i32, i32* %k, align 4
  %inc93 = add nsw i32 %90, 1
  store i32 %inc93, i32* %k, align 4
  br label %for.cond

for.end.94:                                       ; preds = %for.cond
  %91 = load i32, i32* %n.addr, align 4
  store i32 %91, i32* %retval
  br label %return

return:                                           ; preds = %for.end.94, %if.then.11, %if.then.6
  %92 = load i32, i32* %retval
  ret i32 %92
}

; Function Attrs: nounwind uwtable
define internal void @dump_stack_initialize(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_reset(%struct.scheme* %0)
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @oblist_initial_value(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call %struct.cell* @mk_vector(%struct.scheme* %0, i32 461)
  ret %struct.cell* %call
}

; Function Attrs: nounwind uwtable
define internal void @new_frame_in_env(%struct.scheme* %sc, %struct.cell* %old_env) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %old_env.addr = alloca %struct.cell*, align 8
  %new_frame = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %old_env, %struct.cell** %old_env.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %old_env.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %0, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call %struct.cell* @mk_vector(%struct.scheme* %3, i32 461)
  store %struct.cell* %call, %struct.cell** %new_frame, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL1, align 8
  store %struct.cell* %5, %struct.cell** %new_frame, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %new_frame, align 8
  %8 = load %struct.cell*, %struct.cell** %old_env.addr, align 8
  %call2 = call %struct.cell* @_cons(%struct.scheme* %6, %struct.cell* %7, %struct.cell* %8, i32 1)
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 8
  store %struct.cell* %call2, %struct.cell** %envir, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir3 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 8
  %11 = load %struct.cell*, %struct.cell** %envir3, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %11, i32 0, i32 0
  store i32 14, i32* %_flag, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @new_slot_in_env(%struct.scheme* %sc, %struct.cell* %variable, %struct.cell* %value) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %variable.addr = alloca %struct.cell*, align 8
  %value.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %variable, %struct.cell** %variable.addr, align 8
  store %struct.cell* %value, %struct.cell** %value.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 8
  %2 = load %struct.cell*, %struct.cell** %envir, align 8
  %3 = load %struct.cell*, %struct.cell** %variable.addr, align 8
  %4 = load %struct.cell*, %struct.cell** %value.addr, align 8
  call void @new_slot_spec_in_env(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %3, %struct.cell* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @assign_syntax(%struct.scheme* %sc, i8* %name) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %name.addr = alloca i8*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %name.addr, align 8
  %call = call %struct.cell* @oblist_add_by_name(%struct.scheme* %0, i8* %1)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %2 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 0
  %3 = load i32, i32* %_flag, align 4
  %or = or i32 %3, 4096
  store i32 %or, i32* %_flag, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @assign_proc(%struct.scheme* %sc, i32 %op, i8* %name) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %name.addr = alloca i8*, align 8
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store i8* %name, i8** %name.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %name.addr, align 8
  %call = call %struct.cell* @mk_symbol(%struct.scheme* %0, i8* %1)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %3 = load i32, i32* %op.addr, align 4
  %call1 = call %struct.cell* @mk_proc(%struct.scheme* %2, i32 %3)
  store %struct.cell* %call1, %struct.cell** %y, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %6 = load %struct.cell*, %struct.cell** %y, align 8
  call void @new_slot_in_env(%struct.scheme* %4, %struct.cell* %5, %struct.cell* %6)
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_set_input_port_file(%struct.scheme* %sc, %struct._IO_FILE* %fin) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %fin.addr = alloca %struct._IO_FILE*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %fin, %struct._IO_FILE** %fin.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** %fin.addr, align 8
  %call = call %struct.cell* @port_from_file(%struct.scheme* %0, %struct._IO_FILE* %1, i32 16)
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 39
  store %struct.cell* %call, %struct.cell** %inport, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @port_from_file(%struct.scheme* %sc, %struct._IO_FILE* %f, i32 %prop) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %prop.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** %f.addr, align 8
  %2 = load i32, i32* %prop.addr, align 4
  %call = call %struct.port* @port_rep_from_file(%struct.scheme* %0, %struct._IO_FILE* %1, i32 %2)
  store %struct.port* %call, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %call1 = call %struct.cell* @mk_port(%struct.scheme* %6, %struct.port* %7)
  store %struct.cell* %call1, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define void @scheme_set_input_port_string(%struct.scheme* %sc, i8* %start, i8* %past_the_end) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %start.addr = alloca i8*, align 8
  %past_the_end.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %past_the_end, i8** %past_the_end.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %start.addr, align 8
  %2 = load i8*, i8** %past_the_end.addr, align 8
  %call = call %struct.cell* @port_from_string(%struct.scheme* %0, i8* %1, i8* %2, i32 16)
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 39
  store %struct.cell* %call, %struct.cell** %inport, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @port_from_string(%struct.scheme* %sc, i8* %start, i8* %past_the_end, i32 %prop) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %start.addr = alloca i8*, align 8
  %past_the_end.addr = alloca i8*, align 8
  %prop.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %past_the_end, i8** %past_the_end.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %start.addr, align 8
  %2 = load i8*, i8** %past_the_end.addr, align 8
  %3 = load i32, i32* %prop.addr, align 4
  %call = call %struct.port* @port_rep_from_string(%struct.scheme* %0, i8* %1, i8* %2, i32 %3)
  store %struct.port* %call, %struct.port** %pt, align 8
  %4 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %4, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 17
  %6 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %6, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %8 = load %struct.port*, %struct.port** %pt, align 8
  %call1 = call %struct.cell* @mk_port(%struct.scheme* %7, %struct.port* %8)
  store %struct.cell* %call1, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define void @scheme_set_output_port_file(%struct.scheme* %sc, %struct._IO_FILE* %fout) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %fout.addr = alloca %struct._IO_FILE*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %fout, %struct._IO_FILE** %fout.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** %fout.addr, align 8
  %call = call %struct.cell* @port_from_file(%struct.scheme* %0, %struct._IO_FILE* %1, i32 32)
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 40
  store %struct.cell* %call, %struct.cell** %outport, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_set_output_port_string(%struct.scheme* %sc, i8* %start, i8* %past_the_end) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %start.addr = alloca i8*, align 8
  %past_the_end.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %past_the_end, i8** %past_the_end.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %start.addr, align 8
  %2 = load i8*, i8** %past_the_end.addr, align 8
  %call = call %struct.cell* @port_from_string(%struct.scheme* %0, i8* %1, i8* %2, i32 32)
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 40
  store %struct.cell* %call, %struct.cell** %outport, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_set_external_data(%struct.scheme* %sc, i8* %p) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %ext_data = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 56
  store i8* %0, i8** %ext_data, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_deinit(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %i = alloca i32, align 4
  %fname = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 24
  store %struct.cell* %1, %struct.cell** %oblist, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 25
  store %struct.cell* %4, %struct.cell** %global_env, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_free(%struct.scheme* %6)
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL2 = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 17
  %8 = load %struct.cell*, %struct.cell** %NIL2, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 8
  store %struct.cell* %8, %struct.cell** %envir, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  %11 = load %struct.cell*, %struct.cell** %NIL3, align 8
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 9
  store %struct.cell* %11, %struct.cell** %code, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL4 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 17
  %14 = load %struct.cell*, %struct.cell** %NIL4, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 7
  store %struct.cell* %14, %struct.cell** %args, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL5 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 17
  %17 = load %struct.cell*, %struct.cell** %NIL5, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 54
  store %struct.cell* %17, %struct.cell** %value, align 8
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 39
  %20 = load %struct.cell*, %struct.cell** %inport, align 8
  %call = call i32 @is_port(%struct.cell* %20)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport6 = getelementptr inbounds %struct.scheme, %struct.scheme* %21, i32 0, i32 39
  %22 = load %struct.cell*, %struct.cell** %inport6, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %22, i32 0, i32 0
  store i32 16384, i32* %_flag, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL7 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 17
  %24 = load %struct.cell*, %struct.cell** %NIL7, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport8 = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 39
  store %struct.cell* %24, %struct.cell** %inport8, align 8
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL9 = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 17
  %27 = load %struct.cell*, %struct.cell** %NIL9, align 8
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 40
  store %struct.cell* %27, %struct.cell** %outport, align 8
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport = getelementptr inbounds %struct.scheme, %struct.scheme* %29, i32 0, i32 41
  %30 = load %struct.cell*, %struct.cell** %save_inport, align 8
  %call10 = call i32 @is_port(%struct.cell* %30)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then.12, label %if.end.15

if.then.12:                                       ; preds = %if.end
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport13 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 41
  %32 = load %struct.cell*, %struct.cell** %save_inport13, align 8
  %_flag14 = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 0
  store i32 16384, i32* %_flag14, align 4
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.12, %if.end
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL16 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 17
  %34 = load %struct.cell*, %struct.cell** %NIL16, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport17 = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 41
  store %struct.cell* %34, %struct.cell** %save_inport17, align 8
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %36, i32 0, i32 42
  %37 = load %struct.cell*, %struct.cell** %loadport, align 8
  %call18 = call i32 @is_port(%struct.cell* %37)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %if.end.15
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport21 = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 42
  %39 = load %struct.cell*, %struct.cell** %loadport21, align 8
  %_flag22 = getelementptr inbounds %struct.cell, %struct.cell* %39, i32 0, i32 0
  store i32 16384, i32* %_flag22, align 4
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %if.end.15
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL24 = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 17
  %41 = load %struct.cell*, %struct.cell** %NIL24, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport25 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 42
  store %struct.cell* %41, %struct.cell** %loadport25, align 8
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose = getelementptr inbounds %struct.scheme, %struct.scheme* %43, i32 0, i32 47
  store i8 0, i8* %gc_verbose, align 1
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL26 = getelementptr inbounds %struct.scheme, %struct.scheme* %45, i32 0, i32 17
  %46 = load %struct.cell*, %struct.cell** %NIL26, align 8
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL27 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 17
  %48 = load %struct.cell*, %struct.cell** %NIL27, align 8
  call void @gc(%struct.scheme* %44, %struct.cell* %46, %struct.cell* %48)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.23
  %49 = load i32, i32* %i, align 4
  %50 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %50, i32 0, i32 6
  %51 = load i32, i32* %last_cell_seg, align 4
  %cmp = icmp sle i32 %49, %51
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 1
  %53 = load void (i8*)*, void (i8*)** %free, align 8
  %54 = load i32, i32* %i, align 4
  %idxprom = sext i32 %54 to i64
  %55 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %alloc_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %55, i32 0, i32 4
  %arrayidx = getelementptr inbounds [50 x i8*], [50 x i8*]* %alloc_seg, i32 0, i64 %idxprom
  %56 = load i8*, i8** %arrayidx, align 8
  call void %53(i8* %56)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %57 = load i32, i32* %i, align 4
  %inc = add nsw i32 %57, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %58 = load i32, i32* %i, align 4
  %idxprom28 = sext i32 %58 to i64
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 43
  %arrayidx29 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom28
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx29, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %filename = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 3
  %60 = load i8*, i8** %filename, align 8
  store i8* %60, i8** %fname, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.30

for.cond.30:                                      ; preds = %for.inc.37, %for.end
  %61 = load i32, i32* %i, align 4
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 45
  %63 = load i32, i32* %file_i, align 4
  %cmp31 = icmp slt i32 %61, %63
  br i1 %cmp31, label %for.body.32, label %for.end.39

for.body.32:                                      ; preds = %for.cond.30
  %64 = load i8*, i8** %fname, align 8
  %tobool33 = icmp ne i8* %64, null
  br i1 %tobool33, label %if.then.34, label %if.end.36

if.then.34:                                       ; preds = %for.body.32
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free35 = getelementptr inbounds %struct.scheme, %struct.scheme* %65, i32 0, i32 1
  %66 = load void (i8*)*, void (i8*)** %free35, align 8
  %67 = load i8*, i8** %fname, align 8
  call void %66(i8* %67)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.34, %for.body.32
  br label %for.inc.37

for.inc.37:                                       ; preds = %if.end.36
  %68 = load i32, i32* %i, align 4
  %inc38 = add nsw i32 %68, 1
  store i32 %inc38, i32* %i, align 4
  br label %for.cond.30

for.end.39:                                       ; preds = %for.cond.30
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @dump_stack_free(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 10
  store %struct.cell* %1, %struct.cell** %dump, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gc(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  %i = alloca i32, align 4
  %msg = alloca [80 x i8], align 16
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 47
  %1 = load i8, i8* %gc_verbose, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.275, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 24
  %4 = load %struct.cell*, %struct.cell** %oblist, align 8
  call void @mark(%struct.cell* %4)
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 25
  %6 = load %struct.cell*, %struct.cell** %global_env, align 8
  call void @mark(%struct.cell* %6)
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 7
  %8 = load %struct.cell*, %struct.cell** %args, align 8
  call void @mark(%struct.cell* %8)
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 8
  %10 = load %struct.cell*, %struct.cell** %envir, align 8
  call void @mark(%struct.cell* %10)
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 9
  %12 = load %struct.cell*, %struct.cell** %code, align 8
  call void @mark(%struct.cell* %12)
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_mark(%struct.scheme* %13)
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 54
  %15 = load %struct.cell*, %struct.cell** %value, align 8
  call void @mark(%struct.cell* %15)
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 39
  %17 = load %struct.cell*, %struct.cell** %inport, align 8
  call void @mark(%struct.cell* %17)
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 41
  %19 = load %struct.cell*, %struct.cell** %save_inport, align 8
  call void @mark(%struct.cell* %19)
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 40
  %21 = load %struct.cell*, %struct.cell** %outport, align 8
  call void @mark(%struct.cell* %21)
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 42
  %23 = load %struct.cell*, %struct.cell** %loadport, align 8
  call void @mark(%struct.cell* %23)
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 15
  %25 = load %struct.cell*, %struct.cell** %sink, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %25, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %26 = load %struct.cell*, %struct.cell** %_car, align 8
  call void @mark(%struct.cell* %26)
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest = getelementptr inbounds %struct.scheme, %struct.scheme* %27, i32 0, i32 26
  %28 = load %struct.cell*, %struct.cell** %c_nest, align 8
  call void @mark(%struct.cell* %28)
  %29 = load %struct.cell*, %struct.cell** %a.addr, align 8
  call void @mark(%struct.cell* %29)
  %30 = load %struct.cell*, %struct.cell** %b.addr, align 8
  call void @mark(%struct.cell* %30)
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 17
  %32 = load %struct.cell*, %struct.cell** %NIL, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 0
  %33 = load i32, i32* %_flag, align 4
  %and = and i32 %33, 32767
  store i32 %and, i32* %_flag, align 4
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %34, i32 0, i32 38
  store i64 0, i64* %fcells, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 17
  %36 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 37
  store %struct.cell* %36, %struct.cell** %free_cell, align 8
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 6
  %39 = load i32, i32* %last_cell_seg, align 4
  store i32 %39, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %40 = load i32, i32* %i, align 4
  %cmp = icmp sge i32 %40, 0
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %41 = load i32, i32* %i, align 4
  %idxprom = sext i32 %41 to i64
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 5
  %arrayidx = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg, i32 0, i64 %idxprom
  %43 = load %struct.cell*, %struct.cell** %arrayidx, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %43, i64 25000
  store %struct.cell* %add.ptr, %struct.cell** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.26, %for.body
  %44 = load %struct.cell*, %struct.cell** %p, align 8
  %incdec.ptr = getelementptr inbounds %struct.cell, %struct.cell* %44, i32 -1
  store %struct.cell* %incdec.ptr, %struct.cell** %p, align 8
  %45 = load i32, i32* %i, align 4
  %idxprom2 = sext i32 %45 to i64
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %cell_seg3 = getelementptr inbounds %struct.scheme, %struct.scheme* %46, i32 0, i32 5
  %arrayidx4 = getelementptr inbounds [50 x %struct.cell*], [50 x %struct.cell*]* %cell_seg3, i32 0, i64 %idxprom2
  %47 = load %struct.cell*, %struct.cell** %arrayidx4, align 8
  %cmp5 = icmp uge %struct.cell* %incdec.ptr, %47
  br i1 %cmp5, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %48 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag6 = getelementptr inbounds %struct.cell, %struct.cell* %48, i32 0, i32 0
  %49 = load i32, i32* %_flag6, align 4
  %and7 = and i32 %49, 32768
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %while.body
  %50 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag10 = getelementptr inbounds %struct.cell, %struct.cell* %50, i32 0, i32 0
  %51 = load i32, i32* %_flag10, align 4
  %and11 = and i32 %51, 32767
  store i32 %and11, i32* %_flag10, align 4
  br label %if.end.26

if.else:                                          ; preds = %while.body
  %52 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag12 = getelementptr inbounds %struct.cell, %struct.cell* %52, i32 0, i32 0
  %53 = load i32, i32* %_flag12, align 4
  %cmp13 = icmp ne i32 %53, 0
  br i1 %cmp13, label %if.then.14, label %if.end.20

if.then.14:                                       ; preds = %if.else
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %55 = load %struct.cell*, %struct.cell** %p, align 8
  call void @finalize_cell(%struct.scheme* %54, %struct.cell* %55)
  %56 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag15 = getelementptr inbounds %struct.cell, %struct.cell* %56, i32 0, i32 0
  store i32 0, i32* %_flag15, align 4
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL16 = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 17
  %58 = load %struct.cell*, %struct.cell** %NIL16, align 8
  %59 = load %struct.cell*, %struct.cell** %p, align 8
  %_object17 = getelementptr inbounds %struct.cell, %struct.cell* %59, i32 0, i32 1
  %_cons18 = bitcast %union.anon* %_object17 to %struct.anon.4*
  %_car19 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons18, i32 0, i32 0
  store %struct.cell* %58, %struct.cell** %_car19, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.14, %if.else
  %60 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells21 = getelementptr inbounds %struct.scheme, %struct.scheme* %60, i32 0, i32 38
  %61 = load i64, i64* %fcells21, align 8
  %inc = add nsw i64 %61, 1
  store i64 %inc, i64* %fcells21, align 8
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell22 = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 37
  %63 = load %struct.cell*, %struct.cell** %free_cell22, align 8
  %64 = load %struct.cell*, %struct.cell** %p, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %64, i32 0, i32 1
  %_cons24 = bitcast %union.anon* %_object23 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons24, i32 0, i32 1
  store %struct.cell* %63, %struct.cell** %_cdr, align 8
  %65 = load %struct.cell*, %struct.cell** %p, align 8
  %66 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell25 = getelementptr inbounds %struct.scheme, %struct.scheme* %66, i32 0, i32 37
  store %struct.cell* %65, %struct.cell** %free_cell25, align 8
  br label %if.end.26

if.end.26:                                        ; preds = %if.end.20, %if.then.9
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %for.inc

for.inc:                                          ; preds = %while.end
  %67 = load i32, i32* %i, align 4
  %dec = add nsw i32 %67, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose27 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 47
  %69 = load i8, i8* %gc_verbose27, align 1
  %tobool28 = icmp ne i8 %69, 0
  br i1 %tobool28, label %if.then.29, label %if.end.32

if.then.29:                                       ; preds = %for.end
  %arraydecay = getelementptr inbounds [80 x i8], [80 x i8]* %msg, i32 0, i32 0
  %70 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells30 = getelementptr inbounds %struct.scheme, %struct.scheme* %70, i32 0, i32 38
  %71 = load i64, i64* %fcells30, align 8
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 80, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.276, i32 0, i32 0), i64 %71) #2
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %arraydecay31 = getelementptr inbounds [80 x i8], [80 x i8]* %msg, i32 0, i32 0
  call void @putstr(%struct.scheme* %72, i8* %arraydecay31)
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.29, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_load_file(%struct.scheme* %sc, %struct._IO_FILE* %fin) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %fin.addr = alloca %struct._IO_FILE*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %fin, %struct._IO_FILE** %fin.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct._IO_FILE*, %struct._IO_FILE** %fin.addr, align 8
  call void @scheme_load_named_file(%struct.scheme* %0, %struct._IO_FILE* %1, i8* null)
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_load_named_file(%struct.scheme* %sc, %struct._IO_FILE* %fin, i8* %filename) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %fin.addr = alloca %struct._IO_FILE*, align 8
  %filename.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %fin, %struct._IO_FILE** %fin.addr, align 8
  store i8* %filename, i8** %filename.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_reset(%struct.scheme* %0)
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 25
  %2 = load %struct.cell*, %struct.cell** %global_env, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 8
  store %struct.cell* %2, %struct.cell** %envir, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 45
  store i32 0, i32* %file_i, align 4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 0
  %kind = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 0
  store i8 17, i8* %kind, align 1
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** %fin.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack1 = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 43
  %arrayidx2 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack1, i32 0, i64 0
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx2, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  store %struct._IO_FILE* %6, %struct._IO_FILE** %file, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack3 = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 43
  %arraydecay = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack3, i32 0, i32 0
  %call = call %struct.cell* @mk_port(%struct.scheme* %8, %struct.port* %arraydecay)
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 42
  store %struct.cell* %call, %struct.cell** %loadport, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 2
  store i32 0, i32* %retcode, align 4
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** %fin.addr, align 8
  %13 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
  %cmp = icmp eq %struct._IO_FILE* %12, %13
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 12
  store i32 1, i32* %interactive_repl, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack4 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 43
  %arrayidx5 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack4, i32 0, i64 0
  %rep6 = getelementptr inbounds %struct.port, %struct.port* %arrayidx5, i32 0, i32 1
  %stdio7 = bitcast %union.anon.1* %rep6 to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio7, i32 0, i32 2
  store i32 0, i32* %curr_line, align 4
  %16 = load %struct._IO_FILE*, %struct._IO_FILE** %fin.addr, align 8
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
  %cmp8 = icmp ne %struct._IO_FILE* %16, %17
  br i1 %cmp8, label %land.lhs.true, label %if.end.17

land.lhs.true:                                    ; preds = %if.end
  %18 = load i8*, i8** %filename.addr, align 8
  %tobool = icmp ne i8* %18, null
  br i1 %tobool, label %if.then.9, label %if.end.17

if.then.9:                                        ; preds = %land.lhs.true
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %20 = load i8*, i8** %filename.addr, align 8
  %call10 = call i64 @strlen(i8* %20) #6
  %conv = trunc i64 %call10 to i32
  %21 = load i8*, i8** %filename.addr, align 8
  %call11 = call i8* @store_string(%struct.scheme* %19, i32 %conv, i8* %21, i32 0)
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack12 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 43
  %arrayidx13 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack12, i32 0, i64 0
  %rep14 = getelementptr inbounds %struct.port, %struct.port* %arrayidx13, i32 0, i32 1
  %stdio15 = bitcast %union.anon.1* %rep14 to %struct.anon.2*
  %filename16 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio15, i32 0, i32 3
  store i8* %call11, i8** %filename16, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.9, %land.lhs.true, %if.end
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport18 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 42
  %24 = load %struct.cell*, %struct.cell** %loadport18, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 39
  store %struct.cell* %24, %struct.cell** %inport, align 8
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i19 = getelementptr inbounds %struct.scheme, %struct.scheme* %27, i32 0, i32 45
  %28 = load i32, i32* %file_i19, align 4
  %conv20 = sext i32 %28 to i64
  %call21 = call %struct.cell* @mk_integer(%struct.scheme* %26, i64 %conv20)
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %29, i32 0, i32 7
  store %struct.cell* %call21, %struct.cell** %args, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @Eval_Cycle(%struct.scheme* %30, i32 1)
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport22 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 42
  %32 = load %struct.cell*, %struct.cell** %loadport22, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 0
  store i32 16384, i32* %_flag, align 4
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode23 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 2
  %34 = load i32, i32* %retcode23, align 4
  %cmp24 = icmp eq i32 %34, 0
  br i1 %cmp24, label %if.then.26, label %if.end.30

if.then.26:                                       ; preds = %if.end.17
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 46
  %36 = load i32, i32* %nesting, align 4
  %cmp27 = icmp ne i32 %36, 0
  %conv28 = zext i1 %cmp27 to i32
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode29 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 2
  store i32 %conv28, i32* %retcode29, align 4
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.26, %if.end.17
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @dump_stack_reset(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 10
  store %struct.cell* %1, %struct.cell** %dump, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_port(%struct.scheme* %sc, %struct.port* %p) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca %struct.port*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.port* %p, %struct.port** %p.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16394, i32* %_flag, align 4
  %6 = load %struct.port*, %struct.port** %p.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  store %struct.port* %6, %struct.port** %_port, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define internal void @Eval_Cycle(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %pcd = alloca %struct.op_code_info*, align 8
  %msg = alloca [1024 x i8], align 16
  %ok = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %t = alloca i8*, align 8
  %arglist = alloca %struct.cell*, align 8
  %arg = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1 = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 55
  store i32 %0, i32* %op1, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end.90, %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op2 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 55
  %3 = load i32, i32* %op2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* getelementptr inbounds ([181 x %struct.op_code_info], [181 x %struct.op_code_info]* @dispatch_table, i32 0, i32 0), i64 %idx.ext
  store %struct.op_code_info* %add.ptr, %struct.op_code_info** %pcd, align 8
  %4 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %name = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %4, i32 0, i32 1
  %5 = load i8*, i8** %name, align 8
  %cmp = icmp ne i8* %5, null
  br i1 %cmp, label %if.then, label %if.end.79

if.then:                                          ; preds = %for.cond
  store i32 1, i32* %ok, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 7
  %8 = load %struct.cell*, %struct.cell** %args, align 8
  %call = call i32 @list_length(%struct.scheme* %6, %struct.cell* %8)
  store i32 %call, i32* %n, align 4
  %9 = load i32, i32* %n, align 4
  %10 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %min_arity = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %10, i32 0, i32 2
  %11 = load i32, i32* %min_arity, align 4
  %cmp3 = icmp slt i32 %9, %11
  br i1 %cmp3, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.then
  store i32 0, i32* %ok, align 4
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %msg, i32 0, i32 0
  %12 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %name5 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %12, i32 0, i32 1
  %13 = load i8*, i8** %name5, align 8
  %14 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %min_arity6 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %14, i32 0, i32 2
  %15 = load i32, i32* %min_arity6, align 4
  %16 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %max_arity = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %16, i32 0, i32 3
  %17 = load i32, i32* %max_arity, align 4
  %cmp7 = icmp eq i32 %15, %17
  %cond = select i1 %cmp7, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.278, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.279, i32 0, i32 0)
  %18 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %min_arity8 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %18, i32 0, i32 2
  %19 = load i32, i32* %min_arity8, align 4
  %call9 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.277, i32 0, i32 0), i8* %13, i8* %cond, i32 %19) #2
  br label %if.end

if.end:                                           ; preds = %if.then.4, %if.then
  %20 = load i32, i32* %ok, align 4
  %tobool = icmp ne i32 %20, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %if.end
  %21 = load i32, i32* %n, align 4
  %22 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %max_arity10 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %22, i32 0, i32 3
  %23 = load i32, i32* %max_arity10, align 4
  %cmp11 = icmp sgt i32 %21, %23
  br i1 %cmp11, label %if.then.12, label %if.end.21

if.then.12:                                       ; preds = %land.lhs.true
  store i32 0, i32* %ok, align 4
  %arraydecay13 = getelementptr inbounds [1024 x i8], [1024 x i8]* %msg, i32 0, i32 0
  %24 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %name14 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %24, i32 0, i32 1
  %25 = load i8*, i8** %name14, align 8
  %26 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %min_arity15 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %26, i32 0, i32 2
  %27 = load i32, i32* %min_arity15, align 4
  %28 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %max_arity16 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %28, i32 0, i32 3
  %29 = load i32, i32* %max_arity16, align 4
  %cmp17 = icmp eq i32 %27, %29
  %cond18 = select i1 %cmp17, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.278, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.280, i32 0, i32 0)
  %30 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %max_arity19 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %30, i32 0, i32 3
  %31 = load i32, i32* %max_arity19, align 4
  %call20 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay13, i64 1024, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.277, i32 0, i32 0), i8* %25, i8* %cond18, i32 %31) #2
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.12, %land.lhs.true, %if.end
  %32 = load i32, i32* %ok, align 4
  %tobool22 = icmp ne i32 %32, 0
  br i1 %tobool22, label %if.then.23, label %if.end.65

if.then.23:                                       ; preds = %if.end.21
  %33 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %arg_tests_encoding = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %33, i32 0, i32 4
  %34 = load i8*, i8** %arg_tests_encoding, align 8
  %cmp24 = icmp ne i8* %34, null
  br i1 %cmp24, label %if.then.25, label %if.end.64

if.then.25:                                       ; preds = %if.then.23
  store i32 0, i32* %i, align 4
  %35 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %arg_tests_encoding26 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %35, i32 0, i32 4
  %36 = load i8*, i8** %arg_tests_encoding26, align 8
  store i8* %36, i8** %t, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args27 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 7
  %38 = load %struct.cell*, %struct.cell** %args27, align 8
  store %struct.cell* %38, %struct.cell** %arglist, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then.25
  %39 = load %struct.cell*, %struct.cell** %arglist, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %39, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %40 = load %struct.cell*, %struct.cell** %_car, align 8
  store %struct.cell* %40, %struct.cell** %arg, align 8
  %41 = load i8*, i8** %t, align 8
  %arrayidx = getelementptr inbounds i8, i8* %41, i64 0
  %42 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %42 to i32
  store i32 %conv, i32* %j, align 4
  %43 = load i32, i32* %j, align 4
  %44 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.139, i32 0, i64 0), align 1
  %conv28 = sext i8 %44 to i32
  %cmp29 = icmp eq i32 %43, %conv28
  br i1 %cmp29, label %if.then.31, label %if.else

if.then.31:                                       ; preds = %do.body
  %45 = load %struct.cell*, %struct.cell** %arg, align 8
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %46, i32 0, i32 17
  %47 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp32 = icmp ne %struct.cell* %45, %47
  br i1 %cmp32, label %land.lhs.true.34, label %if.end.38

land.lhs.true.34:                                 ; preds = %if.then.31
  %48 = load %struct.cell*, %struct.cell** %arg, align 8
  %call35 = call i32 @is_pair(%struct.cell* %48)
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.end.38, label %if.then.37

if.then.37:                                       ; preds = %land.lhs.true.34
  br label %do.end

if.end.38:                                        ; preds = %land.lhs.true.34, %if.then.31
  br label %if.end.44

if.else:                                          ; preds = %do.body
  %49 = load i32, i32* %j, align 4
  %idxprom = sext i32 %49 to i64
  %arrayidx39 = getelementptr inbounds [15 x %struct.anon.5], [15 x %struct.anon.5]* @tests, i32 0, i64 %idxprom
  %fct = getelementptr inbounds %struct.anon.5, %struct.anon.5* %arrayidx39, i32 0, i32 0
  %50 = load i32 (%struct.cell*)*, i32 (%struct.cell*)** %fct, align 8
  %51 = load %struct.cell*, %struct.cell** %arg, align 8
  %call40 = call i32 %50(%struct.cell* %51)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end.43, label %if.then.42

if.then.42:                                       ; preds = %if.else
  br label %do.end

if.end.43:                                        ; preds = %if.else
  br label %if.end.44

if.end.44:                                        ; preds = %if.end.43, %if.end.38
  %52 = load i8*, i8** %t, align 8
  %arrayidx45 = getelementptr inbounds i8, i8* %52, i64 1
  %53 = load i8, i8* %arrayidx45, align 1
  %conv46 = sext i8 %53 to i32
  %cmp47 = icmp ne i32 %conv46, 0
  br i1 %cmp47, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.end.44
  %54 = load i8*, i8** %t, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %54, i32 1
  store i8* %incdec.ptr, i8** %t, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.49, %if.end.44
  %55 = load %struct.cell*, %struct.cell** %arglist, align 8
  %_object51 = getelementptr inbounds %struct.cell, %struct.cell* %55, i32 0, i32 1
  %_cons52 = bitcast %union.anon* %_object51 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons52, i32 0, i32 1
  %56 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %56, %struct.cell** %arglist, align 8
  %57 = load i32, i32* %i, align 4
  %inc = add nsw i32 %57, 1
  store i32 %inc, i32* %i, align 4
  br label %do.cond

do.cond:                                          ; preds = %if.end.50
  %58 = load i32, i32* %i, align 4
  %59 = load i32, i32* %n, align 4
  %cmp53 = icmp slt i32 %58, %59
  br i1 %cmp53, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %if.then.42, %if.then.37
  %60 = load i32, i32* %i, align 4
  %61 = load i32, i32* %n, align 4
  %cmp55 = icmp slt i32 %60, %61
  br i1 %cmp55, label %if.then.57, label %if.end.63

if.then.57:                                       ; preds = %do.end
  store i32 0, i32* %ok, align 4
  %arraydecay58 = getelementptr inbounds [1024 x i8], [1024 x i8]* %msg, i32 0, i32 0
  %62 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %name59 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %62, i32 0, i32 1
  %63 = load i8*, i8** %name59, align 8
  %64 = load i32, i32* %i, align 4
  %add = add nsw i32 %64, 1
  %65 = load i32, i32* %j, align 4
  %idxprom60 = sext i32 %65 to i64
  %arrayidx61 = getelementptr inbounds [15 x %struct.anon.5], [15 x %struct.anon.5]* @tests, i32 0, i64 %idxprom60
  %kind = getelementptr inbounds %struct.anon.5, %struct.anon.5* %arrayidx61, i32 0, i32 1
  %66 = load i8*, i8** %kind, align 8
  %call62 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay58, i64 1024, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.281, i32 0, i32 0), i8* %63, i32 %add, i8* %66) #2
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.57, %do.end
  br label %if.end.64

if.end.64:                                        ; preds = %if.end.63, %if.then.23
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %if.end.21
  %67 = load i32, i32* %ok, align 4
  %tobool66 = icmp ne i32 %67, 0
  br i1 %tobool66, label %if.end.78, label %if.then.67

if.then.67:                                       ; preds = %if.end.65
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %arraydecay68 = getelementptr inbounds [1024 x i8], [1024 x i8]* %msg, i32 0, i32 0
  %call69 = call %struct.cell* @_Error_1(%struct.scheme* %68, i8* %arraydecay68, %struct.cell* null)
  %69 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL70 = getelementptr inbounds %struct.scheme, %struct.scheme* %69, i32 0, i32 17
  %70 = load %struct.cell*, %struct.cell** %NIL70, align 8
  %cmp71 = icmp eq %struct.cell* %call69, %70
  br i1 %cmp71, label %if.then.73, label %if.end.74

if.then.73:                                       ; preds = %if.then.67
  br label %return

if.end.74:                                        ; preds = %if.then.67
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op75 = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 55
  %72 = load i32, i32* %op75, align 4
  %idx.ext76 = sext i32 %72 to i64
  %add.ptr77 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* getelementptr inbounds ([181 x %struct.op_code_info], [181 x %struct.op_code_info]* @dispatch_table, i32 0, i32 0), i64 %idx.ext76
  store %struct.op_code_info* %add.ptr77, %struct.op_code_info** %pcd, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.end.74, %if.end.65
  br label %if.end.79

if.end.79:                                        ; preds = %if.end.78, %for.cond
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @ok_to_freely_gc(%struct.scheme* %73)
  %74 = load %struct.op_code_info*, %struct.op_code_info** %pcd, align 8
  %func = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %74, i32 0, i32 0
  %75 = load %struct.cell* (%struct.scheme*, i32)*, %struct.cell* (%struct.scheme*, i32)** %func, align 8
  %76 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op80 = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 55
  %78 = load i32, i32* %op80, align 4
  %call81 = call %struct.cell* %75(%struct.scheme* %76, i32 %78)
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL82 = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 17
  %80 = load %struct.cell*, %struct.cell** %NIL82, align 8
  %cmp83 = icmp eq %struct.cell* %call81, %80
  br i1 %cmp83, label %if.then.85, label %if.end.86

if.then.85:                                       ; preds = %if.end.79
  br label %return

if.end.86:                                        ; preds = %if.end.79
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %81, i32 0, i32 48
  %82 = load i8, i8* %no_memory, align 1
  %tobool87 = icmp ne i8 %82, 0
  br i1 %tobool87, label %if.then.88, label %if.end.90

if.then.88:                                       ; preds = %if.end.86
  %83 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %call89 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %83, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.282, i32 0, i32 0))
  br label %return

if.end.90:                                        ; preds = %if.end.86
  br label %for.cond

return:                                           ; preds = %if.then.88, %if.then.85, %if.then.73
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_load_string(%struct.scheme* %sc, i8* %cmd) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %cmd.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %cmd, i8** %cmd.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_reset(%struct.scheme* %0)
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 25
  %2 = load %struct.cell*, %struct.cell** %global_env, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 8
  store %struct.cell* %2, %struct.cell** %envir, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 45
  store i32 0, i32* %file_i, align 4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 0
  %kind = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 0
  store i8 18, i8* %kind, align 1
  %6 = load i8*, i8** %cmd.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack1 = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 43
  %arrayidx2 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack1, i32 0, i64 0
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx2, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %start = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 0
  store i8* %6, i8** %start, align 8
  %8 = load i8*, i8** %cmd.addr, align 8
  %9 = load i8*, i8** %cmd.addr, align 8
  %call = call i64 @strlen(i8* %9) #6
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 %call
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack3 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 43
  %arrayidx4 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack3, i32 0, i64 0
  %rep5 = getelementptr inbounds %struct.port, %struct.port* %arrayidx4, i32 0, i32 1
  %string6 = bitcast %union.anon.1* %rep5 to %struct.anon.3*
  %past_the_end = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string6, i32 0, i32 1
  store i8* %add.ptr, i8** %past_the_end, align 8
  %11 = load i8*, i8** %cmd.addr, align 8
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack7 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 43
  %arrayidx8 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack7, i32 0, i64 0
  %rep9 = getelementptr inbounds %struct.port, %struct.port* %arrayidx8, i32 0, i32 1
  %string10 = bitcast %union.anon.1* %rep9 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string10, i32 0, i32 2
  store i8* %11, i8** %curr, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack11 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 43
  %arraydecay = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack11, i32 0, i32 0
  %call12 = call %struct.cell* @mk_port(%struct.scheme* %13, %struct.port* %arraydecay)
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 42
  store %struct.cell* %call12, %struct.cell** %loadport, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 2
  store i32 0, i32* %retcode, align 4
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 12
  store i32 0, i32* %interactive_repl, align 4
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport13 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 42
  %19 = load %struct.cell*, %struct.cell** %loadport13, align 8
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 39
  store %struct.cell* %19, %struct.cell** %inport, align 8
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i14 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 45
  %23 = load i32, i32* %file_i14, align 4
  %conv = sext i32 %23 to i64
  %call15 = call %struct.cell* @mk_integer(%struct.scheme* %21, i64 %conv)
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 7
  store %struct.cell* %call15, %struct.cell** %args, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @Eval_Cycle(%struct.scheme* %25, i32 1)
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport16 = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 42
  %27 = load %struct.cell*, %struct.cell** %loadport16, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %27, i32 0, i32 0
  store i32 16384, i32* %_flag, align 4
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode17 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 2
  %29 = load i32, i32* %retcode17, align 4
  %cmp = icmp eq i32 %29, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 46
  %31 = load i32, i32* %nesting, align 4
  %cmp19 = icmp ne i32 %31, 0
  %conv20 = zext i1 %cmp19 to i32
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode21 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 2
  store i32 %conv20, i32* %retcode21, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_define(%struct.scheme* %sc, %struct.cell* %envir, %struct.cell* %symbol, %struct.cell* %value) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %envir.addr = alloca %struct.cell*, align 8
  %symbol.addr = alloca %struct.cell*, align 8
  %value.addr = alloca %struct.cell*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %envir, %struct.cell** %envir.addr, align 8
  store %struct.cell* %symbol, %struct.cell** %symbol.addr, align 8
  store %struct.cell* %value, %struct.cell** %value.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %envir.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %symbol.addr, align 8
  %call = call %struct.cell* @find_slot_in_env(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2, i32 0)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %3 = load %struct.cell*, %struct.cell** %x, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %3, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %8 = load %struct.cell*, %struct.cell** %value.addr, align 8
  call void @set_slot_in_env(%struct.scheme* %6, %struct.cell* %7, %struct.cell* %8)
  br label %if.end

if.else:                                          ; preds = %entry
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %10 = load %struct.cell*, %struct.cell** %envir.addr, align 8
  %11 = load %struct.cell*, %struct.cell** %symbol.addr, align 8
  %12 = load %struct.cell*, %struct.cell** %value.addr, align 8
  call void @new_slot_spec_in_env(%struct.scheme* %9, %struct.cell* %10, %struct.cell* %11, %struct.cell* %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @find_slot_in_env(%struct.scheme* %sc, %struct.cell* %env, %struct.cell* %hdl, i32 %all) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %env.addr = alloca %struct.cell*, align 8
  %hdl.addr = alloca %struct.cell*, align 8
  %all.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  %location = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %env, %struct.cell** %env.addr, align 8
  store %struct.cell* %hdl, %struct.cell** %hdl.addr, align 8
  store i32 %all, i32* %all.addr, align 4
  %0 = load %struct.cell*, %struct.cell** %env.addr, align 8
  store %struct.cell* %0, %struct.cell** %x, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.40, %entry
  %1 = load %struct.cell*, %struct.cell** %x, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %1, %3
  br i1 %cmp, label %for.body, label %for.end.44

for.body:                                         ; preds = %for.cond
  %4 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %5 = load %struct.cell*, %struct.cell** %_car, align 8
  %call = call i32 @is_vector(%struct.cell* %5)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %6 = load %struct.cell*, %struct.cell** %hdl.addr, align 8
  %call1 = call i8* @symname(%struct.cell* %6)
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons3 = bitcast %union.anon* %_object2 to %struct.anon.4*
  %_car4 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons3, i32 0, i32 0
  %8 = load %struct.cell*, %struct.cell** %_car4, align 8
  %_object5 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_number = bitcast %union.anon* %_object5 to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %9 = load i64, i64* %ivalue, align 8
  %conv = trunc i64 %9 to i32
  %call6 = call i32 @hash_fn(i8* %call1, i32 %conv)
  store i32 %call6, i32* %location, align 4
  %10 = load %struct.cell*, %struct.cell** %x, align 8
  %_object7 = getelementptr inbounds %struct.cell, %struct.cell* %10, i32 0, i32 1
  %_cons8 = bitcast %union.anon* %_object7 to %struct.anon.4*
  %_car9 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons8, i32 0, i32 0
  %11 = load %struct.cell*, %struct.cell** %_car9, align 8
  %12 = load i32, i32* %location, align 4
  %call10 = call %struct.cell* @vector_elem(%struct.cell* %11, i32 %12)
  store %struct.cell* %call10, %struct.cell** %y, align 8
  br label %if.end

if.else:                                          ; preds = %for.body
  %13 = load %struct.cell*, %struct.cell** %x, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_cons12 = bitcast %union.anon* %_object11 to %struct.anon.4*
  %_car13 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons12, i32 0, i32 0
  %14 = load %struct.cell*, %struct.cell** %_car13, align 8
  store %struct.cell* %14, %struct.cell** %y, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.cond.14

for.cond.14:                                      ; preds = %for.inc, %if.end
  %15 = load %struct.cell*, %struct.cell** %y, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL15 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 17
  %17 = load %struct.cell*, %struct.cell** %NIL15, align 8
  %cmp16 = icmp ne %struct.cell* %15, %17
  br i1 %cmp16, label %for.body.18, label %for.end

for.body.18:                                      ; preds = %for.cond.14
  %18 = load %struct.cell*, %struct.cell** %y, align 8
  %_object19 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 1
  %_cons20 = bitcast %union.anon* %_object19 to %struct.anon.4*
  %_car21 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons20, i32 0, i32 0
  %19 = load %struct.cell*, %struct.cell** %_car21, align 8
  %_object22 = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_cons23 = bitcast %union.anon* %_object22 to %struct.anon.4*
  %_car24 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons23, i32 0, i32 0
  %20 = load %struct.cell*, %struct.cell** %_car24, align 8
  %21 = load %struct.cell*, %struct.cell** %hdl.addr, align 8
  %cmp25 = icmp eq %struct.cell* %20, %21
  br i1 %cmp25, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %for.body.18
  br label %for.end

if.end.28:                                        ; preds = %for.body.18
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %22 = load %struct.cell*, %struct.cell** %y, align 8
  %_object29 = getelementptr inbounds %struct.cell, %struct.cell* %22, i32 0, i32 1
  %_cons30 = bitcast %union.anon* %_object29 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons30, i32 0, i32 1
  %23 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %23, %struct.cell** %y, align 8
  br label %for.cond.14

for.end:                                          ; preds = %if.then.27, %for.cond.14
  %24 = load %struct.cell*, %struct.cell** %y, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL31 = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 17
  %26 = load %struct.cell*, %struct.cell** %NIL31, align 8
  %cmp32 = icmp ne %struct.cell* %24, %26
  br i1 %cmp32, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %for.end
  br label %for.end.44

if.end.35:                                        ; preds = %for.end
  %27 = load i32, i32* %all.addr, align 4
  %tobool36 = icmp ne i32 %27, 0
  br i1 %tobool36, label %if.end.39, label %if.then.37

if.then.37:                                       ; preds = %if.end.35
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL38 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 17
  %29 = load %struct.cell*, %struct.cell** %NIL38, align 8
  store %struct.cell* %29, %struct.cell** %retval
  br label %return

if.end.39:                                        ; preds = %if.end.35
  br label %for.inc.40

for.inc.40:                                       ; preds = %if.end.39
  %30 = load %struct.cell*, %struct.cell** %x, align 8
  %_object41 = getelementptr inbounds %struct.cell, %struct.cell* %30, i32 0, i32 1
  %_cons42 = bitcast %union.anon* %_object41 to %struct.anon.4*
  %_cdr43 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons42, i32 0, i32 1
  %31 = load %struct.cell*, %struct.cell** %_cdr43, align 8
  store %struct.cell* %31, %struct.cell** %x, align 8
  br label %for.cond

for.end.44:                                       ; preds = %if.then.34, %for.cond
  %32 = load %struct.cell*, %struct.cell** %x, align 8
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL45 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 17
  %34 = load %struct.cell*, %struct.cell** %NIL45, align 8
  %cmp46 = icmp ne %struct.cell* %32, %34
  br i1 %cmp46, label %if.then.48, label %if.end.52

if.then.48:                                       ; preds = %for.end.44
  %35 = load %struct.cell*, %struct.cell** %y, align 8
  %_object49 = getelementptr inbounds %struct.cell, %struct.cell* %35, i32 0, i32 1
  %_cons50 = bitcast %union.anon* %_object49 to %struct.anon.4*
  %_car51 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons50, i32 0, i32 0
  %36 = load %struct.cell*, %struct.cell** %_car51, align 8
  store %struct.cell* %36, %struct.cell** %retval
  br label %return

if.end.52:                                        ; preds = %for.end.44
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL53 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 17
  %38 = load %struct.cell*, %struct.cell** %NIL53, align 8
  store %struct.cell* %38, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.52, %if.then.48, %if.then.37
  %39 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %39
}

; Function Attrs: nounwind uwtable
define internal void @set_slot_in_env(%struct.scheme* %sc, %struct.cell* %slot, %struct.cell* %value) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %slot.addr = alloca %struct.cell*, align 8
  %value.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %slot, %struct.cell** %slot.addr, align 8
  store %struct.cell* %value, %struct.cell** %value.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %value.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %slot.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  store %struct.cell* %0, %struct.cell** %_cdr, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @new_slot_spec_in_env(%struct.scheme* %sc, %struct.cell* %env, %struct.cell* %variable, %struct.cell* %value) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %env.addr = alloca %struct.cell*, align 8
  %variable.addr = alloca %struct.cell*, align 8
  %value.addr = alloca %struct.cell*, align 8
  %slot = alloca %struct.cell*, align 8
  %location = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %env, %struct.cell** %env.addr, align 8
  store %struct.cell* %variable, %struct.cell** %variable.addr, align 8
  store %struct.cell* %value, %struct.cell** %value.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %variable.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %value.addr, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2, i32 1)
  store %struct.cell* %call, %struct.cell** %slot, align 8
  %3 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %4 = load %struct.cell*, %struct.cell** %_car, align 8
  %call1 = call i32 @is_vector(%struct.cell* %4)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %variable.addr, align 8
  %call2 = call i8* @symname(%struct.cell* %5)
  %6 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object3 = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_cons4 = bitcast %union.anon* %_object3 to %struct.anon.4*
  %_car5 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons4, i32 0, i32 0
  %7 = load %struct.cell*, %struct.cell** %_car5, align 8
  %_object6 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object6 to %struct.num*
  %value7 = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value7 to i64*
  %8 = load i64, i64* %ivalue, align 8
  %conv = trunc i64 %8 to i32
  %call8 = call i32 @hash_fn(i8* %call2, i32 %conv)
  store i32 %call8, i32* %location, align 4
  %9 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object9 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons10 = bitcast %union.anon* %_object9 to %struct.anon.4*
  %_car11 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons10, i32 0, i32 0
  %10 = load %struct.cell*, %struct.cell** %_car11, align 8
  %11 = load i32, i32* %location, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %13 = load %struct.cell*, %struct.cell** %slot, align 8
  %14 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object12 = getelementptr inbounds %struct.cell, %struct.cell* %14, i32 0, i32 1
  %_cons13 = bitcast %union.anon* %_object12 to %struct.anon.4*
  %_car14 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons13, i32 0, i32 0
  %15 = load %struct.cell*, %struct.cell** %_car14, align 8
  %16 = load i32, i32* %location, align 4
  %call15 = call %struct.cell* @vector_elem(%struct.cell* %15, i32 %16)
  %call16 = call %struct.cell* @_cons(%struct.scheme* %12, %struct.cell* %13, %struct.cell* %call15, i32 1)
  %call17 = call %struct.cell* @set_vector_elem(%struct.cell* %10, i32 %11, %struct.cell* %call16)
  br label %if.end

if.else:                                          ; preds = %entry
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %18 = load %struct.cell*, %struct.cell** %slot, align 8
  %19 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object18 = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_cons19 = bitcast %union.anon* %_object18 to %struct.anon.4*
  %_car20 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons19, i32 0, i32 0
  %20 = load %struct.cell*, %struct.cell** %_car20, align 8
  %call21 = call %struct.cell* @_cons(%struct.scheme* %17, %struct.cell* %18, %struct.cell* %20, i32 1)
  %21 = load %struct.cell*, %struct.cell** %env.addr, align 8
  %_object22 = getelementptr inbounds %struct.cell, %struct.cell* %21, i32 0, i32 1
  %_cons23 = bitcast %union.anon* %_object22 to %struct.anon.4*
  %_car24 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons23, i32 0, i32 0
  store %struct.cell* %call21, %struct.cell** %_car24, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_register_foreign_func(%struct.scheme* %sc, %struct.scheme_registerable* %sr) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %sr.addr = alloca %struct.scheme_registerable*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.scheme_registerable* %sr, %struct.scheme_registerable** %sr.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 25
  %2 = load %struct.cell*, %struct.cell** %global_env, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %4 = load %struct.scheme_registerable*, %struct.scheme_registerable** %sr.addr, align 8
  %name = getelementptr inbounds %struct.scheme_registerable, %struct.scheme_registerable* %4, i32 0, i32 1
  %5 = load i8*, i8** %name, align 8
  %call = call %struct.cell* @mk_symbol(%struct.scheme* %3, i8* %5)
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.scheme_registerable*, %struct.scheme_registerable** %sr.addr, align 8
  %f = getelementptr inbounds %struct.scheme_registerable, %struct.scheme_registerable* %7, i32 0, i32 0
  %8 = load %struct.cell* (%struct.scheme*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*)** %f, align 8
  %call1 = call %struct.cell* @mk_foreign_func(%struct.scheme* %6, %struct.cell* (%struct.scheme*, %struct.cell*)* %8)
  call void @scheme_define(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %call, %struct.cell* %call1)
  ret void
}

; Function Attrs: nounwind uwtable
define void @scheme_register_foreign_func_list(%struct.scheme* %sc, %struct.scheme_registerable* %list, i32 %count) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %list.addr = alloca %struct.scheme_registerable*, align 8
  %count.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.scheme_registerable* %list, %struct.scheme_registerable** %list.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* %count.addr, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %3 = load %struct.scheme_registerable*, %struct.scheme_registerable** %list.addr, align 8
  %4 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr inbounds %struct.scheme_registerable, %struct.scheme_registerable* %3, i64 %idx.ext
  call void @scheme_register_foreign_func(%struct.scheme* %2, %struct.scheme_registerable* %add.ptr)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cell* @scheme_apply0(%struct.scheme* %sc, i8* %procname) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %procname.addr = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %procname, i8** %procname.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %3 = load i8*, i8** %procname.addr, align 8
  %call = call %struct.cell* @mk_symbol(%struct.scheme* %2, i8* %3)
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  %call1 = call %struct.cell* @_cons(%struct.scheme* %1, %struct.cell* %call, %struct.cell* %5, i32 0)
  %call2 = call %struct.cell* @scheme_eval(%struct.scheme* %0, %struct.cell* %call1)
  ret %struct.cell* %call2
}

; Function Attrs: nounwind uwtable
define %struct.cell* @scheme_eval(%struct.scheme* %sc, %struct.cell* %obj) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %obj.addr = alloca %struct.cell*, align 8
  %old_repl = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %obj, %struct.cell** %obj.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 12
  %1 = load i32, i32* %interactive_repl, align 4
  store i32 %1, i32* %old_repl, align 4
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl1 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 12
  store i32 0, i32* %interactive_repl1, align 4
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @save_from_C_call(%struct.scheme* %3)
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 7
  store %struct.cell* %5, %struct.cell** %args, align 8
  %7 = load %struct.cell*, %struct.cell** %obj.addr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 9
  store %struct.cell* %7, %struct.cell** %code, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 2
  store i32 0, i32* %retcode, align 4
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @Eval_Cycle(%struct.scheme* %10, i32 6)
  %11 = load i32, i32* %old_repl, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl2 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 12
  store i32 %11, i32* %interactive_repl2, align 4
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @restore_from_C_call(%struct.scheme* %13)
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 54
  %15 = load %struct.cell*, %struct.cell** %value, align 8
  ret %struct.cell* %15
}

; Function Attrs: nounwind uwtable
define %struct.cell* @scheme_call(%struct.scheme* %sc, %struct.cell* %func, %struct.cell* %args) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %func.addr = alloca %struct.cell*, align 8
  %args.addr = alloca %struct.cell*, align 8
  %old_repl = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %func, %struct.cell** %func.addr, align 8
  store %struct.cell* %args, %struct.cell** %args.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 12
  %1 = load i32, i32* %interactive_repl, align 4
  store i32 %1, i32* %old_repl, align 4
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl1 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 12
  store i32 0, i32* %interactive_repl1, align 4
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @save_from_C_call(%struct.scheme* %3)
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 25
  %5 = load %struct.cell*, %struct.cell** %global_env, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 8
  store %struct.cell* %5, %struct.cell** %envir, align 8
  %7 = load %struct.cell*, %struct.cell** %args.addr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args2 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 7
  store %struct.cell* %7, %struct.cell** %args2, align 8
  %9 = load %struct.cell*, %struct.cell** %func.addr, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 9
  store %struct.cell* %9, %struct.cell** %code, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 2
  store i32 0, i32* %retcode, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @Eval_Cycle(%struct.scheme* %12, i32 10)
  %13 = load i32, i32* %old_repl, align 4
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl3 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 12
  store i32 %13, i32* %interactive_repl3, align 4
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @restore_from_C_call(%struct.scheme* %15)
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 54
  %17 = load %struct.cell*, %struct.cell** %value, align 8
  ret %struct.cell* %17
}

; Function Attrs: nounwind uwtable
define internal void @save_from_C_call(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %saved_data = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 15
  %2 = load %struct.cell*, %struct.cell** %sink, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %3 = load %struct.cell*, %struct.cell** %_car, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 8
  %6 = load %struct.cell*, %struct.cell** %envir, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 10
  %8 = load %struct.cell*, %struct.cell** %dump, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %4, %struct.cell* %6, %struct.cell* %8, i32 0)
  %call1 = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %3, %struct.cell* %call, i32 0)
  store %struct.cell* %call1, %struct.cell** %saved_data, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %10 = load %struct.cell*, %struct.cell** %saved_data, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 26
  %12 = load %struct.cell*, %struct.cell** %c_nest, align 8
  %call2 = call %struct.cell* @_cons(%struct.scheme* %9, %struct.cell* %10, %struct.cell* %12, i32 0)
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest3 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 26
  store %struct.cell* %call2, %struct.cell** %c_nest3, align 8
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_reset(%struct.scheme* %14)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @restore_from_C_call(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 26
  %1 = load %struct.cell*, %struct.cell** %c_nest, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %2 = load %struct.cell*, %struct.cell** %_car, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_car3 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 0
  %3 = load %struct.cell*, %struct.cell** %_car3, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 15
  %5 = load %struct.cell*, %struct.cell** %sink, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 1
  %_cons5 = bitcast %union.anon* %_object4 to %struct.anon.4*
  %_car6 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons5, i32 0, i32 0
  store %struct.cell* %3, %struct.cell** %_car6, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest7 = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 26
  %7 = load %struct.cell*, %struct.cell** %c_nest7, align 8
  %_object8 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons9 = bitcast %union.anon* %_object8 to %struct.anon.4*
  %_car10 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons9, i32 0, i32 0
  %8 = load %struct.cell*, %struct.cell** %_car10, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_cons12 = bitcast %union.anon* %_object11 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons12, i32 0, i32 1
  %9 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %_object13 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons14 = bitcast %union.anon* %_object13 to %struct.anon.4*
  %_car15 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons14, i32 0, i32 0
  %10 = load %struct.cell*, %struct.cell** %_car15, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 8
  store %struct.cell* %10, %struct.cell** %envir, align 8
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest16 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 26
  %13 = load %struct.cell*, %struct.cell** %c_nest16, align 8
  %_object17 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_cons18 = bitcast %union.anon* %_object17 to %struct.anon.4*
  %_car19 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons18, i32 0, i32 0
  %14 = load %struct.cell*, %struct.cell** %_car19, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %14, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr22 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  %15 = load %struct.cell*, %struct.cell** %_cdr22, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %15, i32 0, i32 1
  %_cons24 = bitcast %union.anon* %_object23 to %struct.anon.4*
  %_cdr25 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons24, i32 0, i32 1
  %16 = load %struct.cell*, %struct.cell** %_cdr25, align 8
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 10
  store %struct.cell* %16, %struct.cell** %dump, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest26 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 26
  %19 = load %struct.cell*, %struct.cell** %c_nest26, align 8
  %_object27 = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_cons28 = bitcast %union.anon* %_object27 to %struct.anon.4*
  %_cdr29 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons28, i32 0, i32 1
  %20 = load %struct.cell*, %struct.cell** %_cdr29, align 8
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %c_nest30 = getelementptr inbounds %struct.scheme, %struct.scheme* %21, i32 0, i32 26
  store %struct.cell* %20, %struct.cell** %c_nest30, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @get_cell_x(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 37
  %1 = load %struct.cell*, %struct.cell** %free_cell, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell1 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 37
  %5 = load %struct.cell*, %struct.cell** %free_cell1, align 8
  store %struct.cell* %5, %struct.cell** %x, align 8
  %6 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %7 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell2 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 37
  store %struct.cell* %7, %struct.cell** %free_cell2, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 38
  %10 = load i64, i64* %fcells, align 8
  %dec = add nsw i64 %10, -1
  store i64 %dec, i64* %fcells, align 8
  %11 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %11, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %13 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %14 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call = call %struct.cell* @_get_cell(%struct.scheme* %12, %struct.cell* %13, %struct.cell* %14)
  store %struct.cell* %call, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %15
}

; Function Attrs: nounwind uwtable
define internal void @push_recent_alloc(%struct.scheme* %sc, %struct.cell* %recent, %struct.cell* %extra) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %recent.addr = alloca %struct.cell*, align 8
  %extra.addr = alloca %struct.cell*, align 8
  %holder = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %recent, %struct.cell** %recent.addr, align 8
  store %struct.cell* %extra, %struct.cell** %extra.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %recent.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %extra.addr, align 8
  %call = call %struct.cell* @get_cell_x(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2)
  store %struct.cell* %call, %struct.cell** %holder, align 8
  %3 = load %struct.cell*, %struct.cell** %holder, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 0
  store i32 8197, i32* %_flag, align 4
  %4 = load %struct.cell*, %struct.cell** %recent.addr, align 8
  %5 = load %struct.cell*, %struct.cell** %holder, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %4, %struct.cell** %_car, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 15
  %7 = load %struct.cell*, %struct.cell** %sink, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_car3 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 0
  %8 = load %struct.cell*, %struct.cell** %_car3, align 8
  %9 = load %struct.cell*, %struct.cell** %holder, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons5 = bitcast %union.anon* %_object4 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons5, i32 0, i32 1
  store %struct.cell* %8, %struct.cell** %_cdr, align 8
  %10 = load %struct.cell*, %struct.cell** %holder, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink6 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 15
  %12 = load %struct.cell*, %struct.cell** %sink6, align 8
  %_object7 = getelementptr inbounds %struct.cell, %struct.cell* %12, i32 0, i32 1
  %_cons8 = bitcast %union.anon* %_object7 to %struct.anon.4*
  %_car9 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons8, i32 0, i32 0
  store %struct.cell* %10, %struct.cell** %_car9, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @_get_cell(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %x = alloca %struct.cell*, align 8
  %min_to_be_recovered = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 48
  %1 = load i8, i8* %no_memory, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 15
  %3 = load %struct.cell*, %struct.cell** %sink, align 8
  store %struct.cell* %3, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 37
  %5 = load %struct.cell*, %struct.cell** %free_cell, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 17
  %7 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %5, %7
  br i1 %cmp, label %if.then.1, label %if.end.19

if.then.1:                                        ; preds = %if.end
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %last_cell_seg = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 6
  %9 = load i32, i32* %last_cell_seg, align 4
  %mul = mul nsw i32 %9, 8
  store i32 %mul, i32* %min_to_be_recovered, align 4
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %12 = load %struct.cell*, %struct.cell** %b.addr, align 8
  call void @gc(%struct.scheme* %10, %struct.cell* %11, %struct.cell* %12)
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 38
  %14 = load i64, i64* %fcells, align 8
  %15 = load i32, i32* %min_to_be_recovered, align 4
  %conv = sext i32 %15 to i64
  %cmp2 = icmp slt i64 %14, %conv
  br i1 %cmp2, label %if.then.8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.1
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell4 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 37
  %17 = load %struct.cell*, %struct.cell** %free_cell4, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL5 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 17
  %19 = load %struct.cell*, %struct.cell** %NIL5, align 8
  %cmp6 = icmp eq %struct.cell* %17, %19
  br i1 %cmp6, label %if.then.8, label %if.end.18

if.then.8:                                        ; preds = %lor.lhs.false, %if.then.1
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @alloc_cellseg(%struct.scheme* %20, i32 1)
  %tobool9 = icmp ne i32 %call, 0
  br i1 %tobool9, label %if.end.17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.then.8
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell10 = getelementptr inbounds %struct.scheme, %struct.scheme* %21, i32 0, i32 37
  %22 = load %struct.cell*, %struct.cell** %free_cell10, align 8
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL11 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 17
  %24 = load %struct.cell*, %struct.cell** %NIL11, align 8
  %cmp12 = icmp eq %struct.cell* %22, %24
  br i1 %cmp12, label %if.then.14, label %if.end.17

if.then.14:                                       ; preds = %land.lhs.true
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory15 = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 48
  store i8 1, i8* %no_memory15, align 1
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink16 = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 15
  %27 = load %struct.cell*, %struct.cell** %sink16, align 8
  store %struct.cell* %27, %struct.cell** %retval
  br label %return

if.end.17:                                        ; preds = %land.lhs.true, %if.then.8
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %lor.lhs.false
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %if.end
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell20 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 37
  %29 = load %struct.cell*, %struct.cell** %free_cell20, align 8
  store %struct.cell* %29, %struct.cell** %x, align 8
  %30 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %30, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %31 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell21 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 37
  store %struct.cell* %31, %struct.cell** %free_cell21, align 8
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells22 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 38
  %34 = load i64, i64* %fcells22, align 8
  %dec = add nsw i64 %34, -1
  store i64 %dec, i64* %fcells22, align 8
  %35 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %35, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.then.14, %if.then
  %36 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %36
}

; Function Attrs: nounwind readonly
declare i8* @g_utf8_offset_to_pointer(i8*, i64) #1

declare i32 @g_utf8_validate(i8*, i64, i8**) #4

; Function Attrs: nounwind uwtable
define internal i32 @hash_fn(i8* %key, i32 %table_size) #0 {
entry:
  %key.addr = alloca i8*, align 8
  %table_size.addr = alloca i32, align 4
  %hashed = alloca i32, align 4
  %c = alloca i8*, align 8
  %bits_per_int = alloca i32, align 4
  store i8* %key, i8** %key.addr, align 8
  store i32 %table_size, i32* %table_size.addr, align 4
  store i32 0, i32* %hashed, align 4
  store i32 32, i32* %bits_per_int, align 4
  %0 = load i8*, i8** %key.addr, align 8
  store i8* %0, i8** %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i8*, i8** %c, align 8
  %2 = load i8, i8* %1, align 1
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32, i32* %hashed, align 4
  %shl = shl i32 %3, 5
  %4 = load i32, i32* %hashed, align 4
  %5 = load i32, i32* %bits_per_int, align 4
  %sub = sub nsw i32 %5, 5
  %shr = lshr i32 %4, %sub
  %or = or i32 %shl, %shr
  store i32 %or, i32* %hashed, align 4
  %6 = load i8*, i8** %c, align 8
  %7 = load i8, i8* %6, align 1
  %conv = sext i8 %7 to i32
  %8 = load i32, i32* %hashed, align 4
  %xor = xor i32 %8, %conv
  store i32 %xor, i32* %hashed, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i8*, i8** %c, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %9, i32 1
  store i8* %incdec.ptr, i8** %c, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load i32, i32* %hashed, align 4
  %11 = load i32, i32* %table_size.addr, align 4
  %rem = urem i32 %10, %11
  ret i32 %rem
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @vector_elem(%struct.cell* %vec, i32 %ielem) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %vec.addr = alloca %struct.cell*, align 8
  %ielem.addr = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.cell* %vec, %struct.cell** %vec.addr, align 8
  store i32 %ielem, i32* %ielem.addr, align 4
  %0 = load i32, i32* %ielem.addr, align 4
  %div = sdiv i32 %0, 2
  store i32 %div, i32* %n, align 4
  %1 = load i32, i32* %ielem.addr, align 4
  %rem = srem i32 %1, 2
  %cmp = icmp eq i32 %rem, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %2, i64 1
  %3 = load i32, i32* %n, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr1 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 %idx.ext
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %4 = load %struct.cell*, %struct.cell** %_car, align 8
  store %struct.cell* %4, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr2 = getelementptr inbounds %struct.cell, %struct.cell* %5, i64 1
  %6 = load i32, i32* %n, align 4
  %idx.ext3 = sext i32 %6 to i64
  %add.ptr4 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr2, i64 %idx.ext3
  %_object5 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr4, i32 0, i32 1
  %_cons6 = bitcast %union.anon* %_object5 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons6, i32 0, i32 1
  %7 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %7, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define internal i32 @utf8_stricmp(i8* %s1, i8* %s2) #0 {
entry:
  %s1.addr = alloca i8*, align 8
  %s2.addr = alloca i8*, align 8
  %s1a = alloca i8*, align 8
  %s2a = alloca i8*, align 8
  %result = alloca i32, align 4
  store i8* %s1, i8** %s1.addr, align 8
  store i8* %s2, i8** %s2.addr, align 8
  %0 = load i8*, i8** %s1.addr, align 8
  %call = call noalias i8* @g_utf8_casefold(i8* %0, i64 -1)
  store i8* %call, i8** %s1a, align 8
  %1 = load i8*, i8** %s2.addr, align 8
  %call1 = call noalias i8* @g_utf8_casefold(i8* %1, i64 -1)
  store i8* %call1, i8** %s2a, align 8
  %2 = load i8*, i8** %s1a, align 8
  %3 = load i8*, i8** %s2a, align 8
  %call2 = call i32 @g_utf8_collate(i8* %2, i8* %3) #6
  store i32 %call2, i32* %result, align 4
  %4 = load i8*, i8** %s1a, align 8
  call void @g_free(i8* %4)
  %5 = load i8*, i8** %s2a, align 8
  call void @g_free(i8* %5)
  %6 = load i32, i32* %result, align 4
  ret i32 %6
}

declare noalias i8* @g_utf8_casefold(i8*, i64) #4

; Function Attrs: nounwind readonly
declare i32 @g_utf8_collate(i8*, i8*) #1

declare void @g_free(i8*) #4

; Function Attrs: nounwind uwtable
define internal %struct.cell* @set_vector_elem(%struct.cell* %vec, i32 %ielem, %struct.cell* %a) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %vec.addr = alloca %struct.cell*, align 8
  %ielem.addr = alloca i32, align 4
  %a.addr = alloca %struct.cell*, align 8
  %n = alloca i32, align 4
  store %struct.cell* %vec, %struct.cell** %vec.addr, align 8
  store i32 %ielem, i32* %ielem.addr, align 4
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load i32, i32* %ielem.addr, align 4
  %div = sdiv i32 %0, 2
  store i32 %div, i32* %n, align 4
  %1 = load i32, i32* %ielem.addr, align 4
  %rem = srem i32 %1, 2
  %cmp = icmp eq i32 %rem, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %3 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %3, i64 1
  %4 = load i32, i32* %n, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr1 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 %idx.ext
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr1, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %2, %struct.cell** %_car, align 8
  store %struct.cell* %2, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %6 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr2 = getelementptr inbounds %struct.cell, %struct.cell* %6, i64 1
  %7 = load i32, i32* %n, align 4
  %idx.ext3 = sext i32 %7 to i64
  %add.ptr4 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr2, i64 %idx.ext3
  %_object5 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr4, i32 0, i32 1
  %_cons6 = bitcast %union.anon* %_object5 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons6, i32 0, i32 1
  store %struct.cell* %5, %struct.cell** %_cdr, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %8
}

declare i64 @fwrite(i8*, i64, i64, %struct._IO_FILE*) #4

declare i32 @fflush(%struct._IO_FILE*) #4

; Function Attrs: nounwind uwtable
define internal i32 @realloc_port_string(%struct.scheme* %sc, %struct.port* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca %struct.port*, align 8
  %start = alloca i8*, align 8
  %new_size = alloca i64, align 8
  %str = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.port* %p, %struct.port** %p.addr, align 8
  %0 = load %struct.port*, %struct.port** %p.addr, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %0, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %start1 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 0
  %1 = load i8*, i8** %start1, align 8
  store i8* %1, i8** %start, align 8
  %2 = load %struct.port*, %struct.port** %p.addr, align 8
  %rep2 = getelementptr inbounds %struct.port, %struct.port* %2, i32 0, i32 1
  %string3 = bitcast %union.anon.1* %rep2 to %struct.anon.3*
  %past_the_end = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string3, i32 0, i32 1
  %3 = load i8*, i8** %past_the_end, align 8
  %4 = load i8*, i8** %start, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %3 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add = add nsw i64 %sub.ptr.sub, 1
  %add4 = add nsw i64 %add, 256
  store i64 %add4, i64* %new_size, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 0
  %6 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %7 = load i64, i64* %new_size, align 8
  %call = call i8* %6(i64 %7)
  store i8* %call, i8** %str, align 8
  %8 = load i8*, i8** %str, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load i8*, i8** %str, align 8
  %10 = load i64, i64* %new_size, align 8
  %sub = sub i64 %10, 1
  call void @llvm.memset.p0i8.i64(i8* %9, i8 32, i64 %sub, i32 1, i1 false)
  %11 = load i64, i64* %new_size, align 8
  %sub5 = sub i64 %11, 1
  %12 = load i8*, i8** %str, align 8
  %arrayidx = getelementptr inbounds i8, i8* %12, i64 %sub5
  store i8 0, i8* %arrayidx, align 1
  %13 = load i8*, i8** %str, align 8
  %14 = load i8*, i8** %start, align 8
  %call6 = call i8* @strcpy(i8* %13, i8* %14) #2
  %15 = load i8*, i8** %str, align 8
  %16 = load %struct.port*, %struct.port** %p.addr, align 8
  %rep7 = getelementptr inbounds %struct.port, %struct.port* %16, i32 0, i32 1
  %string8 = bitcast %union.anon.1* %rep7 to %struct.anon.3*
  %start9 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string8, i32 0, i32 0
  store i8* %15, i8** %start9, align 8
  %17 = load i8*, i8** %str, align 8
  %18 = load i64, i64* %new_size, align 8
  %add.ptr = getelementptr inbounds i8, i8* %17, i64 %18
  %add.ptr10 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %19 = load %struct.port*, %struct.port** %p.addr, align 8
  %rep11 = getelementptr inbounds %struct.port, %struct.port* %19, i32 0, i32 1
  %string12 = bitcast %union.anon.1* %rep11 to %struct.anon.3*
  %past_the_end13 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string12, i32 0, i32 1
  store i8* %add.ptr10, i8** %past_the_end13, align 8
  %20 = load i8*, i8** %start, align 8
  %21 = load i8*, i8** %str, align 8
  %sub.ptr.lhs.cast14 = ptrtoint i8* %20 to i64
  %sub.ptr.rhs.cast15 = ptrtoint i8* %21 to i64
  %sub.ptr.sub16 = sub i64 %sub.ptr.lhs.cast14, %sub.ptr.rhs.cast15
  %22 = load %struct.port*, %struct.port** %p.addr, align 8
  %rep17 = getelementptr inbounds %struct.port, %struct.port* %22, i32 0, i32 1
  %string18 = bitcast %union.anon.1* %rep17 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string18, i32 0, i32 2
  %23 = load i8*, i8** %curr, align 8
  %idx.neg = sub i64 0, %sub.ptr.sub16
  %add.ptr19 = getelementptr inbounds i8, i8* %23, i64 %idx.neg
  store i8* %add.ptr19, i8** %curr, align 8
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 1
  %25 = load void (i8*)*, void (i8*)** %free, align 8
  %26 = load i8*, i8** %start, align 8
  call void %25(i8* %26)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %27 = load i32, i32* %retval
  ret i32 %27
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8*) #3

; Function Attrs: nounwind uwtable
define internal %struct.cell* @s_cons(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2, i32 0)
  ret %struct.cell* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @s_immutable_cons(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %b.addr, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2, i32 1)
  ret %struct.cell* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @reserve_cells(%struct.scheme* %sc, i32 %n) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %n.addr = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 48
  %1 = load i8, i8* %no_memory, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %3, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 38
  %5 = load i64, i64* %fcells, align 8
  %6 = load i32, i32* %n.addr, align 4
  %conv = sext i32 %6 to i64
  %cmp = icmp slt i64 %5, %conv
  br i1 %cmp, label %if.then.2, label %if.end.24

if.then.2:                                        ; preds = %if.end
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 17
  %9 = load %struct.cell*, %struct.cell** %NIL3, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL4 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  %11 = load %struct.cell*, %struct.cell** %NIL4, align 8
  call void @gc(%struct.scheme* %7, %struct.cell* %9, %struct.cell* %11)
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells5 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 38
  %13 = load i64, i64* %fcells5, align 8
  %14 = load i32, i32* %n.addr, align 4
  %conv6 = sext i32 %14 to i64
  %cmp7 = icmp slt i64 %13, %conv6
  br i1 %cmp7, label %if.then.9, label %if.end.15

if.then.9:                                        ; preds = %if.then.2
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @alloc_cellseg(%struct.scheme* %15, i32 1)
  %tobool10 = icmp ne i32 %call, 0
  br i1 %tobool10, label %if.end.14, label %if.then.11

if.then.11:                                       ; preds = %if.then.9
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory12 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 48
  store i8 1, i8* %no_memory12, align 1
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL13 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 17
  %18 = load %struct.cell*, %struct.cell** %NIL13, align 8
  store %struct.cell* %18, %struct.cell** %retval
  br label %return

if.end.14:                                        ; preds = %if.then.9
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.14, %if.then.2
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells16 = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 38
  %20 = load i64, i64* %fcells16, align 8
  %21 = load i32, i32* %n.addr, align 4
  %conv17 = sext i32 %21 to i64
  %cmp18 = icmp slt i64 %20, %conv17
  br i1 %cmp18, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %if.end.15
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory21 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 48
  store i8 1, i8* %no_memory21, align 1
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL22 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 17
  %24 = load %struct.cell*, %struct.cell** %NIL22, align 8
  store %struct.cell* %24, %struct.cell** %retval
  br label %return

if.end.23:                                        ; preds = %if.end.15
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.end
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 19
  %26 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %26, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.24, %if.then.20, %if.then.11, %if.then
  %27 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %27
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_vector(%struct.scheme* %sc, i32 %len) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %len.addr = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i32, i32* %len.addr, align 4
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  %call = call %struct.cell* @get_vector_object(%struct.scheme* %0, i32 %1, %struct.cell* %3)
  ret %struct.cell* %call
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_closure(%struct.scheme* %sc, %struct.cell* %c, %struct.cell* %e) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %c.addr = alloca %struct.cell*, align 8
  %e.addr = alloca %struct.cell*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %c, %struct.cell** %c.addr, align 8
  store %struct.cell* %e, %struct.cell** %e.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %c.addr, align 8
  %2 = load %struct.cell*, %struct.cell** %e.addr, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %1, %struct.cell* %2)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %3 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 0
  store i32 6, i32* %_flag, align 4
  %4 = load %struct.cell*, %struct.cell** %c.addr, align 8
  %5 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %4, %struct.cell** %_car, align 8
  %6 = load %struct.cell*, %struct.cell** %e.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 1
  store %struct.cell* %6, %struct.cell** %_cdr, align 8
  %8 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define internal i32 @is_list(%struct.scheme* %sc, %struct.cell* %a) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call = call i32 @list_length(%struct.scheme* %0, %struct.cell* %1)
  %cmp = icmp sge i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define internal void @fill_vector(%struct.cell* %vec, %struct.cell* %obj) #0 {
entry:
  %vec.addr = alloca %struct.cell*, align 8
  %obj.addr = alloca %struct.cell*, align 8
  %i = alloca i32, align 4
  %num = alloca i32, align 4
  store %struct.cell* %vec, %struct.cell** %vec.addr, align 8
  store %struct.cell* %obj, %struct.cell** %obj.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %call = call i64 @ivalue(%struct.cell* %0)
  %div = sdiv i64 %call, 2
  %1 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %call1 = call i64 @ivalue(%struct.cell* %1)
  %rem = srem i64 %call1, 2
  %add = add nsw i64 %div, %rem
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %num, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %num, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %4, i64 1
  %5 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %5 to i64
  %add.ptr3 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 %idx.ext
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr3, i32 0, i32 0
  store i32 5, i32* %_flag, align 4
  %6 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr4 = getelementptr inbounds %struct.cell, %struct.cell* %6, i64 1
  %7 = load i32, i32* %i, align 4
  %idx.ext5 = sext i32 %7 to i64
  %add.ptr6 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr4, i64 %idx.ext5
  call void @setimmutable(%struct.cell* %add.ptr6)
  %8 = load %struct.cell*, %struct.cell** %obj.addr, align 8
  %9 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr7 = getelementptr inbounds %struct.cell, %struct.cell* %9, i64 1
  %10 = load i32, i32* %i, align 4
  %idx.ext8 = sext i32 %10 to i64
  %add.ptr9 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr7, i64 %idx.ext8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr9, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %8, %struct.cell** %_car, align 8
  %11 = load %struct.cell*, %struct.cell** %obj.addr, align 8
  %12 = load %struct.cell*, %struct.cell** %vec.addr, align 8
  %add.ptr10 = getelementptr inbounds %struct.cell, %struct.cell* %12, i64 1
  %13 = load i32, i32* %i, align 4
  %idx.ext11 = sext i32 %13 to i64
  %add.ptr12 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr10, i64 %idx.ext11
  %_object13 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr12, i32 0, i32 1
  %_cons14 = bitcast %union.anon* %_object13 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons14, i32 0, i32 1
  store %struct.cell* %11, %struct.cell** %_cdr, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i32, i32* %i, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @get_vector_object(%struct.scheme* %sc, i32 %len, %struct.cell* %init) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %len.addr = alloca i32, align 4
  %init.addr = alloca %struct.cell*, align 8
  %cells = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  store %struct.cell* %init, %struct.cell** %init.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i32, i32* %len.addr, align 4
  %div = sdiv i32 %1, 2
  %2 = load i32, i32* %len.addr, align 4
  %rem = srem i32 %2, 2
  %add = add nsw i32 %div, %rem
  %add1 = add nsw i32 %add, 1
  %call = call %struct.cell* @get_consecutive_cells(%struct.scheme* %0, i32 %add1)
  store %struct.cell* %call, %struct.cell** %cells, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 48
  %4 = load i8, i8* %no_memory, align 1
  %tobool = icmp ne i8 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 15
  %6 = load %struct.cell*, %struct.cell** %sink, align 8
  store %struct.cell* %6, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.cell*, %struct.cell** %cells, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 0
  store i32 16395, i32* %_flag, align 4
  %8 = load i32, i32* %len.addr, align 4
  %conv = sext i32 %8 to i64
  %9 = load %struct.cell*, %struct.cell** %cells, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  store i64 %conv, i64* %ivalue, align 8
  %10 = load %struct.cell*, %struct.cell** %cells, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %10, i32 0, i32 1
  %_number3 = bitcast %union.anon* %_object2 to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number3, i32 0, i32 0
  store i8 1, i8* %is_fixnum, align 1
  %11 = load %struct.cell*, %struct.cell** %cells, align 8
  %12 = load %struct.cell*, %struct.cell** %init.addr, align 8
  call void @fill_vector(%struct.cell* %11, %struct.cell* %12)
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %14 = load %struct.cell*, %struct.cell** %cells, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 17
  %16 = load %struct.cell*, %struct.cell** %NIL, align 8
  call void @push_recent_alloc(%struct.scheme* %13, %struct.cell* %14, %struct.cell* %16)
  %17 = load %struct.cell*, %struct.cell** %cells, align 8
  store %struct.cell* %17, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %18
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @get_consecutive_cells(%struct.scheme* %sc, i32 %n) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %n.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 48
  %1 = load i8, i8* %no_memory, align 1
  %tobool = icmp ne i8 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 15
  %3 = load %struct.cell*, %struct.cell** %sink, align 8
  store %struct.cell* %3, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %5 = load i32, i32* %n.addr, align 4
  %call = call %struct.cell* @find_consecutive_cells(%struct.scheme* %4, i32 %5)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %6 = load %struct.cell*, %struct.cell** %x, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 17
  %8 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %6, %8
  br i1 %cmp, label %if.then.1, label %if.end.2

if.then.1:                                        ; preds = %if.end
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %9, %struct.cell** %retval
  br label %return

if.end.2:                                         ; preds = %if.end
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 17
  %12 = load %struct.cell*, %struct.cell** %NIL3, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL4 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 17
  %14 = load %struct.cell*, %struct.cell** %NIL4, align 8
  call void @gc(%struct.scheme* %10, %struct.cell* %12, %struct.cell* %14)
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %16 = load i32, i32* %n.addr, align 4
  %call5 = call %struct.cell* @find_consecutive_cells(%struct.scheme* %15, i32 %16)
  store %struct.cell* %call5, %struct.cell** %x, align 8
  %17 = load %struct.cell*, %struct.cell** %x, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL6 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 17
  %19 = load %struct.cell*, %struct.cell** %NIL6, align 8
  %cmp7 = icmp ne %struct.cell* %17, %19
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.2
  %20 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %20, %struct.cell** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.2
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call10 = call i32 @alloc_cellseg(%struct.scheme* %21, i32 1)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end.15, label %if.then.12

if.then.12:                                       ; preds = %if.end.9
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory13 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 48
  store i8 1, i8* %no_memory13, align 1
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink14 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 15
  %24 = load %struct.cell*, %struct.cell** %sink14, align 8
  store %struct.cell* %24, %struct.cell** %retval
  br label %return

if.end.15:                                        ; preds = %if.end.9
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %26 = load i32, i32* %n.addr, align 4
  %call16 = call %struct.cell* @find_consecutive_cells(%struct.scheme* %25, i32 %26)
  store %struct.cell* %call16, %struct.cell** %x, align 8
  %27 = load %struct.cell*, %struct.cell** %x, align 8
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL17 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 17
  %29 = load %struct.cell*, %struct.cell** %NIL17, align 8
  %cmp18 = icmp ne %struct.cell* %27, %29
  br i1 %cmp18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %if.end.15
  %30 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %30, %struct.cell** %retval
  br label %return

if.end.20:                                        ; preds = %if.end.15
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory21 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 48
  store i8 1, i8* %no_memory21, align 1
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink22 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 15
  %33 = load %struct.cell*, %struct.cell** %sink22, align 8
  store %struct.cell* %33, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.20, %if.then.19, %if.then.12, %if.then.8, %if.then.1, %if.then
  %34 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %34
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @find_consecutive_cells(%struct.scheme* %sc, i32 %n) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %n.addr = alloca i32, align 4
  %pp = alloca %struct.cell**, align 8
  %cnt = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free_cell = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 37
  store %struct.cell** %free_cell, %struct.cell*** %pp, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %1 = load %struct.cell**, %struct.cell*** %pp, align 8
  %2 = load %struct.cell*, %struct.cell** %1, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %2, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.cell**, %struct.cell*** %pp, align 8
  %6 = load %struct.cell*, %struct.cell** %5, align 8
  %7 = load i32, i32* %n.addr, align 4
  %call = call i32 @count_consecutive_cells(%struct.cell* %6, i32 %7)
  store i32 %call, i32* %cnt, align 4
  %8 = load i32, i32* %cnt, align 4
  %9 = load i32, i32* %n.addr, align 4
  %cmp1 = icmp sge i32 %8, %9
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %10 = load %struct.cell**, %struct.cell*** %pp, align 8
  %11 = load %struct.cell*, %struct.cell** %10, align 8
  store %struct.cell* %11, %struct.cell** %x, align 8
  %12 = load %struct.cell**, %struct.cell*** %pp, align 8
  %13 = load %struct.cell*, %struct.cell** %12, align 8
  %14 = load i32, i32* %n.addr, align 4
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %13, i64 %idx.ext
  %add.ptr2 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 -1
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr2, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %15 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %16 = load %struct.cell**, %struct.cell*** %pp, align 8
  store %struct.cell* %15, %struct.cell** %16, align 8
  %17 = load i32, i32* %n.addr, align 4
  %conv = sext i32 %17 to i64
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %fcells = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 38
  %19 = load i64, i64* %fcells, align 8
  %sub = sub nsw i64 %19, %conv
  store i64 %sub, i64* %fcells, align 8
  %20 = load %struct.cell*, %struct.cell** %x, align 8
  store %struct.cell* %20, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %while.body
  %21 = load %struct.cell**, %struct.cell*** %pp, align 8
  %22 = load %struct.cell*, %struct.cell** %21, align 8
  %23 = load i32, i32* %cnt, align 4
  %idx.ext3 = sext i32 %23 to i64
  %add.ptr4 = getelementptr inbounds %struct.cell, %struct.cell* %22, i64 %idx.ext3
  %add.ptr5 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr4, i64 -1
  %_object6 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr5, i32 0, i32 1
  %_cons7 = bitcast %union.anon* %_object6 to %struct.anon.4*
  %_cdr8 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons7, i32 0, i32 1
  store %struct.cell** %_cdr8, %struct.cell*** %pp, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL9 = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 17
  %25 = load %struct.cell*, %struct.cell** %NIL9, align 8
  store %struct.cell* %25, %struct.cell** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %26 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %26
}

; Function Attrs: nounwind uwtable
define internal i32 @count_consecutive_cells(%struct.cell* %x, i32 %needed) #0 {
entry:
  %retval = alloca i32, align 4
  %x.addr = alloca %struct.cell*, align 8
  %needed.addr = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.cell* %x, %struct.cell** %x.addr, align 8
  store i32 %needed, i32* %needed.addr, align 4
  store i32 1, i32* %n, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load %struct.cell*, %struct.cell** %x.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %1 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %2 = load %struct.cell*, %struct.cell** %x.addr, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %2, i64 1
  %cmp = icmp eq %struct.cell* %1, %add.ptr
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.cell*, %struct.cell** %x.addr, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_cdr3 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 1
  %4 = load %struct.cell*, %struct.cell** %_cdr3, align 8
  store %struct.cell* %4, %struct.cell** %x.addr, align 8
  %5 = load i32, i32* %n, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %n, align 4
  %6 = load i32, i32* %n, align 4
  %7 = load i32, i32* %needed.addr, align 4
  %cmp4 = icmp sgt i32 %6, %7
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %8 = load i32, i32* %n, align 4
  store i32 %8, i32* %retval
  br label %return

if.end:                                           ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i32, i32* %n, align 4
  store i32 %9, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %10 = load i32, i32* %retval
  ret i32 %10
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_0(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  %tr = alloca i32, align 4
  %f = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.23
    i32 2, label %sw.bb.57
    i32 3, label %sw.bb.65
    i32 4, label %sw.bb.77
    i32 5, label %sw.bb.80
    i32 6, label %sw.bb.98
    i32 7, label %sw.bb.111
    i32 8, label %sw.bb.167
    i32 9, label %sw.bb.195
    i32 12, label %sw.bb.240
    i32 10, label %sw.bb.252
    i32 11, label %sw.bb.264
    i32 13, label %sw.bb.396
    i32 14, label %sw.bb.403
    i32 15, label %sw.bb.426
    i32 16, label %sw.bb.431
    i32 17, label %sw.bb.466
    i32 18, label %sw.bb.472
    i32 19, label %sw.bb.539
    i32 20, label %sw.bb.554
    i32 24, label %sw.bb.586
    i32 25, label %sw.bb.617
    i32 21, label %sw.bb.631
    i32 22, label %sw.bb.662
    i32 23, label %sw.bb.677
    i32 26, label %sw.bb.702
    i32 27, label %sw.bb.733
    i32 28, label %sw.bb.807
    i32 29, label %sw.bb.944
    i32 30, label %sw.bb.1026
    i32 31, label %sw.bb.1032
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @file_interactive(%struct.scheme* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 40
  %3 = load %struct.cell*, %struct.cell** %outport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %4 = load %struct.port*, %struct.port** %_port, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %4, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  %5 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 7
  %7 = load %struct.cell*, %struct.cell** %args, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %8 = load %struct.cell*, %struct.cell** %_car, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_string = bitcast %union.anon* %_object2 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %9 = load i8*, i8** %_svalue, align 8
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %5, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.172, i32 0, i32 0), i8* %9)
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args4 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 7
  %12 = load %struct.cell*, %struct.cell** %args4, align 8
  %_object5 = getelementptr inbounds %struct.cell, %struct.cell* %12, i32 0, i32 1
  %_cons6 = bitcast %union.anon* %_object5 to %struct.anon.4*
  %_car7 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons6, i32 0, i32 0
  %13 = load %struct.cell*, %struct.cell** %_car7, align 8
  %_object8 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_string9 = bitcast %union.anon* %_object8 to %struct.anon*
  %_svalue10 = getelementptr inbounds %struct.anon, %struct.anon* %_string9, i32 0, i32 0
  %14 = load i8*, i8** %_svalue10, align 8
  %call11 = call i32 @file_push(%struct.scheme* %10, i8* %14)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.else, label %if.then.13

if.then.13:                                       ; preds = %if.end
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args14 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 7
  %17 = load %struct.cell*, %struct.cell** %args14, align 8
  %_object15 = getelementptr inbounds %struct.cell, %struct.cell* %17, i32 0, i32 1
  %_cons16 = bitcast %union.anon* %_object15 to %struct.anon.4*
  %_car17 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons16, i32 0, i32 0
  %18 = load %struct.cell*, %struct.cell** %_car17, align 8
  %call18 = call %struct.cell* @_Error_1(%struct.scheme* %15, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.173, i32 0, i32 0), %struct.cell* %18)
  store %struct.cell* %call18, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 45
  %21 = load i32, i32* %file_i, align 4
  %conv = sext i32 %21 to i64
  %call19 = call %struct.cell* @mk_integer(%struct.scheme* %19, i64 %conv)
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args20 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 7
  store %struct.cell* %call19, %struct.cell** %args20, align 8
  br label %do.body

do.body:                                          ; preds = %if.else
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op21 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 55
  store i32 1, i32* %op21, align 4
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 19
  %25 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %25, %struct.cell** %retval
  br label %return

do.end:                                           ; No predecessors!
  br label %if.end.22

if.end.22:                                        ; preds = %do.end
  br label %sw.bb.23

sw.bb.23:                                         ; preds = %entry, %if.end.22
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 42
  %27 = load %struct.cell*, %struct.cell** %loadport, align 8
  %_object24 = getelementptr inbounds %struct.cell, %struct.cell* %27, i32 0, i32 1
  %_port25 = bitcast %union.anon* %_object24 to %struct.port**
  %28 = load %struct.port*, %struct.port** %_port25, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %28, i32 0, i32 0
  %29 = load i8, i8* %kind, align 1
  %conv26 = zext i8 %29 to i32
  %and = and i32 %conv26, 64
  %tobool27 = icmp ne i32 %and, 0
  br i1 %tobool27, label %if.then.28, label %if.end.40

if.then.28:                                       ; preds = %sw.bb.23
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i29 = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 45
  %31 = load i32, i32* %file_i29, align 4
  %cmp = icmp eq i32 %31, 0
  br i1 %cmp, label %if.then.31, label %if.else.37

if.then.31:                                       ; preds = %if.then.28
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 17
  %33 = load %struct.cell*, %struct.cell** %NIL, align 8
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args32 = getelementptr inbounds %struct.scheme, %struct.scheme* %34, i32 0, i32 7
  store %struct.cell* %33, %struct.cell** %args32, align 8
  br label %do.body.33

do.body.33:                                       ; preds = %if.then.31
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op34 = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 55
  store i32 139, i32* %op34, align 4
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T35 = getelementptr inbounds %struct.scheme, %struct.scheme* %36, i32 0, i32 19
  %37 = load %struct.cell*, %struct.cell** %T35, align 8
  store %struct.cell* %37, %struct.cell** %retval
  br label %return

do.end.36:                                        ; No predecessors!
  br label %if.end.39

if.else.37:                                       ; preds = %if.then.28
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @file_pop(%struct.scheme* %38)
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 54
  %41 = load %struct.cell*, %struct.cell** %value, align 8
  %call38 = call %struct.cell* @_s_return(%struct.scheme* %39, %struct.cell* %41)
  store %struct.cell* %call38, %struct.cell** %retval
  br label %return

if.end.39:                                        ; preds = %do.end.36
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %sw.bb.23
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call41 = call i32 @file_interactive(%struct.scheme* %42)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %if.end.40
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %43, i32 0, i32 25
  %44 = load %struct.cell*, %struct.cell** %global_env, align 8
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %45, i32 0, i32 8
  store %struct.cell* %44, %struct.cell** %envir, align 8
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @dump_stack_reset(%struct.scheme* %46)
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %47, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0))
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %48, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.174, i32 0, i32 0))
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.43, %if.end.40
  %49 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %49, i32 0, i32 46
  store i32 0, i32* %nesting, align 4
  %50 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %50, i32 0, i32 39
  %51 = load %struct.cell*, %struct.cell** %inport, align 8
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 41
  store %struct.cell* %51, %struct.cell** %save_inport, align 8
  %53 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport45 = getelementptr inbounds %struct.scheme, %struct.scheme* %53, i32 0, i32 42
  %54 = load %struct.cell*, %struct.cell** %loadport45, align 8
  %55 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport46 = getelementptr inbounds %struct.scheme, %struct.scheme* %55, i32 0, i32 39
  store %struct.cell* %54, %struct.cell** %inport46, align 8
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL47 = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 17
  %58 = load %struct.cell*, %struct.cell** %NIL47, align 8
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL48 = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 17
  %60 = load %struct.cell*, %struct.cell** %NIL48, align 8
  call void @s_save(%struct.scheme* %56, i32 1, %struct.cell* %58, %struct.cell* %60)
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL49 = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 17
  %63 = load %struct.cell*, %struct.cell** %NIL49, align 8
  %64 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL50 = getelementptr inbounds %struct.scheme, %struct.scheme* %64, i32 0, i32 17
  %65 = load %struct.cell*, %struct.cell** %NIL50, align 8
  call void @s_save(%struct.scheme* %61, i32 5, %struct.cell* %63, %struct.cell* %65)
  %66 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL51 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 17
  %68 = load %struct.cell*, %struct.cell** %NIL51, align 8
  %69 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL52 = getelementptr inbounds %struct.scheme, %struct.scheme* %69, i32 0, i32 17
  %70 = load %struct.cell*, %struct.cell** %NIL52, align 8
  call void @s_save(%struct.scheme* %66, i32 2, %struct.cell* %68, %struct.cell* %70)
  br label %do.body.53

do.body.53:                                       ; preds = %if.end.44
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op54 = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 55
  store i32 3, i32* %op54, align 4
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T55 = getelementptr inbounds %struct.scheme, %struct.scheme* %72, i32 0, i32 19
  %73 = load %struct.cell*, %struct.cell** %T55, align 8
  store %struct.cell* %73, %struct.cell** %retval
  br label %return

do.end.56:                                        ; No predecessors!
  br label %sw.bb.57

sw.bb.57:                                         ; preds = %entry, %do.end.56
  %74 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value58 = getelementptr inbounds %struct.scheme, %struct.scheme* %74, i32 0, i32 54
  %75 = load %struct.cell*, %struct.cell** %value58, align 8
  %76 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %76, i32 0, i32 9
  store %struct.cell* %75, %struct.cell** %code, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %save_inport59 = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 41
  %78 = load %struct.cell*, %struct.cell** %save_inport59, align 8
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport60 = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 39
  store %struct.cell* %78, %struct.cell** %inport60, align 8
  br label %do.body.61

do.body.61:                                       ; preds = %sw.bb.57
  %80 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op62 = getelementptr inbounds %struct.scheme, %struct.scheme* %80, i32 0, i32 55
  store i32 6, i32* %op62, align 4
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T63 = getelementptr inbounds %struct.scheme, %struct.scheme* %81, i32 0, i32 19
  %82 = load %struct.cell*, %struct.cell** %T63, align 8
  store %struct.cell* %82, %struct.cell** %retval
  br label %return

do.end.64:                                        ; No predecessors!
  br label %sw.bb.65

sw.bb.65:                                         ; preds = %entry, %do.end.64
  %83 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call66 = call i32 @token(%struct.scheme* %83)
  %84 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok = getelementptr inbounds %struct.scheme, %struct.scheme* %84, i32 0, i32 52
  store i32 %call66, i32* %tok, align 4
  %85 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok67 = getelementptr inbounds %struct.scheme, %struct.scheme* %85, i32 0, i32 52
  %86 = load i32, i32* %tok67, align 4
  %cmp68 = icmp eq i32 %86, -1
  br i1 %cmp68, label %if.then.70, label %if.end.72

if.then.70:                                       ; preds = %sw.bb.65
  %87 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %88 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %88, i32 0, i32 23
  %89 = load %struct.cell*, %struct.cell** %EOF_OBJ, align 8
  %call71 = call %struct.cell* @_s_return(%struct.scheme* %87, %struct.cell* %89)
  store %struct.cell* %call71, %struct.cell** %retval
  br label %return

if.end.72:                                        ; preds = %sw.bb.65
  br label %do.body.73

do.body.73:                                       ; preds = %if.end.72
  %90 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op74 = getelementptr inbounds %struct.scheme, %struct.scheme* %90, i32 0, i32 55
  store i32 163, i32* %op74, align 4
  %91 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T75 = getelementptr inbounds %struct.scheme, %struct.scheme* %91, i32 0, i32 19
  %92 = load %struct.cell*, %struct.cell** %T75, align 8
  store %struct.cell* %92, %struct.cell** %retval
  br label %return

do.end.76:                                        ; No predecessors!
  br label %sw.bb.77

sw.bb.77:                                         ; preds = %entry, %do.end.76
  %93 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %94 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call78 = call %struct.cell* @gensym(%struct.scheme* %94)
  %call79 = call %struct.cell* @_s_return(%struct.scheme* %93, %struct.cell* %call78)
  store %struct.cell* %call79, %struct.cell** %retval
  br label %return

sw.bb.80:                                         ; preds = %entry
  %95 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing = getelementptr inbounds %struct.scheme, %struct.scheme* %95, i32 0, i32 3
  %96 = load i32, i32* %tracing, align 4
  %tobool81 = icmp ne i32 %96, 0
  br i1 %tobool81, label %if.then.82, label %if.end.83

if.then.82:                                       ; preds = %sw.bb.80
  %97 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %97, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.175, i32 0, i32 0))
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.82, %sw.bb.80
  %98 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call84 = call i32 @file_interactive(%struct.scheme* %98)
  %tobool85 = icmp ne i32 %call84, 0
  br i1 %tobool85, label %if.then.87, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.83
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_output = getelementptr inbounds %struct.scheme, %struct.scheme* %99, i32 0, i32 13
  %100 = load i32, i32* %print_output, align 4
  %tobool86 = icmp ne i32 %100, 0
  br i1 %tobool86, label %if.then.87, label %if.else.94

if.then.87:                                       ; preds = %lor.lhs.false, %if.end.83
  %101 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %101, i32 0, i32 53
  store i32 1, i32* %print_flag, align 4
  %102 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value88 = getelementptr inbounds %struct.scheme, %struct.scheme* %102, i32 0, i32 54
  %103 = load %struct.cell*, %struct.cell** %value88, align 8
  %104 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args89 = getelementptr inbounds %struct.scheme, %struct.scheme* %104, i32 0, i32 7
  store %struct.cell* %103, %struct.cell** %args89, align 8
  br label %do.body.90

do.body.90:                                       ; preds = %if.then.87
  %105 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op91 = getelementptr inbounds %struct.scheme, %struct.scheme* %105, i32 0, i32 55
  store i32 172, i32* %op91, align 4
  %106 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T92 = getelementptr inbounds %struct.scheme, %struct.scheme* %106, i32 0, i32 19
  %107 = load %struct.cell*, %struct.cell** %T92, align 8
  store %struct.cell* %107, %struct.cell** %retval
  br label %return

do.end.93:                                        ; No predecessors!
  br label %if.end.97

if.else.94:                                       ; preds = %lor.lhs.false
  %108 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %109 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value95 = getelementptr inbounds %struct.scheme, %struct.scheme* %109, i32 0, i32 54
  %110 = load %struct.cell*, %struct.cell** %value95, align 8
  %call96 = call %struct.cell* @_s_return(%struct.scheme* %108, %struct.cell* %110)
  store %struct.cell* %call96, %struct.cell** %retval
  br label %return

if.end.97:                                        ; preds = %do.end.93
  br label %sw.bb.98

sw.bb.98:                                         ; preds = %entry, %if.end.97
  %111 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing99 = getelementptr inbounds %struct.scheme, %struct.scheme* %111, i32 0, i32 3
  %112 = load i32, i32* %tracing99, align 4
  %tobool100 = icmp ne i32 %112, 0
  br i1 %tobool100, label %if.then.101, label %if.end.110

if.then.101:                                      ; preds = %sw.bb.98
  %113 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %114 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args102 = getelementptr inbounds %struct.scheme, %struct.scheme* %114, i32 0, i32 7
  %115 = load %struct.cell*, %struct.cell** %args102, align 8
  %116 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code103 = getelementptr inbounds %struct.scheme, %struct.scheme* %116, i32 0, i32 9
  %117 = load %struct.cell*, %struct.cell** %code103, align 8
  call void @s_save(%struct.scheme* %113, i32 7, %struct.cell* %115, %struct.cell* %117)
  %118 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code104 = getelementptr inbounds %struct.scheme, %struct.scheme* %118, i32 0, i32 9
  %119 = load %struct.cell*, %struct.cell** %code104, align 8
  %120 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args105 = getelementptr inbounds %struct.scheme, %struct.scheme* %120, i32 0, i32 7
  store %struct.cell* %119, %struct.cell** %args105, align 8
  %121 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %121, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.176, i32 0, i32 0))
  br label %do.body.106

do.body.106:                                      ; preds = %if.then.101
  %122 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op107 = getelementptr inbounds %struct.scheme, %struct.scheme* %122, i32 0, i32 55
  store i32 172, i32* %op107, align 4
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T108 = getelementptr inbounds %struct.scheme, %struct.scheme* %123, i32 0, i32 19
  %124 = load %struct.cell*, %struct.cell** %T108, align 8
  store %struct.cell* %124, %struct.cell** %retval
  br label %return

do.end.109:                                       ; No predecessors!
  br label %if.end.110

if.end.110:                                       ; preds = %do.end.109, %sw.bb.98
  br label %sw.bb.111

sw.bb.111:                                        ; preds = %entry, %if.end.110
  %125 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code112 = getelementptr inbounds %struct.scheme, %struct.scheme* %125, i32 0, i32 9
  %126 = load %struct.cell*, %struct.cell** %code112, align 8
  %call113 = call i32 @is_symbol(%struct.cell* %126)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then.115, label %if.else.128

if.then.115:                                      ; preds = %sw.bb.111
  %127 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %128 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir116 = getelementptr inbounds %struct.scheme, %struct.scheme* %128, i32 0, i32 8
  %129 = load %struct.cell*, %struct.cell** %envir116, align 8
  %130 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code117 = getelementptr inbounds %struct.scheme, %struct.scheme* %130, i32 0, i32 9
  %131 = load %struct.cell*, %struct.cell** %code117, align 8
  %call118 = call %struct.cell* @find_slot_in_env(%struct.scheme* %127, %struct.cell* %129, %struct.cell* %131, i32 1)
  store %struct.cell* %call118, %struct.cell** %x, align 8
  %132 = load %struct.cell*, %struct.cell** %x, align 8
  %133 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL119 = getelementptr inbounds %struct.scheme, %struct.scheme* %133, i32 0, i32 17
  %134 = load %struct.cell*, %struct.cell** %NIL119, align 8
  %cmp120 = icmp ne %struct.cell* %132, %134
  br i1 %cmp120, label %if.then.122, label %if.else.125

if.then.122:                                      ; preds = %if.then.115
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %136 = load %struct.cell*, %struct.cell** %x, align 8
  %call123 = call %struct.cell* @slot_value_in_env(%struct.cell* %136)
  %call124 = call %struct.cell* @_s_return(%struct.scheme* %135, %struct.cell* %call123)
  store %struct.cell* %call124, %struct.cell** %retval
  br label %return

if.else.125:                                      ; preds = %if.then.115
  %137 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %138 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code126 = getelementptr inbounds %struct.scheme, %struct.scheme* %138, i32 0, i32 9
  %139 = load %struct.cell*, %struct.cell** %code126, align 8
  %call127 = call %struct.cell* @_Error_1(%struct.scheme* %137, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.177, i32 0, i32 0), %struct.cell* %139)
  store %struct.cell* %call127, %struct.cell** %retval
  br label %return

if.else.128:                                      ; preds = %sw.bb.111
  %140 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code129 = getelementptr inbounds %struct.scheme, %struct.scheme* %140, i32 0, i32 9
  %141 = load %struct.cell*, %struct.cell** %code129, align 8
  %call130 = call i32 @is_pair(%struct.cell* %141)
  %tobool131 = icmp ne i32 %call130, 0
  br i1 %tobool131, label %if.then.132, label %if.else.162

if.then.132:                                      ; preds = %if.else.128
  %142 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code133 = getelementptr inbounds %struct.scheme, %struct.scheme* %142, i32 0, i32 9
  %143 = load %struct.cell*, %struct.cell** %code133, align 8
  %_object134 = getelementptr inbounds %struct.cell, %struct.cell* %143, i32 0, i32 1
  %_cons135 = bitcast %union.anon* %_object134 to %struct.anon.4*
  %_car136 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons135, i32 0, i32 0
  %144 = load %struct.cell*, %struct.cell** %_car136, align 8
  store %struct.cell* %144, %struct.cell** %x, align 8
  %call137 = call i32 @is_syntax(%struct.cell* %144)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then.139, label %if.else.149

if.then.139:                                      ; preds = %if.then.132
  %145 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code140 = getelementptr inbounds %struct.scheme, %struct.scheme* %145, i32 0, i32 9
  %146 = load %struct.cell*, %struct.cell** %code140, align 8
  %_object141 = getelementptr inbounds %struct.cell, %struct.cell* %146, i32 0, i32 1
  %_cons142 = bitcast %union.anon* %_object141 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons142, i32 0, i32 1
  %147 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %148 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code143 = getelementptr inbounds %struct.scheme, %struct.scheme* %148, i32 0, i32 9
  store %struct.cell* %147, %struct.cell** %code143, align 8
  br label %do.body.144

do.body.144:                                      ; preds = %if.then.139
  %149 = load %struct.cell*, %struct.cell** %x, align 8
  %call145 = call i32 @syntaxnum(%struct.cell* %149)
  %150 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op146 = getelementptr inbounds %struct.scheme, %struct.scheme* %150, i32 0, i32 55
  store i32 %call145, i32* %op146, align 4
  %151 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T147 = getelementptr inbounds %struct.scheme, %struct.scheme* %151, i32 0, i32 19
  %152 = load %struct.cell*, %struct.cell** %T147, align 8
  store %struct.cell* %152, %struct.cell** %retval
  br label %return

do.end.148:                                       ; No predecessors!
  br label %if.end.161

if.else.149:                                      ; preds = %if.then.132
  %153 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %154 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL150 = getelementptr inbounds %struct.scheme, %struct.scheme* %154, i32 0, i32 17
  %155 = load %struct.cell*, %struct.cell** %NIL150, align 8
  %156 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code151 = getelementptr inbounds %struct.scheme, %struct.scheme* %156, i32 0, i32 9
  %157 = load %struct.cell*, %struct.cell** %code151, align 8
  call void @s_save(%struct.scheme* %153, i32 8, %struct.cell* %155, %struct.cell* %157)
  %158 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code152 = getelementptr inbounds %struct.scheme, %struct.scheme* %158, i32 0, i32 9
  %159 = load %struct.cell*, %struct.cell** %code152, align 8
  %_object153 = getelementptr inbounds %struct.cell, %struct.cell* %159, i32 0, i32 1
  %_cons154 = bitcast %union.anon* %_object153 to %struct.anon.4*
  %_car155 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons154, i32 0, i32 0
  %160 = load %struct.cell*, %struct.cell** %_car155, align 8
  %161 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code156 = getelementptr inbounds %struct.scheme, %struct.scheme* %161, i32 0, i32 9
  store %struct.cell* %160, %struct.cell** %code156, align 8
  br label %do.body.157

do.body.157:                                      ; preds = %if.else.149
  %162 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op158 = getelementptr inbounds %struct.scheme, %struct.scheme* %162, i32 0, i32 55
  store i32 6, i32* %op158, align 4
  %163 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T159 = getelementptr inbounds %struct.scheme, %struct.scheme* %163, i32 0, i32 19
  %164 = load %struct.cell*, %struct.cell** %T159, align 8
  store %struct.cell* %164, %struct.cell** %retval
  br label %return

do.end.160:                                       ; No predecessors!
  br label %if.end.161

if.end.161:                                       ; preds = %do.end.160, %do.end.148
  br label %if.end.165

if.else.162:                                      ; preds = %if.else.128
  %165 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %166 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code163 = getelementptr inbounds %struct.scheme, %struct.scheme* %166, i32 0, i32 9
  %167 = load %struct.cell*, %struct.cell** %code163, align 8
  %call164 = call %struct.cell* @_s_return(%struct.scheme* %165, %struct.cell* %167)
  store %struct.cell* %call164, %struct.cell** %retval
  br label %return

if.end.165:                                       ; preds = %if.end.161
  br label %if.end.166

if.end.166:                                       ; preds = %if.end.165
  br label %sw.bb.167

sw.bb.167:                                        ; preds = %entry, %if.end.166
  %168 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value168 = getelementptr inbounds %struct.scheme, %struct.scheme* %168, i32 0, i32 54
  %169 = load %struct.cell*, %struct.cell** %value168, align 8
  %call169 = call i32 @is_macro(%struct.cell* %169)
  %tobool170 = icmp ne i32 %call169, 0
  br i1 %tobool170, label %if.then.171, label %if.else.184

if.then.171:                                      ; preds = %sw.bb.167
  %170 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %171 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL172 = getelementptr inbounds %struct.scheme, %struct.scheme* %171, i32 0, i32 17
  %172 = load %struct.cell*, %struct.cell** %NIL172, align 8
  %173 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL173 = getelementptr inbounds %struct.scheme, %struct.scheme* %173, i32 0, i32 17
  %174 = load %struct.cell*, %struct.cell** %NIL173, align 8
  call void @s_save(%struct.scheme* %170, i32 13, %struct.cell* %172, %struct.cell* %174)
  %175 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %176 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code174 = getelementptr inbounds %struct.scheme, %struct.scheme* %176, i32 0, i32 9
  %177 = load %struct.cell*, %struct.cell** %code174, align 8
  %178 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL175 = getelementptr inbounds %struct.scheme, %struct.scheme* %178, i32 0, i32 17
  %179 = load %struct.cell*, %struct.cell** %NIL175, align 8
  %call176 = call %struct.cell* @_cons(%struct.scheme* %175, %struct.cell* %177, %struct.cell* %179, i32 0)
  %180 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args177 = getelementptr inbounds %struct.scheme, %struct.scheme* %180, i32 0, i32 7
  store %struct.cell* %call176, %struct.cell** %args177, align 8
  %181 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value178 = getelementptr inbounds %struct.scheme, %struct.scheme* %181, i32 0, i32 54
  %182 = load %struct.cell*, %struct.cell** %value178, align 8
  %183 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code179 = getelementptr inbounds %struct.scheme, %struct.scheme* %183, i32 0, i32 9
  store %struct.cell* %182, %struct.cell** %code179, align 8
  br label %do.body.180

do.body.180:                                      ; preds = %if.then.171
  %184 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op181 = getelementptr inbounds %struct.scheme, %struct.scheme* %184, i32 0, i32 55
  store i32 10, i32* %op181, align 4
  %185 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T182 = getelementptr inbounds %struct.scheme, %struct.scheme* %185, i32 0, i32 19
  %186 = load %struct.cell*, %struct.cell** %T182, align 8
  store %struct.cell* %186, %struct.cell** %retval
  br label %return

do.end.183:                                       ; No predecessors!
  br label %if.end.194

if.else.184:                                      ; preds = %sw.bb.167
  %187 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code185 = getelementptr inbounds %struct.scheme, %struct.scheme* %187, i32 0, i32 9
  %188 = load %struct.cell*, %struct.cell** %code185, align 8
  %_object186 = getelementptr inbounds %struct.cell, %struct.cell* %188, i32 0, i32 1
  %_cons187 = bitcast %union.anon* %_object186 to %struct.anon.4*
  %_cdr188 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons187, i32 0, i32 1
  %189 = load %struct.cell*, %struct.cell** %_cdr188, align 8
  %190 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code189 = getelementptr inbounds %struct.scheme, %struct.scheme* %190, i32 0, i32 9
  store %struct.cell* %189, %struct.cell** %code189, align 8
  br label %do.body.190

do.body.190:                                      ; preds = %if.else.184
  %191 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op191 = getelementptr inbounds %struct.scheme, %struct.scheme* %191, i32 0, i32 55
  store i32 9, i32* %op191, align 4
  %192 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T192 = getelementptr inbounds %struct.scheme, %struct.scheme* %192, i32 0, i32 19
  %193 = load %struct.cell*, %struct.cell** %T192, align 8
  store %struct.cell* %193, %struct.cell** %retval
  br label %return

do.end.193:                                       ; No predecessors!
  br label %if.end.194

if.end.194:                                       ; preds = %do.end.193, %do.end.183
  br label %sw.bb.195

sw.bb.195:                                        ; preds = %entry, %if.end.194
  %194 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %195 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value196 = getelementptr inbounds %struct.scheme, %struct.scheme* %195, i32 0, i32 54
  %196 = load %struct.cell*, %struct.cell** %value196, align 8
  %197 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args197 = getelementptr inbounds %struct.scheme, %struct.scheme* %197, i32 0, i32 7
  %198 = load %struct.cell*, %struct.cell** %args197, align 8
  %call198 = call %struct.cell* @_cons(%struct.scheme* %194, %struct.cell* %196, %struct.cell* %198, i32 0)
  %199 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args199 = getelementptr inbounds %struct.scheme, %struct.scheme* %199, i32 0, i32 7
  store %struct.cell* %call198, %struct.cell** %args199, align 8
  %200 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code200 = getelementptr inbounds %struct.scheme, %struct.scheme* %200, i32 0, i32 9
  %201 = load %struct.cell*, %struct.cell** %code200, align 8
  %call201 = call i32 @is_pair(%struct.cell* %201)
  %tobool202 = icmp ne i32 %call201, 0
  br i1 %tobool202, label %if.then.203, label %if.else.220

if.then.203:                                      ; preds = %sw.bb.195
  %202 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %203 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args204 = getelementptr inbounds %struct.scheme, %struct.scheme* %203, i32 0, i32 7
  %204 = load %struct.cell*, %struct.cell** %args204, align 8
  %205 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code205 = getelementptr inbounds %struct.scheme, %struct.scheme* %205, i32 0, i32 9
  %206 = load %struct.cell*, %struct.cell** %code205, align 8
  %_object206 = getelementptr inbounds %struct.cell, %struct.cell* %206, i32 0, i32 1
  %_cons207 = bitcast %union.anon* %_object206 to %struct.anon.4*
  %_cdr208 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons207, i32 0, i32 1
  %207 = load %struct.cell*, %struct.cell** %_cdr208, align 8
  call void @s_save(%struct.scheme* %202, i32 9, %struct.cell* %204, %struct.cell* %207)
  %208 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code209 = getelementptr inbounds %struct.scheme, %struct.scheme* %208, i32 0, i32 9
  %209 = load %struct.cell*, %struct.cell** %code209, align 8
  %_object210 = getelementptr inbounds %struct.cell, %struct.cell* %209, i32 0, i32 1
  %_cons211 = bitcast %union.anon* %_object210 to %struct.anon.4*
  %_car212 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons211, i32 0, i32 0
  %210 = load %struct.cell*, %struct.cell** %_car212, align 8
  %211 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code213 = getelementptr inbounds %struct.scheme, %struct.scheme* %211, i32 0, i32 9
  store %struct.cell* %210, %struct.cell** %code213, align 8
  %212 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL214 = getelementptr inbounds %struct.scheme, %struct.scheme* %212, i32 0, i32 17
  %213 = load %struct.cell*, %struct.cell** %NIL214, align 8
  %214 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args215 = getelementptr inbounds %struct.scheme, %struct.scheme* %214, i32 0, i32 7
  store %struct.cell* %213, %struct.cell** %args215, align 8
  br label %do.body.216

do.body.216:                                      ; preds = %if.then.203
  %215 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op217 = getelementptr inbounds %struct.scheme, %struct.scheme* %215, i32 0, i32 55
  store i32 6, i32* %op217, align 4
  %216 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T218 = getelementptr inbounds %struct.scheme, %struct.scheme* %216, i32 0, i32 19
  %217 = load %struct.cell*, %struct.cell** %T218, align 8
  store %struct.cell* %217, %struct.cell** %retval
  br label %return

do.end.219:                                       ; No predecessors!
  br label %if.end.239

if.else.220:                                      ; preds = %sw.bb.195
  %218 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %219 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL221 = getelementptr inbounds %struct.scheme, %struct.scheme* %219, i32 0, i32 17
  %220 = load %struct.cell*, %struct.cell** %NIL221, align 8
  %221 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args222 = getelementptr inbounds %struct.scheme, %struct.scheme* %221, i32 0, i32 7
  %222 = load %struct.cell*, %struct.cell** %args222, align 8
  %call223 = call %struct.cell* @reverse_in_place(%struct.scheme* %218, %struct.cell* %220, %struct.cell* %222)
  %223 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args224 = getelementptr inbounds %struct.scheme, %struct.scheme* %223, i32 0, i32 7
  store %struct.cell* %call223, %struct.cell** %args224, align 8
  %224 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args225 = getelementptr inbounds %struct.scheme, %struct.scheme* %224, i32 0, i32 7
  %225 = load %struct.cell*, %struct.cell** %args225, align 8
  %_object226 = getelementptr inbounds %struct.cell, %struct.cell* %225, i32 0, i32 1
  %_cons227 = bitcast %union.anon* %_object226 to %struct.anon.4*
  %_car228 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons227, i32 0, i32 0
  %226 = load %struct.cell*, %struct.cell** %_car228, align 8
  %227 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code229 = getelementptr inbounds %struct.scheme, %struct.scheme* %227, i32 0, i32 9
  store %struct.cell* %226, %struct.cell** %code229, align 8
  %228 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args230 = getelementptr inbounds %struct.scheme, %struct.scheme* %228, i32 0, i32 7
  %229 = load %struct.cell*, %struct.cell** %args230, align 8
  %_object231 = getelementptr inbounds %struct.cell, %struct.cell* %229, i32 0, i32 1
  %_cons232 = bitcast %union.anon* %_object231 to %struct.anon.4*
  %_cdr233 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons232, i32 0, i32 1
  %230 = load %struct.cell*, %struct.cell** %_cdr233, align 8
  %231 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args234 = getelementptr inbounds %struct.scheme, %struct.scheme* %231, i32 0, i32 7
  store %struct.cell* %230, %struct.cell** %args234, align 8
  br label %do.body.235

do.body.235:                                      ; preds = %if.else.220
  %232 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op236 = getelementptr inbounds %struct.scheme, %struct.scheme* %232, i32 0, i32 55
  store i32 10, i32* %op236, align 4
  %233 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T237 = getelementptr inbounds %struct.scheme, %struct.scheme* %233, i32 0, i32 19
  %234 = load %struct.cell*, %struct.cell** %T237, align 8
  store %struct.cell* %234, %struct.cell** %retval
  br label %return

do.end.238:                                       ; No predecessors!
  br label %if.end.239

if.end.239:                                       ; preds = %do.end.238, %do.end.219
  br label %sw.bb.240

sw.bb.240:                                        ; preds = %entry, %if.end.239
  %235 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing241 = getelementptr inbounds %struct.scheme, %struct.scheme* %235, i32 0, i32 3
  %236 = load i32, i32* %tracing241, align 4
  store i32 %236, i32* %tr, align 4
  %237 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args242 = getelementptr inbounds %struct.scheme, %struct.scheme* %237, i32 0, i32 7
  %238 = load %struct.cell*, %struct.cell** %args242, align 8
  %_object243 = getelementptr inbounds %struct.cell, %struct.cell* %238, i32 0, i32 1
  %_cons244 = bitcast %union.anon* %_object243 to %struct.anon.4*
  %_car245 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons244, i32 0, i32 0
  %239 = load %struct.cell*, %struct.cell** %_car245, align 8
  %call246 = call i64 @ivalue(%struct.cell* %239)
  %conv247 = trunc i64 %call246 to i32
  %240 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing248 = getelementptr inbounds %struct.scheme, %struct.scheme* %240, i32 0, i32 3
  store i32 %conv247, i32* %tracing248, align 4
  %241 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %242 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %243 = load i32, i32* %tr, align 4
  %conv249 = sext i32 %243 to i64
  %call250 = call %struct.cell* @mk_integer(%struct.scheme* %242, i64 %conv249)
  %call251 = call %struct.cell* @_s_return(%struct.scheme* %241, %struct.cell* %call250)
  store %struct.cell* %call251, %struct.cell** %retval
  br label %return

sw.bb.252:                                        ; preds = %entry
  %244 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tracing253 = getelementptr inbounds %struct.scheme, %struct.scheme* %244, i32 0, i32 3
  %245 = load i32, i32* %tracing253, align 4
  %tobool254 = icmp ne i32 %245, 0
  br i1 %tobool254, label %if.then.255, label %if.end.263

if.then.255:                                      ; preds = %sw.bb.252
  %246 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %247 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args256 = getelementptr inbounds %struct.scheme, %struct.scheme* %247, i32 0, i32 7
  %248 = load %struct.cell*, %struct.cell** %args256, align 8
  %249 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code257 = getelementptr inbounds %struct.scheme, %struct.scheme* %249, i32 0, i32 9
  %250 = load %struct.cell*, %struct.cell** %code257, align 8
  call void @s_save(%struct.scheme* %246, i32 11, %struct.cell* %248, %struct.cell* %250)
  %251 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag258 = getelementptr inbounds %struct.scheme, %struct.scheme* %251, i32 0, i32 53
  store i32 1, i32* %print_flag258, align 4
  %252 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %252, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.178, i32 0, i32 0))
  br label %do.body.259

do.body.259:                                      ; preds = %if.then.255
  %253 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op260 = getelementptr inbounds %struct.scheme, %struct.scheme* %253, i32 0, i32 55
  store i32 172, i32* %op260, align 4
  %254 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T261 = getelementptr inbounds %struct.scheme, %struct.scheme* %254, i32 0, i32 19
  %255 = load %struct.cell*, %struct.cell** %T261, align 8
  store %struct.cell* %255, %struct.cell** %retval
  br label %return

do.end.262:                                       ; No predecessors!
  br label %if.end.263

if.end.263:                                       ; preds = %do.end.262, %sw.bb.252
  br label %sw.bb.264

sw.bb.264:                                        ; preds = %entry, %if.end.263
  %256 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code265 = getelementptr inbounds %struct.scheme, %struct.scheme* %256, i32 0, i32 9
  %257 = load %struct.cell*, %struct.cell** %code265, align 8
  %call266 = call i32 @is_proc(%struct.cell* %257)
  %tobool267 = icmp ne i32 %call266, 0
  br i1 %tobool267, label %if.then.268, label %if.else.276

if.then.268:                                      ; preds = %sw.bb.264
  br label %do.body.269

do.body.269:                                      ; preds = %if.then.268
  %258 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code270 = getelementptr inbounds %struct.scheme, %struct.scheme* %258, i32 0, i32 9
  %259 = load %struct.cell*, %struct.cell** %code270, align 8
  %call271 = call i64 @ivalue(%struct.cell* %259)
  %conv272 = trunc i64 %call271 to i32
  %260 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op273 = getelementptr inbounds %struct.scheme, %struct.scheme* %260, i32 0, i32 55
  store i32 %conv272, i32* %op273, align 4
  %261 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T274 = getelementptr inbounds %struct.scheme, %struct.scheme* %261, i32 0, i32 19
  %262 = load %struct.cell*, %struct.cell** %T274, align 8
  store %struct.cell* %262, %struct.cell** %retval
  br label %return

do.end.275:                                       ; No predecessors!
  br label %if.end.395

if.else.276:                                      ; preds = %sw.bb.264
  %263 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code277 = getelementptr inbounds %struct.scheme, %struct.scheme* %263, i32 0, i32 9
  %264 = load %struct.cell*, %struct.cell** %code277, align 8
  %call278 = call i32 @is_foreign(%struct.cell* %264)
  %tobool279 = icmp ne i32 %call278, 0
  br i1 %tobool279, label %if.then.280, label %if.else.306

if.then.280:                                      ; preds = %if.else.276
  %265 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %266 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args281 = getelementptr inbounds %struct.scheme, %struct.scheme* %266, i32 0, i32 7
  %267 = load %struct.cell*, %struct.cell** %args281, align 8
  %268 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL282 = getelementptr inbounds %struct.scheme, %struct.scheme* %268, i32 0, i32 17
  %269 = load %struct.cell*, %struct.cell** %NIL282, align 8
  call void @push_recent_alloc(%struct.scheme* %265, %struct.cell* %267, %struct.cell* %269)
  %270 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL283 = getelementptr inbounds %struct.scheme, %struct.scheme* %270, i32 0, i32 17
  %271 = load %struct.cell*, %struct.cell** %NIL283, align 8
  %272 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %foreign_error = getelementptr inbounds %struct.scheme, %struct.scheme* %272, i32 0, i32 11
  store %struct.cell* %271, %struct.cell** %foreign_error, align 8
  %273 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code284 = getelementptr inbounds %struct.scheme, %struct.scheme* %273, i32 0, i32 9
  %274 = load %struct.cell*, %struct.cell** %code284, align 8
  %_object285 = getelementptr inbounds %struct.cell, %struct.cell* %274, i32 0, i32 1
  %_ff = bitcast %union.anon* %_object285 to %struct.cell* (%struct.scheme*, %struct.cell*)**
  %275 = load %struct.cell* (%struct.scheme*, %struct.cell*)*, %struct.cell* (%struct.scheme*, %struct.cell*)** %_ff, align 8
  %276 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %277 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args286 = getelementptr inbounds %struct.scheme, %struct.scheme* %277, i32 0, i32 7
  %278 = load %struct.cell*, %struct.cell** %args286, align 8
  %call287 = call %struct.cell* %275(%struct.scheme* %276, %struct.cell* %278)
  store %struct.cell* %call287, %struct.cell** %x, align 8
  %279 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %foreign_error288 = getelementptr inbounds %struct.scheme, %struct.scheme* %279, i32 0, i32 11
  %280 = load %struct.cell*, %struct.cell** %foreign_error288, align 8
  %281 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL289 = getelementptr inbounds %struct.scheme, %struct.scheme* %281, i32 0, i32 17
  %282 = load %struct.cell*, %struct.cell** %NIL289, align 8
  %cmp290 = icmp eq %struct.cell* %280, %282
  br i1 %cmp290, label %if.then.292, label %if.else.294

if.then.292:                                      ; preds = %if.then.280
  %283 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %284 = load %struct.cell*, %struct.cell** %x, align 8
  %call293 = call %struct.cell* @_s_return(%struct.scheme* %283, %struct.cell* %284)
  store %struct.cell* %call293, %struct.cell** %retval
  br label %return

if.else.294:                                      ; preds = %if.then.280
  %285 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %foreign_error295 = getelementptr inbounds %struct.scheme, %struct.scheme* %285, i32 0, i32 11
  %286 = load %struct.cell*, %struct.cell** %foreign_error295, align 8
  store %struct.cell* %286, %struct.cell** %x, align 8
  %287 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL296 = getelementptr inbounds %struct.scheme, %struct.scheme* %287, i32 0, i32 17
  %288 = load %struct.cell*, %struct.cell** %NIL296, align 8
  %289 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %foreign_error297 = getelementptr inbounds %struct.scheme, %struct.scheme* %289, i32 0, i32 11
  store %struct.cell* %288, %struct.cell** %foreign_error297, align 8
  %290 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %291 = load %struct.cell*, %struct.cell** %x, align 8
  %_object298 = getelementptr inbounds %struct.cell, %struct.cell* %291, i32 0, i32 1
  %_cons299 = bitcast %union.anon* %_object298 to %struct.anon.4*
  %_car300 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons299, i32 0, i32 0
  %292 = load %struct.cell*, %struct.cell** %_car300, align 8
  %call301 = call i8* @string_value(%struct.cell* %292)
  %293 = load %struct.cell*, %struct.cell** %x, align 8
  %_object302 = getelementptr inbounds %struct.cell, %struct.cell* %293, i32 0, i32 1
  %_cons303 = bitcast %union.anon* %_object302 to %struct.anon.4*
  %_cdr304 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons303, i32 0, i32 1
  %294 = load %struct.cell*, %struct.cell** %_cdr304, align 8
  %call305 = call %struct.cell* @_Error_1(%struct.scheme* %290, i8* %call301, %struct.cell* %294)
  store %struct.cell* %call305, %struct.cell** %retval
  br label %return

if.else.306:                                      ; preds = %if.else.276
  %295 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code307 = getelementptr inbounds %struct.scheme, %struct.scheme* %295, i32 0, i32 9
  %296 = load %struct.cell*, %struct.cell** %code307, align 8
  %call308 = call i32 @is_closure(%struct.cell* %296)
  %tobool309 = icmp ne i32 %call308, 0
  br i1 %tobool309, label %if.then.318, label %lor.lhs.false.310

lor.lhs.false.310:                                ; preds = %if.else.306
  %297 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code311 = getelementptr inbounds %struct.scheme, %struct.scheme* %297, i32 0, i32 9
  %298 = load %struct.cell*, %struct.cell** %code311, align 8
  %call312 = call i32 @is_macro(%struct.cell* %298)
  %tobool313 = icmp ne i32 %call312, 0
  br i1 %tobool313, label %if.then.318, label %lor.lhs.false.314

lor.lhs.false.314:                                ; preds = %lor.lhs.false.310
  %299 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code315 = getelementptr inbounds %struct.scheme, %struct.scheme* %299, i32 0, i32 9
  %300 = load %struct.cell*, %struct.cell** %code315, align 8
  %call316 = call i32 @is_promise(%struct.cell* %300)
  %tobool317 = icmp ne i32 %call316, 0
  br i1 %tobool317, label %if.then.318, label %if.else.372

if.then.318:                                      ; preds = %lor.lhs.false.314, %lor.lhs.false.310, %if.else.306
  %301 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %302 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code319 = getelementptr inbounds %struct.scheme, %struct.scheme* %302, i32 0, i32 9
  %303 = load %struct.cell*, %struct.cell** %code319, align 8
  %call320 = call %struct.cell* @closure_env(%struct.cell* %303)
  call void @new_frame_in_env(%struct.scheme* %301, %struct.cell* %call320)
  %304 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code321 = getelementptr inbounds %struct.scheme, %struct.scheme* %304, i32 0, i32 9
  %305 = load %struct.cell*, %struct.cell** %code321, align 8
  %call322 = call %struct.cell* @closure_code(%struct.cell* %305)
  %_object323 = getelementptr inbounds %struct.cell, %struct.cell* %call322, i32 0, i32 1
  %_cons324 = bitcast %union.anon* %_object323 to %struct.anon.4*
  %_car325 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons324, i32 0, i32 0
  %306 = load %struct.cell*, %struct.cell** %_car325, align 8
  store %struct.cell* %306, %struct.cell** %x, align 8
  %307 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args326 = getelementptr inbounds %struct.scheme, %struct.scheme* %307, i32 0, i32 7
  %308 = load %struct.cell*, %struct.cell** %args326, align 8
  store %struct.cell* %308, %struct.cell** %y, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.318
  %309 = load %struct.cell*, %struct.cell** %x, align 8
  %call327 = call i32 @is_pair(%struct.cell* %309)
  %tobool328 = icmp ne i32 %call327, 0
  br i1 %tobool328, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %310 = load %struct.cell*, %struct.cell** %y, align 8
  %311 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL329 = getelementptr inbounds %struct.scheme, %struct.scheme* %311, i32 0, i32 17
  %312 = load %struct.cell*, %struct.cell** %NIL329, align 8
  %cmp330 = icmp eq %struct.cell* %310, %312
  br i1 %cmp330, label %if.then.332, label %if.else.334

if.then.332:                                      ; preds = %for.body
  %313 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call333 = call %struct.cell* @_Error_1(%struct.scheme* %313, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.179, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call333, %struct.cell** %retval
  br label %return

if.else.334:                                      ; preds = %for.body
  %314 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %315 = load %struct.cell*, %struct.cell** %x, align 8
  %_object335 = getelementptr inbounds %struct.cell, %struct.cell* %315, i32 0, i32 1
  %_cons336 = bitcast %union.anon* %_object335 to %struct.anon.4*
  %_car337 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons336, i32 0, i32 0
  %316 = load %struct.cell*, %struct.cell** %_car337, align 8
  %317 = load %struct.cell*, %struct.cell** %y, align 8
  %_object338 = getelementptr inbounds %struct.cell, %struct.cell* %317, i32 0, i32 1
  %_cons339 = bitcast %union.anon* %_object338 to %struct.anon.4*
  %_car340 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons339, i32 0, i32 0
  %318 = load %struct.cell*, %struct.cell** %_car340, align 8
  call void @new_slot_in_env(%struct.scheme* %314, %struct.cell* %316, %struct.cell* %318)
  br label %if.end.341

if.end.341:                                       ; preds = %if.else.334
  br label %for.inc

for.inc:                                          ; preds = %if.end.341
  %319 = load %struct.cell*, %struct.cell** %x, align 8
  %_object342 = getelementptr inbounds %struct.cell, %struct.cell* %319, i32 0, i32 1
  %_cons343 = bitcast %union.anon* %_object342 to %struct.anon.4*
  %_cdr344 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons343, i32 0, i32 1
  %320 = load %struct.cell*, %struct.cell** %_cdr344, align 8
  store %struct.cell* %320, %struct.cell** %x, align 8
  %321 = load %struct.cell*, %struct.cell** %y, align 8
  %_object345 = getelementptr inbounds %struct.cell, %struct.cell* %321, i32 0, i32 1
  %_cons346 = bitcast %union.anon* %_object345 to %struct.anon.4*
  %_cdr347 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons346, i32 0, i32 1
  %322 = load %struct.cell*, %struct.cell** %_cdr347, align 8
  store %struct.cell* %322, %struct.cell** %y, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %323 = load %struct.cell*, %struct.cell** %x, align 8
  %324 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL348 = getelementptr inbounds %struct.scheme, %struct.scheme* %324, i32 0, i32 17
  %325 = load %struct.cell*, %struct.cell** %NIL348, align 8
  %cmp349 = icmp eq %struct.cell* %323, %325
  br i1 %cmp349, label %if.then.351, label %if.else.352

if.then.351:                                      ; preds = %for.end
  br label %if.end.359

if.else.352:                                      ; preds = %for.end
  %326 = load %struct.cell*, %struct.cell** %x, align 8
  %call353 = call i32 @is_symbol(%struct.cell* %326)
  %tobool354 = icmp ne i32 %call353, 0
  br i1 %tobool354, label %if.then.355, label %if.else.356

if.then.355:                                      ; preds = %if.else.352
  %327 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %328 = load %struct.cell*, %struct.cell** %x, align 8
  %329 = load %struct.cell*, %struct.cell** %y, align 8
  call void @new_slot_in_env(%struct.scheme* %327, %struct.cell* %328, %struct.cell* %329)
  br label %if.end.358

if.else.356:                                      ; preds = %if.else.352
  %330 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %331 = load %struct.cell*, %struct.cell** %x, align 8
  %call357 = call %struct.cell* @_Error_1(%struct.scheme* %330, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.180, i32 0, i32 0), %struct.cell* %331)
  store %struct.cell* %call357, %struct.cell** %retval
  br label %return

if.end.358:                                       ; preds = %if.then.355
  br label %if.end.359

if.end.359:                                       ; preds = %if.end.358, %if.then.351
  %332 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code360 = getelementptr inbounds %struct.scheme, %struct.scheme* %332, i32 0, i32 9
  %333 = load %struct.cell*, %struct.cell** %code360, align 8
  %call361 = call %struct.cell* @closure_code(%struct.cell* %333)
  %_object362 = getelementptr inbounds %struct.cell, %struct.cell* %call361, i32 0, i32 1
  %_cons363 = bitcast %union.anon* %_object362 to %struct.anon.4*
  %_cdr364 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons363, i32 0, i32 1
  %334 = load %struct.cell*, %struct.cell** %_cdr364, align 8
  %335 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code365 = getelementptr inbounds %struct.scheme, %struct.scheme* %335, i32 0, i32 9
  store %struct.cell* %334, %struct.cell** %code365, align 8
  %336 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL366 = getelementptr inbounds %struct.scheme, %struct.scheme* %336, i32 0, i32 17
  %337 = load %struct.cell*, %struct.cell** %NIL366, align 8
  %338 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args367 = getelementptr inbounds %struct.scheme, %struct.scheme* %338, i32 0, i32 7
  store %struct.cell* %337, %struct.cell** %args367, align 8
  br label %do.body.368

do.body.368:                                      ; preds = %if.end.359
  %339 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op369 = getelementptr inbounds %struct.scheme, %struct.scheme* %339, i32 0, i32 55
  store i32 21, i32* %op369, align 4
  %340 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T370 = getelementptr inbounds %struct.scheme, %struct.scheme* %340, i32 0, i32 19
  %341 = load %struct.cell*, %struct.cell** %T370, align 8
  store %struct.cell* %341, %struct.cell** %retval
  br label %return

do.end.371:                                       ; No predecessors!
  br label %if.end.393

if.else.372:                                      ; preds = %lor.lhs.false.314
  %342 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code373 = getelementptr inbounds %struct.scheme, %struct.scheme* %342, i32 0, i32 9
  %343 = load %struct.cell*, %struct.cell** %code373, align 8
  %call374 = call i32 @is_continuation(%struct.cell* %343)
  %tobool375 = icmp ne i32 %call374, 0
  br i1 %tobool375, label %if.then.376, label %if.else.391

if.then.376:                                      ; preds = %if.else.372
  %344 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code377 = getelementptr inbounds %struct.scheme, %struct.scheme* %344, i32 0, i32 9
  %345 = load %struct.cell*, %struct.cell** %code377, align 8
  %_object378 = getelementptr inbounds %struct.cell, %struct.cell* %345, i32 0, i32 1
  %_cons379 = bitcast %union.anon* %_object378 to %struct.anon.4*
  %_cdr380 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons379, i32 0, i32 1
  %346 = load %struct.cell*, %struct.cell** %_cdr380, align 8
  %347 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %347, i32 0, i32 10
  store %struct.cell* %346, %struct.cell** %dump, align 8
  %348 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %349 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args381 = getelementptr inbounds %struct.scheme, %struct.scheme* %349, i32 0, i32 7
  %350 = load %struct.cell*, %struct.cell** %args381, align 8
  %351 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL382 = getelementptr inbounds %struct.scheme, %struct.scheme* %351, i32 0, i32 17
  %352 = load %struct.cell*, %struct.cell** %NIL382, align 8
  %cmp383 = icmp ne %struct.cell* %350, %352
  br i1 %cmp383, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.376
  %353 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args385 = getelementptr inbounds %struct.scheme, %struct.scheme* %353, i32 0, i32 7
  %354 = load %struct.cell*, %struct.cell** %args385, align 8
  %_object386 = getelementptr inbounds %struct.cell, %struct.cell* %354, i32 0, i32 1
  %_cons387 = bitcast %union.anon* %_object386 to %struct.anon.4*
  %_car388 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons387, i32 0, i32 0
  %355 = load %struct.cell*, %struct.cell** %_car388, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.376
  %356 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL389 = getelementptr inbounds %struct.scheme, %struct.scheme* %356, i32 0, i32 17
  %357 = load %struct.cell*, %struct.cell** %NIL389, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.cell* [ %355, %cond.true ], [ %357, %cond.false ]
  %call390 = call %struct.cell* @_s_return(%struct.scheme* %348, %struct.cell* %cond)
  store %struct.cell* %call390, %struct.cell** %retval
  br label %return

if.else.391:                                      ; preds = %if.else.372
  %358 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call392 = call %struct.cell* @_Error_1(%struct.scheme* %358, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.181, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call392, %struct.cell** %retval
  br label %return

if.end.393:                                       ; preds = %do.end.371
  br label %if.end.394

if.end.394:                                       ; preds = %if.end.393
  br label %if.end.395

if.end.395:                                       ; preds = %if.end.394, %do.end.275
  br label %sw.bb.396

sw.bb.396:                                        ; preds = %entry, %if.end.395
  %359 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value397 = getelementptr inbounds %struct.scheme, %struct.scheme* %359, i32 0, i32 54
  %360 = load %struct.cell*, %struct.cell** %value397, align 8
  %361 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code398 = getelementptr inbounds %struct.scheme, %struct.scheme* %361, i32 0, i32 9
  store %struct.cell* %360, %struct.cell** %code398, align 8
  br label %do.body.399

do.body.399:                                      ; preds = %sw.bb.396
  %362 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op400 = getelementptr inbounds %struct.scheme, %struct.scheme* %362, i32 0, i32 55
  store i32 6, i32* %op400, align 4
  %363 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T401 = getelementptr inbounds %struct.scheme, %struct.scheme* %363, i32 0, i32 19
  %364 = load %struct.cell*, %struct.cell** %T401, align 8
  store %struct.cell* %364, %struct.cell** %retval
  br label %return

do.end.402:                                       ; No predecessors!
  br label %sw.bb.403

sw.bb.403:                                        ; preds = %entry, %do.end.402
  %365 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %366 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir404 = getelementptr inbounds %struct.scheme, %struct.scheme* %366, i32 0, i32 8
  %367 = load %struct.cell*, %struct.cell** %envir404, align 8
  %368 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %COMPILE_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %368, i32 0, i32 36
  %369 = load %struct.cell*, %struct.cell** %COMPILE_HOOK, align 8
  %call405 = call %struct.cell* @find_slot_in_env(%struct.scheme* %365, %struct.cell* %367, %struct.cell* %369, i32 1)
  store %struct.cell* %call405, %struct.cell** %f, align 8
  %370 = load %struct.cell*, %struct.cell** %f, align 8
  %371 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL406 = getelementptr inbounds %struct.scheme, %struct.scheme* %371, i32 0, i32 17
  %372 = load %struct.cell*, %struct.cell** %NIL406, align 8
  %cmp407 = icmp eq %struct.cell* %370, %372
  br i1 %cmp407, label %if.then.409, label %if.else.412

if.then.409:                                      ; preds = %sw.bb.403
  %373 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code410 = getelementptr inbounds %struct.scheme, %struct.scheme* %373, i32 0, i32 9
  %374 = load %struct.cell*, %struct.cell** %code410, align 8
  %375 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value411 = getelementptr inbounds %struct.scheme, %struct.scheme* %375, i32 0, i32 54
  store %struct.cell* %374, %struct.cell** %value411, align 8
  br label %if.end.425

if.else.412:                                      ; preds = %sw.bb.403
  %376 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %377 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args413 = getelementptr inbounds %struct.scheme, %struct.scheme* %377, i32 0, i32 7
  %378 = load %struct.cell*, %struct.cell** %args413, align 8
  %379 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code414 = getelementptr inbounds %struct.scheme, %struct.scheme* %379, i32 0, i32 9
  %380 = load %struct.cell*, %struct.cell** %code414, align 8
  call void @s_save(%struct.scheme* %376, i32 15, %struct.cell* %378, %struct.cell* %380)
  %381 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %382 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code415 = getelementptr inbounds %struct.scheme, %struct.scheme* %382, i32 0, i32 9
  %383 = load %struct.cell*, %struct.cell** %code415, align 8
  %384 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL416 = getelementptr inbounds %struct.scheme, %struct.scheme* %384, i32 0, i32 17
  %385 = load %struct.cell*, %struct.cell** %NIL416, align 8
  %call417 = call %struct.cell* @_cons(%struct.scheme* %381, %struct.cell* %383, %struct.cell* %385, i32 0)
  %386 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args418 = getelementptr inbounds %struct.scheme, %struct.scheme* %386, i32 0, i32 7
  store %struct.cell* %call417, %struct.cell** %args418, align 8
  %387 = load %struct.cell*, %struct.cell** %f, align 8
  %call419 = call %struct.cell* @slot_value_in_env(%struct.cell* %387)
  %388 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code420 = getelementptr inbounds %struct.scheme, %struct.scheme* %388, i32 0, i32 9
  store %struct.cell* %call419, %struct.cell** %code420, align 8
  br label %do.body.421

do.body.421:                                      ; preds = %if.else.412
  %389 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op422 = getelementptr inbounds %struct.scheme, %struct.scheme* %389, i32 0, i32 55
  store i32 10, i32* %op422, align 4
  %390 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T423 = getelementptr inbounds %struct.scheme, %struct.scheme* %390, i32 0, i32 19
  %391 = load %struct.cell*, %struct.cell** %T423, align 8
  store %struct.cell* %391, %struct.cell** %retval
  br label %return

do.end.424:                                       ; No predecessors!
  br label %if.end.425

if.end.425:                                       ; preds = %do.end.424, %if.then.409
  br label %sw.bb.426

sw.bb.426:                                        ; preds = %entry, %if.end.425
  %392 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %393 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %394 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value427 = getelementptr inbounds %struct.scheme, %struct.scheme* %394, i32 0, i32 54
  %395 = load %struct.cell*, %struct.cell** %value427, align 8
  %396 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir428 = getelementptr inbounds %struct.scheme, %struct.scheme* %396, i32 0, i32 8
  %397 = load %struct.cell*, %struct.cell** %envir428, align 8
  %call429 = call %struct.cell* @mk_closure(%struct.scheme* %393, %struct.cell* %395, %struct.cell* %397)
  %call430 = call %struct.cell* @_s_return(%struct.scheme* %392, %struct.cell* %call429)
  store %struct.cell* %call430, %struct.cell** %retval
  br label %return

sw.bb.431:                                        ; preds = %entry
  %398 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args432 = getelementptr inbounds %struct.scheme, %struct.scheme* %398, i32 0, i32 7
  %399 = load %struct.cell*, %struct.cell** %args432, align 8
  %_object433 = getelementptr inbounds %struct.cell, %struct.cell* %399, i32 0, i32 1
  %_cons434 = bitcast %union.anon* %_object433 to %struct.anon.4*
  %_car435 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons434, i32 0, i32 0
  %400 = load %struct.cell*, %struct.cell** %_car435, align 8
  store %struct.cell* %400, %struct.cell** %x, align 8
  %401 = load %struct.cell*, %struct.cell** %x, align 8
  %_object436 = getelementptr inbounds %struct.cell, %struct.cell* %401, i32 0, i32 1
  %_cons437 = bitcast %union.anon* %_object436 to %struct.anon.4*
  %_car438 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons437, i32 0, i32 0
  %402 = load %struct.cell*, %struct.cell** %_car438, align 8
  %403 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA = getelementptr inbounds %struct.scheme, %struct.scheme* %403, i32 0, i32 27
  %404 = load %struct.cell*, %struct.cell** %LAMBDA, align 8
  %cmp439 = icmp eq %struct.cell* %402, %404
  br i1 %cmp439, label %if.then.441, label %if.end.445

if.then.441:                                      ; preds = %sw.bb.431
  %405 = load %struct.cell*, %struct.cell** %x, align 8
  %_object442 = getelementptr inbounds %struct.cell, %struct.cell* %405, i32 0, i32 1
  %_cons443 = bitcast %union.anon* %_object442 to %struct.anon.4*
  %_cdr444 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons443, i32 0, i32 1
  %406 = load %struct.cell*, %struct.cell** %_cdr444, align 8
  store %struct.cell* %406, %struct.cell** %x, align 8
  br label %if.end.445

if.end.445:                                       ; preds = %if.then.441, %sw.bb.431
  %407 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args446 = getelementptr inbounds %struct.scheme, %struct.scheme* %407, i32 0, i32 7
  %408 = load %struct.cell*, %struct.cell** %args446, align 8
  %_object447 = getelementptr inbounds %struct.cell, %struct.cell* %408, i32 0, i32 1
  %_cons448 = bitcast %union.anon* %_object447 to %struct.anon.4*
  %_cdr449 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons448, i32 0, i32 1
  %409 = load %struct.cell*, %struct.cell** %_cdr449, align 8
  %410 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL450 = getelementptr inbounds %struct.scheme, %struct.scheme* %410, i32 0, i32 17
  %411 = load %struct.cell*, %struct.cell** %NIL450, align 8
  %cmp451 = icmp eq %struct.cell* %409, %411
  br i1 %cmp451, label %if.then.453, label %if.else.455

if.then.453:                                      ; preds = %if.end.445
  %412 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir454 = getelementptr inbounds %struct.scheme, %struct.scheme* %412, i32 0, i32 8
  %413 = load %struct.cell*, %struct.cell** %envir454, align 8
  store %struct.cell* %413, %struct.cell** %y, align 8
  br label %if.end.463

if.else.455:                                      ; preds = %if.end.445
  %414 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args456 = getelementptr inbounds %struct.scheme, %struct.scheme* %414, i32 0, i32 7
  %415 = load %struct.cell*, %struct.cell** %args456, align 8
  %_object457 = getelementptr inbounds %struct.cell, %struct.cell* %415, i32 0, i32 1
  %_cons458 = bitcast %union.anon* %_object457 to %struct.anon.4*
  %_cdr459 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons458, i32 0, i32 1
  %416 = load %struct.cell*, %struct.cell** %_cdr459, align 8
  %_object460 = getelementptr inbounds %struct.cell, %struct.cell* %416, i32 0, i32 1
  %_cons461 = bitcast %union.anon* %_object460 to %struct.anon.4*
  %_car462 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons461, i32 0, i32 0
  %417 = load %struct.cell*, %struct.cell** %_car462, align 8
  store %struct.cell* %417, %struct.cell** %y, align 8
  br label %if.end.463

if.end.463:                                       ; preds = %if.else.455, %if.then.453
  %418 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %419 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %420 = load %struct.cell*, %struct.cell** %x, align 8
  %421 = load %struct.cell*, %struct.cell** %y, align 8
  %call464 = call %struct.cell* @mk_closure(%struct.scheme* %419, %struct.cell* %420, %struct.cell* %421)
  %call465 = call %struct.cell* @_s_return(%struct.scheme* %418, %struct.cell* %call464)
  store %struct.cell* %call465, %struct.cell** %retval
  br label %return

sw.bb.466:                                        ; preds = %entry
  %422 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %423 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code467 = getelementptr inbounds %struct.scheme, %struct.scheme* %423, i32 0, i32 9
  %424 = load %struct.cell*, %struct.cell** %code467, align 8
  %_object468 = getelementptr inbounds %struct.cell, %struct.cell* %424, i32 0, i32 1
  %_cons469 = bitcast %union.anon* %_object468 to %struct.anon.4*
  %_car470 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons469, i32 0, i32 0
  %425 = load %struct.cell*, %struct.cell** %_car470, align 8
  %call471 = call %struct.cell* @_s_return(%struct.scheme* %422, %struct.cell* %425)
  store %struct.cell* %call471, %struct.cell** %retval
  br label %return

sw.bb.472:                                        ; preds = %entry
  %426 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code473 = getelementptr inbounds %struct.scheme, %struct.scheme* %426, i32 0, i32 9
  %427 = load %struct.cell*, %struct.cell** %code473, align 8
  %_object474 = getelementptr inbounds %struct.cell, %struct.cell* %427, i32 0, i32 1
  %_cons475 = bitcast %union.anon* %_object474 to %struct.anon.4*
  %_car476 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons475, i32 0, i32 0
  %428 = load %struct.cell*, %struct.cell** %_car476, align 8
  %call477 = call i32 @is_immutable(%struct.cell* %428)
  %tobool478 = icmp ne i32 %call477, 0
  br i1 %tobool478, label %if.then.479, label %if.end.485

if.then.479:                                      ; preds = %sw.bb.472
  %429 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %430 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code480 = getelementptr inbounds %struct.scheme, %struct.scheme* %430, i32 0, i32 9
  %431 = load %struct.cell*, %struct.cell** %code480, align 8
  %_object481 = getelementptr inbounds %struct.cell, %struct.cell* %431, i32 0, i32 1
  %_cons482 = bitcast %union.anon* %_object481 to %struct.anon.4*
  %_car483 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons482, i32 0, i32 0
  %432 = load %struct.cell*, %struct.cell** %_car483, align 8
  %call484 = call %struct.cell* @_Error_1(%struct.scheme* %429, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.182, i32 0, i32 0), %struct.cell* %432)
  store %struct.cell* %call484, %struct.cell** %retval
  br label %return

if.end.485:                                       ; preds = %sw.bb.472
  %433 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code486 = getelementptr inbounds %struct.scheme, %struct.scheme* %433, i32 0, i32 9
  %434 = load %struct.cell*, %struct.cell** %code486, align 8
  %_object487 = getelementptr inbounds %struct.cell, %struct.cell* %434, i32 0, i32 1
  %_cons488 = bitcast %union.anon* %_object487 to %struct.anon.4*
  %_car489 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons488, i32 0, i32 0
  %435 = load %struct.cell*, %struct.cell** %_car489, align 8
  %call490 = call i32 @is_pair(%struct.cell* %435)
  %tobool491 = icmp ne i32 %call490, 0
  br i1 %tobool491, label %if.then.492, label %if.else.515

if.then.492:                                      ; preds = %if.end.485
  %436 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code493 = getelementptr inbounds %struct.scheme, %struct.scheme* %436, i32 0, i32 9
  %437 = load %struct.cell*, %struct.cell** %code493, align 8
  %_object494 = getelementptr inbounds %struct.cell, %struct.cell* %437, i32 0, i32 1
  %_cons495 = bitcast %union.anon* %_object494 to %struct.anon.4*
  %_car496 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons495, i32 0, i32 0
  %438 = load %struct.cell*, %struct.cell** %_car496, align 8
  %_object497 = getelementptr inbounds %struct.cell, %struct.cell* %438, i32 0, i32 1
  %_cons498 = bitcast %union.anon* %_object497 to %struct.anon.4*
  %_car499 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons498, i32 0, i32 0
  %439 = load %struct.cell*, %struct.cell** %_car499, align 8
  store %struct.cell* %439, %struct.cell** %x, align 8
  %440 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %441 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA500 = getelementptr inbounds %struct.scheme, %struct.scheme* %441, i32 0, i32 27
  %442 = load %struct.cell*, %struct.cell** %LAMBDA500, align 8
  %443 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %444 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code501 = getelementptr inbounds %struct.scheme, %struct.scheme* %444, i32 0, i32 9
  %445 = load %struct.cell*, %struct.cell** %code501, align 8
  %_object502 = getelementptr inbounds %struct.cell, %struct.cell* %445, i32 0, i32 1
  %_cons503 = bitcast %union.anon* %_object502 to %struct.anon.4*
  %_car504 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons503, i32 0, i32 0
  %446 = load %struct.cell*, %struct.cell** %_car504, align 8
  %_object505 = getelementptr inbounds %struct.cell, %struct.cell* %446, i32 0, i32 1
  %_cons506 = bitcast %union.anon* %_object505 to %struct.anon.4*
  %_cdr507 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons506, i32 0, i32 1
  %447 = load %struct.cell*, %struct.cell** %_cdr507, align 8
  %448 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code508 = getelementptr inbounds %struct.scheme, %struct.scheme* %448, i32 0, i32 9
  %449 = load %struct.cell*, %struct.cell** %code508, align 8
  %_object509 = getelementptr inbounds %struct.cell, %struct.cell* %449, i32 0, i32 1
  %_cons510 = bitcast %union.anon* %_object509 to %struct.anon.4*
  %_cdr511 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons510, i32 0, i32 1
  %450 = load %struct.cell*, %struct.cell** %_cdr511, align 8
  %call512 = call %struct.cell* @_cons(%struct.scheme* %443, %struct.cell* %447, %struct.cell* %450, i32 0)
  %call513 = call %struct.cell* @_cons(%struct.scheme* %440, %struct.cell* %442, %struct.cell* %call512, i32 0)
  %451 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code514 = getelementptr inbounds %struct.scheme, %struct.scheme* %451, i32 0, i32 9
  store %struct.cell* %call513, %struct.cell** %code514, align 8
  br label %if.end.528

if.else.515:                                      ; preds = %if.end.485
  %452 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code516 = getelementptr inbounds %struct.scheme, %struct.scheme* %452, i32 0, i32 9
  %453 = load %struct.cell*, %struct.cell** %code516, align 8
  %_object517 = getelementptr inbounds %struct.cell, %struct.cell* %453, i32 0, i32 1
  %_cons518 = bitcast %union.anon* %_object517 to %struct.anon.4*
  %_car519 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons518, i32 0, i32 0
  %454 = load %struct.cell*, %struct.cell** %_car519, align 8
  store %struct.cell* %454, %struct.cell** %x, align 8
  %455 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code520 = getelementptr inbounds %struct.scheme, %struct.scheme* %455, i32 0, i32 9
  %456 = load %struct.cell*, %struct.cell** %code520, align 8
  %_object521 = getelementptr inbounds %struct.cell, %struct.cell* %456, i32 0, i32 1
  %_cons522 = bitcast %union.anon* %_object521 to %struct.anon.4*
  %_cdr523 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons522, i32 0, i32 1
  %457 = load %struct.cell*, %struct.cell** %_cdr523, align 8
  %_object524 = getelementptr inbounds %struct.cell, %struct.cell* %457, i32 0, i32 1
  %_cons525 = bitcast %union.anon* %_object524 to %struct.anon.4*
  %_car526 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons525, i32 0, i32 0
  %458 = load %struct.cell*, %struct.cell** %_car526, align 8
  %459 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code527 = getelementptr inbounds %struct.scheme, %struct.scheme* %459, i32 0, i32 9
  store %struct.cell* %458, %struct.cell** %code527, align 8
  br label %if.end.528

if.end.528:                                       ; preds = %if.else.515, %if.then.492
  %460 = load %struct.cell*, %struct.cell** %x, align 8
  %call529 = call i32 @is_symbol(%struct.cell* %460)
  %tobool530 = icmp ne i32 %call529, 0
  br i1 %tobool530, label %if.end.533, label %if.then.531

if.then.531:                                      ; preds = %if.end.528
  %461 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call532 = call %struct.cell* @_Error_1(%struct.scheme* %461, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.183, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call532, %struct.cell** %retval
  br label %return

if.end.533:                                       ; preds = %if.end.528
  %462 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %463 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL534 = getelementptr inbounds %struct.scheme, %struct.scheme* %463, i32 0, i32 17
  %464 = load %struct.cell*, %struct.cell** %NIL534, align 8
  %465 = load %struct.cell*, %struct.cell** %x, align 8
  call void @s_save(%struct.scheme* %462, i32 19, %struct.cell* %464, %struct.cell* %465)
  br label %do.body.535

do.body.535:                                      ; preds = %if.end.533
  %466 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op536 = getelementptr inbounds %struct.scheme, %struct.scheme* %466, i32 0, i32 55
  store i32 6, i32* %op536, align 4
  %467 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T537 = getelementptr inbounds %struct.scheme, %struct.scheme* %467, i32 0, i32 19
  %468 = load %struct.cell*, %struct.cell** %T537, align 8
  store %struct.cell* %468, %struct.cell** %retval
  br label %return

do.end.538:                                       ; No predecessors!
  br label %sw.bb.539

sw.bb.539:                                        ; preds = %entry, %do.end.538
  %469 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %470 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir540 = getelementptr inbounds %struct.scheme, %struct.scheme* %470, i32 0, i32 8
  %471 = load %struct.cell*, %struct.cell** %envir540, align 8
  %472 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code541 = getelementptr inbounds %struct.scheme, %struct.scheme* %472, i32 0, i32 9
  %473 = load %struct.cell*, %struct.cell** %code541, align 8
  %call542 = call %struct.cell* @find_slot_in_env(%struct.scheme* %469, %struct.cell* %471, %struct.cell* %473, i32 0)
  store %struct.cell* %call542, %struct.cell** %x, align 8
  %474 = load %struct.cell*, %struct.cell** %x, align 8
  %475 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL543 = getelementptr inbounds %struct.scheme, %struct.scheme* %475, i32 0, i32 17
  %476 = load %struct.cell*, %struct.cell** %NIL543, align 8
  %cmp544 = icmp ne %struct.cell* %474, %476
  br i1 %cmp544, label %if.then.546, label %if.else.548

if.then.546:                                      ; preds = %sw.bb.539
  %477 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %478 = load %struct.cell*, %struct.cell** %x, align 8
  %479 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value547 = getelementptr inbounds %struct.scheme, %struct.scheme* %479, i32 0, i32 54
  %480 = load %struct.cell*, %struct.cell** %value547, align 8
  call void @set_slot_in_env(%struct.scheme* %477, %struct.cell* %478, %struct.cell* %480)
  br label %if.end.551

if.else.548:                                      ; preds = %sw.bb.539
  %481 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %482 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code549 = getelementptr inbounds %struct.scheme, %struct.scheme* %482, i32 0, i32 9
  %483 = load %struct.cell*, %struct.cell** %code549, align 8
  %484 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value550 = getelementptr inbounds %struct.scheme, %struct.scheme* %484, i32 0, i32 54
  %485 = load %struct.cell*, %struct.cell** %value550, align 8
  call void @new_slot_in_env(%struct.scheme* %481, %struct.cell* %483, %struct.cell* %485)
  br label %if.end.551

if.end.551:                                       ; preds = %if.else.548, %if.then.546
  %486 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %487 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code552 = getelementptr inbounds %struct.scheme, %struct.scheme* %487, i32 0, i32 9
  %488 = load %struct.cell*, %struct.cell** %code552, align 8
  %call553 = call %struct.cell* @_s_return(%struct.scheme* %486, %struct.cell* %488)
  store %struct.cell* %call553, %struct.cell** %retval
  br label %return

sw.bb.554:                                        ; preds = %entry
  %489 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir555 = getelementptr inbounds %struct.scheme, %struct.scheme* %489, i32 0, i32 8
  %490 = load %struct.cell*, %struct.cell** %envir555, align 8
  store %struct.cell* %490, %struct.cell** %x, align 8
  %491 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args556 = getelementptr inbounds %struct.scheme, %struct.scheme* %491, i32 0, i32 7
  %492 = load %struct.cell*, %struct.cell** %args556, align 8
  %_object557 = getelementptr inbounds %struct.cell, %struct.cell* %492, i32 0, i32 1
  %_cons558 = bitcast %union.anon* %_object557 to %struct.anon.4*
  %_cdr559 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons558, i32 0, i32 1
  %493 = load %struct.cell*, %struct.cell** %_cdr559, align 8
  %494 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL560 = getelementptr inbounds %struct.scheme, %struct.scheme* %494, i32 0, i32 17
  %495 = load %struct.cell*, %struct.cell** %NIL560, align 8
  %cmp561 = icmp ne %struct.cell* %493, %495
  br i1 %cmp561, label %if.then.563, label %if.end.571

if.then.563:                                      ; preds = %sw.bb.554
  %496 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args564 = getelementptr inbounds %struct.scheme, %struct.scheme* %496, i32 0, i32 7
  %497 = load %struct.cell*, %struct.cell** %args564, align 8
  %_object565 = getelementptr inbounds %struct.cell, %struct.cell* %497, i32 0, i32 1
  %_cons566 = bitcast %union.anon* %_object565 to %struct.anon.4*
  %_cdr567 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons566, i32 0, i32 1
  %498 = load %struct.cell*, %struct.cell** %_cdr567, align 8
  %_object568 = getelementptr inbounds %struct.cell, %struct.cell* %498, i32 0, i32 1
  %_cons569 = bitcast %union.anon* %_object568 to %struct.anon.4*
  %_car570 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons569, i32 0, i32 0
  %499 = load %struct.cell*, %struct.cell** %_car570, align 8
  store %struct.cell* %499, %struct.cell** %x, align 8
  br label %if.end.571

if.end.571:                                       ; preds = %if.then.563, %sw.bb.554
  %500 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %501 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %502 = load %struct.cell*, %struct.cell** %x, align 8
  %503 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args572 = getelementptr inbounds %struct.scheme, %struct.scheme* %503, i32 0, i32 7
  %504 = load %struct.cell*, %struct.cell** %args572, align 8
  %_object573 = getelementptr inbounds %struct.cell, %struct.cell* %504, i32 0, i32 1
  %_cons574 = bitcast %union.anon* %_object573 to %struct.anon.4*
  %_car575 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons574, i32 0, i32 0
  %505 = load %struct.cell*, %struct.cell** %_car575, align 8
  %call576 = call %struct.cell* @find_slot_in_env(%struct.scheme* %501, %struct.cell* %502, %struct.cell* %505, i32 1)
  %506 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL577 = getelementptr inbounds %struct.scheme, %struct.scheme* %506, i32 0, i32 17
  %507 = load %struct.cell*, %struct.cell** %NIL577, align 8
  %cmp578 = icmp ne %struct.cell* %call576, %507
  br i1 %cmp578, label %cond.true.580, label %cond.false.582

cond.true.580:                                    ; preds = %if.end.571
  %508 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T581 = getelementptr inbounds %struct.scheme, %struct.scheme* %508, i32 0, i32 19
  %509 = load %struct.cell*, %struct.cell** %T581, align 8
  br label %cond.end.583

cond.false.582:                                   ; preds = %if.end.571
  %510 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %510, i32 0, i32 21
  %511 = load %struct.cell*, %struct.cell** %F, align 8
  br label %cond.end.583

cond.end.583:                                     ; preds = %cond.false.582, %cond.true.580
  %cond584 = phi %struct.cell* [ %509, %cond.true.580 ], [ %511, %cond.false.582 ]
  %call585 = call %struct.cell* @_s_return(%struct.scheme* %500, %struct.cell* %cond584)
  store %struct.cell* %call585, %struct.cell** %retval
  br label %return

sw.bb.586:                                        ; preds = %entry
  %512 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code587 = getelementptr inbounds %struct.scheme, %struct.scheme* %512, i32 0, i32 9
  %513 = load %struct.cell*, %struct.cell** %code587, align 8
  %_object588 = getelementptr inbounds %struct.cell, %struct.cell* %513, i32 0, i32 1
  %_cons589 = bitcast %union.anon* %_object588 to %struct.anon.4*
  %_car590 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons589, i32 0, i32 0
  %514 = load %struct.cell*, %struct.cell** %_car590, align 8
  %call591 = call i32 @is_immutable(%struct.cell* %514)
  %tobool592 = icmp ne i32 %call591, 0
  br i1 %tobool592, label %if.then.593, label %if.end.599

if.then.593:                                      ; preds = %sw.bb.586
  %515 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %516 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code594 = getelementptr inbounds %struct.scheme, %struct.scheme* %516, i32 0, i32 9
  %517 = load %struct.cell*, %struct.cell** %code594, align 8
  %_object595 = getelementptr inbounds %struct.cell, %struct.cell* %517, i32 0, i32 1
  %_cons596 = bitcast %union.anon* %_object595 to %struct.anon.4*
  %_car597 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons596, i32 0, i32 0
  %518 = load %struct.cell*, %struct.cell** %_car597, align 8
  %call598 = call %struct.cell* @_Error_1(%struct.scheme* %515, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.184, i32 0, i32 0), %struct.cell* %518)
  store %struct.cell* %call598, %struct.cell** %retval
  br label %return

if.end.599:                                       ; preds = %sw.bb.586
  %519 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %520 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL600 = getelementptr inbounds %struct.scheme, %struct.scheme* %520, i32 0, i32 17
  %521 = load %struct.cell*, %struct.cell** %NIL600, align 8
  %522 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code601 = getelementptr inbounds %struct.scheme, %struct.scheme* %522, i32 0, i32 9
  %523 = load %struct.cell*, %struct.cell** %code601, align 8
  %_object602 = getelementptr inbounds %struct.cell, %struct.cell* %523, i32 0, i32 1
  %_cons603 = bitcast %union.anon* %_object602 to %struct.anon.4*
  %_car604 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons603, i32 0, i32 0
  %524 = load %struct.cell*, %struct.cell** %_car604, align 8
  call void @s_save(%struct.scheme* %519, i32 25, %struct.cell* %521, %struct.cell* %524)
  %525 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code605 = getelementptr inbounds %struct.scheme, %struct.scheme* %525, i32 0, i32 9
  %526 = load %struct.cell*, %struct.cell** %code605, align 8
  %_object606 = getelementptr inbounds %struct.cell, %struct.cell* %526, i32 0, i32 1
  %_cons607 = bitcast %union.anon* %_object606 to %struct.anon.4*
  %_cdr608 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons607, i32 0, i32 1
  %527 = load %struct.cell*, %struct.cell** %_cdr608, align 8
  %_object609 = getelementptr inbounds %struct.cell, %struct.cell* %527, i32 0, i32 1
  %_cons610 = bitcast %union.anon* %_object609 to %struct.anon.4*
  %_car611 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons610, i32 0, i32 0
  %528 = load %struct.cell*, %struct.cell** %_car611, align 8
  %529 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code612 = getelementptr inbounds %struct.scheme, %struct.scheme* %529, i32 0, i32 9
  store %struct.cell* %528, %struct.cell** %code612, align 8
  br label %do.body.613

do.body.613:                                      ; preds = %if.end.599
  %530 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op614 = getelementptr inbounds %struct.scheme, %struct.scheme* %530, i32 0, i32 55
  store i32 6, i32* %op614, align 4
  %531 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T615 = getelementptr inbounds %struct.scheme, %struct.scheme* %531, i32 0, i32 19
  %532 = load %struct.cell*, %struct.cell** %T615, align 8
  store %struct.cell* %532, %struct.cell** %retval
  br label %return

do.end.616:                                       ; No predecessors!
  br label %sw.bb.617

sw.bb.617:                                        ; preds = %entry, %do.end.616
  %533 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %534 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir618 = getelementptr inbounds %struct.scheme, %struct.scheme* %534, i32 0, i32 8
  %535 = load %struct.cell*, %struct.cell** %envir618, align 8
  %536 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code619 = getelementptr inbounds %struct.scheme, %struct.scheme* %536, i32 0, i32 9
  %537 = load %struct.cell*, %struct.cell** %code619, align 8
  %call620 = call %struct.cell* @find_slot_in_env(%struct.scheme* %533, %struct.cell* %535, %struct.cell* %537, i32 1)
  store %struct.cell* %call620, %struct.cell** %y, align 8
  %538 = load %struct.cell*, %struct.cell** %y, align 8
  %539 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL621 = getelementptr inbounds %struct.scheme, %struct.scheme* %539, i32 0, i32 17
  %540 = load %struct.cell*, %struct.cell** %NIL621, align 8
  %cmp622 = icmp ne %struct.cell* %538, %540
  br i1 %cmp622, label %if.then.624, label %if.else.628

if.then.624:                                      ; preds = %sw.bb.617
  %541 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %542 = load %struct.cell*, %struct.cell** %y, align 8
  %543 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value625 = getelementptr inbounds %struct.scheme, %struct.scheme* %543, i32 0, i32 54
  %544 = load %struct.cell*, %struct.cell** %value625, align 8
  call void @set_slot_in_env(%struct.scheme* %541, %struct.cell* %542, %struct.cell* %544)
  %545 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %546 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value626 = getelementptr inbounds %struct.scheme, %struct.scheme* %546, i32 0, i32 54
  %547 = load %struct.cell*, %struct.cell** %value626, align 8
  %call627 = call %struct.cell* @_s_return(%struct.scheme* %545, %struct.cell* %547)
  store %struct.cell* %call627, %struct.cell** %retval
  br label %return

if.else.628:                                      ; preds = %sw.bb.617
  %548 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %549 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code629 = getelementptr inbounds %struct.scheme, %struct.scheme* %549, i32 0, i32 9
  %550 = load %struct.cell*, %struct.cell** %code629, align 8
  %call630 = call %struct.cell* @_Error_1(%struct.scheme* %548, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.185, i32 0, i32 0), %struct.cell* %550)
  store %struct.cell* %call630, %struct.cell** %retval
  br label %return

sw.bb.631:                                        ; preds = %entry
  %551 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code632 = getelementptr inbounds %struct.scheme, %struct.scheme* %551, i32 0, i32 9
  %552 = load %struct.cell*, %struct.cell** %code632, align 8
  %call633 = call i32 @is_pair(%struct.cell* %552)
  %tobool634 = icmp ne i32 %call633, 0
  br i1 %tobool634, label %if.end.638, label %if.then.635

if.then.635:                                      ; preds = %sw.bb.631
  %553 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %554 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code636 = getelementptr inbounds %struct.scheme, %struct.scheme* %554, i32 0, i32 9
  %555 = load %struct.cell*, %struct.cell** %code636, align 8
  %call637 = call %struct.cell* @_s_return(%struct.scheme* %553, %struct.cell* %555)
  store %struct.cell* %call637, %struct.cell** %retval
  br label %return

if.end.638:                                       ; preds = %sw.bb.631
  %556 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code639 = getelementptr inbounds %struct.scheme, %struct.scheme* %556, i32 0, i32 9
  %557 = load %struct.cell*, %struct.cell** %code639, align 8
  %_object640 = getelementptr inbounds %struct.cell, %struct.cell* %557, i32 0, i32 1
  %_cons641 = bitcast %union.anon* %_object640 to %struct.anon.4*
  %_cdr642 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons641, i32 0, i32 1
  %558 = load %struct.cell*, %struct.cell** %_cdr642, align 8
  %559 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL643 = getelementptr inbounds %struct.scheme, %struct.scheme* %559, i32 0, i32 17
  %560 = load %struct.cell*, %struct.cell** %NIL643, align 8
  %cmp644 = icmp ne %struct.cell* %558, %560
  br i1 %cmp644, label %if.then.646, label %if.end.652

if.then.646:                                      ; preds = %if.end.638
  %561 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %562 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL647 = getelementptr inbounds %struct.scheme, %struct.scheme* %562, i32 0, i32 17
  %563 = load %struct.cell*, %struct.cell** %NIL647, align 8
  %564 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code648 = getelementptr inbounds %struct.scheme, %struct.scheme* %564, i32 0, i32 9
  %565 = load %struct.cell*, %struct.cell** %code648, align 8
  %_object649 = getelementptr inbounds %struct.cell, %struct.cell* %565, i32 0, i32 1
  %_cons650 = bitcast %union.anon* %_object649 to %struct.anon.4*
  %_cdr651 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons650, i32 0, i32 1
  %566 = load %struct.cell*, %struct.cell** %_cdr651, align 8
  call void @s_save(%struct.scheme* %561, i32 21, %struct.cell* %563, %struct.cell* %566)
  br label %if.end.652

if.end.652:                                       ; preds = %if.then.646, %if.end.638
  %567 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code653 = getelementptr inbounds %struct.scheme, %struct.scheme* %567, i32 0, i32 9
  %568 = load %struct.cell*, %struct.cell** %code653, align 8
  %_object654 = getelementptr inbounds %struct.cell, %struct.cell* %568, i32 0, i32 1
  %_cons655 = bitcast %union.anon* %_object654 to %struct.anon.4*
  %_car656 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons655, i32 0, i32 0
  %569 = load %struct.cell*, %struct.cell** %_car656, align 8
  %570 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code657 = getelementptr inbounds %struct.scheme, %struct.scheme* %570, i32 0, i32 9
  store %struct.cell* %569, %struct.cell** %code657, align 8
  br label %do.body.658

do.body.658:                                      ; preds = %if.end.652
  %571 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op659 = getelementptr inbounds %struct.scheme, %struct.scheme* %571, i32 0, i32 55
  store i32 6, i32* %op659, align 4
  %572 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T660 = getelementptr inbounds %struct.scheme, %struct.scheme* %572, i32 0, i32 19
  %573 = load %struct.cell*, %struct.cell** %T660, align 8
  store %struct.cell* %573, %struct.cell** %retval
  br label %return

do.end.661:                                       ; No predecessors!
  br label %sw.bb.662

sw.bb.662:                                        ; preds = %entry, %do.end.661
  %574 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %575 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL663 = getelementptr inbounds %struct.scheme, %struct.scheme* %575, i32 0, i32 17
  %576 = load %struct.cell*, %struct.cell** %NIL663, align 8
  %577 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code664 = getelementptr inbounds %struct.scheme, %struct.scheme* %577, i32 0, i32 9
  %578 = load %struct.cell*, %struct.cell** %code664, align 8
  %_object665 = getelementptr inbounds %struct.cell, %struct.cell* %578, i32 0, i32 1
  %_cons666 = bitcast %union.anon* %_object665 to %struct.anon.4*
  %_cdr667 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons666, i32 0, i32 1
  %579 = load %struct.cell*, %struct.cell** %_cdr667, align 8
  call void @s_save(%struct.scheme* %574, i32 23, %struct.cell* %576, %struct.cell* %579)
  %580 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code668 = getelementptr inbounds %struct.scheme, %struct.scheme* %580, i32 0, i32 9
  %581 = load %struct.cell*, %struct.cell** %code668, align 8
  %_object669 = getelementptr inbounds %struct.cell, %struct.cell* %581, i32 0, i32 1
  %_cons670 = bitcast %union.anon* %_object669 to %struct.anon.4*
  %_car671 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons670, i32 0, i32 0
  %582 = load %struct.cell*, %struct.cell** %_car671, align 8
  %583 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code672 = getelementptr inbounds %struct.scheme, %struct.scheme* %583, i32 0, i32 9
  store %struct.cell* %582, %struct.cell** %code672, align 8
  br label %do.body.673

do.body.673:                                      ; preds = %sw.bb.662
  %584 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op674 = getelementptr inbounds %struct.scheme, %struct.scheme* %584, i32 0, i32 55
  store i32 6, i32* %op674, align 4
  %585 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T675 = getelementptr inbounds %struct.scheme, %struct.scheme* %585, i32 0, i32 19
  %586 = load %struct.cell*, %struct.cell** %T675, align 8
  store %struct.cell* %586, %struct.cell** %retval
  br label %return

do.end.676:                                       ; No predecessors!
  br label %sw.bb.677

sw.bb.677:                                        ; preds = %entry, %do.end.676
  %587 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value678 = getelementptr inbounds %struct.scheme, %struct.scheme* %587, i32 0, i32 54
  %588 = load %struct.cell*, %struct.cell** %value678, align 8
  %589 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F679 = getelementptr inbounds %struct.scheme, %struct.scheme* %589, i32 0, i32 21
  %590 = load %struct.cell*, %struct.cell** %F679, align 8
  %cmp680 = icmp ne %struct.cell* %588, %590
  br i1 %cmp680, label %if.then.682, label %if.else.688

if.then.682:                                      ; preds = %sw.bb.677
  %591 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code683 = getelementptr inbounds %struct.scheme, %struct.scheme* %591, i32 0, i32 9
  %592 = load %struct.cell*, %struct.cell** %code683, align 8
  %_object684 = getelementptr inbounds %struct.cell, %struct.cell* %592, i32 0, i32 1
  %_cons685 = bitcast %union.anon* %_object684 to %struct.anon.4*
  %_car686 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons685, i32 0, i32 0
  %593 = load %struct.cell*, %struct.cell** %_car686, align 8
  %594 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code687 = getelementptr inbounds %struct.scheme, %struct.scheme* %594, i32 0, i32 9
  store %struct.cell* %593, %struct.cell** %code687, align 8
  br label %if.end.697

if.else.688:                                      ; preds = %sw.bb.677
  %595 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code689 = getelementptr inbounds %struct.scheme, %struct.scheme* %595, i32 0, i32 9
  %596 = load %struct.cell*, %struct.cell** %code689, align 8
  %_object690 = getelementptr inbounds %struct.cell, %struct.cell* %596, i32 0, i32 1
  %_cons691 = bitcast %union.anon* %_object690 to %struct.anon.4*
  %_cdr692 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons691, i32 0, i32 1
  %597 = load %struct.cell*, %struct.cell** %_cdr692, align 8
  %_object693 = getelementptr inbounds %struct.cell, %struct.cell* %597, i32 0, i32 1
  %_cons694 = bitcast %union.anon* %_object693 to %struct.anon.4*
  %_car695 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons694, i32 0, i32 0
  %598 = load %struct.cell*, %struct.cell** %_car695, align 8
  %599 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code696 = getelementptr inbounds %struct.scheme, %struct.scheme* %599, i32 0, i32 9
  store %struct.cell* %598, %struct.cell** %code696, align 8
  br label %if.end.697

if.end.697:                                       ; preds = %if.else.688, %if.then.682
  br label %do.body.698

do.body.698:                                      ; preds = %if.end.697
  %600 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op699 = getelementptr inbounds %struct.scheme, %struct.scheme* %600, i32 0, i32 55
  store i32 6, i32* %op699, align 4
  %601 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T700 = getelementptr inbounds %struct.scheme, %struct.scheme* %601, i32 0, i32 19
  %602 = load %struct.cell*, %struct.cell** %T700, align 8
  store %struct.cell* %602, %struct.cell** %retval
  br label %return

do.end.701:                                       ; No predecessors!
  br label %sw.bb.702

sw.bb.702:                                        ; preds = %entry, %do.end.701
  %603 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL703 = getelementptr inbounds %struct.scheme, %struct.scheme* %603, i32 0, i32 17
  %604 = load %struct.cell*, %struct.cell** %NIL703, align 8
  %605 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args704 = getelementptr inbounds %struct.scheme, %struct.scheme* %605, i32 0, i32 7
  store %struct.cell* %604, %struct.cell** %args704, align 8
  %606 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code705 = getelementptr inbounds %struct.scheme, %struct.scheme* %606, i32 0, i32 9
  %607 = load %struct.cell*, %struct.cell** %code705, align 8
  %608 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value706 = getelementptr inbounds %struct.scheme, %struct.scheme* %608, i32 0, i32 54
  store %struct.cell* %607, %struct.cell** %value706, align 8
  %609 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code707 = getelementptr inbounds %struct.scheme, %struct.scheme* %609, i32 0, i32 9
  %610 = load %struct.cell*, %struct.cell** %code707, align 8
  %_object708 = getelementptr inbounds %struct.cell, %struct.cell* %610, i32 0, i32 1
  %_cons709 = bitcast %union.anon* %_object708 to %struct.anon.4*
  %_car710 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons709, i32 0, i32 0
  %611 = load %struct.cell*, %struct.cell** %_car710, align 8
  %call711 = call i32 @is_symbol(%struct.cell* %611)
  %tobool712 = icmp ne i32 %call711, 0
  br i1 %tobool712, label %cond.true.713, label %cond.false.721

cond.true.713:                                    ; preds = %sw.bb.702
  %612 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code714 = getelementptr inbounds %struct.scheme, %struct.scheme* %612, i32 0, i32 9
  %613 = load %struct.cell*, %struct.cell** %code714, align 8
  %_object715 = getelementptr inbounds %struct.cell, %struct.cell* %613, i32 0, i32 1
  %_cons716 = bitcast %union.anon* %_object715 to %struct.anon.4*
  %_cdr717 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons716, i32 0, i32 1
  %614 = load %struct.cell*, %struct.cell** %_cdr717, align 8
  %_object718 = getelementptr inbounds %struct.cell, %struct.cell* %614, i32 0, i32 1
  %_cons719 = bitcast %union.anon* %_object718 to %struct.anon.4*
  %_car720 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons719, i32 0, i32 0
  %615 = load %struct.cell*, %struct.cell** %_car720, align 8
  br label %cond.end.726

cond.false.721:                                   ; preds = %sw.bb.702
  %616 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code722 = getelementptr inbounds %struct.scheme, %struct.scheme* %616, i32 0, i32 9
  %617 = load %struct.cell*, %struct.cell** %code722, align 8
  %_object723 = getelementptr inbounds %struct.cell, %struct.cell* %617, i32 0, i32 1
  %_cons724 = bitcast %union.anon* %_object723 to %struct.anon.4*
  %_car725 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons724, i32 0, i32 0
  %618 = load %struct.cell*, %struct.cell** %_car725, align 8
  br label %cond.end.726

cond.end.726:                                     ; preds = %cond.false.721, %cond.true.713
  %cond727 = phi %struct.cell* [ %615, %cond.true.713 ], [ %618, %cond.false.721 ]
  %619 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code728 = getelementptr inbounds %struct.scheme, %struct.scheme* %619, i32 0, i32 9
  store %struct.cell* %cond727, %struct.cell** %code728, align 8
  br label %do.body.729

do.body.729:                                      ; preds = %cond.end.726
  %620 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op730 = getelementptr inbounds %struct.scheme, %struct.scheme* %620, i32 0, i32 55
  store i32 27, i32* %op730, align 4
  %621 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T731 = getelementptr inbounds %struct.scheme, %struct.scheme* %621, i32 0, i32 19
  %622 = load %struct.cell*, %struct.cell** %T731, align 8
  store %struct.cell* %622, %struct.cell** %retval
  br label %return

do.end.732:                                       ; No predecessors!
  br label %sw.bb.733

sw.bb.733:                                        ; preds = %entry, %do.end.732
  %623 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %624 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value734 = getelementptr inbounds %struct.scheme, %struct.scheme* %624, i32 0, i32 54
  %625 = load %struct.cell*, %struct.cell** %value734, align 8
  %626 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args735 = getelementptr inbounds %struct.scheme, %struct.scheme* %626, i32 0, i32 7
  %627 = load %struct.cell*, %struct.cell** %args735, align 8
  %call736 = call %struct.cell* @_cons(%struct.scheme* %623, %struct.cell* %625, %struct.cell* %627, i32 0)
  %628 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args737 = getelementptr inbounds %struct.scheme, %struct.scheme* %628, i32 0, i32 7
  store %struct.cell* %call736, %struct.cell** %args737, align 8
  %629 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code738 = getelementptr inbounds %struct.scheme, %struct.scheme* %629, i32 0, i32 9
  %630 = load %struct.cell*, %struct.cell** %code738, align 8
  %call739 = call i32 @is_pair(%struct.cell* %630)
  %tobool740 = icmp ne i32 %call739, 0
  br i1 %tobool740, label %if.then.741, label %if.else.787

if.then.741:                                      ; preds = %sw.bb.733
  %631 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code742 = getelementptr inbounds %struct.scheme, %struct.scheme* %631, i32 0, i32 9
  %632 = load %struct.cell*, %struct.cell** %code742, align 8
  %_object743 = getelementptr inbounds %struct.cell, %struct.cell* %632, i32 0, i32 1
  %_cons744 = bitcast %union.anon* %_object743 to %struct.anon.4*
  %_car745 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons744, i32 0, i32 0
  %633 = load %struct.cell*, %struct.cell** %_car745, align 8
  %call746 = call i32 @is_pair(%struct.cell* %633)
  %tobool747 = icmp ne i32 %call746, 0
  br i1 %tobool747, label %lor.lhs.false.748, label %if.then.758

lor.lhs.false.748:                                ; preds = %if.then.741
  %634 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code749 = getelementptr inbounds %struct.scheme, %struct.scheme* %634, i32 0, i32 9
  %635 = load %struct.cell*, %struct.cell** %code749, align 8
  %_object750 = getelementptr inbounds %struct.cell, %struct.cell* %635, i32 0, i32 1
  %_cons751 = bitcast %union.anon* %_object750 to %struct.anon.4*
  %_car752 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons751, i32 0, i32 0
  %636 = load %struct.cell*, %struct.cell** %_car752, align 8
  %_object753 = getelementptr inbounds %struct.cell, %struct.cell* %636, i32 0, i32 1
  %_cons754 = bitcast %union.anon* %_object753 to %struct.anon.4*
  %_cdr755 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons754, i32 0, i32 1
  %637 = load %struct.cell*, %struct.cell** %_cdr755, align 8
  %call756 = call i32 @is_pair(%struct.cell* %637)
  %tobool757 = icmp ne i32 %call756, 0
  br i1 %tobool757, label %if.end.764, label %if.then.758

if.then.758:                                      ; preds = %lor.lhs.false.748, %if.then.741
  %638 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %639 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code759 = getelementptr inbounds %struct.scheme, %struct.scheme* %639, i32 0, i32 9
  %640 = load %struct.cell*, %struct.cell** %code759, align 8
  %_object760 = getelementptr inbounds %struct.cell, %struct.cell* %640, i32 0, i32 1
  %_cons761 = bitcast %union.anon* %_object760 to %struct.anon.4*
  %_car762 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons761, i32 0, i32 0
  %641 = load %struct.cell*, %struct.cell** %_car762, align 8
  %call763 = call %struct.cell* @_Error_1(%struct.scheme* %638, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.186, i32 0, i32 0), %struct.cell* %641)
  store %struct.cell* %call763, %struct.cell** %retval
  br label %return

if.end.764:                                       ; preds = %lor.lhs.false.748
  %642 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %643 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args765 = getelementptr inbounds %struct.scheme, %struct.scheme* %643, i32 0, i32 7
  %644 = load %struct.cell*, %struct.cell** %args765, align 8
  %645 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code766 = getelementptr inbounds %struct.scheme, %struct.scheme* %645, i32 0, i32 9
  %646 = load %struct.cell*, %struct.cell** %code766, align 8
  %_object767 = getelementptr inbounds %struct.cell, %struct.cell* %646, i32 0, i32 1
  %_cons768 = bitcast %union.anon* %_object767 to %struct.anon.4*
  %_cdr769 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons768, i32 0, i32 1
  %647 = load %struct.cell*, %struct.cell** %_cdr769, align 8
  call void @s_save(%struct.scheme* %642, i32 27, %struct.cell* %644, %struct.cell* %647)
  %648 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code770 = getelementptr inbounds %struct.scheme, %struct.scheme* %648, i32 0, i32 9
  %649 = load %struct.cell*, %struct.cell** %code770, align 8
  %_object771 = getelementptr inbounds %struct.cell, %struct.cell* %649, i32 0, i32 1
  %_cons772 = bitcast %union.anon* %_object771 to %struct.anon.4*
  %_car773 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons772, i32 0, i32 0
  %650 = load %struct.cell*, %struct.cell** %_car773, align 8
  %_object774 = getelementptr inbounds %struct.cell, %struct.cell* %650, i32 0, i32 1
  %_cons775 = bitcast %union.anon* %_object774 to %struct.anon.4*
  %_cdr776 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons775, i32 0, i32 1
  %651 = load %struct.cell*, %struct.cell** %_cdr776, align 8
  %_object777 = getelementptr inbounds %struct.cell, %struct.cell* %651, i32 0, i32 1
  %_cons778 = bitcast %union.anon* %_object777 to %struct.anon.4*
  %_car779 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons778, i32 0, i32 0
  %652 = load %struct.cell*, %struct.cell** %_car779, align 8
  %653 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code780 = getelementptr inbounds %struct.scheme, %struct.scheme* %653, i32 0, i32 9
  store %struct.cell* %652, %struct.cell** %code780, align 8
  %654 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL781 = getelementptr inbounds %struct.scheme, %struct.scheme* %654, i32 0, i32 17
  %655 = load %struct.cell*, %struct.cell** %NIL781, align 8
  %656 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args782 = getelementptr inbounds %struct.scheme, %struct.scheme* %656, i32 0, i32 7
  store %struct.cell* %655, %struct.cell** %args782, align 8
  br label %do.body.783

do.body.783:                                      ; preds = %if.end.764
  %657 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op784 = getelementptr inbounds %struct.scheme, %struct.scheme* %657, i32 0, i32 55
  store i32 6, i32* %op784, align 4
  %658 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T785 = getelementptr inbounds %struct.scheme, %struct.scheme* %658, i32 0, i32 19
  %659 = load %struct.cell*, %struct.cell** %T785, align 8
  store %struct.cell* %659, %struct.cell** %retval
  br label %return

do.end.786:                                       ; No predecessors!
  br label %if.end.806

if.else.787:                                      ; preds = %sw.bb.733
  %660 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %661 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL788 = getelementptr inbounds %struct.scheme, %struct.scheme* %661, i32 0, i32 17
  %662 = load %struct.cell*, %struct.cell** %NIL788, align 8
  %663 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args789 = getelementptr inbounds %struct.scheme, %struct.scheme* %663, i32 0, i32 7
  %664 = load %struct.cell*, %struct.cell** %args789, align 8
  %call790 = call %struct.cell* @reverse_in_place(%struct.scheme* %660, %struct.cell* %662, %struct.cell* %664)
  %665 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args791 = getelementptr inbounds %struct.scheme, %struct.scheme* %665, i32 0, i32 7
  store %struct.cell* %call790, %struct.cell** %args791, align 8
  %666 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args792 = getelementptr inbounds %struct.scheme, %struct.scheme* %666, i32 0, i32 7
  %667 = load %struct.cell*, %struct.cell** %args792, align 8
  %_object793 = getelementptr inbounds %struct.cell, %struct.cell* %667, i32 0, i32 1
  %_cons794 = bitcast %union.anon* %_object793 to %struct.anon.4*
  %_car795 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons794, i32 0, i32 0
  %668 = load %struct.cell*, %struct.cell** %_car795, align 8
  %669 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code796 = getelementptr inbounds %struct.scheme, %struct.scheme* %669, i32 0, i32 9
  store %struct.cell* %668, %struct.cell** %code796, align 8
  %670 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args797 = getelementptr inbounds %struct.scheme, %struct.scheme* %670, i32 0, i32 7
  %671 = load %struct.cell*, %struct.cell** %args797, align 8
  %_object798 = getelementptr inbounds %struct.cell, %struct.cell* %671, i32 0, i32 1
  %_cons799 = bitcast %union.anon* %_object798 to %struct.anon.4*
  %_cdr800 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons799, i32 0, i32 1
  %672 = load %struct.cell*, %struct.cell** %_cdr800, align 8
  %673 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args801 = getelementptr inbounds %struct.scheme, %struct.scheme* %673, i32 0, i32 7
  store %struct.cell* %672, %struct.cell** %args801, align 8
  br label %do.body.802

do.body.802:                                      ; preds = %if.else.787
  %674 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op803 = getelementptr inbounds %struct.scheme, %struct.scheme* %674, i32 0, i32 55
  store i32 28, i32* %op803, align 4
  %675 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T804 = getelementptr inbounds %struct.scheme, %struct.scheme* %675, i32 0, i32 19
  %676 = load %struct.cell*, %struct.cell** %T804, align 8
  store %struct.cell* %676, %struct.cell** %retval
  br label %return

do.end.805:                                       ; No predecessors!
  br label %if.end.806

if.end.806:                                       ; preds = %do.end.805, %do.end.786
  br label %sw.bb.807

sw.bb.807:                                        ; preds = %entry, %if.end.806
  %677 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %678 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir808 = getelementptr inbounds %struct.scheme, %struct.scheme* %678, i32 0, i32 8
  %679 = load %struct.cell*, %struct.cell** %envir808, align 8
  call void @new_frame_in_env(%struct.scheme* %677, %struct.cell* %679)
  %680 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code809 = getelementptr inbounds %struct.scheme, %struct.scheme* %680, i32 0, i32 9
  %681 = load %struct.cell*, %struct.cell** %code809, align 8
  %_object810 = getelementptr inbounds %struct.cell, %struct.cell* %681, i32 0, i32 1
  %_cons811 = bitcast %union.anon* %_object810 to %struct.anon.4*
  %_car812 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons811, i32 0, i32 0
  %682 = load %struct.cell*, %struct.cell** %_car812, align 8
  %call813 = call i32 @is_symbol(%struct.cell* %682)
  %tobool814 = icmp ne i32 %call813, 0
  br i1 %tobool814, label %cond.true.815, label %cond.false.823

cond.true.815:                                    ; preds = %sw.bb.807
  %683 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code816 = getelementptr inbounds %struct.scheme, %struct.scheme* %683, i32 0, i32 9
  %684 = load %struct.cell*, %struct.cell** %code816, align 8
  %_object817 = getelementptr inbounds %struct.cell, %struct.cell* %684, i32 0, i32 1
  %_cons818 = bitcast %union.anon* %_object817 to %struct.anon.4*
  %_cdr819 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons818, i32 0, i32 1
  %685 = load %struct.cell*, %struct.cell** %_cdr819, align 8
  %_object820 = getelementptr inbounds %struct.cell, %struct.cell* %685, i32 0, i32 1
  %_cons821 = bitcast %union.anon* %_object820 to %struct.anon.4*
  %_car822 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons821, i32 0, i32 0
  %686 = load %struct.cell*, %struct.cell** %_car822, align 8
  br label %cond.end.828

cond.false.823:                                   ; preds = %sw.bb.807
  %687 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code824 = getelementptr inbounds %struct.scheme, %struct.scheme* %687, i32 0, i32 9
  %688 = load %struct.cell*, %struct.cell** %code824, align 8
  %_object825 = getelementptr inbounds %struct.cell, %struct.cell* %688, i32 0, i32 1
  %_cons826 = bitcast %union.anon* %_object825 to %struct.anon.4*
  %_car827 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons826, i32 0, i32 0
  %689 = load %struct.cell*, %struct.cell** %_car827, align 8
  br label %cond.end.828

cond.end.828:                                     ; preds = %cond.false.823, %cond.true.815
  %cond829 = phi %struct.cell* [ %686, %cond.true.815 ], [ %689, %cond.false.823 ]
  store %struct.cell* %cond829, %struct.cell** %x, align 8
  %690 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args830 = getelementptr inbounds %struct.scheme, %struct.scheme* %690, i32 0, i32 7
  %691 = load %struct.cell*, %struct.cell** %args830, align 8
  store %struct.cell* %691, %struct.cell** %y, align 8
  br label %for.cond.831

for.cond.831:                                     ; preds = %for.inc.845, %cond.end.828
  %692 = load %struct.cell*, %struct.cell** %y, align 8
  %693 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL832 = getelementptr inbounds %struct.scheme, %struct.scheme* %693, i32 0, i32 17
  %694 = load %struct.cell*, %struct.cell** %NIL832, align 8
  %cmp833 = icmp ne %struct.cell* %692, %694
  br i1 %cmp833, label %for.body.835, label %for.end.852

for.body.835:                                     ; preds = %for.cond.831
  %695 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %696 = load %struct.cell*, %struct.cell** %x, align 8
  %_object836 = getelementptr inbounds %struct.cell, %struct.cell* %696, i32 0, i32 1
  %_cons837 = bitcast %union.anon* %_object836 to %struct.anon.4*
  %_car838 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons837, i32 0, i32 0
  %697 = load %struct.cell*, %struct.cell** %_car838, align 8
  %_object839 = getelementptr inbounds %struct.cell, %struct.cell* %697, i32 0, i32 1
  %_cons840 = bitcast %union.anon* %_object839 to %struct.anon.4*
  %_car841 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons840, i32 0, i32 0
  %698 = load %struct.cell*, %struct.cell** %_car841, align 8
  %699 = load %struct.cell*, %struct.cell** %y, align 8
  %_object842 = getelementptr inbounds %struct.cell, %struct.cell* %699, i32 0, i32 1
  %_cons843 = bitcast %union.anon* %_object842 to %struct.anon.4*
  %_car844 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons843, i32 0, i32 0
  %700 = load %struct.cell*, %struct.cell** %_car844, align 8
  call void @new_slot_in_env(%struct.scheme* %695, %struct.cell* %698, %struct.cell* %700)
  br label %for.inc.845

for.inc.845:                                      ; preds = %for.body.835
  %701 = load %struct.cell*, %struct.cell** %x, align 8
  %_object846 = getelementptr inbounds %struct.cell, %struct.cell* %701, i32 0, i32 1
  %_cons847 = bitcast %union.anon* %_object846 to %struct.anon.4*
  %_cdr848 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons847, i32 0, i32 1
  %702 = load %struct.cell*, %struct.cell** %_cdr848, align 8
  store %struct.cell* %702, %struct.cell** %x, align 8
  %703 = load %struct.cell*, %struct.cell** %y, align 8
  %_object849 = getelementptr inbounds %struct.cell, %struct.cell* %703, i32 0, i32 1
  %_cons850 = bitcast %union.anon* %_object849 to %struct.anon.4*
  %_cdr851 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons850, i32 0, i32 1
  %704 = load %struct.cell*, %struct.cell** %_cdr851, align 8
  store %struct.cell* %704, %struct.cell** %y, align 8
  br label %for.cond.831

for.end.852:                                      ; preds = %for.cond.831
  %705 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code853 = getelementptr inbounds %struct.scheme, %struct.scheme* %705, i32 0, i32 9
  %706 = load %struct.cell*, %struct.cell** %code853, align 8
  %_object854 = getelementptr inbounds %struct.cell, %struct.cell* %706, i32 0, i32 1
  %_cons855 = bitcast %union.anon* %_object854 to %struct.anon.4*
  %_car856 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons855, i32 0, i32 0
  %707 = load %struct.cell*, %struct.cell** %_car856, align 8
  %call857 = call i32 @is_symbol(%struct.cell* %707)
  %tobool858 = icmp ne i32 %call857, 0
  br i1 %tobool858, label %if.then.859, label %if.else.931

if.then.859:                                      ; preds = %for.end.852
  %708 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code860 = getelementptr inbounds %struct.scheme, %struct.scheme* %708, i32 0, i32 9
  %709 = load %struct.cell*, %struct.cell** %code860, align 8
  %_object861 = getelementptr inbounds %struct.cell, %struct.cell* %709, i32 0, i32 1
  %_cons862 = bitcast %union.anon* %_object861 to %struct.anon.4*
  %_cdr863 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons862, i32 0, i32 1
  %710 = load %struct.cell*, %struct.cell** %_cdr863, align 8
  %_object864 = getelementptr inbounds %struct.cell, %struct.cell* %710, i32 0, i32 1
  %_cons865 = bitcast %union.anon* %_object864 to %struct.anon.4*
  %_car866 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons865, i32 0, i32 0
  %711 = load %struct.cell*, %struct.cell** %_car866, align 8
  store %struct.cell* %711, %struct.cell** %x, align 8
  %712 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL867 = getelementptr inbounds %struct.scheme, %struct.scheme* %712, i32 0, i32 17
  %713 = load %struct.cell*, %struct.cell** %NIL867, align 8
  %714 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args868 = getelementptr inbounds %struct.scheme, %struct.scheme* %714, i32 0, i32 7
  store %struct.cell* %713, %struct.cell** %args868, align 8
  br label %for.cond.869

for.cond.869:                                     ; preds = %for.inc.899, %if.then.859
  %715 = load %struct.cell*, %struct.cell** %x, align 8
  %716 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL870 = getelementptr inbounds %struct.scheme, %struct.scheme* %716, i32 0, i32 17
  %717 = load %struct.cell*, %struct.cell** %NIL870, align 8
  %cmp871 = icmp ne %struct.cell* %715, %717
  br i1 %cmp871, label %for.body.873, label %for.end.903

for.body.873:                                     ; preds = %for.cond.869
  %718 = load %struct.cell*, %struct.cell** %x, align 8
  %call874 = call i32 @is_pair(%struct.cell* %718)
  %tobool875 = icmp ne i32 %call874, 0
  br i1 %tobool875, label %if.end.878, label %if.then.876

if.then.876:                                      ; preds = %for.body.873
  %719 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %720 = load %struct.cell*, %struct.cell** %x, align 8
  %call877 = call %struct.cell* @_Error_1(%struct.scheme* %719, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.187, i32 0, i32 0), %struct.cell* %720)
  store %struct.cell* %call877, %struct.cell** %retval
  br label %return

if.end.878:                                       ; preds = %for.body.873
  %721 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %722 = load %struct.cell*, %struct.cell** %x, align 8
  %_object879 = getelementptr inbounds %struct.cell, %struct.cell* %722, i32 0, i32 1
  %_cons880 = bitcast %union.anon* %_object879 to %struct.anon.4*
  %_car881 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons880, i32 0, i32 0
  %723 = load %struct.cell*, %struct.cell** %_car881, align 8
  %call882 = call i32 @is_list(%struct.scheme* %721, %struct.cell* %723)
  %tobool883 = icmp ne i32 %call882, 0
  br i1 %tobool883, label %if.end.889, label %if.then.884

if.then.884:                                      ; preds = %if.end.878
  %724 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %725 = load %struct.cell*, %struct.cell** %x, align 8
  %_object885 = getelementptr inbounds %struct.cell, %struct.cell* %725, i32 0, i32 1
  %_cons886 = bitcast %union.anon* %_object885 to %struct.anon.4*
  %_car887 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons886, i32 0, i32 0
  %726 = load %struct.cell*, %struct.cell** %_car887, align 8
  %call888 = call %struct.cell* @_Error_1(%struct.scheme* %724, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.187, i32 0, i32 0), %struct.cell* %726)
  store %struct.cell* %call888, %struct.cell** %retval
  br label %return

if.end.889:                                       ; preds = %if.end.878
  %727 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %728 = load %struct.cell*, %struct.cell** %x, align 8
  %_object890 = getelementptr inbounds %struct.cell, %struct.cell* %728, i32 0, i32 1
  %_cons891 = bitcast %union.anon* %_object890 to %struct.anon.4*
  %_car892 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons891, i32 0, i32 0
  %729 = load %struct.cell*, %struct.cell** %_car892, align 8
  %_object893 = getelementptr inbounds %struct.cell, %struct.cell* %729, i32 0, i32 1
  %_cons894 = bitcast %union.anon* %_object893 to %struct.anon.4*
  %_car895 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons894, i32 0, i32 0
  %730 = load %struct.cell*, %struct.cell** %_car895, align 8
  %731 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args896 = getelementptr inbounds %struct.scheme, %struct.scheme* %731, i32 0, i32 7
  %732 = load %struct.cell*, %struct.cell** %args896, align 8
  %call897 = call %struct.cell* @_cons(%struct.scheme* %727, %struct.cell* %730, %struct.cell* %732, i32 0)
  %733 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args898 = getelementptr inbounds %struct.scheme, %struct.scheme* %733, i32 0, i32 7
  store %struct.cell* %call897, %struct.cell** %args898, align 8
  br label %for.inc.899

for.inc.899:                                      ; preds = %if.end.889
  %734 = load %struct.cell*, %struct.cell** %x, align 8
  %_object900 = getelementptr inbounds %struct.cell, %struct.cell* %734, i32 0, i32 1
  %_cons901 = bitcast %union.anon* %_object900 to %struct.anon.4*
  %_cdr902 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons901, i32 0, i32 1
  %735 = load %struct.cell*, %struct.cell** %_cdr902, align 8
  store %struct.cell* %735, %struct.cell** %x, align 8
  br label %for.cond.869

for.end.903:                                      ; preds = %for.cond.869
  %736 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %737 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %738 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %739 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL904 = getelementptr inbounds %struct.scheme, %struct.scheme* %739, i32 0, i32 17
  %740 = load %struct.cell*, %struct.cell** %NIL904, align 8
  %741 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args905 = getelementptr inbounds %struct.scheme, %struct.scheme* %741, i32 0, i32 7
  %742 = load %struct.cell*, %struct.cell** %args905, align 8
  %call906 = call %struct.cell* @reverse_in_place(%struct.scheme* %738, %struct.cell* %740, %struct.cell* %742)
  %743 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code907 = getelementptr inbounds %struct.scheme, %struct.scheme* %743, i32 0, i32 9
  %744 = load %struct.cell*, %struct.cell** %code907, align 8
  %_object908 = getelementptr inbounds %struct.cell, %struct.cell* %744, i32 0, i32 1
  %_cons909 = bitcast %union.anon* %_object908 to %struct.anon.4*
  %_cdr910 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons909, i32 0, i32 1
  %745 = load %struct.cell*, %struct.cell** %_cdr910, align 8
  %_object911 = getelementptr inbounds %struct.cell, %struct.cell* %745, i32 0, i32 1
  %_cons912 = bitcast %union.anon* %_object911 to %struct.anon.4*
  %_cdr913 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons912, i32 0, i32 1
  %746 = load %struct.cell*, %struct.cell** %_cdr913, align 8
  %call914 = call %struct.cell* @_cons(%struct.scheme* %737, %struct.cell* %call906, %struct.cell* %746, i32 0)
  %747 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir915 = getelementptr inbounds %struct.scheme, %struct.scheme* %747, i32 0, i32 8
  %748 = load %struct.cell*, %struct.cell** %envir915, align 8
  %call916 = call %struct.cell* @mk_closure(%struct.scheme* %736, %struct.cell* %call914, %struct.cell* %748)
  store %struct.cell* %call916, %struct.cell** %x, align 8
  %749 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %750 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code917 = getelementptr inbounds %struct.scheme, %struct.scheme* %750, i32 0, i32 9
  %751 = load %struct.cell*, %struct.cell** %code917, align 8
  %_object918 = getelementptr inbounds %struct.cell, %struct.cell* %751, i32 0, i32 1
  %_cons919 = bitcast %union.anon* %_object918 to %struct.anon.4*
  %_car920 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons919, i32 0, i32 0
  %752 = load %struct.cell*, %struct.cell** %_car920, align 8
  %753 = load %struct.cell*, %struct.cell** %x, align 8
  call void @new_slot_in_env(%struct.scheme* %749, %struct.cell* %752, %struct.cell* %753)
  %754 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code921 = getelementptr inbounds %struct.scheme, %struct.scheme* %754, i32 0, i32 9
  %755 = load %struct.cell*, %struct.cell** %code921, align 8
  %_object922 = getelementptr inbounds %struct.cell, %struct.cell* %755, i32 0, i32 1
  %_cons923 = bitcast %union.anon* %_object922 to %struct.anon.4*
  %_cdr924 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons923, i32 0, i32 1
  %756 = load %struct.cell*, %struct.cell** %_cdr924, align 8
  %_object925 = getelementptr inbounds %struct.cell, %struct.cell* %756, i32 0, i32 1
  %_cons926 = bitcast %union.anon* %_object925 to %struct.anon.4*
  %_cdr927 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons926, i32 0, i32 1
  %757 = load %struct.cell*, %struct.cell** %_cdr927, align 8
  %758 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code928 = getelementptr inbounds %struct.scheme, %struct.scheme* %758, i32 0, i32 9
  store %struct.cell* %757, %struct.cell** %code928, align 8
  %759 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL929 = getelementptr inbounds %struct.scheme, %struct.scheme* %759, i32 0, i32 17
  %760 = load %struct.cell*, %struct.cell** %NIL929, align 8
  %761 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args930 = getelementptr inbounds %struct.scheme, %struct.scheme* %761, i32 0, i32 7
  store %struct.cell* %760, %struct.cell** %args930, align 8
  br label %if.end.939

if.else.931:                                      ; preds = %for.end.852
  %762 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code932 = getelementptr inbounds %struct.scheme, %struct.scheme* %762, i32 0, i32 9
  %763 = load %struct.cell*, %struct.cell** %code932, align 8
  %_object933 = getelementptr inbounds %struct.cell, %struct.cell* %763, i32 0, i32 1
  %_cons934 = bitcast %union.anon* %_object933 to %struct.anon.4*
  %_cdr935 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons934, i32 0, i32 1
  %764 = load %struct.cell*, %struct.cell** %_cdr935, align 8
  %765 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code936 = getelementptr inbounds %struct.scheme, %struct.scheme* %765, i32 0, i32 9
  store %struct.cell* %764, %struct.cell** %code936, align 8
  %766 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL937 = getelementptr inbounds %struct.scheme, %struct.scheme* %766, i32 0, i32 17
  %767 = load %struct.cell*, %struct.cell** %NIL937, align 8
  %768 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args938 = getelementptr inbounds %struct.scheme, %struct.scheme* %768, i32 0, i32 7
  store %struct.cell* %767, %struct.cell** %args938, align 8
  br label %if.end.939

if.end.939:                                       ; preds = %if.else.931, %for.end.903
  br label %do.body.940

do.body.940:                                      ; preds = %if.end.939
  %769 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op941 = getelementptr inbounds %struct.scheme, %struct.scheme* %769, i32 0, i32 55
  store i32 21, i32* %op941, align 4
  %770 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T942 = getelementptr inbounds %struct.scheme, %struct.scheme* %770, i32 0, i32 19
  %771 = load %struct.cell*, %struct.cell** %T942, align 8
  store %struct.cell* %771, %struct.cell** %retval
  br label %return

do.end.943:                                       ; No predecessors!
  br label %sw.bb.944

sw.bb.944:                                        ; preds = %entry, %do.end.943
  %772 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code945 = getelementptr inbounds %struct.scheme, %struct.scheme* %772, i32 0, i32 9
  %773 = load %struct.cell*, %struct.cell** %code945, align 8
  %_object946 = getelementptr inbounds %struct.cell, %struct.cell* %773, i32 0, i32 1
  %_cons947 = bitcast %union.anon* %_object946 to %struct.anon.4*
  %_car948 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons947, i32 0, i32 0
  %774 = load %struct.cell*, %struct.cell** %_car948, align 8
  %775 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL949 = getelementptr inbounds %struct.scheme, %struct.scheme* %775, i32 0, i32 17
  %776 = load %struct.cell*, %struct.cell** %NIL949, align 8
  %cmp950 = icmp eq %struct.cell* %774, %776
  br i1 %cmp950, label %if.then.952, label %if.end.963

if.then.952:                                      ; preds = %sw.bb.944
  %777 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %778 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir953 = getelementptr inbounds %struct.scheme, %struct.scheme* %778, i32 0, i32 8
  %779 = load %struct.cell*, %struct.cell** %envir953, align 8
  call void @new_frame_in_env(%struct.scheme* %777, %struct.cell* %779)
  %780 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code954 = getelementptr inbounds %struct.scheme, %struct.scheme* %780, i32 0, i32 9
  %781 = load %struct.cell*, %struct.cell** %code954, align 8
  %_object955 = getelementptr inbounds %struct.cell, %struct.cell* %781, i32 0, i32 1
  %_cons956 = bitcast %union.anon* %_object955 to %struct.anon.4*
  %_cdr957 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons956, i32 0, i32 1
  %782 = load %struct.cell*, %struct.cell** %_cdr957, align 8
  %783 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code958 = getelementptr inbounds %struct.scheme, %struct.scheme* %783, i32 0, i32 9
  store %struct.cell* %782, %struct.cell** %code958, align 8
  br label %do.body.959

do.body.959:                                      ; preds = %if.then.952
  %784 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op960 = getelementptr inbounds %struct.scheme, %struct.scheme* %784, i32 0, i32 55
  store i32 21, i32* %op960, align 4
  %785 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T961 = getelementptr inbounds %struct.scheme, %struct.scheme* %785, i32 0, i32 19
  %786 = load %struct.cell*, %struct.cell** %T961, align 8
  store %struct.cell* %786, %struct.cell** %retval
  br label %return

do.end.962:                                       ; No predecessors!
  br label %if.end.963

if.end.963:                                       ; preds = %do.end.962, %sw.bb.944
  %787 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code964 = getelementptr inbounds %struct.scheme, %struct.scheme* %787, i32 0, i32 9
  %788 = load %struct.cell*, %struct.cell** %code964, align 8
  %_object965 = getelementptr inbounds %struct.cell, %struct.cell* %788, i32 0, i32 1
  %_cons966 = bitcast %union.anon* %_object965 to %struct.anon.4*
  %_car967 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons966, i32 0, i32 0
  %789 = load %struct.cell*, %struct.cell** %_car967, align 8
  %call968 = call i32 @is_pair(%struct.cell* %789)
  %tobool969 = icmp ne i32 %call968, 0
  br i1 %tobool969, label %lor.lhs.false.970, label %if.then.993

lor.lhs.false.970:                                ; preds = %if.end.963
  %790 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code971 = getelementptr inbounds %struct.scheme, %struct.scheme* %790, i32 0, i32 9
  %791 = load %struct.cell*, %struct.cell** %code971, align 8
  %_object972 = getelementptr inbounds %struct.cell, %struct.cell* %791, i32 0, i32 1
  %_cons973 = bitcast %union.anon* %_object972 to %struct.anon.4*
  %_car974 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons973, i32 0, i32 0
  %792 = load %struct.cell*, %struct.cell** %_car974, align 8
  %_object975 = getelementptr inbounds %struct.cell, %struct.cell* %792, i32 0, i32 1
  %_cons976 = bitcast %union.anon* %_object975 to %struct.anon.4*
  %_car977 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons976, i32 0, i32 0
  %793 = load %struct.cell*, %struct.cell** %_car977, align 8
  %call978 = call i32 @is_pair(%struct.cell* %793)
  %tobool979 = icmp ne i32 %call978, 0
  br i1 %tobool979, label %lor.lhs.false.980, label %if.then.993

lor.lhs.false.980:                                ; preds = %lor.lhs.false.970
  %794 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code981 = getelementptr inbounds %struct.scheme, %struct.scheme* %794, i32 0, i32 9
  %795 = load %struct.cell*, %struct.cell** %code981, align 8
  %_object982 = getelementptr inbounds %struct.cell, %struct.cell* %795, i32 0, i32 1
  %_cons983 = bitcast %union.anon* %_object982 to %struct.anon.4*
  %_car984 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons983, i32 0, i32 0
  %796 = load %struct.cell*, %struct.cell** %_car984, align 8
  %_object985 = getelementptr inbounds %struct.cell, %struct.cell* %796, i32 0, i32 1
  %_cons986 = bitcast %union.anon* %_object985 to %struct.anon.4*
  %_car987 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons986, i32 0, i32 0
  %797 = load %struct.cell*, %struct.cell** %_car987, align 8
  %_object988 = getelementptr inbounds %struct.cell, %struct.cell* %797, i32 0, i32 1
  %_cons989 = bitcast %union.anon* %_object988 to %struct.anon.4*
  %_cdr990 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons989, i32 0, i32 1
  %798 = load %struct.cell*, %struct.cell** %_cdr990, align 8
  %call991 = call i32 @is_pair(%struct.cell* %798)
  %tobool992 = icmp ne i32 %call991, 0
  br i1 %tobool992, label %if.end.999, label %if.then.993

if.then.993:                                      ; preds = %lor.lhs.false.980, %lor.lhs.false.970, %if.end.963
  %799 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %800 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code994 = getelementptr inbounds %struct.scheme, %struct.scheme* %800, i32 0, i32 9
  %801 = load %struct.cell*, %struct.cell** %code994, align 8
  %_object995 = getelementptr inbounds %struct.cell, %struct.cell* %801, i32 0, i32 1
  %_cons996 = bitcast %union.anon* %_object995 to %struct.anon.4*
  %_car997 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons996, i32 0, i32 0
  %802 = load %struct.cell*, %struct.cell** %_car997, align 8
  %call998 = call %struct.cell* @_Error_1(%struct.scheme* %799, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.188, i32 0, i32 0), %struct.cell* %802)
  store %struct.cell* %call998, %struct.cell** %retval
  br label %return

if.end.999:                                       ; preds = %lor.lhs.false.980
  %803 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %804 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1000 = getelementptr inbounds %struct.scheme, %struct.scheme* %804, i32 0, i32 9
  %805 = load %struct.cell*, %struct.cell** %code1000, align 8
  %_object1001 = getelementptr inbounds %struct.cell, %struct.cell* %805, i32 0, i32 1
  %_cons1002 = bitcast %union.anon* %_object1001 to %struct.anon.4*
  %_cdr1003 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1002, i32 0, i32 1
  %806 = load %struct.cell*, %struct.cell** %_cdr1003, align 8
  %807 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1004 = getelementptr inbounds %struct.scheme, %struct.scheme* %807, i32 0, i32 9
  %808 = load %struct.cell*, %struct.cell** %code1004, align 8
  %_object1005 = getelementptr inbounds %struct.cell, %struct.cell* %808, i32 0, i32 1
  %_cons1006 = bitcast %union.anon* %_object1005 to %struct.anon.4*
  %_car1007 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1006, i32 0, i32 0
  %809 = load %struct.cell*, %struct.cell** %_car1007, align 8
  call void @s_save(%struct.scheme* %803, i32 30, %struct.cell* %806, %struct.cell* %809)
  %810 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1008 = getelementptr inbounds %struct.scheme, %struct.scheme* %810, i32 0, i32 9
  %811 = load %struct.cell*, %struct.cell** %code1008, align 8
  %_object1009 = getelementptr inbounds %struct.cell, %struct.cell* %811, i32 0, i32 1
  %_cons1010 = bitcast %union.anon* %_object1009 to %struct.anon.4*
  %_car1011 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1010, i32 0, i32 0
  %812 = load %struct.cell*, %struct.cell** %_car1011, align 8
  %_object1012 = getelementptr inbounds %struct.cell, %struct.cell* %812, i32 0, i32 1
  %_cons1013 = bitcast %union.anon* %_object1012 to %struct.anon.4*
  %_car1014 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1013, i32 0, i32 0
  %813 = load %struct.cell*, %struct.cell** %_car1014, align 8
  %_object1015 = getelementptr inbounds %struct.cell, %struct.cell* %813, i32 0, i32 1
  %_cons1016 = bitcast %union.anon* %_object1015 to %struct.anon.4*
  %_cdr1017 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1016, i32 0, i32 1
  %814 = load %struct.cell*, %struct.cell** %_cdr1017, align 8
  %_object1018 = getelementptr inbounds %struct.cell, %struct.cell* %814, i32 0, i32 1
  %_cons1019 = bitcast %union.anon* %_object1018 to %struct.anon.4*
  %_car1020 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1019, i32 0, i32 0
  %815 = load %struct.cell*, %struct.cell** %_car1020, align 8
  %816 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1021 = getelementptr inbounds %struct.scheme, %struct.scheme* %816, i32 0, i32 9
  store %struct.cell* %815, %struct.cell** %code1021, align 8
  br label %do.body.1022

do.body.1022:                                     ; preds = %if.end.999
  %817 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1023 = getelementptr inbounds %struct.scheme, %struct.scheme* %817, i32 0, i32 55
  store i32 6, i32* %op1023, align 4
  %818 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T1024 = getelementptr inbounds %struct.scheme, %struct.scheme* %818, i32 0, i32 19
  %819 = load %struct.cell*, %struct.cell** %T1024, align 8
  store %struct.cell* %819, %struct.cell** %retval
  br label %return

do.end.1025:                                      ; No predecessors!
  br label %sw.bb.1026

sw.bb.1026:                                       ; preds = %entry, %do.end.1025
  %820 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %821 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir1027 = getelementptr inbounds %struct.scheme, %struct.scheme* %821, i32 0, i32 8
  %822 = load %struct.cell*, %struct.cell** %envir1027, align 8
  call void @new_frame_in_env(%struct.scheme* %820, %struct.cell* %822)
  br label %do.body.1028

do.body.1028:                                     ; preds = %sw.bb.1026
  %823 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1029 = getelementptr inbounds %struct.scheme, %struct.scheme* %823, i32 0, i32 55
  store i32 31, i32* %op1029, align 4
  %824 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T1030 = getelementptr inbounds %struct.scheme, %struct.scheme* %824, i32 0, i32 19
  %825 = load %struct.cell*, %struct.cell** %T1030, align 8
  store %struct.cell* %825, %struct.cell** %retval
  br label %return

do.end.1031:                                      ; No predecessors!
  br label %sw.bb.1032

sw.bb.1032:                                       ; preds = %entry, %do.end.1031
  %826 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %827 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1033 = getelementptr inbounds %struct.scheme, %struct.scheme* %827, i32 0, i32 9
  %828 = load %struct.cell*, %struct.cell** %code1033, align 8
  %_object1034 = getelementptr inbounds %struct.cell, %struct.cell* %828, i32 0, i32 1
  %_cons1035 = bitcast %union.anon* %_object1034 to %struct.anon.4*
  %_car1036 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1035, i32 0, i32 0
  %829 = load %struct.cell*, %struct.cell** %_car1036, align 8
  %_object1037 = getelementptr inbounds %struct.cell, %struct.cell* %829, i32 0, i32 1
  %_cons1038 = bitcast %union.anon* %_object1037 to %struct.anon.4*
  %_car1039 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1038, i32 0, i32 0
  %830 = load %struct.cell*, %struct.cell** %_car1039, align 8
  %831 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value1040 = getelementptr inbounds %struct.scheme, %struct.scheme* %831, i32 0, i32 54
  %832 = load %struct.cell*, %struct.cell** %value1040, align 8
  call void @new_slot_in_env(%struct.scheme* %826, %struct.cell* %830, %struct.cell* %832)
  %833 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1041 = getelementptr inbounds %struct.scheme, %struct.scheme* %833, i32 0, i32 9
  %834 = load %struct.cell*, %struct.cell** %code1041, align 8
  %_object1042 = getelementptr inbounds %struct.cell, %struct.cell* %834, i32 0, i32 1
  %_cons1043 = bitcast %union.anon* %_object1042 to %struct.anon.4*
  %_cdr1044 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1043, i32 0, i32 1
  %835 = load %struct.cell*, %struct.cell** %_cdr1044, align 8
  %836 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1045 = getelementptr inbounds %struct.scheme, %struct.scheme* %836, i32 0, i32 9
  store %struct.cell* %835, %struct.cell** %code1045, align 8
  %837 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1046 = getelementptr inbounds %struct.scheme, %struct.scheme* %837, i32 0, i32 9
  %838 = load %struct.cell*, %struct.cell** %code1046, align 8
  %call1047 = call i32 @is_pair(%struct.cell* %838)
  %tobool1048 = icmp ne i32 %call1047, 0
  br i1 %tobool1048, label %if.then.1049, label %if.else.1069

if.then.1049:                                     ; preds = %sw.bb.1032
  %839 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %840 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1050 = getelementptr inbounds %struct.scheme, %struct.scheme* %840, i32 0, i32 7
  %841 = load %struct.cell*, %struct.cell** %args1050, align 8
  %842 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1051 = getelementptr inbounds %struct.scheme, %struct.scheme* %842, i32 0, i32 9
  %843 = load %struct.cell*, %struct.cell** %code1051, align 8
  call void @s_save(%struct.scheme* %839, i32 31, %struct.cell* %841, %struct.cell* %843)
  %844 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1052 = getelementptr inbounds %struct.scheme, %struct.scheme* %844, i32 0, i32 9
  %845 = load %struct.cell*, %struct.cell** %code1052, align 8
  %_object1053 = getelementptr inbounds %struct.cell, %struct.cell* %845, i32 0, i32 1
  %_cons1054 = bitcast %union.anon* %_object1053 to %struct.anon.4*
  %_car1055 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1054, i32 0, i32 0
  %846 = load %struct.cell*, %struct.cell** %_car1055, align 8
  %_object1056 = getelementptr inbounds %struct.cell, %struct.cell* %846, i32 0, i32 1
  %_cons1057 = bitcast %union.anon* %_object1056 to %struct.anon.4*
  %_cdr1058 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1057, i32 0, i32 1
  %847 = load %struct.cell*, %struct.cell** %_cdr1058, align 8
  %_object1059 = getelementptr inbounds %struct.cell, %struct.cell* %847, i32 0, i32 1
  %_cons1060 = bitcast %union.anon* %_object1059 to %struct.anon.4*
  %_car1061 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1060, i32 0, i32 0
  %848 = load %struct.cell*, %struct.cell** %_car1061, align 8
  %849 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1062 = getelementptr inbounds %struct.scheme, %struct.scheme* %849, i32 0, i32 9
  store %struct.cell* %848, %struct.cell** %code1062, align 8
  %850 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1063 = getelementptr inbounds %struct.scheme, %struct.scheme* %850, i32 0, i32 17
  %851 = load %struct.cell*, %struct.cell** %NIL1063, align 8
  %852 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1064 = getelementptr inbounds %struct.scheme, %struct.scheme* %852, i32 0, i32 7
  store %struct.cell* %851, %struct.cell** %args1064, align 8
  br label %do.body.1065

do.body.1065:                                     ; preds = %if.then.1049
  %853 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1066 = getelementptr inbounds %struct.scheme, %struct.scheme* %853, i32 0, i32 55
  store i32 6, i32* %op1066, align 4
  %854 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T1067 = getelementptr inbounds %struct.scheme, %struct.scheme* %854, i32 0, i32 19
  %855 = load %struct.cell*, %struct.cell** %T1067, align 8
  store %struct.cell* %855, %struct.cell** %retval
  br label %return

do.end.1068:                                      ; No predecessors!
  br label %if.end.1078

if.else.1069:                                     ; preds = %sw.bb.1032
  %856 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1070 = getelementptr inbounds %struct.scheme, %struct.scheme* %856, i32 0, i32 7
  %857 = load %struct.cell*, %struct.cell** %args1070, align 8
  %858 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1071 = getelementptr inbounds %struct.scheme, %struct.scheme* %858, i32 0, i32 9
  store %struct.cell* %857, %struct.cell** %code1071, align 8
  %859 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1072 = getelementptr inbounds %struct.scheme, %struct.scheme* %859, i32 0, i32 17
  %860 = load %struct.cell*, %struct.cell** %NIL1072, align 8
  %861 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1073 = getelementptr inbounds %struct.scheme, %struct.scheme* %861, i32 0, i32 7
  store %struct.cell* %860, %struct.cell** %args1073, align 8
  br label %do.body.1074

do.body.1074:                                     ; preds = %if.else.1069
  %862 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1075 = getelementptr inbounds %struct.scheme, %struct.scheme* %862, i32 0, i32 55
  store i32 21, i32* %op1075, align 4
  %863 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T1076 = getelementptr inbounds %struct.scheme, %struct.scheme* %863, i32 0, i32 19
  %864 = load %struct.cell*, %struct.cell** %T1076, align 8
  store %struct.cell* %864, %struct.cell** %retval
  br label %return

do.end.1077:                                      ; No predecessors!
  br label %if.end.1078

if.end.1078:                                      ; preds = %do.end.1077, %do.end.1068
  br label %sw.default

sw.default:                                       ; preds = %entry, %if.end.1078
  %865 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %865, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %866 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1079 = getelementptr inbounds %struct.scheme, %struct.scheme* %866, i32 0, i32 55
  %867 = load i32, i32* %op1079, align 4
  %call1080 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %867) #2
  %868 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %869 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff1081 = getelementptr inbounds %struct.scheme, %struct.scheme* %869, i32 0, i32 50
  %arraydecay1082 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff1081, i32 0, i32 0
  %call1083 = call %struct.cell* @_Error_1(%struct.scheme* %868, i8* %arraydecay1082, %struct.cell* null)
  store %struct.cell* %call1083, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default, %do.body.1074, %do.body.1065, %do.body.1028, %do.body.1022, %if.then.993, %do.body.959, %do.body.940, %if.then.884, %if.then.876, %do.body.802, %do.body.783, %if.then.758, %do.body.729, %do.body.698, %do.body.673, %do.body.658, %if.then.635, %if.else.628, %if.then.624, %do.body.613, %if.then.593, %cond.end.583, %if.end.551, %do.body.535, %if.then.531, %if.then.479, %sw.bb.466, %if.end.463, %sw.bb.426, %do.body.421, %do.body.399, %if.else.391, %cond.end, %do.body.368, %if.else.356, %if.then.332, %if.else.294, %if.then.292, %do.body.269, %do.body.259, %sw.bb.240, %do.body.235, %do.body.216, %do.body.190, %do.body.180, %if.else.162, %do.body.157, %do.body.144, %if.else.125, %if.then.122, %do.body.106, %if.else.94, %do.body.90, %sw.bb.77, %do.body.73, %if.then.70, %do.body.61, %do.body.53, %if.else.37, %do.body.33, %do.body, %if.then.13
  %870 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %870
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_1(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 32, label %sw.bb
    i32 33, label %sw.bb.4
    i32 34, label %sw.bb.71
    i32 35, label %sw.bb.104
    i32 36, label %sw.bb.125
    i32 37, label %sw.bb.215
    i32 38, label %sw.bb.222
    i32 39, label %sw.bb.244
    i32 40, label %sw.bb.275
    i32 41, label %sw.bb.297
    i32 42, label %sw.bb.328
    i32 43, label %sw.bb.343
    i32 44, label %sw.bb.355
    i32 45, label %sw.bb.408
    i32 46, label %sw.bb.424
    i32 47, label %sw.bb.439
    i32 48, label %sw.bb.528
    i32 50, label %sw.bb.541
    i32 49, label %sw.bb.557
    i32 51, label %sw.bb.583
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 8
  %3 = load %struct.cell*, %struct.cell** %envir, align 8
  call void @new_frame_in_env(%struct.scheme* %1, %struct.cell* %3)
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 7
  store %struct.cell* %5, %struct.cell** %args, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 9
  %8 = load %struct.cell*, %struct.cell** %code, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 54
  store %struct.cell* %8, %struct.cell** %value, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 9
  %11 = load %struct.cell*, %struct.cell** %code1, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %11, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %12 = load %struct.cell*, %struct.cell** %_car, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code2 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 9
  store %struct.cell* %12, %struct.cell** %code2, align 8
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op3 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 55
  store i32 33, i32* %op3, align 4
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 19
  %16 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %16, %struct.cell** %retval
  br label %return

do.end:                                           ; No predecessors!
  br label %sw.bb.4

sw.bb.4:                                          ; preds = %entry, %do.end
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value5 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 54
  %19 = load %struct.cell*, %struct.cell** %value5, align 8
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args6 = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 7
  %21 = load %struct.cell*, %struct.cell** %args6, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %17, %struct.cell* %19, %struct.cell* %21, i32 0)
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args7 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 7
  store %struct.cell* %call, %struct.cell** %args7, align 8
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code8 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 9
  %24 = load %struct.cell*, %struct.cell** %code8, align 8
  %call9 = call i32 @is_pair(%struct.cell* %24)
  %tobool = icmp ne i32 %call9, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb.4
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code10 = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 9
  %26 = load %struct.cell*, %struct.cell** %code10, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %26, i32 0, i32 1
  %_cons12 = bitcast %union.anon* %_object11 to %struct.anon.4*
  %_car13 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons12, i32 0, i32 0
  %27 = load %struct.cell*, %struct.cell** %_car13, align 8
  %call14 = call i32 @is_pair(%struct.cell* %27)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %lor.lhs.false, label %if.then.24

lor.lhs.false:                                    ; preds = %if.then
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code16 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 9
  %29 = load %struct.cell*, %struct.cell** %code16, align 8
  %_object17 = getelementptr inbounds %struct.cell, %struct.cell* %29, i32 0, i32 1
  %_cons18 = bitcast %union.anon* %_object17 to %struct.anon.4*
  %_car19 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons18, i32 0, i32 0
  %30 = load %struct.cell*, %struct.cell** %_car19, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %30, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  %31 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %call22 = call i32 @is_pair(%struct.cell* %31)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end, label %if.then.24

if.then.24:                                       ; preds = %lor.lhs.false, %if.then
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code25 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 9
  %34 = load %struct.cell*, %struct.cell** %code25, align 8
  %_object26 = getelementptr inbounds %struct.cell, %struct.cell* %34, i32 0, i32 1
  %_cons27 = bitcast %union.anon* %_object26 to %struct.anon.4*
  %_car28 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons27, i32 0, i32 0
  %35 = load %struct.cell*, %struct.cell** %_car28, align 8
  %call29 = call %struct.cell* @_Error_1(%struct.scheme* %32, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.195, i32 0, i32 0), %struct.cell* %35)
  store %struct.cell* %call29, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args30 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 7
  %38 = load %struct.cell*, %struct.cell** %args30, align 8
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code31 = getelementptr inbounds %struct.scheme, %struct.scheme* %39, i32 0, i32 9
  %40 = load %struct.cell*, %struct.cell** %code31, align 8
  %_object32 = getelementptr inbounds %struct.cell, %struct.cell* %40, i32 0, i32 1
  %_cons33 = bitcast %union.anon* %_object32 to %struct.anon.4*
  %_cdr34 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons33, i32 0, i32 1
  %41 = load %struct.cell*, %struct.cell** %_cdr34, align 8
  call void @s_save(%struct.scheme* %36, i32 33, %struct.cell* %38, %struct.cell* %41)
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code35 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 9
  %43 = load %struct.cell*, %struct.cell** %code35, align 8
  %_object36 = getelementptr inbounds %struct.cell, %struct.cell* %43, i32 0, i32 1
  %_cons37 = bitcast %union.anon* %_object36 to %struct.anon.4*
  %_car38 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons37, i32 0, i32 0
  %44 = load %struct.cell*, %struct.cell** %_car38, align 8
  %_object39 = getelementptr inbounds %struct.cell, %struct.cell* %44, i32 0, i32 1
  %_cons40 = bitcast %union.anon* %_object39 to %struct.anon.4*
  %_cdr41 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons40, i32 0, i32 1
  %45 = load %struct.cell*, %struct.cell** %_cdr41, align 8
  %_object42 = getelementptr inbounds %struct.cell, %struct.cell* %45, i32 0, i32 1
  %_cons43 = bitcast %union.anon* %_object42 to %struct.anon.4*
  %_car44 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons43, i32 0, i32 0
  %46 = load %struct.cell*, %struct.cell** %_car44, align 8
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code45 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 9
  store %struct.cell* %46, %struct.cell** %code45, align 8
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL46 = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 17
  %49 = load %struct.cell*, %struct.cell** %NIL46, align 8
  %50 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args47 = getelementptr inbounds %struct.scheme, %struct.scheme* %50, i32 0, i32 7
  store %struct.cell* %49, %struct.cell** %args47, align 8
  br label %do.body.48

do.body.48:                                       ; preds = %if.end
  %51 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op49 = getelementptr inbounds %struct.scheme, %struct.scheme* %51, i32 0, i32 55
  store i32 6, i32* %op49, align 4
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T50 = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 19
  %53 = load %struct.cell*, %struct.cell** %T50, align 8
  store %struct.cell* %53, %struct.cell** %retval
  br label %return

do.end.51:                                        ; No predecessors!
  br label %if.end.70

if.else:                                          ; preds = %sw.bb.4
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %55 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL52 = getelementptr inbounds %struct.scheme, %struct.scheme* %55, i32 0, i32 17
  %56 = load %struct.cell*, %struct.cell** %NIL52, align 8
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args53 = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 7
  %58 = load %struct.cell*, %struct.cell** %args53, align 8
  %call54 = call %struct.cell* @reverse_in_place(%struct.scheme* %54, %struct.cell* %56, %struct.cell* %58)
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args55 = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 7
  store %struct.cell* %call54, %struct.cell** %args55, align 8
  %60 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args56 = getelementptr inbounds %struct.scheme, %struct.scheme* %60, i32 0, i32 7
  %61 = load %struct.cell*, %struct.cell** %args56, align 8
  %_object57 = getelementptr inbounds %struct.cell, %struct.cell* %61, i32 0, i32 1
  %_cons58 = bitcast %union.anon* %_object57 to %struct.anon.4*
  %_car59 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons58, i32 0, i32 0
  %62 = load %struct.cell*, %struct.cell** %_car59, align 8
  %63 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code60 = getelementptr inbounds %struct.scheme, %struct.scheme* %63, i32 0, i32 9
  store %struct.cell* %62, %struct.cell** %code60, align 8
  %64 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args61 = getelementptr inbounds %struct.scheme, %struct.scheme* %64, i32 0, i32 7
  %65 = load %struct.cell*, %struct.cell** %args61, align 8
  %_object62 = getelementptr inbounds %struct.cell, %struct.cell* %65, i32 0, i32 1
  %_cons63 = bitcast %union.anon* %_object62 to %struct.anon.4*
  %_cdr64 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons63, i32 0, i32 1
  %66 = load %struct.cell*, %struct.cell** %_cdr64, align 8
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args65 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 7
  store %struct.cell* %66, %struct.cell** %args65, align 8
  br label %do.body.66

do.body.66:                                       ; preds = %if.else
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op67 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 55
  store i32 34, i32* %op67, align 4
  %69 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T68 = getelementptr inbounds %struct.scheme, %struct.scheme* %69, i32 0, i32 19
  %70 = load %struct.cell*, %struct.cell** %T68, align 8
  store %struct.cell* %70, %struct.cell** %retval
  br label %return

do.end.69:                                        ; No predecessors!
  br label %if.end.70

if.end.70:                                        ; preds = %do.end.69, %do.end.51
  br label %sw.bb.71

sw.bb.71:                                         ; preds = %entry, %if.end.70
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code72 = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 9
  %72 = load %struct.cell*, %struct.cell** %code72, align 8
  %_object73 = getelementptr inbounds %struct.cell, %struct.cell* %72, i32 0, i32 1
  %_cons74 = bitcast %union.anon* %_object73 to %struct.anon.4*
  %_car75 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons74, i32 0, i32 0
  %73 = load %struct.cell*, %struct.cell** %_car75, align 8
  store %struct.cell* %73, %struct.cell** %x, align 8
  %74 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args76 = getelementptr inbounds %struct.scheme, %struct.scheme* %74, i32 0, i32 7
  %75 = load %struct.cell*, %struct.cell** %args76, align 8
  store %struct.cell* %75, %struct.cell** %y, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.71
  %76 = load %struct.cell*, %struct.cell** %y, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL77 = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 17
  %78 = load %struct.cell*, %struct.cell** %NIL77, align 8
  %cmp = icmp ne %struct.cell* %76, %78
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %80 = load %struct.cell*, %struct.cell** %x, align 8
  %_object78 = getelementptr inbounds %struct.cell, %struct.cell* %80, i32 0, i32 1
  %_cons79 = bitcast %union.anon* %_object78 to %struct.anon.4*
  %_car80 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons79, i32 0, i32 0
  %81 = load %struct.cell*, %struct.cell** %_car80, align 8
  %_object81 = getelementptr inbounds %struct.cell, %struct.cell* %81, i32 0, i32 1
  %_cons82 = bitcast %union.anon* %_object81 to %struct.anon.4*
  %_car83 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons82, i32 0, i32 0
  %82 = load %struct.cell*, %struct.cell** %_car83, align 8
  %83 = load %struct.cell*, %struct.cell** %y, align 8
  %_object84 = getelementptr inbounds %struct.cell, %struct.cell* %83, i32 0, i32 1
  %_cons85 = bitcast %union.anon* %_object84 to %struct.anon.4*
  %_car86 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons85, i32 0, i32 0
  %84 = load %struct.cell*, %struct.cell** %_car86, align 8
  call void @new_slot_in_env(%struct.scheme* %79, %struct.cell* %82, %struct.cell* %84)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %85 = load %struct.cell*, %struct.cell** %x, align 8
  %_object87 = getelementptr inbounds %struct.cell, %struct.cell* %85, i32 0, i32 1
  %_cons88 = bitcast %union.anon* %_object87 to %struct.anon.4*
  %_cdr89 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons88, i32 0, i32 1
  %86 = load %struct.cell*, %struct.cell** %_cdr89, align 8
  store %struct.cell* %86, %struct.cell** %x, align 8
  %87 = load %struct.cell*, %struct.cell** %y, align 8
  %_object90 = getelementptr inbounds %struct.cell, %struct.cell* %87, i32 0, i32 1
  %_cons91 = bitcast %union.anon* %_object90 to %struct.anon.4*
  %_cdr92 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons91, i32 0, i32 1
  %88 = load %struct.cell*, %struct.cell** %_cdr92, align 8
  store %struct.cell* %88, %struct.cell** %y, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %89 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code93 = getelementptr inbounds %struct.scheme, %struct.scheme* %89, i32 0, i32 9
  %90 = load %struct.cell*, %struct.cell** %code93, align 8
  %_object94 = getelementptr inbounds %struct.cell, %struct.cell* %90, i32 0, i32 1
  %_cons95 = bitcast %union.anon* %_object94 to %struct.anon.4*
  %_cdr96 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons95, i32 0, i32 1
  %91 = load %struct.cell*, %struct.cell** %_cdr96, align 8
  %92 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code97 = getelementptr inbounds %struct.scheme, %struct.scheme* %92, i32 0, i32 9
  store %struct.cell* %91, %struct.cell** %code97, align 8
  %93 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL98 = getelementptr inbounds %struct.scheme, %struct.scheme* %93, i32 0, i32 17
  %94 = load %struct.cell*, %struct.cell** %NIL98, align 8
  %95 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args99 = getelementptr inbounds %struct.scheme, %struct.scheme* %95, i32 0, i32 7
  store %struct.cell* %94, %struct.cell** %args99, align 8
  br label %do.body.100

do.body.100:                                      ; preds = %for.end
  %96 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op101 = getelementptr inbounds %struct.scheme, %struct.scheme* %96, i32 0, i32 55
  store i32 21, i32* %op101, align 4
  %97 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T102 = getelementptr inbounds %struct.scheme, %struct.scheme* %97, i32 0, i32 19
  %98 = load %struct.cell*, %struct.cell** %T102, align 8
  store %struct.cell* %98, %struct.cell** %retval
  br label %return

do.end.103:                                       ; No predecessors!
  br label %sw.bb.104

sw.bb.104:                                        ; preds = %entry, %do.end.103
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code105 = getelementptr inbounds %struct.scheme, %struct.scheme* %99, i32 0, i32 9
  %100 = load %struct.cell*, %struct.cell** %code105, align 8
  %call106 = call i32 @is_pair(%struct.cell* %100)
  %tobool107 = icmp ne i32 %call106, 0
  br i1 %tobool107, label %if.end.110, label %if.then.108

if.then.108:                                      ; preds = %sw.bb.104
  %101 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call109 = call %struct.cell* @_Error_1(%struct.scheme* %101, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.196, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call109, %struct.cell** %retval
  br label %return

if.end.110:                                       ; preds = %sw.bb.104
  %102 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %103 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL111 = getelementptr inbounds %struct.scheme, %struct.scheme* %103, i32 0, i32 17
  %104 = load %struct.cell*, %struct.cell** %NIL111, align 8
  %105 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code112 = getelementptr inbounds %struct.scheme, %struct.scheme* %105, i32 0, i32 9
  %106 = load %struct.cell*, %struct.cell** %code112, align 8
  call void @s_save(%struct.scheme* %102, i32 36, %struct.cell* %104, %struct.cell* %106)
  %107 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code113 = getelementptr inbounds %struct.scheme, %struct.scheme* %107, i32 0, i32 9
  %108 = load %struct.cell*, %struct.cell** %code113, align 8
  %_object114 = getelementptr inbounds %struct.cell, %struct.cell* %108, i32 0, i32 1
  %_cons115 = bitcast %union.anon* %_object114 to %struct.anon.4*
  %_car116 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons115, i32 0, i32 0
  %109 = load %struct.cell*, %struct.cell** %_car116, align 8
  %_object117 = getelementptr inbounds %struct.cell, %struct.cell* %109, i32 0, i32 1
  %_cons118 = bitcast %union.anon* %_object117 to %struct.anon.4*
  %_car119 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons118, i32 0, i32 0
  %110 = load %struct.cell*, %struct.cell** %_car119, align 8
  %111 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code120 = getelementptr inbounds %struct.scheme, %struct.scheme* %111, i32 0, i32 9
  store %struct.cell* %110, %struct.cell** %code120, align 8
  br label %do.body.121

do.body.121:                                      ; preds = %if.end.110
  %112 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op122 = getelementptr inbounds %struct.scheme, %struct.scheme* %112, i32 0, i32 55
  store i32 6, i32* %op122, align 4
  %113 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T123 = getelementptr inbounds %struct.scheme, %struct.scheme* %113, i32 0, i32 19
  %114 = load %struct.cell*, %struct.cell** %T123, align 8
  store %struct.cell* %114, %struct.cell** %retval
  br label %return

do.end.124:                                       ; No predecessors!
  br label %sw.bb.125

sw.bb.125:                                        ; preds = %entry, %do.end.124
  %115 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value126 = getelementptr inbounds %struct.scheme, %struct.scheme* %115, i32 0, i32 54
  %116 = load %struct.cell*, %struct.cell** %value126, align 8
  %117 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %117, i32 0, i32 21
  %118 = load %struct.cell*, %struct.cell** %F, align 8
  %cmp127 = icmp ne %struct.cell* %116, %118
  br i1 %cmp127, label %if.then.128, label %if.else.187

if.then.128:                                      ; preds = %sw.bb.125
  %119 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code129 = getelementptr inbounds %struct.scheme, %struct.scheme* %119, i32 0, i32 9
  %120 = load %struct.cell*, %struct.cell** %code129, align 8
  %_object130 = getelementptr inbounds %struct.cell, %struct.cell* %120, i32 0, i32 1
  %_cons131 = bitcast %union.anon* %_object130 to %struct.anon.4*
  %_car132 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons131, i32 0, i32 0
  %121 = load %struct.cell*, %struct.cell** %_car132, align 8
  %_object133 = getelementptr inbounds %struct.cell, %struct.cell* %121, i32 0, i32 1
  %_cons134 = bitcast %union.anon* %_object133 to %struct.anon.4*
  %_cdr135 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons134, i32 0, i32 1
  %122 = load %struct.cell*, %struct.cell** %_cdr135, align 8
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code136 = getelementptr inbounds %struct.scheme, %struct.scheme* %123, i32 0, i32 9
  store %struct.cell* %122, %struct.cell** %code136, align 8
  %124 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL137 = getelementptr inbounds %struct.scheme, %struct.scheme* %124, i32 0, i32 17
  %125 = load %struct.cell*, %struct.cell** %NIL137, align 8
  %cmp138 = icmp eq %struct.cell* %122, %125
  br i1 %cmp138, label %if.then.139, label %if.end.142

if.then.139:                                      ; preds = %if.then.128
  %126 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %127 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value140 = getelementptr inbounds %struct.scheme, %struct.scheme* %127, i32 0, i32 54
  %128 = load %struct.cell*, %struct.cell** %value140, align 8
  %call141 = call %struct.cell* @_s_return(%struct.scheme* %126, %struct.cell* %128)
  store %struct.cell* %call141, %struct.cell** %retval
  br label %return

if.end.142:                                       ; preds = %if.then.128
  %129 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code143 = getelementptr inbounds %struct.scheme, %struct.scheme* %129, i32 0, i32 9
  %130 = load %struct.cell*, %struct.cell** %code143, align 8
  %tobool144 = icmp ne %struct.cell* %130, null
  br i1 %tobool144, label %if.end.147, label %if.then.145

if.then.145:                                      ; preds = %if.end.142
  %131 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call146 = call %struct.cell* @_Error_1(%struct.scheme* %131, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.196, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call146, %struct.cell** %retval
  br label %return

if.end.147:                                       ; preds = %if.end.142
  %132 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code148 = getelementptr inbounds %struct.scheme, %struct.scheme* %132, i32 0, i32 9
  %133 = load %struct.cell*, %struct.cell** %code148, align 8
  %_object149 = getelementptr inbounds %struct.cell, %struct.cell* %133, i32 0, i32 1
  %_cons150 = bitcast %union.anon* %_object149 to %struct.anon.4*
  %_car151 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons150, i32 0, i32 0
  %134 = load %struct.cell*, %struct.cell** %_car151, align 8
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %FEED_TO = getelementptr inbounds %struct.scheme, %struct.scheme* %135, i32 0, i32 32
  %136 = load %struct.cell*, %struct.cell** %FEED_TO, align 8
  %cmp152 = icmp eq %struct.cell* %134, %136
  br i1 %cmp152, label %if.then.153, label %if.end.182

if.then.153:                                      ; preds = %if.end.147
  %137 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code154 = getelementptr inbounds %struct.scheme, %struct.scheme* %137, i32 0, i32 9
  %138 = load %struct.cell*, %struct.cell** %code154, align 8
  %_object155 = getelementptr inbounds %struct.cell, %struct.cell* %138, i32 0, i32 1
  %_cons156 = bitcast %union.anon* %_object155 to %struct.anon.4*
  %_cdr157 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons156, i32 0, i32 1
  %139 = load %struct.cell*, %struct.cell** %_cdr157, align 8
  %call158 = call i32 @is_pair(%struct.cell* %139)
  %tobool159 = icmp ne i32 %call158, 0
  br i1 %tobool159, label %if.end.162, label %if.then.160

if.then.160:                                      ; preds = %if.then.153
  %140 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call161 = call %struct.cell* @_Error_1(%struct.scheme* %140, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.196, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call161, %struct.cell** %retval
  br label %return

if.end.162:                                       ; preds = %if.then.153
  %141 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %142 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %142, i32 0, i32 28
  %143 = load %struct.cell*, %struct.cell** %QUOTE, align 8
  %144 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %145 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value163 = getelementptr inbounds %struct.scheme, %struct.scheme* %145, i32 0, i32 54
  %146 = load %struct.cell*, %struct.cell** %value163, align 8
  %147 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL164 = getelementptr inbounds %struct.scheme, %struct.scheme* %147, i32 0, i32 17
  %148 = load %struct.cell*, %struct.cell** %NIL164, align 8
  %call165 = call %struct.cell* @_cons(%struct.scheme* %144, %struct.cell* %146, %struct.cell* %148, i32 0)
  %call166 = call %struct.cell* @_cons(%struct.scheme* %141, %struct.cell* %143, %struct.cell* %call165, i32 0)
  store %struct.cell* %call166, %struct.cell** %x, align 8
  %149 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %150 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code167 = getelementptr inbounds %struct.scheme, %struct.scheme* %150, i32 0, i32 9
  %151 = load %struct.cell*, %struct.cell** %code167, align 8
  %_object168 = getelementptr inbounds %struct.cell, %struct.cell* %151, i32 0, i32 1
  %_cons169 = bitcast %union.anon* %_object168 to %struct.anon.4*
  %_cdr170 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons169, i32 0, i32 1
  %152 = load %struct.cell*, %struct.cell** %_cdr170, align 8
  %_object171 = getelementptr inbounds %struct.cell, %struct.cell* %152, i32 0, i32 1
  %_cons172 = bitcast %union.anon* %_object171 to %struct.anon.4*
  %_car173 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons172, i32 0, i32 0
  %153 = load %struct.cell*, %struct.cell** %_car173, align 8
  %154 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %155 = load %struct.cell*, %struct.cell** %x, align 8
  %156 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL174 = getelementptr inbounds %struct.scheme, %struct.scheme* %156, i32 0, i32 17
  %157 = load %struct.cell*, %struct.cell** %NIL174, align 8
  %call175 = call %struct.cell* @_cons(%struct.scheme* %154, %struct.cell* %155, %struct.cell* %157, i32 0)
  %call176 = call %struct.cell* @_cons(%struct.scheme* %149, %struct.cell* %153, %struct.cell* %call175, i32 0)
  %158 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code177 = getelementptr inbounds %struct.scheme, %struct.scheme* %158, i32 0, i32 9
  store %struct.cell* %call176, %struct.cell** %code177, align 8
  br label %do.body.178

do.body.178:                                      ; preds = %if.end.162
  %159 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op179 = getelementptr inbounds %struct.scheme, %struct.scheme* %159, i32 0, i32 55
  store i32 6, i32* %op179, align 4
  %160 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T180 = getelementptr inbounds %struct.scheme, %struct.scheme* %160, i32 0, i32 19
  %161 = load %struct.cell*, %struct.cell** %T180, align 8
  store %struct.cell* %161, %struct.cell** %retval
  br label %return

do.end.181:                                       ; No predecessors!
  br label %if.end.182

if.end.182:                                       ; preds = %do.end.181, %if.end.147
  br label %do.body.183

do.body.183:                                      ; preds = %if.end.182
  %162 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op184 = getelementptr inbounds %struct.scheme, %struct.scheme* %162, i32 0, i32 55
  store i32 21, i32* %op184, align 4
  %163 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T185 = getelementptr inbounds %struct.scheme, %struct.scheme* %163, i32 0, i32 19
  %164 = load %struct.cell*, %struct.cell** %T185, align 8
  store %struct.cell* %164, %struct.cell** %retval
  br label %return

do.end.186:                                       ; No predecessors!
  br label %if.end.214

if.else.187:                                      ; preds = %sw.bb.125
  %165 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code188 = getelementptr inbounds %struct.scheme, %struct.scheme* %165, i32 0, i32 9
  %166 = load %struct.cell*, %struct.cell** %code188, align 8
  %_object189 = getelementptr inbounds %struct.cell, %struct.cell* %166, i32 0, i32 1
  %_cons190 = bitcast %union.anon* %_object189 to %struct.anon.4*
  %_cdr191 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons190, i32 0, i32 1
  %167 = load %struct.cell*, %struct.cell** %_cdr191, align 8
  %168 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code192 = getelementptr inbounds %struct.scheme, %struct.scheme* %168, i32 0, i32 9
  store %struct.cell* %167, %struct.cell** %code192, align 8
  %169 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL193 = getelementptr inbounds %struct.scheme, %struct.scheme* %169, i32 0, i32 17
  %170 = load %struct.cell*, %struct.cell** %NIL193, align 8
  %cmp194 = icmp eq %struct.cell* %167, %170
  br i1 %cmp194, label %if.then.195, label %if.else.198

if.then.195:                                      ; preds = %if.else.187
  %171 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %172 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL196 = getelementptr inbounds %struct.scheme, %struct.scheme* %172, i32 0, i32 17
  %173 = load %struct.cell*, %struct.cell** %NIL196, align 8
  %call197 = call %struct.cell* @_s_return(%struct.scheme* %171, %struct.cell* %173)
  store %struct.cell* %call197, %struct.cell** %retval
  br label %return

if.else.198:                                      ; preds = %if.else.187
  %174 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %175 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL199 = getelementptr inbounds %struct.scheme, %struct.scheme* %175, i32 0, i32 17
  %176 = load %struct.cell*, %struct.cell** %NIL199, align 8
  %177 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code200 = getelementptr inbounds %struct.scheme, %struct.scheme* %177, i32 0, i32 9
  %178 = load %struct.cell*, %struct.cell** %code200, align 8
  call void @s_save(%struct.scheme* %174, i32 36, %struct.cell* %176, %struct.cell* %178)
  %179 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code201 = getelementptr inbounds %struct.scheme, %struct.scheme* %179, i32 0, i32 9
  %180 = load %struct.cell*, %struct.cell** %code201, align 8
  %_object202 = getelementptr inbounds %struct.cell, %struct.cell* %180, i32 0, i32 1
  %_cons203 = bitcast %union.anon* %_object202 to %struct.anon.4*
  %_car204 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons203, i32 0, i32 0
  %181 = load %struct.cell*, %struct.cell** %_car204, align 8
  %_object205 = getelementptr inbounds %struct.cell, %struct.cell* %181, i32 0, i32 1
  %_cons206 = bitcast %union.anon* %_object205 to %struct.anon.4*
  %_car207 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons206, i32 0, i32 0
  %182 = load %struct.cell*, %struct.cell** %_car207, align 8
  %183 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code208 = getelementptr inbounds %struct.scheme, %struct.scheme* %183, i32 0, i32 9
  store %struct.cell* %182, %struct.cell** %code208, align 8
  br label %do.body.209

do.body.209:                                      ; preds = %if.else.198
  %184 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op210 = getelementptr inbounds %struct.scheme, %struct.scheme* %184, i32 0, i32 55
  store i32 6, i32* %op210, align 4
  %185 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T211 = getelementptr inbounds %struct.scheme, %struct.scheme* %185, i32 0, i32 19
  %186 = load %struct.cell*, %struct.cell** %T211, align 8
  store %struct.cell* %186, %struct.cell** %retval
  br label %return

do.end.212:                                       ; No predecessors!
  br label %if.end.213

if.end.213:                                       ; preds = %do.end.212
  br label %if.end.214

if.end.214:                                       ; preds = %if.end.213, %do.end.186
  br label %sw.bb.215

sw.bb.215:                                        ; preds = %entry, %if.end.214
  %187 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %188 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %189 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL216 = getelementptr inbounds %struct.scheme, %struct.scheme* %189, i32 0, i32 17
  %190 = load %struct.cell*, %struct.cell** %NIL216, align 8
  %191 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code217 = getelementptr inbounds %struct.scheme, %struct.scheme* %191, i32 0, i32 9
  %192 = load %struct.cell*, %struct.cell** %code217, align 8
  %call218 = call %struct.cell* @_cons(%struct.scheme* %188, %struct.cell* %190, %struct.cell* %192, i32 0)
  %193 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir219 = getelementptr inbounds %struct.scheme, %struct.scheme* %193, i32 0, i32 8
  %194 = load %struct.cell*, %struct.cell** %envir219, align 8
  %call220 = call %struct.cell* @mk_closure(%struct.scheme* %187, %struct.cell* %call218, %struct.cell* %194)
  store %struct.cell* %call220, %struct.cell** %x, align 8
  %195 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %195, i32 0, i32 0
  store i32 13, i32* %_flag, align 4
  %196 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %197 = load %struct.cell*, %struct.cell** %x, align 8
  %call221 = call %struct.cell* @_s_return(%struct.scheme* %196, %struct.cell* %197)
  store %struct.cell* %call221, %struct.cell** %retval
  br label %return

sw.bb.222:                                        ; preds = %entry
  %198 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code223 = getelementptr inbounds %struct.scheme, %struct.scheme* %198, i32 0, i32 9
  %199 = load %struct.cell*, %struct.cell** %code223, align 8
  %200 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL224 = getelementptr inbounds %struct.scheme, %struct.scheme* %200, i32 0, i32 17
  %201 = load %struct.cell*, %struct.cell** %NIL224, align 8
  %cmp225 = icmp eq %struct.cell* %199, %201
  br i1 %cmp225, label %if.then.226, label %if.end.229

if.then.226:                                      ; preds = %sw.bb.222
  %202 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %203 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T227 = getelementptr inbounds %struct.scheme, %struct.scheme* %203, i32 0, i32 19
  %204 = load %struct.cell*, %struct.cell** %T227, align 8
  %call228 = call %struct.cell* @_s_return(%struct.scheme* %202, %struct.cell* %204)
  store %struct.cell* %call228, %struct.cell** %retval
  br label %return

if.end.229:                                       ; preds = %sw.bb.222
  %205 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %206 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL230 = getelementptr inbounds %struct.scheme, %struct.scheme* %206, i32 0, i32 17
  %207 = load %struct.cell*, %struct.cell** %NIL230, align 8
  %208 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code231 = getelementptr inbounds %struct.scheme, %struct.scheme* %208, i32 0, i32 9
  %209 = load %struct.cell*, %struct.cell** %code231, align 8
  %_object232 = getelementptr inbounds %struct.cell, %struct.cell* %209, i32 0, i32 1
  %_cons233 = bitcast %union.anon* %_object232 to %struct.anon.4*
  %_cdr234 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons233, i32 0, i32 1
  %210 = load %struct.cell*, %struct.cell** %_cdr234, align 8
  call void @s_save(%struct.scheme* %205, i32 39, %struct.cell* %207, %struct.cell* %210)
  %211 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code235 = getelementptr inbounds %struct.scheme, %struct.scheme* %211, i32 0, i32 9
  %212 = load %struct.cell*, %struct.cell** %code235, align 8
  %_object236 = getelementptr inbounds %struct.cell, %struct.cell* %212, i32 0, i32 1
  %_cons237 = bitcast %union.anon* %_object236 to %struct.anon.4*
  %_car238 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons237, i32 0, i32 0
  %213 = load %struct.cell*, %struct.cell** %_car238, align 8
  %214 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code239 = getelementptr inbounds %struct.scheme, %struct.scheme* %214, i32 0, i32 9
  store %struct.cell* %213, %struct.cell** %code239, align 8
  br label %do.body.240

do.body.240:                                      ; preds = %if.end.229
  %215 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op241 = getelementptr inbounds %struct.scheme, %struct.scheme* %215, i32 0, i32 55
  store i32 6, i32* %op241, align 4
  %216 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T242 = getelementptr inbounds %struct.scheme, %struct.scheme* %216, i32 0, i32 19
  %217 = load %struct.cell*, %struct.cell** %T242, align 8
  store %struct.cell* %217, %struct.cell** %retval
  br label %return

do.end.243:                                       ; No predecessors!
  br label %sw.bb.244

sw.bb.244:                                        ; preds = %entry, %do.end.243
  %218 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value245 = getelementptr inbounds %struct.scheme, %struct.scheme* %218, i32 0, i32 54
  %219 = load %struct.cell*, %struct.cell** %value245, align 8
  %220 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F246 = getelementptr inbounds %struct.scheme, %struct.scheme* %220, i32 0, i32 21
  %221 = load %struct.cell*, %struct.cell** %F246, align 8
  %cmp247 = icmp eq %struct.cell* %219, %221
  br i1 %cmp247, label %if.then.248, label %if.else.251

if.then.248:                                      ; preds = %sw.bb.244
  %222 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %223 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value249 = getelementptr inbounds %struct.scheme, %struct.scheme* %223, i32 0, i32 54
  %224 = load %struct.cell*, %struct.cell** %value249, align 8
  %call250 = call %struct.cell* @_s_return(%struct.scheme* %222, %struct.cell* %224)
  store %struct.cell* %call250, %struct.cell** %retval
  br label %return

if.else.251:                                      ; preds = %sw.bb.244
  %225 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code252 = getelementptr inbounds %struct.scheme, %struct.scheme* %225, i32 0, i32 9
  %226 = load %struct.cell*, %struct.cell** %code252, align 8
  %227 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL253 = getelementptr inbounds %struct.scheme, %struct.scheme* %227, i32 0, i32 17
  %228 = load %struct.cell*, %struct.cell** %NIL253, align 8
  %cmp254 = icmp eq %struct.cell* %226, %228
  br i1 %cmp254, label %if.then.255, label %if.else.258

if.then.255:                                      ; preds = %if.else.251
  %229 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %230 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value256 = getelementptr inbounds %struct.scheme, %struct.scheme* %230, i32 0, i32 54
  %231 = load %struct.cell*, %struct.cell** %value256, align 8
  %call257 = call %struct.cell* @_s_return(%struct.scheme* %229, %struct.cell* %231)
  store %struct.cell* %call257, %struct.cell** %retval
  br label %return

if.else.258:                                      ; preds = %if.else.251
  %232 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %233 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL259 = getelementptr inbounds %struct.scheme, %struct.scheme* %233, i32 0, i32 17
  %234 = load %struct.cell*, %struct.cell** %NIL259, align 8
  %235 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code260 = getelementptr inbounds %struct.scheme, %struct.scheme* %235, i32 0, i32 9
  %236 = load %struct.cell*, %struct.cell** %code260, align 8
  %_object261 = getelementptr inbounds %struct.cell, %struct.cell* %236, i32 0, i32 1
  %_cons262 = bitcast %union.anon* %_object261 to %struct.anon.4*
  %_cdr263 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons262, i32 0, i32 1
  %237 = load %struct.cell*, %struct.cell** %_cdr263, align 8
  call void @s_save(%struct.scheme* %232, i32 39, %struct.cell* %234, %struct.cell* %237)
  %238 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code264 = getelementptr inbounds %struct.scheme, %struct.scheme* %238, i32 0, i32 9
  %239 = load %struct.cell*, %struct.cell** %code264, align 8
  %_object265 = getelementptr inbounds %struct.cell, %struct.cell* %239, i32 0, i32 1
  %_cons266 = bitcast %union.anon* %_object265 to %struct.anon.4*
  %_car267 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons266, i32 0, i32 0
  %240 = load %struct.cell*, %struct.cell** %_car267, align 8
  %241 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code268 = getelementptr inbounds %struct.scheme, %struct.scheme* %241, i32 0, i32 9
  store %struct.cell* %240, %struct.cell** %code268, align 8
  br label %do.body.269

do.body.269:                                      ; preds = %if.else.258
  %242 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op270 = getelementptr inbounds %struct.scheme, %struct.scheme* %242, i32 0, i32 55
  store i32 6, i32* %op270, align 4
  %243 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T271 = getelementptr inbounds %struct.scheme, %struct.scheme* %243, i32 0, i32 19
  %244 = load %struct.cell*, %struct.cell** %T271, align 8
  store %struct.cell* %244, %struct.cell** %retval
  br label %return

do.end.272:                                       ; No predecessors!
  br label %if.end.273

if.end.273:                                       ; preds = %do.end.272
  br label %if.end.274

if.end.274:                                       ; preds = %if.end.273
  br label %sw.bb.275

sw.bb.275:                                        ; preds = %entry, %if.end.274
  %245 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code276 = getelementptr inbounds %struct.scheme, %struct.scheme* %245, i32 0, i32 9
  %246 = load %struct.cell*, %struct.cell** %code276, align 8
  %247 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL277 = getelementptr inbounds %struct.scheme, %struct.scheme* %247, i32 0, i32 17
  %248 = load %struct.cell*, %struct.cell** %NIL277, align 8
  %cmp278 = icmp eq %struct.cell* %246, %248
  br i1 %cmp278, label %if.then.279, label %if.end.282

if.then.279:                                      ; preds = %sw.bb.275
  %249 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %250 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F280 = getelementptr inbounds %struct.scheme, %struct.scheme* %250, i32 0, i32 21
  %251 = load %struct.cell*, %struct.cell** %F280, align 8
  %call281 = call %struct.cell* @_s_return(%struct.scheme* %249, %struct.cell* %251)
  store %struct.cell* %call281, %struct.cell** %retval
  br label %return

if.end.282:                                       ; preds = %sw.bb.275
  %252 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %253 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL283 = getelementptr inbounds %struct.scheme, %struct.scheme* %253, i32 0, i32 17
  %254 = load %struct.cell*, %struct.cell** %NIL283, align 8
  %255 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code284 = getelementptr inbounds %struct.scheme, %struct.scheme* %255, i32 0, i32 9
  %256 = load %struct.cell*, %struct.cell** %code284, align 8
  %_object285 = getelementptr inbounds %struct.cell, %struct.cell* %256, i32 0, i32 1
  %_cons286 = bitcast %union.anon* %_object285 to %struct.anon.4*
  %_cdr287 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons286, i32 0, i32 1
  %257 = load %struct.cell*, %struct.cell** %_cdr287, align 8
  call void @s_save(%struct.scheme* %252, i32 41, %struct.cell* %254, %struct.cell* %257)
  %258 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code288 = getelementptr inbounds %struct.scheme, %struct.scheme* %258, i32 0, i32 9
  %259 = load %struct.cell*, %struct.cell** %code288, align 8
  %_object289 = getelementptr inbounds %struct.cell, %struct.cell* %259, i32 0, i32 1
  %_cons290 = bitcast %union.anon* %_object289 to %struct.anon.4*
  %_car291 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons290, i32 0, i32 0
  %260 = load %struct.cell*, %struct.cell** %_car291, align 8
  %261 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code292 = getelementptr inbounds %struct.scheme, %struct.scheme* %261, i32 0, i32 9
  store %struct.cell* %260, %struct.cell** %code292, align 8
  br label %do.body.293

do.body.293:                                      ; preds = %if.end.282
  %262 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op294 = getelementptr inbounds %struct.scheme, %struct.scheme* %262, i32 0, i32 55
  store i32 6, i32* %op294, align 4
  %263 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T295 = getelementptr inbounds %struct.scheme, %struct.scheme* %263, i32 0, i32 19
  %264 = load %struct.cell*, %struct.cell** %T295, align 8
  store %struct.cell* %264, %struct.cell** %retval
  br label %return

do.end.296:                                       ; No predecessors!
  br label %sw.bb.297

sw.bb.297:                                        ; preds = %entry, %do.end.296
  %265 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value298 = getelementptr inbounds %struct.scheme, %struct.scheme* %265, i32 0, i32 54
  %266 = load %struct.cell*, %struct.cell** %value298, align 8
  %267 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F299 = getelementptr inbounds %struct.scheme, %struct.scheme* %267, i32 0, i32 21
  %268 = load %struct.cell*, %struct.cell** %F299, align 8
  %cmp300 = icmp ne %struct.cell* %266, %268
  br i1 %cmp300, label %if.then.301, label %if.else.304

if.then.301:                                      ; preds = %sw.bb.297
  %269 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %270 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value302 = getelementptr inbounds %struct.scheme, %struct.scheme* %270, i32 0, i32 54
  %271 = load %struct.cell*, %struct.cell** %value302, align 8
  %call303 = call %struct.cell* @_s_return(%struct.scheme* %269, %struct.cell* %271)
  store %struct.cell* %call303, %struct.cell** %retval
  br label %return

if.else.304:                                      ; preds = %sw.bb.297
  %272 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code305 = getelementptr inbounds %struct.scheme, %struct.scheme* %272, i32 0, i32 9
  %273 = load %struct.cell*, %struct.cell** %code305, align 8
  %274 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL306 = getelementptr inbounds %struct.scheme, %struct.scheme* %274, i32 0, i32 17
  %275 = load %struct.cell*, %struct.cell** %NIL306, align 8
  %cmp307 = icmp eq %struct.cell* %273, %275
  br i1 %cmp307, label %if.then.308, label %if.else.311

if.then.308:                                      ; preds = %if.else.304
  %276 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %277 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value309 = getelementptr inbounds %struct.scheme, %struct.scheme* %277, i32 0, i32 54
  %278 = load %struct.cell*, %struct.cell** %value309, align 8
  %call310 = call %struct.cell* @_s_return(%struct.scheme* %276, %struct.cell* %278)
  store %struct.cell* %call310, %struct.cell** %retval
  br label %return

if.else.311:                                      ; preds = %if.else.304
  %279 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %280 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL312 = getelementptr inbounds %struct.scheme, %struct.scheme* %280, i32 0, i32 17
  %281 = load %struct.cell*, %struct.cell** %NIL312, align 8
  %282 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code313 = getelementptr inbounds %struct.scheme, %struct.scheme* %282, i32 0, i32 9
  %283 = load %struct.cell*, %struct.cell** %code313, align 8
  %_object314 = getelementptr inbounds %struct.cell, %struct.cell* %283, i32 0, i32 1
  %_cons315 = bitcast %union.anon* %_object314 to %struct.anon.4*
  %_cdr316 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons315, i32 0, i32 1
  %284 = load %struct.cell*, %struct.cell** %_cdr316, align 8
  call void @s_save(%struct.scheme* %279, i32 41, %struct.cell* %281, %struct.cell* %284)
  %285 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code317 = getelementptr inbounds %struct.scheme, %struct.scheme* %285, i32 0, i32 9
  %286 = load %struct.cell*, %struct.cell** %code317, align 8
  %_object318 = getelementptr inbounds %struct.cell, %struct.cell* %286, i32 0, i32 1
  %_cons319 = bitcast %union.anon* %_object318 to %struct.anon.4*
  %_car320 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons319, i32 0, i32 0
  %287 = load %struct.cell*, %struct.cell** %_car320, align 8
  %288 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code321 = getelementptr inbounds %struct.scheme, %struct.scheme* %288, i32 0, i32 9
  store %struct.cell* %287, %struct.cell** %code321, align 8
  br label %do.body.322

do.body.322:                                      ; preds = %if.else.311
  %289 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op323 = getelementptr inbounds %struct.scheme, %struct.scheme* %289, i32 0, i32 55
  store i32 6, i32* %op323, align 4
  %290 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T324 = getelementptr inbounds %struct.scheme, %struct.scheme* %290, i32 0, i32 19
  %291 = load %struct.cell*, %struct.cell** %T324, align 8
  store %struct.cell* %291, %struct.cell** %retval
  br label %return

do.end.325:                                       ; No predecessors!
  br label %if.end.326

if.end.326:                                       ; preds = %do.end.325
  br label %if.end.327

if.end.327:                                       ; preds = %if.end.326
  br label %sw.bb.328

sw.bb.328:                                        ; preds = %entry, %if.end.327
  %292 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %293 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL329 = getelementptr inbounds %struct.scheme, %struct.scheme* %293, i32 0, i32 17
  %294 = load %struct.cell*, %struct.cell** %NIL329, align 8
  %295 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code330 = getelementptr inbounds %struct.scheme, %struct.scheme* %295, i32 0, i32 9
  %296 = load %struct.cell*, %struct.cell** %code330, align 8
  %_object331 = getelementptr inbounds %struct.cell, %struct.cell* %296, i32 0, i32 1
  %_cons332 = bitcast %union.anon* %_object331 to %struct.anon.4*
  %_cdr333 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons332, i32 0, i32 1
  %297 = load %struct.cell*, %struct.cell** %_cdr333, align 8
  call void @s_save(%struct.scheme* %292, i32 43, %struct.cell* %294, %struct.cell* %297)
  %298 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code334 = getelementptr inbounds %struct.scheme, %struct.scheme* %298, i32 0, i32 9
  %299 = load %struct.cell*, %struct.cell** %code334, align 8
  %_object335 = getelementptr inbounds %struct.cell, %struct.cell* %299, i32 0, i32 1
  %_cons336 = bitcast %union.anon* %_object335 to %struct.anon.4*
  %_car337 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons336, i32 0, i32 0
  %300 = load %struct.cell*, %struct.cell** %_car337, align 8
  %301 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code338 = getelementptr inbounds %struct.scheme, %struct.scheme* %301, i32 0, i32 9
  store %struct.cell* %300, %struct.cell** %code338, align 8
  br label %do.body.339

do.body.339:                                      ; preds = %sw.bb.328
  %302 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op340 = getelementptr inbounds %struct.scheme, %struct.scheme* %302, i32 0, i32 55
  store i32 6, i32* %op340, align 4
  %303 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T341 = getelementptr inbounds %struct.scheme, %struct.scheme* %303, i32 0, i32 19
  %304 = load %struct.cell*, %struct.cell** %T341, align 8
  store %struct.cell* %304, %struct.cell** %retval
  br label %return

do.end.342:                                       ; No predecessors!
  br label %sw.bb.343

sw.bb.343:                                        ; preds = %entry, %do.end.342
  %305 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value344 = getelementptr inbounds %struct.scheme, %struct.scheme* %305, i32 0, i32 54
  %306 = load %struct.cell*, %struct.cell** %value344, align 8
  %307 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args345 = getelementptr inbounds %struct.scheme, %struct.scheme* %307, i32 0, i32 7
  store %struct.cell* %306, %struct.cell** %args345, align 8
  %308 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %309 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %310 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL346 = getelementptr inbounds %struct.scheme, %struct.scheme* %310, i32 0, i32 17
  %311 = load %struct.cell*, %struct.cell** %NIL346, align 8
  %312 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code347 = getelementptr inbounds %struct.scheme, %struct.scheme* %312, i32 0, i32 9
  %313 = load %struct.cell*, %struct.cell** %code347, align 8
  %call348 = call %struct.cell* @_cons(%struct.scheme* %309, %struct.cell* %311, %struct.cell* %313, i32 0)
  %314 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir349 = getelementptr inbounds %struct.scheme, %struct.scheme* %314, i32 0, i32 8
  %315 = load %struct.cell*, %struct.cell** %envir349, align 8
  %call350 = call %struct.cell* @mk_closure(%struct.scheme* %308, %struct.cell* %call348, %struct.cell* %315)
  store %struct.cell* %call350, %struct.cell** %x, align 8
  %316 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag351 = getelementptr inbounds %struct.cell, %struct.cell* %316, i32 0, i32 0
  store i32 13, i32* %_flag351, align 4
  %317 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %318 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %319 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args352 = getelementptr inbounds %struct.scheme, %struct.scheme* %319, i32 0, i32 7
  %320 = load %struct.cell*, %struct.cell** %args352, align 8
  %321 = load %struct.cell*, %struct.cell** %x, align 8
  %call353 = call %struct.cell* @_cons(%struct.scheme* %318, %struct.cell* %320, %struct.cell* %321, i32 0)
  %call354 = call %struct.cell* @_s_return(%struct.scheme* %317, %struct.cell* %call353)
  store %struct.cell* %call354, %struct.cell** %retval
  br label %return

sw.bb.355:                                        ; preds = %entry
  %322 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code356 = getelementptr inbounds %struct.scheme, %struct.scheme* %322, i32 0, i32 9
  %323 = load %struct.cell*, %struct.cell** %code356, align 8
  %_object357 = getelementptr inbounds %struct.cell, %struct.cell* %323, i32 0, i32 1
  %_cons358 = bitcast %union.anon* %_object357 to %struct.anon.4*
  %_car359 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons358, i32 0, i32 0
  %324 = load %struct.cell*, %struct.cell** %_car359, align 8
  %call360 = call i32 @is_pair(%struct.cell* %324)
  %tobool361 = icmp ne i32 %call360, 0
  br i1 %tobool361, label %if.then.362, label %if.else.384

if.then.362:                                      ; preds = %sw.bb.355
  %325 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code363 = getelementptr inbounds %struct.scheme, %struct.scheme* %325, i32 0, i32 9
  %326 = load %struct.cell*, %struct.cell** %code363, align 8
  %_object364 = getelementptr inbounds %struct.cell, %struct.cell* %326, i32 0, i32 1
  %_cons365 = bitcast %union.anon* %_object364 to %struct.anon.4*
  %_car366 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons365, i32 0, i32 0
  %327 = load %struct.cell*, %struct.cell** %_car366, align 8
  %_object367 = getelementptr inbounds %struct.cell, %struct.cell* %327, i32 0, i32 1
  %_cons368 = bitcast %union.anon* %_object367 to %struct.anon.4*
  %_car369 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons368, i32 0, i32 0
  %328 = load %struct.cell*, %struct.cell** %_car369, align 8
  store %struct.cell* %328, %struct.cell** %x, align 8
  %329 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %330 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA = getelementptr inbounds %struct.scheme, %struct.scheme* %330, i32 0, i32 27
  %331 = load %struct.cell*, %struct.cell** %LAMBDA, align 8
  %332 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %333 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code370 = getelementptr inbounds %struct.scheme, %struct.scheme* %333, i32 0, i32 9
  %334 = load %struct.cell*, %struct.cell** %code370, align 8
  %_object371 = getelementptr inbounds %struct.cell, %struct.cell* %334, i32 0, i32 1
  %_cons372 = bitcast %union.anon* %_object371 to %struct.anon.4*
  %_car373 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons372, i32 0, i32 0
  %335 = load %struct.cell*, %struct.cell** %_car373, align 8
  %_object374 = getelementptr inbounds %struct.cell, %struct.cell* %335, i32 0, i32 1
  %_cons375 = bitcast %union.anon* %_object374 to %struct.anon.4*
  %_cdr376 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons375, i32 0, i32 1
  %336 = load %struct.cell*, %struct.cell** %_cdr376, align 8
  %337 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code377 = getelementptr inbounds %struct.scheme, %struct.scheme* %337, i32 0, i32 9
  %338 = load %struct.cell*, %struct.cell** %code377, align 8
  %_object378 = getelementptr inbounds %struct.cell, %struct.cell* %338, i32 0, i32 1
  %_cons379 = bitcast %union.anon* %_object378 to %struct.anon.4*
  %_cdr380 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons379, i32 0, i32 1
  %339 = load %struct.cell*, %struct.cell** %_cdr380, align 8
  %call381 = call %struct.cell* @_cons(%struct.scheme* %332, %struct.cell* %336, %struct.cell* %339, i32 0)
  %call382 = call %struct.cell* @_cons(%struct.scheme* %329, %struct.cell* %331, %struct.cell* %call381, i32 0)
  %340 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code383 = getelementptr inbounds %struct.scheme, %struct.scheme* %340, i32 0, i32 9
  store %struct.cell* %call382, %struct.cell** %code383, align 8
  br label %if.end.397

if.else.384:                                      ; preds = %sw.bb.355
  %341 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code385 = getelementptr inbounds %struct.scheme, %struct.scheme* %341, i32 0, i32 9
  %342 = load %struct.cell*, %struct.cell** %code385, align 8
  %_object386 = getelementptr inbounds %struct.cell, %struct.cell* %342, i32 0, i32 1
  %_cons387 = bitcast %union.anon* %_object386 to %struct.anon.4*
  %_car388 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons387, i32 0, i32 0
  %343 = load %struct.cell*, %struct.cell** %_car388, align 8
  store %struct.cell* %343, %struct.cell** %x, align 8
  %344 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code389 = getelementptr inbounds %struct.scheme, %struct.scheme* %344, i32 0, i32 9
  %345 = load %struct.cell*, %struct.cell** %code389, align 8
  %_object390 = getelementptr inbounds %struct.cell, %struct.cell* %345, i32 0, i32 1
  %_cons391 = bitcast %union.anon* %_object390 to %struct.anon.4*
  %_cdr392 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons391, i32 0, i32 1
  %346 = load %struct.cell*, %struct.cell** %_cdr392, align 8
  %_object393 = getelementptr inbounds %struct.cell, %struct.cell* %346, i32 0, i32 1
  %_cons394 = bitcast %union.anon* %_object393 to %struct.anon.4*
  %_car395 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons394, i32 0, i32 0
  %347 = load %struct.cell*, %struct.cell** %_car395, align 8
  %348 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code396 = getelementptr inbounds %struct.scheme, %struct.scheme* %348, i32 0, i32 9
  store %struct.cell* %347, %struct.cell** %code396, align 8
  br label %if.end.397

if.end.397:                                       ; preds = %if.else.384, %if.then.362
  %349 = load %struct.cell*, %struct.cell** %x, align 8
  %call398 = call i32 @is_symbol(%struct.cell* %349)
  %tobool399 = icmp ne i32 %call398, 0
  br i1 %tobool399, label %if.end.402, label %if.then.400

if.then.400:                                      ; preds = %if.end.397
  %350 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call401 = call %struct.cell* @_Error_1(%struct.scheme* %350, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.183, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call401, %struct.cell** %retval
  br label %return

if.end.402:                                       ; preds = %if.end.397
  %351 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %352 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL403 = getelementptr inbounds %struct.scheme, %struct.scheme* %352, i32 0, i32 17
  %353 = load %struct.cell*, %struct.cell** %NIL403, align 8
  %354 = load %struct.cell*, %struct.cell** %x, align 8
  call void @s_save(%struct.scheme* %351, i32 45, %struct.cell* %353, %struct.cell* %354)
  br label %do.body.404

do.body.404:                                      ; preds = %if.end.402
  %355 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op405 = getelementptr inbounds %struct.scheme, %struct.scheme* %355, i32 0, i32 55
  store i32 6, i32* %op405, align 4
  %356 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T406 = getelementptr inbounds %struct.scheme, %struct.scheme* %356, i32 0, i32 19
  %357 = load %struct.cell*, %struct.cell** %T406, align 8
  store %struct.cell* %357, %struct.cell** %retval
  br label %return

do.end.407:                                       ; No predecessors!
  br label %sw.bb.408

sw.bb.408:                                        ; preds = %entry, %do.end.407
  %358 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value409 = getelementptr inbounds %struct.scheme, %struct.scheme* %358, i32 0, i32 54
  %359 = load %struct.cell*, %struct.cell** %value409, align 8
  %_flag410 = getelementptr inbounds %struct.cell, %struct.cell* %359, i32 0, i32 0
  store i32 12, i32* %_flag410, align 4
  %360 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %361 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir411 = getelementptr inbounds %struct.scheme, %struct.scheme* %361, i32 0, i32 8
  %362 = load %struct.cell*, %struct.cell** %envir411, align 8
  %363 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code412 = getelementptr inbounds %struct.scheme, %struct.scheme* %363, i32 0, i32 9
  %364 = load %struct.cell*, %struct.cell** %code412, align 8
  %call413 = call %struct.cell* @find_slot_in_env(%struct.scheme* %360, %struct.cell* %362, %struct.cell* %364, i32 0)
  store %struct.cell* %call413, %struct.cell** %x, align 8
  %365 = load %struct.cell*, %struct.cell** %x, align 8
  %366 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL414 = getelementptr inbounds %struct.scheme, %struct.scheme* %366, i32 0, i32 17
  %367 = load %struct.cell*, %struct.cell** %NIL414, align 8
  %cmp415 = icmp ne %struct.cell* %365, %367
  br i1 %cmp415, label %if.then.416, label %if.else.418

if.then.416:                                      ; preds = %sw.bb.408
  %368 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %369 = load %struct.cell*, %struct.cell** %x, align 8
  %370 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value417 = getelementptr inbounds %struct.scheme, %struct.scheme* %370, i32 0, i32 54
  %371 = load %struct.cell*, %struct.cell** %value417, align 8
  call void @set_slot_in_env(%struct.scheme* %368, %struct.cell* %369, %struct.cell* %371)
  br label %if.end.421

if.else.418:                                      ; preds = %sw.bb.408
  %372 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %373 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code419 = getelementptr inbounds %struct.scheme, %struct.scheme* %373, i32 0, i32 9
  %374 = load %struct.cell*, %struct.cell** %code419, align 8
  %375 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value420 = getelementptr inbounds %struct.scheme, %struct.scheme* %375, i32 0, i32 54
  %376 = load %struct.cell*, %struct.cell** %value420, align 8
  call void @new_slot_in_env(%struct.scheme* %372, %struct.cell* %374, %struct.cell* %376)
  br label %if.end.421

if.end.421:                                       ; preds = %if.else.418, %if.then.416
  %377 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %378 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code422 = getelementptr inbounds %struct.scheme, %struct.scheme* %378, i32 0, i32 9
  %379 = load %struct.cell*, %struct.cell** %code422, align 8
  %call423 = call %struct.cell* @_s_return(%struct.scheme* %377, %struct.cell* %379)
  store %struct.cell* %call423, %struct.cell** %retval
  br label %return

sw.bb.424:                                        ; preds = %entry
  %380 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %381 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL425 = getelementptr inbounds %struct.scheme, %struct.scheme* %381, i32 0, i32 17
  %382 = load %struct.cell*, %struct.cell** %NIL425, align 8
  %383 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code426 = getelementptr inbounds %struct.scheme, %struct.scheme* %383, i32 0, i32 9
  %384 = load %struct.cell*, %struct.cell** %code426, align 8
  %_object427 = getelementptr inbounds %struct.cell, %struct.cell* %384, i32 0, i32 1
  %_cons428 = bitcast %union.anon* %_object427 to %struct.anon.4*
  %_cdr429 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons428, i32 0, i32 1
  %385 = load %struct.cell*, %struct.cell** %_cdr429, align 8
  call void @s_save(%struct.scheme* %380, i32 47, %struct.cell* %382, %struct.cell* %385)
  %386 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code430 = getelementptr inbounds %struct.scheme, %struct.scheme* %386, i32 0, i32 9
  %387 = load %struct.cell*, %struct.cell** %code430, align 8
  %_object431 = getelementptr inbounds %struct.cell, %struct.cell* %387, i32 0, i32 1
  %_cons432 = bitcast %union.anon* %_object431 to %struct.anon.4*
  %_car433 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons432, i32 0, i32 0
  %388 = load %struct.cell*, %struct.cell** %_car433, align 8
  %389 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code434 = getelementptr inbounds %struct.scheme, %struct.scheme* %389, i32 0, i32 9
  store %struct.cell* %388, %struct.cell** %code434, align 8
  br label %do.body.435

do.body.435:                                      ; preds = %sw.bb.424
  %390 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op436 = getelementptr inbounds %struct.scheme, %struct.scheme* %390, i32 0, i32 55
  store i32 6, i32* %op436, align 4
  %391 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T437 = getelementptr inbounds %struct.scheme, %struct.scheme* %391, i32 0, i32 19
  %392 = load %struct.cell*, %struct.cell** %T437, align 8
  store %struct.cell* %392, %struct.cell** %retval
  br label %return

do.end.438:                                       ; No predecessors!
  br label %sw.bb.439

sw.bb.439:                                        ; preds = %entry, %do.end.438
  %393 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code440 = getelementptr inbounds %struct.scheme, %struct.scheme* %393, i32 0, i32 9
  %394 = load %struct.cell*, %struct.cell** %code440, align 8
  store %struct.cell* %394, %struct.cell** %x, align 8
  br label %for.cond.441

for.cond.441:                                     ; preds = %for.inc.476, %sw.bb.439
  %395 = load %struct.cell*, %struct.cell** %x, align 8
  %396 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL442 = getelementptr inbounds %struct.scheme, %struct.scheme* %396, i32 0, i32 17
  %397 = load %struct.cell*, %struct.cell** %NIL442, align 8
  %cmp443 = icmp ne %struct.cell* %395, %397
  br i1 %cmp443, label %for.body.444, label %for.end.480

for.body.444:                                     ; preds = %for.cond.441
  %398 = load %struct.cell*, %struct.cell** %x, align 8
  %_object445 = getelementptr inbounds %struct.cell, %struct.cell* %398, i32 0, i32 1
  %_cons446 = bitcast %union.anon* %_object445 to %struct.anon.4*
  %_car447 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons446, i32 0, i32 0
  %399 = load %struct.cell*, %struct.cell** %_car447, align 8
  %_object448 = getelementptr inbounds %struct.cell, %struct.cell* %399, i32 0, i32 1
  %_cons449 = bitcast %union.anon* %_object448 to %struct.anon.4*
  %_car450 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons449, i32 0, i32 0
  %400 = load %struct.cell*, %struct.cell** %_car450, align 8
  store %struct.cell* %400, %struct.cell** %y, align 8
  %call451 = call i32 @is_pair(%struct.cell* %400)
  %tobool452 = icmp ne i32 %call451, 0
  br i1 %tobool452, label %if.end.454, label %if.then.453

if.then.453:                                      ; preds = %for.body.444
  br label %for.end.480

if.end.454:                                       ; preds = %for.body.444
  br label %for.cond.455

for.cond.455:                                     ; preds = %for.inc.467, %if.end.454
  %401 = load %struct.cell*, %struct.cell** %y, align 8
  %402 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL456 = getelementptr inbounds %struct.scheme, %struct.scheme* %402, i32 0, i32 17
  %403 = load %struct.cell*, %struct.cell** %NIL456, align 8
  %cmp457 = icmp ne %struct.cell* %401, %403
  br i1 %cmp457, label %for.body.458, label %for.end.471

for.body.458:                                     ; preds = %for.cond.455
  %404 = load %struct.cell*, %struct.cell** %y, align 8
  %_object459 = getelementptr inbounds %struct.cell, %struct.cell* %404, i32 0, i32 1
  %_cons460 = bitcast %union.anon* %_object459 to %struct.anon.4*
  %_car461 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons460, i32 0, i32 0
  %405 = load %struct.cell*, %struct.cell** %_car461, align 8
  %406 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value462 = getelementptr inbounds %struct.scheme, %struct.scheme* %406, i32 0, i32 54
  %407 = load %struct.cell*, %struct.cell** %value462, align 8
  %call463 = call i32 @eqv(%struct.cell* %405, %struct.cell* %407)
  %tobool464 = icmp ne i32 %call463, 0
  br i1 %tobool464, label %if.then.465, label %if.end.466

if.then.465:                                      ; preds = %for.body.458
  br label %for.end.471

if.end.466:                                       ; preds = %for.body.458
  br label %for.inc.467

for.inc.467:                                      ; preds = %if.end.466
  %408 = load %struct.cell*, %struct.cell** %y, align 8
  %_object468 = getelementptr inbounds %struct.cell, %struct.cell* %408, i32 0, i32 1
  %_cons469 = bitcast %union.anon* %_object468 to %struct.anon.4*
  %_cdr470 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons469, i32 0, i32 1
  %409 = load %struct.cell*, %struct.cell** %_cdr470, align 8
  store %struct.cell* %409, %struct.cell** %y, align 8
  br label %for.cond.455

for.end.471:                                      ; preds = %if.then.465, %for.cond.455
  %410 = load %struct.cell*, %struct.cell** %y, align 8
  %411 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL472 = getelementptr inbounds %struct.scheme, %struct.scheme* %411, i32 0, i32 17
  %412 = load %struct.cell*, %struct.cell** %NIL472, align 8
  %cmp473 = icmp ne %struct.cell* %410, %412
  br i1 %cmp473, label %if.then.474, label %if.end.475

if.then.474:                                      ; preds = %for.end.471
  br label %for.end.480

if.end.475:                                       ; preds = %for.end.471
  br label %for.inc.476

for.inc.476:                                      ; preds = %if.end.475
  %413 = load %struct.cell*, %struct.cell** %x, align 8
  %_object477 = getelementptr inbounds %struct.cell, %struct.cell* %413, i32 0, i32 1
  %_cons478 = bitcast %union.anon* %_object477 to %struct.anon.4*
  %_cdr479 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons478, i32 0, i32 1
  %414 = load %struct.cell*, %struct.cell** %_cdr479, align 8
  store %struct.cell* %414, %struct.cell** %x, align 8
  br label %for.cond.441

for.end.480:                                      ; preds = %if.then.474, %if.then.453, %for.cond.441
  %415 = load %struct.cell*, %struct.cell** %x, align 8
  %416 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL481 = getelementptr inbounds %struct.scheme, %struct.scheme* %416, i32 0, i32 17
  %417 = load %struct.cell*, %struct.cell** %NIL481, align 8
  %cmp482 = icmp ne %struct.cell* %415, %417
  br i1 %cmp482, label %if.then.483, label %if.else.524

if.then.483:                                      ; preds = %for.end.480
  %418 = load %struct.cell*, %struct.cell** %x, align 8
  %_object484 = getelementptr inbounds %struct.cell, %struct.cell* %418, i32 0, i32 1
  %_cons485 = bitcast %union.anon* %_object484 to %struct.anon.4*
  %_car486 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons485, i32 0, i32 0
  %419 = load %struct.cell*, %struct.cell** %_car486, align 8
  %_object487 = getelementptr inbounds %struct.cell, %struct.cell* %419, i32 0, i32 1
  %_cons488 = bitcast %union.anon* %_object487 to %struct.anon.4*
  %_car489 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons488, i32 0, i32 0
  %420 = load %struct.cell*, %struct.cell** %_car489, align 8
  %call490 = call i32 @is_pair(%struct.cell* %420)
  %tobool491 = icmp ne i32 %call490, 0
  br i1 %tobool491, label %if.then.492, label %if.else.504

if.then.492:                                      ; preds = %if.then.483
  %421 = load %struct.cell*, %struct.cell** %x, align 8
  %_object493 = getelementptr inbounds %struct.cell, %struct.cell* %421, i32 0, i32 1
  %_cons494 = bitcast %union.anon* %_object493 to %struct.anon.4*
  %_car495 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons494, i32 0, i32 0
  %422 = load %struct.cell*, %struct.cell** %_car495, align 8
  %_object496 = getelementptr inbounds %struct.cell, %struct.cell* %422, i32 0, i32 1
  %_cons497 = bitcast %union.anon* %_object496 to %struct.anon.4*
  %_cdr498 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons497, i32 0, i32 1
  %423 = load %struct.cell*, %struct.cell** %_cdr498, align 8
  %424 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code499 = getelementptr inbounds %struct.scheme, %struct.scheme* %424, i32 0, i32 9
  store %struct.cell* %423, %struct.cell** %code499, align 8
  br label %do.body.500

do.body.500:                                      ; preds = %if.then.492
  %425 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op501 = getelementptr inbounds %struct.scheme, %struct.scheme* %425, i32 0, i32 55
  store i32 21, i32* %op501, align 4
  %426 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T502 = getelementptr inbounds %struct.scheme, %struct.scheme* %426, i32 0, i32 19
  %427 = load %struct.cell*, %struct.cell** %T502, align 8
  store %struct.cell* %427, %struct.cell** %retval
  br label %return

do.end.503:                                       ; No predecessors!
  br label %if.end.523

if.else.504:                                      ; preds = %if.then.483
  %428 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %429 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL505 = getelementptr inbounds %struct.scheme, %struct.scheme* %429, i32 0, i32 17
  %430 = load %struct.cell*, %struct.cell** %NIL505, align 8
  %431 = load %struct.cell*, %struct.cell** %x, align 8
  %_object506 = getelementptr inbounds %struct.cell, %struct.cell* %431, i32 0, i32 1
  %_cons507 = bitcast %union.anon* %_object506 to %struct.anon.4*
  %_car508 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons507, i32 0, i32 0
  %432 = load %struct.cell*, %struct.cell** %_car508, align 8
  %_object509 = getelementptr inbounds %struct.cell, %struct.cell* %432, i32 0, i32 1
  %_cons510 = bitcast %union.anon* %_object509 to %struct.anon.4*
  %_cdr511 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons510, i32 0, i32 1
  %433 = load %struct.cell*, %struct.cell** %_cdr511, align 8
  call void @s_save(%struct.scheme* %428, i32 48, %struct.cell* %430, %struct.cell* %433)
  %434 = load %struct.cell*, %struct.cell** %x, align 8
  %_object512 = getelementptr inbounds %struct.cell, %struct.cell* %434, i32 0, i32 1
  %_cons513 = bitcast %union.anon* %_object512 to %struct.anon.4*
  %_car514 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons513, i32 0, i32 0
  %435 = load %struct.cell*, %struct.cell** %_car514, align 8
  %_object515 = getelementptr inbounds %struct.cell, %struct.cell* %435, i32 0, i32 1
  %_cons516 = bitcast %union.anon* %_object515 to %struct.anon.4*
  %_car517 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons516, i32 0, i32 0
  %436 = load %struct.cell*, %struct.cell** %_car517, align 8
  %437 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code518 = getelementptr inbounds %struct.scheme, %struct.scheme* %437, i32 0, i32 9
  store %struct.cell* %436, %struct.cell** %code518, align 8
  br label %do.body.519

do.body.519:                                      ; preds = %if.else.504
  %438 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op520 = getelementptr inbounds %struct.scheme, %struct.scheme* %438, i32 0, i32 55
  store i32 6, i32* %op520, align 4
  %439 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T521 = getelementptr inbounds %struct.scheme, %struct.scheme* %439, i32 0, i32 19
  %440 = load %struct.cell*, %struct.cell** %T521, align 8
  store %struct.cell* %440, %struct.cell** %retval
  br label %return

do.end.522:                                       ; No predecessors!
  br label %if.end.523

if.end.523:                                       ; preds = %do.end.522, %do.end.503
  br label %if.end.527

if.else.524:                                      ; preds = %for.end.480
  %441 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %442 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL525 = getelementptr inbounds %struct.scheme, %struct.scheme* %442, i32 0, i32 17
  %443 = load %struct.cell*, %struct.cell** %NIL525, align 8
  %call526 = call %struct.cell* @_s_return(%struct.scheme* %441, %struct.cell* %443)
  store %struct.cell* %call526, %struct.cell** %retval
  br label %return

if.end.527:                                       ; preds = %if.end.523
  br label %sw.bb.528

sw.bb.528:                                        ; preds = %entry, %if.end.527
  %444 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value529 = getelementptr inbounds %struct.scheme, %struct.scheme* %444, i32 0, i32 54
  %445 = load %struct.cell*, %struct.cell** %value529, align 8
  %446 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F530 = getelementptr inbounds %struct.scheme, %struct.scheme* %446, i32 0, i32 21
  %447 = load %struct.cell*, %struct.cell** %F530, align 8
  %cmp531 = icmp ne %struct.cell* %445, %447
  br i1 %cmp531, label %if.then.532, label %if.else.537

if.then.532:                                      ; preds = %sw.bb.528
  br label %do.body.533

do.body.533:                                      ; preds = %if.then.532
  %448 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op534 = getelementptr inbounds %struct.scheme, %struct.scheme* %448, i32 0, i32 55
  store i32 21, i32* %op534, align 4
  %449 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T535 = getelementptr inbounds %struct.scheme, %struct.scheme* %449, i32 0, i32 19
  %450 = load %struct.cell*, %struct.cell** %T535, align 8
  store %struct.cell* %450, %struct.cell** %retval
  br label %return

do.end.536:                                       ; No predecessors!
  br label %if.end.540

if.else.537:                                      ; preds = %sw.bb.528
  %451 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %452 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL538 = getelementptr inbounds %struct.scheme, %struct.scheme* %452, i32 0, i32 17
  %453 = load %struct.cell*, %struct.cell** %NIL538, align 8
  %call539 = call %struct.cell* @_s_return(%struct.scheme* %451, %struct.cell* %453)
  store %struct.cell* %call539, %struct.cell** %retval
  br label %return

if.end.540:                                       ; preds = %do.end.536
  br label %sw.bb.541

sw.bb.541:                                        ; preds = %entry, %if.end.540
  %454 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args542 = getelementptr inbounds %struct.scheme, %struct.scheme* %454, i32 0, i32 7
  %455 = load %struct.cell*, %struct.cell** %args542, align 8
  %_object543 = getelementptr inbounds %struct.cell, %struct.cell* %455, i32 0, i32 1
  %_cons544 = bitcast %union.anon* %_object543 to %struct.anon.4*
  %_car545 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons544, i32 0, i32 0
  %456 = load %struct.cell*, %struct.cell** %_car545, align 8
  %457 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code546 = getelementptr inbounds %struct.scheme, %struct.scheme* %457, i32 0, i32 9
  store %struct.cell* %456, %struct.cell** %code546, align 8
  %458 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %459 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args547 = getelementptr inbounds %struct.scheme, %struct.scheme* %459, i32 0, i32 7
  %460 = load %struct.cell*, %struct.cell** %args547, align 8
  %_object548 = getelementptr inbounds %struct.cell, %struct.cell* %460, i32 0, i32 1
  %_cons549 = bitcast %union.anon* %_object548 to %struct.anon.4*
  %_cdr550 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons549, i32 0, i32 1
  %461 = load %struct.cell*, %struct.cell** %_cdr550, align 8
  %call551 = call %struct.cell* @list_star(%struct.scheme* %458, %struct.cell* %461)
  %462 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args552 = getelementptr inbounds %struct.scheme, %struct.scheme* %462, i32 0, i32 7
  store %struct.cell* %call551, %struct.cell** %args552, align 8
  br label %do.body.553

do.body.553:                                      ; preds = %sw.bb.541
  %463 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op554 = getelementptr inbounds %struct.scheme, %struct.scheme* %463, i32 0, i32 55
  store i32 10, i32* %op554, align 4
  %464 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T555 = getelementptr inbounds %struct.scheme, %struct.scheme* %464, i32 0, i32 19
  %465 = load %struct.cell*, %struct.cell** %T555, align 8
  store %struct.cell* %465, %struct.cell** %retval
  br label %return

do.end.556:                                       ; No predecessors!
  br label %sw.bb.557

sw.bb.557:                                        ; preds = %entry, %do.end.556
  %466 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args558 = getelementptr inbounds %struct.scheme, %struct.scheme* %466, i32 0, i32 7
  %467 = load %struct.cell*, %struct.cell** %args558, align 8
  %_object559 = getelementptr inbounds %struct.cell, %struct.cell* %467, i32 0, i32 1
  %_cons560 = bitcast %union.anon* %_object559 to %struct.anon.4*
  %_cdr561 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons560, i32 0, i32 1
  %468 = load %struct.cell*, %struct.cell** %_cdr561, align 8
  %469 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL562 = getelementptr inbounds %struct.scheme, %struct.scheme* %469, i32 0, i32 17
  %470 = load %struct.cell*, %struct.cell** %NIL562, align 8
  %cmp563 = icmp ne %struct.cell* %468, %470
  br i1 %cmp563, label %if.then.564, label %if.end.573

if.then.564:                                      ; preds = %sw.bb.557
  %471 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args565 = getelementptr inbounds %struct.scheme, %struct.scheme* %471, i32 0, i32 7
  %472 = load %struct.cell*, %struct.cell** %args565, align 8
  %_object566 = getelementptr inbounds %struct.cell, %struct.cell* %472, i32 0, i32 1
  %_cons567 = bitcast %union.anon* %_object566 to %struct.anon.4*
  %_cdr568 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons567, i32 0, i32 1
  %473 = load %struct.cell*, %struct.cell** %_cdr568, align 8
  %_object569 = getelementptr inbounds %struct.cell, %struct.cell* %473, i32 0, i32 1
  %_cons570 = bitcast %union.anon* %_object569 to %struct.anon.4*
  %_car571 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons570, i32 0, i32 0
  %474 = load %struct.cell*, %struct.cell** %_car571, align 8
  %475 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir572 = getelementptr inbounds %struct.scheme, %struct.scheme* %475, i32 0, i32 8
  store %struct.cell* %474, %struct.cell** %envir572, align 8
  br label %if.end.573

if.end.573:                                       ; preds = %if.then.564, %sw.bb.557
  %476 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args574 = getelementptr inbounds %struct.scheme, %struct.scheme* %476, i32 0, i32 7
  %477 = load %struct.cell*, %struct.cell** %args574, align 8
  %_object575 = getelementptr inbounds %struct.cell, %struct.cell* %477, i32 0, i32 1
  %_cons576 = bitcast %union.anon* %_object575 to %struct.anon.4*
  %_car577 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons576, i32 0, i32 0
  %478 = load %struct.cell*, %struct.cell** %_car577, align 8
  %479 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code578 = getelementptr inbounds %struct.scheme, %struct.scheme* %479, i32 0, i32 9
  store %struct.cell* %478, %struct.cell** %code578, align 8
  br label %do.body.579

do.body.579:                                      ; preds = %if.end.573
  %480 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op580 = getelementptr inbounds %struct.scheme, %struct.scheme* %480, i32 0, i32 55
  store i32 6, i32* %op580, align 4
  %481 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T581 = getelementptr inbounds %struct.scheme, %struct.scheme* %481, i32 0, i32 19
  %482 = load %struct.cell*, %struct.cell** %T581, align 8
  store %struct.cell* %482, %struct.cell** %retval
  br label %return

do.end.582:                                       ; No predecessors!
  br label %sw.bb.583

sw.bb.583:                                        ; preds = %entry, %do.end.582
  %483 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args584 = getelementptr inbounds %struct.scheme, %struct.scheme* %483, i32 0, i32 7
  %484 = load %struct.cell*, %struct.cell** %args584, align 8
  %_object585 = getelementptr inbounds %struct.cell, %struct.cell* %484, i32 0, i32 1
  %_cons586 = bitcast %union.anon* %_object585 to %struct.anon.4*
  %_car587 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons586, i32 0, i32 0
  %485 = load %struct.cell*, %struct.cell** %_car587, align 8
  %486 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code588 = getelementptr inbounds %struct.scheme, %struct.scheme* %486, i32 0, i32 9
  store %struct.cell* %485, %struct.cell** %code588, align 8
  %487 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %488 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %489 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %489, i32 0, i32 10
  %490 = load %struct.cell*, %struct.cell** %dump, align 8
  %call589 = call %struct.cell* @mk_continuation(%struct.scheme* %488, %struct.cell* %490)
  %491 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL590 = getelementptr inbounds %struct.scheme, %struct.scheme* %491, i32 0, i32 17
  %492 = load %struct.cell*, %struct.cell** %NIL590, align 8
  %call591 = call %struct.cell* @_cons(%struct.scheme* %487, %struct.cell* %call589, %struct.cell* %492, i32 0)
  %493 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args592 = getelementptr inbounds %struct.scheme, %struct.scheme* %493, i32 0, i32 7
  store %struct.cell* %call591, %struct.cell** %args592, align 8
  br label %do.body.593

do.body.593:                                      ; preds = %sw.bb.583
  %494 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op594 = getelementptr inbounds %struct.scheme, %struct.scheme* %494, i32 0, i32 55
  store i32 10, i32* %op594, align 4
  %495 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T595 = getelementptr inbounds %struct.scheme, %struct.scheme* %495, i32 0, i32 19
  %496 = load %struct.cell*, %struct.cell** %T595, align 8
  store %struct.cell* %496, %struct.cell** %retval
  br label %return

do.end.596:                                       ; No predecessors!
  br label %sw.default

sw.default:                                       ; preds = %entry, %do.end.596
  %497 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %497, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %498 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op597 = getelementptr inbounds %struct.scheme, %struct.scheme* %498, i32 0, i32 55
  %499 = load i32, i32* %op597, align 4
  %call598 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %499) #2
  %500 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %501 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff599 = getelementptr inbounds %struct.scheme, %struct.scheme* %501, i32 0, i32 50
  %arraydecay600 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff599, i32 0, i32 0
  %call601 = call %struct.cell* @_Error_1(%struct.scheme* %500, i8* %arraydecay600, %struct.cell* null)
  store %struct.cell* %call601, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default, %do.body.593, %do.body.579, %do.body.553, %if.else.537, %do.body.533, %if.else.524, %do.body.519, %do.body.500, %do.body.435, %if.end.421, %do.body.404, %if.then.400, %sw.bb.343, %do.body.339, %do.body.322, %if.then.308, %if.then.301, %do.body.293, %if.then.279, %do.body.269, %if.then.255, %if.then.248, %do.body.240, %if.then.226, %sw.bb.215, %do.body.209, %if.then.195, %do.body.183, %do.body.178, %if.then.160, %if.then.145, %if.then.139, %do.body.121, %if.then.108, %do.body.100, %do.body.66, %do.body.48, %if.then.24, %do.body
  %502 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %502
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_2(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %v = alloca %struct.num, align 8
  %dd = alloca double, align 8
  %y = alloca %struct.cell*, align 8
  %result = alloca double, align 8
  %real_result = alloca i32, align 4
  %y110 = alloca %struct.cell*, align 8
  %result_as_long = alloca i64, align 8
  %rvalue_of_x = alloca double, align 8
  %agg.tmp = alloca %struct.num, align 8
  %coerce = alloca %struct.num, align 8
  %agg.tmp224 = alloca %struct.num, align 8
  %coerce230 = alloca %struct.num, align 8
  %coerce258 = alloca %struct.num, align 8
  %agg.tmp265 = alloca %struct.num, align 8
  %coerce271 = alloca %struct.num, align 8
  %coerce299 = alloca %struct.num, align 8
  %agg.tmp313 = alloca %struct.num, align 8
  %coerce319 = alloca %struct.num, align 8
  %coerce350 = alloca %struct.num, align 8
  %agg.tmp364 = alloca %struct.num, align 8
  %coerce370 = alloca %struct.num, align 8
  %coerce387 = alloca %struct.num, align 8
  %agg.tmp399 = alloca %struct.num, align 8
  %coerce409 = alloca %struct.num, align 8
  %coerce421 = alloca %struct.num, align 8
  %agg.tmp433 = alloca %struct.num, align 8
  %coerce443 = alloca %struct.num, align 8
  %c = alloca i32, align 4
  %c550 = alloca i32, align 4
  %c560 = alloca i32, align 4
  %c571 = alloca i32, align 4
  %s = alloca i8*, align 8
  %p = alloca i8*, align 8
  %len = alloca i32, align 4
  %fill = alloca i32, align 4
  %len635 = alloca i32, align 4
  %str = alloca i8*, align 8
  %index = alloca i32, align 4
  %a = alloca %struct.cell*, align 8
  %str716 = alloca i8*, align 8
  %index717 = alloca i32, align 4
  %c718 = alloca i32, align 4
  %utf8 = alloca [7 x i8], align 1
  %utf8_len = alloca i32, align 4
  %newlen = alloca i32, align 4
  %p1 = alloca i8*, align 8
  %p2 = alloca i8*, align 8
  %p1_len = alloca i32, align 4
  %p2_len = alloca i32, align 4
  %newstr = alloca i8*, align 8
  %len815 = alloca i32, align 4
  %car_x = alloca %struct.cell*, align 8
  %newstr816 = alloca i8*, align 8
  %pos = alloca i8*, align 8
  %end = alloca i8*, align 8
  %str900 = alloca i8*, align 8
  %beg = alloca i8*, align 8
  %end901 = alloca i8*, align 8
  %index0 = alloca i32, align 4
  %index1 = alloca i32, align 4
  %len902 = alloca i32, align 4
  %x903 = alloca %struct.cell*, align 8
  %i = alloca i32, align 4
  %vec = alloca %struct.cell*, align 8
  %len1009 = alloca i32, align 4
  %fill1040 = alloca %struct.cell*, align 8
  %len1042 = alloca i32, align 4
  %vec1043 = alloca %struct.cell*, align 8
  %index1088 = alloca i32, align 4
  %index1123 = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 52, label %sw.bb
    i32 53, label %sw.bb.10
    i32 54, label %sw.bb.19
    i32 55, label %sw.bb.28
    i32 56, label %sw.bb.37
    i32 57, label %sw.bb.46
    i32 58, label %sw.bb.55
    i32 59, label %sw.bb.64
    i32 60, label %sw.bb.73
    i32 61, label %sw.bb.100
    i32 62, label %sw.bb.109
    i32 63, label %sw.bb.154
    i32 64, label %sw.bb.163
    i32 65, label %sw.bb.172
    i32 66, label %sw.bb.188
    i32 67, label %sw.bb.202
    i32 69, label %sw.bb.217
    i32 68, label %sw.bb.238
    i32 70, label %sw.bb.279
    i32 71, label %sw.bb.330
    i32 72, label %sw.bb.381
    i32 73, label %sw.bb.415
    i32 74, label %sw.bb.449
    i32 75, label %sw.bb.458
    i32 76, label %sw.bb.467
    i32 77, label %sw.bb.481
    i32 78, label %sw.bb.510
    i32 79, label %sw.bb.539
    i32 80, label %sw.bb.549
    i32 81, label %sw.bb.559
    i32 82, label %sw.bb.570
    i32 85, label %sw.bb.581
    i32 86, label %sw.bb.589
    i32 83, label %sw.bb.606
    i32 84, label %sw.bb.614
    i32 87, label %sw.bb.634
    i32 88, label %sw.bb.661
    i32 89, label %sw.bb.672
    i32 90, label %sw.bb.715
    i32 91, label %sw.bb.814
    i32 92, label %sw.bb.899
    i32 93, label %sw.bb.1008
    i32 94, label %sw.bb.1039
    i32 95, label %sw.bb.1079
    i32 96, label %sw.bb.1087
    i32 97, label %sw.bb.1122
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 7
  %2 = load %struct.cell*, %struct.cell** %args, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %3 = load %struct.cell*, %struct.cell** %_car, align 8
  store %struct.cell* %3, %struct.cell** %x, align 8
  %4 = load %struct.cell*, %struct.cell** %x, align 8
  %call = call i32 @num_is_integer(%struct.cell* %4)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %6 = load %struct.cell*, %struct.cell** %x, align 8
  %call1 = call %struct.cell* @_s_return(%struct.scheme* %5, %struct.cell* %6)
  store %struct.cell* %call1, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %sw.bb
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object2 to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value to double*
  %8 = load double, double* %rvalue, align 8
  %call3 = call double @modf(double %8, double* %dd) #2
  %cmp = fcmp oeq double %call3, 0.000000e+00
  br i1 %cmp, label %if.then.4, label %if.else.8

if.then.4:                                        ; preds = %if.else
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.cell*, %struct.cell** %x, align 8
  %call5 = call i64 @ivalue(%struct.cell* %11)
  %call6 = call %struct.cell* @mk_integer(%struct.scheme* %10, i64 %call5)
  %call7 = call %struct.cell* @_s_return(%struct.scheme* %9, %struct.cell* %call6)
  store %struct.cell* %call7, %struct.cell** %retval
  br label %return

if.else.8:                                        ; preds = %if.else
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %13 = load %struct.cell*, %struct.cell** %x, align 8
  %call9 = call %struct.cell* @_Error_1(%struct.scheme* %12, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.197, i32 0, i32 0), %struct.cell* %13)
  store %struct.cell* %call9, %struct.cell** %retval
  br label %return

sw.bb.10:                                         ; preds = %entry
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args11 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 7
  %15 = load %struct.cell*, %struct.cell** %args11, align 8
  %_object12 = getelementptr inbounds %struct.cell, %struct.cell* %15, i32 0, i32 1
  %_cons13 = bitcast %union.anon* %_object12 to %struct.anon.4*
  %_car14 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons13, i32 0, i32 0
  %16 = load %struct.cell*, %struct.cell** %_car14, align 8
  store %struct.cell* %16, %struct.cell** %x, align 8
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %19 = load %struct.cell*, %struct.cell** %x, align 8
  %call15 = call double @rvalue(%struct.cell* %19)
  %call16 = call double @exp(double %call15) #2
  %call17 = call %struct.cell* @mk_real(%struct.scheme* %18, double %call16)
  %call18 = call %struct.cell* @_s_return(%struct.scheme* %17, %struct.cell* %call17)
  store %struct.cell* %call18, %struct.cell** %retval
  br label %return

sw.bb.19:                                         ; preds = %entry
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args20 = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 7
  %21 = load %struct.cell*, %struct.cell** %args20, align 8
  %_object21 = getelementptr inbounds %struct.cell, %struct.cell* %21, i32 0, i32 1
  %_cons22 = bitcast %union.anon* %_object21 to %struct.anon.4*
  %_car23 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons22, i32 0, i32 0
  %22 = load %struct.cell*, %struct.cell** %_car23, align 8
  store %struct.cell* %22, %struct.cell** %x, align 8
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %25 = load %struct.cell*, %struct.cell** %x, align 8
  %call24 = call double @rvalue(%struct.cell* %25)
  %call25 = call double @log(double %call24) #2
  %call26 = call %struct.cell* @mk_real(%struct.scheme* %24, double %call25)
  %call27 = call %struct.cell* @_s_return(%struct.scheme* %23, %struct.cell* %call26)
  store %struct.cell* %call27, %struct.cell** %retval
  br label %return

sw.bb.28:                                         ; preds = %entry
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args29 = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 7
  %27 = load %struct.cell*, %struct.cell** %args29, align 8
  %_object30 = getelementptr inbounds %struct.cell, %struct.cell* %27, i32 0, i32 1
  %_cons31 = bitcast %union.anon* %_object30 to %struct.anon.4*
  %_car32 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons31, i32 0, i32 0
  %28 = load %struct.cell*, %struct.cell** %_car32, align 8
  store %struct.cell* %28, %struct.cell** %x, align 8
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %31 = load %struct.cell*, %struct.cell** %x, align 8
  %call33 = call double @rvalue(%struct.cell* %31)
  %call34 = call double @sin(double %call33) #2
  %call35 = call %struct.cell* @mk_real(%struct.scheme* %30, double %call34)
  %call36 = call %struct.cell* @_s_return(%struct.scheme* %29, %struct.cell* %call35)
  store %struct.cell* %call36, %struct.cell** %retval
  br label %return

sw.bb.37:                                         ; preds = %entry
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args38 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 7
  %33 = load %struct.cell*, %struct.cell** %args38, align 8
  %_object39 = getelementptr inbounds %struct.cell, %struct.cell* %33, i32 0, i32 1
  %_cons40 = bitcast %union.anon* %_object39 to %struct.anon.4*
  %_car41 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons40, i32 0, i32 0
  %34 = load %struct.cell*, %struct.cell** %_car41, align 8
  store %struct.cell* %34, %struct.cell** %x, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %37 = load %struct.cell*, %struct.cell** %x, align 8
  %call42 = call double @rvalue(%struct.cell* %37)
  %call43 = call double @cos(double %call42) #2
  %call44 = call %struct.cell* @mk_real(%struct.scheme* %36, double %call43)
  %call45 = call %struct.cell* @_s_return(%struct.scheme* %35, %struct.cell* %call44)
  store %struct.cell* %call45, %struct.cell** %retval
  br label %return

sw.bb.46:                                         ; preds = %entry
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args47 = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 7
  %39 = load %struct.cell*, %struct.cell** %args47, align 8
  %_object48 = getelementptr inbounds %struct.cell, %struct.cell* %39, i32 0, i32 1
  %_cons49 = bitcast %union.anon* %_object48 to %struct.anon.4*
  %_car50 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons49, i32 0, i32 0
  %40 = load %struct.cell*, %struct.cell** %_car50, align 8
  store %struct.cell* %40, %struct.cell** %x, align 8
  %41 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %43 = load %struct.cell*, %struct.cell** %x, align 8
  %call51 = call double @rvalue(%struct.cell* %43)
  %call52 = call double @tan(double %call51) #2
  %call53 = call %struct.cell* @mk_real(%struct.scheme* %42, double %call52)
  %call54 = call %struct.cell* @_s_return(%struct.scheme* %41, %struct.cell* %call53)
  store %struct.cell* %call54, %struct.cell** %retval
  br label %return

sw.bb.55:                                         ; preds = %entry
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args56 = getelementptr inbounds %struct.scheme, %struct.scheme* %44, i32 0, i32 7
  %45 = load %struct.cell*, %struct.cell** %args56, align 8
  %_object57 = getelementptr inbounds %struct.cell, %struct.cell* %45, i32 0, i32 1
  %_cons58 = bitcast %union.anon* %_object57 to %struct.anon.4*
  %_car59 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons58, i32 0, i32 0
  %46 = load %struct.cell*, %struct.cell** %_car59, align 8
  store %struct.cell* %46, %struct.cell** %x, align 8
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %49 = load %struct.cell*, %struct.cell** %x, align 8
  %call60 = call double @rvalue(%struct.cell* %49)
  %call61 = call double @asin(double %call60) #2
  %call62 = call %struct.cell* @mk_real(%struct.scheme* %48, double %call61)
  %call63 = call %struct.cell* @_s_return(%struct.scheme* %47, %struct.cell* %call62)
  store %struct.cell* %call63, %struct.cell** %retval
  br label %return

sw.bb.64:                                         ; preds = %entry
  %50 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args65 = getelementptr inbounds %struct.scheme, %struct.scheme* %50, i32 0, i32 7
  %51 = load %struct.cell*, %struct.cell** %args65, align 8
  %_object66 = getelementptr inbounds %struct.cell, %struct.cell* %51, i32 0, i32 1
  %_cons67 = bitcast %union.anon* %_object66 to %struct.anon.4*
  %_car68 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons67, i32 0, i32 0
  %52 = load %struct.cell*, %struct.cell** %_car68, align 8
  store %struct.cell* %52, %struct.cell** %x, align 8
  %53 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %55 = load %struct.cell*, %struct.cell** %x, align 8
  %call69 = call double @rvalue(%struct.cell* %55)
  %call70 = call double @acos(double %call69) #2
  %call71 = call %struct.cell* @mk_real(%struct.scheme* %54, double %call70)
  %call72 = call %struct.cell* @_s_return(%struct.scheme* %53, %struct.cell* %call71)
  store %struct.cell* %call72, %struct.cell** %retval
  br label %return

sw.bb.73:                                         ; preds = %entry
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args74 = getelementptr inbounds %struct.scheme, %struct.scheme* %56, i32 0, i32 7
  %57 = load %struct.cell*, %struct.cell** %args74, align 8
  %_object75 = getelementptr inbounds %struct.cell, %struct.cell* %57, i32 0, i32 1
  %_cons76 = bitcast %union.anon* %_object75 to %struct.anon.4*
  %_car77 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons76, i32 0, i32 0
  %58 = load %struct.cell*, %struct.cell** %_car77, align 8
  store %struct.cell* %58, %struct.cell** %x, align 8
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args78 = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 7
  %60 = load %struct.cell*, %struct.cell** %args78, align 8
  %_object79 = getelementptr inbounds %struct.cell, %struct.cell* %60, i32 0, i32 1
  %_cons80 = bitcast %union.anon* %_object79 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons80, i32 0, i32 1
  %61 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 17
  %63 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp81 = icmp eq %struct.cell* %61, %63
  br i1 %cmp81, label %if.then.82, label %if.else.87

if.then.82:                                       ; preds = %sw.bb.73
  %64 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %66 = load %struct.cell*, %struct.cell** %x, align 8
  %call83 = call double @rvalue(%struct.cell* %66)
  %call84 = call double @atan(double %call83) #2
  %call85 = call %struct.cell* @mk_real(%struct.scheme* %65, double %call84)
  %call86 = call %struct.cell* @_s_return(%struct.scheme* %64, %struct.cell* %call85)
  store %struct.cell* %call86, %struct.cell** %retval
  br label %return

if.else.87:                                       ; preds = %sw.bb.73
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args88 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 7
  %68 = load %struct.cell*, %struct.cell** %args88, align 8
  %_object89 = getelementptr inbounds %struct.cell, %struct.cell* %68, i32 0, i32 1
  %_cons90 = bitcast %union.anon* %_object89 to %struct.anon.4*
  %_cdr91 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons90, i32 0, i32 1
  %69 = load %struct.cell*, %struct.cell** %_cdr91, align 8
  %_object92 = getelementptr inbounds %struct.cell, %struct.cell* %69, i32 0, i32 1
  %_cons93 = bitcast %union.anon* %_object92 to %struct.anon.4*
  %_car94 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons93, i32 0, i32 0
  %70 = load %struct.cell*, %struct.cell** %_car94, align 8
  store %struct.cell* %70, %struct.cell** %y, align 8
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %73 = load %struct.cell*, %struct.cell** %x, align 8
  %call95 = call double @rvalue(%struct.cell* %73)
  %74 = load %struct.cell*, %struct.cell** %y, align 8
  %call96 = call double @rvalue(%struct.cell* %74)
  %call97 = call double @atan2(double %call95, double %call96) #2
  %call98 = call %struct.cell* @mk_real(%struct.scheme* %72, double %call97)
  %call99 = call %struct.cell* @_s_return(%struct.scheme* %71, %struct.cell* %call98)
  store %struct.cell* %call99, %struct.cell** %retval
  br label %return

sw.bb.100:                                        ; preds = %entry
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args101 = getelementptr inbounds %struct.scheme, %struct.scheme* %75, i32 0, i32 7
  %76 = load %struct.cell*, %struct.cell** %args101, align 8
  %_object102 = getelementptr inbounds %struct.cell, %struct.cell* %76, i32 0, i32 1
  %_cons103 = bitcast %union.anon* %_object102 to %struct.anon.4*
  %_car104 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons103, i32 0, i32 0
  %77 = load %struct.cell*, %struct.cell** %_car104, align 8
  store %struct.cell* %77, %struct.cell** %x, align 8
  %78 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %80 = load %struct.cell*, %struct.cell** %x, align 8
  %call105 = call double @rvalue(%struct.cell* %80)
  %call106 = call double @sqrt(double %call105) #2
  %call107 = call %struct.cell* @mk_real(%struct.scheme* %79, double %call106)
  %call108 = call %struct.cell* @_s_return(%struct.scheme* %78, %struct.cell* %call107)
  store %struct.cell* %call108, %struct.cell** %retval
  br label %return

sw.bb.109:                                        ; preds = %entry
  store i32 1, i32* %real_result, align 4
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args111 = getelementptr inbounds %struct.scheme, %struct.scheme* %81, i32 0, i32 7
  %82 = load %struct.cell*, %struct.cell** %args111, align 8
  %_object112 = getelementptr inbounds %struct.cell, %struct.cell* %82, i32 0, i32 1
  %_cons113 = bitcast %union.anon* %_object112 to %struct.anon.4*
  %_cdr114 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons113, i32 0, i32 1
  %83 = load %struct.cell*, %struct.cell** %_cdr114, align 8
  %_object115 = getelementptr inbounds %struct.cell, %struct.cell* %83, i32 0, i32 1
  %_cons116 = bitcast %union.anon* %_object115 to %struct.anon.4*
  %_car117 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons116, i32 0, i32 0
  %84 = load %struct.cell*, %struct.cell** %_car117, align 8
  store %struct.cell* %84, %struct.cell** %y110, align 8
  %85 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args118 = getelementptr inbounds %struct.scheme, %struct.scheme* %85, i32 0, i32 7
  %86 = load %struct.cell*, %struct.cell** %args118, align 8
  %_object119 = getelementptr inbounds %struct.cell, %struct.cell* %86, i32 0, i32 1
  %_cons120 = bitcast %union.anon* %_object119 to %struct.anon.4*
  %_car121 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons120, i32 0, i32 0
  %87 = load %struct.cell*, %struct.cell** %_car121, align 8
  store %struct.cell* %87, %struct.cell** %x, align 8
  %88 = load %struct.cell*, %struct.cell** %x, align 8
  %call122 = call i32 @num_is_integer(%struct.cell* %88)
  %tobool123 = icmp ne i32 %call122, 0
  br i1 %tobool123, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %sw.bb.109
  %89 = load %struct.cell*, %struct.cell** %y110, align 8
  %call124 = call i32 @num_is_integer(%struct.cell* %89)
  %tobool125 = icmp ne i32 %call124, 0
  br i1 %tobool125, label %if.then.126, label %if.end

if.then.126:                                      ; preds = %land.lhs.true
  store i32 0, i32* %real_result, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.126, %land.lhs.true, %sw.bb.109
  %90 = load %struct.cell*, %struct.cell** %x, align 8
  %call127 = call double @rvalue(%struct.cell* %90)
  %cmp128 = fcmp oeq double %call127, 0.000000e+00
  br i1 %cmp128, label %land.lhs.true.129, label %if.else.133

land.lhs.true.129:                                ; preds = %if.end
  %91 = load %struct.cell*, %struct.cell** %y110, align 8
  %call130 = call double @rvalue(%struct.cell* %91)
  %cmp131 = fcmp olt double %call130, 0.000000e+00
  br i1 %cmp131, label %if.then.132, label %if.else.133

if.then.132:                                      ; preds = %land.lhs.true.129
  store double 0.000000e+00, double* %result, align 8
  br label %if.end.137

if.else.133:                                      ; preds = %land.lhs.true.129, %if.end
  %92 = load %struct.cell*, %struct.cell** %x, align 8
  %call134 = call double @rvalue(%struct.cell* %92)
  %93 = load %struct.cell*, %struct.cell** %y110, align 8
  %call135 = call double @rvalue(%struct.cell* %93)
  %call136 = call double @pow(double %call134, double %call135) #2
  store double %call136, double* %result, align 8
  br label %if.end.137

if.end.137:                                       ; preds = %if.else.133, %if.then.132
  %94 = load i32, i32* %real_result, align 4
  %tobool138 = icmp ne i32 %94, 0
  br i1 %tobool138, label %if.end.145, label %if.then.139

if.then.139:                                      ; preds = %if.end.137
  %95 = load double, double* %result, align 8
  %conv = fptosi double %95 to i64
  store i64 %conv, i64* %result_as_long, align 8
  %96 = load double, double* %result, align 8
  %97 = load i64, i64* %result_as_long, align 8
  %conv140 = sitofp i64 %97 to double
  %cmp141 = fcmp une double %96, %conv140
  br i1 %cmp141, label %if.then.143, label %if.end.144

if.then.143:                                      ; preds = %if.then.139
  store i32 1, i32* %real_result, align 4
  br label %if.end.144

if.end.144:                                       ; preds = %if.then.143, %if.then.139
  br label %if.end.145

if.end.145:                                       ; preds = %if.end.144, %if.end.137
  %98 = load i32, i32* %real_result, align 4
  %tobool146 = icmp ne i32 %98, 0
  br i1 %tobool146, label %if.then.147, label %if.else.150

if.then.147:                                      ; preds = %if.end.145
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %100 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %101 = load double, double* %result, align 8
  %call148 = call %struct.cell* @mk_real(%struct.scheme* %100, double %101)
  %call149 = call %struct.cell* @_s_return(%struct.scheme* %99, %struct.cell* %call148)
  store %struct.cell* %call149, %struct.cell** %retval
  br label %return

if.else.150:                                      ; preds = %if.end.145
  %102 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %103 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %104 = load double, double* %result, align 8
  %conv151 = fptosi double %104 to i64
  %call152 = call %struct.cell* @mk_integer(%struct.scheme* %103, i64 %conv151)
  %call153 = call %struct.cell* @_s_return(%struct.scheme* %102, %struct.cell* %call152)
  store %struct.cell* %call153, %struct.cell** %retval
  br label %return

sw.bb.154:                                        ; preds = %entry
  %105 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args155 = getelementptr inbounds %struct.scheme, %struct.scheme* %105, i32 0, i32 7
  %106 = load %struct.cell*, %struct.cell** %args155, align 8
  %_object156 = getelementptr inbounds %struct.cell, %struct.cell* %106, i32 0, i32 1
  %_cons157 = bitcast %union.anon* %_object156 to %struct.anon.4*
  %_car158 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons157, i32 0, i32 0
  %107 = load %struct.cell*, %struct.cell** %_car158, align 8
  store %struct.cell* %107, %struct.cell** %x, align 8
  %108 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %109 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %110 = load %struct.cell*, %struct.cell** %x, align 8
  %call159 = call double @rvalue(%struct.cell* %110)
  %call160 = call double @floor(double %call159) #7
  %call161 = call %struct.cell* @mk_real(%struct.scheme* %109, double %call160)
  %call162 = call %struct.cell* @_s_return(%struct.scheme* %108, %struct.cell* %call161)
  store %struct.cell* %call162, %struct.cell** %retval
  br label %return

sw.bb.163:                                        ; preds = %entry
  %111 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args164 = getelementptr inbounds %struct.scheme, %struct.scheme* %111, i32 0, i32 7
  %112 = load %struct.cell*, %struct.cell** %args164, align 8
  %_object165 = getelementptr inbounds %struct.cell, %struct.cell* %112, i32 0, i32 1
  %_cons166 = bitcast %union.anon* %_object165 to %struct.anon.4*
  %_car167 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons166, i32 0, i32 0
  %113 = load %struct.cell*, %struct.cell** %_car167, align 8
  store %struct.cell* %113, %struct.cell** %x, align 8
  %114 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %115 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %116 = load %struct.cell*, %struct.cell** %x, align 8
  %call168 = call double @rvalue(%struct.cell* %116)
  %call169 = call double @ceil(double %call168) #7
  %call170 = call %struct.cell* @mk_real(%struct.scheme* %115, double %call169)
  %call171 = call %struct.cell* @_s_return(%struct.scheme* %114, %struct.cell* %call170)
  store %struct.cell* %call171, %struct.cell** %retval
  br label %return

sw.bb.172:                                        ; preds = %entry
  %117 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args173 = getelementptr inbounds %struct.scheme, %struct.scheme* %117, i32 0, i32 7
  %118 = load %struct.cell*, %struct.cell** %args173, align 8
  %_object174 = getelementptr inbounds %struct.cell, %struct.cell* %118, i32 0, i32 1
  %_cons175 = bitcast %union.anon* %_object174 to %struct.anon.4*
  %_car176 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons175, i32 0, i32 0
  %119 = load %struct.cell*, %struct.cell** %_car176, align 8
  store %struct.cell* %119, %struct.cell** %x, align 8
  %120 = load %struct.cell*, %struct.cell** %x, align 8
  %call177 = call double @rvalue(%struct.cell* %120)
  store double %call177, double* %rvalue_of_x, align 8
  %121 = load double, double* %rvalue_of_x, align 8
  %cmp178 = fcmp ogt double %121, 0.000000e+00
  br i1 %cmp178, label %if.then.180, label %if.else.184

if.then.180:                                      ; preds = %sw.bb.172
  %122 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %124 = load double, double* %rvalue_of_x, align 8
  %call181 = call double @floor(double %124) #7
  %call182 = call %struct.cell* @mk_real(%struct.scheme* %123, double %call181)
  %call183 = call %struct.cell* @_s_return(%struct.scheme* %122, %struct.cell* %call182)
  store %struct.cell* %call183, %struct.cell** %retval
  br label %return

if.else.184:                                      ; preds = %sw.bb.172
  %125 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %126 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %127 = load double, double* %rvalue_of_x, align 8
  %call185 = call double @ceil(double %127) #7
  %call186 = call %struct.cell* @mk_real(%struct.scheme* %126, double %call185)
  %call187 = call %struct.cell* @_s_return(%struct.scheme* %125, %struct.cell* %call186)
  store %struct.cell* %call187, %struct.cell** %retval
  br label %return

sw.bb.188:                                        ; preds = %entry
  %128 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args189 = getelementptr inbounds %struct.scheme, %struct.scheme* %128, i32 0, i32 7
  %129 = load %struct.cell*, %struct.cell** %args189, align 8
  %_object190 = getelementptr inbounds %struct.cell, %struct.cell* %129, i32 0, i32 1
  %_cons191 = bitcast %union.anon* %_object190 to %struct.anon.4*
  %_car192 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons191, i32 0, i32 0
  %130 = load %struct.cell*, %struct.cell** %_car192, align 8
  store %struct.cell* %130, %struct.cell** %x, align 8
  %131 = load %struct.cell*, %struct.cell** %x, align 8
  %call193 = call i32 @num_is_integer(%struct.cell* %131)
  %tobool194 = icmp ne i32 %call193, 0
  br i1 %tobool194, label %if.then.195, label %if.end.197

if.then.195:                                      ; preds = %sw.bb.188
  %132 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %133 = load %struct.cell*, %struct.cell** %x, align 8
  %call196 = call %struct.cell* @_s_return(%struct.scheme* %132, %struct.cell* %133)
  store %struct.cell* %call196, %struct.cell** %retval
  br label %return

if.end.197:                                       ; preds = %sw.bb.188
  %134 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %136 = load %struct.cell*, %struct.cell** %x, align 8
  %call198 = call double @rvalue(%struct.cell* %136)
  %call199 = call double @round_per_R5RS(double %call198)
  %call200 = call %struct.cell* @mk_real(%struct.scheme* %135, double %call199)
  %call201 = call %struct.cell* @_s_return(%struct.scheme* %134, %struct.cell* %call200)
  store %struct.cell* %call201, %struct.cell** %retval
  br label %return

sw.bb.202:                                        ; preds = %entry
  %137 = bitcast %struct.num* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %137, i8* getelementptr inbounds (%struct.num, %struct.num* @num_zero, i32 0, i32 0), i64 16, i32 8, i1 false)
  %138 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args203 = getelementptr inbounds %struct.scheme, %struct.scheme* %138, i32 0, i32 7
  %139 = load %struct.cell*, %struct.cell** %args203, align 8
  store %struct.cell* %139, %struct.cell** %x, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.202
  %140 = load %struct.cell*, %struct.cell** %x, align 8
  %141 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL204 = getelementptr inbounds %struct.scheme, %struct.scheme* %141, i32 0, i32 17
  %142 = load %struct.cell*, %struct.cell** %NIL204, align 8
  %cmp205 = icmp ne %struct.cell* %140, %142
  br i1 %cmp205, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %143 = load %struct.cell*, %struct.cell** %x, align 8
  %_object207 = getelementptr inbounds %struct.cell, %struct.cell* %143, i32 0, i32 1
  %_cons208 = bitcast %union.anon* %_object207 to %struct.anon.4*
  %_car209 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons208, i32 0, i32 0
  %144 = load %struct.cell*, %struct.cell** %_car209, align 8
  %call210 = call { i8, i64 } @nvalue(%struct.cell* %144)
  %145 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %146 = getelementptr { i8, i64 }, { i8, i64 }* %145, i32 0, i32 0
  %147 = extractvalue { i8, i64 } %call210, 0
  store i8 %147, i8* %146, align 8
  %148 = getelementptr { i8, i64 }, { i8, i64 }* %145, i32 0, i32 1
  %149 = extractvalue { i8, i64 } %call210, 1
  store i64 %149, i64* %148, align 8
  %150 = bitcast %struct.num* %v to { i8, i64 }*
  %151 = getelementptr { i8, i64 }, { i8, i64 }* %150, i32 0, i32 0
  %152 = load i8, i8* %151, align 1
  %153 = getelementptr { i8, i64 }, { i8, i64 }* %150, i32 0, i32 1
  %154 = load i64, i64* %153, align 1
  %155 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %156 = getelementptr { i8, i64 }, { i8, i64 }* %155, i32 0, i32 0
  %157 = load i8, i8* %156, align 1
  %158 = getelementptr { i8, i64 }, { i8, i64 }* %155, i32 0, i32 1
  %159 = load i64, i64* %158, align 1
  %call211 = call { i8, i64 } @num_add(i8 %152, i64 %154, i8 %157, i64 %159)
  %160 = bitcast %struct.num* %coerce to { i8, i64 }*
  %161 = getelementptr { i8, i64 }, { i8, i64 }* %160, i32 0, i32 0
  %162 = extractvalue { i8, i64 } %call211, 0
  store i8 %162, i8* %161, align 8
  %163 = getelementptr { i8, i64 }, { i8, i64 }* %160, i32 0, i32 1
  %164 = extractvalue { i8, i64 } %call211, 1
  store i64 %164, i64* %163, align 8
  %165 = bitcast %struct.num* %v to i8*
  %166 = bitcast %struct.num* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %165, i8* %166, i64 16, i32 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %167 = load %struct.cell*, %struct.cell** %x, align 8
  %_object212 = getelementptr inbounds %struct.cell, %struct.cell* %167, i32 0, i32 1
  %_cons213 = bitcast %union.anon* %_object212 to %struct.anon.4*
  %_cdr214 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons213, i32 0, i32 1
  %168 = load %struct.cell*, %struct.cell** %_cdr214, align 8
  store %struct.cell* %168, %struct.cell** %x, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %169 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %170 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %171 = bitcast %struct.num* %v to { i8, i64 }*
  %172 = getelementptr { i8, i64 }, { i8, i64 }* %171, i32 0, i32 0
  %173 = load i8, i8* %172, align 1
  %174 = getelementptr { i8, i64 }, { i8, i64 }* %171, i32 0, i32 1
  %175 = load i64, i64* %174, align 1
  %call215 = call %struct.cell* @mk_number(%struct.scheme* %170, i8 %173, i64 %175)
  %call216 = call %struct.cell* @_s_return(%struct.scheme* %169, %struct.cell* %call215)
  store %struct.cell* %call216, %struct.cell** %retval
  br label %return

sw.bb.217:                                        ; preds = %entry
  %176 = bitcast %struct.num* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %176, i8* getelementptr inbounds (%struct.num, %struct.num* @num_one, i32 0, i32 0), i64 16, i32 8, i1 false)
  %177 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args218 = getelementptr inbounds %struct.scheme, %struct.scheme* %177, i32 0, i32 7
  %178 = load %struct.cell*, %struct.cell** %args218, align 8
  store %struct.cell* %178, %struct.cell** %x, align 8
  br label %for.cond.219

for.cond.219:                                     ; preds = %for.inc.231, %sw.bb.217
  %179 = load %struct.cell*, %struct.cell** %x, align 8
  %180 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL220 = getelementptr inbounds %struct.scheme, %struct.scheme* %180, i32 0, i32 17
  %181 = load %struct.cell*, %struct.cell** %NIL220, align 8
  %cmp221 = icmp ne %struct.cell* %179, %181
  br i1 %cmp221, label %for.body.223, label %for.end.235

for.body.223:                                     ; preds = %for.cond.219
  %182 = load %struct.cell*, %struct.cell** %x, align 8
  %_object225 = getelementptr inbounds %struct.cell, %struct.cell* %182, i32 0, i32 1
  %_cons226 = bitcast %union.anon* %_object225 to %struct.anon.4*
  %_car227 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons226, i32 0, i32 0
  %183 = load %struct.cell*, %struct.cell** %_car227, align 8
  %call228 = call { i8, i64 } @nvalue(%struct.cell* %183)
  %184 = bitcast %struct.num* %agg.tmp224 to { i8, i64 }*
  %185 = getelementptr { i8, i64 }, { i8, i64 }* %184, i32 0, i32 0
  %186 = extractvalue { i8, i64 } %call228, 0
  store i8 %186, i8* %185, align 8
  %187 = getelementptr { i8, i64 }, { i8, i64 }* %184, i32 0, i32 1
  %188 = extractvalue { i8, i64 } %call228, 1
  store i64 %188, i64* %187, align 8
  %189 = bitcast %struct.num* %v to { i8, i64 }*
  %190 = getelementptr { i8, i64 }, { i8, i64 }* %189, i32 0, i32 0
  %191 = load i8, i8* %190, align 1
  %192 = getelementptr { i8, i64 }, { i8, i64 }* %189, i32 0, i32 1
  %193 = load i64, i64* %192, align 1
  %194 = bitcast %struct.num* %agg.tmp224 to { i8, i64 }*
  %195 = getelementptr { i8, i64 }, { i8, i64 }* %194, i32 0, i32 0
  %196 = load i8, i8* %195, align 1
  %197 = getelementptr { i8, i64 }, { i8, i64 }* %194, i32 0, i32 1
  %198 = load i64, i64* %197, align 1
  %call229 = call { i8, i64 } @num_mul(i8 %191, i64 %193, i8 %196, i64 %198)
  %199 = bitcast %struct.num* %coerce230 to { i8, i64 }*
  %200 = getelementptr { i8, i64 }, { i8, i64 }* %199, i32 0, i32 0
  %201 = extractvalue { i8, i64 } %call229, 0
  store i8 %201, i8* %200, align 8
  %202 = getelementptr { i8, i64 }, { i8, i64 }* %199, i32 0, i32 1
  %203 = extractvalue { i8, i64 } %call229, 1
  store i64 %203, i64* %202, align 8
  %204 = bitcast %struct.num* %v to i8*
  %205 = bitcast %struct.num* %coerce230 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %204, i8* %205, i64 16, i32 8, i1 false)
  br label %for.inc.231

for.inc.231:                                      ; preds = %for.body.223
  %206 = load %struct.cell*, %struct.cell** %x, align 8
  %_object232 = getelementptr inbounds %struct.cell, %struct.cell* %206, i32 0, i32 1
  %_cons233 = bitcast %union.anon* %_object232 to %struct.anon.4*
  %_cdr234 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons233, i32 0, i32 1
  %207 = load %struct.cell*, %struct.cell** %_cdr234, align 8
  store %struct.cell* %207, %struct.cell** %x, align 8
  br label %for.cond.219

for.end.235:                                      ; preds = %for.cond.219
  %208 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %209 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %210 = bitcast %struct.num* %v to { i8, i64 }*
  %211 = getelementptr { i8, i64 }, { i8, i64 }* %210, i32 0, i32 0
  %212 = load i8, i8* %211, align 1
  %213 = getelementptr { i8, i64 }, { i8, i64 }* %210, i32 0, i32 1
  %214 = load i64, i64* %213, align 1
  %call236 = call %struct.cell* @mk_number(%struct.scheme* %209, i8 %212, i64 %214)
  %call237 = call %struct.cell* @_s_return(%struct.scheme* %208, %struct.cell* %call236)
  store %struct.cell* %call237, %struct.cell** %retval
  br label %return

sw.bb.238:                                        ; preds = %entry
  %215 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args239 = getelementptr inbounds %struct.scheme, %struct.scheme* %215, i32 0, i32 7
  %216 = load %struct.cell*, %struct.cell** %args239, align 8
  %_object240 = getelementptr inbounds %struct.cell, %struct.cell* %216, i32 0, i32 1
  %_cons241 = bitcast %union.anon* %_object240 to %struct.anon.4*
  %_cdr242 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons241, i32 0, i32 1
  %217 = load %struct.cell*, %struct.cell** %_cdr242, align 8
  %218 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL243 = getelementptr inbounds %struct.scheme, %struct.scheme* %218, i32 0, i32 17
  %219 = load %struct.cell*, %struct.cell** %NIL243, align 8
  %cmp244 = icmp eq %struct.cell* %217, %219
  br i1 %cmp244, label %if.then.246, label %if.else.248

if.then.246:                                      ; preds = %sw.bb.238
  %220 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args247 = getelementptr inbounds %struct.scheme, %struct.scheme* %220, i32 0, i32 7
  %221 = load %struct.cell*, %struct.cell** %args247, align 8
  store %struct.cell* %221, %struct.cell** %x, align 8
  %222 = bitcast %struct.num* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %222, i8* getelementptr inbounds (%struct.num, %struct.num* @num_zero, i32 0, i32 0), i64 16, i32 8, i1 false)
  br label %if.end.259

if.else.248:                                      ; preds = %sw.bb.238
  %223 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args249 = getelementptr inbounds %struct.scheme, %struct.scheme* %223, i32 0, i32 7
  %224 = load %struct.cell*, %struct.cell** %args249, align 8
  %_object250 = getelementptr inbounds %struct.cell, %struct.cell* %224, i32 0, i32 1
  %_cons251 = bitcast %union.anon* %_object250 to %struct.anon.4*
  %_cdr252 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons251, i32 0, i32 1
  %225 = load %struct.cell*, %struct.cell** %_cdr252, align 8
  store %struct.cell* %225, %struct.cell** %x, align 8
  %226 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args253 = getelementptr inbounds %struct.scheme, %struct.scheme* %226, i32 0, i32 7
  %227 = load %struct.cell*, %struct.cell** %args253, align 8
  %_object254 = getelementptr inbounds %struct.cell, %struct.cell* %227, i32 0, i32 1
  %_cons255 = bitcast %union.anon* %_object254 to %struct.anon.4*
  %_car256 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons255, i32 0, i32 0
  %228 = load %struct.cell*, %struct.cell** %_car256, align 8
  %call257 = call { i8, i64 } @nvalue(%struct.cell* %228)
  %229 = bitcast %struct.num* %coerce258 to { i8, i64 }*
  %230 = getelementptr { i8, i64 }, { i8, i64 }* %229, i32 0, i32 0
  %231 = extractvalue { i8, i64 } %call257, 0
  store i8 %231, i8* %230, align 8
  %232 = getelementptr { i8, i64 }, { i8, i64 }* %229, i32 0, i32 1
  %233 = extractvalue { i8, i64 } %call257, 1
  store i64 %233, i64* %232, align 8
  %234 = bitcast %struct.num* %v to i8*
  %235 = bitcast %struct.num* %coerce258 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %234, i8* %235, i64 16, i32 8, i1 false)
  br label %if.end.259

if.end.259:                                       ; preds = %if.else.248, %if.then.246
  br label %for.cond.260

for.cond.260:                                     ; preds = %for.inc.272, %if.end.259
  %236 = load %struct.cell*, %struct.cell** %x, align 8
  %237 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL261 = getelementptr inbounds %struct.scheme, %struct.scheme* %237, i32 0, i32 17
  %238 = load %struct.cell*, %struct.cell** %NIL261, align 8
  %cmp262 = icmp ne %struct.cell* %236, %238
  br i1 %cmp262, label %for.body.264, label %for.end.276

for.body.264:                                     ; preds = %for.cond.260
  %239 = load %struct.cell*, %struct.cell** %x, align 8
  %_object266 = getelementptr inbounds %struct.cell, %struct.cell* %239, i32 0, i32 1
  %_cons267 = bitcast %union.anon* %_object266 to %struct.anon.4*
  %_car268 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons267, i32 0, i32 0
  %240 = load %struct.cell*, %struct.cell** %_car268, align 8
  %call269 = call { i8, i64 } @nvalue(%struct.cell* %240)
  %241 = bitcast %struct.num* %agg.tmp265 to { i8, i64 }*
  %242 = getelementptr { i8, i64 }, { i8, i64 }* %241, i32 0, i32 0
  %243 = extractvalue { i8, i64 } %call269, 0
  store i8 %243, i8* %242, align 8
  %244 = getelementptr { i8, i64 }, { i8, i64 }* %241, i32 0, i32 1
  %245 = extractvalue { i8, i64 } %call269, 1
  store i64 %245, i64* %244, align 8
  %246 = bitcast %struct.num* %v to { i8, i64 }*
  %247 = getelementptr { i8, i64 }, { i8, i64 }* %246, i32 0, i32 0
  %248 = load i8, i8* %247, align 1
  %249 = getelementptr { i8, i64 }, { i8, i64 }* %246, i32 0, i32 1
  %250 = load i64, i64* %249, align 1
  %251 = bitcast %struct.num* %agg.tmp265 to { i8, i64 }*
  %252 = getelementptr { i8, i64 }, { i8, i64 }* %251, i32 0, i32 0
  %253 = load i8, i8* %252, align 1
  %254 = getelementptr { i8, i64 }, { i8, i64 }* %251, i32 0, i32 1
  %255 = load i64, i64* %254, align 1
  %call270 = call { i8, i64 } @num_sub(i8 %248, i64 %250, i8 %253, i64 %255)
  %256 = bitcast %struct.num* %coerce271 to { i8, i64 }*
  %257 = getelementptr { i8, i64 }, { i8, i64 }* %256, i32 0, i32 0
  %258 = extractvalue { i8, i64 } %call270, 0
  store i8 %258, i8* %257, align 8
  %259 = getelementptr { i8, i64 }, { i8, i64 }* %256, i32 0, i32 1
  %260 = extractvalue { i8, i64 } %call270, 1
  store i64 %260, i64* %259, align 8
  %261 = bitcast %struct.num* %v to i8*
  %262 = bitcast %struct.num* %coerce271 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %261, i8* %262, i64 16, i32 8, i1 false)
  br label %for.inc.272

for.inc.272:                                      ; preds = %for.body.264
  %263 = load %struct.cell*, %struct.cell** %x, align 8
  %_object273 = getelementptr inbounds %struct.cell, %struct.cell* %263, i32 0, i32 1
  %_cons274 = bitcast %union.anon* %_object273 to %struct.anon.4*
  %_cdr275 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons274, i32 0, i32 1
  %264 = load %struct.cell*, %struct.cell** %_cdr275, align 8
  store %struct.cell* %264, %struct.cell** %x, align 8
  br label %for.cond.260

for.end.276:                                      ; preds = %for.cond.260
  %265 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %266 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %267 = bitcast %struct.num* %v to { i8, i64 }*
  %268 = getelementptr { i8, i64 }, { i8, i64 }* %267, i32 0, i32 0
  %269 = load i8, i8* %268, align 1
  %270 = getelementptr { i8, i64 }, { i8, i64 }* %267, i32 0, i32 1
  %271 = load i64, i64* %270, align 1
  %call277 = call %struct.cell* @mk_number(%struct.scheme* %266, i8 %269, i64 %271)
  %call278 = call %struct.cell* @_s_return(%struct.scheme* %265, %struct.cell* %call277)
  store %struct.cell* %call278, %struct.cell** %retval
  br label %return

sw.bb.279:                                        ; preds = %entry
  %272 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args280 = getelementptr inbounds %struct.scheme, %struct.scheme* %272, i32 0, i32 7
  %273 = load %struct.cell*, %struct.cell** %args280, align 8
  %_object281 = getelementptr inbounds %struct.cell, %struct.cell* %273, i32 0, i32 1
  %_cons282 = bitcast %union.anon* %_object281 to %struct.anon.4*
  %_cdr283 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons282, i32 0, i32 1
  %274 = load %struct.cell*, %struct.cell** %_cdr283, align 8
  %275 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL284 = getelementptr inbounds %struct.scheme, %struct.scheme* %275, i32 0, i32 17
  %276 = load %struct.cell*, %struct.cell** %NIL284, align 8
  %cmp285 = icmp eq %struct.cell* %274, %276
  br i1 %cmp285, label %if.then.287, label %if.else.289

if.then.287:                                      ; preds = %sw.bb.279
  %277 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args288 = getelementptr inbounds %struct.scheme, %struct.scheme* %277, i32 0, i32 7
  %278 = load %struct.cell*, %struct.cell** %args288, align 8
  store %struct.cell* %278, %struct.cell** %x, align 8
  %279 = bitcast %struct.num* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %279, i8* getelementptr inbounds (%struct.num, %struct.num* @num_one, i32 0, i32 0), i64 16, i32 8, i1 false)
  br label %if.end.300

if.else.289:                                      ; preds = %sw.bb.279
  %280 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args290 = getelementptr inbounds %struct.scheme, %struct.scheme* %280, i32 0, i32 7
  %281 = load %struct.cell*, %struct.cell** %args290, align 8
  %_object291 = getelementptr inbounds %struct.cell, %struct.cell* %281, i32 0, i32 1
  %_cons292 = bitcast %union.anon* %_object291 to %struct.anon.4*
  %_cdr293 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons292, i32 0, i32 1
  %282 = load %struct.cell*, %struct.cell** %_cdr293, align 8
  store %struct.cell* %282, %struct.cell** %x, align 8
  %283 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args294 = getelementptr inbounds %struct.scheme, %struct.scheme* %283, i32 0, i32 7
  %284 = load %struct.cell*, %struct.cell** %args294, align 8
  %_object295 = getelementptr inbounds %struct.cell, %struct.cell* %284, i32 0, i32 1
  %_cons296 = bitcast %union.anon* %_object295 to %struct.anon.4*
  %_car297 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons296, i32 0, i32 0
  %285 = load %struct.cell*, %struct.cell** %_car297, align 8
  %call298 = call { i8, i64 } @nvalue(%struct.cell* %285)
  %286 = bitcast %struct.num* %coerce299 to { i8, i64 }*
  %287 = getelementptr { i8, i64 }, { i8, i64 }* %286, i32 0, i32 0
  %288 = extractvalue { i8, i64 } %call298, 0
  store i8 %288, i8* %287, align 8
  %289 = getelementptr { i8, i64 }, { i8, i64 }* %286, i32 0, i32 1
  %290 = extractvalue { i8, i64 } %call298, 1
  store i64 %290, i64* %289, align 8
  %291 = bitcast %struct.num* %v to i8*
  %292 = bitcast %struct.num* %coerce299 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %291, i8* %292, i64 16, i32 8, i1 false)
  br label %if.end.300

if.end.300:                                       ; preds = %if.else.289, %if.then.287
  br label %for.cond.301

for.cond.301:                                     ; preds = %for.inc.323, %if.end.300
  %293 = load %struct.cell*, %struct.cell** %x, align 8
  %294 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL302 = getelementptr inbounds %struct.scheme, %struct.scheme* %294, i32 0, i32 17
  %295 = load %struct.cell*, %struct.cell** %NIL302, align 8
  %cmp303 = icmp ne %struct.cell* %293, %295
  br i1 %cmp303, label %for.body.305, label %for.end.327

for.body.305:                                     ; preds = %for.cond.301
  %296 = load %struct.cell*, %struct.cell** %x, align 8
  %_object306 = getelementptr inbounds %struct.cell, %struct.cell* %296, i32 0, i32 1
  %_cons307 = bitcast %union.anon* %_object306 to %struct.anon.4*
  %_car308 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons307, i32 0, i32 0
  %297 = load %struct.cell*, %struct.cell** %_car308, align 8
  %call309 = call double @rvalue(%struct.cell* %297)
  %call310 = call i32 @is_zero_double(double %call309)
  %tobool311 = icmp ne i32 %call310, 0
  br i1 %tobool311, label %if.else.320, label %if.then.312

if.then.312:                                      ; preds = %for.body.305
  %298 = load %struct.cell*, %struct.cell** %x, align 8
  %_object314 = getelementptr inbounds %struct.cell, %struct.cell* %298, i32 0, i32 1
  %_cons315 = bitcast %union.anon* %_object314 to %struct.anon.4*
  %_car316 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons315, i32 0, i32 0
  %299 = load %struct.cell*, %struct.cell** %_car316, align 8
  %call317 = call { i8, i64 } @nvalue(%struct.cell* %299)
  %300 = bitcast %struct.num* %agg.tmp313 to { i8, i64 }*
  %301 = getelementptr { i8, i64 }, { i8, i64 }* %300, i32 0, i32 0
  %302 = extractvalue { i8, i64 } %call317, 0
  store i8 %302, i8* %301, align 8
  %303 = getelementptr { i8, i64 }, { i8, i64 }* %300, i32 0, i32 1
  %304 = extractvalue { i8, i64 } %call317, 1
  store i64 %304, i64* %303, align 8
  %305 = bitcast %struct.num* %v to { i8, i64 }*
  %306 = getelementptr { i8, i64 }, { i8, i64 }* %305, i32 0, i32 0
  %307 = load i8, i8* %306, align 1
  %308 = getelementptr { i8, i64 }, { i8, i64 }* %305, i32 0, i32 1
  %309 = load i64, i64* %308, align 1
  %310 = bitcast %struct.num* %agg.tmp313 to { i8, i64 }*
  %311 = getelementptr { i8, i64 }, { i8, i64 }* %310, i32 0, i32 0
  %312 = load i8, i8* %311, align 1
  %313 = getelementptr { i8, i64 }, { i8, i64 }* %310, i32 0, i32 1
  %314 = load i64, i64* %313, align 1
  %call318 = call { i8, i64 } @num_div(i8 %307, i64 %309, i8 %312, i64 %314)
  %315 = bitcast %struct.num* %coerce319 to { i8, i64 }*
  %316 = getelementptr { i8, i64 }, { i8, i64 }* %315, i32 0, i32 0
  %317 = extractvalue { i8, i64 } %call318, 0
  store i8 %317, i8* %316, align 8
  %318 = getelementptr { i8, i64 }, { i8, i64 }* %315, i32 0, i32 1
  %319 = extractvalue { i8, i64 } %call318, 1
  store i64 %319, i64* %318, align 8
  %320 = bitcast %struct.num* %v to i8*
  %321 = bitcast %struct.num* %coerce319 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %320, i8* %321, i64 16, i32 8, i1 false)
  br label %if.end.322

if.else.320:                                      ; preds = %for.body.305
  %322 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call321 = call %struct.cell* @_Error_1(%struct.scheme* %322, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.198, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call321, %struct.cell** %retval
  br label %return

if.end.322:                                       ; preds = %if.then.312
  br label %for.inc.323

for.inc.323:                                      ; preds = %if.end.322
  %323 = load %struct.cell*, %struct.cell** %x, align 8
  %_object324 = getelementptr inbounds %struct.cell, %struct.cell* %323, i32 0, i32 1
  %_cons325 = bitcast %union.anon* %_object324 to %struct.anon.4*
  %_cdr326 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons325, i32 0, i32 1
  %324 = load %struct.cell*, %struct.cell** %_cdr326, align 8
  store %struct.cell* %324, %struct.cell** %x, align 8
  br label %for.cond.301

for.end.327:                                      ; preds = %for.cond.301
  %325 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %326 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %327 = bitcast %struct.num* %v to { i8, i64 }*
  %328 = getelementptr { i8, i64 }, { i8, i64 }* %327, i32 0, i32 0
  %329 = load i8, i8* %328, align 1
  %330 = getelementptr { i8, i64 }, { i8, i64 }* %327, i32 0, i32 1
  %331 = load i64, i64* %330, align 1
  %call328 = call %struct.cell* @mk_number(%struct.scheme* %326, i8 %329, i64 %331)
  %call329 = call %struct.cell* @_s_return(%struct.scheme* %325, %struct.cell* %call328)
  store %struct.cell* %call329, %struct.cell** %retval
  br label %return

sw.bb.330:                                        ; preds = %entry
  %332 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args331 = getelementptr inbounds %struct.scheme, %struct.scheme* %332, i32 0, i32 7
  %333 = load %struct.cell*, %struct.cell** %args331, align 8
  %_object332 = getelementptr inbounds %struct.cell, %struct.cell* %333, i32 0, i32 1
  %_cons333 = bitcast %union.anon* %_object332 to %struct.anon.4*
  %_cdr334 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons333, i32 0, i32 1
  %334 = load %struct.cell*, %struct.cell** %_cdr334, align 8
  %335 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL335 = getelementptr inbounds %struct.scheme, %struct.scheme* %335, i32 0, i32 17
  %336 = load %struct.cell*, %struct.cell** %NIL335, align 8
  %cmp336 = icmp eq %struct.cell* %334, %336
  br i1 %cmp336, label %if.then.338, label %if.else.340

if.then.338:                                      ; preds = %sw.bb.330
  %337 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args339 = getelementptr inbounds %struct.scheme, %struct.scheme* %337, i32 0, i32 7
  %338 = load %struct.cell*, %struct.cell** %args339, align 8
  store %struct.cell* %338, %struct.cell** %x, align 8
  %339 = bitcast %struct.num* %v to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %339, i8* getelementptr inbounds (%struct.num, %struct.num* @num_one, i32 0, i32 0), i64 16, i32 8, i1 false)
  br label %if.end.351

if.else.340:                                      ; preds = %sw.bb.330
  %340 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args341 = getelementptr inbounds %struct.scheme, %struct.scheme* %340, i32 0, i32 7
  %341 = load %struct.cell*, %struct.cell** %args341, align 8
  %_object342 = getelementptr inbounds %struct.cell, %struct.cell* %341, i32 0, i32 1
  %_cons343 = bitcast %union.anon* %_object342 to %struct.anon.4*
  %_cdr344 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons343, i32 0, i32 1
  %342 = load %struct.cell*, %struct.cell** %_cdr344, align 8
  store %struct.cell* %342, %struct.cell** %x, align 8
  %343 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args345 = getelementptr inbounds %struct.scheme, %struct.scheme* %343, i32 0, i32 7
  %344 = load %struct.cell*, %struct.cell** %args345, align 8
  %_object346 = getelementptr inbounds %struct.cell, %struct.cell* %344, i32 0, i32 1
  %_cons347 = bitcast %union.anon* %_object346 to %struct.anon.4*
  %_car348 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons347, i32 0, i32 0
  %345 = load %struct.cell*, %struct.cell** %_car348, align 8
  %call349 = call { i8, i64 } @nvalue(%struct.cell* %345)
  %346 = bitcast %struct.num* %coerce350 to { i8, i64 }*
  %347 = getelementptr { i8, i64 }, { i8, i64 }* %346, i32 0, i32 0
  %348 = extractvalue { i8, i64 } %call349, 0
  store i8 %348, i8* %347, align 8
  %349 = getelementptr { i8, i64 }, { i8, i64 }* %346, i32 0, i32 1
  %350 = extractvalue { i8, i64 } %call349, 1
  store i64 %350, i64* %349, align 8
  %351 = bitcast %struct.num* %v to i8*
  %352 = bitcast %struct.num* %coerce350 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %351, i8* %352, i64 16, i32 8, i1 false)
  br label %if.end.351

if.end.351:                                       ; preds = %if.else.340, %if.then.338
  br label %for.cond.352

for.cond.352:                                     ; preds = %for.inc.374, %if.end.351
  %353 = load %struct.cell*, %struct.cell** %x, align 8
  %354 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL353 = getelementptr inbounds %struct.scheme, %struct.scheme* %354, i32 0, i32 17
  %355 = load %struct.cell*, %struct.cell** %NIL353, align 8
  %cmp354 = icmp ne %struct.cell* %353, %355
  br i1 %cmp354, label %for.body.356, label %for.end.378

for.body.356:                                     ; preds = %for.cond.352
  %356 = load %struct.cell*, %struct.cell** %x, align 8
  %_object357 = getelementptr inbounds %struct.cell, %struct.cell* %356, i32 0, i32 1
  %_cons358 = bitcast %union.anon* %_object357 to %struct.anon.4*
  %_car359 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons358, i32 0, i32 0
  %357 = load %struct.cell*, %struct.cell** %_car359, align 8
  %call360 = call i64 @ivalue(%struct.cell* %357)
  %cmp361 = icmp ne i64 %call360, 0
  br i1 %cmp361, label %if.then.363, label %if.else.371

if.then.363:                                      ; preds = %for.body.356
  %358 = load %struct.cell*, %struct.cell** %x, align 8
  %_object365 = getelementptr inbounds %struct.cell, %struct.cell* %358, i32 0, i32 1
  %_cons366 = bitcast %union.anon* %_object365 to %struct.anon.4*
  %_car367 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons366, i32 0, i32 0
  %359 = load %struct.cell*, %struct.cell** %_car367, align 8
  %call368 = call { i8, i64 } @nvalue(%struct.cell* %359)
  %360 = bitcast %struct.num* %agg.tmp364 to { i8, i64 }*
  %361 = getelementptr { i8, i64 }, { i8, i64 }* %360, i32 0, i32 0
  %362 = extractvalue { i8, i64 } %call368, 0
  store i8 %362, i8* %361, align 8
  %363 = getelementptr { i8, i64 }, { i8, i64 }* %360, i32 0, i32 1
  %364 = extractvalue { i8, i64 } %call368, 1
  store i64 %364, i64* %363, align 8
  %365 = bitcast %struct.num* %v to { i8, i64 }*
  %366 = getelementptr { i8, i64 }, { i8, i64 }* %365, i32 0, i32 0
  %367 = load i8, i8* %366, align 1
  %368 = getelementptr { i8, i64 }, { i8, i64 }* %365, i32 0, i32 1
  %369 = load i64, i64* %368, align 1
  %370 = bitcast %struct.num* %agg.tmp364 to { i8, i64 }*
  %371 = getelementptr { i8, i64 }, { i8, i64 }* %370, i32 0, i32 0
  %372 = load i8, i8* %371, align 1
  %373 = getelementptr { i8, i64 }, { i8, i64 }* %370, i32 0, i32 1
  %374 = load i64, i64* %373, align 1
  %call369 = call { i8, i64 } @num_intdiv(i8 %367, i64 %369, i8 %372, i64 %374)
  %375 = bitcast %struct.num* %coerce370 to { i8, i64 }*
  %376 = getelementptr { i8, i64 }, { i8, i64 }* %375, i32 0, i32 0
  %377 = extractvalue { i8, i64 } %call369, 0
  store i8 %377, i8* %376, align 8
  %378 = getelementptr { i8, i64 }, { i8, i64 }* %375, i32 0, i32 1
  %379 = extractvalue { i8, i64 } %call369, 1
  store i64 %379, i64* %378, align 8
  %380 = bitcast %struct.num* %v to i8*
  %381 = bitcast %struct.num* %coerce370 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %380, i8* %381, i64 16, i32 8, i1 false)
  br label %if.end.373

if.else.371:                                      ; preds = %for.body.356
  %382 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call372 = call %struct.cell* @_Error_1(%struct.scheme* %382, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.199, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call372, %struct.cell** %retval
  br label %return

if.end.373:                                       ; preds = %if.then.363
  br label %for.inc.374

for.inc.374:                                      ; preds = %if.end.373
  %383 = load %struct.cell*, %struct.cell** %x, align 8
  %_object375 = getelementptr inbounds %struct.cell, %struct.cell* %383, i32 0, i32 1
  %_cons376 = bitcast %union.anon* %_object375 to %struct.anon.4*
  %_cdr377 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons376, i32 0, i32 1
  %384 = load %struct.cell*, %struct.cell** %_cdr377, align 8
  store %struct.cell* %384, %struct.cell** %x, align 8
  br label %for.cond.352

for.end.378:                                      ; preds = %for.cond.352
  %385 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %386 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %387 = bitcast %struct.num* %v to { i8, i64 }*
  %388 = getelementptr { i8, i64 }, { i8, i64 }* %387, i32 0, i32 0
  %389 = load i8, i8* %388, align 1
  %390 = getelementptr { i8, i64 }, { i8, i64 }* %387, i32 0, i32 1
  %391 = load i64, i64* %390, align 1
  %call379 = call %struct.cell* @mk_number(%struct.scheme* %386, i8 %389, i64 %391)
  %call380 = call %struct.cell* @_s_return(%struct.scheme* %385, %struct.cell* %call379)
  store %struct.cell* %call380, %struct.cell** %retval
  br label %return

sw.bb.381:                                        ; preds = %entry
  %392 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args382 = getelementptr inbounds %struct.scheme, %struct.scheme* %392, i32 0, i32 7
  %393 = load %struct.cell*, %struct.cell** %args382, align 8
  %_object383 = getelementptr inbounds %struct.cell, %struct.cell* %393, i32 0, i32 1
  %_cons384 = bitcast %union.anon* %_object383 to %struct.anon.4*
  %_car385 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons384, i32 0, i32 0
  %394 = load %struct.cell*, %struct.cell** %_car385, align 8
  %call386 = call { i8, i64 } @nvalue(%struct.cell* %394)
  %395 = bitcast %struct.num* %coerce387 to { i8, i64 }*
  %396 = getelementptr { i8, i64 }, { i8, i64 }* %395, i32 0, i32 0
  %397 = extractvalue { i8, i64 } %call386, 0
  store i8 %397, i8* %396, align 8
  %398 = getelementptr { i8, i64 }, { i8, i64 }* %395, i32 0, i32 1
  %399 = extractvalue { i8, i64 } %call386, 1
  store i64 %399, i64* %398, align 8
  %400 = bitcast %struct.num* %v to i8*
  %401 = bitcast %struct.num* %coerce387 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %400, i8* %401, i64 16, i32 8, i1 false)
  %402 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args388 = getelementptr inbounds %struct.scheme, %struct.scheme* %402, i32 0, i32 7
  %403 = load %struct.cell*, %struct.cell** %args388, align 8
  %_object389 = getelementptr inbounds %struct.cell, %struct.cell* %403, i32 0, i32 1
  %_cons390 = bitcast %union.anon* %_object389 to %struct.anon.4*
  %_cdr391 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons390, i32 0, i32 1
  %404 = load %struct.cell*, %struct.cell** %_cdr391, align 8
  %_object392 = getelementptr inbounds %struct.cell, %struct.cell* %404, i32 0, i32 1
  %_cons393 = bitcast %union.anon* %_object392 to %struct.anon.4*
  %_car394 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons393, i32 0, i32 0
  %405 = load %struct.cell*, %struct.cell** %_car394, align 8
  %call395 = call i64 @ivalue(%struct.cell* %405)
  %cmp396 = icmp ne i64 %call395, 0
  br i1 %cmp396, label %if.then.398, label %if.else.410

if.then.398:                                      ; preds = %sw.bb.381
  %406 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args400 = getelementptr inbounds %struct.scheme, %struct.scheme* %406, i32 0, i32 7
  %407 = load %struct.cell*, %struct.cell** %args400, align 8
  %_object401 = getelementptr inbounds %struct.cell, %struct.cell* %407, i32 0, i32 1
  %_cons402 = bitcast %union.anon* %_object401 to %struct.anon.4*
  %_cdr403 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons402, i32 0, i32 1
  %408 = load %struct.cell*, %struct.cell** %_cdr403, align 8
  %_object404 = getelementptr inbounds %struct.cell, %struct.cell* %408, i32 0, i32 1
  %_cons405 = bitcast %union.anon* %_object404 to %struct.anon.4*
  %_car406 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons405, i32 0, i32 0
  %409 = load %struct.cell*, %struct.cell** %_car406, align 8
  %call407 = call { i8, i64 } @nvalue(%struct.cell* %409)
  %410 = bitcast %struct.num* %agg.tmp399 to { i8, i64 }*
  %411 = getelementptr { i8, i64 }, { i8, i64 }* %410, i32 0, i32 0
  %412 = extractvalue { i8, i64 } %call407, 0
  store i8 %412, i8* %411, align 8
  %413 = getelementptr { i8, i64 }, { i8, i64 }* %410, i32 0, i32 1
  %414 = extractvalue { i8, i64 } %call407, 1
  store i64 %414, i64* %413, align 8
  %415 = bitcast %struct.num* %v to { i8, i64 }*
  %416 = getelementptr { i8, i64 }, { i8, i64 }* %415, i32 0, i32 0
  %417 = load i8, i8* %416, align 1
  %418 = getelementptr { i8, i64 }, { i8, i64 }* %415, i32 0, i32 1
  %419 = load i64, i64* %418, align 1
  %420 = bitcast %struct.num* %agg.tmp399 to { i8, i64 }*
  %421 = getelementptr { i8, i64 }, { i8, i64 }* %420, i32 0, i32 0
  %422 = load i8, i8* %421, align 1
  %423 = getelementptr { i8, i64 }, { i8, i64 }* %420, i32 0, i32 1
  %424 = load i64, i64* %423, align 1
  %call408 = call { i8, i64 } @num_rem(i8 %417, i64 %419, i8 %422, i64 %424)
  %425 = bitcast %struct.num* %coerce409 to { i8, i64 }*
  %426 = getelementptr { i8, i64 }, { i8, i64 }* %425, i32 0, i32 0
  %427 = extractvalue { i8, i64 } %call408, 0
  store i8 %427, i8* %426, align 8
  %428 = getelementptr { i8, i64 }, { i8, i64 }* %425, i32 0, i32 1
  %429 = extractvalue { i8, i64 } %call408, 1
  store i64 %429, i64* %428, align 8
  %430 = bitcast %struct.num* %v to i8*
  %431 = bitcast %struct.num* %coerce409 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %430, i8* %431, i64 16, i32 8, i1 false)
  br label %if.end.412

if.else.410:                                      ; preds = %sw.bb.381
  %432 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call411 = call %struct.cell* @_Error_1(%struct.scheme* %432, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.200, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call411, %struct.cell** %retval
  br label %return

if.end.412:                                       ; preds = %if.then.398
  %433 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %434 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %435 = bitcast %struct.num* %v to { i8, i64 }*
  %436 = getelementptr { i8, i64 }, { i8, i64 }* %435, i32 0, i32 0
  %437 = load i8, i8* %436, align 1
  %438 = getelementptr { i8, i64 }, { i8, i64 }* %435, i32 0, i32 1
  %439 = load i64, i64* %438, align 1
  %call413 = call %struct.cell* @mk_number(%struct.scheme* %434, i8 %437, i64 %439)
  %call414 = call %struct.cell* @_s_return(%struct.scheme* %433, %struct.cell* %call413)
  store %struct.cell* %call414, %struct.cell** %retval
  br label %return

sw.bb.415:                                        ; preds = %entry
  %440 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args416 = getelementptr inbounds %struct.scheme, %struct.scheme* %440, i32 0, i32 7
  %441 = load %struct.cell*, %struct.cell** %args416, align 8
  %_object417 = getelementptr inbounds %struct.cell, %struct.cell* %441, i32 0, i32 1
  %_cons418 = bitcast %union.anon* %_object417 to %struct.anon.4*
  %_car419 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons418, i32 0, i32 0
  %442 = load %struct.cell*, %struct.cell** %_car419, align 8
  %call420 = call { i8, i64 } @nvalue(%struct.cell* %442)
  %443 = bitcast %struct.num* %coerce421 to { i8, i64 }*
  %444 = getelementptr { i8, i64 }, { i8, i64 }* %443, i32 0, i32 0
  %445 = extractvalue { i8, i64 } %call420, 0
  store i8 %445, i8* %444, align 8
  %446 = getelementptr { i8, i64 }, { i8, i64 }* %443, i32 0, i32 1
  %447 = extractvalue { i8, i64 } %call420, 1
  store i64 %447, i64* %446, align 8
  %448 = bitcast %struct.num* %v to i8*
  %449 = bitcast %struct.num* %coerce421 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %448, i8* %449, i64 16, i32 8, i1 false)
  %450 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args422 = getelementptr inbounds %struct.scheme, %struct.scheme* %450, i32 0, i32 7
  %451 = load %struct.cell*, %struct.cell** %args422, align 8
  %_object423 = getelementptr inbounds %struct.cell, %struct.cell* %451, i32 0, i32 1
  %_cons424 = bitcast %union.anon* %_object423 to %struct.anon.4*
  %_cdr425 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons424, i32 0, i32 1
  %452 = load %struct.cell*, %struct.cell** %_cdr425, align 8
  %_object426 = getelementptr inbounds %struct.cell, %struct.cell* %452, i32 0, i32 1
  %_cons427 = bitcast %union.anon* %_object426 to %struct.anon.4*
  %_car428 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons427, i32 0, i32 0
  %453 = load %struct.cell*, %struct.cell** %_car428, align 8
  %call429 = call i64 @ivalue(%struct.cell* %453)
  %cmp430 = icmp ne i64 %call429, 0
  br i1 %cmp430, label %if.then.432, label %if.else.444

if.then.432:                                      ; preds = %sw.bb.415
  %454 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args434 = getelementptr inbounds %struct.scheme, %struct.scheme* %454, i32 0, i32 7
  %455 = load %struct.cell*, %struct.cell** %args434, align 8
  %_object435 = getelementptr inbounds %struct.cell, %struct.cell* %455, i32 0, i32 1
  %_cons436 = bitcast %union.anon* %_object435 to %struct.anon.4*
  %_cdr437 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons436, i32 0, i32 1
  %456 = load %struct.cell*, %struct.cell** %_cdr437, align 8
  %_object438 = getelementptr inbounds %struct.cell, %struct.cell* %456, i32 0, i32 1
  %_cons439 = bitcast %union.anon* %_object438 to %struct.anon.4*
  %_car440 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons439, i32 0, i32 0
  %457 = load %struct.cell*, %struct.cell** %_car440, align 8
  %call441 = call { i8, i64 } @nvalue(%struct.cell* %457)
  %458 = bitcast %struct.num* %agg.tmp433 to { i8, i64 }*
  %459 = getelementptr { i8, i64 }, { i8, i64 }* %458, i32 0, i32 0
  %460 = extractvalue { i8, i64 } %call441, 0
  store i8 %460, i8* %459, align 8
  %461 = getelementptr { i8, i64 }, { i8, i64 }* %458, i32 0, i32 1
  %462 = extractvalue { i8, i64 } %call441, 1
  store i64 %462, i64* %461, align 8
  %463 = bitcast %struct.num* %v to { i8, i64 }*
  %464 = getelementptr { i8, i64 }, { i8, i64 }* %463, i32 0, i32 0
  %465 = load i8, i8* %464, align 1
  %466 = getelementptr { i8, i64 }, { i8, i64 }* %463, i32 0, i32 1
  %467 = load i64, i64* %466, align 1
  %468 = bitcast %struct.num* %agg.tmp433 to { i8, i64 }*
  %469 = getelementptr { i8, i64 }, { i8, i64 }* %468, i32 0, i32 0
  %470 = load i8, i8* %469, align 1
  %471 = getelementptr { i8, i64 }, { i8, i64 }* %468, i32 0, i32 1
  %472 = load i64, i64* %471, align 1
  %call442 = call { i8, i64 } @num_mod(i8 %465, i64 %467, i8 %470, i64 %472)
  %473 = bitcast %struct.num* %coerce443 to { i8, i64 }*
  %474 = getelementptr { i8, i64 }, { i8, i64 }* %473, i32 0, i32 0
  %475 = extractvalue { i8, i64 } %call442, 0
  store i8 %475, i8* %474, align 8
  %476 = getelementptr { i8, i64 }, { i8, i64 }* %473, i32 0, i32 1
  %477 = extractvalue { i8, i64 } %call442, 1
  store i64 %477, i64* %476, align 8
  %478 = bitcast %struct.num* %v to i8*
  %479 = bitcast %struct.num* %coerce443 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %478, i8* %479, i64 16, i32 8, i1 false)
  br label %if.end.446

if.else.444:                                      ; preds = %sw.bb.415
  %480 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call445 = call %struct.cell* @_Error_1(%struct.scheme* %480, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.201, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call445, %struct.cell** %retval
  br label %return

if.end.446:                                       ; preds = %if.then.432
  %481 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %482 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %483 = bitcast %struct.num* %v to { i8, i64 }*
  %484 = getelementptr { i8, i64 }, { i8, i64 }* %483, i32 0, i32 0
  %485 = load i8, i8* %484, align 1
  %486 = getelementptr { i8, i64 }, { i8, i64 }* %483, i32 0, i32 1
  %487 = load i64, i64* %486, align 1
  %call447 = call %struct.cell* @mk_number(%struct.scheme* %482, i8 %485, i64 %487)
  %call448 = call %struct.cell* @_s_return(%struct.scheme* %481, %struct.cell* %call447)
  store %struct.cell* %call448, %struct.cell** %retval
  br label %return

sw.bb.449:                                        ; preds = %entry
  %488 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %489 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args450 = getelementptr inbounds %struct.scheme, %struct.scheme* %489, i32 0, i32 7
  %490 = load %struct.cell*, %struct.cell** %args450, align 8
  %_object451 = getelementptr inbounds %struct.cell, %struct.cell* %490, i32 0, i32 1
  %_cons452 = bitcast %union.anon* %_object451 to %struct.anon.4*
  %_car453 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons452, i32 0, i32 0
  %491 = load %struct.cell*, %struct.cell** %_car453, align 8
  %_object454 = getelementptr inbounds %struct.cell, %struct.cell* %491, i32 0, i32 1
  %_cons455 = bitcast %union.anon* %_object454 to %struct.anon.4*
  %_car456 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons455, i32 0, i32 0
  %492 = load %struct.cell*, %struct.cell** %_car456, align 8
  %call457 = call %struct.cell* @_s_return(%struct.scheme* %488, %struct.cell* %492)
  store %struct.cell* %call457, %struct.cell** %retval
  br label %return

sw.bb.458:                                        ; preds = %entry
  %493 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %494 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args459 = getelementptr inbounds %struct.scheme, %struct.scheme* %494, i32 0, i32 7
  %495 = load %struct.cell*, %struct.cell** %args459, align 8
  %_object460 = getelementptr inbounds %struct.cell, %struct.cell* %495, i32 0, i32 1
  %_cons461 = bitcast %union.anon* %_object460 to %struct.anon.4*
  %_car462 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons461, i32 0, i32 0
  %496 = load %struct.cell*, %struct.cell** %_car462, align 8
  %_object463 = getelementptr inbounds %struct.cell, %struct.cell* %496, i32 0, i32 1
  %_cons464 = bitcast %union.anon* %_object463 to %struct.anon.4*
  %_cdr465 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons464, i32 0, i32 1
  %497 = load %struct.cell*, %struct.cell** %_cdr465, align 8
  %call466 = call %struct.cell* @_s_return(%struct.scheme* %493, %struct.cell* %497)
  store %struct.cell* %call466, %struct.cell** %retval
  br label %return

sw.bb.467:                                        ; preds = %entry
  %498 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args468 = getelementptr inbounds %struct.scheme, %struct.scheme* %498, i32 0, i32 7
  %499 = load %struct.cell*, %struct.cell** %args468, align 8
  %_object469 = getelementptr inbounds %struct.cell, %struct.cell* %499, i32 0, i32 1
  %_cons470 = bitcast %union.anon* %_object469 to %struct.anon.4*
  %_cdr471 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons470, i32 0, i32 1
  %500 = load %struct.cell*, %struct.cell** %_cdr471, align 8
  %_object472 = getelementptr inbounds %struct.cell, %struct.cell* %500, i32 0, i32 1
  %_cons473 = bitcast %union.anon* %_object472 to %struct.anon.4*
  %_car474 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons473, i32 0, i32 0
  %501 = load %struct.cell*, %struct.cell** %_car474, align 8
  %502 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args475 = getelementptr inbounds %struct.scheme, %struct.scheme* %502, i32 0, i32 7
  %503 = load %struct.cell*, %struct.cell** %args475, align 8
  %_object476 = getelementptr inbounds %struct.cell, %struct.cell* %503, i32 0, i32 1
  %_cons477 = bitcast %union.anon* %_object476 to %struct.anon.4*
  %_cdr478 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons477, i32 0, i32 1
  store %struct.cell* %501, %struct.cell** %_cdr478, align 8
  %504 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %505 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args479 = getelementptr inbounds %struct.scheme, %struct.scheme* %505, i32 0, i32 7
  %506 = load %struct.cell*, %struct.cell** %args479, align 8
  %call480 = call %struct.cell* @_s_return(%struct.scheme* %504, %struct.cell* %506)
  store %struct.cell* %call480, %struct.cell** %retval
  br label %return

sw.bb.481:                                        ; preds = %entry
  %507 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args482 = getelementptr inbounds %struct.scheme, %struct.scheme* %507, i32 0, i32 7
  %508 = load %struct.cell*, %struct.cell** %args482, align 8
  %_object483 = getelementptr inbounds %struct.cell, %struct.cell* %508, i32 0, i32 1
  %_cons484 = bitcast %union.anon* %_object483 to %struct.anon.4*
  %_car485 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons484, i32 0, i32 0
  %509 = load %struct.cell*, %struct.cell** %_car485, align 8
  %call486 = call i32 @is_immutable(%struct.cell* %509)
  %tobool487 = icmp ne i32 %call486, 0
  br i1 %tobool487, label %if.else.508, label %if.then.488

if.then.488:                                      ; preds = %sw.bb.481
  %510 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args489 = getelementptr inbounds %struct.scheme, %struct.scheme* %510, i32 0, i32 7
  %511 = load %struct.cell*, %struct.cell** %args489, align 8
  %_object490 = getelementptr inbounds %struct.cell, %struct.cell* %511, i32 0, i32 1
  %_cons491 = bitcast %union.anon* %_object490 to %struct.anon.4*
  %_cdr492 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons491, i32 0, i32 1
  %512 = load %struct.cell*, %struct.cell** %_cdr492, align 8
  %_object493 = getelementptr inbounds %struct.cell, %struct.cell* %512, i32 0, i32 1
  %_cons494 = bitcast %union.anon* %_object493 to %struct.anon.4*
  %_car495 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons494, i32 0, i32 0
  %513 = load %struct.cell*, %struct.cell** %_car495, align 8
  %514 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args496 = getelementptr inbounds %struct.scheme, %struct.scheme* %514, i32 0, i32 7
  %515 = load %struct.cell*, %struct.cell** %args496, align 8
  %_object497 = getelementptr inbounds %struct.cell, %struct.cell* %515, i32 0, i32 1
  %_cons498 = bitcast %union.anon* %_object497 to %struct.anon.4*
  %_car499 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons498, i32 0, i32 0
  %516 = load %struct.cell*, %struct.cell** %_car499, align 8
  %_object500 = getelementptr inbounds %struct.cell, %struct.cell* %516, i32 0, i32 1
  %_cons501 = bitcast %union.anon* %_object500 to %struct.anon.4*
  %_car502 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons501, i32 0, i32 0
  store %struct.cell* %513, %struct.cell** %_car502, align 8
  %517 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %518 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args503 = getelementptr inbounds %struct.scheme, %struct.scheme* %518, i32 0, i32 7
  %519 = load %struct.cell*, %struct.cell** %args503, align 8
  %_object504 = getelementptr inbounds %struct.cell, %struct.cell* %519, i32 0, i32 1
  %_cons505 = bitcast %union.anon* %_object504 to %struct.anon.4*
  %_car506 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons505, i32 0, i32 0
  %520 = load %struct.cell*, %struct.cell** %_car506, align 8
  %call507 = call %struct.cell* @_s_return(%struct.scheme* %517, %struct.cell* %520)
  store %struct.cell* %call507, %struct.cell** %retval
  br label %return

if.else.508:                                      ; preds = %sw.bb.481
  %521 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call509 = call %struct.cell* @_Error_1(%struct.scheme* %521, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.202, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call509, %struct.cell** %retval
  br label %return

sw.bb.510:                                        ; preds = %entry
  %522 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args511 = getelementptr inbounds %struct.scheme, %struct.scheme* %522, i32 0, i32 7
  %523 = load %struct.cell*, %struct.cell** %args511, align 8
  %_object512 = getelementptr inbounds %struct.cell, %struct.cell* %523, i32 0, i32 1
  %_cons513 = bitcast %union.anon* %_object512 to %struct.anon.4*
  %_car514 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons513, i32 0, i32 0
  %524 = load %struct.cell*, %struct.cell** %_car514, align 8
  %call515 = call i32 @is_immutable(%struct.cell* %524)
  %tobool516 = icmp ne i32 %call515, 0
  br i1 %tobool516, label %if.else.537, label %if.then.517

if.then.517:                                      ; preds = %sw.bb.510
  %525 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args518 = getelementptr inbounds %struct.scheme, %struct.scheme* %525, i32 0, i32 7
  %526 = load %struct.cell*, %struct.cell** %args518, align 8
  %_object519 = getelementptr inbounds %struct.cell, %struct.cell* %526, i32 0, i32 1
  %_cons520 = bitcast %union.anon* %_object519 to %struct.anon.4*
  %_cdr521 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons520, i32 0, i32 1
  %527 = load %struct.cell*, %struct.cell** %_cdr521, align 8
  %_object522 = getelementptr inbounds %struct.cell, %struct.cell* %527, i32 0, i32 1
  %_cons523 = bitcast %union.anon* %_object522 to %struct.anon.4*
  %_car524 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons523, i32 0, i32 0
  %528 = load %struct.cell*, %struct.cell** %_car524, align 8
  %529 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args525 = getelementptr inbounds %struct.scheme, %struct.scheme* %529, i32 0, i32 7
  %530 = load %struct.cell*, %struct.cell** %args525, align 8
  %_object526 = getelementptr inbounds %struct.cell, %struct.cell* %530, i32 0, i32 1
  %_cons527 = bitcast %union.anon* %_object526 to %struct.anon.4*
  %_car528 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons527, i32 0, i32 0
  %531 = load %struct.cell*, %struct.cell** %_car528, align 8
  %_object529 = getelementptr inbounds %struct.cell, %struct.cell* %531, i32 0, i32 1
  %_cons530 = bitcast %union.anon* %_object529 to %struct.anon.4*
  %_cdr531 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons530, i32 0, i32 1
  store %struct.cell* %528, %struct.cell** %_cdr531, align 8
  %532 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %533 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args532 = getelementptr inbounds %struct.scheme, %struct.scheme* %533, i32 0, i32 7
  %534 = load %struct.cell*, %struct.cell** %args532, align 8
  %_object533 = getelementptr inbounds %struct.cell, %struct.cell* %534, i32 0, i32 1
  %_cons534 = bitcast %union.anon* %_object533 to %struct.anon.4*
  %_car535 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons534, i32 0, i32 0
  %535 = load %struct.cell*, %struct.cell** %_car535, align 8
  %call536 = call %struct.cell* @_s_return(%struct.scheme* %532, %struct.cell* %535)
  store %struct.cell* %call536, %struct.cell** %retval
  br label %return

if.else.537:                                      ; preds = %sw.bb.510
  %536 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call538 = call %struct.cell* @_Error_1(%struct.scheme* %536, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.203, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call538, %struct.cell** %retval
  br label %return

sw.bb.539:                                        ; preds = %entry
  %537 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args540 = getelementptr inbounds %struct.scheme, %struct.scheme* %537, i32 0, i32 7
  %538 = load %struct.cell*, %struct.cell** %args540, align 8
  %_object541 = getelementptr inbounds %struct.cell, %struct.cell* %538, i32 0, i32 1
  %_cons542 = bitcast %union.anon* %_object541 to %struct.anon.4*
  %_car543 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons542, i32 0, i32 0
  %539 = load %struct.cell*, %struct.cell** %_car543, align 8
  %call544 = call i64 @ivalue(%struct.cell* %539)
  %conv545 = trunc i64 %call544 to i32
  store i32 %conv545, i32* %c, align 4
  %540 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %541 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %542 = load i32, i32* %c, align 4
  %conv546 = zext i32 %542 to i64
  %call547 = call %struct.cell* @mk_integer(%struct.scheme* %541, i64 %conv546)
  %call548 = call %struct.cell* @_s_return(%struct.scheme* %540, %struct.cell* %call547)
  store %struct.cell* %call548, %struct.cell** %retval
  br label %return

sw.bb.549:                                        ; preds = %entry
  %543 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args551 = getelementptr inbounds %struct.scheme, %struct.scheme* %543, i32 0, i32 7
  %544 = load %struct.cell*, %struct.cell** %args551, align 8
  %_object552 = getelementptr inbounds %struct.cell, %struct.cell* %544, i32 0, i32 1
  %_cons553 = bitcast %union.anon* %_object552 to %struct.anon.4*
  %_car554 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons553, i32 0, i32 0
  %545 = load %struct.cell*, %struct.cell** %_car554, align 8
  %call555 = call i64 @ivalue(%struct.cell* %545)
  %conv556 = trunc i64 %call555 to i32
  store i32 %conv556, i32* %c550, align 4
  %546 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %547 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %548 = load i32, i32* %c550, align 4
  %call557 = call %struct.cell* @mk_character(%struct.scheme* %547, i32 %548)
  %call558 = call %struct.cell* @_s_return(%struct.scheme* %546, %struct.cell* %call557)
  store %struct.cell* %call558, %struct.cell** %retval
  br label %return

sw.bb.559:                                        ; preds = %entry
  %549 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args561 = getelementptr inbounds %struct.scheme, %struct.scheme* %549, i32 0, i32 7
  %550 = load %struct.cell*, %struct.cell** %args561, align 8
  %_object562 = getelementptr inbounds %struct.cell, %struct.cell* %550, i32 0, i32 1
  %_cons563 = bitcast %union.anon* %_object562 to %struct.anon.4*
  %_car564 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons563, i32 0, i32 0
  %551 = load %struct.cell*, %struct.cell** %_car564, align 8
  %call565 = call i64 @ivalue(%struct.cell* %551)
  %conv566 = trunc i64 %call565 to i32
  store i32 %conv566, i32* %c560, align 4
  %552 = load i32, i32* %c560, align 4
  %call567 = call i32 @g_unichar_toupper(i32 %552) #7
  store i32 %call567, i32* %c560, align 4
  %553 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %554 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %555 = load i32, i32* %c560, align 4
  %call568 = call %struct.cell* @mk_character(%struct.scheme* %554, i32 %555)
  %call569 = call %struct.cell* @_s_return(%struct.scheme* %553, %struct.cell* %call568)
  store %struct.cell* %call569, %struct.cell** %retval
  br label %return

sw.bb.570:                                        ; preds = %entry
  %556 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args572 = getelementptr inbounds %struct.scheme, %struct.scheme* %556, i32 0, i32 7
  %557 = load %struct.cell*, %struct.cell** %args572, align 8
  %_object573 = getelementptr inbounds %struct.cell, %struct.cell* %557, i32 0, i32 1
  %_cons574 = bitcast %union.anon* %_object573 to %struct.anon.4*
  %_car575 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons574, i32 0, i32 0
  %558 = load %struct.cell*, %struct.cell** %_car575, align 8
  %call576 = call i64 @ivalue(%struct.cell* %558)
  %conv577 = trunc i64 %call576 to i32
  store i32 %conv577, i32* %c571, align 4
  %559 = load i32, i32* %c571, align 4
  %call578 = call i32 @g_unichar_tolower(i32 %559) #7
  store i32 %call578, i32* %c571, align 4
  %560 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %561 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %562 = load i32, i32* %c571, align 4
  %call579 = call %struct.cell* @mk_character(%struct.scheme* %561, i32 %562)
  %call580 = call %struct.cell* @_s_return(%struct.scheme* %560, %struct.cell* %call579)
  store %struct.cell* %call580, %struct.cell** %retval
  br label %return

sw.bb.581:                                        ; preds = %entry
  %563 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %564 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %565 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args582 = getelementptr inbounds %struct.scheme, %struct.scheme* %565, i32 0, i32 7
  %566 = load %struct.cell*, %struct.cell** %args582, align 8
  %_object583 = getelementptr inbounds %struct.cell, %struct.cell* %566, i32 0, i32 1
  %_cons584 = bitcast %union.anon* %_object583 to %struct.anon.4*
  %_car585 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons584, i32 0, i32 0
  %567 = load %struct.cell*, %struct.cell** %_car585, align 8
  %_object586 = getelementptr inbounds %struct.cell, %struct.cell* %567, i32 0, i32 1
  %_string = bitcast %union.anon* %_object586 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %568 = load i8*, i8** %_svalue, align 8
  %call587 = call %struct.cell* @mk_symbol(%struct.scheme* %564, i8* %568)
  %call588 = call %struct.cell* @_s_return(%struct.scheme* %563, %struct.cell* %call587)
  store %struct.cell* %call588, %struct.cell** %retval
  br label %return

sw.bb.589:                                        ; preds = %entry
  %569 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args590 = getelementptr inbounds %struct.scheme, %struct.scheme* %569, i32 0, i32 7
  %570 = load %struct.cell*, %struct.cell** %args590, align 8
  %_object591 = getelementptr inbounds %struct.cell, %struct.cell* %570, i32 0, i32 1
  %_cons592 = bitcast %union.anon* %_object591 to %struct.anon.4*
  %_car593 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons592, i32 0, i32 0
  %571 = load %struct.cell*, %struct.cell** %_car593, align 8
  %_object594 = getelementptr inbounds %struct.cell, %struct.cell* %571, i32 0, i32 1
  %_string595 = bitcast %union.anon* %_object594 to %struct.anon*
  %_svalue596 = getelementptr inbounds %struct.anon, %struct.anon* %_string595, i32 0, i32 0
  %572 = load i8*, i8** %_svalue596, align 8
  store i8* %572, i8** %s, align 8
  %573 = load i8*, i8** %s, align 8
  %574 = load i8, i8* %573, align 1
  %conv597 = sext i8 %574 to i32
  %cmp598 = icmp eq i32 %conv597, 35
  br i1 %cmp598, label %if.then.600, label %if.else.603

if.then.600:                                      ; preds = %sw.bb.589
  %575 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %576 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %577 = load i8*, i8** %s, align 8
  %add.ptr = getelementptr inbounds i8, i8* %577, i64 1
  %call601 = call %struct.cell* @mk_sharp_const(%struct.scheme* %576, i8* %add.ptr)
  %call602 = call %struct.cell* @_s_return(%struct.scheme* %575, %struct.cell* %call601)
  store %struct.cell* %call602, %struct.cell** %retval
  br label %return

if.else.603:                                      ; preds = %sw.bb.589
  %578 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %579 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %580 = load i8*, i8** %s, align 8
  %call604 = call %struct.cell* @mk_atom(%struct.scheme* %579, i8* %580)
  %call605 = call %struct.cell* @_s_return(%struct.scheme* %578, %struct.cell* %call604)
  store %struct.cell* %call605, %struct.cell** %retval
  br label %return

sw.bb.606:                                        ; preds = %entry
  %581 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %582 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args607 = getelementptr inbounds %struct.scheme, %struct.scheme* %582, i32 0, i32 7
  %583 = load %struct.cell*, %struct.cell** %args607, align 8
  %_object608 = getelementptr inbounds %struct.cell, %struct.cell* %583, i32 0, i32 1
  %_cons609 = bitcast %union.anon* %_object608 to %struct.anon.4*
  %_car610 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons609, i32 0, i32 0
  %584 = load %struct.cell*, %struct.cell** %_car610, align 8
  %call611 = call i8* @symname(%struct.cell* %584)
  %call612 = call %struct.cell* @mk_string(%struct.scheme* %581, i8* %call611)
  store %struct.cell* %call612, %struct.cell** %x, align 8
  %585 = load %struct.cell*, %struct.cell** %x, align 8
  call void @setimmutable(%struct.cell* %585)
  %586 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %587 = load %struct.cell*, %struct.cell** %x, align 8
  %call613 = call %struct.cell* @_s_return(%struct.scheme* %586, %struct.cell* %587)
  store %struct.cell* %call613, %struct.cell** %retval
  br label %return

sw.bb.614:                                        ; preds = %entry
  %588 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args615 = getelementptr inbounds %struct.scheme, %struct.scheme* %588, i32 0, i32 7
  %589 = load %struct.cell*, %struct.cell** %args615, align 8
  %_object616 = getelementptr inbounds %struct.cell, %struct.cell* %589, i32 0, i32 1
  %_cons617 = bitcast %union.anon* %_object616 to %struct.anon.4*
  %_car618 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons617, i32 0, i32 0
  %590 = load %struct.cell*, %struct.cell** %_car618, align 8
  store %struct.cell* %590, %struct.cell** %x, align 8
  %591 = load %struct.cell*, %struct.cell** %x, align 8
  %call619 = call i32 @is_number(%struct.cell* %591)
  %tobool620 = icmp ne i32 %call619, 0
  br i1 %tobool620, label %if.then.629, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb.614
  %592 = load %struct.cell*, %struct.cell** %x, align 8
  %call621 = call i32 @is_character(%struct.cell* %592)
  %tobool622 = icmp ne i32 %call621, 0
  br i1 %tobool622, label %if.then.629, label %lor.lhs.false.623

lor.lhs.false.623:                                ; preds = %lor.lhs.false
  %593 = load %struct.cell*, %struct.cell** %x, align 8
  %call624 = call i32 @is_string(%struct.cell* %593)
  %tobool625 = icmp ne i32 %call624, 0
  br i1 %tobool625, label %if.then.629, label %lor.lhs.false.626

lor.lhs.false.626:                                ; preds = %lor.lhs.false.623
  %594 = load %struct.cell*, %struct.cell** %x, align 8
  %call627 = call i32 @is_symbol(%struct.cell* %594)
  %tobool628 = icmp ne i32 %call627, 0
  br i1 %tobool628, label %if.then.629, label %if.else.632

if.then.629:                                      ; preds = %lor.lhs.false.626, %lor.lhs.false.623, %lor.lhs.false, %sw.bb.614
  %595 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %596 = load %struct.cell*, %struct.cell** %x, align 8
  call void @atom2str(%struct.scheme* %595, %struct.cell* %596, i32 0, i8** %p, i32* %len)
  %597 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %598 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %599 = load i8*, i8** %p, align 8
  %600 = load i32, i32* %len, align 4
  %call630 = call %struct.cell* @mk_counted_string(%struct.scheme* %598, i8* %599, i32 %600)
  %call631 = call %struct.cell* @_s_return(%struct.scheme* %597, %struct.cell* %call630)
  store %struct.cell* %call631, %struct.cell** %retval
  br label %return

if.else.632:                                      ; preds = %lor.lhs.false.626
  %601 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %602 = load %struct.cell*, %struct.cell** %x, align 8
  %call633 = call %struct.cell* @_Error_1(%struct.scheme* %601, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.204, i32 0, i32 0), %struct.cell* %602)
  store %struct.cell* %call633, %struct.cell** %retval
  br label %return

sw.bb.634:                                        ; preds = %entry
  store i32 32, i32* %fill, align 4
  %603 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args636 = getelementptr inbounds %struct.scheme, %struct.scheme* %603, i32 0, i32 7
  %604 = load %struct.cell*, %struct.cell** %args636, align 8
  %_object637 = getelementptr inbounds %struct.cell, %struct.cell* %604, i32 0, i32 1
  %_cons638 = bitcast %union.anon* %_object637 to %struct.anon.4*
  %_car639 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons638, i32 0, i32 0
  %605 = load %struct.cell*, %struct.cell** %_car639, align 8
  %call640 = call i64 @ivalue(%struct.cell* %605)
  %conv641 = trunc i64 %call640 to i32
  store i32 %conv641, i32* %len635, align 4
  %606 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args642 = getelementptr inbounds %struct.scheme, %struct.scheme* %606, i32 0, i32 7
  %607 = load %struct.cell*, %struct.cell** %args642, align 8
  %_object643 = getelementptr inbounds %struct.cell, %struct.cell* %607, i32 0, i32 1
  %_cons644 = bitcast %union.anon* %_object643 to %struct.anon.4*
  %_cdr645 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons644, i32 0, i32 1
  %608 = load %struct.cell*, %struct.cell** %_cdr645, align 8
  %609 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL646 = getelementptr inbounds %struct.scheme, %struct.scheme* %609, i32 0, i32 17
  %610 = load %struct.cell*, %struct.cell** %NIL646, align 8
  %cmp647 = icmp ne %struct.cell* %608, %610
  br i1 %cmp647, label %if.then.649, label %if.end.658

if.then.649:                                      ; preds = %sw.bb.634
  %611 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args650 = getelementptr inbounds %struct.scheme, %struct.scheme* %611, i32 0, i32 7
  %612 = load %struct.cell*, %struct.cell** %args650, align 8
  %_object651 = getelementptr inbounds %struct.cell, %struct.cell* %612, i32 0, i32 1
  %_cons652 = bitcast %union.anon* %_object651 to %struct.anon.4*
  %_cdr653 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons652, i32 0, i32 1
  %613 = load %struct.cell*, %struct.cell** %_cdr653, align 8
  %_object654 = getelementptr inbounds %struct.cell, %struct.cell* %613, i32 0, i32 1
  %_cons655 = bitcast %union.anon* %_object654 to %struct.anon.4*
  %_car656 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons655, i32 0, i32 0
  %614 = load %struct.cell*, %struct.cell** %_car656, align 8
  %call657 = call i32 @charvalue(%struct.cell* %614)
  store i32 %call657, i32* %fill, align 4
  br label %if.end.658

if.end.658:                                       ; preds = %if.then.649, %sw.bb.634
  %615 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %616 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %617 = load i32, i32* %len635, align 4
  %618 = load i32, i32* %fill, align 4
  %call659 = call %struct.cell* @mk_empty_string(%struct.scheme* %616, i32 %617, i32 %618)
  %call660 = call %struct.cell* @_s_return(%struct.scheme* %615, %struct.cell* %call659)
  store %struct.cell* %call660, %struct.cell** %retval
  br label %return

sw.bb.661:                                        ; preds = %entry
  %619 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %620 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %621 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args662 = getelementptr inbounds %struct.scheme, %struct.scheme* %621, i32 0, i32 7
  %622 = load %struct.cell*, %struct.cell** %args662, align 8
  %_object663 = getelementptr inbounds %struct.cell, %struct.cell* %622, i32 0, i32 1
  %_cons664 = bitcast %union.anon* %_object663 to %struct.anon.4*
  %_car665 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons664, i32 0, i32 0
  %623 = load %struct.cell*, %struct.cell** %_car665, align 8
  %_object666 = getelementptr inbounds %struct.cell, %struct.cell* %623, i32 0, i32 1
  %_string667 = bitcast %union.anon* %_object666 to %struct.anon*
  %_svalue668 = getelementptr inbounds %struct.anon, %struct.anon* %_string667, i32 0, i32 0
  %624 = load i8*, i8** %_svalue668, align 8
  %call669 = call i64 @g_utf8_strlen(i8* %624, i64 -1) #6
  %call670 = call %struct.cell* @mk_integer(%struct.scheme* %620, i64 %call669)
  %call671 = call %struct.cell* @_s_return(%struct.scheme* %619, %struct.cell* %call670)
  store %struct.cell* %call671, %struct.cell** %retval
  br label %return

sw.bb.672:                                        ; preds = %entry
  %625 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args673 = getelementptr inbounds %struct.scheme, %struct.scheme* %625, i32 0, i32 7
  %626 = load %struct.cell*, %struct.cell** %args673, align 8
  %_object674 = getelementptr inbounds %struct.cell, %struct.cell* %626, i32 0, i32 1
  %_cons675 = bitcast %union.anon* %_object674 to %struct.anon.4*
  %_car676 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons675, i32 0, i32 0
  %627 = load %struct.cell*, %struct.cell** %_car676, align 8
  %_object677 = getelementptr inbounds %struct.cell, %struct.cell* %627, i32 0, i32 1
  %_string678 = bitcast %union.anon* %_object677 to %struct.anon*
  %_svalue679 = getelementptr inbounds %struct.anon, %struct.anon* %_string678, i32 0, i32 0
  %628 = load i8*, i8** %_svalue679, align 8
  store i8* %628, i8** %str, align 8
  %629 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args680 = getelementptr inbounds %struct.scheme, %struct.scheme* %629, i32 0, i32 7
  %630 = load %struct.cell*, %struct.cell** %args680, align 8
  %_object681 = getelementptr inbounds %struct.cell, %struct.cell* %630, i32 0, i32 1
  %_cons682 = bitcast %union.anon* %_object681 to %struct.anon.4*
  %_cdr683 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons682, i32 0, i32 1
  %631 = load %struct.cell*, %struct.cell** %_cdr683, align 8
  %_object684 = getelementptr inbounds %struct.cell, %struct.cell* %631, i32 0, i32 1
  %_cons685 = bitcast %union.anon* %_object684 to %struct.anon.4*
  %_car686 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons685, i32 0, i32 0
  %632 = load %struct.cell*, %struct.cell** %_car686, align 8
  %call687 = call i64 @ivalue(%struct.cell* %632)
  %conv688 = trunc i64 %call687 to i32
  store i32 %conv688, i32* %index, align 4
  %633 = load i32, i32* %index, align 4
  %conv689 = sext i32 %633 to i64
  %634 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args690 = getelementptr inbounds %struct.scheme, %struct.scheme* %634, i32 0, i32 7
  %635 = load %struct.cell*, %struct.cell** %args690, align 8
  %_object691 = getelementptr inbounds %struct.cell, %struct.cell* %635, i32 0, i32 1
  %_cons692 = bitcast %union.anon* %_object691 to %struct.anon.4*
  %_car693 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons692, i32 0, i32 0
  %636 = load %struct.cell*, %struct.cell** %_car693, align 8
  %_object694 = getelementptr inbounds %struct.cell, %struct.cell* %636, i32 0, i32 1
  %_string695 = bitcast %union.anon* %_object694 to %struct.anon*
  %_svalue696 = getelementptr inbounds %struct.anon, %struct.anon* %_string695, i32 0, i32 0
  %637 = load i8*, i8** %_svalue696, align 8
  %call697 = call i64 @g_utf8_strlen(i8* %637, i64 -1) #6
  %cmp698 = icmp sge i64 %conv689, %call697
  br i1 %cmp698, label %if.then.700, label %if.end.709

if.then.700:                                      ; preds = %sw.bb.672
  %638 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %639 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args701 = getelementptr inbounds %struct.scheme, %struct.scheme* %639, i32 0, i32 7
  %640 = load %struct.cell*, %struct.cell** %args701, align 8
  %_object702 = getelementptr inbounds %struct.cell, %struct.cell* %640, i32 0, i32 1
  %_cons703 = bitcast %union.anon* %_object702 to %struct.anon.4*
  %_cdr704 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons703, i32 0, i32 1
  %641 = load %struct.cell*, %struct.cell** %_cdr704, align 8
  %_object705 = getelementptr inbounds %struct.cell, %struct.cell* %641, i32 0, i32 1
  %_cons706 = bitcast %union.anon* %_object705 to %struct.anon.4*
  %_car707 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons706, i32 0, i32 0
  %642 = load %struct.cell*, %struct.cell** %_car707, align 8
  %call708 = call %struct.cell* @_Error_1(%struct.scheme* %638, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.205, i32 0, i32 0), %struct.cell* %642)
  store %struct.cell* %call708, %struct.cell** %retval
  br label %return

if.end.709:                                       ; preds = %sw.bb.672
  %643 = load i8*, i8** %str, align 8
  %644 = load i32, i32* %index, align 4
  %conv710 = sext i32 %644 to i64
  %call711 = call i8* @g_utf8_offset_to_pointer(i8* %643, i64 %conv710) #6
  store i8* %call711, i8** %str, align 8
  %645 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %646 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %647 = load i8*, i8** %str, align 8
  %call712 = call i32 @g_utf8_get_char(i8* %647) #6
  %call713 = call %struct.cell* @mk_character(%struct.scheme* %646, i32 %call712)
  %call714 = call %struct.cell* @_s_return(%struct.scheme* %645, %struct.cell* %call713)
  store %struct.cell* %call714, %struct.cell** %retval
  br label %return

sw.bb.715:                                        ; preds = %entry
  %648 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args719 = getelementptr inbounds %struct.scheme, %struct.scheme* %648, i32 0, i32 7
  %649 = load %struct.cell*, %struct.cell** %args719, align 8
  %_object720 = getelementptr inbounds %struct.cell, %struct.cell* %649, i32 0, i32 1
  %_cons721 = bitcast %union.anon* %_object720 to %struct.anon.4*
  %_car722 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons721, i32 0, i32 0
  %650 = load %struct.cell*, %struct.cell** %_car722, align 8
  store %struct.cell* %650, %struct.cell** %a, align 8
  %651 = load %struct.cell*, %struct.cell** %a, align 8
  %call723 = call i32 @is_immutable(%struct.cell* %651)
  %tobool724 = icmp ne i32 %call723, 0
  br i1 %tobool724, label %if.then.725, label %if.end.727

if.then.725:                                      ; preds = %sw.bb.715
  %652 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %653 = load %struct.cell*, %struct.cell** %a, align 8
  %call726 = call %struct.cell* @_Error_1(%struct.scheme* %652, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.206, i32 0, i32 0), %struct.cell* %653)
  store %struct.cell* %call726, %struct.cell** %retval
  br label %return

if.end.727:                                       ; preds = %sw.bb.715
  %654 = load %struct.cell*, %struct.cell** %a, align 8
  %_object728 = getelementptr inbounds %struct.cell, %struct.cell* %654, i32 0, i32 1
  %_string729 = bitcast %union.anon* %_object728 to %struct.anon*
  %_svalue730 = getelementptr inbounds %struct.anon, %struct.anon* %_string729, i32 0, i32 0
  %655 = load i8*, i8** %_svalue730, align 8
  store i8* %655, i8** %str716, align 8
  %656 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args731 = getelementptr inbounds %struct.scheme, %struct.scheme* %656, i32 0, i32 7
  %657 = load %struct.cell*, %struct.cell** %args731, align 8
  %_object732 = getelementptr inbounds %struct.cell, %struct.cell* %657, i32 0, i32 1
  %_cons733 = bitcast %union.anon* %_object732 to %struct.anon.4*
  %_cdr734 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons733, i32 0, i32 1
  %658 = load %struct.cell*, %struct.cell** %_cdr734, align 8
  %_object735 = getelementptr inbounds %struct.cell, %struct.cell* %658, i32 0, i32 1
  %_cons736 = bitcast %union.anon* %_object735 to %struct.anon.4*
  %_car737 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons736, i32 0, i32 0
  %659 = load %struct.cell*, %struct.cell** %_car737, align 8
  %call738 = call i64 @ivalue(%struct.cell* %659)
  %conv739 = trunc i64 %call738 to i32
  store i32 %conv739, i32* %index717, align 4
  %660 = load i32, i32* %index717, align 4
  %conv740 = sext i32 %660 to i64
  %661 = load i8*, i8** %str716, align 8
  %call741 = call i64 @g_utf8_strlen(i8* %661, i64 -1) #6
  %cmp742 = icmp sge i64 %conv740, %call741
  br i1 %cmp742, label %if.then.744, label %if.end.753

if.then.744:                                      ; preds = %if.end.727
  %662 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %663 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args745 = getelementptr inbounds %struct.scheme, %struct.scheme* %663, i32 0, i32 7
  %664 = load %struct.cell*, %struct.cell** %args745, align 8
  %_object746 = getelementptr inbounds %struct.cell, %struct.cell* %664, i32 0, i32 1
  %_cons747 = bitcast %union.anon* %_object746 to %struct.anon.4*
  %_cdr748 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons747, i32 0, i32 1
  %665 = load %struct.cell*, %struct.cell** %_cdr748, align 8
  %_object749 = getelementptr inbounds %struct.cell, %struct.cell* %665, i32 0, i32 1
  %_cons750 = bitcast %union.anon* %_object749 to %struct.anon.4*
  %_car751 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons750, i32 0, i32 0
  %666 = load %struct.cell*, %struct.cell** %_car751, align 8
  %call752 = call %struct.cell* @_Error_1(%struct.scheme* %662, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.207, i32 0, i32 0), %struct.cell* %666)
  store %struct.cell* %call752, %struct.cell** %retval
  br label %return

if.end.753:                                       ; preds = %if.end.727
  %667 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args754 = getelementptr inbounds %struct.scheme, %struct.scheme* %667, i32 0, i32 7
  %668 = load %struct.cell*, %struct.cell** %args754, align 8
  %_object755 = getelementptr inbounds %struct.cell, %struct.cell* %668, i32 0, i32 1
  %_cons756 = bitcast %union.anon* %_object755 to %struct.anon.4*
  %_cdr757 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons756, i32 0, i32 1
  %669 = load %struct.cell*, %struct.cell** %_cdr757, align 8
  %_object758 = getelementptr inbounds %struct.cell, %struct.cell* %669, i32 0, i32 1
  %_cons759 = bitcast %union.anon* %_object758 to %struct.anon.4*
  %_cdr760 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons759, i32 0, i32 1
  %670 = load %struct.cell*, %struct.cell** %_cdr760, align 8
  %_object761 = getelementptr inbounds %struct.cell, %struct.cell* %670, i32 0, i32 1
  %_cons762 = bitcast %union.anon* %_object761 to %struct.anon.4*
  %_car763 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons762, i32 0, i32 0
  %671 = load %struct.cell*, %struct.cell** %_car763, align 8
  %call764 = call i32 @charvalue(%struct.cell* %671)
  store i32 %call764, i32* %c718, align 4
  %672 = load i32, i32* %c718, align 4
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i32 0
  %call765 = call i32 @g_unichar_to_utf8(i32 %672, i8* %arraydecay)
  store i32 %call765, i32* %utf8_len, align 4
  %673 = load i8*, i8** %str716, align 8
  %674 = load i32, i32* %index717, align 4
  %conv766 = sext i32 %674 to i64
  %call767 = call i8* @g_utf8_offset_to_pointer(i8* %673, i64 %conv766) #6
  store i8* %call767, i8** %p1, align 8
  %675 = load i8*, i8** %str716, align 8
  %676 = load i32, i32* %index717, align 4
  %conv768 = sext i32 %676 to i64
  %add = add nsw i64 %conv768, 1
  %call769 = call i8* @g_utf8_offset_to_pointer(i8* %675, i64 %add) #6
  store i8* %call769, i8** %p2, align 8
  %677 = load i8*, i8** %p1, align 8
  %678 = load i8*, i8** %str716, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %677 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %678 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv770 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv770, i32* %p1_len, align 4
  %679 = load i8*, i8** %p2, align 8
  %call771 = call i64 @strlen(i8* %679) #6
  %conv772 = trunc i64 %call771 to i32
  store i32 %conv772, i32* %p2_len, align 4
  %680 = load i32, i32* %p1_len, align 4
  %681 = load i32, i32* %utf8_len, align 4
  %add773 = add nsw i32 %680, %681
  %682 = load i32, i32* %p2_len, align 4
  %add774 = add nsw i32 %add773, %682
  store i32 %add774, i32* %newlen, align 4
  %683 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %683, i32 0, i32 0
  %684 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %685 = load i32, i32* %newlen, align 4
  %add775 = add nsw i32 %685, 1
  %conv776 = sext i32 %add775 to i64
  %call777 = call i8* %684(i64 %conv776)
  store i8* %call777, i8** %newstr, align 8
  %686 = load i8*, i8** %newstr, align 8
  %cmp778 = icmp eq i8* %686, null
  br i1 %cmp778, label %if.then.780, label %if.end.786

if.then.780:                                      ; preds = %if.end.753
  %687 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory = getelementptr inbounds %struct.scheme, %struct.scheme* %687, i32 0, i32 48
  store i8 1, i8* %no_memory, align 1
  %688 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %689 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args781 = getelementptr inbounds %struct.scheme, %struct.scheme* %689, i32 0, i32 7
  %690 = load %struct.cell*, %struct.cell** %args781, align 8
  %_object782 = getelementptr inbounds %struct.cell, %struct.cell* %690, i32 0, i32 1
  %_cons783 = bitcast %union.anon* %_object782 to %struct.anon.4*
  %_car784 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons783, i32 0, i32 0
  %691 = load %struct.cell*, %struct.cell** %_car784, align 8
  %call785 = call %struct.cell* @_Error_1(%struct.scheme* %688, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.208, i32 0, i32 0), %struct.cell* %691)
  store %struct.cell* %call785, %struct.cell** %retval
  br label %return

if.end.786:                                       ; preds = %if.end.753
  %692 = load i32, i32* %p1_len, align 4
  %cmp787 = icmp sgt i32 %692, 0
  br i1 %cmp787, label %if.then.789, label %if.end.791

if.then.789:                                      ; preds = %if.end.786
  %693 = load i8*, i8** %newstr, align 8
  %694 = load i8*, i8** %str716, align 8
  %695 = load i32, i32* %p1_len, align 4
  %conv790 = sext i32 %695 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %693, i8* %694, i64 %conv790, i32 1, i1 false)
  br label %if.end.791

if.end.791:                                       ; preds = %if.then.789, %if.end.786
  %696 = load i8*, i8** %newstr, align 8
  %697 = load i32, i32* %p1_len, align 4
  %idx.ext = sext i32 %697 to i64
  %add.ptr792 = getelementptr inbounds i8, i8* %696, i64 %idx.ext
  %698 = bitcast [7 x i8]* %utf8 to i8*
  %699 = load i32, i32* %utf8_len, align 4
  %conv793 = sext i32 %699 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr792, i8* %698, i64 %conv793, i32 1, i1 false)
  %700 = load i32, i32* %p2_len, align 4
  %cmp794 = icmp sgt i32 %700, 0
  br i1 %cmp794, label %if.then.796, label %if.end.802

if.then.796:                                      ; preds = %if.end.791
  %701 = load i8*, i8** %newstr, align 8
  %702 = load i32, i32* %p1_len, align 4
  %idx.ext797 = sext i32 %702 to i64
  %add.ptr798 = getelementptr inbounds i8, i8* %701, i64 %idx.ext797
  %703 = load i32, i32* %utf8_len, align 4
  %idx.ext799 = sext i32 %703 to i64
  %add.ptr800 = getelementptr inbounds i8, i8* %add.ptr798, i64 %idx.ext799
  %704 = load i8*, i8** %p2, align 8
  %705 = load i32, i32* %p2_len, align 4
  %conv801 = sext i32 %705 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr800, i8* %704, i64 %conv801, i32 1, i1 false)
  br label %if.end.802

if.end.802:                                       ; preds = %if.then.796, %if.end.791
  %706 = load i32, i32* %newlen, align 4
  %idxprom = sext i32 %706 to i64
  %707 = load i8*, i8** %newstr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %707, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  %708 = load %struct.cell*, %struct.cell** %a, align 8
  %_object803 = getelementptr inbounds %struct.cell, %struct.cell* %708, i32 0, i32 1
  %_string804 = bitcast %union.anon* %_object803 to %struct.anon*
  %_svalue805 = getelementptr inbounds %struct.anon, %struct.anon* %_string804, i32 0, i32 0
  %709 = load i8*, i8** %_svalue805, align 8
  call void @free(i8* %709) #2
  %710 = load i8*, i8** %newstr, align 8
  %711 = load %struct.cell*, %struct.cell** %a, align 8
  %_object806 = getelementptr inbounds %struct.cell, %struct.cell* %711, i32 0, i32 1
  %_string807 = bitcast %union.anon* %_object806 to %struct.anon*
  %_svalue808 = getelementptr inbounds %struct.anon, %struct.anon* %_string807, i32 0, i32 0
  store i8* %710, i8** %_svalue808, align 8
  %712 = load i8*, i8** %newstr, align 8
  %call809 = call i64 @g_utf8_strlen(i8* %712, i64 -1) #6
  %conv810 = trunc i64 %call809 to i32
  %713 = load %struct.cell*, %struct.cell** %a, align 8
  %_object811 = getelementptr inbounds %struct.cell, %struct.cell* %713, i32 0, i32 1
  %_string812 = bitcast %union.anon* %_object811 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string812, i32 0, i32 1
  store i32 %conv810, i32* %_length, align 4
  %714 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %715 = load %struct.cell*, %struct.cell** %a, align 8
  %call813 = call %struct.cell* @_s_return(%struct.scheme* %714, %struct.cell* %715)
  store %struct.cell* %call813, %struct.cell** %retval
  br label %return

sw.bb.814:                                        ; preds = %entry
  store i32 0, i32* %len815, align 4
  %716 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args817 = getelementptr inbounds %struct.scheme, %struct.scheme* %716, i32 0, i32 7
  %717 = load %struct.cell*, %struct.cell** %args817, align 8
  store %struct.cell* %717, %struct.cell** %x, align 8
  br label %for.cond.818

for.cond.818:                                     ; preds = %for.inc.843, %sw.bb.814
  %718 = load %struct.cell*, %struct.cell** %x, align 8
  %719 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL819 = getelementptr inbounds %struct.scheme, %struct.scheme* %719, i32 0, i32 17
  %720 = load %struct.cell*, %struct.cell** %NIL819, align 8
  %cmp820 = icmp ne %struct.cell* %718, %720
  br i1 %cmp820, label %for.body.822, label %for.end.847

for.body.822:                                     ; preds = %for.cond.818
  %721 = load %struct.cell*, %struct.cell** %x, align 8
  %_object823 = getelementptr inbounds %struct.cell, %struct.cell* %721, i32 0, i32 1
  %_cons824 = bitcast %union.anon* %_object823 to %struct.anon.4*
  %_car825 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons824, i32 0, i32 0
  %722 = load %struct.cell*, %struct.cell** %_car825, align 8
  store %struct.cell* %722, %struct.cell** %car_x, align 8
  %723 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object826 = getelementptr inbounds %struct.cell, %struct.cell* %723, i32 0, i32 1
  %_string827 = bitcast %union.anon* %_object826 to %struct.anon*
  %_svalue828 = getelementptr inbounds %struct.anon, %struct.anon* %_string827, i32 0, i32 0
  %724 = load i8*, i8** %_svalue828, align 8
  %725 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object829 = getelementptr inbounds %struct.cell, %struct.cell* %725, i32 0, i32 1
  %_string830 = bitcast %union.anon* %_object829 to %struct.anon*
  %_length831 = getelementptr inbounds %struct.anon, %struct.anon* %_string830, i32 0, i32 1
  %726 = load i32, i32* %_length831, align 4
  %conv832 = sext i32 %726 to i64
  %call833 = call i8* @g_utf8_offset_to_pointer(i8* %724, i64 %conv832) #6
  store i8* %call833, i8** %end, align 8
  %727 = load i8*, i8** %end, align 8
  %728 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object834 = getelementptr inbounds %struct.cell, %struct.cell* %728, i32 0, i32 1
  %_string835 = bitcast %union.anon* %_object834 to %struct.anon*
  %_svalue836 = getelementptr inbounds %struct.anon, %struct.anon* %_string835, i32 0, i32 0
  %729 = load i8*, i8** %_svalue836, align 8
  %sub.ptr.lhs.cast837 = ptrtoint i8* %727 to i64
  %sub.ptr.rhs.cast838 = ptrtoint i8* %729 to i64
  %sub.ptr.sub839 = sub i64 %sub.ptr.lhs.cast837, %sub.ptr.rhs.cast838
  %730 = load i32, i32* %len815, align 4
  %conv840 = sext i32 %730 to i64
  %add841 = add nsw i64 %conv840, %sub.ptr.sub839
  %conv842 = trunc i64 %add841 to i32
  store i32 %conv842, i32* %len815, align 4
  br label %for.inc.843

for.inc.843:                                      ; preds = %for.body.822
  %731 = load %struct.cell*, %struct.cell** %x, align 8
  %_object844 = getelementptr inbounds %struct.cell, %struct.cell* %731, i32 0, i32 1
  %_cons845 = bitcast %union.anon* %_object844 to %struct.anon.4*
  %_cdr846 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons845, i32 0, i32 1
  %732 = load %struct.cell*, %struct.cell** %_cdr846, align 8
  store %struct.cell* %732, %struct.cell** %x, align 8
  br label %for.cond.818

for.end.847:                                      ; preds = %for.cond.818
  %733 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc848 = getelementptr inbounds %struct.scheme, %struct.scheme* %733, i32 0, i32 0
  %734 = load i8* (i64)*, i8* (i64)** %malloc848, align 8
  %735 = load i32, i32* %len815, align 4
  %add849 = add nsw i32 %735, 1
  %conv850 = sext i32 %add849 to i64
  %call851 = call i8* %734(i64 %conv850)
  store i8* %call851, i8** %newstr816, align 8
  %736 = load i8*, i8** %newstr816, align 8
  %cmp852 = icmp eq i8* %736, null
  br i1 %cmp852, label %if.then.854, label %if.end.861

if.then.854:                                      ; preds = %for.end.847
  %737 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory855 = getelementptr inbounds %struct.scheme, %struct.scheme* %737, i32 0, i32 48
  store i8 1, i8* %no_memory855, align 1
  %738 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %739 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args856 = getelementptr inbounds %struct.scheme, %struct.scheme* %739, i32 0, i32 7
  %740 = load %struct.cell*, %struct.cell** %args856, align 8
  %_object857 = getelementptr inbounds %struct.cell, %struct.cell* %740, i32 0, i32 1
  %_cons858 = bitcast %union.anon* %_object857 to %struct.anon.4*
  %_car859 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons858, i32 0, i32 0
  %741 = load %struct.cell*, %struct.cell** %_car859, align 8
  %call860 = call %struct.cell* @_Error_1(%struct.scheme* %738, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.209, i32 0, i32 0), %struct.cell* %741)
  store %struct.cell* %call860, %struct.cell** %retval
  br label %return

if.end.861:                                       ; preds = %for.end.847
  %742 = load i8*, i8** %newstr816, align 8
  store i8* %742, i8** %pos, align 8
  %743 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args862 = getelementptr inbounds %struct.scheme, %struct.scheme* %743, i32 0, i32 7
  %744 = load %struct.cell*, %struct.cell** %args862, align 8
  store %struct.cell* %744, %struct.cell** %x, align 8
  br label %for.cond.863

for.cond.863:                                     ; preds = %for.inc.892, %if.end.861
  %745 = load %struct.cell*, %struct.cell** %x, align 8
  %746 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL864 = getelementptr inbounds %struct.scheme, %struct.scheme* %746, i32 0, i32 17
  %747 = load %struct.cell*, %struct.cell** %NIL864, align 8
  %cmp865 = icmp ne %struct.cell* %745, %747
  br i1 %cmp865, label %for.body.867, label %for.end.896

for.body.867:                                     ; preds = %for.cond.863
  %748 = load %struct.cell*, %struct.cell** %x, align 8
  %_object868 = getelementptr inbounds %struct.cell, %struct.cell* %748, i32 0, i32 1
  %_cons869 = bitcast %union.anon* %_object868 to %struct.anon.4*
  %_car870 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons869, i32 0, i32 0
  %749 = load %struct.cell*, %struct.cell** %_car870, align 8
  store %struct.cell* %749, %struct.cell** %car_x, align 8
  %750 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object871 = getelementptr inbounds %struct.cell, %struct.cell* %750, i32 0, i32 1
  %_string872 = bitcast %union.anon* %_object871 to %struct.anon*
  %_svalue873 = getelementptr inbounds %struct.anon, %struct.anon* %_string872, i32 0, i32 0
  %751 = load i8*, i8** %_svalue873, align 8
  %752 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object874 = getelementptr inbounds %struct.cell, %struct.cell* %752, i32 0, i32 1
  %_string875 = bitcast %union.anon* %_object874 to %struct.anon*
  %_length876 = getelementptr inbounds %struct.anon, %struct.anon* %_string875, i32 0, i32 1
  %753 = load i32, i32* %_length876, align 4
  %conv877 = sext i32 %753 to i64
  %call878 = call i8* @g_utf8_offset_to_pointer(i8* %751, i64 %conv877) #6
  store i8* %call878, i8** %end, align 8
  %754 = load i8*, i8** %end, align 8
  %755 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object879 = getelementptr inbounds %struct.cell, %struct.cell* %755, i32 0, i32 1
  %_string880 = bitcast %union.anon* %_object879 to %struct.anon*
  %_svalue881 = getelementptr inbounds %struct.anon, %struct.anon* %_string880, i32 0, i32 0
  %756 = load i8*, i8** %_svalue881, align 8
  %sub.ptr.lhs.cast882 = ptrtoint i8* %754 to i64
  %sub.ptr.rhs.cast883 = ptrtoint i8* %756 to i64
  %sub.ptr.sub884 = sub i64 %sub.ptr.lhs.cast882, %sub.ptr.rhs.cast883
  %conv885 = trunc i64 %sub.ptr.sub884 to i32
  store i32 %conv885, i32* %len815, align 4
  %757 = load i8*, i8** %pos, align 8
  %758 = load %struct.cell*, %struct.cell** %car_x, align 8
  %_object886 = getelementptr inbounds %struct.cell, %struct.cell* %758, i32 0, i32 1
  %_string887 = bitcast %union.anon* %_object886 to %struct.anon*
  %_svalue888 = getelementptr inbounds %struct.anon, %struct.anon* %_string887, i32 0, i32 0
  %759 = load i8*, i8** %_svalue888, align 8
  %760 = load i32, i32* %len815, align 4
  %conv889 = sext i32 %760 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %757, i8* %759, i64 %conv889, i32 1, i1 false)
  %761 = load i32, i32* %len815, align 4
  %762 = load i8*, i8** %pos, align 8
  %idx.ext890 = sext i32 %761 to i64
  %add.ptr891 = getelementptr inbounds i8, i8* %762, i64 %idx.ext890
  store i8* %add.ptr891, i8** %pos, align 8
  br label %for.inc.892

for.inc.892:                                      ; preds = %for.body.867
  %763 = load %struct.cell*, %struct.cell** %x, align 8
  %_object893 = getelementptr inbounds %struct.cell, %struct.cell* %763, i32 0, i32 1
  %_cons894 = bitcast %union.anon* %_object893 to %struct.anon.4*
  %_cdr895 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons894, i32 0, i32 1
  %764 = load %struct.cell*, %struct.cell** %_cdr895, align 8
  store %struct.cell* %764, %struct.cell** %x, align 8
  br label %for.cond.863

for.end.896:                                      ; preds = %for.cond.863
  %765 = load i8*, i8** %pos, align 8
  store i8 0, i8* %765, align 1
  %766 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %767 = load i8*, i8** %newstr816, align 8
  %call897 = call %struct.cell* @mk_string(%struct.scheme* %766, i8* %767)
  store %struct.cell* %call897, %struct.cell** %car_x, align 8
  %768 = load i8*, i8** %newstr816, align 8
  call void @g_free(i8* %768)
  %769 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %770 = load %struct.cell*, %struct.cell** %car_x, align 8
  %call898 = call %struct.cell* @_s_return(%struct.scheme* %769, %struct.cell* %770)
  store %struct.cell* %call898, %struct.cell** %retval
  br label %return

sw.bb.899:                                        ; preds = %entry
  %771 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args904 = getelementptr inbounds %struct.scheme, %struct.scheme* %771, i32 0, i32 7
  %772 = load %struct.cell*, %struct.cell** %args904, align 8
  %_object905 = getelementptr inbounds %struct.cell, %struct.cell* %772, i32 0, i32 1
  %_cons906 = bitcast %union.anon* %_object905 to %struct.anon.4*
  %_car907 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons906, i32 0, i32 0
  %773 = load %struct.cell*, %struct.cell** %_car907, align 8
  %_object908 = getelementptr inbounds %struct.cell, %struct.cell* %773, i32 0, i32 1
  %_string909 = bitcast %union.anon* %_object908 to %struct.anon*
  %_svalue910 = getelementptr inbounds %struct.anon, %struct.anon* %_string909, i32 0, i32 0
  %774 = load i8*, i8** %_svalue910, align 8
  store i8* %774, i8** %str900, align 8
  %775 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args911 = getelementptr inbounds %struct.scheme, %struct.scheme* %775, i32 0, i32 7
  %776 = load %struct.cell*, %struct.cell** %args911, align 8
  %_object912 = getelementptr inbounds %struct.cell, %struct.cell* %776, i32 0, i32 1
  %_cons913 = bitcast %union.anon* %_object912 to %struct.anon.4*
  %_cdr914 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons913, i32 0, i32 1
  %777 = load %struct.cell*, %struct.cell** %_cdr914, align 8
  %_object915 = getelementptr inbounds %struct.cell, %struct.cell* %777, i32 0, i32 1
  %_cons916 = bitcast %union.anon* %_object915 to %struct.anon.4*
  %_car917 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons916, i32 0, i32 0
  %778 = load %struct.cell*, %struct.cell** %_car917, align 8
  %call918 = call i64 @ivalue(%struct.cell* %778)
  %conv919 = trunc i64 %call918 to i32
  store i32 %conv919, i32* %index0, align 4
  %779 = load i32, i32* %index0, align 4
  %conv920 = sext i32 %779 to i64
  %780 = load i8*, i8** %str900, align 8
  %call921 = call i64 @g_utf8_strlen(i8* %780, i64 -1) #6
  %cmp922 = icmp sgt i64 %conv920, %call921
  br i1 %cmp922, label %if.then.924, label %if.end.933

if.then.924:                                      ; preds = %sw.bb.899
  %781 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %782 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args925 = getelementptr inbounds %struct.scheme, %struct.scheme* %782, i32 0, i32 7
  %783 = load %struct.cell*, %struct.cell** %args925, align 8
  %_object926 = getelementptr inbounds %struct.cell, %struct.cell* %783, i32 0, i32 1
  %_cons927 = bitcast %union.anon* %_object926 to %struct.anon.4*
  %_cdr928 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons927, i32 0, i32 1
  %784 = load %struct.cell*, %struct.cell** %_cdr928, align 8
  %_object929 = getelementptr inbounds %struct.cell, %struct.cell* %784, i32 0, i32 1
  %_cons930 = bitcast %union.anon* %_object929 to %struct.anon.4*
  %_car931 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons930, i32 0, i32 0
  %785 = load %struct.cell*, %struct.cell** %_car931, align 8
  %call932 = call %struct.cell* @_Error_1(%struct.scheme* %781, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.210, i32 0, i32 0), %struct.cell* %785)
  store %struct.cell* %call932, %struct.cell** %retval
  br label %return

if.end.933:                                       ; preds = %sw.bb.899
  %786 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args934 = getelementptr inbounds %struct.scheme, %struct.scheme* %786, i32 0, i32 7
  %787 = load %struct.cell*, %struct.cell** %args934, align 8
  %_object935 = getelementptr inbounds %struct.cell, %struct.cell* %787, i32 0, i32 1
  %_cons936 = bitcast %union.anon* %_object935 to %struct.anon.4*
  %_cdr937 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons936, i32 0, i32 1
  %788 = load %struct.cell*, %struct.cell** %_cdr937, align 8
  %_object938 = getelementptr inbounds %struct.cell, %struct.cell* %788, i32 0, i32 1
  %_cons939 = bitcast %union.anon* %_object938 to %struct.anon.4*
  %_cdr940 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons939, i32 0, i32 1
  %789 = load %struct.cell*, %struct.cell** %_cdr940, align 8
  %790 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL941 = getelementptr inbounds %struct.scheme, %struct.scheme* %790, i32 0, i32 17
  %791 = load %struct.cell*, %struct.cell** %NIL941, align 8
  %cmp942 = icmp ne %struct.cell* %789, %791
  br i1 %cmp942, label %if.then.944, label %if.else.977

if.then.944:                                      ; preds = %if.end.933
  %792 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args945 = getelementptr inbounds %struct.scheme, %struct.scheme* %792, i32 0, i32 7
  %793 = load %struct.cell*, %struct.cell** %args945, align 8
  %_object946 = getelementptr inbounds %struct.cell, %struct.cell* %793, i32 0, i32 1
  %_cons947 = bitcast %union.anon* %_object946 to %struct.anon.4*
  %_cdr948 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons947, i32 0, i32 1
  %794 = load %struct.cell*, %struct.cell** %_cdr948, align 8
  %_object949 = getelementptr inbounds %struct.cell, %struct.cell* %794, i32 0, i32 1
  %_cons950 = bitcast %union.anon* %_object949 to %struct.anon.4*
  %_cdr951 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons950, i32 0, i32 1
  %795 = load %struct.cell*, %struct.cell** %_cdr951, align 8
  %_object952 = getelementptr inbounds %struct.cell, %struct.cell* %795, i32 0, i32 1
  %_cons953 = bitcast %union.anon* %_object952 to %struct.anon.4*
  %_car954 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons953, i32 0, i32 0
  %796 = load %struct.cell*, %struct.cell** %_car954, align 8
  %call955 = call i64 @ivalue(%struct.cell* %796)
  %conv956 = trunc i64 %call955 to i32
  store i32 %conv956, i32* %index1, align 4
  %797 = load i32, i32* %index1, align 4
  %conv957 = sext i32 %797 to i64
  %798 = load i8*, i8** %str900, align 8
  %call958 = call i64 @g_utf8_strlen(i8* %798, i64 -1) #6
  %cmp959 = icmp sgt i64 %conv957, %call958
  br i1 %cmp959, label %if.then.964, label %lor.lhs.false.961

lor.lhs.false.961:                                ; preds = %if.then.944
  %799 = load i32, i32* %index1, align 4
  %800 = load i32, i32* %index0, align 4
  %cmp962 = icmp slt i32 %799, %800
  br i1 %cmp962, label %if.then.964, label %if.end.976

if.then.964:                                      ; preds = %lor.lhs.false.961, %if.then.944
  %801 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %802 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args965 = getelementptr inbounds %struct.scheme, %struct.scheme* %802, i32 0, i32 7
  %803 = load %struct.cell*, %struct.cell** %args965, align 8
  %_object966 = getelementptr inbounds %struct.cell, %struct.cell* %803, i32 0, i32 1
  %_cons967 = bitcast %union.anon* %_object966 to %struct.anon.4*
  %_cdr968 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons967, i32 0, i32 1
  %804 = load %struct.cell*, %struct.cell** %_cdr968, align 8
  %_object969 = getelementptr inbounds %struct.cell, %struct.cell* %804, i32 0, i32 1
  %_cons970 = bitcast %union.anon* %_object969 to %struct.anon.4*
  %_cdr971 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons970, i32 0, i32 1
  %805 = load %struct.cell*, %struct.cell** %_cdr971, align 8
  %_object972 = getelementptr inbounds %struct.cell, %struct.cell* %805, i32 0, i32 1
  %_cons973 = bitcast %union.anon* %_object972 to %struct.anon.4*
  %_car974 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons973, i32 0, i32 0
  %806 = load %struct.cell*, %struct.cell** %_car974, align 8
  %call975 = call %struct.cell* @_Error_1(%struct.scheme* %801, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.211, i32 0, i32 0), %struct.cell* %806)
  store %struct.cell* %call975, %struct.cell** %retval
  br label %return

if.end.976:                                       ; preds = %lor.lhs.false.961
  br label %if.end.980

if.else.977:                                      ; preds = %if.end.933
  %807 = load i8*, i8** %str900, align 8
  %call978 = call i64 @g_utf8_strlen(i8* %807, i64 -1) #6
  %conv979 = trunc i64 %call978 to i32
  store i32 %conv979, i32* %index1, align 4
  br label %if.end.980

if.end.980:                                       ; preds = %if.else.977, %if.end.976
  %808 = load i8*, i8** %str900, align 8
  %809 = load i32, i32* %index0, align 4
  %conv981 = sext i32 %809 to i64
  %call982 = call i8* @g_utf8_offset_to_pointer(i8* %808, i64 %conv981) #6
  store i8* %call982, i8** %beg, align 8
  %810 = load i8*, i8** %str900, align 8
  %811 = load i32, i32* %index1, align 4
  %conv983 = sext i32 %811 to i64
  %call984 = call i8* @g_utf8_offset_to_pointer(i8* %810, i64 %conv983) #6
  store i8* %call984, i8** %end901, align 8
  %812 = load i8*, i8** %end901, align 8
  %813 = load i8*, i8** %beg, align 8
  %sub.ptr.lhs.cast985 = ptrtoint i8* %812 to i64
  %sub.ptr.rhs.cast986 = ptrtoint i8* %813 to i64
  %sub.ptr.sub987 = sub i64 %sub.ptr.lhs.cast985, %sub.ptr.rhs.cast986
  %conv988 = trunc i64 %sub.ptr.sub987 to i32
  store i32 %conv988, i32* %len902, align 4
  %814 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc989 = getelementptr inbounds %struct.scheme, %struct.scheme* %814, i32 0, i32 0
  %815 = load i8* (i64)*, i8* (i64)** %malloc989, align 8
  %816 = load i32, i32* %len902, align 4
  %add990 = add nsw i32 %816, 1
  %conv991 = sext i32 %add990 to i64
  %call992 = call i8* %815(i64 %conv991)
  store i8* %call992, i8** %str900, align 8
  %817 = load i8*, i8** %str900, align 8
  %cmp993 = icmp eq i8* %817, null
  br i1 %cmp993, label %if.then.995, label %if.end.1002

if.then.995:                                      ; preds = %if.end.980
  %818 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory996 = getelementptr inbounds %struct.scheme, %struct.scheme* %818, i32 0, i32 48
  store i8 1, i8* %no_memory996, align 1
  %819 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %820 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args997 = getelementptr inbounds %struct.scheme, %struct.scheme* %820, i32 0, i32 7
  %821 = load %struct.cell*, %struct.cell** %args997, align 8
  %_object998 = getelementptr inbounds %struct.cell, %struct.cell* %821, i32 0, i32 1
  %_cons999 = bitcast %union.anon* %_object998 to %struct.anon.4*
  %_car1000 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons999, i32 0, i32 0
  %822 = load %struct.cell*, %struct.cell** %_car1000, align 8
  %call1001 = call %struct.cell* @_Error_1(%struct.scheme* %819, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.212, i32 0, i32 0), %struct.cell* %822)
  store %struct.cell* %call1001, %struct.cell** %retval
  br label %return

if.end.1002:                                      ; preds = %if.end.980
  %823 = load i8*, i8** %str900, align 8
  %824 = load i8*, i8** %beg, align 8
  %825 = load i32, i32* %len902, align 4
  %conv1003 = sext i32 %825 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %823, i8* %824, i64 %conv1003, i32 1, i1 false)
  %826 = load i32, i32* %len902, align 4
  %idxprom1004 = sext i32 %826 to i64
  %827 = load i8*, i8** %str900, align 8
  %arrayidx1005 = getelementptr inbounds i8, i8* %827, i64 %idxprom1004
  store i8 0, i8* %arrayidx1005, align 1
  %828 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %829 = load i8*, i8** %str900, align 8
  %call1006 = call %struct.cell* @mk_string(%struct.scheme* %828, i8* %829)
  store %struct.cell* %call1006, %struct.cell** %x903, align 8
  %830 = load i8*, i8** %str900, align 8
  call void @g_free(i8* %830)
  %831 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %832 = load %struct.cell*, %struct.cell** %x903, align 8
  %call1007 = call %struct.cell* @_s_return(%struct.scheme* %831, %struct.cell* %832)
  store %struct.cell* %call1007, %struct.cell** %retval
  br label %return

sw.bb.1008:                                       ; preds = %entry
  %833 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %834 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1010 = getelementptr inbounds %struct.scheme, %struct.scheme* %834, i32 0, i32 7
  %835 = load %struct.cell*, %struct.cell** %args1010, align 8
  %call1011 = call i32 @list_length(%struct.scheme* %833, %struct.cell* %835)
  store i32 %call1011, i32* %len1009, align 4
  %836 = load i32, i32* %len1009, align 4
  %cmp1012 = icmp slt i32 %836, 0
  br i1 %cmp1012, label %if.then.1014, label %if.end.1017

if.then.1014:                                     ; preds = %sw.bb.1008
  %837 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %838 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1015 = getelementptr inbounds %struct.scheme, %struct.scheme* %838, i32 0, i32 7
  %839 = load %struct.cell*, %struct.cell** %args1015, align 8
  %call1016 = call %struct.cell* @_Error_1(%struct.scheme* %837, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.213, i32 0, i32 0), %struct.cell* %839)
  store %struct.cell* %call1016, %struct.cell** %retval
  br label %return

if.end.1017:                                      ; preds = %sw.bb.1008
  %840 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %841 = load i32, i32* %len1009, align 4
  %call1018 = call %struct.cell* @mk_vector(%struct.scheme* %840, i32 %841)
  store %struct.cell* %call1018, %struct.cell** %vec, align 8
  %842 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory1019 = getelementptr inbounds %struct.scheme, %struct.scheme* %842, i32 0, i32 48
  %843 = load i8, i8* %no_memory1019, align 1
  %tobool1020 = icmp ne i8 %843, 0
  br i1 %tobool1020, label %if.then.1021, label %if.end.1023

if.then.1021:                                     ; preds = %if.end.1017
  %844 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %845 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %845, i32 0, i32 15
  %846 = load %struct.cell*, %struct.cell** %sink, align 8
  %call1022 = call %struct.cell* @_s_return(%struct.scheme* %844, %struct.cell* %846)
  store %struct.cell* %call1022, %struct.cell** %retval
  br label %return

if.end.1023:                                      ; preds = %if.end.1017
  %847 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1024 = getelementptr inbounds %struct.scheme, %struct.scheme* %847, i32 0, i32 7
  %848 = load %struct.cell*, %struct.cell** %args1024, align 8
  store %struct.cell* %848, %struct.cell** %x, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond.1025

for.cond.1025:                                    ; preds = %for.inc.1033, %if.end.1023
  %849 = load %struct.cell*, %struct.cell** %x, align 8
  %call1026 = call i32 @is_pair(%struct.cell* %849)
  %tobool1027 = icmp ne i32 %call1026, 0
  br i1 %tobool1027, label %for.body.1028, label %for.end.1037

for.body.1028:                                    ; preds = %for.cond.1025
  %850 = load %struct.cell*, %struct.cell** %vec, align 8
  %851 = load i32, i32* %i, align 4
  %852 = load %struct.cell*, %struct.cell** %x, align 8
  %_object1029 = getelementptr inbounds %struct.cell, %struct.cell* %852, i32 0, i32 1
  %_cons1030 = bitcast %union.anon* %_object1029 to %struct.anon.4*
  %_car1031 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1030, i32 0, i32 0
  %853 = load %struct.cell*, %struct.cell** %_car1031, align 8
  %call1032 = call %struct.cell* @set_vector_elem(%struct.cell* %850, i32 %851, %struct.cell* %853)
  br label %for.inc.1033

for.inc.1033:                                     ; preds = %for.body.1028
  %854 = load %struct.cell*, %struct.cell** %x, align 8
  %_object1034 = getelementptr inbounds %struct.cell, %struct.cell* %854, i32 0, i32 1
  %_cons1035 = bitcast %union.anon* %_object1034 to %struct.anon.4*
  %_cdr1036 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1035, i32 0, i32 1
  %855 = load %struct.cell*, %struct.cell** %_cdr1036, align 8
  store %struct.cell* %855, %struct.cell** %x, align 8
  %856 = load i32, i32* %i, align 4
  %inc = add nsw i32 %856, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond.1025

for.end.1037:                                     ; preds = %for.cond.1025
  %857 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %858 = load %struct.cell*, %struct.cell** %vec, align 8
  %call1038 = call %struct.cell* @_s_return(%struct.scheme* %857, %struct.cell* %858)
  store %struct.cell* %call1038, %struct.cell** %retval
  br label %return

sw.bb.1039:                                       ; preds = %entry
  %859 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1041 = getelementptr inbounds %struct.scheme, %struct.scheme* %859, i32 0, i32 17
  %860 = load %struct.cell*, %struct.cell** %NIL1041, align 8
  store %struct.cell* %860, %struct.cell** %fill1040, align 8
  %861 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1044 = getelementptr inbounds %struct.scheme, %struct.scheme* %861, i32 0, i32 7
  %862 = load %struct.cell*, %struct.cell** %args1044, align 8
  %_object1045 = getelementptr inbounds %struct.cell, %struct.cell* %862, i32 0, i32 1
  %_cons1046 = bitcast %union.anon* %_object1045 to %struct.anon.4*
  %_car1047 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1046, i32 0, i32 0
  %863 = load %struct.cell*, %struct.cell** %_car1047, align 8
  %call1048 = call i64 @ivalue(%struct.cell* %863)
  %conv1049 = trunc i64 %call1048 to i32
  store i32 %conv1049, i32* %len1042, align 4
  %864 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1050 = getelementptr inbounds %struct.scheme, %struct.scheme* %864, i32 0, i32 7
  %865 = load %struct.cell*, %struct.cell** %args1050, align 8
  %_object1051 = getelementptr inbounds %struct.cell, %struct.cell* %865, i32 0, i32 1
  %_cons1052 = bitcast %union.anon* %_object1051 to %struct.anon.4*
  %_cdr1053 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1052, i32 0, i32 1
  %866 = load %struct.cell*, %struct.cell** %_cdr1053, align 8
  %867 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1054 = getelementptr inbounds %struct.scheme, %struct.scheme* %867, i32 0, i32 17
  %868 = load %struct.cell*, %struct.cell** %NIL1054, align 8
  %cmp1055 = icmp ne %struct.cell* %866, %868
  br i1 %cmp1055, label %if.then.1057, label %if.end.1065

if.then.1057:                                     ; preds = %sw.bb.1039
  %869 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1058 = getelementptr inbounds %struct.scheme, %struct.scheme* %869, i32 0, i32 7
  %870 = load %struct.cell*, %struct.cell** %args1058, align 8
  %_object1059 = getelementptr inbounds %struct.cell, %struct.cell* %870, i32 0, i32 1
  %_cons1060 = bitcast %union.anon* %_object1059 to %struct.anon.4*
  %_cdr1061 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1060, i32 0, i32 1
  %871 = load %struct.cell*, %struct.cell** %_cdr1061, align 8
  %_object1062 = getelementptr inbounds %struct.cell, %struct.cell* %871, i32 0, i32 1
  %_cons1063 = bitcast %union.anon* %_object1062 to %struct.anon.4*
  %_car1064 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1063, i32 0, i32 0
  %872 = load %struct.cell*, %struct.cell** %_car1064, align 8
  store %struct.cell* %872, %struct.cell** %fill1040, align 8
  br label %if.end.1065

if.end.1065:                                      ; preds = %if.then.1057, %sw.bb.1039
  %873 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %874 = load i32, i32* %len1042, align 4
  %call1066 = call %struct.cell* @mk_vector(%struct.scheme* %873, i32 %874)
  store %struct.cell* %call1066, %struct.cell** %vec1043, align 8
  %875 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %no_memory1067 = getelementptr inbounds %struct.scheme, %struct.scheme* %875, i32 0, i32 48
  %876 = load i8, i8* %no_memory1067, align 1
  %tobool1068 = icmp ne i8 %876, 0
  br i1 %tobool1068, label %if.then.1069, label %if.end.1072

if.then.1069:                                     ; preds = %if.end.1065
  %877 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %878 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink1070 = getelementptr inbounds %struct.scheme, %struct.scheme* %878, i32 0, i32 15
  %879 = load %struct.cell*, %struct.cell** %sink1070, align 8
  %call1071 = call %struct.cell* @_s_return(%struct.scheme* %877, %struct.cell* %879)
  store %struct.cell* %call1071, %struct.cell** %retval
  br label %return

if.end.1072:                                      ; preds = %if.end.1065
  %880 = load %struct.cell*, %struct.cell** %fill1040, align 8
  %881 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1073 = getelementptr inbounds %struct.scheme, %struct.scheme* %881, i32 0, i32 17
  %882 = load %struct.cell*, %struct.cell** %NIL1073, align 8
  %cmp1074 = icmp ne %struct.cell* %880, %882
  br i1 %cmp1074, label %if.then.1076, label %if.end.1077

if.then.1076:                                     ; preds = %if.end.1072
  %883 = load %struct.cell*, %struct.cell** %vec1043, align 8
  %884 = load %struct.cell*, %struct.cell** %fill1040, align 8
  call void @fill_vector(%struct.cell* %883, %struct.cell* %884)
  br label %if.end.1077

if.end.1077:                                      ; preds = %if.then.1076, %if.end.1072
  %885 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %886 = load %struct.cell*, %struct.cell** %vec1043, align 8
  %call1078 = call %struct.cell* @_s_return(%struct.scheme* %885, %struct.cell* %886)
  store %struct.cell* %call1078, %struct.cell** %retval
  br label %return

sw.bb.1079:                                       ; preds = %entry
  %887 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %888 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %889 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1080 = getelementptr inbounds %struct.scheme, %struct.scheme* %889, i32 0, i32 7
  %890 = load %struct.cell*, %struct.cell** %args1080, align 8
  %_object1081 = getelementptr inbounds %struct.cell, %struct.cell* %890, i32 0, i32 1
  %_cons1082 = bitcast %union.anon* %_object1081 to %struct.anon.4*
  %_car1083 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1082, i32 0, i32 0
  %891 = load %struct.cell*, %struct.cell** %_car1083, align 8
  %call1084 = call i64 @ivalue(%struct.cell* %891)
  %call1085 = call %struct.cell* @mk_integer(%struct.scheme* %888, i64 %call1084)
  %call1086 = call %struct.cell* @_s_return(%struct.scheme* %887, %struct.cell* %call1085)
  store %struct.cell* %call1086, %struct.cell** %retval
  br label %return

sw.bb.1087:                                       ; preds = %entry
  %892 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1089 = getelementptr inbounds %struct.scheme, %struct.scheme* %892, i32 0, i32 7
  %893 = load %struct.cell*, %struct.cell** %args1089, align 8
  %_object1090 = getelementptr inbounds %struct.cell, %struct.cell* %893, i32 0, i32 1
  %_cons1091 = bitcast %union.anon* %_object1090 to %struct.anon.4*
  %_cdr1092 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1091, i32 0, i32 1
  %894 = load %struct.cell*, %struct.cell** %_cdr1092, align 8
  %_object1093 = getelementptr inbounds %struct.cell, %struct.cell* %894, i32 0, i32 1
  %_cons1094 = bitcast %union.anon* %_object1093 to %struct.anon.4*
  %_car1095 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1094, i32 0, i32 0
  %895 = load %struct.cell*, %struct.cell** %_car1095, align 8
  %call1096 = call i64 @ivalue(%struct.cell* %895)
  %conv1097 = trunc i64 %call1096 to i32
  store i32 %conv1097, i32* %index1088, align 4
  %896 = load i32, i32* %index1088, align 4
  %conv1098 = sext i32 %896 to i64
  %897 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1099 = getelementptr inbounds %struct.scheme, %struct.scheme* %897, i32 0, i32 7
  %898 = load %struct.cell*, %struct.cell** %args1099, align 8
  %_object1100 = getelementptr inbounds %struct.cell, %struct.cell* %898, i32 0, i32 1
  %_cons1101 = bitcast %union.anon* %_object1100 to %struct.anon.4*
  %_car1102 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1101, i32 0, i32 0
  %899 = load %struct.cell*, %struct.cell** %_car1102, align 8
  %call1103 = call i64 @ivalue(%struct.cell* %899)
  %cmp1104 = icmp sge i64 %conv1098, %call1103
  br i1 %cmp1104, label %if.then.1106, label %if.end.1115

if.then.1106:                                     ; preds = %sw.bb.1087
  %900 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %901 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1107 = getelementptr inbounds %struct.scheme, %struct.scheme* %901, i32 0, i32 7
  %902 = load %struct.cell*, %struct.cell** %args1107, align 8
  %_object1108 = getelementptr inbounds %struct.cell, %struct.cell* %902, i32 0, i32 1
  %_cons1109 = bitcast %union.anon* %_object1108 to %struct.anon.4*
  %_cdr1110 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1109, i32 0, i32 1
  %903 = load %struct.cell*, %struct.cell** %_cdr1110, align 8
  %_object1111 = getelementptr inbounds %struct.cell, %struct.cell* %903, i32 0, i32 1
  %_cons1112 = bitcast %union.anon* %_object1111 to %struct.anon.4*
  %_car1113 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1112, i32 0, i32 0
  %904 = load %struct.cell*, %struct.cell** %_car1113, align 8
  %call1114 = call %struct.cell* @_Error_1(%struct.scheme* %900, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.214, i32 0, i32 0), %struct.cell* %904)
  store %struct.cell* %call1114, %struct.cell** %retval
  br label %return

if.end.1115:                                      ; preds = %sw.bb.1087
  %905 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %906 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1116 = getelementptr inbounds %struct.scheme, %struct.scheme* %906, i32 0, i32 7
  %907 = load %struct.cell*, %struct.cell** %args1116, align 8
  %_object1117 = getelementptr inbounds %struct.cell, %struct.cell* %907, i32 0, i32 1
  %_cons1118 = bitcast %union.anon* %_object1117 to %struct.anon.4*
  %_car1119 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1118, i32 0, i32 0
  %908 = load %struct.cell*, %struct.cell** %_car1119, align 8
  %909 = load i32, i32* %index1088, align 4
  %call1120 = call %struct.cell* @vector_elem(%struct.cell* %908, i32 %909)
  %call1121 = call %struct.cell* @_s_return(%struct.scheme* %905, %struct.cell* %call1120)
  store %struct.cell* %call1121, %struct.cell** %retval
  br label %return

sw.bb.1122:                                       ; preds = %entry
  %910 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1124 = getelementptr inbounds %struct.scheme, %struct.scheme* %910, i32 0, i32 7
  %911 = load %struct.cell*, %struct.cell** %args1124, align 8
  %_object1125 = getelementptr inbounds %struct.cell, %struct.cell* %911, i32 0, i32 1
  %_cons1126 = bitcast %union.anon* %_object1125 to %struct.anon.4*
  %_car1127 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1126, i32 0, i32 0
  %912 = load %struct.cell*, %struct.cell** %_car1127, align 8
  %call1128 = call i32 @is_immutable(%struct.cell* %912)
  %tobool1129 = icmp ne i32 %call1128, 0
  br i1 %tobool1129, label %if.then.1130, label %if.end.1136

if.then.1130:                                     ; preds = %sw.bb.1122
  %913 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %914 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1131 = getelementptr inbounds %struct.scheme, %struct.scheme* %914, i32 0, i32 7
  %915 = load %struct.cell*, %struct.cell** %args1131, align 8
  %_object1132 = getelementptr inbounds %struct.cell, %struct.cell* %915, i32 0, i32 1
  %_cons1133 = bitcast %union.anon* %_object1132 to %struct.anon.4*
  %_car1134 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1133, i32 0, i32 0
  %916 = load %struct.cell*, %struct.cell** %_car1134, align 8
  %call1135 = call %struct.cell* @_Error_1(%struct.scheme* %913, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.215, i32 0, i32 0), %struct.cell* %916)
  store %struct.cell* %call1135, %struct.cell** %retval
  br label %return

if.end.1136:                                      ; preds = %sw.bb.1122
  %917 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1137 = getelementptr inbounds %struct.scheme, %struct.scheme* %917, i32 0, i32 7
  %918 = load %struct.cell*, %struct.cell** %args1137, align 8
  %_object1138 = getelementptr inbounds %struct.cell, %struct.cell* %918, i32 0, i32 1
  %_cons1139 = bitcast %union.anon* %_object1138 to %struct.anon.4*
  %_cdr1140 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1139, i32 0, i32 1
  %919 = load %struct.cell*, %struct.cell** %_cdr1140, align 8
  %_object1141 = getelementptr inbounds %struct.cell, %struct.cell* %919, i32 0, i32 1
  %_cons1142 = bitcast %union.anon* %_object1141 to %struct.anon.4*
  %_car1143 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1142, i32 0, i32 0
  %920 = load %struct.cell*, %struct.cell** %_car1143, align 8
  %call1144 = call i64 @ivalue(%struct.cell* %920)
  %conv1145 = trunc i64 %call1144 to i32
  store i32 %conv1145, i32* %index1123, align 4
  %921 = load i32, i32* %index1123, align 4
  %conv1146 = sext i32 %921 to i64
  %922 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1147 = getelementptr inbounds %struct.scheme, %struct.scheme* %922, i32 0, i32 7
  %923 = load %struct.cell*, %struct.cell** %args1147, align 8
  %_object1148 = getelementptr inbounds %struct.cell, %struct.cell* %923, i32 0, i32 1
  %_cons1149 = bitcast %union.anon* %_object1148 to %struct.anon.4*
  %_car1150 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1149, i32 0, i32 0
  %924 = load %struct.cell*, %struct.cell** %_car1150, align 8
  %call1151 = call i64 @ivalue(%struct.cell* %924)
  %cmp1152 = icmp sge i64 %conv1146, %call1151
  br i1 %cmp1152, label %if.then.1154, label %if.end.1163

if.then.1154:                                     ; preds = %if.end.1136
  %925 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %926 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1155 = getelementptr inbounds %struct.scheme, %struct.scheme* %926, i32 0, i32 7
  %927 = load %struct.cell*, %struct.cell** %args1155, align 8
  %_object1156 = getelementptr inbounds %struct.cell, %struct.cell* %927, i32 0, i32 1
  %_cons1157 = bitcast %union.anon* %_object1156 to %struct.anon.4*
  %_cdr1158 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1157, i32 0, i32 1
  %928 = load %struct.cell*, %struct.cell** %_cdr1158, align 8
  %_object1159 = getelementptr inbounds %struct.cell, %struct.cell* %928, i32 0, i32 1
  %_cons1160 = bitcast %union.anon* %_object1159 to %struct.anon.4*
  %_car1161 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1160, i32 0, i32 0
  %929 = load %struct.cell*, %struct.cell** %_car1161, align 8
  %call1162 = call %struct.cell* @_Error_1(%struct.scheme* %925, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.216, i32 0, i32 0), %struct.cell* %929)
  store %struct.cell* %call1162, %struct.cell** %retval
  br label %return

if.end.1163:                                      ; preds = %if.end.1136
  %930 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1164 = getelementptr inbounds %struct.scheme, %struct.scheme* %930, i32 0, i32 7
  %931 = load %struct.cell*, %struct.cell** %args1164, align 8
  %_object1165 = getelementptr inbounds %struct.cell, %struct.cell* %931, i32 0, i32 1
  %_cons1166 = bitcast %union.anon* %_object1165 to %struct.anon.4*
  %_car1167 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1166, i32 0, i32 0
  %932 = load %struct.cell*, %struct.cell** %_car1167, align 8
  %933 = load i32, i32* %index1123, align 4
  %934 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1168 = getelementptr inbounds %struct.scheme, %struct.scheme* %934, i32 0, i32 7
  %935 = load %struct.cell*, %struct.cell** %args1168, align 8
  %_object1169 = getelementptr inbounds %struct.cell, %struct.cell* %935, i32 0, i32 1
  %_cons1170 = bitcast %union.anon* %_object1169 to %struct.anon.4*
  %_cdr1171 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1170, i32 0, i32 1
  %936 = load %struct.cell*, %struct.cell** %_cdr1171, align 8
  %_object1172 = getelementptr inbounds %struct.cell, %struct.cell* %936, i32 0, i32 1
  %_cons1173 = bitcast %union.anon* %_object1172 to %struct.anon.4*
  %_cdr1174 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1173, i32 0, i32 1
  %937 = load %struct.cell*, %struct.cell** %_cdr1174, align 8
  %_object1175 = getelementptr inbounds %struct.cell, %struct.cell* %937, i32 0, i32 1
  %_cons1176 = bitcast %union.anon* %_object1175 to %struct.anon.4*
  %_car1177 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1176, i32 0, i32 0
  %938 = load %struct.cell*, %struct.cell** %_car1177, align 8
  %call1178 = call %struct.cell* @set_vector_elem(%struct.cell* %932, i32 %933, %struct.cell* %938)
  %939 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %940 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args1179 = getelementptr inbounds %struct.scheme, %struct.scheme* %940, i32 0, i32 7
  %941 = load %struct.cell*, %struct.cell** %args1179, align 8
  %_object1180 = getelementptr inbounds %struct.cell, %struct.cell* %941, i32 0, i32 1
  %_cons1181 = bitcast %union.anon* %_object1180 to %struct.anon.4*
  %_car1182 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons1181, i32 0, i32 0
  %942 = load %struct.cell*, %struct.cell** %_car1182, align 8
  %call1183 = call %struct.cell* @_s_return(%struct.scheme* %939, %struct.cell* %942)
  store %struct.cell* %call1183, %struct.cell** %retval
  br label %return

sw.default:                                       ; preds = %entry
  %943 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %943, i32 0, i32 50
  %arraydecay1184 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %944 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op1185 = getelementptr inbounds %struct.scheme, %struct.scheme* %944, i32 0, i32 55
  %945 = load i32, i32* %op1185, align 4
  %call1186 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay1184, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %945) #2
  %946 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %947 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff1187 = getelementptr inbounds %struct.scheme, %struct.scheme* %947, i32 0, i32 50
  %arraydecay1188 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff1187, i32 0, i32 0
  %call1189 = call %struct.cell* @_Error_1(%struct.scheme* %946, i8* %arraydecay1188, %struct.cell* null)
  store %struct.cell* %call1189, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default, %if.end.1163, %if.then.1154, %if.then.1130, %if.end.1115, %if.then.1106, %sw.bb.1079, %if.end.1077, %if.then.1069, %for.end.1037, %if.then.1021, %if.then.1014, %if.end.1002, %if.then.995, %if.then.964, %if.then.924, %for.end.896, %if.then.854, %if.end.802, %if.then.780, %if.then.744, %if.then.725, %if.end.709, %if.then.700, %sw.bb.661, %if.end.658, %if.else.632, %if.then.629, %sw.bb.606, %if.else.603, %if.then.600, %sw.bb.581, %sw.bb.570, %sw.bb.559, %sw.bb.549, %sw.bb.539, %if.else.537, %if.then.517, %if.else.508, %if.then.488, %sw.bb.467, %sw.bb.458, %sw.bb.449, %if.end.446, %if.else.444, %if.end.412, %if.else.410, %for.end.378, %if.else.371, %for.end.327, %if.else.320, %for.end.276, %for.end.235, %for.end, %if.end.197, %if.then.195, %if.else.184, %if.then.180, %sw.bb.163, %sw.bb.154, %if.else.150, %if.then.147, %sw.bb.100, %if.else.87, %if.then.82, %sw.bb.64, %sw.bb.55, %sw.bb.46, %sw.bb.37, %sw.bb.28, %sw.bb.19, %sw.bb.10, %if.else.8, %if.then.4, %if.then
  %948 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %948
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_3(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %v = alloca %struct.num, align 8
  %comp_func = alloca i32 (i8, i64, i8, i64)*, align 8
  %coerce = alloca %struct.num, align 8
  %agg.tmp = alloca %struct.num, align 8
  %coerce74 = alloca %struct.num, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store i32 (i8, i64, i8, i64)* null, i32 (i8, i64, i8, i64)** %comp_func, align 8
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default.419 [
    i32 98, label %sw.bb
    i32 99, label %sw.bb.2
    i32 100, label %sw.bb.22
    i32 101, label %sw.bb.35
    i32 102, label %sw.bb.48
    i32 103, label %sw.bb.48
    i32 104, label %sw.bb.48
    i32 105, label %sw.bb.48
    i32 106, label %sw.bb.48
    i32 107, label %sw.bb.80
    i32 108, label %sw.bb.94
    i32 109, label %sw.bb.108
    i32 110, label %sw.bb.122
    i32 111, label %sw.bb.136
    i32 112, label %sw.bb.150
    i32 113, label %sw.bb.164
    i32 114, label %sw.bb.179
    i32 115, label %sw.bb.195
    i32 116, label %sw.bb.211
    i32 117, label %sw.bb.227
    i32 118, label %sw.bb.243
    i32 119, label %sw.bb.257
    i32 120, label %sw.bb.271
    i32 121, label %sw.bb.285
    i32 122, label %sw.bb.320
    i32 123, label %sw.bb.334
    i32 124, label %sw.bb.349
    i32 125, label %sw.bb.363
    i32 126, label %sw.bb.377
    i32 127, label %sw.bb.398
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 7
  %3 = load %struct.cell*, %struct.cell** %args, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %4 = load %struct.cell*, %struct.cell** %_car, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 21
  %6 = load %struct.cell*, %struct.cell** %F, align 8
  %cmp = icmp eq %struct.cell* %4, %6
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 19
  %8 = load %struct.cell*, %struct.cell** %T, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F1 = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 21
  %10 = load %struct.cell*, %struct.cell** %F1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.cell* [ %8, %cond.true ], [ %10, %cond.false ]
  %call = call %struct.cell* @_s_return(%struct.scheme* %1, %struct.cell* %cond)
  store %struct.cell* %call, %struct.cell** %retval
  br label %return

sw.bb.2:                                          ; preds = %entry
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args3 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 7
  %13 = load %struct.cell*, %struct.cell** %args3, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_cons5 = bitcast %union.anon* %_object4 to %struct.anon.4*
  %_car6 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons5, i32 0, i32 0
  %14 = load %struct.cell*, %struct.cell** %_car6, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F7 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 21
  %16 = load %struct.cell*, %struct.cell** %F7, align 8
  %cmp8 = icmp eq %struct.cell* %14, %16
  br i1 %cmp8, label %cond.true.15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.bb.2
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args9 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 7
  %18 = load %struct.cell*, %struct.cell** %args9, align 8
  %_object10 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 1
  %_cons11 = bitcast %union.anon* %_object10 to %struct.anon.4*
  %_car12 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons11, i32 0, i32 0
  %19 = load %struct.cell*, %struct.cell** %_car12, align 8
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T13 = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 19
  %21 = load %struct.cell*, %struct.cell** %T13, align 8
  %cmp14 = icmp eq %struct.cell* %19, %21
  br i1 %cmp14, label %cond.true.15, label %cond.false.17

cond.true.15:                                     ; preds = %lor.lhs.false, %sw.bb.2
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T16 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 19
  %23 = load %struct.cell*, %struct.cell** %T16, align 8
  br label %cond.end.19

cond.false.17:                                    ; preds = %lor.lhs.false
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F18 = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 21
  %25 = load %struct.cell*, %struct.cell** %F18, align 8
  br label %cond.end.19

cond.end.19:                                      ; preds = %cond.false.17, %cond.true.15
  %cond20 = phi %struct.cell* [ %23, %cond.true.15 ], [ %25, %cond.false.17 ]
  %call21 = call %struct.cell* @_s_return(%struct.scheme* %11, %struct.cell* %cond20)
  store %struct.cell* %call21, %struct.cell** %retval
  br label %return

sw.bb.22:                                         ; preds = %entry
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args23 = getelementptr inbounds %struct.scheme, %struct.scheme* %27, i32 0, i32 7
  %28 = load %struct.cell*, %struct.cell** %args23, align 8
  %_object24 = getelementptr inbounds %struct.cell, %struct.cell* %28, i32 0, i32 1
  %_cons25 = bitcast %union.anon* %_object24 to %struct.anon.4*
  %_car26 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons25, i32 0, i32 0
  %29 = load %struct.cell*, %struct.cell** %_car26, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 23
  %31 = load %struct.cell*, %struct.cell** %EOF_OBJ, align 8
  %cmp27 = icmp eq %struct.cell* %29, %31
  br i1 %cmp27, label %cond.true.28, label %cond.false.30

cond.true.28:                                     ; preds = %sw.bb.22
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T29 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 19
  %33 = load %struct.cell*, %struct.cell** %T29, align 8
  br label %cond.end.32

cond.false.30:                                    ; preds = %sw.bb.22
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F31 = getelementptr inbounds %struct.scheme, %struct.scheme* %34, i32 0, i32 21
  %35 = load %struct.cell*, %struct.cell** %F31, align 8
  br label %cond.end.32

cond.end.32:                                      ; preds = %cond.false.30, %cond.true.28
  %cond33 = phi %struct.cell* [ %33, %cond.true.28 ], [ %35, %cond.false.30 ]
  %call34 = call %struct.cell* @_s_return(%struct.scheme* %26, %struct.cell* %cond33)
  store %struct.cell* %call34, %struct.cell** %retval
  br label %return

sw.bb.35:                                         ; preds = %entry
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args36 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 7
  %38 = load %struct.cell*, %struct.cell** %args36, align 8
  %_object37 = getelementptr inbounds %struct.cell, %struct.cell* %38, i32 0, i32 1
  %_cons38 = bitcast %union.anon* %_object37 to %struct.anon.4*
  %_car39 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons38, i32 0, i32 0
  %39 = load %struct.cell*, %struct.cell** %_car39, align 8
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 17
  %41 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp40 = icmp eq %struct.cell* %39, %41
  br i1 %cmp40, label %cond.true.41, label %cond.false.43

cond.true.41:                                     ; preds = %sw.bb.35
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T42 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 19
  %43 = load %struct.cell*, %struct.cell** %T42, align 8
  br label %cond.end.45

cond.false.43:                                    ; preds = %sw.bb.35
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F44 = getelementptr inbounds %struct.scheme, %struct.scheme* %44, i32 0, i32 21
  %45 = load %struct.cell*, %struct.cell** %F44, align 8
  br label %cond.end.45

cond.end.45:                                      ; preds = %cond.false.43, %cond.true.41
  %cond46 = phi %struct.cell* [ %43, %cond.true.41 ], [ %45, %cond.false.43 ]
  %call47 = call %struct.cell* @_s_return(%struct.scheme* %36, %struct.cell* %cond46)
  store %struct.cell* %call47, %struct.cell** %retval
  br label %return

sw.bb.48:                                         ; preds = %entry, %entry, %entry, %entry, %entry
  %46 = load i32, i32* %op.addr, align 4
  switch i32 %46, label %sw.default [
    i32 102, label %sw.bb.49
    i32 103, label %sw.bb.50
    i32 104, label %sw.bb.51
    i32 105, label %sw.bb.52
    i32 106, label %sw.bb.53
  ]

sw.bb.49:                                         ; preds = %sw.bb.48
  store i32 (i8, i64, i8, i64)* @num_eq, i32 (i8, i64, i8, i64)** %comp_func, align 8
  br label %sw.epilog

sw.bb.50:                                         ; preds = %sw.bb.48
  store i32 (i8, i64, i8, i64)* @num_lt, i32 (i8, i64, i8, i64)** %comp_func, align 8
  br label %sw.epilog

sw.bb.51:                                         ; preds = %sw.bb.48
  store i32 (i8, i64, i8, i64)* @num_gt, i32 (i8, i64, i8, i64)** %comp_func, align 8
  br label %sw.epilog

sw.bb.52:                                         ; preds = %sw.bb.48
  store i32 (i8, i64, i8, i64)* @num_le, i32 (i8, i64, i8, i64)** %comp_func, align 8
  br label %sw.epilog

sw.bb.53:                                         ; preds = %sw.bb.48
  store i32 (i8, i64, i8, i64)* @num_ge, i32 (i8, i64, i8, i64)** %comp_func, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb.48
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.53, %sw.bb.52, %sw.bb.51, %sw.bb.50, %sw.bb.49
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args54 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 7
  %48 = load %struct.cell*, %struct.cell** %args54, align 8
  store %struct.cell* %48, %struct.cell** %x, align 8
  %49 = load %struct.cell*, %struct.cell** %x, align 8
  %_object55 = getelementptr inbounds %struct.cell, %struct.cell* %49, i32 0, i32 1
  %_cons56 = bitcast %union.anon* %_object55 to %struct.anon.4*
  %_car57 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons56, i32 0, i32 0
  %50 = load %struct.cell*, %struct.cell** %_car57, align 8
  %call58 = call { i8, i64 } @nvalue(%struct.cell* %50)
  %51 = bitcast %struct.num* %coerce to { i8, i64 }*
  %52 = getelementptr { i8, i64 }, { i8, i64 }* %51, i32 0, i32 0
  %53 = extractvalue { i8, i64 } %call58, 0
  store i8 %53, i8* %52, align 8
  %54 = getelementptr { i8, i64 }, { i8, i64 }* %51, i32 0, i32 1
  %55 = extractvalue { i8, i64 } %call58, 1
  store i64 %55, i64* %54, align 8
  %56 = bitcast %struct.num* %v to i8*
  %57 = bitcast %struct.num* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %56, i8* %57, i64 16, i32 8, i1 false)
  %58 = load %struct.cell*, %struct.cell** %x, align 8
  %_object59 = getelementptr inbounds %struct.cell, %struct.cell* %58, i32 0, i32 1
  %_cons60 = bitcast %union.anon* %_object59 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons60, i32 0, i32 1
  %59 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %59, %struct.cell** %x, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %60 = load %struct.cell*, %struct.cell** %x, align 8
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL61 = getelementptr inbounds %struct.scheme, %struct.scheme* %61, i32 0, i32 17
  %62 = load %struct.cell*, %struct.cell** %NIL61, align 8
  %cmp62 = icmp ne %struct.cell* %60, %62
  br i1 %cmp62, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %63 = load i32 (i8, i64, i8, i64)*, i32 (i8, i64, i8, i64)** %comp_func, align 8
  %64 = load %struct.cell*, %struct.cell** %x, align 8
  %_object63 = getelementptr inbounds %struct.cell, %struct.cell* %64, i32 0, i32 1
  %_cons64 = bitcast %union.anon* %_object63 to %struct.anon.4*
  %_car65 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons64, i32 0, i32 0
  %65 = load %struct.cell*, %struct.cell** %_car65, align 8
  %call66 = call { i8, i64 } @nvalue(%struct.cell* %65)
  %66 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %67 = getelementptr { i8, i64 }, { i8, i64 }* %66, i32 0, i32 0
  %68 = extractvalue { i8, i64 } %call66, 0
  store i8 %68, i8* %67, align 8
  %69 = getelementptr { i8, i64 }, { i8, i64 }* %66, i32 0, i32 1
  %70 = extractvalue { i8, i64 } %call66, 1
  store i64 %70, i64* %69, align 8
  %71 = bitcast %struct.num* %v to { i8, i64 }*
  %72 = getelementptr { i8, i64 }, { i8, i64 }* %71, i32 0, i32 0
  %73 = load i8, i8* %72, align 1
  %74 = getelementptr { i8, i64 }, { i8, i64 }* %71, i32 0, i32 1
  %75 = load i64, i64* %74, align 1
  %76 = bitcast %struct.num* %agg.tmp to { i8, i64 }*
  %77 = getelementptr { i8, i64 }, { i8, i64 }* %76, i32 0, i32 0
  %78 = load i8, i8* %77, align 1
  %79 = getelementptr { i8, i64 }, { i8, i64 }* %76, i32 0, i32 1
  %80 = load i64, i64* %79, align 1
  %call67 = call i32 %63(i8 %73, i64 %75, i8 %78, i64 %80)
  %tobool = icmp ne i32 %call67, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %82 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F68 = getelementptr inbounds %struct.scheme, %struct.scheme* %82, i32 0, i32 21
  %83 = load %struct.cell*, %struct.cell** %F68, align 8
  %call69 = call %struct.cell* @_s_return(%struct.scheme* %81, %struct.cell* %83)
  store %struct.cell* %call69, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %for.body
  %84 = load %struct.cell*, %struct.cell** %x, align 8
  %_object70 = getelementptr inbounds %struct.cell, %struct.cell* %84, i32 0, i32 1
  %_cons71 = bitcast %union.anon* %_object70 to %struct.anon.4*
  %_car72 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons71, i32 0, i32 0
  %85 = load %struct.cell*, %struct.cell** %_car72, align 8
  %call73 = call { i8, i64 } @nvalue(%struct.cell* %85)
  %86 = bitcast %struct.num* %coerce74 to { i8, i64 }*
  %87 = getelementptr { i8, i64 }, { i8, i64 }* %86, i32 0, i32 0
  %88 = extractvalue { i8, i64 } %call73, 0
  store i8 %88, i8* %87, align 8
  %89 = getelementptr { i8, i64 }, { i8, i64 }* %86, i32 0, i32 1
  %90 = extractvalue { i8, i64 } %call73, 1
  store i64 %90, i64* %89, align 8
  %91 = bitcast %struct.num* %v to i8*
  %92 = bitcast %struct.num* %coerce74 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %91, i8* %92, i64 16, i32 8, i1 false)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %93 = load %struct.cell*, %struct.cell** %x, align 8
  %_object75 = getelementptr inbounds %struct.cell, %struct.cell* %93, i32 0, i32 1
  %_cons76 = bitcast %union.anon* %_object75 to %struct.anon.4*
  %_cdr77 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons76, i32 0, i32 1
  %94 = load %struct.cell*, %struct.cell** %_cdr77, align 8
  store %struct.cell* %94, %struct.cell** %x, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %95 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %96 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T78 = getelementptr inbounds %struct.scheme, %struct.scheme* %96, i32 0, i32 19
  %97 = load %struct.cell*, %struct.cell** %T78, align 8
  %call79 = call %struct.cell* @_s_return(%struct.scheme* %95, %struct.cell* %97)
  store %struct.cell* %call79, %struct.cell** %retval
  br label %return

sw.bb.80:                                         ; preds = %entry
  %98 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args81 = getelementptr inbounds %struct.scheme, %struct.scheme* %99, i32 0, i32 7
  %100 = load %struct.cell*, %struct.cell** %args81, align 8
  %_object82 = getelementptr inbounds %struct.cell, %struct.cell* %100, i32 0, i32 1
  %_cons83 = bitcast %union.anon* %_object82 to %struct.anon.4*
  %_car84 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons83, i32 0, i32 0
  %101 = load %struct.cell*, %struct.cell** %_car84, align 8
  %call85 = call i32 @is_symbol(%struct.cell* %101)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %cond.true.87, label %cond.false.89

cond.true.87:                                     ; preds = %sw.bb.80
  %102 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T88 = getelementptr inbounds %struct.scheme, %struct.scheme* %102, i32 0, i32 19
  %103 = load %struct.cell*, %struct.cell** %T88, align 8
  br label %cond.end.91

cond.false.89:                                    ; preds = %sw.bb.80
  %104 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F90 = getelementptr inbounds %struct.scheme, %struct.scheme* %104, i32 0, i32 21
  %105 = load %struct.cell*, %struct.cell** %F90, align 8
  br label %cond.end.91

cond.end.91:                                      ; preds = %cond.false.89, %cond.true.87
  %cond92 = phi %struct.cell* [ %103, %cond.true.87 ], [ %105, %cond.false.89 ]
  %call93 = call %struct.cell* @_s_return(%struct.scheme* %98, %struct.cell* %cond92)
  store %struct.cell* %call93, %struct.cell** %retval
  br label %return

sw.bb.94:                                         ; preds = %entry
  %106 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %107 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args95 = getelementptr inbounds %struct.scheme, %struct.scheme* %107, i32 0, i32 7
  %108 = load %struct.cell*, %struct.cell** %args95, align 8
  %_object96 = getelementptr inbounds %struct.cell, %struct.cell* %108, i32 0, i32 1
  %_cons97 = bitcast %union.anon* %_object96 to %struct.anon.4*
  %_car98 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons97, i32 0, i32 0
  %109 = load %struct.cell*, %struct.cell** %_car98, align 8
  %call99 = call i32 @is_number(%struct.cell* %109)
  %tobool100 = icmp ne i32 %call99, 0
  br i1 %tobool100, label %cond.true.101, label %cond.false.103

cond.true.101:                                    ; preds = %sw.bb.94
  %110 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T102 = getelementptr inbounds %struct.scheme, %struct.scheme* %110, i32 0, i32 19
  %111 = load %struct.cell*, %struct.cell** %T102, align 8
  br label %cond.end.105

cond.false.103:                                   ; preds = %sw.bb.94
  %112 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F104 = getelementptr inbounds %struct.scheme, %struct.scheme* %112, i32 0, i32 21
  %113 = load %struct.cell*, %struct.cell** %F104, align 8
  br label %cond.end.105

cond.end.105:                                     ; preds = %cond.false.103, %cond.true.101
  %cond106 = phi %struct.cell* [ %111, %cond.true.101 ], [ %113, %cond.false.103 ]
  %call107 = call %struct.cell* @_s_return(%struct.scheme* %106, %struct.cell* %cond106)
  store %struct.cell* %call107, %struct.cell** %retval
  br label %return

sw.bb.108:                                        ; preds = %entry
  %114 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %115 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args109 = getelementptr inbounds %struct.scheme, %struct.scheme* %115, i32 0, i32 7
  %116 = load %struct.cell*, %struct.cell** %args109, align 8
  %_object110 = getelementptr inbounds %struct.cell, %struct.cell* %116, i32 0, i32 1
  %_cons111 = bitcast %union.anon* %_object110 to %struct.anon.4*
  %_car112 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons111, i32 0, i32 0
  %117 = load %struct.cell*, %struct.cell** %_car112, align 8
  %call113 = call i32 @is_string(%struct.cell* %117)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %cond.true.115, label %cond.false.117

cond.true.115:                                    ; preds = %sw.bb.108
  %118 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T116 = getelementptr inbounds %struct.scheme, %struct.scheme* %118, i32 0, i32 19
  %119 = load %struct.cell*, %struct.cell** %T116, align 8
  br label %cond.end.119

cond.false.117:                                   ; preds = %sw.bb.108
  %120 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F118 = getelementptr inbounds %struct.scheme, %struct.scheme* %120, i32 0, i32 21
  %121 = load %struct.cell*, %struct.cell** %F118, align 8
  br label %cond.end.119

cond.end.119:                                     ; preds = %cond.false.117, %cond.true.115
  %cond120 = phi %struct.cell* [ %119, %cond.true.115 ], [ %121, %cond.false.117 ]
  %call121 = call %struct.cell* @_s_return(%struct.scheme* %114, %struct.cell* %cond120)
  store %struct.cell* %call121, %struct.cell** %retval
  br label %return

sw.bb.122:                                        ; preds = %entry
  %122 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args123 = getelementptr inbounds %struct.scheme, %struct.scheme* %123, i32 0, i32 7
  %124 = load %struct.cell*, %struct.cell** %args123, align 8
  %_object124 = getelementptr inbounds %struct.cell, %struct.cell* %124, i32 0, i32 1
  %_cons125 = bitcast %union.anon* %_object124 to %struct.anon.4*
  %_car126 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons125, i32 0, i32 0
  %125 = load %struct.cell*, %struct.cell** %_car126, align 8
  %call127 = call i32 @is_integer(%struct.cell* %125)
  %tobool128 = icmp ne i32 %call127, 0
  br i1 %tobool128, label %cond.true.129, label %cond.false.131

cond.true.129:                                    ; preds = %sw.bb.122
  %126 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T130 = getelementptr inbounds %struct.scheme, %struct.scheme* %126, i32 0, i32 19
  %127 = load %struct.cell*, %struct.cell** %T130, align 8
  br label %cond.end.133

cond.false.131:                                   ; preds = %sw.bb.122
  %128 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F132 = getelementptr inbounds %struct.scheme, %struct.scheme* %128, i32 0, i32 21
  %129 = load %struct.cell*, %struct.cell** %F132, align 8
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.false.131, %cond.true.129
  %cond134 = phi %struct.cell* [ %127, %cond.true.129 ], [ %129, %cond.false.131 ]
  %call135 = call %struct.cell* @_s_return(%struct.scheme* %122, %struct.cell* %cond134)
  store %struct.cell* %call135, %struct.cell** %retval
  br label %return

sw.bb.136:                                        ; preds = %entry
  %130 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %131 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args137 = getelementptr inbounds %struct.scheme, %struct.scheme* %131, i32 0, i32 7
  %132 = load %struct.cell*, %struct.cell** %args137, align 8
  %_object138 = getelementptr inbounds %struct.cell, %struct.cell* %132, i32 0, i32 1
  %_cons139 = bitcast %union.anon* %_object138 to %struct.anon.4*
  %_car140 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons139, i32 0, i32 0
  %133 = load %struct.cell*, %struct.cell** %_car140, align 8
  %call141 = call i32 @is_number(%struct.cell* %133)
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %cond.true.143, label %cond.false.145

cond.true.143:                                    ; preds = %sw.bb.136
  %134 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T144 = getelementptr inbounds %struct.scheme, %struct.scheme* %134, i32 0, i32 19
  %135 = load %struct.cell*, %struct.cell** %T144, align 8
  br label %cond.end.147

cond.false.145:                                   ; preds = %sw.bb.136
  %136 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F146 = getelementptr inbounds %struct.scheme, %struct.scheme* %136, i32 0, i32 21
  %137 = load %struct.cell*, %struct.cell** %F146, align 8
  br label %cond.end.147

cond.end.147:                                     ; preds = %cond.false.145, %cond.true.143
  %cond148 = phi %struct.cell* [ %135, %cond.true.143 ], [ %137, %cond.false.145 ]
  %call149 = call %struct.cell* @_s_return(%struct.scheme* %130, %struct.cell* %cond148)
  store %struct.cell* %call149, %struct.cell** %retval
  br label %return

sw.bb.150:                                        ; preds = %entry
  %138 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %139 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args151 = getelementptr inbounds %struct.scheme, %struct.scheme* %139, i32 0, i32 7
  %140 = load %struct.cell*, %struct.cell** %args151, align 8
  %_object152 = getelementptr inbounds %struct.cell, %struct.cell* %140, i32 0, i32 1
  %_cons153 = bitcast %union.anon* %_object152 to %struct.anon.4*
  %_car154 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons153, i32 0, i32 0
  %141 = load %struct.cell*, %struct.cell** %_car154, align 8
  %call155 = call i32 @is_character(%struct.cell* %141)
  %tobool156 = icmp ne i32 %call155, 0
  br i1 %tobool156, label %cond.true.157, label %cond.false.159

cond.true.157:                                    ; preds = %sw.bb.150
  %142 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T158 = getelementptr inbounds %struct.scheme, %struct.scheme* %142, i32 0, i32 19
  %143 = load %struct.cell*, %struct.cell** %T158, align 8
  br label %cond.end.161

cond.false.159:                                   ; preds = %sw.bb.150
  %144 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F160 = getelementptr inbounds %struct.scheme, %struct.scheme* %144, i32 0, i32 21
  %145 = load %struct.cell*, %struct.cell** %F160, align 8
  br label %cond.end.161

cond.end.161:                                     ; preds = %cond.false.159, %cond.true.157
  %cond162 = phi %struct.cell* [ %143, %cond.true.157 ], [ %145, %cond.false.159 ]
  %call163 = call %struct.cell* @_s_return(%struct.scheme* %138, %struct.cell* %cond162)
  store %struct.cell* %call163, %struct.cell** %retval
  br label %return

sw.bb.164:                                        ; preds = %entry
  %146 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %147 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args165 = getelementptr inbounds %struct.scheme, %struct.scheme* %147, i32 0, i32 7
  %148 = load %struct.cell*, %struct.cell** %args165, align 8
  %_object166 = getelementptr inbounds %struct.cell, %struct.cell* %148, i32 0, i32 1
  %_cons167 = bitcast %union.anon* %_object166 to %struct.anon.4*
  %_car168 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons167, i32 0, i32 0
  %149 = load %struct.cell*, %struct.cell** %_car168, align 8
  %call169 = call i64 @ivalue(%struct.cell* %149)
  %conv = trunc i64 %call169 to i32
  %call170 = call i32 @Cisalpha(i32 %conv)
  %tobool171 = icmp ne i32 %call170, 0
  br i1 %tobool171, label %cond.true.172, label %cond.false.174

cond.true.172:                                    ; preds = %sw.bb.164
  %150 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T173 = getelementptr inbounds %struct.scheme, %struct.scheme* %150, i32 0, i32 19
  %151 = load %struct.cell*, %struct.cell** %T173, align 8
  br label %cond.end.176

cond.false.174:                                   ; preds = %sw.bb.164
  %152 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F175 = getelementptr inbounds %struct.scheme, %struct.scheme* %152, i32 0, i32 21
  %153 = load %struct.cell*, %struct.cell** %F175, align 8
  br label %cond.end.176

cond.end.176:                                     ; preds = %cond.false.174, %cond.true.172
  %cond177 = phi %struct.cell* [ %151, %cond.true.172 ], [ %153, %cond.false.174 ]
  %call178 = call %struct.cell* @_s_return(%struct.scheme* %146, %struct.cell* %cond177)
  store %struct.cell* %call178, %struct.cell** %retval
  br label %return

sw.bb.179:                                        ; preds = %entry
  %154 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %155 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args180 = getelementptr inbounds %struct.scheme, %struct.scheme* %155, i32 0, i32 7
  %156 = load %struct.cell*, %struct.cell** %args180, align 8
  %_object181 = getelementptr inbounds %struct.cell, %struct.cell* %156, i32 0, i32 1
  %_cons182 = bitcast %union.anon* %_object181 to %struct.anon.4*
  %_car183 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons182, i32 0, i32 0
  %157 = load %struct.cell*, %struct.cell** %_car183, align 8
  %call184 = call i64 @ivalue(%struct.cell* %157)
  %conv185 = trunc i64 %call184 to i32
  %call186 = call i32 @Cisdigit(i32 %conv185)
  %tobool187 = icmp ne i32 %call186, 0
  br i1 %tobool187, label %cond.true.188, label %cond.false.190

cond.true.188:                                    ; preds = %sw.bb.179
  %158 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T189 = getelementptr inbounds %struct.scheme, %struct.scheme* %158, i32 0, i32 19
  %159 = load %struct.cell*, %struct.cell** %T189, align 8
  br label %cond.end.192

cond.false.190:                                   ; preds = %sw.bb.179
  %160 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F191 = getelementptr inbounds %struct.scheme, %struct.scheme* %160, i32 0, i32 21
  %161 = load %struct.cell*, %struct.cell** %F191, align 8
  br label %cond.end.192

cond.end.192:                                     ; preds = %cond.false.190, %cond.true.188
  %cond193 = phi %struct.cell* [ %159, %cond.true.188 ], [ %161, %cond.false.190 ]
  %call194 = call %struct.cell* @_s_return(%struct.scheme* %154, %struct.cell* %cond193)
  store %struct.cell* %call194, %struct.cell** %retval
  br label %return

sw.bb.195:                                        ; preds = %entry
  %162 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %163 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args196 = getelementptr inbounds %struct.scheme, %struct.scheme* %163, i32 0, i32 7
  %164 = load %struct.cell*, %struct.cell** %args196, align 8
  %_object197 = getelementptr inbounds %struct.cell, %struct.cell* %164, i32 0, i32 1
  %_cons198 = bitcast %union.anon* %_object197 to %struct.anon.4*
  %_car199 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons198, i32 0, i32 0
  %165 = load %struct.cell*, %struct.cell** %_car199, align 8
  %call200 = call i64 @ivalue(%struct.cell* %165)
  %conv201 = trunc i64 %call200 to i32
  %call202 = call i32 @Cisspace(i32 %conv201)
  %tobool203 = icmp ne i32 %call202, 0
  br i1 %tobool203, label %cond.true.204, label %cond.false.206

cond.true.204:                                    ; preds = %sw.bb.195
  %166 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T205 = getelementptr inbounds %struct.scheme, %struct.scheme* %166, i32 0, i32 19
  %167 = load %struct.cell*, %struct.cell** %T205, align 8
  br label %cond.end.208

cond.false.206:                                   ; preds = %sw.bb.195
  %168 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F207 = getelementptr inbounds %struct.scheme, %struct.scheme* %168, i32 0, i32 21
  %169 = load %struct.cell*, %struct.cell** %F207, align 8
  br label %cond.end.208

cond.end.208:                                     ; preds = %cond.false.206, %cond.true.204
  %cond209 = phi %struct.cell* [ %167, %cond.true.204 ], [ %169, %cond.false.206 ]
  %call210 = call %struct.cell* @_s_return(%struct.scheme* %162, %struct.cell* %cond209)
  store %struct.cell* %call210, %struct.cell** %retval
  br label %return

sw.bb.211:                                        ; preds = %entry
  %170 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %171 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args212 = getelementptr inbounds %struct.scheme, %struct.scheme* %171, i32 0, i32 7
  %172 = load %struct.cell*, %struct.cell** %args212, align 8
  %_object213 = getelementptr inbounds %struct.cell, %struct.cell* %172, i32 0, i32 1
  %_cons214 = bitcast %union.anon* %_object213 to %struct.anon.4*
  %_car215 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons214, i32 0, i32 0
  %173 = load %struct.cell*, %struct.cell** %_car215, align 8
  %call216 = call i64 @ivalue(%struct.cell* %173)
  %conv217 = trunc i64 %call216 to i32
  %call218 = call i32 @Cisupper(i32 %conv217)
  %tobool219 = icmp ne i32 %call218, 0
  br i1 %tobool219, label %cond.true.220, label %cond.false.222

cond.true.220:                                    ; preds = %sw.bb.211
  %174 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T221 = getelementptr inbounds %struct.scheme, %struct.scheme* %174, i32 0, i32 19
  %175 = load %struct.cell*, %struct.cell** %T221, align 8
  br label %cond.end.224

cond.false.222:                                   ; preds = %sw.bb.211
  %176 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F223 = getelementptr inbounds %struct.scheme, %struct.scheme* %176, i32 0, i32 21
  %177 = load %struct.cell*, %struct.cell** %F223, align 8
  br label %cond.end.224

cond.end.224:                                     ; preds = %cond.false.222, %cond.true.220
  %cond225 = phi %struct.cell* [ %175, %cond.true.220 ], [ %177, %cond.false.222 ]
  %call226 = call %struct.cell* @_s_return(%struct.scheme* %170, %struct.cell* %cond225)
  store %struct.cell* %call226, %struct.cell** %retval
  br label %return

sw.bb.227:                                        ; preds = %entry
  %178 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %179 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args228 = getelementptr inbounds %struct.scheme, %struct.scheme* %179, i32 0, i32 7
  %180 = load %struct.cell*, %struct.cell** %args228, align 8
  %_object229 = getelementptr inbounds %struct.cell, %struct.cell* %180, i32 0, i32 1
  %_cons230 = bitcast %union.anon* %_object229 to %struct.anon.4*
  %_car231 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons230, i32 0, i32 0
  %181 = load %struct.cell*, %struct.cell** %_car231, align 8
  %call232 = call i64 @ivalue(%struct.cell* %181)
  %conv233 = trunc i64 %call232 to i32
  %call234 = call i32 @Cislower(i32 %conv233)
  %tobool235 = icmp ne i32 %call234, 0
  br i1 %tobool235, label %cond.true.236, label %cond.false.238

cond.true.236:                                    ; preds = %sw.bb.227
  %182 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T237 = getelementptr inbounds %struct.scheme, %struct.scheme* %182, i32 0, i32 19
  %183 = load %struct.cell*, %struct.cell** %T237, align 8
  br label %cond.end.240

cond.false.238:                                   ; preds = %sw.bb.227
  %184 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F239 = getelementptr inbounds %struct.scheme, %struct.scheme* %184, i32 0, i32 21
  %185 = load %struct.cell*, %struct.cell** %F239, align 8
  br label %cond.end.240

cond.end.240:                                     ; preds = %cond.false.238, %cond.true.236
  %cond241 = phi %struct.cell* [ %183, %cond.true.236 ], [ %185, %cond.false.238 ]
  %call242 = call %struct.cell* @_s_return(%struct.scheme* %178, %struct.cell* %cond241)
  store %struct.cell* %call242, %struct.cell** %retval
  br label %return

sw.bb.243:                                        ; preds = %entry
  %186 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %187 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args244 = getelementptr inbounds %struct.scheme, %struct.scheme* %187, i32 0, i32 7
  %188 = load %struct.cell*, %struct.cell** %args244, align 8
  %_object245 = getelementptr inbounds %struct.cell, %struct.cell* %188, i32 0, i32 1
  %_cons246 = bitcast %union.anon* %_object245 to %struct.anon.4*
  %_car247 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons246, i32 0, i32 0
  %189 = load %struct.cell*, %struct.cell** %_car247, align 8
  %call248 = call i32 @is_port(%struct.cell* %189)
  %tobool249 = icmp ne i32 %call248, 0
  br i1 %tobool249, label %cond.true.250, label %cond.false.252

cond.true.250:                                    ; preds = %sw.bb.243
  %190 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T251 = getelementptr inbounds %struct.scheme, %struct.scheme* %190, i32 0, i32 19
  %191 = load %struct.cell*, %struct.cell** %T251, align 8
  br label %cond.end.254

cond.false.252:                                   ; preds = %sw.bb.243
  %192 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F253 = getelementptr inbounds %struct.scheme, %struct.scheme* %192, i32 0, i32 21
  %193 = load %struct.cell*, %struct.cell** %F253, align 8
  br label %cond.end.254

cond.end.254:                                     ; preds = %cond.false.252, %cond.true.250
  %cond255 = phi %struct.cell* [ %191, %cond.true.250 ], [ %193, %cond.false.252 ]
  %call256 = call %struct.cell* @_s_return(%struct.scheme* %186, %struct.cell* %cond255)
  store %struct.cell* %call256, %struct.cell** %retval
  br label %return

sw.bb.257:                                        ; preds = %entry
  %194 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %195 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args258 = getelementptr inbounds %struct.scheme, %struct.scheme* %195, i32 0, i32 7
  %196 = load %struct.cell*, %struct.cell** %args258, align 8
  %_object259 = getelementptr inbounds %struct.cell, %struct.cell* %196, i32 0, i32 1
  %_cons260 = bitcast %union.anon* %_object259 to %struct.anon.4*
  %_car261 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons260, i32 0, i32 0
  %197 = load %struct.cell*, %struct.cell** %_car261, align 8
  %call262 = call i32 @is_inport(%struct.cell* %197)
  %tobool263 = icmp ne i32 %call262, 0
  br i1 %tobool263, label %cond.true.264, label %cond.false.266

cond.true.264:                                    ; preds = %sw.bb.257
  %198 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T265 = getelementptr inbounds %struct.scheme, %struct.scheme* %198, i32 0, i32 19
  %199 = load %struct.cell*, %struct.cell** %T265, align 8
  br label %cond.end.268

cond.false.266:                                   ; preds = %sw.bb.257
  %200 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F267 = getelementptr inbounds %struct.scheme, %struct.scheme* %200, i32 0, i32 21
  %201 = load %struct.cell*, %struct.cell** %F267, align 8
  br label %cond.end.268

cond.end.268:                                     ; preds = %cond.false.266, %cond.true.264
  %cond269 = phi %struct.cell* [ %199, %cond.true.264 ], [ %201, %cond.false.266 ]
  %call270 = call %struct.cell* @_s_return(%struct.scheme* %194, %struct.cell* %cond269)
  store %struct.cell* %call270, %struct.cell** %retval
  br label %return

sw.bb.271:                                        ; preds = %entry
  %202 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %203 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args272 = getelementptr inbounds %struct.scheme, %struct.scheme* %203, i32 0, i32 7
  %204 = load %struct.cell*, %struct.cell** %args272, align 8
  %_object273 = getelementptr inbounds %struct.cell, %struct.cell* %204, i32 0, i32 1
  %_cons274 = bitcast %union.anon* %_object273 to %struct.anon.4*
  %_car275 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons274, i32 0, i32 0
  %205 = load %struct.cell*, %struct.cell** %_car275, align 8
  %call276 = call i32 @is_outport(%struct.cell* %205)
  %tobool277 = icmp ne i32 %call276, 0
  br i1 %tobool277, label %cond.true.278, label %cond.false.280

cond.true.278:                                    ; preds = %sw.bb.271
  %206 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T279 = getelementptr inbounds %struct.scheme, %struct.scheme* %206, i32 0, i32 19
  %207 = load %struct.cell*, %struct.cell** %T279, align 8
  br label %cond.end.282

cond.false.280:                                   ; preds = %sw.bb.271
  %208 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F281 = getelementptr inbounds %struct.scheme, %struct.scheme* %208, i32 0, i32 21
  %209 = load %struct.cell*, %struct.cell** %F281, align 8
  br label %cond.end.282

cond.end.282:                                     ; preds = %cond.false.280, %cond.true.278
  %cond283 = phi %struct.cell* [ %207, %cond.true.278 ], [ %209, %cond.false.280 ]
  %call284 = call %struct.cell* @_s_return(%struct.scheme* %202, %struct.cell* %cond283)
  store %struct.cell* %call284, %struct.cell** %retval
  br label %return

sw.bb.285:                                        ; preds = %entry
  %210 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %211 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args286 = getelementptr inbounds %struct.scheme, %struct.scheme* %211, i32 0, i32 7
  %212 = load %struct.cell*, %struct.cell** %args286, align 8
  %_object287 = getelementptr inbounds %struct.cell, %struct.cell* %212, i32 0, i32 1
  %_cons288 = bitcast %union.anon* %_object287 to %struct.anon.4*
  %_car289 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons288, i32 0, i32 0
  %213 = load %struct.cell*, %struct.cell** %_car289, align 8
  %call290 = call i32 @is_proc(%struct.cell* %213)
  %tobool291 = icmp ne i32 %call290, 0
  br i1 %tobool291, label %cond.true.313, label %lor.lhs.false.292

lor.lhs.false.292:                                ; preds = %sw.bb.285
  %214 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args293 = getelementptr inbounds %struct.scheme, %struct.scheme* %214, i32 0, i32 7
  %215 = load %struct.cell*, %struct.cell** %args293, align 8
  %_object294 = getelementptr inbounds %struct.cell, %struct.cell* %215, i32 0, i32 1
  %_cons295 = bitcast %union.anon* %_object294 to %struct.anon.4*
  %_car296 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons295, i32 0, i32 0
  %216 = load %struct.cell*, %struct.cell** %_car296, align 8
  %call297 = call i32 @is_closure(%struct.cell* %216)
  %tobool298 = icmp ne i32 %call297, 0
  br i1 %tobool298, label %cond.true.313, label %lor.lhs.false.299

lor.lhs.false.299:                                ; preds = %lor.lhs.false.292
  %217 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args300 = getelementptr inbounds %struct.scheme, %struct.scheme* %217, i32 0, i32 7
  %218 = load %struct.cell*, %struct.cell** %args300, align 8
  %_object301 = getelementptr inbounds %struct.cell, %struct.cell* %218, i32 0, i32 1
  %_cons302 = bitcast %union.anon* %_object301 to %struct.anon.4*
  %_car303 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons302, i32 0, i32 0
  %219 = load %struct.cell*, %struct.cell** %_car303, align 8
  %call304 = call i32 @is_continuation(%struct.cell* %219)
  %tobool305 = icmp ne i32 %call304, 0
  br i1 %tobool305, label %cond.true.313, label %lor.lhs.false.306

lor.lhs.false.306:                                ; preds = %lor.lhs.false.299
  %220 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args307 = getelementptr inbounds %struct.scheme, %struct.scheme* %220, i32 0, i32 7
  %221 = load %struct.cell*, %struct.cell** %args307, align 8
  %_object308 = getelementptr inbounds %struct.cell, %struct.cell* %221, i32 0, i32 1
  %_cons309 = bitcast %union.anon* %_object308 to %struct.anon.4*
  %_car310 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons309, i32 0, i32 0
  %222 = load %struct.cell*, %struct.cell** %_car310, align 8
  %call311 = call i32 @is_foreign(%struct.cell* %222)
  %tobool312 = icmp ne i32 %call311, 0
  br i1 %tobool312, label %cond.true.313, label %cond.false.315

cond.true.313:                                    ; preds = %lor.lhs.false.306, %lor.lhs.false.299, %lor.lhs.false.292, %sw.bb.285
  %223 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T314 = getelementptr inbounds %struct.scheme, %struct.scheme* %223, i32 0, i32 19
  %224 = load %struct.cell*, %struct.cell** %T314, align 8
  br label %cond.end.317

cond.false.315:                                   ; preds = %lor.lhs.false.306
  %225 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F316 = getelementptr inbounds %struct.scheme, %struct.scheme* %225, i32 0, i32 21
  %226 = load %struct.cell*, %struct.cell** %F316, align 8
  br label %cond.end.317

cond.end.317:                                     ; preds = %cond.false.315, %cond.true.313
  %cond318 = phi %struct.cell* [ %224, %cond.true.313 ], [ %226, %cond.false.315 ]
  %call319 = call %struct.cell* @_s_return(%struct.scheme* %210, %struct.cell* %cond318)
  store %struct.cell* %call319, %struct.cell** %retval
  br label %return

sw.bb.320:                                        ; preds = %entry
  %227 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %228 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args321 = getelementptr inbounds %struct.scheme, %struct.scheme* %228, i32 0, i32 7
  %229 = load %struct.cell*, %struct.cell** %args321, align 8
  %_object322 = getelementptr inbounds %struct.cell, %struct.cell* %229, i32 0, i32 1
  %_cons323 = bitcast %union.anon* %_object322 to %struct.anon.4*
  %_car324 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons323, i32 0, i32 0
  %230 = load %struct.cell*, %struct.cell** %_car324, align 8
  %call325 = call i32 @is_pair(%struct.cell* %230)
  %tobool326 = icmp ne i32 %call325, 0
  br i1 %tobool326, label %cond.true.327, label %cond.false.329

cond.true.327:                                    ; preds = %sw.bb.320
  %231 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T328 = getelementptr inbounds %struct.scheme, %struct.scheme* %231, i32 0, i32 19
  %232 = load %struct.cell*, %struct.cell** %T328, align 8
  br label %cond.end.331

cond.false.329:                                   ; preds = %sw.bb.320
  %233 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F330 = getelementptr inbounds %struct.scheme, %struct.scheme* %233, i32 0, i32 21
  %234 = load %struct.cell*, %struct.cell** %F330, align 8
  br label %cond.end.331

cond.end.331:                                     ; preds = %cond.false.329, %cond.true.327
  %cond332 = phi %struct.cell* [ %232, %cond.true.327 ], [ %234, %cond.false.329 ]
  %call333 = call %struct.cell* @_s_return(%struct.scheme* %227, %struct.cell* %cond332)
  store %struct.cell* %call333, %struct.cell** %retval
  br label %return

sw.bb.334:                                        ; preds = %entry
  %235 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %236 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %237 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args335 = getelementptr inbounds %struct.scheme, %struct.scheme* %237, i32 0, i32 7
  %238 = load %struct.cell*, %struct.cell** %args335, align 8
  %_object336 = getelementptr inbounds %struct.cell, %struct.cell* %238, i32 0, i32 1
  %_cons337 = bitcast %union.anon* %_object336 to %struct.anon.4*
  %_car338 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons337, i32 0, i32 0
  %239 = load %struct.cell*, %struct.cell** %_car338, align 8
  %call339 = call i32 @list_length(%struct.scheme* %236, %struct.cell* %239)
  %cmp340 = icmp sge i32 %call339, 0
  br i1 %cmp340, label %cond.true.342, label %cond.false.344

cond.true.342:                                    ; preds = %sw.bb.334
  %240 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T343 = getelementptr inbounds %struct.scheme, %struct.scheme* %240, i32 0, i32 19
  %241 = load %struct.cell*, %struct.cell** %T343, align 8
  br label %cond.end.346

cond.false.344:                                   ; preds = %sw.bb.334
  %242 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F345 = getelementptr inbounds %struct.scheme, %struct.scheme* %242, i32 0, i32 21
  %243 = load %struct.cell*, %struct.cell** %F345, align 8
  br label %cond.end.346

cond.end.346:                                     ; preds = %cond.false.344, %cond.true.342
  %cond347 = phi %struct.cell* [ %241, %cond.true.342 ], [ %243, %cond.false.344 ]
  %call348 = call %struct.cell* @_s_return(%struct.scheme* %235, %struct.cell* %cond347)
  store %struct.cell* %call348, %struct.cell** %retval
  br label %return

sw.bb.349:                                        ; preds = %entry
  %244 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %245 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args350 = getelementptr inbounds %struct.scheme, %struct.scheme* %245, i32 0, i32 7
  %246 = load %struct.cell*, %struct.cell** %args350, align 8
  %_object351 = getelementptr inbounds %struct.cell, %struct.cell* %246, i32 0, i32 1
  %_cons352 = bitcast %union.anon* %_object351 to %struct.anon.4*
  %_car353 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons352, i32 0, i32 0
  %247 = load %struct.cell*, %struct.cell** %_car353, align 8
  %call354 = call i32 @is_environment(%struct.cell* %247)
  %tobool355 = icmp ne i32 %call354, 0
  br i1 %tobool355, label %cond.true.356, label %cond.false.358

cond.true.356:                                    ; preds = %sw.bb.349
  %248 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T357 = getelementptr inbounds %struct.scheme, %struct.scheme* %248, i32 0, i32 19
  %249 = load %struct.cell*, %struct.cell** %T357, align 8
  br label %cond.end.360

cond.false.358:                                   ; preds = %sw.bb.349
  %250 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F359 = getelementptr inbounds %struct.scheme, %struct.scheme* %250, i32 0, i32 21
  %251 = load %struct.cell*, %struct.cell** %F359, align 8
  br label %cond.end.360

cond.end.360:                                     ; preds = %cond.false.358, %cond.true.356
  %cond361 = phi %struct.cell* [ %249, %cond.true.356 ], [ %251, %cond.false.358 ]
  %call362 = call %struct.cell* @_s_return(%struct.scheme* %244, %struct.cell* %cond361)
  store %struct.cell* %call362, %struct.cell** %retval
  br label %return

sw.bb.363:                                        ; preds = %entry
  %252 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %253 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args364 = getelementptr inbounds %struct.scheme, %struct.scheme* %253, i32 0, i32 7
  %254 = load %struct.cell*, %struct.cell** %args364, align 8
  %_object365 = getelementptr inbounds %struct.cell, %struct.cell* %254, i32 0, i32 1
  %_cons366 = bitcast %union.anon* %_object365 to %struct.anon.4*
  %_car367 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons366, i32 0, i32 0
  %255 = load %struct.cell*, %struct.cell** %_car367, align 8
  %call368 = call i32 @is_vector(%struct.cell* %255)
  %tobool369 = icmp ne i32 %call368, 0
  br i1 %tobool369, label %cond.true.370, label %cond.false.372

cond.true.370:                                    ; preds = %sw.bb.363
  %256 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T371 = getelementptr inbounds %struct.scheme, %struct.scheme* %256, i32 0, i32 19
  %257 = load %struct.cell*, %struct.cell** %T371, align 8
  br label %cond.end.374

cond.false.372:                                   ; preds = %sw.bb.363
  %258 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F373 = getelementptr inbounds %struct.scheme, %struct.scheme* %258, i32 0, i32 21
  %259 = load %struct.cell*, %struct.cell** %F373, align 8
  br label %cond.end.374

cond.end.374:                                     ; preds = %cond.false.372, %cond.true.370
  %cond375 = phi %struct.cell* [ %257, %cond.true.370 ], [ %259, %cond.false.372 ]
  %call376 = call %struct.cell* @_s_return(%struct.scheme* %252, %struct.cell* %cond375)
  store %struct.cell* %call376, %struct.cell** %retval
  br label %return

sw.bb.377:                                        ; preds = %entry
  %260 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %261 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args378 = getelementptr inbounds %struct.scheme, %struct.scheme* %261, i32 0, i32 7
  %262 = load %struct.cell*, %struct.cell** %args378, align 8
  %_object379 = getelementptr inbounds %struct.cell, %struct.cell* %262, i32 0, i32 1
  %_cons380 = bitcast %union.anon* %_object379 to %struct.anon.4*
  %_car381 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons380, i32 0, i32 0
  %263 = load %struct.cell*, %struct.cell** %_car381, align 8
  %264 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args382 = getelementptr inbounds %struct.scheme, %struct.scheme* %264, i32 0, i32 7
  %265 = load %struct.cell*, %struct.cell** %args382, align 8
  %_object383 = getelementptr inbounds %struct.cell, %struct.cell* %265, i32 0, i32 1
  %_cons384 = bitcast %union.anon* %_object383 to %struct.anon.4*
  %_cdr385 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons384, i32 0, i32 1
  %266 = load %struct.cell*, %struct.cell** %_cdr385, align 8
  %_object386 = getelementptr inbounds %struct.cell, %struct.cell* %266, i32 0, i32 1
  %_cons387 = bitcast %union.anon* %_object386 to %struct.anon.4*
  %_car388 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons387, i32 0, i32 0
  %267 = load %struct.cell*, %struct.cell** %_car388, align 8
  %cmp389 = icmp eq %struct.cell* %263, %267
  br i1 %cmp389, label %cond.true.391, label %cond.false.393

cond.true.391:                                    ; preds = %sw.bb.377
  %268 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T392 = getelementptr inbounds %struct.scheme, %struct.scheme* %268, i32 0, i32 19
  %269 = load %struct.cell*, %struct.cell** %T392, align 8
  br label %cond.end.395

cond.false.393:                                   ; preds = %sw.bb.377
  %270 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F394 = getelementptr inbounds %struct.scheme, %struct.scheme* %270, i32 0, i32 21
  %271 = load %struct.cell*, %struct.cell** %F394, align 8
  br label %cond.end.395

cond.end.395:                                     ; preds = %cond.false.393, %cond.true.391
  %cond396 = phi %struct.cell* [ %269, %cond.true.391 ], [ %271, %cond.false.393 ]
  %call397 = call %struct.cell* @_s_return(%struct.scheme* %260, %struct.cell* %cond396)
  store %struct.cell* %call397, %struct.cell** %retval
  br label %return

sw.bb.398:                                        ; preds = %entry
  %272 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %273 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args399 = getelementptr inbounds %struct.scheme, %struct.scheme* %273, i32 0, i32 7
  %274 = load %struct.cell*, %struct.cell** %args399, align 8
  %_object400 = getelementptr inbounds %struct.cell, %struct.cell* %274, i32 0, i32 1
  %_cons401 = bitcast %union.anon* %_object400 to %struct.anon.4*
  %_car402 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons401, i32 0, i32 0
  %275 = load %struct.cell*, %struct.cell** %_car402, align 8
  %276 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args403 = getelementptr inbounds %struct.scheme, %struct.scheme* %276, i32 0, i32 7
  %277 = load %struct.cell*, %struct.cell** %args403, align 8
  %_object404 = getelementptr inbounds %struct.cell, %struct.cell* %277, i32 0, i32 1
  %_cons405 = bitcast %union.anon* %_object404 to %struct.anon.4*
  %_cdr406 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons405, i32 0, i32 1
  %278 = load %struct.cell*, %struct.cell** %_cdr406, align 8
  %_object407 = getelementptr inbounds %struct.cell, %struct.cell* %278, i32 0, i32 1
  %_cons408 = bitcast %union.anon* %_object407 to %struct.anon.4*
  %_car409 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons408, i32 0, i32 0
  %279 = load %struct.cell*, %struct.cell** %_car409, align 8
  %call410 = call i32 @eqv(%struct.cell* %275, %struct.cell* %279)
  %tobool411 = icmp ne i32 %call410, 0
  br i1 %tobool411, label %cond.true.412, label %cond.false.414

cond.true.412:                                    ; preds = %sw.bb.398
  %280 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T413 = getelementptr inbounds %struct.scheme, %struct.scheme* %280, i32 0, i32 19
  %281 = load %struct.cell*, %struct.cell** %T413, align 8
  br label %cond.end.416

cond.false.414:                                   ; preds = %sw.bb.398
  %282 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F415 = getelementptr inbounds %struct.scheme, %struct.scheme* %282, i32 0, i32 21
  %283 = load %struct.cell*, %struct.cell** %F415, align 8
  br label %cond.end.416

cond.end.416:                                     ; preds = %cond.false.414, %cond.true.412
  %cond417 = phi %struct.cell* [ %281, %cond.true.412 ], [ %283, %cond.false.414 ]
  %call418 = call %struct.cell* @_s_return(%struct.scheme* %272, %struct.cell* %cond417)
  store %struct.cell* %call418, %struct.cell** %retval
  br label %return

sw.default.419:                                   ; preds = %entry
  %284 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %284, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %285 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op420 = getelementptr inbounds %struct.scheme, %struct.scheme* %285, i32 0, i32 55
  %286 = load i32, i32* %op420, align 4
  %call421 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %286) #2
  %287 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %288 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff422 = getelementptr inbounds %struct.scheme, %struct.scheme* %288, i32 0, i32 50
  %arraydecay423 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff422, i32 0, i32 0
  %call424 = call %struct.cell* @_Error_1(%struct.scheme* %287, i8* %arraydecay423, %struct.cell* null)
  store %struct.cell* %call424, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default.419, %cond.end.416, %cond.end.395, %cond.end.374, %cond.end.360, %cond.end.346, %cond.end.331, %cond.end.317, %cond.end.282, %cond.end.268, %cond.end.254, %cond.end.240, %cond.end.224, %cond.end.208, %cond.end.192, %cond.end.176, %cond.end.161, %cond.end.147, %cond.end.133, %cond.end.119, %cond.end.105, %cond.end.91, %for.end, %if.then, %cond.end.45, %cond.end.32, %cond.end.19, %cond.end
  %289 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %289
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_4(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  %was = alloca i32, align 4
  %prop = alloca i32, align 4
  %p = alloca %struct.cell*, align 8
  %prop265 = alloca i32, align 4
  %p266 = alloca %struct.cell*, align 8
  %p303 = alloca %struct.cell*, align 8
  %p353 = alloca %struct.port*, align 8
  %size = alloca i64, align 8
  %str = alloca i8*, align 8
  %s = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default.396 [
    i32 128, label %sw.bb
    i32 129, label %sw.bb.8
    i32 130, label %sw.bb.12
    i32 132, label %sw.bb.12
    i32 131, label %sw.bb.12
    i32 133, label %sw.bb.55
    i32 134, label %sw.bb.80
    i32 135, label %sw.bb.111
    i32 136, label %sw.bb.142
    i32 137, label %sw.bb.149
    i32 138, label %sw.bb.153
    i32 139, label %sw.bb.181
    i32 140, label %sw.bb.194
    i32 141, label %sw.bb.199
    i32 142, label %sw.bb.214
    i32 143, label %sw.bb.236
    i32 144, label %sw.bb.239
    i32 145, label %sw.bb.241
    i32 146, label %sw.bb.244
    i32 147, label %sw.bb.244
    i32 148, label %sw.bb.244
    i32 149, label %sw.bb.264
    i32 150, label %sw.bb.264
    i32 151, label %sw.bb.302
    i32 152, label %sw.bb.352
    i32 153, label %sw.bb.378
    i32 154, label %sw.bb.385
    i32 155, label %sw.bb.392
    i32 156, label %sw.bb.394
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 7
  %2 = load %struct.cell*, %struct.cell** %args, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %2, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %3 = load %struct.cell*, %struct.cell** %_car, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 9
  store %struct.cell* %3, %struct.cell** %code, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code1 = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 9
  %6 = load %struct.cell*, %struct.cell** %code1, align 8
  %call = call i32 @is_promise(%struct.cell* %6)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 17
  %9 = load %struct.cell*, %struct.cell** %NIL, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code2 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 9
  %11 = load %struct.cell*, %struct.cell** %code2, align 8
  call void @s_save(%struct.scheme* %7, i32 129, %struct.cell* %9, %struct.cell* %11)
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL3 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 17
  %13 = load %struct.cell*, %struct.cell** %NIL3, align 8
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args4 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 7
  store %struct.cell* %13, %struct.cell** %args4, align 8
  br label %do.body

do.body:                                          ; preds = %if.then
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op5 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 55
  store i32 10, i32* %op5, align 4
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 19
  %17 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %17, %struct.cell** %retval
  br label %return

do.end:                                           ; No predecessors!
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code6 = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 9
  %20 = load %struct.cell*, %struct.cell** %code6, align 8
  %call7 = call %struct.cell* @_s_return(%struct.scheme* %18, %struct.cell* %20)
  store %struct.cell* %call7, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %do.end
  br label %sw.bb.8

sw.bb.8:                                          ; preds = %entry, %if.end
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code9 = getelementptr inbounds %struct.scheme, %struct.scheme* %21, i32 0, i32 9
  %22 = load %struct.cell*, %struct.cell** %code9, align 8
  %23 = bitcast %struct.cell* %22 to i8*
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 54
  %25 = load %struct.cell*, %struct.cell** %value, align 8
  %26 = bitcast %struct.cell* %25 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %26, i64 24, i32 8, i1 false)
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value10 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 54
  %29 = load %struct.cell*, %struct.cell** %value10, align 8
  %call11 = call %struct.cell* @_s_return(%struct.scheme* %27, %struct.cell* %29)
  store %struct.cell* %call11, %struct.cell** %retval
  br label %return

sw.bb.12:                                         ; preds = %entry, %entry, %entry
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args13 = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 7
  %31 = load %struct.cell*, %struct.cell** %args13, align 8
  %_object14 = getelementptr inbounds %struct.cell, %struct.cell* %31, i32 0, i32 1
  %_cons15 = bitcast %union.anon* %_object14 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons15, i32 0, i32 1
  %32 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %call16 = call i32 @is_pair(%struct.cell* %32)
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then.18, label %if.end.40

if.then.18:                                       ; preds = %sw.bb.12
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args19 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 7
  %34 = load %struct.cell*, %struct.cell** %args19, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %34, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr22 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  %35 = load %struct.cell*, %struct.cell** %_cdr22, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %35, i32 0, i32 1
  %_cons24 = bitcast %union.anon* %_object23 to %struct.anon.4*
  %_car25 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons24, i32 0, i32 0
  %36 = load %struct.cell*, %struct.cell** %_car25, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 40
  %38 = load %struct.cell*, %struct.cell** %outport, align 8
  %cmp = icmp ne %struct.cell* %36, %38
  br i1 %cmp, label %if.then.26, label %if.end.39

if.then.26:                                       ; preds = %if.then.18
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport27 = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 40
  %41 = load %struct.cell*, %struct.cell** %outport27, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL28 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 17
  %43 = load %struct.cell*, %struct.cell** %NIL28, align 8
  %call29 = call %struct.cell* @_cons(%struct.scheme* %39, %struct.cell* %41, %struct.cell* %43, i32 0)
  store %struct.cell* %call29, %struct.cell** %x, align 8
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %45 = load %struct.cell*, %struct.cell** %x, align 8
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL30 = getelementptr inbounds %struct.scheme, %struct.scheme* %46, i32 0, i32 17
  %47 = load %struct.cell*, %struct.cell** %NIL30, align 8
  call void @s_save(%struct.scheme* %44, i32 162, %struct.cell* %45, %struct.cell* %47)
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args31 = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 7
  %49 = load %struct.cell*, %struct.cell** %args31, align 8
  %_object32 = getelementptr inbounds %struct.cell, %struct.cell* %49, i32 0, i32 1
  %_cons33 = bitcast %union.anon* %_object32 to %struct.anon.4*
  %_cdr34 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons33, i32 0, i32 1
  %50 = load %struct.cell*, %struct.cell** %_cdr34, align 8
  %_object35 = getelementptr inbounds %struct.cell, %struct.cell* %50, i32 0, i32 1
  %_cons36 = bitcast %union.anon* %_object35 to %struct.anon.4*
  %_car37 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons36, i32 0, i32 0
  %51 = load %struct.cell*, %struct.cell** %_car37, align 8
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport38 = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 40
  store %struct.cell* %51, %struct.cell** %outport38, align 8
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.26, %if.then.18
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %sw.bb.12
  %53 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args41 = getelementptr inbounds %struct.scheme, %struct.scheme* %53, i32 0, i32 7
  %54 = load %struct.cell*, %struct.cell** %args41, align 8
  %_object42 = getelementptr inbounds %struct.cell, %struct.cell* %54, i32 0, i32 1
  %_cons43 = bitcast %union.anon* %_object42 to %struct.anon.4*
  %_car44 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons43, i32 0, i32 0
  %55 = load %struct.cell*, %struct.cell** %_car44, align 8
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args45 = getelementptr inbounds %struct.scheme, %struct.scheme* %56, i32 0, i32 7
  store %struct.cell* %55, %struct.cell** %args45, align 8
  %57 = load i32, i32* %op.addr, align 4
  %cmp46 = icmp eq i32 %57, 130
  br i1 %cmp46, label %if.then.47, label %if.else.48

if.then.47:                                       ; preds = %if.end.40
  %58 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %58, i32 0, i32 53
  store i32 1, i32* %print_flag, align 4
  br label %if.end.50

if.else.48:                                       ; preds = %if.end.40
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag49 = getelementptr inbounds %struct.scheme, %struct.scheme* %59, i32 0, i32 53
  store i32 0, i32* %print_flag49, align 4
  br label %if.end.50

if.end.50:                                        ; preds = %if.else.48, %if.then.47
  br label %do.body.51

do.body.51:                                       ; preds = %if.end.50
  %60 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op52 = getelementptr inbounds %struct.scheme, %struct.scheme* %60, i32 0, i32 55
  store i32 172, i32* %op52, align 4
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T53 = getelementptr inbounds %struct.scheme, %struct.scheme* %61, i32 0, i32 19
  %62 = load %struct.cell*, %struct.cell** %T53, align 8
  store %struct.cell* %62, %struct.cell** %retval
  br label %return

do.end.54:                                        ; No predecessors!
  br label %sw.bb.55

sw.bb.55:                                         ; preds = %entry, %do.end.54
  %63 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args56 = getelementptr inbounds %struct.scheme, %struct.scheme* %63, i32 0, i32 7
  %64 = load %struct.cell*, %struct.cell** %args56, align 8
  %call57 = call i32 @is_pair(%struct.cell* %64)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then.59, label %if.end.77

if.then.59:                                       ; preds = %sw.bb.55
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args60 = getelementptr inbounds %struct.scheme, %struct.scheme* %65, i32 0, i32 7
  %66 = load %struct.cell*, %struct.cell** %args60, align 8
  %_object61 = getelementptr inbounds %struct.cell, %struct.cell* %66, i32 0, i32 1
  %_cons62 = bitcast %union.anon* %_object61 to %struct.anon.4*
  %_car63 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons62, i32 0, i32 0
  %67 = load %struct.cell*, %struct.cell** %_car63, align 8
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport64 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 40
  %69 = load %struct.cell*, %struct.cell** %outport64, align 8
  %cmp65 = icmp ne %struct.cell* %67, %69
  br i1 %cmp65, label %if.then.66, label %if.end.76

if.then.66:                                       ; preds = %if.then.59
  %70 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport67 = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 40
  %72 = load %struct.cell*, %struct.cell** %outport67, align 8
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL68 = getelementptr inbounds %struct.scheme, %struct.scheme* %73, i32 0, i32 17
  %74 = load %struct.cell*, %struct.cell** %NIL68, align 8
  %call69 = call %struct.cell* @_cons(%struct.scheme* %70, %struct.cell* %72, %struct.cell* %74, i32 0)
  store %struct.cell* %call69, %struct.cell** %x, align 8
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %76 = load %struct.cell*, %struct.cell** %x, align 8
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL70 = getelementptr inbounds %struct.scheme, %struct.scheme* %77, i32 0, i32 17
  %78 = load %struct.cell*, %struct.cell** %NIL70, align 8
  call void @s_save(%struct.scheme* %75, i32 162, %struct.cell* %76, %struct.cell* %78)
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args71 = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 7
  %80 = load %struct.cell*, %struct.cell** %args71, align 8
  %_object72 = getelementptr inbounds %struct.cell, %struct.cell* %80, i32 0, i32 1
  %_cons73 = bitcast %union.anon* %_object72 to %struct.anon.4*
  %_car74 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons73, i32 0, i32 0
  %81 = load %struct.cell*, %struct.cell** %_car74, align 8
  %82 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport75 = getelementptr inbounds %struct.scheme, %struct.scheme* %82, i32 0, i32 40
  store %struct.cell* %81, %struct.cell** %outport75, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.66, %if.then.59
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.76, %sw.bb.55
  %83 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %83, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0))
  %84 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %85 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T78 = getelementptr inbounds %struct.scheme, %struct.scheme* %85, i32 0, i32 19
  %86 = load %struct.cell*, %struct.cell** %T78, align 8
  %call79 = call %struct.cell* @_s_return(%struct.scheme* %84, %struct.cell* %86)
  store %struct.cell* %call79, %struct.cell** %retval
  br label %return

sw.bb.80:                                         ; preds = %entry
  %87 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %87, i32 0, i32 2
  store i32 -1, i32* %retcode, align 4
  %88 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args81 = getelementptr inbounds %struct.scheme, %struct.scheme* %88, i32 0, i32 7
  %89 = load %struct.cell*, %struct.cell** %args81, align 8
  %_object82 = getelementptr inbounds %struct.cell, %struct.cell* %89, i32 0, i32 1
  %_cons83 = bitcast %union.anon* %_object82 to %struct.anon.4*
  %_car84 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons83, i32 0, i32 0
  %90 = load %struct.cell*, %struct.cell** %_car84, align 8
  %call85 = call i32 @is_string(%struct.cell* %90)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.end.96, label %if.then.87

if.then.87:                                       ; preds = %sw.bb.80
  %91 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %92 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call88 = call %struct.cell* @mk_string(%struct.scheme* %92, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.250, i32 0, i32 0))
  %93 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args89 = getelementptr inbounds %struct.scheme, %struct.scheme* %93, i32 0, i32 7
  %94 = load %struct.cell*, %struct.cell** %args89, align 8
  %call90 = call %struct.cell* @_cons(%struct.scheme* %91, %struct.cell* %call88, %struct.cell* %94, i32 0)
  %95 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args91 = getelementptr inbounds %struct.scheme, %struct.scheme* %95, i32 0, i32 7
  store %struct.cell* %call90, %struct.cell** %args91, align 8
  %96 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args92 = getelementptr inbounds %struct.scheme, %struct.scheme* %96, i32 0, i32 7
  %97 = load %struct.cell*, %struct.cell** %args92, align 8
  %_object93 = getelementptr inbounds %struct.cell, %struct.cell* %97, i32 0, i32 1
  %_cons94 = bitcast %union.anon* %_object93 to %struct.anon.4*
  %_car95 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons94, i32 0, i32 0
  %98 = load %struct.cell*, %struct.cell** %_car95, align 8
  call void @setimmutable(%struct.cell* %98)
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.87, %sw.bb.80
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %99, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.251, i32 0, i32 0))
  %100 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %101 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args97 = getelementptr inbounds %struct.scheme, %struct.scheme* %101, i32 0, i32 7
  %102 = load %struct.cell*, %struct.cell** %args97, align 8
  %_object98 = getelementptr inbounds %struct.cell, %struct.cell* %102, i32 0, i32 1
  %_cons99 = bitcast %union.anon* %_object98 to %struct.anon.4*
  %_car100 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons99, i32 0, i32 0
  %103 = load %struct.cell*, %struct.cell** %_car100, align 8
  %_object101 = getelementptr inbounds %struct.cell, %struct.cell* %103, i32 0, i32 1
  %_string = bitcast %union.anon* %_object101 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %104 = load i8*, i8** %_svalue, align 8
  call void @putstr(%struct.scheme* %100, i8* %104)
  %105 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args102 = getelementptr inbounds %struct.scheme, %struct.scheme* %105, i32 0, i32 7
  %106 = load %struct.cell*, %struct.cell** %args102, align 8
  %_object103 = getelementptr inbounds %struct.cell, %struct.cell* %106, i32 0, i32 1
  %_cons104 = bitcast %union.anon* %_object103 to %struct.anon.4*
  %_cdr105 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons104, i32 0, i32 1
  %107 = load %struct.cell*, %struct.cell** %_cdr105, align 8
  %108 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args106 = getelementptr inbounds %struct.scheme, %struct.scheme* %108, i32 0, i32 7
  store %struct.cell* %107, %struct.cell** %args106, align 8
  br label %do.body.107

do.body.107:                                      ; preds = %if.end.96
  %109 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op108 = getelementptr inbounds %struct.scheme, %struct.scheme* %109, i32 0, i32 55
  store i32 135, i32* %op108, align 4
  %110 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T109 = getelementptr inbounds %struct.scheme, %struct.scheme* %110, i32 0, i32 19
  %111 = load %struct.cell*, %struct.cell** %T109, align 8
  store %struct.cell* %111, %struct.cell** %retval
  br label %return

do.end.110:                                       ; No predecessors!
  br label %sw.bb.111

sw.bb.111:                                        ; preds = %entry, %do.end.110
  %112 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %112, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.252, i32 0, i32 0))
  %113 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args112 = getelementptr inbounds %struct.scheme, %struct.scheme* %113, i32 0, i32 7
  %114 = load %struct.cell*, %struct.cell** %args112, align 8
  %115 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL113 = getelementptr inbounds %struct.scheme, %struct.scheme* %115, i32 0, i32 17
  %116 = load %struct.cell*, %struct.cell** %NIL113, align 8
  %cmp114 = icmp ne %struct.cell* %114, %116
  br i1 %cmp114, label %if.then.115, label %if.else.131

if.then.115:                                      ; preds = %sw.bb.111
  %117 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %118 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args116 = getelementptr inbounds %struct.scheme, %struct.scheme* %118, i32 0, i32 7
  %119 = load %struct.cell*, %struct.cell** %args116, align 8
  %_object117 = getelementptr inbounds %struct.cell, %struct.cell* %119, i32 0, i32 1
  %_cons118 = bitcast %union.anon* %_object117 to %struct.anon.4*
  %_cdr119 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons118, i32 0, i32 1
  %120 = load %struct.cell*, %struct.cell** %_cdr119, align 8
  %121 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL120 = getelementptr inbounds %struct.scheme, %struct.scheme* %121, i32 0, i32 17
  %122 = load %struct.cell*, %struct.cell** %NIL120, align 8
  call void @s_save(%struct.scheme* %117, i32 135, %struct.cell* %120, %struct.cell* %122)
  %123 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args121 = getelementptr inbounds %struct.scheme, %struct.scheme* %123, i32 0, i32 7
  %124 = load %struct.cell*, %struct.cell** %args121, align 8
  %_object122 = getelementptr inbounds %struct.cell, %struct.cell* %124, i32 0, i32 1
  %_cons123 = bitcast %union.anon* %_object122 to %struct.anon.4*
  %_car124 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons123, i32 0, i32 0
  %125 = load %struct.cell*, %struct.cell** %_car124, align 8
  %126 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args125 = getelementptr inbounds %struct.scheme, %struct.scheme* %126, i32 0, i32 7
  store %struct.cell* %125, %struct.cell** %args125, align 8
  %127 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag126 = getelementptr inbounds %struct.scheme, %struct.scheme* %127, i32 0, i32 53
  store i32 1, i32* %print_flag126, align 4
  br label %do.body.127

do.body.127:                                      ; preds = %if.then.115
  %128 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op128 = getelementptr inbounds %struct.scheme, %struct.scheme* %128, i32 0, i32 55
  store i32 172, i32* %op128, align 4
  %129 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T129 = getelementptr inbounds %struct.scheme, %struct.scheme* %129, i32 0, i32 19
  %130 = load %struct.cell*, %struct.cell** %T129, align 8
  store %struct.cell* %130, %struct.cell** %retval
  br label %return

do.end.130:                                       ; No predecessors!
  br label %if.end.141

if.else.131:                                      ; preds = %sw.bb.111
  %131 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %131, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.71, i32 0, i32 0))
  %132 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %interactive_repl = getelementptr inbounds %struct.scheme, %struct.scheme* %132, i32 0, i32 12
  %133 = load i32, i32* %interactive_repl, align 4
  %tobool132 = icmp ne i32 %133, 0
  br i1 %tobool132, label %if.then.133, label %if.else.138

if.then.133:                                      ; preds = %if.else.131
  br label %do.body.134

do.body.134:                                      ; preds = %if.then.133
  %134 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op135 = getelementptr inbounds %struct.scheme, %struct.scheme* %134, i32 0, i32 55
  store i32 1, i32* %op135, align 4
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T136 = getelementptr inbounds %struct.scheme, %struct.scheme* %135, i32 0, i32 19
  %136 = load %struct.cell*, %struct.cell** %T136, align 8
  store %struct.cell* %136, %struct.cell** %retval
  br label %return

do.end.137:                                       ; No predecessors!
  br label %if.end.140

if.else.138:                                      ; preds = %if.else.131
  %137 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL139 = getelementptr inbounds %struct.scheme, %struct.scheme* %137, i32 0, i32 17
  %138 = load %struct.cell*, %struct.cell** %NIL139, align 8
  store %struct.cell* %138, %struct.cell** %retval
  br label %return

if.end.140:                                       ; preds = %do.end.137
  br label %if.end.141

if.end.141:                                       ; preds = %if.end.140, %do.end.130
  br label %sw.bb.142

sw.bb.142:                                        ; preds = %entry, %if.end.141
  %139 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %140 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %141 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args143 = getelementptr inbounds %struct.scheme, %struct.scheme* %141, i32 0, i32 7
  %142 = load %struct.cell*, %struct.cell** %args143, align 8
  %_object144 = getelementptr inbounds %struct.cell, %struct.cell* %142, i32 0, i32 1
  %_cons145 = bitcast %union.anon* %_object144 to %struct.anon.4*
  %_car146 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons145, i32 0, i32 0
  %143 = load %struct.cell*, %struct.cell** %_car146, align 8
  %call147 = call %struct.cell* @reverse(%struct.scheme* %140, %struct.cell* %143)
  %call148 = call %struct.cell* @_s_return(%struct.scheme* %139, %struct.cell* %call147)
  store %struct.cell* %call148, %struct.cell** %retval
  br label %return

sw.bb.149:                                        ; preds = %entry
  %144 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %145 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %146 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args150 = getelementptr inbounds %struct.scheme, %struct.scheme* %146, i32 0, i32 7
  %147 = load %struct.cell*, %struct.cell** %args150, align 8
  %call151 = call %struct.cell* @list_star(%struct.scheme* %145, %struct.cell* %147)
  %call152 = call %struct.cell* @_s_return(%struct.scheme* %144, %struct.cell* %call151)
  store %struct.cell* %call152, %struct.cell** %retval
  br label %return

sw.bb.153:                                        ; preds = %entry
  %148 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL154 = getelementptr inbounds %struct.scheme, %struct.scheme* %148, i32 0, i32 17
  %149 = load %struct.cell*, %struct.cell** %NIL154, align 8
  store %struct.cell* %149, %struct.cell** %x, align 8
  %150 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args155 = getelementptr inbounds %struct.scheme, %struct.scheme* %150, i32 0, i32 7
  %151 = load %struct.cell*, %struct.cell** %args155, align 8
  store %struct.cell* %151, %struct.cell** %y, align 8
  %152 = load %struct.cell*, %struct.cell** %y, align 8
  %153 = load %struct.cell*, %struct.cell** %x, align 8
  %cmp156 = icmp eq %struct.cell* %152, %153
  br i1 %cmp156, label %if.then.157, label %if.end.159

if.then.157:                                      ; preds = %sw.bb.153
  %154 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %155 = load %struct.cell*, %struct.cell** %x, align 8
  %call158 = call %struct.cell* @_s_return(%struct.scheme* %154, %struct.cell* %155)
  store %struct.cell* %call158, %struct.cell** %retval
  br label %return

if.end.159:                                       ; preds = %sw.bb.153
  br label %while.cond

while.cond:                                       ; preds = %if.end.175, %if.end.159
  %156 = load %struct.cell*, %struct.cell** %y, align 8
  %_object160 = getelementptr inbounds %struct.cell, %struct.cell* %156, i32 0, i32 1
  %_cons161 = bitcast %union.anon* %_object160 to %struct.anon.4*
  %_cdr162 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons161, i32 0, i32 1
  %157 = load %struct.cell*, %struct.cell** %_cdr162, align 8
  %158 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL163 = getelementptr inbounds %struct.scheme, %struct.scheme* %158, i32 0, i32 17
  %159 = load %struct.cell*, %struct.cell** %NIL163, align 8
  %cmp164 = icmp ne %struct.cell* %157, %159
  br i1 %cmp164, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %160 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %161 = load %struct.cell*, %struct.cell** %x, align 8
  %162 = load %struct.cell*, %struct.cell** %y, align 8
  %_object165 = getelementptr inbounds %struct.cell, %struct.cell* %162, i32 0, i32 1
  %_cons166 = bitcast %union.anon* %_object165 to %struct.anon.4*
  %_car167 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons166, i32 0, i32 0
  %163 = load %struct.cell*, %struct.cell** %_car167, align 8
  %call168 = call %struct.cell* @revappend(%struct.scheme* %160, %struct.cell* %161, %struct.cell* %163)
  store %struct.cell* %call168, %struct.cell** %x, align 8
  %164 = load %struct.cell*, %struct.cell** %y, align 8
  %_object169 = getelementptr inbounds %struct.cell, %struct.cell* %164, i32 0, i32 1
  %_cons170 = bitcast %union.anon* %_object169 to %struct.anon.4*
  %_cdr171 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons170, i32 0, i32 1
  %165 = load %struct.cell*, %struct.cell** %_cdr171, align 8
  store %struct.cell* %165, %struct.cell** %y, align 8
  %166 = load %struct.cell*, %struct.cell** %x, align 8
  %167 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %167, i32 0, i32 21
  %168 = load %struct.cell*, %struct.cell** %F, align 8
  %cmp172 = icmp eq %struct.cell* %166, %168
  br i1 %cmp172, label %if.then.173, label %if.end.175

if.then.173:                                      ; preds = %while.body
  %169 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call174 = call %struct.cell* @_Error_1(%struct.scheme* %169, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.253, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call174, %struct.cell** %retval
  br label %return

if.end.175:                                       ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %170 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %171 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %172 = load %struct.cell*, %struct.cell** %y, align 8
  %_object176 = getelementptr inbounds %struct.cell, %struct.cell* %172, i32 0, i32 1
  %_cons177 = bitcast %union.anon* %_object176 to %struct.anon.4*
  %_car178 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons177, i32 0, i32 0
  %173 = load %struct.cell*, %struct.cell** %_car178, align 8
  %174 = load %struct.cell*, %struct.cell** %x, align 8
  %call179 = call %struct.cell* @reverse_in_place(%struct.scheme* %171, %struct.cell* %173, %struct.cell* %174)
  %call180 = call %struct.cell* @_s_return(%struct.scheme* %170, %struct.cell* %call179)
  store %struct.cell* %call180, %struct.cell** %retval
  br label %return

sw.bb.181:                                        ; preds = %entry
  %175 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args182 = getelementptr inbounds %struct.scheme, %struct.scheme* %175, i32 0, i32 7
  %176 = load %struct.cell*, %struct.cell** %args182, align 8
  %call183 = call i32 @is_pair(%struct.cell* %176)
  %tobool184 = icmp ne i32 %call183, 0
  br i1 %tobool184, label %if.then.185, label %if.end.192

if.then.185:                                      ; preds = %sw.bb.181
  %177 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args186 = getelementptr inbounds %struct.scheme, %struct.scheme* %177, i32 0, i32 7
  %178 = load %struct.cell*, %struct.cell** %args186, align 8
  %_object187 = getelementptr inbounds %struct.cell, %struct.cell* %178, i32 0, i32 1
  %_cons188 = bitcast %union.anon* %_object187 to %struct.anon.4*
  %_car189 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons188, i32 0, i32 0
  %179 = load %struct.cell*, %struct.cell** %_car189, align 8
  %call190 = call i64 @ivalue(%struct.cell* %179)
  %conv = trunc i64 %call190 to i32
  %180 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode191 = getelementptr inbounds %struct.scheme, %struct.scheme* %180, i32 0, i32 2
  store i32 %conv, i32* %retcode191, align 4
  br label %if.end.192

if.end.192:                                       ; preds = %if.then.185, %sw.bb.181
  %181 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL193 = getelementptr inbounds %struct.scheme, %struct.scheme* %181, i32 0, i32 17
  %182 = load %struct.cell*, %struct.cell** %NIL193, align 8
  store %struct.cell* %182, %struct.cell** %retval
  br label %return

sw.bb.194:                                        ; preds = %entry
  %183 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %184 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL195 = getelementptr inbounds %struct.scheme, %struct.scheme* %184, i32 0, i32 17
  %185 = load %struct.cell*, %struct.cell** %NIL195, align 8
  %186 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL196 = getelementptr inbounds %struct.scheme, %struct.scheme* %186, i32 0, i32 17
  %187 = load %struct.cell*, %struct.cell** %NIL196, align 8
  call void @gc(%struct.scheme* %183, %struct.cell* %185, %struct.cell* %187)
  %188 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %189 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T197 = getelementptr inbounds %struct.scheme, %struct.scheme* %189, i32 0, i32 19
  %190 = load %struct.cell*, %struct.cell** %T197, align 8
  %call198 = call %struct.cell* @_s_return(%struct.scheme* %188, %struct.cell* %190)
  store %struct.cell* %call198, %struct.cell** %retval
  br label %return

sw.bb.199:                                        ; preds = %entry
  %191 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose = getelementptr inbounds %struct.scheme, %struct.scheme* %191, i32 0, i32 47
  %192 = load i8, i8* %gc_verbose, align 1
  %conv200 = sext i8 %192 to i32
  store i32 %conv200, i32* %was, align 4
  %193 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args201 = getelementptr inbounds %struct.scheme, %struct.scheme* %193, i32 0, i32 7
  %194 = load %struct.cell*, %struct.cell** %args201, align 8
  %_object202 = getelementptr inbounds %struct.cell, %struct.cell* %194, i32 0, i32 1
  %_cons203 = bitcast %union.anon* %_object202 to %struct.anon.4*
  %_car204 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons203, i32 0, i32 0
  %195 = load %struct.cell*, %struct.cell** %_car204, align 8
  %196 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F205 = getelementptr inbounds %struct.scheme, %struct.scheme* %196, i32 0, i32 21
  %197 = load %struct.cell*, %struct.cell** %F205, align 8
  %cmp206 = icmp ne %struct.cell* %195, %197
  %conv207 = zext i1 %cmp206 to i32
  %conv208 = trunc i32 %conv207 to i8
  %198 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %gc_verbose209 = getelementptr inbounds %struct.scheme, %struct.scheme* %198, i32 0, i32 47
  store i8 %conv208, i8* %gc_verbose209, align 1
  %199 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %200 = load i32, i32* %was, align 4
  %tobool210 = icmp ne i32 %200, 0
  br i1 %tobool210, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb.199
  %201 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T211 = getelementptr inbounds %struct.scheme, %struct.scheme* %201, i32 0, i32 19
  %202 = load %struct.cell*, %struct.cell** %T211, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb.199
  %203 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F212 = getelementptr inbounds %struct.scheme, %struct.scheme* %203, i32 0, i32 21
  %204 = load %struct.cell*, %struct.cell** %F212, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.cell* [ %202, %cond.true ], [ %204, %cond.false ]
  %call213 = call %struct.cell* @_s_return(%struct.scheme* %199, %struct.cell* %cond)
  store %struct.cell* %call213, %struct.cell** %retval
  br label %return

sw.bb.214:                                        ; preds = %entry
  %205 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args215 = getelementptr inbounds %struct.scheme, %struct.scheme* %205, i32 0, i32 7
  %206 = load %struct.cell*, %struct.cell** %args215, align 8
  %call216 = call i32 @is_pair(%struct.cell* %206)
  %tobool217 = icmp ne i32 %call216, 0
  br i1 %tobool217, label %lor.lhs.false, label %if.then.224

lor.lhs.false:                                    ; preds = %sw.bb.214
  %207 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args218 = getelementptr inbounds %struct.scheme, %struct.scheme* %207, i32 0, i32 7
  %208 = load %struct.cell*, %struct.cell** %args218, align 8
  %_object219 = getelementptr inbounds %struct.cell, %struct.cell* %208, i32 0, i32 1
  %_cons220 = bitcast %union.anon* %_object219 to %struct.anon.4*
  %_car221 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons220, i32 0, i32 0
  %209 = load %struct.cell*, %struct.cell** %_car221, align 8
  %call222 = call i32 @is_number(%struct.cell* %209)
  %tobool223 = icmp ne i32 %call222, 0
  br i1 %tobool223, label %if.end.226, label %if.then.224

if.then.224:                                      ; preds = %lor.lhs.false, %sw.bb.214
  %210 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call225 = call %struct.cell* @_Error_1(%struct.scheme* %210, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.254, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call225, %struct.cell** %retval
  br label %return

if.end.226:                                       ; preds = %lor.lhs.false
  %211 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %212 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args227 = getelementptr inbounds %struct.scheme, %struct.scheme* %212, i32 0, i32 7
  %213 = load %struct.cell*, %struct.cell** %args227, align 8
  %_object228 = getelementptr inbounds %struct.cell, %struct.cell* %213, i32 0, i32 1
  %_cons229 = bitcast %union.anon* %_object228 to %struct.anon.4*
  %_car230 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons229, i32 0, i32 0
  %214 = load %struct.cell*, %struct.cell** %_car230, align 8
  %call231 = call i64 @ivalue(%struct.cell* %214)
  %conv232 = trunc i64 %call231 to i32
  %call233 = call i32 @alloc_cellseg(%struct.scheme* %211, i32 %conv232)
  %215 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %216 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T234 = getelementptr inbounds %struct.scheme, %struct.scheme* %216, i32 0, i32 19
  %217 = load %struct.cell*, %struct.cell** %T234, align 8
  %call235 = call %struct.cell* @_s_return(%struct.scheme* %215, %struct.cell* %217)
  store %struct.cell* %call235, %struct.cell** %retval
  br label %return

sw.bb.236:                                        ; preds = %entry
  %218 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %219 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call237 = call %struct.cell* @oblist_all_symbols(%struct.scheme* %219)
  %call238 = call %struct.cell* @_s_return(%struct.scheme* %218, %struct.cell* %call237)
  store %struct.cell* %call238, %struct.cell** %retval
  br label %return

sw.bb.239:                                        ; preds = %entry
  %220 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %221 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %221, i32 0, i32 39
  %222 = load %struct.cell*, %struct.cell** %inport, align 8
  %call240 = call %struct.cell* @_s_return(%struct.scheme* %220, %struct.cell* %222)
  store %struct.cell* %call240, %struct.cell** %retval
  br label %return

sw.bb.241:                                        ; preds = %entry
  %223 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %224 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport242 = getelementptr inbounds %struct.scheme, %struct.scheme* %224, i32 0, i32 40
  %225 = load %struct.cell*, %struct.cell** %outport242, align 8
  %call243 = call %struct.cell* @_s_return(%struct.scheme* %223, %struct.cell* %225)
  store %struct.cell* %call243, %struct.cell** %retval
  br label %return

sw.bb.244:                                        ; preds = %entry, %entry, %entry
  store i32 0, i32* %prop, align 4
  %226 = load i32, i32* %op.addr, align 4
  switch i32 %226, label %sw.default [
    i32 146, label %sw.bb.245
    i32 147, label %sw.bb.246
    i32 148, label %sw.bb.247
  ]

sw.bb.245:                                        ; preds = %sw.bb.244
  store i32 16, i32* %prop, align 4
  br label %sw.epilog

sw.bb.246:                                        ; preds = %sw.bb.244
  store i32 32, i32* %prop, align 4
  br label %sw.epilog

sw.bb.247:                                        ; preds = %sw.bb.244
  store i32 48, i32* %prop, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %sw.bb.244
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.247, %sw.bb.246, %sw.bb.245
  %227 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %228 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args248 = getelementptr inbounds %struct.scheme, %struct.scheme* %228, i32 0, i32 7
  %229 = load %struct.cell*, %struct.cell** %args248, align 8
  %_object249 = getelementptr inbounds %struct.cell, %struct.cell* %229, i32 0, i32 1
  %_cons250 = bitcast %union.anon* %_object249 to %struct.anon.4*
  %_car251 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons250, i32 0, i32 0
  %230 = load %struct.cell*, %struct.cell** %_car251, align 8
  %_object252 = getelementptr inbounds %struct.cell, %struct.cell* %230, i32 0, i32 1
  %_string253 = bitcast %union.anon* %_object252 to %struct.anon*
  %_svalue254 = getelementptr inbounds %struct.anon, %struct.anon* %_string253, i32 0, i32 0
  %231 = load i8*, i8** %_svalue254, align 8
  %232 = load i32, i32* %prop, align 4
  %call255 = call %struct.cell* @port_from_filename(%struct.scheme* %227, i8* %231, i32 %232)
  store %struct.cell* %call255, %struct.cell** %p, align 8
  %233 = load %struct.cell*, %struct.cell** %p, align 8
  %234 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL256 = getelementptr inbounds %struct.scheme, %struct.scheme* %234, i32 0, i32 17
  %235 = load %struct.cell*, %struct.cell** %NIL256, align 8
  %cmp257 = icmp eq %struct.cell* %233, %235
  br i1 %cmp257, label %if.then.259, label %if.end.262

if.then.259:                                      ; preds = %sw.epilog
  %236 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %237 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F260 = getelementptr inbounds %struct.scheme, %struct.scheme* %237, i32 0, i32 21
  %238 = load %struct.cell*, %struct.cell** %F260, align 8
  %call261 = call %struct.cell* @_s_return(%struct.scheme* %236, %struct.cell* %238)
  store %struct.cell* %call261, %struct.cell** %retval
  br label %return

if.end.262:                                       ; preds = %sw.epilog
  %239 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %240 = load %struct.cell*, %struct.cell** %p, align 8
  %call263 = call %struct.cell* @_s_return(%struct.scheme* %239, %struct.cell* %240)
  store %struct.cell* %call263, %struct.cell** %retval
  br label %return

sw.bb.264:                                        ; preds = %entry, %entry
  store i32 0, i32* %prop265, align 4
  %241 = load i32, i32* %op.addr, align 4
  switch i32 %241, label %sw.default.269 [
    i32 149, label %sw.bb.267
    i32 150, label %sw.bb.268
  ]

sw.bb.267:                                        ; preds = %sw.bb.264
  store i32 16, i32* %prop265, align 4
  br label %sw.epilog.270

sw.bb.268:                                        ; preds = %sw.bb.264
  store i32 48, i32* %prop265, align 4
  br label %sw.epilog.270

sw.default.269:                                   ; preds = %sw.bb.264
  br label %sw.epilog.270

sw.epilog.270:                                    ; preds = %sw.default.269, %sw.bb.268, %sw.bb.267
  %242 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %243 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args271 = getelementptr inbounds %struct.scheme, %struct.scheme* %243, i32 0, i32 7
  %244 = load %struct.cell*, %struct.cell** %args271, align 8
  %_object272 = getelementptr inbounds %struct.cell, %struct.cell* %244, i32 0, i32 1
  %_cons273 = bitcast %union.anon* %_object272 to %struct.anon.4*
  %_car274 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons273, i32 0, i32 0
  %245 = load %struct.cell*, %struct.cell** %_car274, align 8
  %_object275 = getelementptr inbounds %struct.cell, %struct.cell* %245, i32 0, i32 1
  %_string276 = bitcast %union.anon* %_object275 to %struct.anon*
  %_svalue277 = getelementptr inbounds %struct.anon, %struct.anon* %_string276, i32 0, i32 0
  %246 = load i8*, i8** %_svalue277, align 8
  %247 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args278 = getelementptr inbounds %struct.scheme, %struct.scheme* %247, i32 0, i32 7
  %248 = load %struct.cell*, %struct.cell** %args278, align 8
  %_object279 = getelementptr inbounds %struct.cell, %struct.cell* %248, i32 0, i32 1
  %_cons280 = bitcast %union.anon* %_object279 to %struct.anon.4*
  %_car281 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons280, i32 0, i32 0
  %249 = load %struct.cell*, %struct.cell** %_car281, align 8
  %_object282 = getelementptr inbounds %struct.cell, %struct.cell* %249, i32 0, i32 1
  %_string283 = bitcast %union.anon* %_object282 to %struct.anon*
  %_svalue284 = getelementptr inbounds %struct.anon, %struct.anon* %_string283, i32 0, i32 0
  %250 = load i8*, i8** %_svalue284, align 8
  %251 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args285 = getelementptr inbounds %struct.scheme, %struct.scheme* %251, i32 0, i32 7
  %252 = load %struct.cell*, %struct.cell** %args285, align 8
  %_object286 = getelementptr inbounds %struct.cell, %struct.cell* %252, i32 0, i32 1
  %_cons287 = bitcast %union.anon* %_object286 to %struct.anon.4*
  %_car288 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons287, i32 0, i32 0
  %253 = load %struct.cell*, %struct.cell** %_car288, align 8
  %_object289 = getelementptr inbounds %struct.cell, %struct.cell* %253, i32 0, i32 1
  %_string290 = bitcast %union.anon* %_object289 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string290, i32 0, i32 1
  %254 = load i32, i32* %_length, align 4
  %conv291 = sext i32 %254 to i64
  %call292 = call i8* @g_utf8_offset_to_pointer(i8* %250, i64 %conv291) #6
  %255 = load i32, i32* %prop265, align 4
  %call293 = call %struct.cell* @port_from_string(%struct.scheme* %242, i8* %246, i8* %call292, i32 %255)
  store %struct.cell* %call293, %struct.cell** %p266, align 8
  %256 = load %struct.cell*, %struct.cell** %p266, align 8
  %257 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL294 = getelementptr inbounds %struct.scheme, %struct.scheme* %257, i32 0, i32 17
  %258 = load %struct.cell*, %struct.cell** %NIL294, align 8
  %cmp295 = icmp eq %struct.cell* %256, %258
  br i1 %cmp295, label %if.then.297, label %if.end.300

if.then.297:                                      ; preds = %sw.epilog.270
  %259 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %260 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F298 = getelementptr inbounds %struct.scheme, %struct.scheme* %260, i32 0, i32 21
  %261 = load %struct.cell*, %struct.cell** %F298, align 8
  %call299 = call %struct.cell* @_s_return(%struct.scheme* %259, %struct.cell* %261)
  store %struct.cell* %call299, %struct.cell** %retval
  br label %return

if.end.300:                                       ; preds = %sw.epilog.270
  %262 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %263 = load %struct.cell*, %struct.cell** %p266, align 8
  %call301 = call %struct.cell* @_s_return(%struct.scheme* %262, %struct.cell* %263)
  store %struct.cell* %call301, %struct.cell** %retval
  br label %return

sw.bb.302:                                        ; preds = %entry
  %264 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args304 = getelementptr inbounds %struct.scheme, %struct.scheme* %264, i32 0, i32 7
  %265 = load %struct.cell*, %struct.cell** %args304, align 8
  %_object305 = getelementptr inbounds %struct.cell, %struct.cell* %265, i32 0, i32 1
  %_cons306 = bitcast %union.anon* %_object305 to %struct.anon.4*
  %_car307 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons306, i32 0, i32 0
  %266 = load %struct.cell*, %struct.cell** %_car307, align 8
  %267 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL308 = getelementptr inbounds %struct.scheme, %struct.scheme* %267, i32 0, i32 17
  %268 = load %struct.cell*, %struct.cell** %NIL308, align 8
  %cmp309 = icmp eq %struct.cell* %266, %268
  br i1 %cmp309, label %if.then.311, label %if.else.320

if.then.311:                                      ; preds = %sw.bb.302
  %269 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call312 = call %struct.cell* @port_from_scratch(%struct.scheme* %269)
  store %struct.cell* %call312, %struct.cell** %p303, align 8
  %270 = load %struct.cell*, %struct.cell** %p303, align 8
  %271 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL313 = getelementptr inbounds %struct.scheme, %struct.scheme* %271, i32 0, i32 17
  %272 = load %struct.cell*, %struct.cell** %NIL313, align 8
  %cmp314 = icmp eq %struct.cell* %270, %272
  br i1 %cmp314, label %if.then.316, label %if.end.319

if.then.316:                                      ; preds = %if.then.311
  %273 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %274 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F317 = getelementptr inbounds %struct.scheme, %struct.scheme* %274, i32 0, i32 21
  %275 = load %struct.cell*, %struct.cell** %F317, align 8
  %call318 = call %struct.cell* @_s_return(%struct.scheme* %273, %struct.cell* %275)
  store %struct.cell* %call318, %struct.cell** %retval
  br label %return

if.end.319:                                       ; preds = %if.then.311
  br label %if.end.350

if.else.320:                                      ; preds = %sw.bb.302
  %276 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %277 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args321 = getelementptr inbounds %struct.scheme, %struct.scheme* %277, i32 0, i32 7
  %278 = load %struct.cell*, %struct.cell** %args321, align 8
  %_object322 = getelementptr inbounds %struct.cell, %struct.cell* %278, i32 0, i32 1
  %_cons323 = bitcast %union.anon* %_object322 to %struct.anon.4*
  %_car324 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons323, i32 0, i32 0
  %279 = load %struct.cell*, %struct.cell** %_car324, align 8
  %_object325 = getelementptr inbounds %struct.cell, %struct.cell* %279, i32 0, i32 1
  %_string326 = bitcast %union.anon* %_object325 to %struct.anon*
  %_svalue327 = getelementptr inbounds %struct.anon, %struct.anon* %_string326, i32 0, i32 0
  %280 = load i8*, i8** %_svalue327, align 8
  %281 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args328 = getelementptr inbounds %struct.scheme, %struct.scheme* %281, i32 0, i32 7
  %282 = load %struct.cell*, %struct.cell** %args328, align 8
  %_object329 = getelementptr inbounds %struct.cell, %struct.cell* %282, i32 0, i32 1
  %_cons330 = bitcast %union.anon* %_object329 to %struct.anon.4*
  %_car331 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons330, i32 0, i32 0
  %283 = load %struct.cell*, %struct.cell** %_car331, align 8
  %_object332 = getelementptr inbounds %struct.cell, %struct.cell* %283, i32 0, i32 1
  %_string333 = bitcast %union.anon* %_object332 to %struct.anon*
  %_svalue334 = getelementptr inbounds %struct.anon, %struct.anon* %_string333, i32 0, i32 0
  %284 = load i8*, i8** %_svalue334, align 8
  %285 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args335 = getelementptr inbounds %struct.scheme, %struct.scheme* %285, i32 0, i32 7
  %286 = load %struct.cell*, %struct.cell** %args335, align 8
  %_object336 = getelementptr inbounds %struct.cell, %struct.cell* %286, i32 0, i32 1
  %_cons337 = bitcast %union.anon* %_object336 to %struct.anon.4*
  %_car338 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons337, i32 0, i32 0
  %287 = load %struct.cell*, %struct.cell** %_car338, align 8
  %_object339 = getelementptr inbounds %struct.cell, %struct.cell* %287, i32 0, i32 1
  %_string340 = bitcast %union.anon* %_object339 to %struct.anon*
  %_length341 = getelementptr inbounds %struct.anon, %struct.anon* %_string340, i32 0, i32 1
  %288 = load i32, i32* %_length341, align 4
  %idx.ext = sext i32 %288 to i64
  %add.ptr = getelementptr inbounds i8, i8* %284, i64 %idx.ext
  %call342 = call %struct.cell* @port_from_string(%struct.scheme* %276, i8* %280, i8* %add.ptr, i32 32)
  store %struct.cell* %call342, %struct.cell** %p303, align 8
  %289 = load %struct.cell*, %struct.cell** %p303, align 8
  %290 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL343 = getelementptr inbounds %struct.scheme, %struct.scheme* %290, i32 0, i32 17
  %291 = load %struct.cell*, %struct.cell** %NIL343, align 8
  %cmp344 = icmp eq %struct.cell* %289, %291
  br i1 %cmp344, label %if.then.346, label %if.end.349

if.then.346:                                      ; preds = %if.else.320
  %292 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %293 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F347 = getelementptr inbounds %struct.scheme, %struct.scheme* %293, i32 0, i32 21
  %294 = load %struct.cell*, %struct.cell** %F347, align 8
  %call348 = call %struct.cell* @_s_return(%struct.scheme* %292, %struct.cell* %294)
  store %struct.cell* %call348, %struct.cell** %retval
  br label %return

if.end.349:                                       ; preds = %if.else.320
  br label %if.end.350

if.end.350:                                       ; preds = %if.end.349, %if.end.319
  %295 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %296 = load %struct.cell*, %struct.cell** %p303, align 8
  %call351 = call %struct.cell* @_s_return(%struct.scheme* %295, %struct.cell* %296)
  store %struct.cell* %call351, %struct.cell** %retval
  br label %return

sw.bb.352:                                        ; preds = %entry
  %297 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args354 = getelementptr inbounds %struct.scheme, %struct.scheme* %297, i32 0, i32 7
  %298 = load %struct.cell*, %struct.cell** %args354, align 8
  %_object355 = getelementptr inbounds %struct.cell, %struct.cell* %298, i32 0, i32 1
  %_cons356 = bitcast %union.anon* %_object355 to %struct.anon.4*
  %_car357 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons356, i32 0, i32 0
  %299 = load %struct.cell*, %struct.cell** %_car357, align 8
  %_object358 = getelementptr inbounds %struct.cell, %struct.cell* %299, i32 0, i32 1
  %_port = bitcast %union.anon* %_object358 to %struct.port**
  %300 = load %struct.port*, %struct.port** %_port, align 8
  store %struct.port* %300, %struct.port** %p353, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %300, i32 0, i32 0
  %301 = load i8, i8* %kind, align 1
  %conv359 = zext i8 %301 to i32
  %and = and i32 %conv359, 2
  %tobool360 = icmp ne i32 %and, 0
  br i1 %tobool360, label %if.then.361, label %if.end.375

if.then.361:                                      ; preds = %sw.bb.352
  %302 = load %struct.port*, %struct.port** %p353, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %302, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 2
  %303 = load i8*, i8** %curr, align 8
  %304 = load %struct.port*, %struct.port** %p353, align 8
  %rep362 = getelementptr inbounds %struct.port, %struct.port* %304, i32 0, i32 1
  %string363 = bitcast %union.anon.1* %rep362 to %struct.anon.3*
  %start = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string363, i32 0, i32 0
  %305 = load i8*, i8** %start, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %303 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %305 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %add = add nsw i64 %sub.ptr.sub, 1
  store i64 %add, i64* %size, align 8
  %306 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %306, i32 0, i32 0
  %307 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %308 = load i64, i64* %size, align 8
  %call364 = call i8* %307(i64 %308)
  store i8* %call364, i8** %str, align 8
  %309 = load i8*, i8** %str, align 8
  %cmp365 = icmp ne i8* %309, null
  br i1 %cmp365, label %if.then.367, label %if.end.374

if.then.367:                                      ; preds = %if.then.361
  %310 = load i8*, i8** %str, align 8
  %311 = load %struct.port*, %struct.port** %p353, align 8
  %rep368 = getelementptr inbounds %struct.port, %struct.port* %311, i32 0, i32 1
  %string369 = bitcast %union.anon.1* %rep368 to %struct.anon.3*
  %start370 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string369, i32 0, i32 0
  %312 = load i8*, i8** %start370, align 8
  %313 = load i64, i64* %size, align 8
  %sub = sub nsw i64 %313, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %310, i8* %312, i64 %sub, i32 1, i1 false)
  %314 = load i64, i64* %size, align 8
  %sub371 = sub nsw i64 %314, 1
  %315 = load i8*, i8** %str, align 8
  %arrayidx = getelementptr inbounds i8, i8* %315, i64 %sub371
  store i8 0, i8* %arrayidx, align 1
  %316 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %317 = load i8*, i8** %str, align 8
  %call372 = call %struct.cell* @mk_string(%struct.scheme* %316, i8* %317)
  store %struct.cell* %call372, %struct.cell** %s, align 8
  %318 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %318, i32 0, i32 1
  %319 = load void (i8*)*, void (i8*)** %free, align 8
  %320 = load i8*, i8** %str, align 8
  call void %319(i8* %320)
  %321 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %322 = load %struct.cell*, %struct.cell** %s, align 8
  %call373 = call %struct.cell* @_s_return(%struct.scheme* %321, %struct.cell* %322)
  store %struct.cell* %call373, %struct.cell** %retval
  br label %return

if.end.374:                                       ; preds = %if.then.361
  br label %if.end.375

if.end.375:                                       ; preds = %if.end.374, %sw.bb.352
  %323 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %324 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F376 = getelementptr inbounds %struct.scheme, %struct.scheme* %324, i32 0, i32 21
  %325 = load %struct.cell*, %struct.cell** %F376, align 8
  %call377 = call %struct.cell* @_s_return(%struct.scheme* %323, %struct.cell* %325)
  store %struct.cell* %call377, %struct.cell** %retval
  br label %return

sw.bb.378:                                        ; preds = %entry
  %326 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %327 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args379 = getelementptr inbounds %struct.scheme, %struct.scheme* %327, i32 0, i32 7
  %328 = load %struct.cell*, %struct.cell** %args379, align 8
  %_object380 = getelementptr inbounds %struct.cell, %struct.cell* %328, i32 0, i32 1
  %_cons381 = bitcast %union.anon* %_object380 to %struct.anon.4*
  %_car382 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons381, i32 0, i32 0
  %329 = load %struct.cell*, %struct.cell** %_car382, align 8
  call void @port_close(%struct.scheme* %326, %struct.cell* %329, i32 16)
  %330 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %331 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T383 = getelementptr inbounds %struct.scheme, %struct.scheme* %331, i32 0, i32 19
  %332 = load %struct.cell*, %struct.cell** %T383, align 8
  %call384 = call %struct.cell* @_s_return(%struct.scheme* %330, %struct.cell* %332)
  store %struct.cell* %call384, %struct.cell** %retval
  br label %return

sw.bb.385:                                        ; preds = %entry
  %333 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %334 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args386 = getelementptr inbounds %struct.scheme, %struct.scheme* %334, i32 0, i32 7
  %335 = load %struct.cell*, %struct.cell** %args386, align 8
  %_object387 = getelementptr inbounds %struct.cell, %struct.cell* %335, i32 0, i32 1
  %_cons388 = bitcast %union.anon* %_object387 to %struct.anon.4*
  %_car389 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons388, i32 0, i32 0
  %336 = load %struct.cell*, %struct.cell** %_car389, align 8
  call void @port_close(%struct.scheme* %333, %struct.cell* %336, i32 32)
  %337 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %338 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T390 = getelementptr inbounds %struct.scheme, %struct.scheme* %338, i32 0, i32 19
  %339 = load %struct.cell*, %struct.cell** %T390, align 8
  %call391 = call %struct.cell* @_s_return(%struct.scheme* %337, %struct.cell* %339)
  store %struct.cell* %call391, %struct.cell** %retval
  br label %return

sw.bb.392:                                        ; preds = %entry
  %340 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %341 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %global_env = getelementptr inbounds %struct.scheme, %struct.scheme* %341, i32 0, i32 25
  %342 = load %struct.cell*, %struct.cell** %global_env, align 8
  %call393 = call %struct.cell* @_s_return(%struct.scheme* %340, %struct.cell* %342)
  store %struct.cell* %call393, %struct.cell** %retval
  br label %return

sw.bb.394:                                        ; preds = %entry
  %343 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %344 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %344, i32 0, i32 8
  %345 = load %struct.cell*, %struct.cell** %envir, align 8
  %call395 = call %struct.cell* @_s_return(%struct.scheme* %343, %struct.cell* %345)
  store %struct.cell* %call395, %struct.cell** %retval
  br label %return

sw.default.396:                                   ; preds = %entry
  %346 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %346, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %347 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op397 = getelementptr inbounds %struct.scheme, %struct.scheme* %347, i32 0, i32 55
  %348 = load i32, i32* %op397, align 4
  %call398 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %348) #2
  %349 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %350 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff399 = getelementptr inbounds %struct.scheme, %struct.scheme* %350, i32 0, i32 50
  %arraydecay400 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff399, i32 0, i32 0
  %call401 = call %struct.cell* @_Error_1(%struct.scheme* %349, i8* %arraydecay400, %struct.cell* null)
  store %struct.cell* %call401, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default.396, %sw.bb.394, %sw.bb.392, %sw.bb.385, %sw.bb.378, %if.end.375, %if.then.367, %if.end.350, %if.then.346, %if.then.316, %if.end.300, %if.then.297, %if.end.262, %if.then.259, %sw.bb.241, %sw.bb.239, %sw.bb.236, %if.end.226, %if.then.224, %cond.end, %sw.bb.194, %if.end.192, %while.end, %if.then.173, %if.then.157, %sw.bb.149, %sw.bb.142, %if.else.138, %do.body.134, %do.body.127, %do.body.107, %if.end.77, %do.body.51, %sw.bb.8, %if.else, %do.body
  %351 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %351
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_5(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %trans_str = alloca i8*, align 8
  %n = alloca i32, align 4
  %c = alloca i32, align 4
  %p = alloca %struct.cell*, align 8
  %res = alloca i32, align 4
  %f = alloca %struct.cell*, align 8
  %c281 = alloca i32, align 4
  %i = alloca i32, align 4
  %vec = alloca %struct.cell*, align 8
  %len = alloca i32, align 4
  %elem = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 46
  %1 = load i32, i32* %nesting, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting1 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 46
  %3 = load i32, i32* %nesting1, align 4
  store i32 %3, i32* %n, align 4
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting2 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 46
  store i32 0, i32* %nesting2, align 4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %retcode = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 2
  store i32 -1, i32* %retcode, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %8 = load i32, i32* %n, align 4
  %conv = sext i32 %8 to i64
  %call = call %struct.cell* @mk_integer(%struct.scheme* %7, i64 %conv)
  %call3 = call %struct.cell* @_Error_1(%struct.scheme* %6, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.257, i32 0, i32 0), %struct.cell* %call)
  store %struct.cell* %call3, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i32, i32* %op.addr, align 4
  switch i32 %9, label %sw.default.675 [
    i32 157, label %sw.bb
    i32 158, label %sw.bb.42
    i32 159, label %sw.bb.42
    i32 160, label %sw.bb.79
    i32 161, label %sw.bb.95
    i32 162, label %sw.bb.102
    i32 163, label %sw.bb.109
    i32 164, label %sw.bb.263
    i32 165, label %sw.bb.323
    i32 166, label %sw.bb.339
    i32 167, label %sw.bb.345
    i32 168, label %sw.bb.351
    i32 169, label %sw.bb.364
    i32 170, label %sw.bb.370
    i32 171, label %sw.bb.376
    i32 172, label %sw.bb.383
    i32 173, label %sw.bb.587
    i32 174, label %sw.bb.630
  ]

sw.bb:                                            ; preds = %if.end
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 7
  %11 = load %struct.cell*, %struct.cell** %args, align 8
  %call4 = call i32 @is_pair(%struct.cell* %11)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.end.7, label %if.then.5

if.then.5:                                        ; preds = %sw.bb
  br label %do.body

do.body:                                          ; preds = %if.then.5
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op6 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 55
  store i32 3, i32* %op6, align 4
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 19
  %14 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %14, %struct.cell** %retval
  br label %return

do.end:                                           ; No predecessors!
  br label %if.end.7

if.end.7:                                         ; preds = %do.end, %sw.bb
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args8 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 7
  %16 = load %struct.cell*, %struct.cell** %args8, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %16, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %17 = load %struct.cell*, %struct.cell** %_car, align 8
  %call9 = call i32 @is_inport(%struct.cell* %17)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.end.17, label %if.then.11

if.then.11:                                       ; preds = %if.end.7
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args12 = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 7
  %20 = load %struct.cell*, %struct.cell** %args12, align 8
  %_object13 = getelementptr inbounds %struct.cell, %struct.cell* %20, i32 0, i32 1
  %_cons14 = bitcast %union.anon* %_object13 to %struct.anon.4*
  %_car15 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons14, i32 0, i32 0
  %21 = load %struct.cell*, %struct.cell** %_car15, align 8
  %call16 = call %struct.cell* @_Error_1(%struct.scheme* %18, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.258, i32 0, i32 0), %struct.cell* %21)
  store %struct.cell* %call16, %struct.cell** %retval
  br label %return

if.end.17:                                        ; preds = %if.end.7
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args18 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 7
  %23 = load %struct.cell*, %struct.cell** %args18, align 8
  %_object19 = getelementptr inbounds %struct.cell, %struct.cell* %23, i32 0, i32 1
  %_cons20 = bitcast %union.anon* %_object19 to %struct.anon.4*
  %_car21 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons20, i32 0, i32 0
  %24 = load %struct.cell*, %struct.cell** %_car21, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 39
  %26 = load %struct.cell*, %struct.cell** %inport, align 8
  %cmp22 = icmp eq %struct.cell* %24, %26
  br i1 %cmp22, label %if.then.24, label %if.end.29

if.then.24:                                       ; preds = %if.end.17
  br label %do.body.25

do.body.25:                                       ; preds = %if.then.24
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op26 = getelementptr inbounds %struct.scheme, %struct.scheme* %27, i32 0, i32 55
  store i32 3, i32* %op26, align 4
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T27 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 19
  %29 = load %struct.cell*, %struct.cell** %T27, align 8
  store %struct.cell* %29, %struct.cell** %retval
  br label %return

do.end.28:                                        ; No predecessors!
  br label %if.end.29

if.end.29:                                        ; preds = %do.end.28, %if.end.17
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport30 = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 39
  %31 = load %struct.cell*, %struct.cell** %inport30, align 8
  store %struct.cell* %31, %struct.cell** %x, align 8
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args31 = getelementptr inbounds %struct.scheme, %struct.scheme* %32, i32 0, i32 7
  %33 = load %struct.cell*, %struct.cell** %args31, align 8
  %_object32 = getelementptr inbounds %struct.cell, %struct.cell* %33, i32 0, i32 1
  %_cons33 = bitcast %union.anon* %_object32 to %struct.anon.4*
  %_car34 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons33, i32 0, i32 0
  %34 = load %struct.cell*, %struct.cell** %_car34, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport35 = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 39
  store %struct.cell* %34, %struct.cell** %inport35, align 8
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %37 = load %struct.cell*, %struct.cell** %x, align 8
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 17
  %39 = load %struct.cell*, %struct.cell** %NIL, align 8
  %call36 = call %struct.cell* @_cons(%struct.scheme* %36, %struct.cell* %37, %struct.cell* %39, i32 0)
  store %struct.cell* %call36, %struct.cell** %x, align 8
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %41 = load %struct.cell*, %struct.cell** %x, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL37 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 17
  %43 = load %struct.cell*, %struct.cell** %NIL37, align 8
  call void @s_save(%struct.scheme* %40, i32 161, %struct.cell* %41, %struct.cell* %43)
  br label %do.body.38

do.body.38:                                       ; preds = %if.end.29
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op39 = getelementptr inbounds %struct.scheme, %struct.scheme* %44, i32 0, i32 55
  store i32 3, i32* %op39, align 4
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T40 = getelementptr inbounds %struct.scheme, %struct.scheme* %45, i32 0, i32 19
  %46 = load %struct.cell*, %struct.cell** %T40, align 8
  store %struct.cell* %46, %struct.cell** %retval
  br label %return

do.end.41:                                        ; No predecessors!
  br label %sw.bb.42

sw.bb.42:                                         ; preds = %if.end, %if.end, %do.end.41
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args43 = getelementptr inbounds %struct.scheme, %struct.scheme* %47, i32 0, i32 7
  %48 = load %struct.cell*, %struct.cell** %args43, align 8
  %call44 = call i32 @is_pair(%struct.cell* %48)
  %tobool45 = icmp ne i32 %call44, 0
  br i1 %tobool45, label %if.then.46, label %if.end.65

if.then.46:                                       ; preds = %sw.bb.42
  %49 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args47 = getelementptr inbounds %struct.scheme, %struct.scheme* %49, i32 0, i32 7
  %50 = load %struct.cell*, %struct.cell** %args47, align 8
  %_object48 = getelementptr inbounds %struct.cell, %struct.cell* %50, i32 0, i32 1
  %_cons49 = bitcast %union.anon* %_object48 to %struct.anon.4*
  %_car50 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons49, i32 0, i32 0
  %51 = load %struct.cell*, %struct.cell** %_car50, align 8
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport51 = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 39
  %53 = load %struct.cell*, %struct.cell** %inport51, align 8
  %cmp52 = icmp ne %struct.cell* %51, %53
  br i1 %cmp52, label %if.then.54, label %if.end.64

if.then.54:                                       ; preds = %if.then.46
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport55 = getelementptr inbounds %struct.scheme, %struct.scheme* %54, i32 0, i32 39
  %55 = load %struct.cell*, %struct.cell** %inport55, align 8
  store %struct.cell* %55, %struct.cell** %x, align 8
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %57 = load %struct.cell*, %struct.cell** %x, align 8
  %58 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL56 = getelementptr inbounds %struct.scheme, %struct.scheme* %58, i32 0, i32 17
  %59 = load %struct.cell*, %struct.cell** %NIL56, align 8
  %call57 = call %struct.cell* @_cons(%struct.scheme* %56, %struct.cell* %57, %struct.cell* %59, i32 0)
  store %struct.cell* %call57, %struct.cell** %x, align 8
  %60 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %61 = load %struct.cell*, %struct.cell** %x, align 8
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL58 = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 17
  %63 = load %struct.cell*, %struct.cell** %NIL58, align 8
  call void @s_save(%struct.scheme* %60, i32 161, %struct.cell* %61, %struct.cell* %63)
  %64 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args59 = getelementptr inbounds %struct.scheme, %struct.scheme* %64, i32 0, i32 7
  %65 = load %struct.cell*, %struct.cell** %args59, align 8
  %_object60 = getelementptr inbounds %struct.cell, %struct.cell* %65, i32 0, i32 1
  %_cons61 = bitcast %union.anon* %_object60 to %struct.anon.4*
  %_car62 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons61, i32 0, i32 0
  %66 = load %struct.cell*, %struct.cell** %_car62, align 8
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport63 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 39
  store %struct.cell* %66, %struct.cell** %inport63, align 8
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.54, %if.then.46
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %sw.bb.42
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call66 = call i32 @inchar(%struct.scheme* %68)
  store i32 %call66, i32* %c, align 4
  %69 = load i32, i32* %c, align 4
  %cmp67 = icmp eq i32 %69, -1
  br i1 %cmp67, label %if.then.69, label %if.end.71

if.then.69:                                       ; preds = %if.end.65
  %70 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 23
  %72 = load %struct.cell*, %struct.cell** %EOF_OBJ, align 8
  %call70 = call %struct.cell* @_s_return(%struct.scheme* %70, %struct.cell* %72)
  store %struct.cell* %call70, %struct.cell** %retval
  br label %return

if.end.71:                                        ; preds = %if.end.65
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op72 = getelementptr inbounds %struct.scheme, %struct.scheme* %73, i32 0, i32 55
  %74 = load i32, i32* %op72, align 4
  %cmp73 = icmp eq i32 %74, 159
  br i1 %cmp73, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %if.end.71
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %76 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %75, i32 %76)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %if.end.71
  %77 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %78 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %79 = load i32, i32* %c, align 4
  %call77 = call %struct.cell* @mk_character(%struct.scheme* %78, i32 %79)
  %call78 = call %struct.cell* @_s_return(%struct.scheme* %77, %struct.cell* %call77)
  store %struct.cell* %call78, %struct.cell** %retval
  br label %return

sw.bb.79:                                         ; preds = %if.end
  %80 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport80 = getelementptr inbounds %struct.scheme, %struct.scheme* %80, i32 0, i32 39
  %81 = load %struct.cell*, %struct.cell** %inport80, align 8
  store %struct.cell* %81, %struct.cell** %p, align 8
  %82 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args81 = getelementptr inbounds %struct.scheme, %struct.scheme* %82, i32 0, i32 7
  %83 = load %struct.cell*, %struct.cell** %args81, align 8
  %call82 = call i32 @is_pair(%struct.cell* %83)
  %tobool83 = icmp ne i32 %call82, 0
  br i1 %tobool83, label %if.then.84, label %if.end.89

if.then.84:                                       ; preds = %sw.bb.79
  %84 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args85 = getelementptr inbounds %struct.scheme, %struct.scheme* %84, i32 0, i32 7
  %85 = load %struct.cell*, %struct.cell** %args85, align 8
  %_object86 = getelementptr inbounds %struct.cell, %struct.cell* %85, i32 0, i32 1
  %_cons87 = bitcast %union.anon* %_object86 to %struct.anon.4*
  %_car88 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons87, i32 0, i32 0
  %86 = load %struct.cell*, %struct.cell** %_car88, align 8
  store %struct.cell* %86, %struct.cell** %p, align 8
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.84, %sw.bb.79
  %87 = load %struct.cell*, %struct.cell** %p, align 8
  %_object90 = getelementptr inbounds %struct.cell, %struct.cell* %87, i32 0, i32 1
  %_port = bitcast %union.anon* %_object90 to %struct.port**
  %88 = load %struct.port*, %struct.port** %_port, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %88, i32 0, i32 0
  %89 = load i8, i8* %kind, align 1
  %conv91 = zext i8 %89 to i32
  %and = and i32 %conv91, 2
  store i32 %and, i32* %res, align 4
  %90 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %91 = load i32, i32* %res, align 4
  %tobool92 = icmp ne i32 %91, 0
  br i1 %tobool92, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.89
  %92 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T93 = getelementptr inbounds %struct.scheme, %struct.scheme* %92, i32 0, i32 19
  %93 = load %struct.cell*, %struct.cell** %T93, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.89
  %94 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %94, i32 0, i32 21
  %95 = load %struct.cell*, %struct.cell** %F, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.cell* [ %93, %cond.true ], [ %95, %cond.false ]
  %call94 = call %struct.cell* @_s_return(%struct.scheme* %90, %struct.cell* %cond)
  store %struct.cell* %call94, %struct.cell** %retval
  br label %return

sw.bb.95:                                         ; preds = %if.end
  %96 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args96 = getelementptr inbounds %struct.scheme, %struct.scheme* %96, i32 0, i32 7
  %97 = load %struct.cell*, %struct.cell** %args96, align 8
  %_object97 = getelementptr inbounds %struct.cell, %struct.cell* %97, i32 0, i32 1
  %_cons98 = bitcast %union.anon* %_object97 to %struct.anon.4*
  %_car99 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons98, i32 0, i32 0
  %98 = load %struct.cell*, %struct.cell** %_car99, align 8
  %99 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport100 = getelementptr inbounds %struct.scheme, %struct.scheme* %99, i32 0, i32 39
  store %struct.cell* %98, %struct.cell** %inport100, align 8
  %100 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %101 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %101, i32 0, i32 54
  %102 = load %struct.cell*, %struct.cell** %value, align 8
  %call101 = call %struct.cell* @_s_return(%struct.scheme* %100, %struct.cell* %102)
  store %struct.cell* %call101, %struct.cell** %retval
  br label %return

sw.bb.102:                                        ; preds = %if.end
  %103 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args103 = getelementptr inbounds %struct.scheme, %struct.scheme* %103, i32 0, i32 7
  %104 = load %struct.cell*, %struct.cell** %args103, align 8
  %_object104 = getelementptr inbounds %struct.cell, %struct.cell* %104, i32 0, i32 1
  %_cons105 = bitcast %union.anon* %_object104 to %struct.anon.4*
  %_car106 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons105, i32 0, i32 0
  %105 = load %struct.cell*, %struct.cell** %_car106, align 8
  %106 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %outport = getelementptr inbounds %struct.scheme, %struct.scheme* %106, i32 0, i32 40
  store %struct.cell* %105, %struct.cell** %outport, align 8
  %107 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %108 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value107 = getelementptr inbounds %struct.scheme, %struct.scheme* %108, i32 0, i32 54
  %109 = load %struct.cell*, %struct.cell** %value107, align 8
  %call108 = call %struct.cell* @_s_return(%struct.scheme* %107, %struct.cell* %109)
  store %struct.cell* %call108, %struct.cell** %retval
  br label %return

sw.bb.109:                                        ; preds = %if.end
  %110 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok = getelementptr inbounds %struct.scheme, %struct.scheme* %110, i32 0, i32 52
  %111 = load i32, i32* %tok, align 4
  switch i32 %111, label %sw.default [
    i32 -1, label %sw.bb.110
    i32 12, label %sw.bb.113
    i32 0, label %sw.bb.116
    i32 4, label %sw.bb.139
    i32 7, label %sw.bb.148
    i32 8, label %sw.bb.170
    i32 9, label %sw.bb.179
    i32 3, label %sw.bb.188
    i32 6, label %sw.bb.192
    i32 13, label %sw.bb.201
    i32 10, label %sw.bb.233
    i32 11, label %sw.bb.249
  ]

sw.bb.110:                                        ; preds = %sw.bb.109
  %112 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %113 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ111 = getelementptr inbounds %struct.scheme, %struct.scheme* %113, i32 0, i32 23
  %114 = load %struct.cell*, %struct.cell** %EOF_OBJ111, align 8
  %call112 = call %struct.cell* @_s_return(%struct.scheme* %112, %struct.cell* %114)
  store %struct.cell* %call112, %struct.cell** %retval
  br label %return

sw.bb.113:                                        ; preds = %sw.bb.109
  %115 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %116 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL114 = getelementptr inbounds %struct.scheme, %struct.scheme* %116, i32 0, i32 17
  %117 = load %struct.cell*, %struct.cell** %NIL114, align 8
  %118 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL115 = getelementptr inbounds %struct.scheme, %struct.scheme* %118, i32 0, i32 17
  %119 = load %struct.cell*, %struct.cell** %NIL115, align 8
  call void @s_save(%struct.scheme* %115, i32 171, %struct.cell* %117, %struct.cell* %119)
  br label %sw.bb.116

sw.bb.116:                                        ; preds = %sw.bb.109, %sw.bb.113
  %120 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call117 = call i32 @token(%struct.scheme* %120)
  %121 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok118 = getelementptr inbounds %struct.scheme, %struct.scheme* %121, i32 0, i32 52
  store i32 %call117, i32* %tok118, align 4
  %122 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok119 = getelementptr inbounds %struct.scheme, %struct.scheme* %122, i32 0, i32 52
  %123 = load i32, i32* %tok119, align 4
  %cmp120 = icmp eq i32 %123, 1
  br i1 %cmp120, label %if.then.122, label %if.else

if.then.122:                                      ; preds = %sw.bb.116
  %124 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %125 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL123 = getelementptr inbounds %struct.scheme, %struct.scheme* %125, i32 0, i32 17
  %126 = load %struct.cell*, %struct.cell** %NIL123, align 8
  %call124 = call %struct.cell* @_s_return(%struct.scheme* %124, %struct.cell* %126)
  store %struct.cell* %call124, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %sw.bb.116
  %127 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok125 = getelementptr inbounds %struct.scheme, %struct.scheme* %127, i32 0, i32 52
  %128 = load i32, i32* %tok125, align 4
  %cmp126 = icmp eq i32 %128, 2
  br i1 %cmp126, label %if.then.128, label %if.else.130

if.then.128:                                      ; preds = %if.else
  %129 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call129 = call %struct.cell* @_Error_1(%struct.scheme* %129, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.259, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call129, %struct.cell** %retval
  br label %return

if.else.130:                                      ; preds = %if.else
  %130 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %130, i32 0, i32 45
  %131 = load i32, i32* %file_i, align 4
  %idxprom = sext i32 %131 to i64
  %132 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %132, i32 0, i32 44
  %arrayidx = getelementptr inbounds [64 x i32], [64 x i32]* %nesting_stack, i32 0, i64 %idxprom
  %133 = load i32, i32* %arrayidx, align 4
  %inc = add nsw i32 %133, 1
  store i32 %inc, i32* %arrayidx, align 4
  %134 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %135 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL131 = getelementptr inbounds %struct.scheme, %struct.scheme* %135, i32 0, i32 17
  %136 = load %struct.cell*, %struct.cell** %NIL131, align 8
  %137 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL132 = getelementptr inbounds %struct.scheme, %struct.scheme* %137, i32 0, i32 17
  %138 = load %struct.cell*, %struct.cell** %NIL132, align 8
  call void @s_save(%struct.scheme* %134, i32 164, %struct.cell* %136, %struct.cell* %138)
  br label %do.body.133

do.body.133:                                      ; preds = %if.else.130
  %139 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op134 = getelementptr inbounds %struct.scheme, %struct.scheme* %139, i32 0, i32 55
  store i32 163, i32* %op134, align 4
  %140 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T135 = getelementptr inbounds %struct.scheme, %struct.scheme* %140, i32 0, i32 19
  %141 = load %struct.cell*, %struct.cell** %T135, align 8
  store %struct.cell* %141, %struct.cell** %retval
  br label %return

do.end.136:                                       ; No predecessors!
  br label %if.end.137

if.end.137:                                       ; preds = %do.end.136
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137
  br label %sw.bb.139

sw.bb.139:                                        ; preds = %sw.bb.109, %if.end.138
  %142 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %143 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL140 = getelementptr inbounds %struct.scheme, %struct.scheme* %143, i32 0, i32 17
  %144 = load %struct.cell*, %struct.cell** %NIL140, align 8
  %145 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL141 = getelementptr inbounds %struct.scheme, %struct.scheme* %145, i32 0, i32 17
  %146 = load %struct.cell*, %struct.cell** %NIL141, align 8
  call void @s_save(%struct.scheme* %142, i32 166, %struct.cell* %144, %struct.cell* %146)
  %147 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call142 = call i32 @token(%struct.scheme* %147)
  %148 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok143 = getelementptr inbounds %struct.scheme, %struct.scheme* %148, i32 0, i32 52
  store i32 %call142, i32* %tok143, align 4
  br label %do.body.144

do.body.144:                                      ; preds = %sw.bb.139
  %149 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op145 = getelementptr inbounds %struct.scheme, %struct.scheme* %149, i32 0, i32 55
  store i32 163, i32* %op145, align 4
  %150 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T146 = getelementptr inbounds %struct.scheme, %struct.scheme* %150, i32 0, i32 19
  %151 = load %struct.cell*, %struct.cell** %T146, align 8
  store %struct.cell* %151, %struct.cell** %retval
  br label %return

do.end.147:                                       ; No predecessors!
  br label %sw.bb.148

sw.bb.148:                                        ; preds = %sw.bb.109, %do.end.147
  %152 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call149 = call i32 @token(%struct.scheme* %152)
  %153 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok150 = getelementptr inbounds %struct.scheme, %struct.scheme* %153, i32 0, i32 52
  store i32 %call149, i32* %tok150, align 4
  %154 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok151 = getelementptr inbounds %struct.scheme, %struct.scheme* %154, i32 0, i32 52
  %155 = load i32, i32* %tok151, align 4
  %cmp152 = icmp eq i32 %155, 12
  br i1 %cmp152, label %if.then.154, label %if.else.162

if.then.154:                                      ; preds = %sw.bb.148
  %156 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %157 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL155 = getelementptr inbounds %struct.scheme, %struct.scheme* %157, i32 0, i32 17
  %158 = load %struct.cell*, %struct.cell** %NIL155, align 8
  %159 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL156 = getelementptr inbounds %struct.scheme, %struct.scheme* %159, i32 0, i32 17
  %160 = load %struct.cell*, %struct.cell** %NIL156, align 8
  call void @s_save(%struct.scheme* %156, i32 168, %struct.cell* %158, %struct.cell* %160)
  %161 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok157 = getelementptr inbounds %struct.scheme, %struct.scheme* %161, i32 0, i32 52
  store i32 0, i32* %tok157, align 4
  br label %do.body.158

do.body.158:                                      ; preds = %if.then.154
  %162 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op159 = getelementptr inbounds %struct.scheme, %struct.scheme* %162, i32 0, i32 55
  store i32 163, i32* %op159, align 4
  %163 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T160 = getelementptr inbounds %struct.scheme, %struct.scheme* %163, i32 0, i32 19
  %164 = load %struct.cell*, %struct.cell** %T160, align 8
  store %struct.cell* %164, %struct.cell** %retval
  br label %return

do.end.161:                                       ; No predecessors!
  br label %if.end.165

if.else.162:                                      ; preds = %sw.bb.148
  %165 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %166 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL163 = getelementptr inbounds %struct.scheme, %struct.scheme* %166, i32 0, i32 17
  %167 = load %struct.cell*, %struct.cell** %NIL163, align 8
  %168 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL164 = getelementptr inbounds %struct.scheme, %struct.scheme* %168, i32 0, i32 17
  %169 = load %struct.cell*, %struct.cell** %NIL164, align 8
  call void @s_save(%struct.scheme* %165, i32 167, %struct.cell* %167, %struct.cell* %169)
  br label %if.end.165

if.end.165:                                       ; preds = %if.else.162, %do.end.161
  br label %do.body.166

do.body.166:                                      ; preds = %if.end.165
  %170 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op167 = getelementptr inbounds %struct.scheme, %struct.scheme* %170, i32 0, i32 55
  store i32 163, i32* %op167, align 4
  %171 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T168 = getelementptr inbounds %struct.scheme, %struct.scheme* %171, i32 0, i32 19
  %172 = load %struct.cell*, %struct.cell** %T168, align 8
  store %struct.cell* %172, %struct.cell** %retval
  br label %return

do.end.169:                                       ; No predecessors!
  br label %sw.bb.170

sw.bb.170:                                        ; preds = %sw.bb.109, %do.end.169
  %173 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %174 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL171 = getelementptr inbounds %struct.scheme, %struct.scheme* %174, i32 0, i32 17
  %175 = load %struct.cell*, %struct.cell** %NIL171, align 8
  %176 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL172 = getelementptr inbounds %struct.scheme, %struct.scheme* %176, i32 0, i32 17
  %177 = load %struct.cell*, %struct.cell** %NIL172, align 8
  call void @s_save(%struct.scheme* %173, i32 169, %struct.cell* %175, %struct.cell* %177)
  %178 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call173 = call i32 @token(%struct.scheme* %178)
  %179 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok174 = getelementptr inbounds %struct.scheme, %struct.scheme* %179, i32 0, i32 52
  store i32 %call173, i32* %tok174, align 4
  br label %do.body.175

do.body.175:                                      ; preds = %sw.bb.170
  %180 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op176 = getelementptr inbounds %struct.scheme, %struct.scheme* %180, i32 0, i32 55
  store i32 163, i32* %op176, align 4
  %181 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T177 = getelementptr inbounds %struct.scheme, %struct.scheme* %181, i32 0, i32 19
  %182 = load %struct.cell*, %struct.cell** %T177, align 8
  store %struct.cell* %182, %struct.cell** %retval
  br label %return

do.end.178:                                       ; No predecessors!
  br label %sw.bb.179

sw.bb.179:                                        ; preds = %sw.bb.109, %do.end.178
  %183 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %184 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL180 = getelementptr inbounds %struct.scheme, %struct.scheme* %184, i32 0, i32 17
  %185 = load %struct.cell*, %struct.cell** %NIL180, align 8
  %186 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL181 = getelementptr inbounds %struct.scheme, %struct.scheme* %186, i32 0, i32 17
  %187 = load %struct.cell*, %struct.cell** %NIL181, align 8
  call void @s_save(%struct.scheme* %183, i32 170, %struct.cell* %185, %struct.cell* %187)
  %188 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call182 = call i32 @token(%struct.scheme* %188)
  %189 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok183 = getelementptr inbounds %struct.scheme, %struct.scheme* %189, i32 0, i32 52
  store i32 %call182, i32* %tok183, align 4
  br label %do.body.184

do.body.184:                                      ; preds = %sw.bb.179
  %190 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op185 = getelementptr inbounds %struct.scheme, %struct.scheme* %190, i32 0, i32 55
  store i32 163, i32* %op185, align 4
  %191 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T186 = getelementptr inbounds %struct.scheme, %struct.scheme* %191, i32 0, i32 19
  %192 = load %struct.cell*, %struct.cell** %T186, align 8
  store %struct.cell* %192, %struct.cell** %retval
  br label %return

do.end.187:                                       ; No predecessors!
  br label %sw.bb.188

sw.bb.188:                                        ; preds = %sw.bb.109, %do.end.187
  %193 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %194 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %195 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call189 = call i8* @readstr_upto(%struct.scheme* %195, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.260, i32 0, i32 0))
  %call190 = call %struct.cell* @mk_atom(%struct.scheme* %194, i8* %call189)
  %call191 = call %struct.cell* @_s_return(%struct.scheme* %193, %struct.cell* %call190)
  store %struct.cell* %call191, %struct.cell** %retval
  br label %return

sw.bb.192:                                        ; preds = %sw.bb.109
  %196 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call193 = call %struct.cell* @readstrexp(%struct.scheme* %196)
  store %struct.cell* %call193, %struct.cell** %x, align 8
  %197 = load %struct.cell*, %struct.cell** %x, align 8
  %198 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F194 = getelementptr inbounds %struct.scheme, %struct.scheme* %198, i32 0, i32 21
  %199 = load %struct.cell*, %struct.cell** %F194, align 8
  %cmp195 = icmp eq %struct.cell* %197, %199
  br i1 %cmp195, label %if.then.197, label %if.end.199

if.then.197:                                      ; preds = %sw.bb.192
  %200 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call198 = call %struct.cell* @_Error_1(%struct.scheme* %200, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.261, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call198, %struct.cell** %retval
  br label %return

if.end.199:                                       ; preds = %sw.bb.192
  %201 = load %struct.cell*, %struct.cell** %x, align 8
  call void @setimmutable(%struct.cell* %201)
  %202 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %203 = load %struct.cell*, %struct.cell** %x, align 8
  %call200 = call %struct.cell* @_s_return(%struct.scheme* %202, %struct.cell* %203)
  store %struct.cell* %call200, %struct.cell** %retval
  br label %return

sw.bb.201:                                        ; preds = %sw.bb.109
  %204 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call202 = call %struct.cell* @readstrexp(%struct.scheme* %204)
  store %struct.cell* %call202, %struct.cell** %x, align 8
  %205 = load %struct.cell*, %struct.cell** %x, align 8
  %206 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F203 = getelementptr inbounds %struct.scheme, %struct.scheme* %206, i32 0, i32 21
  %207 = load %struct.cell*, %struct.cell** %F203, align 8
  %cmp204 = icmp eq %struct.cell* %205, %207
  br i1 %cmp204, label %if.then.206, label %if.end.208

if.then.206:                                      ; preds = %sw.bb.201
  %208 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call207 = call %struct.cell* @_Error_1(%struct.scheme* %208, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.261, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call207, %struct.cell** %retval
  br label %return

if.end.208:                                       ; preds = %sw.bb.201
  %209 = load %struct.cell*, %struct.cell** %x, align 8
  %_object209 = getelementptr inbounds %struct.cell, %struct.cell* %209, i32 0, i32 1
  %_string = bitcast %union.anon* %_object209 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %210 = load i8*, i8** %_svalue, align 8
  %call210 = call i8* @gettext(i8* %210) #2
  store i8* %call210, i8** %trans_str, align 8
  %211 = load i8*, i8** %trans_str, align 8
  %212 = load %struct.cell*, %struct.cell** %x, align 8
  %_object211 = getelementptr inbounds %struct.cell, %struct.cell* %212, i32 0, i32 1
  %_string212 = bitcast %union.anon* %_object211 to %struct.anon*
  %_svalue213 = getelementptr inbounds %struct.anon, %struct.anon* %_string212, i32 0, i32 0
  %213 = load i8*, i8** %_svalue213, align 8
  %cmp214 = icmp ne i8* %211, %213
  br i1 %cmp214, label %if.then.216, label %if.end.231

if.then.216:                                      ; preds = %if.end.208
  %214 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %214, i32 0, i32 1
  %215 = load void (i8*)*, void (i8*)** %free, align 8
  %216 = load %struct.cell*, %struct.cell** %x, align 8
  %_object217 = getelementptr inbounds %struct.cell, %struct.cell* %216, i32 0, i32 1
  %_string218 = bitcast %union.anon* %_object217 to %struct.anon*
  %_svalue219 = getelementptr inbounds %struct.anon, %struct.anon* %_string218, i32 0, i32 0
  %217 = load i8*, i8** %_svalue219, align 8
  call void %215(i8* %217)
  %218 = load i8*, i8** %trans_str, align 8
  %call220 = call i64 @g_utf8_strlen(i8* %218, i64 -1) #6
  %conv221 = trunc i64 %call220 to i32
  %219 = load %struct.cell*, %struct.cell** %x, align 8
  %_object222 = getelementptr inbounds %struct.cell, %struct.cell* %219, i32 0, i32 1
  %_string223 = bitcast %union.anon* %_object222 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string223, i32 0, i32 1
  store i32 %conv221, i32* %_length, align 4
  %220 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %221 = load %struct.cell*, %struct.cell** %x, align 8
  %_object224 = getelementptr inbounds %struct.cell, %struct.cell* %221, i32 0, i32 1
  %_string225 = bitcast %union.anon* %_object224 to %struct.anon*
  %_length226 = getelementptr inbounds %struct.anon, %struct.anon* %_string225, i32 0, i32 1
  %222 = load i32, i32* %_length226, align 4
  %223 = load i8*, i8** %trans_str, align 8
  %call227 = call i8* @store_string(%struct.scheme* %220, i32 %222, i8* %223, i32 0)
  %224 = load %struct.cell*, %struct.cell** %x, align 8
  %_object228 = getelementptr inbounds %struct.cell, %struct.cell* %224, i32 0, i32 1
  %_string229 = bitcast %union.anon* %_object228 to %struct.anon*
  %_svalue230 = getelementptr inbounds %struct.anon, %struct.anon* %_string229, i32 0, i32 0
  store i8* %call227, i8** %_svalue230, align 8
  br label %if.end.231

if.end.231:                                       ; preds = %if.then.216, %if.end.208
  %225 = load %struct.cell*, %struct.cell** %x, align 8
  call void @setimmutable(%struct.cell* %225)
  %226 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %227 = load %struct.cell*, %struct.cell** %x, align 8
  %call232 = call %struct.cell* @_s_return(%struct.scheme* %226, %struct.cell* %227)
  store %struct.cell* %call232, %struct.cell** %retval
  br label %return

sw.bb.233:                                        ; preds = %sw.bb.109
  %228 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %229 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %229, i32 0, i32 8
  %230 = load %struct.cell*, %struct.cell** %envir, align 8
  %231 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %SHARP_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %231, i32 0, i32 35
  %232 = load %struct.cell*, %struct.cell** %SHARP_HOOK, align 8
  %call234 = call %struct.cell* @find_slot_in_env(%struct.scheme* %228, %struct.cell* %230, %struct.cell* %232, i32 1)
  store %struct.cell* %call234, %struct.cell** %f, align 8
  %233 = load %struct.cell*, %struct.cell** %f, align 8
  %234 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL235 = getelementptr inbounds %struct.scheme, %struct.scheme* %234, i32 0, i32 17
  %235 = load %struct.cell*, %struct.cell** %NIL235, align 8
  %cmp236 = icmp eq %struct.cell* %233, %235
  br i1 %cmp236, label %if.then.238, label %if.else.240

if.then.238:                                      ; preds = %sw.bb.233
  %236 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call239 = call %struct.cell* @_Error_1(%struct.scheme* %236, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.262, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call239, %struct.cell** %retval
  br label %return

if.else.240:                                      ; preds = %sw.bb.233
  %237 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %238 = load %struct.cell*, %struct.cell** %f, align 8
  %call241 = call %struct.cell* @slot_value_in_env(%struct.cell* %238)
  %239 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL242 = getelementptr inbounds %struct.scheme, %struct.scheme* %239, i32 0, i32 17
  %240 = load %struct.cell*, %struct.cell** %NIL242, align 8
  %call243 = call %struct.cell* @_cons(%struct.scheme* %237, %struct.cell* %call241, %struct.cell* %240, i32 0)
  %241 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %241, i32 0, i32 9
  store %struct.cell* %call243, %struct.cell** %code, align 8
  br label %do.body.244

do.body.244:                                      ; preds = %if.else.240
  %242 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op245 = getelementptr inbounds %struct.scheme, %struct.scheme* %242, i32 0, i32 55
  store i32 6, i32* %op245, align 4
  %243 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T246 = getelementptr inbounds %struct.scheme, %struct.scheme* %243, i32 0, i32 19
  %244 = load %struct.cell*, %struct.cell** %T246, align 8
  store %struct.cell* %244, %struct.cell** %retval
  br label %return

do.end.247:                                       ; No predecessors!
  br label %if.end.248

if.end.248:                                       ; preds = %do.end.247
  br label %sw.bb.249

sw.bb.249:                                        ; preds = %sw.bb.109, %if.end.248
  %245 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %246 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call250 = call i8* @readstr_upto(%struct.scheme* %246, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.260, i32 0, i32 0))
  %call251 = call %struct.cell* @mk_sharp_const(%struct.scheme* %245, i8* %call250)
  store %struct.cell* %call251, %struct.cell** %x, align 8
  %247 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL252 = getelementptr inbounds %struct.scheme, %struct.scheme* %247, i32 0, i32 17
  %248 = load %struct.cell*, %struct.cell** %NIL252, align 8
  %cmp253 = icmp eq %struct.cell* %call251, %248
  br i1 %cmp253, label %if.then.255, label %if.else.257

if.then.255:                                      ; preds = %sw.bb.249
  %249 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call256 = call %struct.cell* @_Error_1(%struct.scheme* %249, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.262, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call256, %struct.cell** %retval
  br label %return

if.else.257:                                      ; preds = %sw.bb.249
  %250 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %251 = load %struct.cell*, %struct.cell** %x, align 8
  %call258 = call %struct.cell* @_s_return(%struct.scheme* %250, %struct.cell* %251)
  store %struct.cell* %call258, %struct.cell** %retval
  br label %return

sw.default:                                       ; preds = %sw.bb.109
  %252 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %253 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %254 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok259 = getelementptr inbounds %struct.scheme, %struct.scheme* %254, i32 0, i32 52
  %255 = load i32, i32* %tok259, align 4
  %conv260 = sext i32 %255 to i64
  %call261 = call %struct.cell* @mk_integer(%struct.scheme* %253, i64 %conv260)
  %call262 = call %struct.cell* @_Error_1(%struct.scheme* %252, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.263, i32 0, i32 0), %struct.cell* %call261)
  store %struct.cell* %call262, %struct.cell** %retval
  br label %return

sw.bb.263:                                        ; preds = %if.end
  %256 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %257 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value264 = getelementptr inbounds %struct.scheme, %struct.scheme* %257, i32 0, i32 54
  %258 = load %struct.cell*, %struct.cell** %value264, align 8
  %259 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args265 = getelementptr inbounds %struct.scheme, %struct.scheme* %259, i32 0, i32 7
  %260 = load %struct.cell*, %struct.cell** %args265, align 8
  %call266 = call %struct.cell* @_cons(%struct.scheme* %256, %struct.cell* %258, %struct.cell* %260, i32 0)
  %261 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args267 = getelementptr inbounds %struct.scheme, %struct.scheme* %261, i32 0, i32 7
  store %struct.cell* %call266, %struct.cell** %args267, align 8
  %262 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call268 = call i32 @token(%struct.scheme* %262)
  %263 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok269 = getelementptr inbounds %struct.scheme, %struct.scheme* %263, i32 0, i32 52
  store i32 %call268, i32* %tok269, align 4
  %264 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok270 = getelementptr inbounds %struct.scheme, %struct.scheme* %264, i32 0, i32 52
  %265 = load i32, i32* %tok270, align 4
  %cmp271 = icmp eq i32 %265, -1
  br i1 %cmp271, label %if.then.273, label %if.else.276

if.then.273:                                      ; preds = %sw.bb.263
  %266 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %267 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ274 = getelementptr inbounds %struct.scheme, %struct.scheme* %267, i32 0, i32 23
  %268 = load %struct.cell*, %struct.cell** %EOF_OBJ274, align 8
  %call275 = call %struct.cell* @_s_return(%struct.scheme* %266, %struct.cell* %268)
  store %struct.cell* %call275, %struct.cell** %retval
  br label %return

if.else.276:                                      ; preds = %sw.bb.263
  %269 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok277 = getelementptr inbounds %struct.scheme, %struct.scheme* %269, i32 0, i32 52
  %270 = load i32, i32* %tok277, align 4
  %cmp278 = icmp eq i32 %270, 1
  br i1 %cmp278, label %if.then.280, label %if.else.300

if.then.280:                                      ; preds = %if.else.276
  %271 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call282 = call i32 @inchar(%struct.scheme* %271)
  store i32 %call282, i32* %c281, align 4
  %272 = load i32, i32* %c281, align 4
  %cmp283 = icmp ne i32 %272, 10
  br i1 %cmp283, label %if.then.285, label %if.else.286

if.then.285:                                      ; preds = %if.then.280
  %273 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %274 = load i32, i32* %c281, align 4
  call void @backchar(%struct.scheme* %273, i32 %274)
  br label %if.end.291

if.else.286:                                      ; preds = %if.then.280
  %275 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i287 = getelementptr inbounds %struct.scheme, %struct.scheme* %275, i32 0, i32 45
  %276 = load i32, i32* %file_i287, align 4
  %idxprom288 = sext i32 %276 to i64
  %277 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %277, i32 0, i32 43
  %arrayidx289 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom288
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx289, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 2
  %278 = load i32, i32* %curr_line, align 4
  %inc290 = add nsw i32 %278, 1
  store i32 %inc290, i32* %curr_line, align 4
  br label %if.end.291

if.end.291:                                       ; preds = %if.else.286, %if.then.285
  %279 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i292 = getelementptr inbounds %struct.scheme, %struct.scheme* %279, i32 0, i32 45
  %280 = load i32, i32* %file_i292, align 4
  %idxprom293 = sext i32 %280 to i64
  %281 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting_stack294 = getelementptr inbounds %struct.scheme, %struct.scheme* %281, i32 0, i32 44
  %arrayidx295 = getelementptr inbounds [64 x i32], [64 x i32]* %nesting_stack294, i32 0, i64 %idxprom293
  %282 = load i32, i32* %arrayidx295, align 4
  %dec = add nsw i32 %282, -1
  store i32 %dec, i32* %arrayidx295, align 4
  %283 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %284 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %285 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL296 = getelementptr inbounds %struct.scheme, %struct.scheme* %285, i32 0, i32 17
  %286 = load %struct.cell*, %struct.cell** %NIL296, align 8
  %287 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args297 = getelementptr inbounds %struct.scheme, %struct.scheme* %287, i32 0, i32 7
  %288 = load %struct.cell*, %struct.cell** %args297, align 8
  %call298 = call %struct.cell* @reverse_in_place(%struct.scheme* %284, %struct.cell* %286, %struct.cell* %288)
  %call299 = call %struct.cell* @_s_return(%struct.scheme* %283, %struct.cell* %call298)
  store %struct.cell* %call299, %struct.cell** %retval
  br label %return

if.else.300:                                      ; preds = %if.else.276
  %289 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok301 = getelementptr inbounds %struct.scheme, %struct.scheme* %289, i32 0, i32 52
  %290 = load i32, i32* %tok301, align 4
  %cmp302 = icmp eq i32 %290, 2
  br i1 %cmp302, label %if.then.304, label %if.else.313

if.then.304:                                      ; preds = %if.else.300
  %291 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %292 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args305 = getelementptr inbounds %struct.scheme, %struct.scheme* %292, i32 0, i32 7
  %293 = load %struct.cell*, %struct.cell** %args305, align 8
  %294 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL306 = getelementptr inbounds %struct.scheme, %struct.scheme* %294, i32 0, i32 17
  %295 = load %struct.cell*, %struct.cell** %NIL306, align 8
  call void @s_save(%struct.scheme* %291, i32 165, %struct.cell* %293, %struct.cell* %295)
  %296 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call307 = call i32 @token(%struct.scheme* %296)
  %297 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %tok308 = getelementptr inbounds %struct.scheme, %struct.scheme* %297, i32 0, i32 52
  store i32 %call307, i32* %tok308, align 4
  br label %do.body.309

do.body.309:                                      ; preds = %if.then.304
  %298 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op310 = getelementptr inbounds %struct.scheme, %struct.scheme* %298, i32 0, i32 55
  store i32 163, i32* %op310, align 4
  %299 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T311 = getelementptr inbounds %struct.scheme, %struct.scheme* %299, i32 0, i32 19
  %300 = load %struct.cell*, %struct.cell** %T311, align 8
  store %struct.cell* %300, %struct.cell** %retval
  br label %return

do.end.312:                                       ; No predecessors!
  br label %if.end.320

if.else.313:                                      ; preds = %if.else.300
  %301 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %302 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args314 = getelementptr inbounds %struct.scheme, %struct.scheme* %302, i32 0, i32 7
  %303 = load %struct.cell*, %struct.cell** %args314, align 8
  %304 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL315 = getelementptr inbounds %struct.scheme, %struct.scheme* %304, i32 0, i32 17
  %305 = load %struct.cell*, %struct.cell** %NIL315, align 8
  call void @s_save(%struct.scheme* %301, i32 164, %struct.cell* %303, %struct.cell* %305)
  br label %do.body.316

do.body.316:                                      ; preds = %if.else.313
  %306 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op317 = getelementptr inbounds %struct.scheme, %struct.scheme* %306, i32 0, i32 55
  store i32 163, i32* %op317, align 4
  %307 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T318 = getelementptr inbounds %struct.scheme, %struct.scheme* %307, i32 0, i32 19
  %308 = load %struct.cell*, %struct.cell** %T318, align 8
  store %struct.cell* %308, %struct.cell** %retval
  br label %return

do.end.319:                                       ; No predecessors!
  br label %if.end.320

if.end.320:                                       ; preds = %do.end.319, %do.end.312
  br label %if.end.321

if.end.321:                                       ; preds = %if.end.320
  br label %if.end.322

if.end.322:                                       ; preds = %if.end.321
  br label %sw.bb.323

sw.bb.323:                                        ; preds = %if.end, %if.end.322
  %309 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call324 = call i32 @token(%struct.scheme* %309)
  %cmp325 = icmp ne i32 %call324, 1
  br i1 %cmp325, label %if.then.327, label %if.else.329

if.then.327:                                      ; preds = %sw.bb.323
  %310 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call328 = call %struct.cell* @_Error_1(%struct.scheme* %310, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.259, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call328, %struct.cell** %retval
  br label %return

if.else.329:                                      ; preds = %sw.bb.323
  %311 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i330 = getelementptr inbounds %struct.scheme, %struct.scheme* %311, i32 0, i32 45
  %312 = load i32, i32* %file_i330, align 4
  %idxprom331 = sext i32 %312 to i64
  %313 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting_stack332 = getelementptr inbounds %struct.scheme, %struct.scheme* %313, i32 0, i32 44
  %arrayidx333 = getelementptr inbounds [64 x i32], [64 x i32]* %nesting_stack332, i32 0, i64 %idxprom331
  %314 = load i32, i32* %arrayidx333, align 4
  %dec334 = add nsw i32 %314, -1
  store i32 %dec334, i32* %arrayidx333, align 4
  %315 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %316 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %317 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value335 = getelementptr inbounds %struct.scheme, %struct.scheme* %317, i32 0, i32 54
  %318 = load %struct.cell*, %struct.cell** %value335, align 8
  %319 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args336 = getelementptr inbounds %struct.scheme, %struct.scheme* %319, i32 0, i32 7
  %320 = load %struct.cell*, %struct.cell** %args336, align 8
  %call337 = call %struct.cell* @reverse_in_place(%struct.scheme* %316, %struct.cell* %318, %struct.cell* %320)
  %call338 = call %struct.cell* @_s_return(%struct.scheme* %315, %struct.cell* %call337)
  store %struct.cell* %call338, %struct.cell** %retval
  br label %return

sw.bb.339:                                        ; preds = %if.end
  %321 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %322 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %323 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %323, i32 0, i32 28
  %324 = load %struct.cell*, %struct.cell** %QUOTE, align 8
  %325 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %326 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value340 = getelementptr inbounds %struct.scheme, %struct.scheme* %326, i32 0, i32 54
  %327 = load %struct.cell*, %struct.cell** %value340, align 8
  %328 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL341 = getelementptr inbounds %struct.scheme, %struct.scheme* %328, i32 0, i32 17
  %329 = load %struct.cell*, %struct.cell** %NIL341, align 8
  %call342 = call %struct.cell* @_cons(%struct.scheme* %325, %struct.cell* %327, %struct.cell* %329, i32 0)
  %call343 = call %struct.cell* @_cons(%struct.scheme* %322, %struct.cell* %324, %struct.cell* %call342, i32 0)
  %call344 = call %struct.cell* @_s_return(%struct.scheme* %321, %struct.cell* %call343)
  store %struct.cell* %call344, %struct.cell** %retval
  br label %return

sw.bb.345:                                        ; preds = %if.end
  %330 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %331 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %332 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QQUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %332, i32 0, i32 29
  %333 = load %struct.cell*, %struct.cell** %QQUOTE, align 8
  %334 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %335 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value346 = getelementptr inbounds %struct.scheme, %struct.scheme* %335, i32 0, i32 54
  %336 = load %struct.cell*, %struct.cell** %value346, align 8
  %337 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL347 = getelementptr inbounds %struct.scheme, %struct.scheme* %337, i32 0, i32 17
  %338 = load %struct.cell*, %struct.cell** %NIL347, align 8
  %call348 = call %struct.cell* @_cons(%struct.scheme* %334, %struct.cell* %336, %struct.cell* %338, i32 0)
  %call349 = call %struct.cell* @_cons(%struct.scheme* %331, %struct.cell* %333, %struct.cell* %call348, i32 0)
  %call350 = call %struct.cell* @_s_return(%struct.scheme* %330, %struct.cell* %call349)
  store %struct.cell* %call350, %struct.cell** %retval
  br label %return

sw.bb.351:                                        ; preds = %if.end
  %339 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %340 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %341 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call352 = call %struct.cell* @mk_symbol(%struct.scheme* %341, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.37, i32 0, i32 0))
  %342 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %343 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call353 = call %struct.cell* @mk_symbol(%struct.scheme* %343, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.90, i32 0, i32 0))
  %344 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %345 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %346 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QQUOTE354 = getelementptr inbounds %struct.scheme, %struct.scheme* %346, i32 0, i32 29
  %347 = load %struct.cell*, %struct.cell** %QQUOTE354, align 8
  %348 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %349 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value355 = getelementptr inbounds %struct.scheme, %struct.scheme* %349, i32 0, i32 54
  %350 = load %struct.cell*, %struct.cell** %value355, align 8
  %351 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL356 = getelementptr inbounds %struct.scheme, %struct.scheme* %351, i32 0, i32 17
  %352 = load %struct.cell*, %struct.cell** %NIL356, align 8
  %call357 = call %struct.cell* @_cons(%struct.scheme* %348, %struct.cell* %350, %struct.cell* %352, i32 0)
  %call358 = call %struct.cell* @_cons(%struct.scheme* %345, %struct.cell* %347, %struct.cell* %call357, i32 0)
  %353 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL359 = getelementptr inbounds %struct.scheme, %struct.scheme* %353, i32 0, i32 17
  %354 = load %struct.cell*, %struct.cell** %NIL359, align 8
  %call360 = call %struct.cell* @_cons(%struct.scheme* %344, %struct.cell* %call358, %struct.cell* %354, i32 0)
  %call361 = call %struct.cell* @_cons(%struct.scheme* %342, %struct.cell* %call353, %struct.cell* %call360, i32 0)
  %call362 = call %struct.cell* @_cons(%struct.scheme* %340, %struct.cell* %call352, %struct.cell* %call361, i32 0)
  %call363 = call %struct.cell* @_s_return(%struct.scheme* %339, %struct.cell* %call362)
  store %struct.cell* %call363, %struct.cell** %retval
  br label %return

sw.bb.364:                                        ; preds = %if.end
  %355 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %356 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %357 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %357, i32 0, i32 30
  %358 = load %struct.cell*, %struct.cell** %UNQUOTE, align 8
  %359 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %360 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value365 = getelementptr inbounds %struct.scheme, %struct.scheme* %360, i32 0, i32 54
  %361 = load %struct.cell*, %struct.cell** %value365, align 8
  %362 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL366 = getelementptr inbounds %struct.scheme, %struct.scheme* %362, i32 0, i32 17
  %363 = load %struct.cell*, %struct.cell** %NIL366, align 8
  %call367 = call %struct.cell* @_cons(%struct.scheme* %359, %struct.cell* %361, %struct.cell* %363, i32 0)
  %call368 = call %struct.cell* @_cons(%struct.scheme* %356, %struct.cell* %358, %struct.cell* %call367, i32 0)
  %call369 = call %struct.cell* @_s_return(%struct.scheme* %355, %struct.cell* %call368)
  store %struct.cell* %call369, %struct.cell** %retval
  br label %return

sw.bb.370:                                        ; preds = %if.end
  %364 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %365 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %366 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTESP = getelementptr inbounds %struct.scheme, %struct.scheme* %366, i32 0, i32 31
  %367 = load %struct.cell*, %struct.cell** %UNQUOTESP, align 8
  %368 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %369 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value371 = getelementptr inbounds %struct.scheme, %struct.scheme* %369, i32 0, i32 54
  %370 = load %struct.cell*, %struct.cell** %value371, align 8
  %371 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL372 = getelementptr inbounds %struct.scheme, %struct.scheme* %371, i32 0, i32 17
  %372 = load %struct.cell*, %struct.cell** %NIL372, align 8
  %call373 = call %struct.cell* @_cons(%struct.scheme* %368, %struct.cell* %370, %struct.cell* %372, i32 0)
  %call374 = call %struct.cell* @_cons(%struct.scheme* %365, %struct.cell* %367, %struct.cell* %call373, i32 0)
  %call375 = call %struct.cell* @_s_return(%struct.scheme* %364, %struct.cell* %call374)
  store %struct.cell* %call375, %struct.cell** %retval
  br label %return

sw.bb.376:                                        ; preds = %if.end
  %373 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value377 = getelementptr inbounds %struct.scheme, %struct.scheme* %373, i32 0, i32 54
  %374 = load %struct.cell*, %struct.cell** %value377, align 8
  %375 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args378 = getelementptr inbounds %struct.scheme, %struct.scheme* %375, i32 0, i32 7
  store %struct.cell* %374, %struct.cell** %args378, align 8
  br label %do.body.379

do.body.379:                                      ; preds = %sw.bb.376
  %376 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op380 = getelementptr inbounds %struct.scheme, %struct.scheme* %376, i32 0, i32 55
  store i32 93, i32* %op380, align 4
  %377 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T381 = getelementptr inbounds %struct.scheme, %struct.scheme* %377, i32 0, i32 19
  %378 = load %struct.cell*, %struct.cell** %T381, align 8
  store %struct.cell* %378, %struct.cell** %retval
  br label %return

do.end.382:                                       ; No predecessors!
  br label %sw.bb.383

sw.bb.383:                                        ; preds = %if.end, %do.end.382
  %379 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args384 = getelementptr inbounds %struct.scheme, %struct.scheme* %379, i32 0, i32 7
  %380 = load %struct.cell*, %struct.cell** %args384, align 8
  %call385 = call i32 @is_vector(%struct.cell* %380)
  %tobool386 = icmp ne i32 %call385, 0
  br i1 %tobool386, label %if.then.387, label %if.else.396

if.then.387:                                      ; preds = %sw.bb.383
  %381 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %381, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.264, i32 0, i32 0))
  %382 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %383 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args388 = getelementptr inbounds %struct.scheme, %struct.scheme* %383, i32 0, i32 7
  %384 = load %struct.cell*, %struct.cell** %args388, align 8
  %385 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call389 = call %struct.cell* @mk_integer(%struct.scheme* %385, i64 0)
  %call390 = call %struct.cell* @_cons(%struct.scheme* %382, %struct.cell* %384, %struct.cell* %call389, i32 0)
  %386 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args391 = getelementptr inbounds %struct.scheme, %struct.scheme* %386, i32 0, i32 7
  store %struct.cell* %call390, %struct.cell** %args391, align 8
  br label %do.body.392

do.body.392:                                      ; preds = %if.then.387
  %387 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op393 = getelementptr inbounds %struct.scheme, %struct.scheme* %387, i32 0, i32 55
  store i32 174, i32* %op393, align 4
  %388 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T394 = getelementptr inbounds %struct.scheme, %struct.scheme* %388, i32 0, i32 19
  %389 = load %struct.cell*, %struct.cell** %T394, align 8
  store %struct.cell* %389, %struct.cell** %retval
  br label %return

do.end.395:                                       ; No predecessors!
  br label %if.end.586

if.else.396:                                      ; preds = %sw.bb.383
  %390 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args397 = getelementptr inbounds %struct.scheme, %struct.scheme* %390, i32 0, i32 7
  %391 = load %struct.cell*, %struct.cell** %args397, align 8
  %call398 = call i32 @is_environment(%struct.cell* %391)
  %tobool399 = icmp ne i32 %call398, 0
  br i1 %tobool399, label %if.then.400, label %if.else.403

if.then.400:                                      ; preds = %if.else.396
  %392 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %392, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.265, i32 0, i32 0))
  %393 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %394 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T401 = getelementptr inbounds %struct.scheme, %struct.scheme* %394, i32 0, i32 19
  %395 = load %struct.cell*, %struct.cell** %T401, align 8
  %call402 = call %struct.cell* @_s_return(%struct.scheme* %393, %struct.cell* %395)
  store %struct.cell* %call402, %struct.cell** %retval
  br label %return

if.else.403:                                      ; preds = %if.else.396
  %396 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args404 = getelementptr inbounds %struct.scheme, %struct.scheme* %396, i32 0, i32 7
  %397 = load %struct.cell*, %struct.cell** %args404, align 8
  %call405 = call i32 @is_pair(%struct.cell* %397)
  %tobool406 = icmp ne i32 %call405, 0
  br i1 %tobool406, label %if.else.411, label %if.then.407

if.then.407:                                      ; preds = %if.else.403
  %398 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %399 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args408 = getelementptr inbounds %struct.scheme, %struct.scheme* %399, i32 0, i32 7
  %400 = load %struct.cell*, %struct.cell** %args408, align 8
  %401 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %401, i32 0, i32 53
  %402 = load i32, i32* %print_flag, align 4
  call void @printatom(%struct.scheme* %398, %struct.cell* %400, i32 %402)
  %403 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %404 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T409 = getelementptr inbounds %struct.scheme, %struct.scheme* %404, i32 0, i32 19
  %405 = load %struct.cell*, %struct.cell** %T409, align 8
  %call410 = call %struct.cell* @_s_return(%struct.scheme* %403, %struct.cell* %405)
  store %struct.cell* %call410, %struct.cell** %retval
  br label %return

if.else.411:                                      ; preds = %if.else.403
  %406 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args412 = getelementptr inbounds %struct.scheme, %struct.scheme* %406, i32 0, i32 7
  %407 = load %struct.cell*, %struct.cell** %args412, align 8
  %_object413 = getelementptr inbounds %struct.cell, %struct.cell* %407, i32 0, i32 1
  %_cons414 = bitcast %union.anon* %_object413 to %struct.anon.4*
  %_car415 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons414, i32 0, i32 0
  %408 = load %struct.cell*, %struct.cell** %_car415, align 8
  %409 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE416 = getelementptr inbounds %struct.scheme, %struct.scheme* %409, i32 0, i32 28
  %410 = load %struct.cell*, %struct.cell** %QUOTE416, align 8
  %cmp417 = icmp eq %struct.cell* %408, %410
  br i1 %cmp417, label %land.lhs.true, label %if.else.448

land.lhs.true:                                    ; preds = %if.else.411
  %411 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args419 = getelementptr inbounds %struct.scheme, %struct.scheme* %411, i32 0, i32 7
  %412 = load %struct.cell*, %struct.cell** %args419, align 8
  %_object420 = getelementptr inbounds %struct.cell, %struct.cell* %412, i32 0, i32 1
  %_cons421 = bitcast %union.anon* %_object420 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons421, i32 0, i32 1
  %413 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %call422 = call i32 @is_pair(%struct.cell* %413)
  %tobool423 = icmp ne i32 %call422, 0
  br i1 %tobool423, label %land.lhs.true.424, label %if.else.448

land.lhs.true.424:                                ; preds = %land.lhs.true
  %414 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args425 = getelementptr inbounds %struct.scheme, %struct.scheme* %414, i32 0, i32 7
  %415 = load %struct.cell*, %struct.cell** %args425, align 8
  %_object426 = getelementptr inbounds %struct.cell, %struct.cell* %415, i32 0, i32 1
  %_cons427 = bitcast %union.anon* %_object426 to %struct.anon.4*
  %_cdr428 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons427, i32 0, i32 1
  %416 = load %struct.cell*, %struct.cell** %_cdr428, align 8
  %_object429 = getelementptr inbounds %struct.cell, %struct.cell* %416, i32 0, i32 1
  %_cons430 = bitcast %union.anon* %_object429 to %struct.anon.4*
  %_cdr431 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons430, i32 0, i32 1
  %417 = load %struct.cell*, %struct.cell** %_cdr431, align 8
  %418 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL432 = getelementptr inbounds %struct.scheme, %struct.scheme* %418, i32 0, i32 17
  %419 = load %struct.cell*, %struct.cell** %NIL432, align 8
  %cmp433 = icmp eq %struct.cell* %417, %419
  br i1 %cmp433, label %if.then.435, label %if.else.448

if.then.435:                                      ; preds = %land.lhs.true.424
  %420 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %420, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.266, i32 0, i32 0))
  %421 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args436 = getelementptr inbounds %struct.scheme, %struct.scheme* %421, i32 0, i32 7
  %422 = load %struct.cell*, %struct.cell** %args436, align 8
  %_object437 = getelementptr inbounds %struct.cell, %struct.cell* %422, i32 0, i32 1
  %_cons438 = bitcast %union.anon* %_object437 to %struct.anon.4*
  %_cdr439 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons438, i32 0, i32 1
  %423 = load %struct.cell*, %struct.cell** %_cdr439, align 8
  %_object440 = getelementptr inbounds %struct.cell, %struct.cell* %423, i32 0, i32 1
  %_cons441 = bitcast %union.anon* %_object440 to %struct.anon.4*
  %_car442 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons441, i32 0, i32 0
  %424 = load %struct.cell*, %struct.cell** %_car442, align 8
  %425 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args443 = getelementptr inbounds %struct.scheme, %struct.scheme* %425, i32 0, i32 7
  store %struct.cell* %424, %struct.cell** %args443, align 8
  br label %do.body.444

do.body.444:                                      ; preds = %if.then.435
  %426 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op445 = getelementptr inbounds %struct.scheme, %struct.scheme* %426, i32 0, i32 55
  store i32 172, i32* %op445, align 4
  %427 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T446 = getelementptr inbounds %struct.scheme, %struct.scheme* %427, i32 0, i32 19
  %428 = load %struct.cell*, %struct.cell** %T446, align 8
  store %struct.cell* %428, %struct.cell** %retval
  br label %return

do.end.447:                                       ; No predecessors!
  br label %if.end.583

if.else.448:                                      ; preds = %land.lhs.true.424, %land.lhs.true, %if.else.411
  %429 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args449 = getelementptr inbounds %struct.scheme, %struct.scheme* %429, i32 0, i32 7
  %430 = load %struct.cell*, %struct.cell** %args449, align 8
  %_object450 = getelementptr inbounds %struct.cell, %struct.cell* %430, i32 0, i32 1
  %_cons451 = bitcast %union.anon* %_object450 to %struct.anon.4*
  %_car452 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons451, i32 0, i32 0
  %431 = load %struct.cell*, %struct.cell** %_car452, align 8
  %432 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QQUOTE453 = getelementptr inbounds %struct.scheme, %struct.scheme* %432, i32 0, i32 29
  %433 = load %struct.cell*, %struct.cell** %QQUOTE453, align 8
  %cmp454 = icmp eq %struct.cell* %431, %433
  br i1 %cmp454, label %land.lhs.true.456, label %if.else.487

land.lhs.true.456:                                ; preds = %if.else.448
  %434 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args457 = getelementptr inbounds %struct.scheme, %struct.scheme* %434, i32 0, i32 7
  %435 = load %struct.cell*, %struct.cell** %args457, align 8
  %_object458 = getelementptr inbounds %struct.cell, %struct.cell* %435, i32 0, i32 1
  %_cons459 = bitcast %union.anon* %_object458 to %struct.anon.4*
  %_cdr460 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons459, i32 0, i32 1
  %436 = load %struct.cell*, %struct.cell** %_cdr460, align 8
  %call461 = call i32 @is_pair(%struct.cell* %436)
  %tobool462 = icmp ne i32 %call461, 0
  br i1 %tobool462, label %land.lhs.true.463, label %if.else.487

land.lhs.true.463:                                ; preds = %land.lhs.true.456
  %437 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args464 = getelementptr inbounds %struct.scheme, %struct.scheme* %437, i32 0, i32 7
  %438 = load %struct.cell*, %struct.cell** %args464, align 8
  %_object465 = getelementptr inbounds %struct.cell, %struct.cell* %438, i32 0, i32 1
  %_cons466 = bitcast %union.anon* %_object465 to %struct.anon.4*
  %_cdr467 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons466, i32 0, i32 1
  %439 = load %struct.cell*, %struct.cell** %_cdr467, align 8
  %_object468 = getelementptr inbounds %struct.cell, %struct.cell* %439, i32 0, i32 1
  %_cons469 = bitcast %union.anon* %_object468 to %struct.anon.4*
  %_cdr470 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons469, i32 0, i32 1
  %440 = load %struct.cell*, %struct.cell** %_cdr470, align 8
  %441 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL471 = getelementptr inbounds %struct.scheme, %struct.scheme* %441, i32 0, i32 17
  %442 = load %struct.cell*, %struct.cell** %NIL471, align 8
  %cmp472 = icmp eq %struct.cell* %440, %442
  br i1 %cmp472, label %if.then.474, label %if.else.487

if.then.474:                                      ; preds = %land.lhs.true.463
  %443 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %443, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.267, i32 0, i32 0))
  %444 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args475 = getelementptr inbounds %struct.scheme, %struct.scheme* %444, i32 0, i32 7
  %445 = load %struct.cell*, %struct.cell** %args475, align 8
  %_object476 = getelementptr inbounds %struct.cell, %struct.cell* %445, i32 0, i32 1
  %_cons477 = bitcast %union.anon* %_object476 to %struct.anon.4*
  %_cdr478 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons477, i32 0, i32 1
  %446 = load %struct.cell*, %struct.cell** %_cdr478, align 8
  %_object479 = getelementptr inbounds %struct.cell, %struct.cell* %446, i32 0, i32 1
  %_cons480 = bitcast %union.anon* %_object479 to %struct.anon.4*
  %_car481 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons480, i32 0, i32 0
  %447 = load %struct.cell*, %struct.cell** %_car481, align 8
  %448 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args482 = getelementptr inbounds %struct.scheme, %struct.scheme* %448, i32 0, i32 7
  store %struct.cell* %447, %struct.cell** %args482, align 8
  br label %do.body.483

do.body.483:                                      ; preds = %if.then.474
  %449 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op484 = getelementptr inbounds %struct.scheme, %struct.scheme* %449, i32 0, i32 55
  store i32 172, i32* %op484, align 4
  %450 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T485 = getelementptr inbounds %struct.scheme, %struct.scheme* %450, i32 0, i32 19
  %451 = load %struct.cell*, %struct.cell** %T485, align 8
  store %struct.cell* %451, %struct.cell** %retval
  br label %return

do.end.486:                                       ; No predecessors!
  br label %if.end.582

if.else.487:                                      ; preds = %land.lhs.true.463, %land.lhs.true.456, %if.else.448
  %452 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args488 = getelementptr inbounds %struct.scheme, %struct.scheme* %452, i32 0, i32 7
  %453 = load %struct.cell*, %struct.cell** %args488, align 8
  %_object489 = getelementptr inbounds %struct.cell, %struct.cell* %453, i32 0, i32 1
  %_cons490 = bitcast %union.anon* %_object489 to %struct.anon.4*
  %_car491 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons490, i32 0, i32 0
  %454 = load %struct.cell*, %struct.cell** %_car491, align 8
  %455 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTE492 = getelementptr inbounds %struct.scheme, %struct.scheme* %455, i32 0, i32 30
  %456 = load %struct.cell*, %struct.cell** %UNQUOTE492, align 8
  %cmp493 = icmp eq %struct.cell* %454, %456
  br i1 %cmp493, label %land.lhs.true.495, label %if.else.526

land.lhs.true.495:                                ; preds = %if.else.487
  %457 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args496 = getelementptr inbounds %struct.scheme, %struct.scheme* %457, i32 0, i32 7
  %458 = load %struct.cell*, %struct.cell** %args496, align 8
  %_object497 = getelementptr inbounds %struct.cell, %struct.cell* %458, i32 0, i32 1
  %_cons498 = bitcast %union.anon* %_object497 to %struct.anon.4*
  %_cdr499 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons498, i32 0, i32 1
  %459 = load %struct.cell*, %struct.cell** %_cdr499, align 8
  %call500 = call i32 @is_pair(%struct.cell* %459)
  %tobool501 = icmp ne i32 %call500, 0
  br i1 %tobool501, label %land.lhs.true.502, label %if.else.526

land.lhs.true.502:                                ; preds = %land.lhs.true.495
  %460 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args503 = getelementptr inbounds %struct.scheme, %struct.scheme* %460, i32 0, i32 7
  %461 = load %struct.cell*, %struct.cell** %args503, align 8
  %_object504 = getelementptr inbounds %struct.cell, %struct.cell* %461, i32 0, i32 1
  %_cons505 = bitcast %union.anon* %_object504 to %struct.anon.4*
  %_cdr506 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons505, i32 0, i32 1
  %462 = load %struct.cell*, %struct.cell** %_cdr506, align 8
  %_object507 = getelementptr inbounds %struct.cell, %struct.cell* %462, i32 0, i32 1
  %_cons508 = bitcast %union.anon* %_object507 to %struct.anon.4*
  %_cdr509 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons508, i32 0, i32 1
  %463 = load %struct.cell*, %struct.cell** %_cdr509, align 8
  %464 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL510 = getelementptr inbounds %struct.scheme, %struct.scheme* %464, i32 0, i32 17
  %465 = load %struct.cell*, %struct.cell** %NIL510, align 8
  %cmp511 = icmp eq %struct.cell* %463, %465
  br i1 %cmp511, label %if.then.513, label %if.else.526

if.then.513:                                      ; preds = %land.lhs.true.502
  %466 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %466, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.268, i32 0, i32 0))
  %467 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args514 = getelementptr inbounds %struct.scheme, %struct.scheme* %467, i32 0, i32 7
  %468 = load %struct.cell*, %struct.cell** %args514, align 8
  %_object515 = getelementptr inbounds %struct.cell, %struct.cell* %468, i32 0, i32 1
  %_cons516 = bitcast %union.anon* %_object515 to %struct.anon.4*
  %_cdr517 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons516, i32 0, i32 1
  %469 = load %struct.cell*, %struct.cell** %_cdr517, align 8
  %_object518 = getelementptr inbounds %struct.cell, %struct.cell* %469, i32 0, i32 1
  %_cons519 = bitcast %union.anon* %_object518 to %struct.anon.4*
  %_car520 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons519, i32 0, i32 0
  %470 = load %struct.cell*, %struct.cell** %_car520, align 8
  %471 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args521 = getelementptr inbounds %struct.scheme, %struct.scheme* %471, i32 0, i32 7
  store %struct.cell* %470, %struct.cell** %args521, align 8
  br label %do.body.522

do.body.522:                                      ; preds = %if.then.513
  %472 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op523 = getelementptr inbounds %struct.scheme, %struct.scheme* %472, i32 0, i32 55
  store i32 172, i32* %op523, align 4
  %473 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T524 = getelementptr inbounds %struct.scheme, %struct.scheme* %473, i32 0, i32 19
  %474 = load %struct.cell*, %struct.cell** %T524, align 8
  store %struct.cell* %474, %struct.cell** %retval
  br label %return

do.end.525:                                       ; No predecessors!
  br label %if.end.581

if.else.526:                                      ; preds = %land.lhs.true.502, %land.lhs.true.495, %if.else.487
  %475 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args527 = getelementptr inbounds %struct.scheme, %struct.scheme* %475, i32 0, i32 7
  %476 = load %struct.cell*, %struct.cell** %args527, align 8
  %_object528 = getelementptr inbounds %struct.cell, %struct.cell* %476, i32 0, i32 1
  %_cons529 = bitcast %union.anon* %_object528 to %struct.anon.4*
  %_car530 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons529, i32 0, i32 0
  %477 = load %struct.cell*, %struct.cell** %_car530, align 8
  %478 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %UNQUOTESP531 = getelementptr inbounds %struct.scheme, %struct.scheme* %478, i32 0, i32 31
  %479 = load %struct.cell*, %struct.cell** %UNQUOTESP531, align 8
  %cmp532 = icmp eq %struct.cell* %477, %479
  br i1 %cmp532, label %land.lhs.true.534, label %if.else.565

land.lhs.true.534:                                ; preds = %if.else.526
  %480 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args535 = getelementptr inbounds %struct.scheme, %struct.scheme* %480, i32 0, i32 7
  %481 = load %struct.cell*, %struct.cell** %args535, align 8
  %_object536 = getelementptr inbounds %struct.cell, %struct.cell* %481, i32 0, i32 1
  %_cons537 = bitcast %union.anon* %_object536 to %struct.anon.4*
  %_cdr538 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons537, i32 0, i32 1
  %482 = load %struct.cell*, %struct.cell** %_cdr538, align 8
  %call539 = call i32 @is_pair(%struct.cell* %482)
  %tobool540 = icmp ne i32 %call539, 0
  br i1 %tobool540, label %land.lhs.true.541, label %if.else.565

land.lhs.true.541:                                ; preds = %land.lhs.true.534
  %483 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args542 = getelementptr inbounds %struct.scheme, %struct.scheme* %483, i32 0, i32 7
  %484 = load %struct.cell*, %struct.cell** %args542, align 8
  %_object543 = getelementptr inbounds %struct.cell, %struct.cell* %484, i32 0, i32 1
  %_cons544 = bitcast %union.anon* %_object543 to %struct.anon.4*
  %_cdr545 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons544, i32 0, i32 1
  %485 = load %struct.cell*, %struct.cell** %_cdr545, align 8
  %_object546 = getelementptr inbounds %struct.cell, %struct.cell* %485, i32 0, i32 1
  %_cons547 = bitcast %union.anon* %_object546 to %struct.anon.4*
  %_cdr548 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons547, i32 0, i32 1
  %486 = load %struct.cell*, %struct.cell** %_cdr548, align 8
  %487 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL549 = getelementptr inbounds %struct.scheme, %struct.scheme* %487, i32 0, i32 17
  %488 = load %struct.cell*, %struct.cell** %NIL549, align 8
  %cmp550 = icmp eq %struct.cell* %486, %488
  br i1 %cmp550, label %if.then.552, label %if.else.565

if.then.552:                                      ; preds = %land.lhs.true.541
  %489 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %489, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.269, i32 0, i32 0))
  %490 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args553 = getelementptr inbounds %struct.scheme, %struct.scheme* %490, i32 0, i32 7
  %491 = load %struct.cell*, %struct.cell** %args553, align 8
  %_object554 = getelementptr inbounds %struct.cell, %struct.cell* %491, i32 0, i32 1
  %_cons555 = bitcast %union.anon* %_object554 to %struct.anon.4*
  %_cdr556 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons555, i32 0, i32 1
  %492 = load %struct.cell*, %struct.cell** %_cdr556, align 8
  %_object557 = getelementptr inbounds %struct.cell, %struct.cell* %492, i32 0, i32 1
  %_cons558 = bitcast %union.anon* %_object557 to %struct.anon.4*
  %_car559 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons558, i32 0, i32 0
  %493 = load %struct.cell*, %struct.cell** %_car559, align 8
  %494 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args560 = getelementptr inbounds %struct.scheme, %struct.scheme* %494, i32 0, i32 7
  store %struct.cell* %493, %struct.cell** %args560, align 8
  br label %do.body.561

do.body.561:                                      ; preds = %if.then.552
  %495 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op562 = getelementptr inbounds %struct.scheme, %struct.scheme* %495, i32 0, i32 55
  store i32 172, i32* %op562, align 4
  %496 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T563 = getelementptr inbounds %struct.scheme, %struct.scheme* %496, i32 0, i32 19
  %497 = load %struct.cell*, %struct.cell** %T563, align 8
  store %struct.cell* %497, %struct.cell** %retval
  br label %return

do.end.564:                                       ; No predecessors!
  br label %if.end.580

if.else.565:                                      ; preds = %land.lhs.true.541, %land.lhs.true.534, %if.else.526
  %498 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %498, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.270, i32 0, i32 0))
  %499 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %500 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args566 = getelementptr inbounds %struct.scheme, %struct.scheme* %500, i32 0, i32 7
  %501 = load %struct.cell*, %struct.cell** %args566, align 8
  %_object567 = getelementptr inbounds %struct.cell, %struct.cell* %501, i32 0, i32 1
  %_cons568 = bitcast %union.anon* %_object567 to %struct.anon.4*
  %_cdr569 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons568, i32 0, i32 1
  %502 = load %struct.cell*, %struct.cell** %_cdr569, align 8
  %503 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL570 = getelementptr inbounds %struct.scheme, %struct.scheme* %503, i32 0, i32 17
  %504 = load %struct.cell*, %struct.cell** %NIL570, align 8
  call void @s_save(%struct.scheme* %499, i32 173, %struct.cell* %502, %struct.cell* %504)
  %505 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args571 = getelementptr inbounds %struct.scheme, %struct.scheme* %505, i32 0, i32 7
  %506 = load %struct.cell*, %struct.cell** %args571, align 8
  %_object572 = getelementptr inbounds %struct.cell, %struct.cell* %506, i32 0, i32 1
  %_cons573 = bitcast %union.anon* %_object572 to %struct.anon.4*
  %_car574 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons573, i32 0, i32 0
  %507 = load %struct.cell*, %struct.cell** %_car574, align 8
  %508 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args575 = getelementptr inbounds %struct.scheme, %struct.scheme* %508, i32 0, i32 7
  store %struct.cell* %507, %struct.cell** %args575, align 8
  br label %do.body.576

do.body.576:                                      ; preds = %if.else.565
  %509 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op577 = getelementptr inbounds %struct.scheme, %struct.scheme* %509, i32 0, i32 55
  store i32 172, i32* %op577, align 4
  %510 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T578 = getelementptr inbounds %struct.scheme, %struct.scheme* %510, i32 0, i32 19
  %511 = load %struct.cell*, %struct.cell** %T578, align 8
  store %struct.cell* %511, %struct.cell** %retval
  br label %return

do.end.579:                                       ; No predecessors!
  br label %if.end.580

if.end.580:                                       ; preds = %do.end.579, %do.end.564
  br label %if.end.581

if.end.581:                                       ; preds = %if.end.580, %do.end.525
  br label %if.end.582

if.end.582:                                       ; preds = %if.end.581, %do.end.486
  br label %if.end.583

if.end.583:                                       ; preds = %if.end.582, %do.end.447
  br label %if.end.584

if.end.584:                                       ; preds = %if.end.583
  br label %if.end.585

if.end.585:                                       ; preds = %if.end.584
  br label %if.end.586

if.end.586:                                       ; preds = %if.end.585, %do.end.395
  br label %sw.bb.587

sw.bb.587:                                        ; preds = %if.end, %if.end.586
  %512 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args588 = getelementptr inbounds %struct.scheme, %struct.scheme* %512, i32 0, i32 7
  %513 = load %struct.cell*, %struct.cell** %args588, align 8
  %call589 = call i32 @is_pair(%struct.cell* %513)
  %tobool590 = icmp ne i32 %call589, 0
  br i1 %tobool590, label %if.then.591, label %if.else.606

if.then.591:                                      ; preds = %sw.bb.587
  %514 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %515 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args592 = getelementptr inbounds %struct.scheme, %struct.scheme* %515, i32 0, i32 7
  %516 = load %struct.cell*, %struct.cell** %args592, align 8
  %_object593 = getelementptr inbounds %struct.cell, %struct.cell* %516, i32 0, i32 1
  %_cons594 = bitcast %union.anon* %_object593 to %struct.anon.4*
  %_cdr595 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons594, i32 0, i32 1
  %517 = load %struct.cell*, %struct.cell** %_cdr595, align 8
  %518 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL596 = getelementptr inbounds %struct.scheme, %struct.scheme* %518, i32 0, i32 17
  %519 = load %struct.cell*, %struct.cell** %NIL596, align 8
  call void @s_save(%struct.scheme* %514, i32 173, %struct.cell* %517, %struct.cell* %519)
  %520 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %520, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.252, i32 0, i32 0))
  %521 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args597 = getelementptr inbounds %struct.scheme, %struct.scheme* %521, i32 0, i32 7
  %522 = load %struct.cell*, %struct.cell** %args597, align 8
  %_object598 = getelementptr inbounds %struct.cell, %struct.cell* %522, i32 0, i32 1
  %_cons599 = bitcast %union.anon* %_object598 to %struct.anon.4*
  %_car600 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons599, i32 0, i32 0
  %523 = load %struct.cell*, %struct.cell** %_car600, align 8
  %524 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args601 = getelementptr inbounds %struct.scheme, %struct.scheme* %524, i32 0, i32 7
  store %struct.cell* %523, %struct.cell** %args601, align 8
  br label %do.body.602

do.body.602:                                      ; preds = %if.then.591
  %525 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op603 = getelementptr inbounds %struct.scheme, %struct.scheme* %525, i32 0, i32 55
  store i32 172, i32* %op603, align 4
  %526 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T604 = getelementptr inbounds %struct.scheme, %struct.scheme* %526, i32 0, i32 19
  %527 = load %struct.cell*, %struct.cell** %T604, align 8
  store %struct.cell* %527, %struct.cell** %retval
  br label %return

do.end.605:                                       ; No predecessors!
  br label %if.end.629

if.else.606:                                      ; preds = %sw.bb.587
  %528 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args607 = getelementptr inbounds %struct.scheme, %struct.scheme* %528, i32 0, i32 7
  %529 = load %struct.cell*, %struct.cell** %args607, align 8
  %call608 = call i32 @is_vector(%struct.cell* %529)
  %tobool609 = icmp ne i32 %call608, 0
  br i1 %tobool609, label %if.then.610, label %if.else.617

if.then.610:                                      ; preds = %if.else.606
  %530 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %531 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL611 = getelementptr inbounds %struct.scheme, %struct.scheme* %531, i32 0, i32 17
  %532 = load %struct.cell*, %struct.cell** %NIL611, align 8
  %533 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL612 = getelementptr inbounds %struct.scheme, %struct.scheme* %533, i32 0, i32 17
  %534 = load %struct.cell*, %struct.cell** %NIL612, align 8
  call void @s_save(%struct.scheme* %530, i32 173, %struct.cell* %532, %struct.cell* %534)
  %535 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %535, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.271, i32 0, i32 0))
  br label %do.body.613

do.body.613:                                      ; preds = %if.then.610
  %536 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op614 = getelementptr inbounds %struct.scheme, %struct.scheme* %536, i32 0, i32 55
  store i32 172, i32* %op614, align 4
  %537 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T615 = getelementptr inbounds %struct.scheme, %struct.scheme* %537, i32 0, i32 19
  %538 = load %struct.cell*, %struct.cell** %T615, align 8
  store %struct.cell* %538, %struct.cell** %retval
  br label %return

do.end.616:                                       ; No predecessors!
  br label %if.end.628

if.else.617:                                      ; preds = %if.else.606
  %539 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args618 = getelementptr inbounds %struct.scheme, %struct.scheme* %539, i32 0, i32 7
  %540 = load %struct.cell*, %struct.cell** %args618, align 8
  %541 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL619 = getelementptr inbounds %struct.scheme, %struct.scheme* %541, i32 0, i32 17
  %542 = load %struct.cell*, %struct.cell** %NIL619, align 8
  %cmp620 = icmp ne %struct.cell* %540, %542
  br i1 %cmp620, label %if.then.622, label %if.end.625

if.then.622:                                      ; preds = %if.else.617
  %543 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %543, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.271, i32 0, i32 0))
  %544 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %545 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args623 = getelementptr inbounds %struct.scheme, %struct.scheme* %545, i32 0, i32 7
  %546 = load %struct.cell*, %struct.cell** %args623, align 8
  %547 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %print_flag624 = getelementptr inbounds %struct.scheme, %struct.scheme* %547, i32 0, i32 53
  %548 = load i32, i32* %print_flag624, align 4
  call void @printatom(%struct.scheme* %544, %struct.cell* %546, i32 %548)
  br label %if.end.625

if.end.625:                                       ; preds = %if.then.622, %if.else.617
  %549 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %549, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.272, i32 0, i32 0))
  %550 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %551 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T626 = getelementptr inbounds %struct.scheme, %struct.scheme* %551, i32 0, i32 19
  %552 = load %struct.cell*, %struct.cell** %T626, align 8
  %call627 = call %struct.cell* @_s_return(%struct.scheme* %550, %struct.cell* %552)
  store %struct.cell* %call627, %struct.cell** %retval
  br label %return

if.end.628:                                       ; preds = %do.end.616
  br label %if.end.629

if.end.629:                                       ; preds = %if.end.628, %do.end.605
  br label %sw.bb.630

sw.bb.630:                                        ; preds = %if.end, %if.end.629
  %553 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args631 = getelementptr inbounds %struct.scheme, %struct.scheme* %553, i32 0, i32 7
  %554 = load %struct.cell*, %struct.cell** %args631, align 8
  %_object632 = getelementptr inbounds %struct.cell, %struct.cell* %554, i32 0, i32 1
  %_cons633 = bitcast %union.anon* %_object632 to %struct.anon.4*
  %_cdr634 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons633, i32 0, i32 1
  %555 = load %struct.cell*, %struct.cell** %_cdr634, align 8
  %_object635 = getelementptr inbounds %struct.cell, %struct.cell* %555, i32 0, i32 1
  %_number = bitcast %union.anon* %_object635 to %struct.num*
  %value636 = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value636 to i64*
  %556 = load i64, i64* %ivalue, align 8
  %conv637 = trunc i64 %556 to i32
  store i32 %conv637, i32* %i, align 4
  %557 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args638 = getelementptr inbounds %struct.scheme, %struct.scheme* %557, i32 0, i32 7
  %558 = load %struct.cell*, %struct.cell** %args638, align 8
  %_object639 = getelementptr inbounds %struct.cell, %struct.cell* %558, i32 0, i32 1
  %_cons640 = bitcast %union.anon* %_object639 to %struct.anon.4*
  %_car641 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons640, i32 0, i32 0
  %559 = load %struct.cell*, %struct.cell** %_car641, align 8
  store %struct.cell* %559, %struct.cell** %vec, align 8
  %560 = load %struct.cell*, %struct.cell** %vec, align 8
  %_object642 = getelementptr inbounds %struct.cell, %struct.cell* %560, i32 0, i32 1
  %_number643 = bitcast %union.anon* %_object642 to %struct.num*
  %value644 = getelementptr inbounds %struct.num, %struct.num* %_number643, i32 0, i32 1
  %ivalue645 = bitcast %union.anon.0* %value644 to i64*
  %561 = load i64, i64* %ivalue645, align 8
  %conv646 = trunc i64 %561 to i32
  store i32 %conv646, i32* %len, align 4
  %562 = load i32, i32* %i, align 4
  %563 = load i32, i32* %len, align 4
  %cmp647 = icmp eq i32 %562, %563
  br i1 %cmp647, label %if.then.649, label %if.else.652

if.then.649:                                      ; preds = %sw.bb.630
  %564 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %564, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.272, i32 0, i32 0))
  %565 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %566 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T650 = getelementptr inbounds %struct.scheme, %struct.scheme* %566, i32 0, i32 19
  %567 = load %struct.cell*, %struct.cell** %T650, align 8
  %call651 = call %struct.cell* @_s_return(%struct.scheme* %565, %struct.cell* %567)
  store %struct.cell* %call651, %struct.cell** %retval
  br label %return

if.else.652:                                      ; preds = %sw.bb.630
  %568 = load %struct.cell*, %struct.cell** %vec, align 8
  %569 = load i32, i32* %i, align 4
  %call653 = call %struct.cell* @vector_elem(%struct.cell* %568, i32 %569)
  store %struct.cell* %call653, %struct.cell** %elem, align 8
  %570 = load i32, i32* %i, align 4
  %add = add nsw i32 %570, 1
  %conv654 = sext i32 %add to i64
  %571 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args655 = getelementptr inbounds %struct.scheme, %struct.scheme* %571, i32 0, i32 7
  %572 = load %struct.cell*, %struct.cell** %args655, align 8
  %_object656 = getelementptr inbounds %struct.cell, %struct.cell* %572, i32 0, i32 1
  %_cons657 = bitcast %union.anon* %_object656 to %struct.anon.4*
  %_cdr658 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons657, i32 0, i32 1
  %573 = load %struct.cell*, %struct.cell** %_cdr658, align 8
  %_object659 = getelementptr inbounds %struct.cell, %struct.cell* %573, i32 0, i32 1
  %_number660 = bitcast %union.anon* %_object659 to %struct.num*
  %value661 = getelementptr inbounds %struct.num, %struct.num* %_number660, i32 0, i32 1
  %ivalue662 = bitcast %union.anon.0* %value661 to i64*
  store i64 %conv654, i64* %ivalue662, align 8
  %574 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %575 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args663 = getelementptr inbounds %struct.scheme, %struct.scheme* %575, i32 0, i32 7
  %576 = load %struct.cell*, %struct.cell** %args663, align 8
  %577 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL664 = getelementptr inbounds %struct.scheme, %struct.scheme* %577, i32 0, i32 17
  %578 = load %struct.cell*, %struct.cell** %NIL664, align 8
  call void @s_save(%struct.scheme* %574, i32 174, %struct.cell* %576, %struct.cell* %578)
  %579 = load %struct.cell*, %struct.cell** %elem, align 8
  %580 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args665 = getelementptr inbounds %struct.scheme, %struct.scheme* %580, i32 0, i32 7
  store %struct.cell* %579, %struct.cell** %args665, align 8
  %581 = load i32, i32* %i, align 4
  %cmp666 = icmp sgt i32 %581, 0
  br i1 %cmp666, label %if.then.668, label %if.end.669

if.then.668:                                      ; preds = %if.else.652
  %582 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putstr(%struct.scheme* %582, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.252, i32 0, i32 0))
  br label %if.end.669

if.end.669:                                       ; preds = %if.then.668, %if.else.652
  br label %do.body.670

do.body.670:                                      ; preds = %if.end.669
  %583 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op671 = getelementptr inbounds %struct.scheme, %struct.scheme* %583, i32 0, i32 55
  store i32 172, i32* %op671, align 4
  %584 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T672 = getelementptr inbounds %struct.scheme, %struct.scheme* %584, i32 0, i32 19
  %585 = load %struct.cell*, %struct.cell** %T672, align 8
  store %struct.cell* %585, %struct.cell** %retval
  br label %return

do.end.673:                                       ; No predecessors!
  br label %if.end.674

if.end.674:                                       ; preds = %do.end.673
  br label %sw.default.675

sw.default.675:                                   ; preds = %if.end, %if.end.674
  %586 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %586, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %587 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op676 = getelementptr inbounds %struct.scheme, %struct.scheme* %587, i32 0, i32 55
  %588 = load i32, i32* %op676, align 4
  %call677 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %588) #2
  %589 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %590 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff678 = getelementptr inbounds %struct.scheme, %struct.scheme* %590, i32 0, i32 50
  %arraydecay679 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff678, i32 0, i32 0
  %call680 = call %struct.cell* @_Error_1(%struct.scheme* %589, i8* %arraydecay679, %struct.cell* null)
  store %struct.cell* %call680, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default.675, %do.body.670, %if.then.649, %if.end.625, %do.body.613, %do.body.602, %do.body.576, %do.body.561, %do.body.522, %do.body.483, %do.body.444, %if.then.407, %if.then.400, %do.body.392, %do.body.379, %sw.bb.370, %sw.bb.364, %sw.bb.351, %sw.bb.345, %sw.bb.339, %if.else.329, %if.then.327, %do.body.316, %do.body.309, %if.end.291, %if.then.273, %sw.default, %if.else.257, %if.then.255, %do.body.244, %if.then.238, %if.end.231, %if.then.206, %if.end.199, %if.then.197, %sw.bb.188, %do.body.184, %do.body.175, %do.body.166, %do.body.158, %do.body.144, %do.body.133, %if.then.128, %if.then.122, %sw.bb.110, %sw.bb.102, %sw.bb.95, %cond.end, %if.end.76, %if.then.69, %do.body.38, %do.body.25, %if.then.11, %do.body, %if.then
  %591 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %591
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @opexe_6(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %y = alloca %struct.cell*, align 8
  %v = alloca i64, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load i32, i32* %op.addr, align 4
  switch i32 %0, label %sw.default [
    i32 175, label %sw.bb
    i32 176, label %sw.bb.9
    i32 177, label %sw.bb.50
    i32 178, label %sw.bb.83
    i32 179, label %sw.bb.92
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 7
  %3 = load %struct.cell*, %struct.cell** %args, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %4 = load %struct.cell*, %struct.cell** %_car, align 8
  %call = call i32 @list_length(%struct.scheme* %1, %struct.cell* %4)
  %conv = sext i32 %call to i64
  store i64 %conv, i64* %v, align 8
  %5 = load i64, i64* %v, align 8
  %cmp = icmp slt i64 %5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args2 = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 7
  %8 = load %struct.cell*, %struct.cell** %args2, align 8
  %_object3 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_cons4 = bitcast %union.anon* %_object3 to %struct.anon.4*
  %_car5 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons4, i32 0, i32 0
  %9 = load %struct.cell*, %struct.cell** %_car5, align 8
  %call6 = call %struct.cell* @_Error_1(%struct.scheme* %6, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.273, i32 0, i32 0), %struct.cell* %9)
  store %struct.cell* %call6, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %sw.bb
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %12 = load i64, i64* %v, align 8
  %call7 = call %struct.cell* @mk_integer(%struct.scheme* %11, i64 %12)
  %call8 = call %struct.cell* @_s_return(%struct.scheme* %10, %struct.cell* %call7)
  store %struct.cell* %call8, %struct.cell** %retval
  br label %return

sw.bb.9:                                          ; preds = %entry
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args10 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 7
  %14 = load %struct.cell*, %struct.cell** %args10, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %14, i32 0, i32 1
  %_cons12 = bitcast %union.anon* %_object11 to %struct.anon.4*
  %_car13 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons12, i32 0, i32 0
  %15 = load %struct.cell*, %struct.cell** %_car13, align 8
  store %struct.cell* %15, %struct.cell** %x, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args14 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 7
  %17 = load %struct.cell*, %struct.cell** %args14, align 8
  %_object15 = getelementptr inbounds %struct.cell, %struct.cell* %17, i32 0, i32 1
  %_cons16 = bitcast %union.anon* %_object15 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons16, i32 0, i32 1
  %18 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %_object17 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 1
  %_cons18 = bitcast %union.anon* %_object17 to %struct.anon.4*
  %_car19 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons18, i32 0, i32 0
  %19 = load %struct.cell*, %struct.cell** %_car19, align 8
  store %struct.cell* %19, %struct.cell** %y, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.9
  %20 = load %struct.cell*, %struct.cell** %y, align 8
  %call20 = call i32 @is_pair(%struct.cell* %20)
  %tobool = icmp ne i32 %call20, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load %struct.cell*, %struct.cell** %y, align 8
  %_object21 = getelementptr inbounds %struct.cell, %struct.cell* %21, i32 0, i32 1
  %_cons22 = bitcast %union.anon* %_object21 to %struct.anon.4*
  %_car23 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons22, i32 0, i32 0
  %22 = load %struct.cell*, %struct.cell** %_car23, align 8
  %call24 = call i32 @is_pair(%struct.cell* %22)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end.28, label %if.then.26

if.then.26:                                       ; preds = %for.body
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call27 = call %struct.cell* @_Error_1(%struct.scheme* %23, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.274, i32 0, i32 0), %struct.cell* null)
  store %struct.cell* %call27, %struct.cell** %retval
  br label %return

if.end.28:                                        ; preds = %for.body
  %24 = load %struct.cell*, %struct.cell** %x, align 8
  %25 = load %struct.cell*, %struct.cell** %y, align 8
  %_object29 = getelementptr inbounds %struct.cell, %struct.cell* %25, i32 0, i32 1
  %_cons30 = bitcast %union.anon* %_object29 to %struct.anon.4*
  %_car31 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons30, i32 0, i32 0
  %26 = load %struct.cell*, %struct.cell** %_car31, align 8
  %_object32 = getelementptr inbounds %struct.cell, %struct.cell* %26, i32 0, i32 1
  %_cons33 = bitcast %union.anon* %_object32 to %struct.anon.4*
  %_car34 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons33, i32 0, i32 0
  %27 = load %struct.cell*, %struct.cell** %_car34, align 8
  %cmp35 = icmp eq %struct.cell* %24, %27
  br i1 %cmp35, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %if.end.28
  br label %for.end

if.end.38:                                        ; preds = %if.end.28
  br label %for.inc

for.inc:                                          ; preds = %if.end.38
  %28 = load %struct.cell*, %struct.cell** %y, align 8
  %_object39 = getelementptr inbounds %struct.cell, %struct.cell* %28, i32 0, i32 1
  %_cons40 = bitcast %union.anon* %_object39 to %struct.anon.4*
  %_cdr41 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons40, i32 0, i32 1
  %29 = load %struct.cell*, %struct.cell** %_cdr41, align 8
  store %struct.cell* %29, %struct.cell** %y, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.37, %for.cond
  %30 = load %struct.cell*, %struct.cell** %y, align 8
  %call42 = call i32 @is_pair(%struct.cell* %30)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then.44, label %if.else

if.then.44:                                       ; preds = %for.end
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %32 = load %struct.cell*, %struct.cell** %y, align 8
  %_object45 = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 1
  %_cons46 = bitcast %union.anon* %_object45 to %struct.anon.4*
  %_car47 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons46, i32 0, i32 0
  %33 = load %struct.cell*, %struct.cell** %_car47, align 8
  %call48 = call %struct.cell* @_s_return(%struct.scheme* %31, %struct.cell* %33)
  store %struct.cell* %call48, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %for.end
  %34 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 21
  %36 = load %struct.cell*, %struct.cell** %F, align 8
  %call49 = call %struct.cell* @_s_return(%struct.scheme* %34, %struct.cell* %36)
  store %struct.cell* %call49, %struct.cell** %retval
  br label %return

sw.bb.50:                                         ; preds = %entry
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args51 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 7
  %38 = load %struct.cell*, %struct.cell** %args51, align 8
  %_object52 = getelementptr inbounds %struct.cell, %struct.cell* %38, i32 0, i32 1
  %_cons53 = bitcast %union.anon* %_object52 to %struct.anon.4*
  %_car54 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons53, i32 0, i32 0
  %39 = load %struct.cell*, %struct.cell** %_car54, align 8
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args55 = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 7
  store %struct.cell* %39, %struct.cell** %args55, align 8
  %41 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args56 = getelementptr inbounds %struct.scheme, %struct.scheme* %41, i32 0, i32 7
  %42 = load %struct.cell*, %struct.cell** %args56, align 8
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %43, i32 0, i32 17
  %44 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp57 = icmp eq %struct.cell* %42, %44
  br i1 %cmp57, label %if.then.59, label %if.else.62

if.then.59:                                       ; preds = %sw.bb.50
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F60 = getelementptr inbounds %struct.scheme, %struct.scheme* %46, i32 0, i32 21
  %47 = load %struct.cell*, %struct.cell** %F60, align 8
  %call61 = call %struct.cell* @_s_return(%struct.scheme* %45, %struct.cell* %47)
  store %struct.cell* %call61, %struct.cell** %retval
  br label %return

if.else.62:                                       ; preds = %sw.bb.50
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args63 = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 7
  %49 = load %struct.cell*, %struct.cell** %args63, align 8
  %call64 = call i32 @is_closure(%struct.cell* %49)
  %tobool65 = icmp ne i32 %call64, 0
  br i1 %tobool65, label %if.then.66, label %if.else.70

if.then.66:                                       ; preds = %if.else.62
  %50 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %51 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA = getelementptr inbounds %struct.scheme, %struct.scheme* %52, i32 0, i32 27
  %53 = load %struct.cell*, %struct.cell** %LAMBDA, align 8
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %54, i32 0, i32 54
  %55 = load %struct.cell*, %struct.cell** %value, align 8
  %call67 = call %struct.cell* @closure_code(%struct.cell* %55)
  %call68 = call %struct.cell* @_cons(%struct.scheme* %51, %struct.cell* %53, %struct.cell* %call67, i32 0)
  %call69 = call %struct.cell* @_s_return(%struct.scheme* %50, %struct.cell* %call68)
  store %struct.cell* %call69, %struct.cell** %retval
  br label %return

if.else.70:                                       ; preds = %if.else.62
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args71 = getelementptr inbounds %struct.scheme, %struct.scheme* %56, i32 0, i32 7
  %57 = load %struct.cell*, %struct.cell** %args71, align 8
  %call72 = call i32 @is_macro(%struct.cell* %57)
  %tobool73 = icmp ne i32 %call72, 0
  br i1 %tobool73, label %if.then.74, label %if.else.80

if.then.74:                                       ; preds = %if.else.70
  %58 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %59 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %60 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %LAMBDA75 = getelementptr inbounds %struct.scheme, %struct.scheme* %60, i32 0, i32 27
  %61 = load %struct.cell*, %struct.cell** %LAMBDA75, align 8
  %62 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value76 = getelementptr inbounds %struct.scheme, %struct.scheme* %62, i32 0, i32 54
  %63 = load %struct.cell*, %struct.cell** %value76, align 8
  %call77 = call %struct.cell* @closure_code(%struct.cell* %63)
  %call78 = call %struct.cell* @_cons(%struct.scheme* %59, %struct.cell* %61, %struct.cell* %call77, i32 0)
  %call79 = call %struct.cell* @_s_return(%struct.scheme* %58, %struct.cell* %call78)
  store %struct.cell* %call79, %struct.cell** %retval
  br label %return

if.else.80:                                       ; preds = %if.else.70
  %64 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F81 = getelementptr inbounds %struct.scheme, %struct.scheme* %65, i32 0, i32 21
  %66 = load %struct.cell*, %struct.cell** %F81, align 8
  %call82 = call %struct.cell* @_s_return(%struct.scheme* %64, %struct.cell* %66)
  store %struct.cell* %call82, %struct.cell** %retval
  br label %return

sw.bb.83:                                         ; preds = %entry
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args84 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 7
  %69 = load %struct.cell*, %struct.cell** %args84, align 8
  %_object85 = getelementptr inbounds %struct.cell, %struct.cell* %69, i32 0, i32 1
  %_cons86 = bitcast %union.anon* %_object85 to %struct.anon.4*
  %_car87 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons86, i32 0, i32 0
  %70 = load %struct.cell*, %struct.cell** %_car87, align 8
  %call88 = call i32 @is_closure(%struct.cell* %70)
  %tobool89 = icmp ne i32 %call88, 0
  br i1 %tobool89, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.bb.83
  %71 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %71, i32 0, i32 19
  %72 = load %struct.cell*, %struct.cell** %T, align 8
  br label %cond.end

cond.false:                                       ; preds = %sw.bb.83
  %73 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F90 = getelementptr inbounds %struct.scheme, %struct.scheme* %73, i32 0, i32 21
  %74 = load %struct.cell*, %struct.cell** %F90, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.cell* [ %72, %cond.true ], [ %74, %cond.false ]
  %call91 = call %struct.cell* @_s_return(%struct.scheme* %67, %struct.cell* %cond)
  store %struct.cell* %call91, %struct.cell** %retval
  br label %return

sw.bb.92:                                         ; preds = %entry
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %76 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args93 = getelementptr inbounds %struct.scheme, %struct.scheme* %76, i32 0, i32 7
  %77 = load %struct.cell*, %struct.cell** %args93, align 8
  %_object94 = getelementptr inbounds %struct.cell, %struct.cell* %77, i32 0, i32 1
  %_cons95 = bitcast %union.anon* %_object94 to %struct.anon.4*
  %_car96 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons95, i32 0, i32 0
  %78 = load %struct.cell*, %struct.cell** %_car96, align 8
  %call97 = call i32 @is_macro(%struct.cell* %78)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %cond.true.99, label %cond.false.101

cond.true.99:                                     ; preds = %sw.bb.92
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T100 = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 19
  %80 = load %struct.cell*, %struct.cell** %T100, align 8
  br label %cond.end.103

cond.false.101:                                   ; preds = %sw.bb.92
  %81 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F102 = getelementptr inbounds %struct.scheme, %struct.scheme* %81, i32 0, i32 21
  %82 = load %struct.cell*, %struct.cell** %F102, align 8
  br label %cond.end.103

cond.end.103:                                     ; preds = %cond.false.101, %cond.true.99
  %cond104 = phi %struct.cell* [ %80, %cond.true.99 ], [ %82, %cond.false.101 ]
  %call105 = call %struct.cell* @_s_return(%struct.scheme* %75, %struct.cell* %cond104)
  store %struct.cell* %call105, %struct.cell** %retval
  br label %return

sw.default:                                       ; preds = %entry
  %83 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %83, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  %84 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op106 = getelementptr inbounds %struct.scheme, %struct.scheme* %84, i32 0, i32 55
  %85 = load i32, i32* %op106, align 4
  %call107 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.189, i32 0, i32 0), i32 %85) #2
  %86 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %87 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff108 = getelementptr inbounds %struct.scheme, %struct.scheme* %87, i32 0, i32 50
  %arraydecay109 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff108, i32 0, i32 0
  %call110 = call %struct.cell* @_Error_1(%struct.scheme* %86, i8* %arraydecay109, %struct.cell* null)
  store %struct.cell* %call110, %struct.cell** %retval
  br label %return

return:                                           ; preds = %sw.default, %cond.end.103, %cond.end, %if.else.80, %if.then.74, %if.then.66, %if.then.59, %if.else, %if.then.44, %if.then.26, %if.end, %if.then
  %88 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %88
}

; Function Attrs: nounwind uwtable
define internal i32 @file_interactive(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 45
  %1 = load i32, i32* %file_i, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 0
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
  %cmp1 = icmp eq %struct._IO_FILE* %3, %4
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 39
  %6 = load %struct.cell*, %struct.cell** %inport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %7 = load %struct.port*, %struct.port** %_port, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 0
  %8 = load i8, i8* %kind, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %9 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %9 to i32
  ret i32 %land.ext
}

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...) #4

; Function Attrs: nounwind uwtable
define internal i32 @file_push(%struct.scheme* %sc, i8* %fname) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %fname.addr = alloca i8*, align 8
  %fin = alloca %struct._IO_FILE*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %fname, i8** %fname.addr, align 8
  store %struct._IO_FILE* null, %struct._IO_FILE** %fin, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 45
  %1 = load i32, i32* %file_i, align 4
  %cmp = icmp eq i32 %1, 63
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i8*, i8** %fname.addr, align 8
  %call = call %struct._IO_FILE* @fopen(i8* %2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.190, i32 0, i32 0))
  store %struct._IO_FILE* %call, %struct._IO_FILE** %fin, align 8
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** %fin, align 8
  %cmp1 = icmp ne %struct._IO_FILE* %3, null
  br i1 %cmp1, label %if.then.2, label %if.end.36

if.then.2:                                        ; preds = %if.end
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i3 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 45
  %5 = load i32, i32* %file_i3, align 4
  %inc = add nsw i32 %5, 1
  store i32 %inc, i32* %file_i3, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i4 = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 45
  %7 = load i32, i32* %file_i4, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom
  %kind = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 0
  store i8 17, i8* %kind, align 1
  %9 = load %struct._IO_FILE*, %struct._IO_FILE** %fin, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i5 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 45
  %11 = load i32, i32* %file_i5, align 4
  %idxprom6 = sext i32 %11 to i64
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack7 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 43
  %arrayidx8 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack7, i32 0, i64 %idxprom6
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx8, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  store %struct._IO_FILE* %9, %struct._IO_FILE** %file, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i9 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 45
  %14 = load i32, i32* %file_i9, align 4
  %idxprom10 = sext i32 %14 to i64
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack11 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 43
  %arrayidx12 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack11, i32 0, i64 %idxprom10
  %rep13 = getelementptr inbounds %struct.port, %struct.port* %arrayidx12, i32 0, i32 1
  %stdio14 = bitcast %union.anon.1* %rep13 to %struct.anon.2*
  %closeit = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio14, i32 0, i32 1
  store i32 1, i32* %closeit, align 4
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i15 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 45
  %17 = load i32, i32* %file_i15, align 4
  %idxprom16 = sext i32 %17 to i64
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 44
  %arrayidx17 = getelementptr inbounds [64 x i32], [64 x i32]* %nesting_stack, i32 0, i64 %idxprom16
  store i32 0, i32* %arrayidx17, align 4
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack18 = getelementptr inbounds %struct.scheme, %struct.scheme* %19, i32 0, i32 43
  %arraydecay = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack18, i32 0, i32 0
  %20 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i19 = getelementptr inbounds %struct.scheme, %struct.scheme* %20, i32 0, i32 45
  %21 = load i32, i32* %file_i19, align 4
  %idx.ext = sext i32 %21 to i64
  %add.ptr = getelementptr inbounds %struct.port, %struct.port* %arraydecay, i64 %idx.ext
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 42
  %23 = load %struct.cell*, %struct.cell** %loadport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %23, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  store %struct.port* %add.ptr, %struct.port** %_port, align 8
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i20 = getelementptr inbounds %struct.scheme, %struct.scheme* %24, i32 0, i32 45
  %25 = load i32, i32* %file_i20, align 4
  %idxprom21 = sext i32 %25 to i64
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack22 = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 43
  %arrayidx23 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack22, i32 0, i64 %idxprom21
  %rep24 = getelementptr inbounds %struct.port, %struct.port* %arrayidx23, i32 0, i32 1
  %stdio25 = bitcast %union.anon.1* %rep24 to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio25, i32 0, i32 2
  store i32 0, i32* %curr_line, align 4
  %27 = load i8*, i8** %fname.addr, align 8
  %tobool = icmp ne i8* %27, null
  br i1 %tobool, label %if.then.26, label %if.end.35

if.then.26:                                       ; preds = %if.then.2
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %29 = load i8*, i8** %fname.addr, align 8
  %call27 = call i64 @strlen(i8* %29) #6
  %conv = trunc i64 %call27 to i32
  %30 = load i8*, i8** %fname.addr, align 8
  %call28 = call i8* @store_string(%struct.scheme* %28, i32 %conv, i8* %30, i32 0)
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i29 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 45
  %32 = load i32, i32* %file_i29, align 4
  %idxprom30 = sext i32 %32 to i64
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack31 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 43
  %arrayidx32 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack31, i32 0, i64 %idxprom30
  %rep33 = getelementptr inbounds %struct.port, %struct.port* %arrayidx32, i32 0, i32 1
  %stdio34 = bitcast %union.anon.1* %rep33 to %struct.anon.2*
  %filename = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio34, i32 0, i32 3
  store i8* %call28, i8** %filename, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.26, %if.then.2
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.end
  %34 = load %struct._IO_FILE*, %struct._IO_FILE** %fin, align 8
  %cmp37 = icmp ne %struct._IO_FILE* %34, null
  %conv38 = zext i1 %cmp37 to i32
  store i32 %conv38, i32* %retval
  br label %return

return:                                           ; preds = %if.end.36, %if.then
  %35 = load i32, i32* %retval
  ret i32 %35
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @_Error_1(%struct.scheme* %sc, i8* %s, %struct.cell* %a) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %s.addr = alloca i8*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %str = alloca i8*, align 8
  %x = alloca %struct.cell*, align 8
  %hdl = alloca %struct.cell*, align 8
  %sbuf = alloca [1024 x i8], align 16
  %ln = alloca i32, align 4
  %fname = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %s, i8** %s.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load i8*, i8** %s.addr, align 8
  store i8* %0, i8** %str, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %ERROR_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 34
  %2 = load %struct.cell*, %struct.cell** %ERROR_HOOK, align 8
  store %struct.cell* %2, %struct.cell** %hdl, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 45
  %4 = load i32, i32* %file_i, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %7 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
  %cmp = icmp ne %struct._IO_FILE* %6, %7
  br i1 %cmp, label %if.then, label %if.end.15

if.then:                                          ; preds = %entry
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i1 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 45
  %9 = load i32, i32* %file_i1, align 4
  %idxprom2 = sext i32 %9 to i64
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack3 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 43
  %arrayidx4 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack3, i32 0, i64 %idxprom2
  %rep5 = getelementptr inbounds %struct.port, %struct.port* %arrayidx4, i32 0, i32 1
  %stdio6 = bitcast %union.anon.1* %rep5 to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio6, i32 0, i32 2
  %11 = load i32, i32* %curr_line, align 4
  store i32 %11, i32* %ln, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i7 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 45
  %13 = load i32, i32* %file_i7, align 4
  %idxprom8 = sext i32 %13 to i64
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack9 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 43
  %arrayidx10 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack9, i32 0, i64 %idxprom8
  %rep11 = getelementptr inbounds %struct.port, %struct.port* %arrayidx10, i32 0, i32 1
  %stdio12 = bitcast %union.anon.1* %rep11 to %struct.anon.2*
  %filename = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio12, i32 0, i32 3
  %15 = load i8*, i8** %filename, align 8
  store i8* %15, i8** %fname, align 8
  %16 = load i8*, i8** %fname, align 8
  %tobool = icmp ne i8* %16, null
  br i1 %tobool, label %if.end, label %if.then.13

if.then.13:                                       ; preds = %if.then
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.191, i32 0, i32 0), i8** %fname, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.13, %if.then
  %17 = load i32, i32* %ln, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %ln, align 4
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %sbuf, i32 0, i32 0
  %18 = load i8*, i8** %fname, align 8
  %19 = load i32, i32* %ln, align 4
  %20 = load i8*, i8** %s.addr, align 8
  %call = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.192, i32 0, i32 0), i8* %18, i32 %19, i8* %20) #2
  %arraydecay14 = getelementptr inbounds [1024 x i8], [1024 x i8]* %sbuf, i32 0, i32 0
  store i8* %arraydecay14, i8** %str, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.end, %entry
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 8
  %23 = load %struct.cell*, %struct.cell** %envir, align 8
  %24 = load %struct.cell*, %struct.cell** %hdl, align 8
  %call16 = call %struct.cell* @find_slot_in_env(%struct.scheme* %21, %struct.cell* %23, %struct.cell* %24, i32 1)
  store %struct.cell* %call16, %struct.cell** %x, align 8
  %25 = load %struct.cell*, %struct.cell** %x, align 8
  %26 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %26, i32 0, i32 17
  %27 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp17 = icmp ne %struct.cell* %25, %27
  br i1 %cmp17, label %if.then.18, label %if.end.38

if.then.18:                                       ; preds = %if.end.15
  %28 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %cmp19 = icmp ne %struct.cell* %28, null
  br i1 %cmp19, label %if.then.20, label %if.else

if.then.20:                                       ; preds = %if.then.18
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 28
  %32 = load %struct.cell*, %struct.cell** %QUOTE, align 8
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %34 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %35 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL21 = getelementptr inbounds %struct.scheme, %struct.scheme* %35, i32 0, i32 17
  %36 = load %struct.cell*, %struct.cell** %NIL21, align 8
  %call22 = call %struct.cell* @_cons(%struct.scheme* %33, %struct.cell* %34, %struct.cell* %36, i32 0)
  %call23 = call %struct.cell* @_cons(%struct.scheme* %30, %struct.cell* %32, %struct.cell* %call22, i32 0)
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL24 = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 17
  %38 = load %struct.cell*, %struct.cell** %NIL24, align 8
  %call25 = call %struct.cell* @_cons(%struct.scheme* %29, %struct.cell* %call23, %struct.cell* %38, i32 0)
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %39, i32 0, i32 9
  store %struct.cell* %call25, %struct.cell** %code, align 8
  br label %if.end.28

if.else:                                          ; preds = %if.then.18
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL26 = getelementptr inbounds %struct.scheme, %struct.scheme* %40, i32 0, i32 17
  %41 = load %struct.cell*, %struct.cell** %NIL26, align 8
  %42 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code27 = getelementptr inbounds %struct.scheme, %struct.scheme* %42, i32 0, i32 9
  store %struct.cell* %41, %struct.cell** %code27, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.else, %if.then.20
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %44 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %45 = load i8*, i8** %str, align 8
  %call29 = call %struct.cell* @mk_string(%struct.scheme* %44, i8* %45)
  %46 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code30 = getelementptr inbounds %struct.scheme, %struct.scheme* %46, i32 0, i32 9
  %47 = load %struct.cell*, %struct.cell** %code30, align 8
  %call31 = call %struct.cell* @_cons(%struct.scheme* %43, %struct.cell* %call29, %struct.cell* %47, i32 0)
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code32 = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 9
  store %struct.cell* %call31, %struct.cell** %code32, align 8
  %49 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code33 = getelementptr inbounds %struct.scheme, %struct.scheme* %49, i32 0, i32 9
  %50 = load %struct.cell*, %struct.cell** %code33, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %50, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %51 = load %struct.cell*, %struct.cell** %_car, align 8
  call void @setimmutable(%struct.cell* %51)
  %52 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %53 = load %struct.cell*, %struct.cell** %x, align 8
  %call34 = call %struct.cell* @slot_value_in_env(%struct.cell* %53)
  %54 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code35 = getelementptr inbounds %struct.scheme, %struct.scheme* %54, i32 0, i32 9
  %55 = load %struct.cell*, %struct.cell** %code35, align 8
  %call36 = call %struct.cell* @_cons(%struct.scheme* %52, %struct.cell* %call34, %struct.cell* %55, i32 0)
  %56 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code37 = getelementptr inbounds %struct.scheme, %struct.scheme* %56, i32 0, i32 9
  store %struct.cell* %call36, %struct.cell** %code37, align 8
  %57 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op = getelementptr inbounds %struct.scheme, %struct.scheme* %57, i32 0, i32 55
  store i32 6, i32* %op, align 4
  %58 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %58, i32 0, i32 19
  %59 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %59, %struct.cell** %retval
  br label %return

if.end.38:                                        ; preds = %if.end.15
  %60 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %cmp39 = icmp ne %struct.cell* %60, null
  br i1 %cmp39, label %if.then.40, label %if.else.43

if.then.40:                                       ; preds = %if.end.38
  %61 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %62 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %63 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL41 = getelementptr inbounds %struct.scheme, %struct.scheme* %63, i32 0, i32 17
  %64 = load %struct.cell*, %struct.cell** %NIL41, align 8
  %call42 = call %struct.cell* @_cons(%struct.scheme* %61, %struct.cell* %62, %struct.cell* %64, i32 0)
  %65 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %65, i32 0, i32 7
  store %struct.cell* %call42, %struct.cell** %args, align 8
  br label %if.end.46

if.else.43:                                       ; preds = %if.end.38
  %66 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL44 = getelementptr inbounds %struct.scheme, %struct.scheme* %66, i32 0, i32 17
  %67 = load %struct.cell*, %struct.cell** %NIL44, align 8
  %68 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args45 = getelementptr inbounds %struct.scheme, %struct.scheme* %68, i32 0, i32 7
  store %struct.cell* %67, %struct.cell** %args45, align 8
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.43, %if.then.40
  %69 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %70 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %71 = load i8*, i8** %str, align 8
  %call47 = call %struct.cell* @mk_string(%struct.scheme* %70, i8* %71)
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args48 = getelementptr inbounds %struct.scheme, %struct.scheme* %72, i32 0, i32 7
  %73 = load %struct.cell*, %struct.cell** %args48, align 8
  %call49 = call %struct.cell* @_cons(%struct.scheme* %69, %struct.cell* %call47, %struct.cell* %73, i32 0)
  %74 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args50 = getelementptr inbounds %struct.scheme, %struct.scheme* %74, i32 0, i32 7
  store %struct.cell* %call49, %struct.cell** %args50, align 8
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args51 = getelementptr inbounds %struct.scheme, %struct.scheme* %75, i32 0, i32 7
  %76 = load %struct.cell*, %struct.cell** %args51, align 8
  %_object52 = getelementptr inbounds %struct.cell, %struct.cell* %76, i32 0, i32 1
  %_cons53 = bitcast %union.anon* %_object52 to %struct.anon.4*
  %_car54 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons53, i32 0, i32 0
  %77 = load %struct.cell*, %struct.cell** %_car54, align 8
  call void @setimmutable(%struct.cell* %77)
  %78 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op55 = getelementptr inbounds %struct.scheme, %struct.scheme* %78, i32 0, i32 55
  store i32 134, i32* %op55, align 4
  %79 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T56 = getelementptr inbounds %struct.scheme, %struct.scheme* %79, i32 0, i32 19
  %80 = load %struct.cell*, %struct.cell** %T56, align 8
  store %struct.cell* %80, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.46, %if.end.28
  %81 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %81
}

; Function Attrs: nounwind uwtable
define internal void @file_pop(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 45
  %1 = load i32, i32* %file_i, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i1 = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 45
  %3 = load i32, i32* %file_i1, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 44
  %arrayidx = getelementptr inbounds [64 x i32], [64 x i32]* %nesting_stack, i32 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %nesting = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 46
  store i32 %5, i32* %nesting, align 4
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 42
  %9 = load %struct.cell*, %struct.cell** %loadport, align 8
  call void @port_close(%struct.scheme* %7, %struct.cell* %9, i32 16)
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i2 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 45
  %11 = load i32, i32* %file_i2, align 4
  %dec = add nsw i32 %11, -1
  store i32 %dec, i32* %file_i2, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 43
  %arraydecay = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i32 0
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i3 = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 45
  %14 = load i32, i32* %file_i3, align 4
  %idx.ext = sext i32 %14 to i64
  %add.ptr = getelementptr inbounds %struct.port, %struct.port* %arraydecay, i64 %idx.ext
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport4 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 42
  %16 = load %struct.cell*, %struct.cell** %loadport4, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %16, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  store %struct.port* %add.ptr, %struct.port** %_port, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @_s_return(%struct.scheme* %sc, %struct.cell* %a) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 54
  store %struct.cell* %0, %struct.cell** %value, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 10
  %3 = load %struct.cell*, %struct.cell** %dump, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 17
  %7 = load %struct.cell*, %struct.cell** %NIL1, align 8
  store %struct.cell* %7, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump2 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 10
  %9 = load %struct.cell*, %struct.cell** %dump2, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %10 = load %struct.cell*, %struct.cell** %_car, align 8
  %call = call i64 @ivalue(%struct.cell* %10)
  %conv = trunc i64 %call to i32
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %op = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 55
  store i32 %conv, i32* %op, align 4
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump3 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 10
  %13 = load %struct.cell*, %struct.cell** %dump3, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_cons5 = bitcast %union.anon* %_object4 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons5, i32 0, i32 1
  %14 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %_object6 = getelementptr inbounds %struct.cell, %struct.cell* %14, i32 0, i32 1
  %_cons7 = bitcast %union.anon* %_object6 to %struct.anon.4*
  %_car8 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons7, i32 0, i32 0
  %15 = load %struct.cell*, %struct.cell** %_car8, align 8
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %args = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 7
  store %struct.cell* %15, %struct.cell** %args, align 8
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump9 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 10
  %18 = load %struct.cell*, %struct.cell** %dump9, align 8
  %_object10 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 1
  %_cons11 = bitcast %union.anon* %_object10 to %struct.anon.4*
  %_cdr12 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons11, i32 0, i32 1
  %19 = load %struct.cell*, %struct.cell** %_cdr12, align 8
  %_object13 = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_cons14 = bitcast %union.anon* %_object13 to %struct.anon.4*
  %_cdr15 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons14, i32 0, i32 1
  %20 = load %struct.cell*, %struct.cell** %_cdr15, align 8
  %_object16 = getelementptr inbounds %struct.cell, %struct.cell* %20, i32 0, i32 1
  %_cons17 = bitcast %union.anon* %_object16 to %struct.anon.4*
  %_car18 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons17, i32 0, i32 0
  %21 = load %struct.cell*, %struct.cell** %_car18, align 8
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 8
  store %struct.cell* %21, %struct.cell** %envir, align 8
  %23 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump19 = getelementptr inbounds %struct.scheme, %struct.scheme* %23, i32 0, i32 10
  %24 = load %struct.cell*, %struct.cell** %dump19, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %24, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr22 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  %25 = load %struct.cell*, %struct.cell** %_cdr22, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %25, i32 0, i32 1
  %_cons24 = bitcast %union.anon* %_object23 to %struct.anon.4*
  %_cdr25 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons24, i32 0, i32 1
  %26 = load %struct.cell*, %struct.cell** %_cdr25, align 8
  %_object26 = getelementptr inbounds %struct.cell, %struct.cell* %26, i32 0, i32 1
  %_cons27 = bitcast %union.anon* %_object26 to %struct.anon.4*
  %_cdr28 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons27, i32 0, i32 1
  %27 = load %struct.cell*, %struct.cell** %_cdr28, align 8
  %_object29 = getelementptr inbounds %struct.cell, %struct.cell* %27, i32 0, i32 1
  %_cons30 = bitcast %union.anon* %_object29 to %struct.anon.4*
  %_car31 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons30, i32 0, i32 0
  %28 = load %struct.cell*, %struct.cell** %_car31, align 8
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %code = getelementptr inbounds %struct.scheme, %struct.scheme* %29, i32 0, i32 9
  store %struct.cell* %28, %struct.cell** %code, align 8
  %30 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump32 = getelementptr inbounds %struct.scheme, %struct.scheme* %30, i32 0, i32 10
  %31 = load %struct.cell*, %struct.cell** %dump32, align 8
  %_object33 = getelementptr inbounds %struct.cell, %struct.cell* %31, i32 0, i32 1
  %_cons34 = bitcast %union.anon* %_object33 to %struct.anon.4*
  %_cdr35 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons34, i32 0, i32 1
  %32 = load %struct.cell*, %struct.cell** %_cdr35, align 8
  %_object36 = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 1
  %_cons37 = bitcast %union.anon* %_object36 to %struct.anon.4*
  %_cdr38 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons37, i32 0, i32 1
  %33 = load %struct.cell*, %struct.cell** %_cdr38, align 8
  %_object39 = getelementptr inbounds %struct.cell, %struct.cell* %33, i32 0, i32 1
  %_cons40 = bitcast %union.anon* %_object39 to %struct.anon.4*
  %_cdr41 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons40, i32 0, i32 1
  %34 = load %struct.cell*, %struct.cell** %_cdr41, align 8
  %_object42 = getelementptr inbounds %struct.cell, %struct.cell* %34, i32 0, i32 1
  %_cons43 = bitcast %union.anon* %_object42 to %struct.anon.4*
  %_cdr44 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons43, i32 0, i32 1
  %35 = load %struct.cell*, %struct.cell** %_cdr44, align 8
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump45 = getelementptr inbounds %struct.scheme, %struct.scheme* %36, i32 0, i32 10
  store %struct.cell* %35, %struct.cell** %dump45, align 8
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %37, i32 0, i32 19
  %38 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %38, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %39 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %39
}

; Function Attrs: nounwind uwtable
define internal void @s_save(%struct.scheme* %sc, i32 %op, %struct.cell* %args, %struct.cell* %code) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %args.addr = alloca %struct.cell*, align 8
  %code.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  store %struct.cell* %args, %struct.cell** %args.addr, align 8
  store %struct.cell* %code, %struct.cell** %code.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %envir = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 8
  %2 = load %struct.cell*, %struct.cell** %envir, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %4 = load %struct.cell*, %struct.cell** %code.addr, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 10
  %6 = load %struct.cell*, %struct.cell** %dump, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %3, %struct.cell* %4, %struct.cell* %6, i32 0)
  %call1 = call %struct.cell* @_cons(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %call, i32 0)
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump2 = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 10
  store %struct.cell* %call1, %struct.cell** %dump2, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %9 = load %struct.cell*, %struct.cell** %args.addr, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump3 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 10
  %11 = load %struct.cell*, %struct.cell** %dump3, align 8
  %call4 = call %struct.cell* @_cons(%struct.scheme* %8, %struct.cell* %9, %struct.cell* %11, i32 0)
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump5 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 10
  store %struct.cell* %call4, %struct.cell** %dump5, align 8
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %15 = load i32, i32* %op.addr, align 4
  %conv = zext i32 %15 to i64
  %call6 = call %struct.cell* @mk_integer(%struct.scheme* %14, i64 %conv)
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump7 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 10
  %17 = load %struct.cell*, %struct.cell** %dump7, align 8
  %call8 = call %struct.cell* @_cons(%struct.scheme* %13, %struct.cell* %call6, %struct.cell* %17, i32 0)
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump9 = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 10
  store %struct.cell* %call8, %struct.cell** %dump9, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @token(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %c = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @skipspace(%struct.scheme* %0)
  store i32 %call, i32* %c, align 4
  %1 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call1 = call i32 @inchar(%struct.scheme* %2)
  store i32 %call1, i32* %c, align 4
  switch i32 %call1, label %sw.default [
    i32 -1, label %sw.bb
    i32 40, label %sw.bb.2
    i32 41, label %sw.bb.3
    i32 46, label %sw.bb.4
    i32 39, label %sw.bb.8
    i32 59, label %sw.bb.9
    i32 34, label %sw.bb.20
    i32 95, label %sw.bb.21
    i32 96, label %sw.bb.26
    i32 44, label %sw.bb.27
    i32 35, label %sw.bb.32
  ]

sw.bb:                                            ; preds = %if.end
  store i32 -1, i32* %retval
  br label %return

sw.bb.2:                                          ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

sw.bb.3:                                          ; preds = %if.end
  store i32 1, i32* %retval
  br label %return

sw.bb.4:                                          ; preds = %if.end
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call5 = call i32 @inchar(%struct.scheme* %3)
  store i32 %call5, i32* %c, align 4
  %4 = load i32, i32* %c, align 4
  %call6 = call i32 @is_one_of(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.193, i32 0, i32 0), i32 %4)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %sw.bb.4
  store i32 2, i32* %retval
  br label %return

if.else:                                          ; preds = %sw.bb.4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %6 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %5, i32 %6)
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @backchar(%struct.scheme* %7, i32 46)
  store i32 3, i32* %retval
  br label %return

sw.bb.8:                                          ; preds = %if.end
  store i32 4, i32* %retval
  br label %return

sw.bb.9:                                          ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb.9
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call10 = call i32 @inchar(%struct.scheme* %8)
  store i32 %call10, i32* %c, align 4
  %cmp11 = icmp ne i32 %call10, 10
  br i1 %cmp11, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %9 = load i32, i32* %c, align 4
  %cmp12 = icmp ne i32 %9, -1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %10 = phi i1 [ false, %while.cond ], [ %cmp12, %land.rhs ]
  br i1 %10, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %while.cond

while.end:                                        ; preds = %land.end
  %11 = load i32, i32* %c, align 4
  %cmp13 = icmp eq i32 %11, 10
  br i1 %cmp13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %while.end
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 45
  %13 = load i32, i32* %file_i, align 4
  %idxprom = sext i32 %13 to i64
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 2
  %15 = load i32, i32* %curr_line, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %curr_line, align 4
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.14, %while.end
  %16 = load i32, i32* %c, align 4
  %cmp16 = icmp eq i32 %16, -1
  br i1 %cmp16, label %if.then.17, label %if.else.18

if.then.17:                                       ; preds = %if.end.15
  store i32 -1, i32* %retval
  br label %return

if.else.18:                                       ; preds = %if.end.15
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call19 = call i32 @token(%struct.scheme* %17)
  store i32 %call19, i32* %retval
  br label %return

sw.bb.20:                                         ; preds = %if.end
  store i32 6, i32* %retval
  br label %return

sw.bb.21:                                         ; preds = %if.end
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call22 = call i32 @inchar(%struct.scheme* %18)
  store i32 %call22, i32* %c, align 4
  %cmp23 = icmp eq i32 %call22, 34
  br i1 %cmp23, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %sw.bb.21
  store i32 13, i32* %retval
  br label %return

if.end.25:                                        ; preds = %sw.bb.21
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %20 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %19, i32 %20)
  store i32 3, i32* %retval
  br label %return

sw.bb.26:                                         ; preds = %if.end
  store i32 7, i32* %retval
  br label %return

sw.bb.27:                                         ; preds = %if.end
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call28 = call i32 @inchar(%struct.scheme* %21)
  store i32 %call28, i32* %c, align 4
  %cmp29 = icmp eq i32 %call28, 64
  br i1 %cmp29, label %if.then.30, label %if.else.31

if.then.30:                                       ; preds = %sw.bb.27
  store i32 9, i32* %retval
  br label %return

if.else.31:                                       ; preds = %sw.bb.27
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %23 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %22, i32 %23)
  store i32 8, i32* %retval
  br label %return

sw.bb.32:                                         ; preds = %if.end
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call33 = call i32 @inchar(%struct.scheme* %24)
  store i32 %call33, i32* %c, align 4
  %25 = load i32, i32* %c, align 4
  %cmp34 = icmp eq i32 %25, 40
  br i1 %cmp34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %sw.bb.32
  store i32 12, i32* %retval
  br label %return

if.else.36:                                       ; preds = %sw.bb.32
  %26 = load i32, i32* %c, align 4
  %cmp37 = icmp eq i32 %26, 33
  br i1 %cmp37, label %if.then.38, label %if.else.62

if.then.38:                                       ; preds = %if.else.36
  br label %while.cond.39

while.cond.39:                                    ; preds = %while.body.45, %if.then.38
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call40 = call i32 @inchar(%struct.scheme* %27)
  store i32 %call40, i32* %c, align 4
  %cmp41 = icmp ne i32 %call40, 10
  br i1 %cmp41, label %land.rhs.42, label %land.end.44

land.rhs.42:                                      ; preds = %while.cond.39
  %28 = load i32, i32* %c, align 4
  %cmp43 = icmp ne i32 %28, -1
  br label %land.end.44

land.end.44:                                      ; preds = %land.rhs.42, %while.cond.39
  %29 = phi i1 [ false, %while.cond.39 ], [ %cmp43, %land.rhs.42 ]
  br i1 %29, label %while.body.45, label %while.end.46

while.body.45:                                    ; preds = %land.end.44
  br label %while.cond.39

while.end.46:                                     ; preds = %land.end.44
  %30 = load i32, i32* %c, align 4
  %cmp47 = icmp eq i32 %30, 10
  br i1 %cmp47, label %if.then.48, label %if.end.57

if.then.48:                                       ; preds = %while.end.46
  %31 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i49 = getelementptr inbounds %struct.scheme, %struct.scheme* %31, i32 0, i32 45
  %32 = load i32, i32* %file_i49, align 4
  %idxprom50 = sext i32 %32 to i64
  %33 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack51 = getelementptr inbounds %struct.scheme, %struct.scheme* %33, i32 0, i32 43
  %arrayidx52 = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack51, i32 0, i64 %idxprom50
  %rep53 = getelementptr inbounds %struct.port, %struct.port* %arrayidx52, i32 0, i32 1
  %stdio54 = bitcast %union.anon.1* %rep53 to %struct.anon.2*
  %curr_line55 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio54, i32 0, i32 2
  %34 = load i32, i32* %curr_line55, align 4
  %inc56 = add nsw i32 %34, 1
  store i32 %inc56, i32* %curr_line55, align 4
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.48, %while.end.46
  %35 = load i32, i32* %c, align 4
  %cmp58 = icmp eq i32 %35, -1
  br i1 %cmp58, label %if.then.59, label %if.else.60

if.then.59:                                       ; preds = %if.end.57
  store i32 -1, i32* %retval
  br label %return

if.else.60:                                       ; preds = %if.end.57
  %36 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call61 = call i32 @token(%struct.scheme* %36)
  store i32 %call61, i32* %retval
  br label %return

if.else.62:                                       ; preds = %if.else.36
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %38 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %37, i32 %38)
  %39 = load i32, i32* %c, align 4
  %call63 = call i32 @is_one_of(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.194, i32 0, i32 0), i32 %39)
  %tobool64 = icmp ne i32 %call63, 0
  br i1 %tobool64, label %if.then.65, label %if.else.66

if.then.65:                                       ; preds = %if.else.62
  store i32 11, i32* %retval
  br label %return

if.else.66:                                       ; preds = %if.else.62
  store i32 10, i32* %retval
  br label %return

sw.default:                                       ; preds = %if.end
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %41 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %40, i32 %41)
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %if.else.66, %if.then.65, %if.else.60, %if.then.59, %if.then.35, %if.else.31, %if.then.30, %sw.bb.26, %if.end.25, %if.then.24, %sw.bb.20, %if.else.18, %if.then.17, %sw.bb.8, %if.else, %if.then.7, %sw.bb.3, %sw.bb.2, %sw.bb, %if.then
  %42 = load i32, i32* %retval
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @slot_value_in_env(%struct.cell* %slot) #0 {
entry:
  %slot.addr = alloca %struct.cell*, align 8
  store %struct.cell* %slot, %struct.cell** %slot.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %slot.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %1 = load %struct.cell*, %struct.cell** %_cdr, align 8
  ret %struct.cell* %1
}

; Function Attrs: nounwind uwtable
define internal i32 @syntaxnum(%struct.cell* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %p.addr = alloca %struct.cell*, align 8
  %s = alloca i8*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %1 = load %struct.cell*, %struct.cell** %_car, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_string = bitcast %union.anon* %_object1 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %2 = load i8*, i8** %_svalue, align 8
  store i8* %2, i8** %s, align 8
  %3 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons3 = bitcast %union.anon* %_object2 to %struct.anon.4*
  %_car4 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons3, i32 0, i32 0
  %4 = load %struct.cell*, %struct.cell** %_car4, align 8
  %_object5 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_string6 = bitcast %union.anon* %_object5 to %struct.anon*
  %_length = getelementptr inbounds %struct.anon, %struct.anon* %_string6, i32 0, i32 1
  %5 = load i32, i32* %_length, align 4
  switch i32 %5, label %sw.default.34 [
    i32 2, label %sw.bb
    i32 3, label %sw.bb.8
    i32 4, label %sw.bb.15
    i32 5, label %sw.bb.21
    i32 6, label %sw.bb.28
  ]

sw.bb:                                            ; preds = %entry
  %6 = load i8*, i8** %s, align 8
  %arrayidx = getelementptr inbounds i8, i8* %6, i64 0
  %7 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %7 to i32
  %cmp = icmp eq i32 %conv, 105
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  store i32 22, i32* %retval
  br label %return

if.else:                                          ; preds = %sw.bb
  store i32 40, i32* %retval
  br label %return

sw.bb.8:                                          ; preds = %entry
  %8 = load i8*, i8** %s, align 8
  %arrayidx9 = getelementptr inbounds i8, i8* %8, i64 0
  %9 = load i8, i8* %arrayidx9, align 1
  %conv10 = sext i8 %9 to i32
  %cmp11 = icmp eq i32 %conv10, 97
  br i1 %cmp11, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %sw.bb.8
  store i32 38, i32* %retval
  br label %return

if.else.14:                                       ; preds = %sw.bb.8
  store i32 26, i32* %retval
  br label %return

sw.bb.15:                                         ; preds = %entry
  %10 = load i8*, i8** %s, align 8
  %arrayidx16 = getelementptr inbounds i8, i8* %10, i64 3
  %11 = load i8, i8* %arrayidx16, align 1
  %conv17 = sext i8 %11 to i32
  switch i32 %conv17, label %sw.default [
    i32 101, label %sw.bb.18
    i32 100, label %sw.bb.19
    i32 42, label %sw.bb.20
  ]

sw.bb.18:                                         ; preds = %sw.bb.15
  store i32 46, i32* %retval
  br label %return

sw.bb.19:                                         ; preds = %sw.bb.15
  store i32 35, i32* %retval
  br label %return

sw.bb.20:                                         ; preds = %sw.bb.15
  store i32 29, i32* %retval
  br label %return

sw.default:                                       ; preds = %sw.bb.15
  store i32 24, i32* %retval
  br label %return

sw.bb.21:                                         ; preds = %entry
  %12 = load i8*, i8** %s, align 8
  %arrayidx22 = getelementptr inbounds i8, i8* %12, i64 2
  %13 = load i8, i8* %arrayidx22, align 1
  %conv23 = sext i8 %13 to i32
  switch i32 %conv23, label %sw.default.27 [
    i32 103, label %sw.bb.24
    i32 108, label %sw.bb.25
    i32 99, label %sw.bb.26
  ]

sw.bb.24:                                         ; preds = %sw.bb.21
  store i32 21, i32* %retval
  br label %return

sw.bb.25:                                         ; preds = %sw.bb.21
  store i32 37, i32* %retval
  br label %return

sw.bb.26:                                         ; preds = %sw.bb.21
  store i32 44, i32* %retval
  br label %return

sw.default.27:                                    ; preds = %sw.bb.21
  store i32 17, i32* %retval
  br label %return

sw.bb.28:                                         ; preds = %entry
  %14 = load i8*, i8** %s, align 8
  %arrayidx29 = getelementptr inbounds i8, i8* %14, i64 2
  %15 = load i8, i8* %arrayidx29, align 1
  %conv30 = sext i8 %15 to i32
  switch i32 %conv30, label %sw.default.33 [
    i32 109, label %sw.bb.31
    i32 102, label %sw.bb.32
  ]

sw.bb.31:                                         ; preds = %sw.bb.28
  store i32 14, i32* %retval
  br label %return

sw.bb.32:                                         ; preds = %sw.bb.28
  store i32 18, i32* %retval
  br label %return

sw.default.33:                                    ; preds = %sw.bb.28
  store i32 32, i32* %retval
  br label %return

sw.default.34:                                    ; preds = %entry
  store i32 42, i32* %retval
  br label %return

return:                                           ; preds = %sw.default.34, %sw.default.33, %sw.bb.32, %sw.bb.31, %sw.default.27, %sw.bb.26, %sw.bb.25, %sw.bb.24, %sw.default, %sw.bb.20, %sw.bb.19, %sw.bb.18, %if.else.14, %if.then.13, %if.else, %if.then
  %16 = load i32, i32* %retval
  ret i32 %16
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @reverse_in_place(%struct.scheme* %sc, %struct.cell* %term, %struct.cell* %list) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %term.addr = alloca %struct.cell*, align 8
  %list.addr = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  %result = alloca %struct.cell*, align 8
  %q = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %term, %struct.cell** %term.addr, align 8
  store %struct.cell* %list, %struct.cell** %list.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %list.addr, align 8
  store %struct.cell* %0, %struct.cell** %p, align 8
  %1 = load %struct.cell*, %struct.cell** %term.addr, align 8
  store %struct.cell* %1, %struct.cell** %result, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.cell*, %struct.cell** %p, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp ne %struct.cell* %2, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load %struct.cell*, %struct.cell** %p, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %6 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %6, %struct.cell** %q, align 8
  %7 = load %struct.cell*, %struct.cell** %result, align 8
  %8 = load %struct.cell*, %struct.cell** %p, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_cdr3 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 1
  store %struct.cell* %7, %struct.cell** %_cdr3, align 8
  %9 = load %struct.cell*, %struct.cell** %p, align 8
  store %struct.cell* %9, %struct.cell** %result, align 8
  %10 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %10, %struct.cell** %p, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %11 = load %struct.cell*, %struct.cell** %result, align 8
  ret %struct.cell* %11
}

declare %struct._IO_FILE* @fopen(i8*, i8*) #4

; Function Attrs: nounwind uwtable
define internal void @port_close(%struct.scheme* %sc, %struct.cell* %p, i32 %flag) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca %struct.cell*, align 8
  %flag.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  store i32 %flag, i32* %flag.addr, align 4
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %1 = load %struct.port*, %struct.port** %_port, align 8
  store %struct.port* %1, %struct.port** %pt, align 8
  %2 = load i32, i32* %flag.addr, align 4
  %neg = xor i32 %2, -1
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %3, i32 0, i32 0
  %4 = load i8, i8* %kind, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, %neg
  %conv1 = trunc i32 %and to i8
  store i8 %conv1, i8* %kind, align 1
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %kind2 = getelementptr inbounds %struct.port, %struct.port* %5, i32 0, i32 0
  %6 = load i8, i8* %kind2, align 1
  %conv3 = zext i8 %6 to i32
  %and4 = and i32 %conv3, 48
  %cmp = icmp eq i32 %and4, 0
  br i1 %cmp, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %kind6 = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 0
  %8 = load i8, i8* %kind6, align 1
  %conv7 = zext i8 %8 to i32
  %and8 = and i32 %conv7, 1
  %tobool = icmp ne i32 %and8, 0
  br i1 %tobool, label %if.then.9, label %if.end.19

if.then.9:                                        ; preds = %if.then
  %9 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %9, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 2
  store i32 0, i32* %curr_line, align 4
  %10 = load %struct.port*, %struct.port** %pt, align 8
  %rep10 = getelementptr inbounds %struct.port, %struct.port* %10, i32 0, i32 1
  %stdio11 = bitcast %union.anon.1* %rep10 to %struct.anon.2*
  %filename = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio11, i32 0, i32 3
  %11 = load i8*, i8** %filename, align 8
  %tobool12 = icmp ne i8* %11, null
  br i1 %tobool12, label %if.then.13, label %if.end

if.then.13:                                       ; preds = %if.then.9
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 1
  %13 = load void (i8*)*, void (i8*)** %free, align 8
  %14 = load %struct.port*, %struct.port** %pt, align 8
  %rep14 = getelementptr inbounds %struct.port, %struct.port* %14, i32 0, i32 1
  %stdio15 = bitcast %union.anon.1* %rep14 to %struct.anon.2*
  %filename16 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio15, i32 0, i32 3
  %15 = load i8*, i8** %filename16, align 8
  call void %13(i8* %15)
  br label %if.end

if.end:                                           ; preds = %if.then.13, %if.then.9
  %16 = load %struct.port*, %struct.port** %pt, align 8
  %rep17 = getelementptr inbounds %struct.port, %struct.port* %16, i32 0, i32 1
  %stdio18 = bitcast %union.anon.1* %rep17 to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio18, i32 0, i32 0
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %call = call i32 @fclose(%struct._IO_FILE* %17)
  br label %if.end.19

if.end.19:                                        ; preds = %if.end, %if.then
  %18 = load %struct.port*, %struct.port** %pt, align 8
  %kind20 = getelementptr inbounds %struct.port, %struct.port* %18, i32 0, i32 0
  store i8 0, i8* %kind20, align 1
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.19, %entry
  ret void
}

declare i32 @fclose(%struct._IO_FILE*) #4

; Function Attrs: nounwind uwtable
define internal i32 @skipspace(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %c = alloca i32, align 4
  %curr_line = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 0, i32* %curr_line, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @inchar(%struct.scheme* %0)
  store i32 %call, i32* %c, align 4
  %1 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %1, 10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  %2 = load i32, i32* %curr_line, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %curr_line, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %3 = load i32, i32* %c, align 4
  %call1 = call i32 @g_unichar_isspace(i32 %3) #7
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %4 = load i32, i32* %curr_line, align 4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %file_i = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 45
  %6 = load i32, i32* %file_i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %load_stack = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 43
  %arrayidx = getelementptr inbounds [64 x %struct.port], [64 x %struct.port]* %load_stack, i32 0, i64 %idxprom
  %rep = getelementptr inbounds %struct.port, %struct.port* %arrayidx, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %curr_line2 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 2
  %8 = load i32, i32* %curr_line2, align 4
  %add = add nsw i32 %8, %4
  store i32 %add, i32* %curr_line2, align 4
  %9 = load i32, i32* %c, align 4
  %cmp3 = icmp ne i32 %9, -1
  br i1 %cmp3, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %do.end
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %10, i32 %11)
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %do.end
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.4
  %12 = load i32, i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind uwtable
define internal i32 @inchar(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca i32, align 4
  %sc.addr = alloca %struct.scheme*, align 8
  %c = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 39
  %1 = load %struct.cell*, %struct.cell** %inport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %2 = load %struct.port*, %struct.port** %_port, align 8
  store %struct.port* %2, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %3, i32 0, i32 0
  %4 = load i8, i8* %kind, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %kind1 = getelementptr inbounds %struct.port, %struct.port* %5, i32 0, i32 0
  %6 = load i8, i8* %kind1, align 1
  %conv2 = zext i8 %6 to i32
  %and3 = and i32 %conv2, 1
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then.5, label %if.else.10

if.then.5:                                        ; preds = %if.end
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %bc_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 62
  %8 = load i32, i32* %bc_flag, align 4
  %tobool6 = icmp ne i32 %8, 0
  br i1 %tobool6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.then.5
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %bc_flag8 = getelementptr inbounds %struct.scheme, %struct.scheme* %9, i32 0, i32 62
  %10 = load i32, i32* %bc_flag8, align 4
  %dec = add nsw i32 %10, -1
  store i32 %dec, i32* %bc_flag8, align 4
  %idxprom = sext i32 %dec to i64
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %backchar = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 61
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %backchar, i32 0, i64 %idxprom
  %12 = load i32, i32* %arrayidx, align 4
  store i32 %12, i32* %c, align 4
  br label %if.end.9

if.else:                                          ; preds = %if.then.5
  %13 = load %struct.port*, %struct.port** %pt, align 8
  %call = call i32 @basic_inchar(%struct.port* %13)
  store i32 %call, i32* %c, align 4
  br label %if.end.9

if.end.9:                                         ; preds = %if.else, %if.then.7
  br label %if.end.12

if.else.10:                                       ; preds = %if.end
  %14 = load %struct.port*, %struct.port** %pt, align 8
  %call11 = call i32 @basic_inchar(%struct.port* %14)
  store i32 %call11, i32* %c, align 4
  br label %if.end.12

if.end.12:                                        ; preds = %if.else.10, %if.end.9
  %15 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %15, -1
  br i1 %cmp, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %if.end.12
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport14 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 39
  %17 = load %struct.cell*, %struct.cell** %inport14, align 8
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %loadport = getelementptr inbounds %struct.scheme, %struct.scheme* %18, i32 0, i32 42
  %19 = load %struct.cell*, %struct.cell** %loadport, align 8
  %cmp15 = icmp eq %struct.cell* %17, %19
  br i1 %cmp15, label %if.then.17, label %if.end.21

if.then.17:                                       ; preds = %land.lhs.true
  %20 = load %struct.port*, %struct.port** %pt, align 8
  %kind18 = getelementptr inbounds %struct.port, %struct.port* %20, i32 0, i32 0
  %21 = load i8, i8* %kind18, align 1
  %conv19 = zext i8 %21 to i32
  %or = or i32 %conv19, 64
  %conv20 = trunc i32 %or to i8
  store i8 %conv20, i8* %kind18, align 1
  store i32 -1, i32* %retval
  br label %return

if.end.21:                                        ; preds = %land.lhs.true, %if.end.12
  %22 = load i32, i32* %c, align 4
  store i32 %22, i32* %retval
  br label %return

return:                                           ; preds = %if.end.21, %if.then.17, %if.then
  %23 = load i32, i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal i32 @is_one_of(i8* %s, i32 %c) #0 {
entry:
  %retval = alloca i32, align 4
  %s.addr = alloca i8*, align 8
  %c.addr = alloca i32, align 4
  store i8* %s, i8** %s.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %s.addr, align 8
  %2 = load i32, i32* %c.addr, align 4
  %call = call i8* @g_utf8_strchr(i8* %1, i64 -1, i32 %2)
  %cmp1 = icmp ne i8* %call, null
  br i1 %cmp1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store i32 1, i32* %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.3, %if.then.2, %if.then
  %3 = load i32, i32* %retval
  ret i32 %3
}

; Function Attrs: nounwind uwtable
define internal void @backchar(%struct.scheme* %sc, i32 %c) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %c.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  %charlen = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end.34

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_to_utf8(i32 %1, i8* null)
  store i32 %call, i32* %charlen, align 4
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %inport = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 39
  %3 = load %struct.cell*, %struct.cell** %inport, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_port = bitcast %union.anon* %_object to %struct.port**
  %4 = load %struct.port*, %struct.port** %_port, align 8
  store %struct.port* %4, %struct.port** %pt, align 8
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %5, i32 0, i32 0
  %6 = load i8, i8* %kind, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.1, label %if.else

if.then.1:                                        ; preds = %if.end
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %bc_flag = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 62
  %8 = load i32, i32* %bc_flag, align 4
  %cmp2 = icmp slt i32 %8, 2
  br i1 %cmp2, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.then.1
  %9 = load i32, i32* %c.addr, align 4
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %bc_flag5 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 62
  %11 = load i32, i32* %bc_flag5, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %bc_flag5, align 4
  %idxprom = sext i32 %11 to i64
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %backchar = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 61
  %arrayidx = getelementptr inbounds [2 x i32], [2 x i32]* %backchar, i32 0, i64 %idxprom
  store i32 %9, i32* %arrayidx, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.4, %if.then.1
  br label %if.end.34

if.else:                                          ; preds = %if.end
  %13 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %13, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 2
  %14 = load i8*, i8** %curr, align 8
  %15 = load %struct.port*, %struct.port** %pt, align 8
  %rep7 = getelementptr inbounds %struct.port, %struct.port* %15, i32 0, i32 1
  %string8 = bitcast %union.anon.1* %rep7 to %struct.anon.3*
  %start = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string8, i32 0, i32 0
  %16 = load i8*, i8** %start, align 8
  %cmp9 = icmp ne i8* %14, %16
  br i1 %cmp9, label %if.then.11, label %if.end.33

if.then.11:                                       ; preds = %if.else
  %17 = load %struct.port*, %struct.port** %pt, align 8
  %rep12 = getelementptr inbounds %struct.port, %struct.port* %17, i32 0, i32 1
  %string13 = bitcast %union.anon.1* %rep12 to %struct.anon.3*
  %curr14 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string13, i32 0, i32 2
  %18 = load i8*, i8** %curr14, align 8
  %19 = load %struct.port*, %struct.port** %pt, align 8
  %rep15 = getelementptr inbounds %struct.port, %struct.port* %19, i32 0, i32 1
  %string16 = bitcast %union.anon.1* %rep15 to %struct.anon.3*
  %start17 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string16, i32 0, i32 0
  %20 = load i8*, i8** %start17, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %18 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %20 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %21 = load i32, i32* %charlen, align 4
  %conv18 = sext i32 %21 to i64
  %cmp19 = icmp sge i64 %sub.ptr.sub, %conv18
  br i1 %cmp19, label %if.then.21, label %if.else.25

if.then.21:                                       ; preds = %if.then.11
  %22 = load i32, i32* %charlen, align 4
  %23 = load %struct.port*, %struct.port** %pt, align 8
  %rep22 = getelementptr inbounds %struct.port, %struct.port* %23, i32 0, i32 1
  %string23 = bitcast %union.anon.1* %rep22 to %struct.anon.3*
  %curr24 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string23, i32 0, i32 2
  %24 = load i8*, i8** %curr24, align 8
  %idx.ext = sext i32 %22 to i64
  %idx.neg = sub i64 0, %idx.ext
  %add.ptr = getelementptr inbounds i8, i8* %24, i64 %idx.neg
  store i8* %add.ptr, i8** %curr24, align 8
  br label %if.end.32

if.else.25:                                       ; preds = %if.then.11
  %25 = load %struct.port*, %struct.port** %pt, align 8
  %rep26 = getelementptr inbounds %struct.port, %struct.port* %25, i32 0, i32 1
  %string27 = bitcast %union.anon.1* %rep26 to %struct.anon.3*
  %start28 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string27, i32 0, i32 0
  %26 = load i8*, i8** %start28, align 8
  %27 = load %struct.port*, %struct.port** %pt, align 8
  %rep29 = getelementptr inbounds %struct.port, %struct.port* %27, i32 0, i32 1
  %string30 = bitcast %union.anon.1* %rep29 to %struct.anon.3*
  %curr31 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string30, i32 0, i32 2
  store i8* %26, i8** %curr31, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.25, %if.then.21
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.else
  br label %if.end.34

if.end.34:                                        ; preds = %if.then, %if.end.33, %if.end.6
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @g_unichar_isspace(i32) #5

; Function Attrs: nounwind uwtable
define internal i32 @basic_inchar(%struct.port* %pt) #0 {
entry:
  %retval = alloca i32, align 4
  %pt.addr = alloca %struct.port*, align 8
  %c = alloca i32, align 4
  %utf8 = alloca [7 x i8], align 1
  %len = alloca i32, align 4
  %i = alloca i32, align 4
  %c41 = alloca i32, align 4
  %len42 = alloca i32, align 4
  store %struct.port* %pt, %struct.port** %pt.addr, align 8
  %0 = load %struct.port*, %struct.port** %pt.addr, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %0, i32 0, i32 0
  %1 = load i8, i8* %kind, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else.40

if.then:                                          ; preds = %entry
  %2 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %2, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** %file, align 8
  %call = call i32 @fgetc(%struct._IO_FILE* %3)
  store i32 %call, i32* %c, align 4
  br label %while.body

while.body:                                       ; preds = %if.then, %if.end.39
  %4 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %while.body
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %while.body
  %5 = load i32, i32* %c, align 4
  %cmp3 = icmp sle i32 %5, 127
  br i1 %cmp3, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end
  %6 = load i32, i32* %c, align 4
  store i32 %6, i32* %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %7 = load i32, i32* %c, align 4
  %cmp7 = icmp slt i32 %7, 194
  br i1 %cmp7, label %if.then.11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.6
  %8 = load i32, i32* %c, align 4
  %cmp9 = icmp sgt i32 %8, 244
  br i1 %cmp9, label %if.then.11, label %if.else

if.then.11:                                       ; preds = %lor.lhs.false, %if.end.6
  %9 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep12 = getelementptr inbounds %struct.port, %struct.port* %9, i32 0, i32 1
  %stdio13 = bitcast %union.anon.1* %rep12 to %struct.anon.2*
  %file14 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio13, i32 0, i32 0
  %10 = load %struct._IO_FILE*, %struct._IO_FILE** %file14, align 8
  %call15 = call i32 @fgetc(%struct._IO_FILE* %10)
  store i32 %call15, i32* %c, align 4
  br label %if.end.39

if.else:                                          ; preds = %lor.lhs.false
  %11 = load i32, i32* %c, align 4
  %conv16 = trunc i32 %11 to i8
  %arrayidx = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i64 0
  store i8 %conv16, i8* %arrayidx, align 1
  %12 = load i32, i32* %c, align 4
  %and17 = and i32 %12, 63
  %idxprom = sext i32 %and17 to i64
  %arrayidx18 = getelementptr inbounds [64 x i8], [64 x i8]* @utf8_length, i32 0, i64 %idxprom
  %13 = load i8, i8* %arrayidx18, align 1
  %conv19 = sext i8 %13 to i32
  store i32 %conv19, i32* %len, align 4
  store i32 1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %len, align 4
  %cmp20 = icmp sle i32 %14, %15
  br i1 %cmp20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep22 = getelementptr inbounds %struct.port, %struct.port* %16, i32 0, i32 1
  %stdio23 = bitcast %union.anon.1* %rep22 to %struct.anon.2*
  %file24 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio23, i32 0, i32 0
  %17 = load %struct._IO_FILE*, %struct._IO_FILE** %file24, align 8
  %call25 = call i32 @fgetc(%struct._IO_FILE* %17)
  store i32 %call25, i32* %c, align 4
  %18 = load i32, i32* %c, align 4
  %and26 = and i32 %18, 192
  %cmp27 = icmp ne i32 %and26, 128
  br i1 %cmp27, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %for.body
  br label %for.end

if.end.30:                                        ; preds = %for.body
  %19 = load i32, i32* %c, align 4
  %conv31 = trunc i32 %19 to i8
  %20 = load i32, i32* %i, align 4
  %idxprom32 = sext i32 %20 to i64
  %arrayidx33 = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i64 %idxprom32
  store i8 %conv31, i8* %arrayidx33, align 1
  br label %for.inc

for.inc:                                          ; preds = %if.end.30
  %21 = load i32, i32* %i, align 4
  %inc = add nsw i32 %21, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then.29, %for.cond
  %22 = load i32, i32* %i, align 4
  %23 = load i32, i32* %len, align 4
  %cmp34 = icmp sgt i32 %22, %23
  br i1 %cmp34, label %if.then.36, label %if.end.38

if.then.36:                                       ; preds = %for.end
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %utf8, i32 0, i32 0
  %call37 = call i32 @g_utf8_get_char_validated(i8* %arraydecay, i64 7) #6
  store i32 %call37, i32* %retval
  br label %return

if.end.38:                                        ; preds = %for.end
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.11
  br label %while.body

if.else.40:                                       ; preds = %entry
  br label %while.body.43

while.body.43:                                    ; preds = %if.else.40, %if.end.77
  %24 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep44 = getelementptr inbounds %struct.port, %struct.port* %24, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep44 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 2
  %25 = load i8*, i8** %curr, align 8
  %26 = load i8, i8* %25, align 1
  %conv45 = sext i8 %26 to i32
  %cmp46 = icmp eq i32 %conv45, 0
  br i1 %cmp46, label %if.then.56, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %while.body.43
  %27 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep49 = getelementptr inbounds %struct.port, %struct.port* %27, i32 0, i32 1
  %string50 = bitcast %union.anon.1* %rep49 to %struct.anon.3*
  %curr51 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string50, i32 0, i32 2
  %28 = load i8*, i8** %curr51, align 8
  %29 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep52 = getelementptr inbounds %struct.port, %struct.port* %29, i32 0, i32 1
  %string53 = bitcast %union.anon.1* %rep52 to %struct.anon.3*
  %past_the_end = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string53, i32 0, i32 1
  %30 = load i8*, i8** %past_the_end, align 8
  %cmp54 = icmp eq i8* %28, %30
  br i1 %cmp54, label %if.then.56, label %if.end.57

if.then.56:                                       ; preds = %lor.lhs.false.48, %while.body.43
  store i32 -1, i32* %retval
  br label %return

if.end.57:                                        ; preds = %lor.lhs.false.48
  %31 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep58 = getelementptr inbounds %struct.port, %struct.port* %31, i32 0, i32 1
  %string59 = bitcast %union.anon.1* %rep58 to %struct.anon.3*
  %past_the_end60 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string59, i32 0, i32 1
  %32 = load i8*, i8** %past_the_end60, align 8
  %33 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep61 = getelementptr inbounds %struct.port, %struct.port* %33, i32 0, i32 1
  %string62 = bitcast %union.anon.1* %rep61 to %struct.anon.3*
  %curr63 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string62, i32 0, i32 2
  %34 = load i8*, i8** %curr63, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %32 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv64 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv64, i32* %len42, align 4
  %35 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep65 = getelementptr inbounds %struct.port, %struct.port* %35, i32 0, i32 1
  %string66 = bitcast %union.anon.1* %rep65 to %struct.anon.3*
  %curr67 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string66, i32 0, i32 2
  %36 = load i8*, i8** %curr67, align 8
  %37 = load i32, i32* %len42, align 4
  %conv68 = sext i32 %37 to i64
  %call69 = call i32 @g_utf8_get_char_validated(i8* %36, i64 %conv68) #6
  store i32 %call69, i32* %c41, align 4
  %38 = load i32, i32* %c41, align 4
  %cmp70 = icmp uge i32 %38, 0
  br i1 %cmp70, label %if.then.72, label %if.end.77

if.then.72:                                       ; preds = %if.end.57
  %39 = load i32, i32* %c41, align 4
  %call73 = call i32 @g_unichar_to_utf8(i32 %39, i8* null)
  store i32 %call73, i32* %len42, align 4
  %40 = load i32, i32* %len42, align 4
  %41 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep74 = getelementptr inbounds %struct.port, %struct.port* %41, i32 0, i32 1
  %string75 = bitcast %union.anon.1* %rep74 to %struct.anon.3*
  %curr76 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string75, i32 0, i32 2
  %42 = load i8*, i8** %curr76, align 8
  %idx.ext = sext i32 %40 to i64
  %add.ptr = getelementptr inbounds i8, i8* %42, i64 %idx.ext
  store i8* %add.ptr, i8** %curr76, align 8
  %43 = load i32, i32* %c41, align 4
  store i32 %43, i32* %retval
  br label %return

if.end.77:                                        ; preds = %if.end.57
  %44 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep78 = getelementptr inbounds %struct.port, %struct.port* %44, i32 0, i32 1
  %string79 = bitcast %union.anon.1* %rep78 to %struct.anon.3*
  %curr80 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string79, i32 0, i32 2
  %45 = load i8*, i8** %curr80, align 8
  %46 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep81 = getelementptr inbounds %struct.port, %struct.port* %46, i32 0, i32 1
  %string82 = bitcast %union.anon.1* %rep81 to %struct.anon.3*
  %past_the_end83 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string82, i32 0, i32 1
  %47 = load i8*, i8** %past_the_end83, align 8
  %call84 = call i8* @g_utf8_find_next_char(i8* %45, i8* %47) #6
  %48 = load %struct.port*, %struct.port** %pt.addr, align 8
  %rep85 = getelementptr inbounds %struct.port, %struct.port* %48, i32 0, i32 1
  %string86 = bitcast %union.anon.1* %rep85 to %struct.anon.3*
  %curr87 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string86, i32 0, i32 2
  store i8* %call84, i8** %curr87, align 8
  br label %while.body.43

return:                                           ; preds = %if.then.72, %if.then.56, %if.then.36, %if.then.5, %if.then.2
  %49 = load i32, i32* %retval
  ret i32 %49
}

declare i32 @fgetc(%struct._IO_FILE*) #4

; Function Attrs: nounwind readonly
declare i32 @g_utf8_get_char_validated(i8*, i64) #1

; Function Attrs: nounwind readonly
declare i8* @g_utf8_find_next_char(i8*, i8*) #1

declare i8* @g_utf8_strchr(i8*, i64, i32) #4

; Function Attrs: nounwind uwtable
define internal %struct.cell* @list_star(%struct.scheme* %sc, %struct.cell* %d) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %d.addr = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  %q = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %d, %struct.cell** %d.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %0, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %1 = load %struct.cell*, %struct.cell** %_cdr, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %1, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_cons2 = bitcast %union.anon* %_object1 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons2, i32 0, i32 0
  %5 = load %struct.cell*, %struct.cell** %_car, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %_object3 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons4 = bitcast %union.anon* %_object3 to %struct.anon.4*
  %_car5 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons4, i32 0, i32 0
  %8 = load %struct.cell*, %struct.cell** %_car5, align 8
  %9 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %_object6 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_cons7 = bitcast %union.anon* %_object6 to %struct.anon.4*
  %_cdr8 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons7, i32 0, i32 1
  %10 = load %struct.cell*, %struct.cell** %_cdr8, align 8
  %call = call %struct.cell* @_cons(%struct.scheme* %6, %struct.cell* %8, %struct.cell* %10, i32 0)
  store %struct.cell* %call, %struct.cell** %p, align 8
  %11 = load %struct.cell*, %struct.cell** %p, align 8
  store %struct.cell* %11, %struct.cell** %q, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.36, %if.end
  %12 = load %struct.cell*, %struct.cell** %p, align 8
  %_object9 = getelementptr inbounds %struct.cell, %struct.cell* %12, i32 0, i32 1
  %_cons10 = bitcast %union.anon* %_object9 to %struct.anon.4*
  %_cdr11 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons10, i32 0, i32 1
  %13 = load %struct.cell*, %struct.cell** %_cdr11, align 8
  %_object12 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 1
  %_cons13 = bitcast %union.anon* %_object12 to %struct.anon.4*
  %_cdr14 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons13, i32 0, i32 1
  %14 = load %struct.cell*, %struct.cell** %_cdr14, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL15 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 17
  %16 = load %struct.cell*, %struct.cell** %NIL15, align 8
  %cmp16 = icmp ne %struct.cell* %14, %16
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %18 = load %struct.cell*, %struct.cell** %p, align 8
  %_object17 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 1
  %_cons18 = bitcast %union.anon* %_object17 to %struct.anon.4*
  %_car19 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons18, i32 0, i32 0
  %19 = load %struct.cell*, %struct.cell** %_car19, align 8
  %20 = load %struct.cell*, %struct.cell** %p, align 8
  %_object20 = getelementptr inbounds %struct.cell, %struct.cell* %20, i32 0, i32 1
  %_cons21 = bitcast %union.anon* %_object20 to %struct.anon.4*
  %_cdr22 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons21, i32 0, i32 1
  %21 = load %struct.cell*, %struct.cell** %_cdr22, align 8
  %call23 = call %struct.cell* @_cons(%struct.scheme* %17, %struct.cell* %19, %struct.cell* %21, i32 0)
  store %struct.cell* %call23, %struct.cell** %d.addr, align 8
  %22 = load %struct.cell*, %struct.cell** %p, align 8
  %_object24 = getelementptr inbounds %struct.cell, %struct.cell* %22, i32 0, i32 1
  %_cons25 = bitcast %union.anon* %_object24 to %struct.anon.4*
  %_cdr26 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons25, i32 0, i32 1
  %23 = load %struct.cell*, %struct.cell** %_cdr26, align 8
  %_object27 = getelementptr inbounds %struct.cell, %struct.cell* %23, i32 0, i32 1
  %_cons28 = bitcast %union.anon* %_object27 to %struct.anon.4*
  %_cdr29 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons28, i32 0, i32 1
  %24 = load %struct.cell*, %struct.cell** %_cdr29, align 8
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL30 = getelementptr inbounds %struct.scheme, %struct.scheme* %25, i32 0, i32 17
  %26 = load %struct.cell*, %struct.cell** %NIL30, align 8
  %cmp31 = icmp ne %struct.cell* %24, %26
  br i1 %cmp31, label %if.then.32, label %if.end.36

if.then.32:                                       ; preds = %while.body
  %27 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %_object33 = getelementptr inbounds %struct.cell, %struct.cell* %27, i32 0, i32 1
  %_cons34 = bitcast %union.anon* %_object33 to %struct.anon.4*
  %_cdr35 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons34, i32 0, i32 1
  %28 = load %struct.cell*, %struct.cell** %_cdr35, align 8
  store %struct.cell* %28, %struct.cell** %p, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.32, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %29 = load %struct.cell*, %struct.cell** %p, align 8
  %_object37 = getelementptr inbounds %struct.cell, %struct.cell* %29, i32 0, i32 1
  %_cons38 = bitcast %union.anon* %_object37 to %struct.anon.4*
  %_cdr39 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons38, i32 0, i32 1
  %30 = load %struct.cell*, %struct.cell** %_cdr39, align 8
  %_object40 = getelementptr inbounds %struct.cell, %struct.cell* %30, i32 0, i32 1
  %_cons41 = bitcast %union.anon* %_object40 to %struct.anon.4*
  %_car42 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons41, i32 0, i32 0
  %31 = load %struct.cell*, %struct.cell** %_car42, align 8
  %32 = load %struct.cell*, %struct.cell** %p, align 8
  %_object43 = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 1
  %_cons44 = bitcast %union.anon* %_object43 to %struct.anon.4*
  %_cdr45 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons44, i32 0, i32 1
  store %struct.cell* %31, %struct.cell** %_cdr45, align 8
  %33 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %33, %struct.cell** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %34 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %34
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_continuation(%struct.scheme* %sc, %struct.cell* %d) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %d.addr = alloca %struct.cell*, align 8
  %x = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %d, %struct.cell** %d.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %3)
  store %struct.cell* %call, %struct.cell** %x, align 8
  %4 = load %struct.cell*, %struct.cell** %x, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 0
  store i32 7, i32* %_flag, align 4
  %5 = load %struct.cell*, %struct.cell** %d.addr, align 8
  %6 = load %struct.cell*, %struct.cell** %x, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  store %struct.cell* %5, %struct.cell** %_cdr, align 8
  %7 = load %struct.cell*, %struct.cell** %x, align 8
  ret %struct.cell* %7
}

; Function Attrs: nounwind
declare double @modf(double, double*) #3

; Function Attrs: nounwind
declare double @exp(double) #3

; Function Attrs: nounwind
declare double @log(double) #3

; Function Attrs: nounwind
declare double @sin(double) #3

; Function Attrs: nounwind
declare double @cos(double) #3

; Function Attrs: nounwind
declare double @tan(double) #3

; Function Attrs: nounwind
declare double @asin(double) #3

; Function Attrs: nounwind
declare double @acos(double) #3

; Function Attrs: nounwind
declare double @atan(double) #3

; Function Attrs: nounwind
declare double @atan2(double, double) #3

; Function Attrs: nounwind
declare double @sqrt(double) #3

; Function Attrs: nounwind
declare double @pow(double, double) #3

; Function Attrs: nounwind readnone
declare double @floor(double) #5

; Function Attrs: nounwind readnone
declare double @ceil(double) #5

; Function Attrs: nounwind uwtable
define internal double @round_per_R5RS(double %x) #0 {
entry:
  %retval = alloca double, align 8
  %x.addr = alloca double, align 8
  %fl = alloca double, align 8
  %ce = alloca double, align 8
  %dfl = alloca double, align 8
  %dce = alloca double, align 8
  store double %x, double* %x.addr, align 8
  %0 = load double, double* %x.addr, align 8
  %call = call double @floor(double %0) #7
  store double %call, double* %fl, align 8
  %1 = load double, double* %x.addr, align 8
  %call1 = call double @ceil(double %1) #7
  store double %call1, double* %ce, align 8
  %2 = load double, double* %x.addr, align 8
  %3 = load double, double* %fl, align 8
  %sub = fsub double %2, %3
  store double %sub, double* %dfl, align 8
  %4 = load double, double* %ce, align 8
  %5 = load double, double* %x.addr, align 8
  %sub2 = fsub double %4, %5
  store double %sub2, double* %dce, align 8
  %6 = load double, double* %dfl, align 8
  %7 = load double, double* %dce, align 8
  %cmp = fcmp ogt double %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load double, double* %ce, align 8
  store double %8, double* %retval
  br label %return

if.else:                                          ; preds = %entry
  %9 = load double, double* %dfl, align 8
  %10 = load double, double* %dce, align 8
  %cmp3 = fcmp olt double %9, %10
  br i1 %cmp3, label %if.then.4, label %if.else.5

if.then.4:                                        ; preds = %if.else
  %11 = load double, double* %fl, align 8
  store double %11, double* %retval
  br label %return

if.else.5:                                        ; preds = %if.else
  %12 = load double, double* %fl, align 8
  %call6 = call double @fmod(double %12, double 2.000000e+00) #2
  %cmp7 = fcmp oeq double %call6, 0.000000e+00
  br i1 %cmp7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.else.5
  %13 = load double, double* %fl, align 8
  store double %13, double* %retval
  br label %return

if.else.9:                                        ; preds = %if.else.5
  %14 = load double, double* %ce, align 8
  store double %14, double* %retval
  br label %return

return:                                           ; preds = %if.else.9, %if.then.8, %if.then.4, %if.then
  %15 = load double, double* %retval
  ret double %15
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_add(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %tobool7 = icmp ne i8 %9, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value8 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue9 = bitcast %union.anon.0* %value8 to i64*
  %11 = load i64, i64* %ivalue9, align 8
  %add = add nsw i64 %10, %11
  %value10 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue11 = bitcast %union.anon.0* %value10 to i64*
  store i64 %add, i64* %ivalue11, align 8
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum12, align 1
  %tobool13 = icmp ne i8 %12, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value14 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value14 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value15 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %14 = load i64, i64* %ivalue16, align 8
  %conv17 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv17, %cond.false ]
  %is_fixnum18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum18, align 1
  %tobool19 = icmp ne i8 %15, 0
  br i1 %tobool19, label %cond.false.23, label %cond.true.20

cond.true.20:                                     ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue22 = bitcast %union.anon.0* %value21 to double*
  %16 = load double, double* %rvalue22, align 8
  br label %cond.end.27

cond.false.23:                                    ; preds = %cond.end
  %value24 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue25 = bitcast %union.anon.0* %value24 to i64*
  %17 = load i64, i64* %ivalue25, align 8
  %conv26 = sitofp i64 %17 to double
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.false.23, %cond.true.20
  %cond28 = phi double [ %16, %cond.true.20 ], [ %conv26, %cond.false.23 ]
  %add29 = fadd double %cond, %cond28
  %value30 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %rvalue31 = bitcast %union.anon.0* %value30 to double*
  store double %add29, double* %rvalue31, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.27, %if.then
  %18 = bitcast %struct.num* %retval to i8*
  %19 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false)
  %20 = bitcast %struct.num* %retval to { i8, i64 }*
  %21 = load { i8, i64 }, { i8, i64 }* %20, align 8
  ret { i8, i64 } %21
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_number(%struct.scheme* %sc, i8 %n.coerce0, i64 %n.coerce1) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %n = alloca %struct.num, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %0 = bitcast %struct.num* %n to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %n.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %n.coerce1, i64* %2
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %n, i32 0, i32 0
  %3 = load i8, i8* %is_fixnum, align 1
  %tobool = icmp ne i8 %3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value = getelementptr inbounds %struct.num, %struct.num* %n, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %5 = load i64, i64* %ivalue, align 8
  %call = call %struct.cell* @mk_integer(%struct.scheme* %4, i64 %5)
  store %struct.cell* %call, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %value1 = getelementptr inbounds %struct.num, %struct.num* %n, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value1 to double*
  %7 = load double, double* %rvalue, align 8
  %call2 = call %struct.cell* @mk_real(%struct.scheme* %6, double %7)
  store %struct.cell* %call2, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_mul(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %tobool7 = icmp ne i8 %9, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value8 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue9 = bitcast %union.anon.0* %value8 to i64*
  %11 = load i64, i64* %ivalue9, align 8
  %mul = mul nsw i64 %10, %11
  %value10 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue11 = bitcast %union.anon.0* %value10 to i64*
  store i64 %mul, i64* %ivalue11, align 8
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum12, align 1
  %tobool13 = icmp ne i8 %12, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value14 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value14 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value15 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %14 = load i64, i64* %ivalue16, align 8
  %conv17 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv17, %cond.false ]
  %is_fixnum18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum18, align 1
  %tobool19 = icmp ne i8 %15, 0
  br i1 %tobool19, label %cond.false.23, label %cond.true.20

cond.true.20:                                     ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue22 = bitcast %union.anon.0* %value21 to double*
  %16 = load double, double* %rvalue22, align 8
  br label %cond.end.27

cond.false.23:                                    ; preds = %cond.end
  %value24 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue25 = bitcast %union.anon.0* %value24 to i64*
  %17 = load i64, i64* %ivalue25, align 8
  %conv26 = sitofp i64 %17 to double
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.false.23, %cond.true.20
  %cond28 = phi double [ %16, %cond.true.20 ], [ %conv26, %cond.false.23 ]
  %mul29 = fmul double %cond, %cond28
  %value30 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %rvalue31 = bitcast %union.anon.0* %value30 to double*
  store double %mul29, double* %rvalue31, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.27, %if.then
  %18 = bitcast %struct.num* %retval to i8*
  %19 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false)
  %20 = bitcast %struct.num* %retval to { i8, i64 }*
  %21 = load { i8, i64 }, { i8, i64 }* %20, align 8
  ret { i8, i64 } %21
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_sub(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %tobool7 = icmp ne i8 %9, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value8 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue9 = bitcast %union.anon.0* %value8 to i64*
  %11 = load i64, i64* %ivalue9, align 8
  %sub = sub nsw i64 %10, %11
  %value10 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue11 = bitcast %union.anon.0* %value10 to i64*
  store i64 %sub, i64* %ivalue11, align 8
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum12, align 1
  %tobool13 = icmp ne i8 %12, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value14 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value14 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value15 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %14 = load i64, i64* %ivalue16, align 8
  %conv17 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv17, %cond.false ]
  %is_fixnum18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum18, align 1
  %tobool19 = icmp ne i8 %15, 0
  br i1 %tobool19, label %cond.false.23, label %cond.true.20

cond.true.20:                                     ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue22 = bitcast %union.anon.0* %value21 to double*
  %16 = load double, double* %rvalue22, align 8
  br label %cond.end.27

cond.false.23:                                    ; preds = %cond.end
  %value24 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue25 = bitcast %union.anon.0* %value24 to i64*
  %17 = load i64, i64* %ivalue25, align 8
  %conv26 = sitofp i64 %17 to double
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.false.23, %cond.true.20
  %cond28 = phi double [ %16, %cond.true.20 ], [ %conv26, %cond.false.23 ]
  %sub29 = fsub double %cond, %cond28
  %value30 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %rvalue31 = bitcast %union.anon.0* %value30 to double*
  store double %sub29, double* %rvalue31, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.27, %if.then
  %18 = bitcast %struct.num* %retval to i8*
  %19 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false)
  %20 = bitcast %struct.num* %retval to { i8, i64 }*
  %21 = load { i8, i64 }, { i8, i64 }* %20, align 8
  ret { i8, i64 } %21
}

; Function Attrs: nounwind uwtable
define internal i32 @is_zero_double(double %x) #0 {
entry:
  %x.addr = alloca double, align 8
  store double %x, double* %x.addr, align 8
  %0 = load double, double* %x.addr, align 8
  %cmp = fcmp olt double %0, 0x10000000000000
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load double, double* %x.addr, align 8
  %cmp1 = fcmp ogt double %1, 0x8010000000000000
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %cmp1, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_div(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %8 = load i64, i64* %ivalue, align 8
  %value4 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue5 = bitcast %union.anon.0* %value4 to i64*
  %9 = load i64, i64* %ivalue5, align 8
  %rem = srem i64 %8, %9
  %cmp = icmp eq i64 %rem, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %10 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp, %land.rhs ]
  %land.ext = zext i1 %10 to i32
  %conv7 = trunc i32 %land.ext to i8
  %is_fixnum8 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv7, i8* %is_fixnum8, align 1
  %is_fixnum9 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  %11 = load i8, i8* %is_fixnum9, align 1
  %tobool10 = icmp ne i8 %11, 0
  br i1 %tobool10, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value11 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue12 = bitcast %union.anon.0* %value11 to i64*
  %12 = load i64, i64* %ivalue12, align 8
  %value13 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue14 = bitcast %union.anon.0* %value13 to i64*
  %13 = load i64, i64* %ivalue14, align 8
  %div = sdiv i64 %12, %13
  %value15 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  store i64 %div, i64* %ivalue16, align 8
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum17 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %14 = load i8, i8* %is_fixnum17, align 1
  %tobool18 = icmp ne i8 %14, 0
  br i1 %tobool18, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value19 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value19 to double*
  %15 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value20 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue21 = bitcast %union.anon.0* %value20 to i64*
  %16 = load i64, i64* %ivalue21, align 8
  %conv22 = sitofp i64 %16 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %15, %cond.true ], [ %conv22, %cond.false ]
  %is_fixnum23 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %17 = load i8, i8* %is_fixnum23, align 1
  %tobool24 = icmp ne i8 %17, 0
  br i1 %tobool24, label %cond.false.28, label %cond.true.25

cond.true.25:                                     ; preds = %cond.end
  %value26 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue27 = bitcast %union.anon.0* %value26 to double*
  %18 = load double, double* %rvalue27, align 8
  br label %cond.end.32

cond.false.28:                                    ; preds = %cond.end
  %value29 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue30 = bitcast %union.anon.0* %value29 to i64*
  %19 = load i64, i64* %ivalue30, align 8
  %conv31 = sitofp i64 %19 to double
  br label %cond.end.32

cond.end.32:                                      ; preds = %cond.false.28, %cond.true.25
  %cond33 = phi double [ %18, %cond.true.25 ], [ %conv31, %cond.false.28 ]
  %div34 = fdiv double %cond, %cond33
  %value35 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %rvalue36 = bitcast %union.anon.0* %value35 to double*
  store double %div34, double* %rvalue36, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.32, %if.then
  %20 = bitcast %struct.num* %retval to i8*
  %21 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 16, i32 8, i1 false)
  %22 = bitcast %struct.num* %retval to { i8, i64 }*
  %23 = load { i8, i64 }, { i8, i64 }* %22, align 8
  ret { i8, i64 } %23
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_intdiv(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %tobool7 = icmp ne i8 %9, 0
  br i1 %tobool7, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value8 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue9 = bitcast %union.anon.0* %value8 to i64*
  %11 = load i64, i64* %ivalue9, align 8
  %div = sdiv i64 %10, %11
  %value10 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue11 = bitcast %union.anon.0* %value10 to i64*
  store i64 %div, i64* %ivalue11, align 8
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum12, align 1
  %tobool13 = icmp ne i8 %12, 0
  br i1 %tobool13, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value14 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value14 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value15 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %14 = load i64, i64* %ivalue16, align 8
  %conv17 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv17, %cond.false ]
  %is_fixnum18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum18, align 1
  %tobool19 = icmp ne i8 %15, 0
  br i1 %tobool19, label %cond.false.23, label %cond.true.20

cond.true.20:                                     ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue22 = bitcast %union.anon.0* %value21 to double*
  %16 = load double, double* %rvalue22, align 8
  br label %cond.end.27

cond.false.23:                                    ; preds = %cond.end
  %value24 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue25 = bitcast %union.anon.0* %value24 to i64*
  %17 = load i64, i64* %ivalue25, align 8
  %conv26 = sitofp i64 %17 to double
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.false.23, %cond.true.20
  %cond28 = phi double [ %16, %cond.true.20 ], [ %conv26, %cond.false.23 ]
  %div29 = fdiv double %cond, %cond28
  %value30 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %rvalue31 = bitcast %union.anon.0* %value30 to double*
  store double %div29, double* %rvalue31, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.27, %if.then
  %18 = bitcast %struct.num* %retval to i8*
  %19 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* %19, i64 16, i32 8, i1 false)
  %20 = bitcast %struct.num* %retval to { i8, i64 }*
  %21 = load { i8, i64 }, { i8, i64 }* %20, align 8
  ret { i8, i64 } %21
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_rem(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %e1 = alloca i64, align 8
  %e2 = alloca i64, align 8
  %res = alloca i64, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %conv7 = sext i8 %9 to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %value9 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value9 to double*
  %11 = load double, double* %rvalue, align 8
  %conv10 = fptosi double %11 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %conv10, %cond.false ]
  store i64 %cond, i64* %e1, align 8
  %is_fixnum11 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum11, align 1
  %conv12 = sext i8 %12 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true.14, label %cond.false.17

cond.true.14:                                     ; preds = %cond.end
  %value15 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %13 = load i64, i64* %ivalue16, align 8
  br label %cond.end.21

cond.false.17:                                    ; preds = %cond.end
  %value18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue19 = bitcast %union.anon.0* %value18 to double*
  %14 = load double, double* %rvalue19, align 8
  %conv20 = fptosi double %14 to i64
  br label %cond.end.21

cond.end.21:                                      ; preds = %cond.false.17, %cond.true.14
  %cond22 = phi i64 [ %13, %cond.true.14 ], [ %conv20, %cond.false.17 ]
  store i64 %cond22, i64* %e2, align 8
  %15 = load i64, i64* %e1, align 8
  %16 = load i64, i64* %e2, align 8
  %rem = srem i64 %15, %16
  store i64 %rem, i64* %res, align 8
  %17 = load i64, i64* %res, align 8
  %cmp = icmp sgt i64 %17, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end.21
  %18 = load i64, i64* %e1, align 8
  %cmp24 = icmp slt i64 %18, 0
  br i1 %cmp24, label %if.then.26, label %if.end

if.then.26:                                       ; preds = %if.then
  %19 = load i64, i64* %e2, align 8
  %call = call i64 @labs(i64 %19) #7
  %20 = load i64, i64* %res, align 8
  %sub = sub nsw i64 %20, %call
  store i64 %sub, i64* %res, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.26, %if.then
  br label %if.end.36

if.else:                                          ; preds = %cond.end.21
  %21 = load i64, i64* %res, align 8
  %cmp27 = icmp slt i64 %21, 0
  br i1 %cmp27, label %if.then.29, label %if.end.35

if.then.29:                                       ; preds = %if.else
  %22 = load i64, i64* %e1, align 8
  %cmp30 = icmp sgt i64 %22, 0
  br i1 %cmp30, label %if.then.32, label %if.end.34

if.then.32:                                       ; preds = %if.then.29
  %23 = load i64, i64* %e2, align 8
  %call33 = call i64 @labs(i64 %23) #7
  %24 = load i64, i64* %res, align 8
  %add = add nsw i64 %24, %call33
  store i64 %add, i64* %res, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.32, %if.then.29
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34, %if.else
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.end
  %25 = load i64, i64* %res, align 8
  %value37 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue38 = bitcast %union.anon.0* %value37 to i64*
  store i64 %25, i64* %ivalue38, align 8
  %26 = bitcast %struct.num* %retval to i8*
  %27 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %27, i64 16, i32 8, i1 false)
  %28 = bitcast %struct.num* %retval to { i8, i64 }*
  %29 = load { i8, i64 }, { i8, i64 }* %28, align 8
  ret { i8, i64 } %29
}

; Function Attrs: nounwind uwtable
define internal { i8, i64 } @num_mod(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %retval = alloca %struct.num, align 8
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca %struct.num, align 8
  %e1 = alloca i64, align 8
  %e2 = alloca i64, align 8
  %res = alloca i64, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum1, align 1
  %conv2 = sext i8 %7 to i32
  %tobool3 = icmp ne i32 %conv2, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  %conv4 = trunc i32 %land.ext to i8
  %is_fixnum5 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 0
  store i8 %conv4, i8* %is_fixnum5, align 1
  %is_fixnum6 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %9 = load i8, i8* %is_fixnum6, align 1
  %conv7 = sext i8 %9 to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.end
  %value9 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value9 to double*
  %11 = load double, double* %rvalue, align 8
  %conv10 = fptosi double %11 to i64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %conv10, %cond.false ]
  store i64 %cond, i64* %e1, align 8
  %is_fixnum11 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum11, align 1
  %conv12 = sext i8 %12 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %cond.true.14, label %cond.false.17

cond.true.14:                                     ; preds = %cond.end
  %value15 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue16 = bitcast %union.anon.0* %value15 to i64*
  %13 = load i64, i64* %ivalue16, align 8
  br label %cond.end.21

cond.false.17:                                    ; preds = %cond.end
  %value18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue19 = bitcast %union.anon.0* %value18 to double*
  %14 = load double, double* %rvalue19, align 8
  %conv20 = fptosi double %14 to i64
  br label %cond.end.21

cond.end.21:                                      ; preds = %cond.false.17, %cond.true.14
  %cond22 = phi i64 [ %13, %cond.true.14 ], [ %conv20, %cond.false.17 ]
  store i64 %cond22, i64* %e2, align 8
  %15 = load i64, i64* %e1, align 8
  %16 = load i64, i64* %e2, align 8
  %rem = srem i64 %15, %16
  store i64 %rem, i64* %res, align 8
  %17 = load i64, i64* %res, align 8
  %cmp = icmp slt i64 %17, 0
  %conv23 = zext i1 %cmp to i32
  %18 = load i64, i64* %e2, align 8
  %cmp24 = icmp slt i64 %18, 0
  %conv25 = zext i1 %cmp24 to i32
  %cmp26 = icmp ne i32 %conv23, %conv25
  br i1 %cmp26, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end.21
  %19 = load i64, i64* %res, align 8
  %tobool28 = icmp ne i64 %19, 0
  br i1 %tobool28, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %20 = load i64, i64* %e2, align 8
  %21 = load i64, i64* %res, align 8
  %add = add nsw i64 %21, %20
  store i64 %add, i64* %res, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end.21
  %22 = load i64, i64* %res, align 8
  %value29 = getelementptr inbounds %struct.num, %struct.num* %ret, i32 0, i32 1
  %ivalue30 = bitcast %union.anon.0* %value29 to i64*
  store i64 %22, i64* %ivalue30, align 8
  %23 = bitcast %struct.num* %retval to i8*
  %24 = bitcast %struct.num* %ret to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %24, i64 16, i32 8, i1 false)
  %25 = bitcast %struct.num* %retval to { i8, i64 }*
  %26 = load { i8, i64 }, { i8, i64 }* %25, align 8
  ret { i8, i64 } %26
}

; Function Attrs: nounwind readnone
declare i32 @g_unichar_toupper(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_tolower(i32) #5

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_sharp_const(%struct.scheme* %sc, i8* %name) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %name.addr = alloca i8*, align 8
  %x = alloca i64, align 8
  %tmp = alloca [1024 x i8], align 16
  %c = alloca i32, align 4
  %c1 = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %call = call i32 @strcmp(i8* %0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.217, i32 0, i32 0)) #6
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 19
  %2 = load %struct.cell*, %struct.cell** %T, align 8
  store %struct.cell* %2, %struct.cell** %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i8*, i8** %name.addr, align 8
  %call1 = call i32 @strcmp(i8* %3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.218, i32 0, i32 0)) #6
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.else.4, label %if.then.3

if.then.3:                                        ; preds = %if.else
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 21
  %5 = load %struct.cell*, %struct.cell** %F, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

if.else.4:                                        ; preds = %if.else
  %6 = load i8*, i8** %name.addr, align 8
  %7 = load i8, i8* %6, align 1
  %conv = sext i8 %7 to i32
  %cmp = icmp eq i32 %conv, 111
  br i1 %cmp, label %if.then.6, label %if.else.11

if.then.6:                                        ; preds = %if.else.4
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %8 = load i8*, i8** %name.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %8, i64 1
  %call7 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay, i64 1024, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.219, i32 0, i32 0), i8* %add.ptr) #2
  %arraydecay8 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %call9 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %arraydecay8, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.220, i32 0, i32 0), i64* %x) #2
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %10 = load i64, i64* %x, align 8
  %call10 = call %struct.cell* @mk_integer(%struct.scheme* %9, i64 %10)
  store %struct.cell* %call10, %struct.cell** %retval
  br label %return

if.else.11:                                       ; preds = %if.else.4
  %11 = load i8*, i8** %name.addr, align 8
  %12 = load i8, i8* %11, align 1
  %conv12 = sext i8 %12 to i32
  %cmp13 = icmp eq i32 %conv12, 100
  br i1 %cmp13, label %if.then.15, label %if.else.19

if.then.15:                                       ; preds = %if.else.11
  %13 = load i8*, i8** %name.addr, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %13, i64 1
  %call17 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %add.ptr16, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.221, i32 0, i32 0), i64* %x) #2
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %15 = load i64, i64* %x, align 8
  %call18 = call %struct.cell* @mk_integer(%struct.scheme* %14, i64 %15)
  store %struct.cell* %call18, %struct.cell** %retval
  br label %return

if.else.19:                                       ; preds = %if.else.11
  %16 = load i8*, i8** %name.addr, align 8
  %17 = load i8, i8* %16, align 1
  %conv20 = sext i8 %17 to i32
  %cmp21 = icmp eq i32 %conv20, 120
  br i1 %cmp21, label %if.then.23, label %if.else.30

if.then.23:                                       ; preds = %if.else.19
  %arraydecay24 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %18 = load i8*, i8** %name.addr, align 8
  %add.ptr25 = getelementptr inbounds i8, i8* %18, i64 1
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %arraydecay24, i64 1024, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.222, i32 0, i32 0), i8* %add.ptr25) #2
  %arraydecay27 = getelementptr inbounds [1024 x i8], [1024 x i8]* %tmp, i32 0, i32 0
  %call28 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %arraydecay27, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.223, i32 0, i32 0), i64* %x) #2
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %20 = load i64, i64* %x, align 8
  %call29 = call %struct.cell* @mk_integer(%struct.scheme* %19, i64 %20)
  store %struct.cell* %call29, %struct.cell** %retval
  br label %return

if.else.30:                                       ; preds = %if.else.19
  %21 = load i8*, i8** %name.addr, align 8
  %22 = load i8, i8* %21, align 1
  %conv31 = sext i8 %22 to i32
  %cmp32 = icmp eq i32 %conv31, 98
  br i1 %cmp32, label %if.then.34, label %if.else.38

if.then.34:                                       ; preds = %if.else.30
  %23 = load i8*, i8** %name.addr, align 8
  %add.ptr35 = getelementptr inbounds i8, i8* %23, i64 1
  %call36 = call i64 @binary_decode(i8* %add.ptr35)
  store i64 %call36, i64* %x, align 8
  %24 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %25 = load i64, i64* %x, align 8
  %call37 = call %struct.cell* @mk_integer(%struct.scheme* %24, i64 %25)
  store %struct.cell* %call37, %struct.cell** %retval
  br label %return

if.else.38:                                       ; preds = %if.else.30
  %26 = load i8*, i8** %name.addr, align 8
  %27 = load i8, i8* %26, align 1
  %conv39 = sext i8 %27 to i32
  %cmp40 = icmp eq i32 %conv39, 92
  br i1 %cmp40, label %if.then.42, label %if.else.103

if.then.42:                                       ; preds = %if.else.38
  store i32 0, i32* %c, align 4
  %28 = load i8*, i8** %name.addr, align 8
  %add.ptr44 = getelementptr inbounds i8, i8* %28, i64 1
  %call45 = call i32 @utf8_stricmp(i8* %add.ptr44, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.224, i32 0, i32 0))
  %cmp46 = icmp eq i32 %call45, 0
  br i1 %cmp46, label %if.then.48, label %if.else.49

if.then.48:                                       ; preds = %if.then.42
  store i32 32, i32* %c, align 4
  br label %if.end.101

if.else.49:                                       ; preds = %if.then.42
  %29 = load i8*, i8** %name.addr, align 8
  %add.ptr50 = getelementptr inbounds i8, i8* %29, i64 1
  %call51 = call i32 @utf8_stricmp(i8* %add.ptr50, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.135, i32 0, i32 0))
  %cmp52 = icmp eq i32 %call51, 0
  br i1 %cmp52, label %if.then.54, label %if.else.55

if.then.54:                                       ; preds = %if.else.49
  store i32 10, i32* %c, align 4
  br label %if.end.100

if.else.55:                                       ; preds = %if.else.49
  %30 = load i8*, i8** %name.addr, align 8
  %add.ptr56 = getelementptr inbounds i8, i8* %30, i64 1
  %call57 = call i32 @utf8_stricmp(i8* %add.ptr56, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.225, i32 0, i32 0))
  %cmp58 = icmp eq i32 %call57, 0
  br i1 %cmp58, label %if.then.60, label %if.else.61

if.then.60:                                       ; preds = %if.else.55
  store i32 13, i32* %c, align 4
  br label %if.end.99

if.else.61:                                       ; preds = %if.else.55
  %31 = load i8*, i8** %name.addr, align 8
  %add.ptr62 = getelementptr inbounds i8, i8* %31, i64 1
  %call63 = call i32 @utf8_stricmp(i8* %add.ptr62, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.226, i32 0, i32 0))
  %cmp64 = icmp eq i32 %call63, 0
  br i1 %cmp64, label %if.then.66, label %if.else.67

if.then.66:                                       ; preds = %if.else.61
  store i32 9, i32* %c, align 4
  br label %if.end.98

if.else.67:                                       ; preds = %if.else.61
  %32 = load i8*, i8** %name.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %32, i64 1
  %33 = load i8, i8* %arrayidx, align 1
  %conv68 = sext i8 %33 to i32
  %cmp69 = icmp eq i32 %conv68, 120
  br i1 %cmp69, label %land.lhs.true, label %if.else.86

land.lhs.true:                                    ; preds = %if.else.67
  %34 = load i8*, i8** %name.addr, align 8
  %arrayidx71 = getelementptr inbounds i8, i8* %34, i64 2
  %35 = load i8, i8* %arrayidx71, align 1
  %conv72 = sext i8 %35 to i32
  %cmp73 = icmp ne i32 %conv72, 0
  br i1 %cmp73, label %if.then.75, label %if.else.86

if.then.75:                                       ; preds = %land.lhs.true
  store i32 0, i32* %c1, align 4
  %36 = load i8*, i8** %name.addr, align 8
  %add.ptr77 = getelementptr inbounds i8, i8* %36, i64 2
  %call78 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %add.ptr77, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.227, i32 0, i32 0), i32* %c1) #2
  %cmp79 = icmp eq i32 %call78, 1
  br i1 %cmp79, label %land.lhs.true.81, label %if.else.85

land.lhs.true.81:                                 ; preds = %if.then.75
  %37 = load i32, i32* %c1, align 4
  %cmp82 = icmp slt i32 %37, 255
  br i1 %cmp82, label %if.then.84, label %if.else.85

if.then.84:                                       ; preds = %land.lhs.true.81
  %38 = load i32, i32* %c1, align 4
  store i32 %38, i32* %c, align 4
  br label %if.end

if.else.85:                                       ; preds = %land.lhs.true.81, %if.then.75
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %39, i32 0, i32 17
  %40 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %40, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %if.then.84
  br label %if.end.97

if.else.86:                                       ; preds = %land.lhs.true, %if.else.67
  %41 = load i8*, i8** %name.addr, align 8
  %arrayidx87 = getelementptr inbounds i8, i8* %41, i64 2
  %42 = load i8, i8* %arrayidx87, align 1
  %conv88 = sext i8 %42 to i32
  %cmp89 = icmp eq i32 %conv88, 0
  br i1 %cmp89, label %if.then.91, label %if.else.94

if.then.91:                                       ; preds = %if.else.86
  %43 = load i8*, i8** %name.addr, align 8
  %arrayidx92 = getelementptr inbounds i8, i8* %43, i64 1
  %44 = load i8, i8* %arrayidx92, align 1
  %conv93 = sext i8 %44 to i32
  store i32 %conv93, i32* %c, align 4
  br label %if.end.96

if.else.94:                                       ; preds = %if.else.86
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL95 = getelementptr inbounds %struct.scheme, %struct.scheme* %45, i32 0, i32 17
  %46 = load %struct.cell*, %struct.cell** %NIL95, align 8
  store %struct.cell* %46, %struct.cell** %retval
  br label %return

if.end.96:                                        ; preds = %if.then.91
  br label %if.end.97

if.end.97:                                        ; preds = %if.end.96, %if.end
  br label %if.end.98

if.end.98:                                        ; preds = %if.end.97, %if.then.66
  br label %if.end.99

if.end.99:                                        ; preds = %if.end.98, %if.then.60
  br label %if.end.100

if.end.100:                                       ; preds = %if.end.99, %if.then.54
  br label %if.end.101

if.end.101:                                       ; preds = %if.end.100, %if.then.48
  %47 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %48 = load i32, i32* %c, align 4
  %call102 = call %struct.cell* @mk_character(%struct.scheme* %47, i32 %48)
  store %struct.cell* %call102, %struct.cell** %retval
  br label %return

if.else.103:                                      ; preds = %if.else.38
  %49 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL104 = getelementptr inbounds %struct.scheme, %struct.scheme* %49, i32 0, i32 17
  %50 = load %struct.cell*, %struct.cell** %NIL104, align 8
  store %struct.cell* %50, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.else.103, %if.end.101, %if.else.94, %if.else.85, %if.then.34, %if.then.23, %if.then.15, %if.then.6, %if.then.3, %if.then
  %51 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %51
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_atom(%struct.scheme* %sc, i8* %q) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %q.addr = alloca i8*, align 8
  %c = alloca i8, align 1
  %p = alloca i8*, align 8
  %has_dec_point = alloca i32, align 4
  %has_fp_exp = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %q, i8** %q.addr, align 8
  store i32 0, i32* %has_dec_point, align 4
  store i32 0, i32* %has_fp_exp, align 4
  %0 = load i8*, i8** %q.addr, align 8
  %call = call i8* @strstr(i8* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.228, i32 0, i32 0)) #6
  store i8* %call, i8** %p, align 8
  %cmp = icmp ne i8* %call, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %p, align 8
  store i8 0, i8* %1, align 1
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %COLON_HOOK = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 33
  %4 = load %struct.cell*, %struct.cell** %COLON_HOOK, align 8
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %QUOTE = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 28
  %8 = load %struct.cell*, %struct.cell** %QUOTE, align 8
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load i8*, i8** %p, align 8
  %add.ptr = getelementptr inbounds i8, i8* %11, i64 2
  %call1 = call %struct.cell* @mk_atom(%struct.scheme* %10, i8* %add.ptr)
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 17
  %13 = load %struct.cell*, %struct.cell** %NIL, align 8
  %call2 = call %struct.cell* @_cons(%struct.scheme* %9, %struct.cell* %call1, %struct.cell* %13, i32 0)
  %call3 = call %struct.cell* @_cons(%struct.scheme* %6, %struct.cell* %8, %struct.cell* %call2, i32 0)
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %16 = load i8*, i8** %q.addr, align 8
  %call4 = call %struct.cell* @mk_symbol(%struct.scheme* %15, i8* %16)
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL5 = getelementptr inbounds %struct.scheme, %struct.scheme* %17, i32 0, i32 17
  %18 = load %struct.cell*, %struct.cell** %NIL5, align 8
  %call6 = call %struct.cell* @_cons(%struct.scheme* %14, %struct.cell* %call4, %struct.cell* %18, i32 0)
  %call7 = call %struct.cell* @_cons(%struct.scheme* %5, %struct.cell* %call3, %struct.cell* %call6, i32 0)
  %call8 = call %struct.cell* @_cons(%struct.scheme* %2, %struct.cell* %4, %struct.cell* %call7, i32 0)
  store %struct.cell* %call8, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %19 = load i8*, i8** %q.addr, align 8
  store i8* %19, i8** %p, align 8
  %20 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %20, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %21 = load i8, i8* %20, align 1
  store i8 %21, i8* %c, align 1
  %22 = load i8, i8* %c, align 1
  %conv = sext i8 %22 to i32
  %cmp9 = icmp eq i32 %conv, 43
  br i1 %cmp9, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %23 = load i8, i8* %c, align 1
  %conv11 = sext i8 %23 to i32
  %cmp12 = icmp eq i32 %conv11, 45
  br i1 %cmp12, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %lor.lhs.false, %if.end
  %24 = load i8*, i8** %p, align 8
  %incdec.ptr15 = getelementptr inbounds i8, i8* %24, i32 1
  store i8* %incdec.ptr15, i8** %p, align 8
  %25 = load i8, i8* %24, align 1
  store i8 %25, i8* %c, align 1
  %26 = load i8, i8* %c, align 1
  %conv16 = sext i8 %26 to i32
  %cmp17 = icmp eq i32 %conv16, 46
  br i1 %cmp17, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.then.14
  store i32 1, i32* %has_dec_point, align 4
  %27 = load i8*, i8** %p, align 8
  %incdec.ptr20 = getelementptr inbounds i8, i8* %27, i32 1
  store i8* %incdec.ptr20, i8** %p, align 8
  %28 = load i8, i8* %27, align 1
  store i8 %28, i8* %c, align 1
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.then.14
  %29 = load i8, i8* %c, align 1
  %conv22 = sext i8 %29 to i32
  %idxprom = sext i32 %conv22 to i64
  %call23 = call i16** @__ctype_b_loc() #7
  %30 = load i16*, i16** %call23, align 8
  %arrayidx = getelementptr inbounds i16, i16* %30, i64 %idxprom
  %31 = load i16, i16* %arrayidx, align 2
  %conv24 = zext i16 %31 to i32
  %and = and i32 %conv24, 2048
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end.27, label %if.then.25

if.then.25:                                       ; preds = %if.end.21
  %32 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %33 = load i8*, i8** %q.addr, align 8
  %call26 = call %struct.cell* @mk_symbol(%struct.scheme* %32, i8* %33)
  store %struct.cell* %call26, %struct.cell** %retval
  br label %return

if.end.27:                                        ; preds = %if.end.21
  br label %if.end.55

if.else:                                          ; preds = %lor.lhs.false
  %34 = load i8, i8* %c, align 1
  %conv28 = sext i8 %34 to i32
  %cmp29 = icmp eq i32 %conv28, 46
  br i1 %cmp29, label %if.then.31, label %if.else.43

if.then.31:                                       ; preds = %if.else
  store i32 1, i32* %has_dec_point, align 4
  %35 = load i8*, i8** %p, align 8
  %incdec.ptr32 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr32, i8** %p, align 8
  %36 = load i8, i8* %35, align 1
  store i8 %36, i8* %c, align 1
  %37 = load i8, i8* %c, align 1
  %conv33 = sext i8 %37 to i32
  %idxprom34 = sext i32 %conv33 to i64
  %call35 = call i16** @__ctype_b_loc() #7
  %38 = load i16*, i16** %call35, align 8
  %arrayidx36 = getelementptr inbounds i16, i16* %38, i64 %idxprom34
  %39 = load i16, i16* %arrayidx36, align 2
  %conv37 = zext i16 %39 to i32
  %and38 = and i32 %conv37, 2048
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.end.42, label %if.then.40

if.then.40:                                       ; preds = %if.then.31
  %40 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %41 = load i8*, i8** %q.addr, align 8
  %call41 = call %struct.cell* @mk_symbol(%struct.scheme* %40, i8* %41)
  store %struct.cell* %call41, %struct.cell** %retval
  br label %return

if.end.42:                                        ; preds = %if.then.31
  br label %if.end.54

if.else.43:                                       ; preds = %if.else
  %42 = load i8, i8* %c, align 1
  %conv44 = sext i8 %42 to i32
  %idxprom45 = sext i32 %conv44 to i64
  %call46 = call i16** @__ctype_b_loc() #7
  %43 = load i16*, i16** %call46, align 8
  %arrayidx47 = getelementptr inbounds i16, i16* %43, i64 %idxprom45
  %44 = load i16, i16* %arrayidx47, align 2
  %conv48 = zext i16 %44 to i32
  %and49 = and i32 %conv48, 2048
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %if.end.53, label %if.then.51

if.then.51:                                       ; preds = %if.else.43
  %45 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %46 = load i8*, i8** %q.addr, align 8
  %call52 = call %struct.cell* @mk_symbol(%struct.scheme* %45, i8* %46)
  store %struct.cell* %call52, %struct.cell** %retval
  br label %return

if.end.53:                                        ; preds = %if.else.43
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.end.42
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %if.end.27
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.55
  %47 = load i8*, i8** %p, align 8
  %48 = load i8, i8* %47, align 1
  store i8 %48, i8* %c, align 1
  %conv56 = sext i8 %48 to i32
  %cmp57 = icmp ne i32 %conv56, 0
  br i1 %cmp57, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %49 = load i8, i8* %c, align 1
  %conv59 = sext i8 %49 to i32
  %idxprom60 = sext i32 %conv59 to i64
  %call61 = call i16** @__ctype_b_loc() #7
  %50 = load i16*, i16** %call61, align 8
  %arrayidx62 = getelementptr inbounds i16, i16* %50, i64 %idxprom60
  %51 = load i16, i16* %arrayidx62, align 2
  %conv63 = zext i16 %51 to i32
  %and64 = and i32 %conv63, 2048
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.end.107, label %if.then.66

if.then.66:                                       ; preds = %for.body
  %52 = load i8, i8* %c, align 1
  %conv67 = sext i8 %52 to i32
  %cmp68 = icmp eq i32 %conv67, 46
  br i1 %cmp68, label %if.then.70, label %if.else.74

if.then.70:                                       ; preds = %if.then.66
  %53 = load i32, i32* %has_dec_point, align 4
  %tobool71 = icmp ne i32 %53, 0
  br i1 %tobool71, label %if.end.73, label %if.then.72

if.then.72:                                       ; preds = %if.then.70
  store i32 1, i32* %has_dec_point, align 4
  br label %for.inc

if.end.73:                                        ; preds = %if.then.70
  br label %if.end.105

if.else.74:                                       ; preds = %if.then.66
  %54 = load i8, i8* %c, align 1
  %conv75 = sext i8 %54 to i32
  %cmp76 = icmp eq i32 %conv75, 101
  br i1 %cmp76, label %if.then.82, label %lor.lhs.false.78

lor.lhs.false.78:                                 ; preds = %if.else.74
  %55 = load i8, i8* %c, align 1
  %conv79 = sext i8 %55 to i32
  %cmp80 = icmp eq i32 %conv79, 69
  br i1 %cmp80, label %if.then.82, label %if.end.104

if.then.82:                                       ; preds = %lor.lhs.false.78, %if.else.74
  %56 = load i32, i32* %has_fp_exp, align 4
  %tobool83 = icmp ne i32 %56, 0
  br i1 %tobool83, label %if.end.103, label %if.then.84

if.then.84:                                       ; preds = %if.then.82
  store i32 1, i32* %has_dec_point, align 4
  %57 = load i8*, i8** %p, align 8
  %incdec.ptr85 = getelementptr inbounds i8, i8* %57, i32 1
  store i8* %incdec.ptr85, i8** %p, align 8
  %58 = load i8*, i8** %p, align 8
  %59 = load i8, i8* %58, align 1
  %conv86 = sext i8 %59 to i32
  %cmp87 = icmp eq i32 %conv86, 45
  br i1 %cmp87, label %if.then.101, label %lor.lhs.false.89

lor.lhs.false.89:                                 ; preds = %if.then.84
  %60 = load i8*, i8** %p, align 8
  %61 = load i8, i8* %60, align 1
  %conv90 = sext i8 %61 to i32
  %cmp91 = icmp eq i32 %conv90, 43
  br i1 %cmp91, label %if.then.101, label %lor.lhs.false.93

lor.lhs.false.93:                                 ; preds = %lor.lhs.false.89
  %62 = load i8*, i8** %p, align 8
  %63 = load i8, i8* %62, align 1
  %conv94 = sext i8 %63 to i32
  %idxprom95 = sext i32 %conv94 to i64
  %call96 = call i16** @__ctype_b_loc() #7
  %64 = load i16*, i16** %call96, align 8
  %arrayidx97 = getelementptr inbounds i16, i16* %64, i64 %idxprom95
  %65 = load i16, i16* %arrayidx97, align 2
  %conv98 = zext i16 %65 to i32
  %and99 = and i32 %conv98, 2048
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.then.101, label %if.end.102

if.then.101:                                      ; preds = %lor.lhs.false.93, %lor.lhs.false.89, %if.then.84
  br label %for.inc

if.end.102:                                       ; preds = %lor.lhs.false.93
  br label %if.end.103

if.end.103:                                       ; preds = %if.end.102, %if.then.82
  br label %if.end.104

if.end.104:                                       ; preds = %if.end.103, %lor.lhs.false.78
  br label %if.end.105

if.end.105:                                       ; preds = %if.end.104, %if.end.73
  %66 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %67 = load i8*, i8** %q.addr, align 8
  %call106 = call %struct.cell* @mk_symbol(%struct.scheme* %66, i8* %67)
  store %struct.cell* %call106, %struct.cell** %retval
  br label %return

if.end.107:                                       ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.107, %if.then.101, %if.then.72
  %68 = load i8*, i8** %p, align 8
  %incdec.ptr108 = getelementptr inbounds i8, i8* %68, i32 1
  store i8* %incdec.ptr108, i8** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %69 = load i32, i32* %has_dec_point, align 4
  %tobool109 = icmp ne i32 %69, 0
  br i1 %tobool109, label %if.then.110, label %if.end.113

if.then.110:                                      ; preds = %for.end
  %70 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %71 = load i8*, i8** %q.addr, align 8
  %call111 = call double @g_ascii_strtod(i8* %71, i8** null)
  %call112 = call %struct.cell* @mk_real(%struct.scheme* %70, double %call111)
  store %struct.cell* %call112, %struct.cell** %retval
  br label %return

if.end.113:                                       ; preds = %for.end
  %72 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %73 = load i8*, i8** %q.addr, align 8
  %call114 = call i64 @atol(i8* %73) #6
  %call115 = call %struct.cell* @mk_integer(%struct.scheme* %72, i64 %call114)
  store %struct.cell* %call115, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end.113, %if.then.110, %if.end.105, %if.then.51, %if.then.40, %if.then.25, %if.then
  %74 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %74
}

; Function Attrs: nounwind uwtable
define internal void @atom2str(%struct.scheme* %sc, %struct.cell* %l, i32 %f, i8** %pp, i32* %plen) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %l.addr = alloca %struct.cell*, align 8
  %f.addr = alloca i32, align 4
  %pp.addr = alloca i8**, align 8
  %plen.addr = alloca i32*, align 8
  %p = alloca i8*, align 8
  %c = alloca i32, align 4
  %len = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %l, %struct.cell** %l.addr, align 8
  store i32 %f, i32* %f.addr, align 4
  store i8** %pp, i8*** %pp.addr, align 8
  store i32* %plen, i32** %plen.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %0, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.229, i32 0, i32 0), i8** %p, align 8
  br label %if.end.139

if.else:                                          ; preds = %entry
  %3 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %T = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 19
  %5 = load %struct.cell*, %struct.cell** %T, align 8
  %cmp1 = icmp eq %struct.cell* %3, %5
  br i1 %cmp1, label %if.then.2, label %if.else.3

if.then.2:                                        ; preds = %if.else
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.230, i32 0, i32 0), i8** %p, align 8
  br label %if.end.138

if.else.3:                                        ; preds = %if.else
  %6 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %7 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %7, i32 0, i32 21
  %8 = load %struct.cell*, %struct.cell** %F, align 8
  %cmp4 = icmp eq %struct.cell* %6, %8
  br i1 %cmp4, label %if.then.5, label %if.else.6

if.then.5:                                        ; preds = %if.else.3
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.231, i32 0, i32 0), i8** %p, align 8
  br label %if.end.137

if.else.6:                                        ; preds = %if.else.3
  %9 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %EOF_OBJ = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 23
  %11 = load %struct.cell*, %struct.cell** %EOF_OBJ, align 8
  %cmp7 = icmp eq %struct.cell* %9, %11
  br i1 %cmp7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.else.6
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.232, i32 0, i32 0), i8** %p, align 8
  br label %if.end.136

if.else.9:                                        ; preds = %if.else.6
  %12 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call = call i32 @is_port(%struct.cell* %12)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then.10, label %if.else.12

if.then.10:                                       ; preds = %if.else.9
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  store i8* %arraydecay, i8** %p, align 8
  %14 = load i8*, i8** %p, align 8
  %call11 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %14, i64 1024, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.233, i32 0, i32 0)) #2
  br label %if.end.135

if.else.12:                                       ; preds = %if.else.9
  %15 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call13 = call i32 @is_number(%struct.cell* %15)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then.15, label %if.else.40

if.then.15:                                       ; preds = %if.else.12
  %16 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff16 = getelementptr inbounds %struct.scheme, %struct.scheme* %16, i32 0, i32 50
  %arraydecay17 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff16, i32 0, i32 0
  store i8* %arraydecay17, i8** %p, align 8
  %17 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call18 = call i32 @num_is_integer(%struct.cell* %17)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then.20, label %if.else.22

if.then.20:                                       ; preds = %if.then.15
  %18 = load i8*, i8** %p, align 8
  %19 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %19, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %20 = load i64, i64* %ivalue, align 8
  %call21 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %18, i64 1024, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.221, i32 0, i32 0), i64 %20) #2
  br label %if.end.39

if.else.22:                                       ; preds = %if.then.15
  %21 = load i8*, i8** %p, align 8
  %22 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %22, i32 0, i32 1
  %_number24 = bitcast %union.anon* %_object23 to %struct.num*
  %value25 = getelementptr inbounds %struct.num, %struct.num* %_number24, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value25 to double*
  %23 = load double, double* %rvalue, align 8
  %call26 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %21, i64 1024, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.234, i32 0, i32 0), double %23) #2
  %24 = load i8*, i8** %p, align 8
  %call27 = call i64 @strcspn(i8* %24, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.235, i32 0, i32 0)) #6
  %conv = trunc i64 %call27 to i32
  store i32 %conv, i32* %f.addr, align 4
  %25 = load i32, i32* %f.addr, align 4
  %idxprom = sext i32 %25 to i64
  %26 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %26, i64 %idxprom
  %27 = load i8, i8* %arrayidx, align 1
  %conv28 = sext i8 %27 to i32
  %cmp29 = icmp eq i32 %conv28, 0
  br i1 %cmp29, label %if.then.31, label %if.end

if.then.31:                                       ; preds = %if.else.22
  %28 = load i32, i32* %f.addr, align 4
  %idxprom32 = sext i32 %28 to i64
  %29 = load i8*, i8** %p, align 8
  %arrayidx33 = getelementptr inbounds i8, i8* %29, i64 %idxprom32
  store i8 46, i8* %arrayidx33, align 1
  %30 = load i32, i32* %f.addr, align 4
  %add = add nsw i32 %30, 1
  %idxprom34 = sext i32 %add to i64
  %31 = load i8*, i8** %p, align 8
  %arrayidx35 = getelementptr inbounds i8, i8* %31, i64 %idxprom34
  store i8 48, i8* %arrayidx35, align 1
  %32 = load i32, i32* %f.addr, align 4
  %add36 = add nsw i32 %32, 2
  %idxprom37 = sext i32 %add36 to i64
  %33 = load i8*, i8** %p, align 8
  %arrayidx38 = getelementptr inbounds i8, i8* %33, i64 %idxprom37
  store i8 0, i8* %arrayidx38, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.31, %if.else.22
  br label %if.end.39

if.end.39:                                        ; preds = %if.end, %if.then.20
  br label %if.end.134

if.else.40:                                       ; preds = %if.else.12
  %34 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call41 = call i32 @is_string(%struct.cell* %34)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then.43, label %if.else.59

if.then.43:                                       ; preds = %if.else.40
  %35 = load i32, i32* %f.addr, align 4
  %tobool44 = icmp ne i32 %35, 0
  br i1 %tobool44, label %if.else.47, label %if.then.45

if.then.45:                                       ; preds = %if.then.43
  %36 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %_object46 = getelementptr inbounds %struct.cell, %struct.cell* %36, i32 0, i32 1
  %_string = bitcast %union.anon* %_object46 to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %37 = load i8*, i8** %_svalue, align 8
  store i8* %37, i8** %p, align 8
  br label %if.end.58

if.else.47:                                       ; preds = %if.then.43
  %38 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff48 = getelementptr inbounds %struct.scheme, %struct.scheme* %38, i32 0, i32 50
  %arraydecay49 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff48, i32 0, i32 0
  %39 = load i8**, i8*** %pp.addr, align 8
  store i8* %arraydecay49, i8** %39, align 8
  %40 = load i32*, i32** %plen.addr, align 8
  store i32 0, i32* %40, align 4
  %41 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %42 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %_object50 = getelementptr inbounds %struct.cell, %struct.cell* %42, i32 0, i32 1
  %_string51 = bitcast %union.anon* %_object50 to %struct.anon*
  %_svalue52 = getelementptr inbounds %struct.anon, %struct.anon* %_string51, i32 0, i32 0
  %43 = load i8*, i8** %_svalue52, align 8
  %44 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %_object53 = getelementptr inbounds %struct.cell, %struct.cell* %44, i32 0, i32 1
  %_string54 = bitcast %union.anon* %_object53 to %struct.anon*
  %_svalue55 = getelementptr inbounds %struct.anon, %struct.anon* %_string54, i32 0, i32 0
  %45 = load i8*, i8** %_svalue55, align 8
  %call56 = call i64 @g_utf8_strlen(i8* %45, i64 -1) #6
  %conv57 = trunc i64 %call56 to i32
  call void @printslashstring(%struct.scheme* %41, i8* %43, i32 %conv57)
  br label %return

if.end.58:                                        ; preds = %if.then.45
  br label %if.end.133

if.else.59:                                       ; preds = %if.else.40
  %46 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call60 = call i32 @is_character(%struct.cell* %46)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.then.62, label %if.else.86

if.then.62:                                       ; preds = %if.else.59
  %47 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call63 = call i32 @charvalue(%struct.cell* %47)
  store i32 %call63, i32* %c, align 4
  %48 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff64 = getelementptr inbounds %struct.scheme, %struct.scheme* %48, i32 0, i32 50
  %arraydecay65 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff64, i32 0, i32 0
  store i8* %arraydecay65, i8** %p, align 8
  %49 = load i32, i32* %f.addr, align 4
  %tobool66 = icmp ne i32 %49, 0
  br i1 %tobool66, label %if.else.71, label %if.then.67

if.then.67:                                       ; preds = %if.then.62
  %50 = load i32, i32* %c, align 4
  %51 = load i8*, i8** %p, align 8
  %call68 = call i32 @g_unichar_to_utf8(i32 %50, i8* %51)
  store i32 %call68, i32* %len, align 4
  %52 = load i32, i32* %len, align 4
  %idxprom69 = sext i32 %52 to i64
  %53 = load i8*, i8** %p, align 8
  %arrayidx70 = getelementptr inbounds i8, i8* %53, i64 %idxprom69
  store i8 0, i8* %arrayidx70, align 1
  br label %if.end.85

if.else.71:                                       ; preds = %if.then.62
  %54 = load i32, i32* %c, align 4
  switch i32 %54, label %sw.default [
    i32 32, label %sw.bb
    i32 10, label %sw.bb.73
    i32 13, label %sw.bb.75
    i32 9, label %sw.bb.77
  ]

sw.bb:                                            ; preds = %if.else.71
  %55 = load i8*, i8** %p, align 8
  %call72 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %55, i64 1024, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.236, i32 0, i32 0)) #2
  br label %sw.epilog

sw.bb.73:                                         ; preds = %if.else.71
  %56 = load i8*, i8** %p, align 8
  %call74 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %56, i64 1024, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.237, i32 0, i32 0)) #2
  br label %sw.epilog

sw.bb.75:                                         ; preds = %if.else.71
  %57 = load i8*, i8** %p, align 8
  %call76 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %57, i64 1024, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.238, i32 0, i32 0)) #2
  br label %sw.epilog

sw.bb.77:                                         ; preds = %if.else.71
  %58 = load i8*, i8** %p, align 8
  %call78 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %58, i64 1024, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.239, i32 0, i32 0)) #2
  br label %sw.epilog

sw.default:                                       ; preds = %if.else.71
  %59 = load i32, i32* %c, align 4
  %cmp79 = icmp ult i32 %59, 32
  br i1 %cmp79, label %if.then.81, label %if.end.83

if.then.81:                                       ; preds = %sw.default
  %60 = load i8*, i8** %p, align 8
  %61 = load i32, i32* %c, align 4
  %call82 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %60, i64 1024, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.240, i32 0, i32 0), i32 %61) #2
  br label %sw.epilog

if.end.83:                                        ; preds = %sw.default
  %62 = load i8*, i8** %p, align 8
  %63 = load i32, i32* %c, align 4
  %call84 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %62, i64 1024, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.241, i32 0, i32 0), i32 %63) #2
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.83, %if.then.81, %sw.bb.77, %sw.bb.75, %sw.bb.73, %sw.bb
  br label %if.end.85

if.end.85:                                        ; preds = %sw.epilog, %if.then.67
  br label %if.end.132

if.else.86:                                       ; preds = %if.else.59
  %64 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call87 = call i32 @is_symbol(%struct.cell* %64)
  %tobool88 = icmp ne i32 %call87, 0
  br i1 %tobool88, label %if.then.89, label %if.else.91

if.then.89:                                       ; preds = %if.else.86
  %65 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call90 = call i8* @symname(%struct.cell* %65)
  store i8* %call90, i8** %p, align 8
  br label %if.end.131

if.else.91:                                       ; preds = %if.else.86
  %66 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call92 = call i32 @is_proc(%struct.cell* %66)
  %tobool93 = icmp ne i32 %call92, 0
  br i1 %tobool93, label %if.then.94, label %if.else.100

if.then.94:                                       ; preds = %if.else.91
  %67 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff95 = getelementptr inbounds %struct.scheme, %struct.scheme* %67, i32 0, i32 50
  %arraydecay96 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff95, i32 0, i32 0
  store i8* %arraydecay96, i8** %p, align 8
  %68 = load i8*, i8** %p, align 8
  %69 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call97 = call i8* @procname(%struct.cell* %69)
  %70 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call98 = call i64 @ivalue(%struct.cell* %70)
  %call99 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %68, i64 1024, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.242, i32 0, i32 0), i8* %call97, i64 %call98) #2
  br label %if.end.130

if.else.100:                                      ; preds = %if.else.91
  %71 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call101 = call i32 @is_macro(%struct.cell* %71)
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.then.103, label %if.else.104

if.then.103:                                      ; preds = %if.else.100
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.243, i32 0, i32 0), i8** %p, align 8
  br label %if.end.129

if.else.104:                                      ; preds = %if.else.100
  %72 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call105 = call i32 @is_closure(%struct.cell* %72)
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then.107, label %if.else.108

if.then.107:                                      ; preds = %if.else.104
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.244, i32 0, i32 0), i8** %p, align 8
  br label %if.end.128

if.else.108:                                      ; preds = %if.else.104
  %73 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call109 = call i32 @is_promise(%struct.cell* %73)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then.111, label %if.else.112

if.then.111:                                      ; preds = %if.else.108
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.245, i32 0, i32 0), i8** %p, align 8
  br label %if.end.127

if.else.112:                                      ; preds = %if.else.108
  %74 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call113 = call i32 @is_foreign(%struct.cell* %74)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then.115, label %if.else.120

if.then.115:                                      ; preds = %if.else.112
  %75 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff116 = getelementptr inbounds %struct.scheme, %struct.scheme* %75, i32 0, i32 50
  %arraydecay117 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff116, i32 0, i32 0
  store i8* %arraydecay117, i8** %p, align 8
  %76 = load i8*, i8** %p, align 8
  %77 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call118 = call i64 @ivalue(%struct.cell* %77)
  %call119 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %76, i64 1024, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.246, i32 0, i32 0), i64 %call118) #2
  br label %if.end.126

if.else.120:                                      ; preds = %if.else.112
  %78 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %call121 = call i32 @is_continuation(%struct.cell* %78)
  %tobool122 = icmp ne i32 %call121, 0
  br i1 %tobool122, label %if.then.123, label %if.else.124

if.then.123:                                      ; preds = %if.else.120
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.247, i32 0, i32 0), i8** %p, align 8
  br label %if.end.125

if.else.124:                                      ; preds = %if.else.120
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.248, i32 0, i32 0), i8** %p, align 8
  br label %if.end.125

if.end.125:                                       ; preds = %if.else.124, %if.then.123
  br label %if.end.126

if.end.126:                                       ; preds = %if.end.125, %if.then.115
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %if.then.111
  br label %if.end.128

if.end.128:                                       ; preds = %if.end.127, %if.then.107
  br label %if.end.129

if.end.129:                                       ; preds = %if.end.128, %if.then.103
  br label %if.end.130

if.end.130:                                       ; preds = %if.end.129, %if.then.94
  br label %if.end.131

if.end.131:                                       ; preds = %if.end.130, %if.then.89
  br label %if.end.132

if.end.132:                                       ; preds = %if.end.131, %if.end.85
  br label %if.end.133

if.end.133:                                       ; preds = %if.end.132, %if.end.58
  br label %if.end.134

if.end.134:                                       ; preds = %if.end.133, %if.end.39
  br label %if.end.135

if.end.135:                                       ; preds = %if.end.134, %if.then.10
  br label %if.end.136

if.end.136:                                       ; preds = %if.end.135, %if.then.8
  br label %if.end.137

if.end.137:                                       ; preds = %if.end.136, %if.then.5
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137, %if.then.2
  br label %if.end.139

if.end.139:                                       ; preds = %if.end.138, %if.then
  %79 = load i8*, i8** %p, align 8
  %80 = load i8**, i8*** %pp.addr, align 8
  store i8* %79, i8** %80, align 8
  %81 = load i8*, i8** %p, align 8
  %call140 = call i64 @g_utf8_strlen(i8* %81, i64 -1) #6
  %conv141 = trunc i64 %call140 to i32
  %82 = load i32*, i32** %plen.addr, align 8
  store i32 %conv141, i32* %82, align 4
  br label %return

return:                                           ; preds = %if.end.139, %if.else.47
  ret void
}

; Function Attrs: nounwind readonly
declare i32 @g_utf8_get_char(i8*) #1

; Function Attrs: nounwind
declare double @fmod(double, double) #3

; Function Attrs: nounwind readnone
declare i64 @labs(i64) #5

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind
declare i32 @__isoc99_sscanf(i8*, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal i64 @binary_decode(i8* %s) #0 {
entry:
  %s.addr = alloca i8*, align 8
  %x = alloca i64, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 0, i64* %x, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load i8*, i8** %s.addr, align 8
  %3 = load i8, i8* %2, align 1
  %conv2 = sext i8 %3 to i32
  %cmp3 = icmp eq i32 %conv2, 49
  br i1 %cmp3, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %4 = load i8*, i8** %s.addr, align 8
  %5 = load i8, i8* %4, align 1
  %conv5 = sext i8 %5 to i32
  %cmp6 = icmp eq i32 %conv5, 48
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %6 = phi i1 [ true, %land.rhs ], [ %cmp6, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %7 = phi i1 [ false, %while.cond ], [ %6, %lor.end ]
  br i1 %7, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %8 = load i64, i64* %x, align 8
  %shl = shl i64 %8, 1
  store i64 %shl, i64* %x, align 8
  %9 = load i8*, i8** %s.addr, align 8
  %10 = load i8, i8* %9, align 1
  %conv8 = sext i8 %10 to i32
  %sub = sub nsw i32 %conv8, 48
  %conv9 = sext i32 %sub to i64
  %11 = load i64, i64* %x, align 8
  %add = add nsw i64 %11, %conv9
  store i64 %add, i64* %x, align 8
  %12 = load i8*, i8** %s.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %12, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %13 = load i64, i64* %x, align 8
  ret i64 %13
}

; Function Attrs: nounwind readonly
declare i8* @strstr(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i16** @__ctype_b_loc() #5

declare double @g_ascii_strtod(i8*, i8**) #4

; Function Attrs: nounwind readonly
declare i64 @atol(i8*) #1

; Function Attrs: nounwind readonly
declare i64 @strcspn(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @printslashstring(%struct.scheme* %sc, i8* %p, i32 %len) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %p.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %c = alloca i32, align 4
  %s = alloca i8*, align 8
  %d = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i8*, i8** %p.addr, align 8
  store i8* %0, i8** %s, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %1, i32 34)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %len.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i8*, i8** %s, align 8
  %call = call i32 @g_utf8_get_char(i8* %4) #6
  store i32 %call, i32* %c, align 4
  %5 = load i32, i32* %c, align 4
  %cmp1 = icmp eq i32 %5, 255
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %6 = load i32, i32* %c, align 4
  %cmp2 = icmp eq i32 %6, 34
  br i1 %cmp2, label %if.then, label %lor.lhs.false.3

lor.lhs.false.3:                                  ; preds = %lor.lhs.false
  %7 = load i32, i32* %c, align 4
  %cmp4 = icmp ult i32 %7, 32
  br i1 %cmp4, label %if.then, label %lor.lhs.false.5

lor.lhs.false.5:                                  ; preds = %lor.lhs.false.3
  %8 = load i32, i32* %c, align 4
  %cmp6 = icmp eq i32 %8, 92
  br i1 %cmp6, label %if.then, label %if.else.21

if.then:                                          ; preds = %lor.lhs.false.5, %lor.lhs.false.3, %lor.lhs.false, %for.body
  %9 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %9, i32 92)
  %10 = load i32, i32* %c, align 4
  switch i32 %10, label %sw.default [
    i32 34, label %sw.bb
    i32 10, label %sw.bb.7
    i32 9, label %sw.bb.8
    i32 13, label %sw.bb.9
    i32 92, label %sw.bb.10
  ]

sw.bb:                                            ; preds = %if.then
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %11, i32 34)
  br label %sw.epilog

sw.bb.7:                                          ; preds = %if.then
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %12, i32 110)
  br label %sw.epilog

sw.bb.8:                                          ; preds = %if.then
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %13, i32 116)
  br label %sw.epilog

sw.bb.9:                                          ; preds = %if.then
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %14, i32 114)
  br label %sw.epilog

sw.bb.10:                                         ; preds = %if.then
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %15, i32 92)
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %16 = load i32, i32* %c, align 4
  %div = udiv i32 %16, 16
  store i32 %div, i32* %d, align 4
  %17 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %17, i32 120)
  %18 = load i32, i32* %d, align 4
  %cmp11 = icmp slt i32 %18, 10
  br i1 %cmp11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %sw.default
  %19 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %20 = load i32, i32* %d, align 4
  %add = add nsw i32 %20, 48
  call void @putcharacter(%struct.scheme* %19, i32 %add)
  br label %if.end

if.else:                                          ; preds = %sw.default
  %21 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %22 = load i32, i32* %d, align 4
  %sub = sub nsw i32 %22, 10
  %add13 = add nsw i32 %sub, 65
  call void @putcharacter(%struct.scheme* %21, i32 %add13)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.12
  %23 = load i32, i32* %c, align 4
  %rem = urem i32 %23, 16
  store i32 %rem, i32* %d, align 4
  %24 = load i32, i32* %d, align 4
  %cmp14 = icmp slt i32 %24, 10
  br i1 %cmp14, label %if.then.15, label %if.else.17

if.then.15:                                       ; preds = %if.end
  %25 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %26 = load i32, i32* %d, align 4
  %add16 = add nsw i32 %26, 48
  call void @putcharacter(%struct.scheme* %25, i32 %add16)
  br label %if.end.20

if.else.17:                                       ; preds = %if.end
  %27 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %28 = load i32, i32* %d, align 4
  %sub18 = sub nsw i32 %28, 10
  %add19 = add nsw i32 %sub18, 65
  call void @putcharacter(%struct.scheme* %27, i32 %add19)
  br label %if.end.20

if.end.20:                                        ; preds = %if.else.17, %if.then.15
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.20, %sw.bb.10, %sw.bb.9, %sw.bb.8, %sw.bb.7, %sw.bb
  br label %if.end.22

if.else.21:                                       ; preds = %lor.lhs.false.5
  %29 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %30 = load i32, i32* %c, align 4
  call void @putcharacter(%struct.scheme* %29, i32 %30)
  br label %if.end.22

if.end.22:                                        ; preds = %if.else.21, %sw.epilog
  %31 = load i8*, i8** %s, align 8
  %32 = load i8*, i8** %s, align 8
  %33 = load i8, i8* %32, align 1
  %idxprom = zext i8 %33 to i64
  %34 = load i8*, i8** @g_utf8_skip, align 8
  %arrayidx = getelementptr inbounds i8, i8* %34, i64 %idxprom
  %35 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %35 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr inbounds i8, i8* %31, i64 %idx.ext
  store i8* %add.ptr, i8** %s, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.22
  %36 = load i32, i32* %i, align 4
  %inc = add nsw i32 %36, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %37 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  call void @putcharacter(%struct.scheme* %37, i32 34)
  ret void
}

; Function Attrs: nounwind uwtable
define internal i8* @procname(%struct.cell* %x) #0 {
entry:
  %x.addr = alloca %struct.cell*, align 8
  %n = alloca i32, align 4
  %name = alloca i8*, align 8
  store %struct.cell* %x, %struct.cell** %x.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %x.addr, align 8
  %call = call i64 @ivalue(%struct.cell* %0)
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %n, align 4
  %1 = load i32, i32* %n, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [181 x %struct.op_code_info], [181 x %struct.op_code_info]* @dispatch_table, i32 0, i64 %idxprom
  %name1 = getelementptr inbounds %struct.op_code_info, %struct.op_code_info* %arrayidx, i32 0, i32 1
  %2 = load i8*, i8** %name1, align 8
  store i8* %2, i8** %name, align 8
  %3 = load i8*, i8** %name, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.249, i32 0, i32 0), i8** %name, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i8*, i8** %name, align 8
  ret i8* %4
}

; Function Attrs: nounwind uwtable
define internal i32 @num_lt(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca i32, align 4
  %is_fixnum = alloca i32, align 4
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum1, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum2 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum2, align 1
  %conv3 = sext i8 %7 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool4, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, i32* %is_fixnum, align 4
  %9 = load i32, i32* %is_fixnum, align 4
  %tobool5 = icmp ne i32 %9, 0
  br i1 %tobool5, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value6 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue7 = bitcast %union.anon.0* %value6 to i64*
  %11 = load i64, i64* %ivalue7, align 8
  %cmp = icmp slt i64 %10, %11
  %conv8 = zext i1 %cmp to i32
  store i32 %conv8, i32* %ret, align 4
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum9 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum9, align 1
  %tobool10 = icmp ne i8 %12, 0
  br i1 %tobool10, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value11 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value11 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue13 = bitcast %union.anon.0* %value12 to i64*
  %14 = load i64, i64* %ivalue13, align 8
  %conv14 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv14, %cond.false ]
  %is_fixnum15 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum15, align 1
  %tobool16 = icmp ne i8 %15, 0
  br i1 %tobool16, label %cond.false.20, label %cond.true.17

cond.true.17:                                     ; preds = %cond.end
  %value18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue19 = bitcast %union.anon.0* %value18 to double*
  %16 = load double, double* %rvalue19, align 8
  br label %cond.end.24

cond.false.20:                                    ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue22 = bitcast %union.anon.0* %value21 to i64*
  %17 = load i64, i64* %ivalue22, align 8
  %conv23 = sitofp i64 %17 to double
  br label %cond.end.24

cond.end.24:                                      ; preds = %cond.false.20, %cond.true.17
  %cond25 = phi double [ %16, %cond.true.17 ], [ %conv23, %cond.false.20 ]
  %cmp26 = fcmp olt double %cond, %cond25
  %conv27 = zext i1 %cmp26 to i32
  store i32 %conv27, i32* %ret, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end.24, %if.then
  %18 = load i32, i32* %ret, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal i32 @num_gt(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %ret = alloca i32, align 4
  %is_fixnum = alloca i32, align 4
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %is_fixnum1 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %6 = load i8, i8* %is_fixnum1, align 1
  %conv = sext i8 %6 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %is_fixnum2 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %7 = load i8, i8* %is_fixnum2, align 1
  %conv3 = sext i8 %7 to i32
  %tobool4 = icmp ne i32 %conv3, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %8 = phi i1 [ false, %entry ], [ %tobool4, %land.rhs ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, i32* %is_fixnum, align 4
  %9 = load i32, i32* %is_fixnum, align 4
  %tobool5 = icmp ne i32 %9, 0
  br i1 %tobool5, label %if.then, label %if.else

if.then:                                          ; preds = %land.end
  %value = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %10 = load i64, i64* %ivalue, align 8
  %value6 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue7 = bitcast %union.anon.0* %value6 to i64*
  %11 = load i64, i64* %ivalue7, align 8
  %cmp = icmp sgt i64 %10, %11
  %conv8 = zext i1 %cmp to i32
  store i32 %conv8, i32* %ret, align 4
  br label %if.end

if.else:                                          ; preds = %land.end
  %is_fixnum9 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 0
  %12 = load i8, i8* %is_fixnum9, align 1
  %tobool10 = icmp ne i8 %12, 0
  br i1 %tobool10, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %value11 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %rvalue = bitcast %union.anon.0* %value11 to double*
  %13 = load double, double* %rvalue, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %value12 = getelementptr inbounds %struct.num, %struct.num* %a, i32 0, i32 1
  %ivalue13 = bitcast %union.anon.0* %value12 to i64*
  %14 = load i64, i64* %ivalue13, align 8
  %conv14 = sitofp i64 %14 to double
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %13, %cond.true ], [ %conv14, %cond.false ]
  %is_fixnum15 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 0
  %15 = load i8, i8* %is_fixnum15, align 1
  %tobool16 = icmp ne i8 %15, 0
  br i1 %tobool16, label %cond.false.20, label %cond.true.17

cond.true.17:                                     ; preds = %cond.end
  %value18 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %rvalue19 = bitcast %union.anon.0* %value18 to double*
  %16 = load double, double* %rvalue19, align 8
  br label %cond.end.24

cond.false.20:                                    ; preds = %cond.end
  %value21 = getelementptr inbounds %struct.num, %struct.num* %b, i32 0, i32 1
  %ivalue22 = bitcast %union.anon.0* %value21 to i64*
  %17 = load i64, i64* %ivalue22, align 8
  %conv23 = sitofp i64 %17 to double
  br label %cond.end.24

cond.end.24:                                      ; preds = %cond.false.20, %cond.true.17
  %cond25 = phi double [ %16, %cond.true.17 ], [ %conv23, %cond.false.20 ]
  %cmp26 = fcmp ogt double %cond, %cond25
  %conv27 = zext i1 %cmp26 to i32
  store i32 %conv27, i32* %ret, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end.24, %if.then
  %18 = load i32, i32* %ret, align 4
  ret i32 %18
}

; Function Attrs: nounwind uwtable
define internal i32 @num_le(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %6 = bitcast %struct.num* %a to { i8, i64 }*
  %7 = getelementptr { i8, i64 }, { i8, i64 }* %6, i32 0, i32 0
  %8 = load i8, i8* %7, align 1
  %9 = getelementptr { i8, i64 }, { i8, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 1
  %11 = bitcast %struct.num* %b to { i8, i64 }*
  %12 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 0
  %13 = load i8, i8* %12, align 1
  %14 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 1
  %call = call i32 @num_gt(i8 %8, i64 %10, i8 %13, i64 %15)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @num_ge(i8 %a.coerce0, i64 %a.coerce1, i8 %b.coerce0, i64 %b.coerce1) #0 {
entry:
  %a = alloca %struct.num, align 8
  %b = alloca %struct.num, align 8
  %0 = bitcast %struct.num* %a to { i8, i64 }*
  %1 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 0
  store i8 %a.coerce0, i8* %1
  %2 = getelementptr { i8, i64 }, { i8, i64 }* %0, i32 0, i32 1
  store i64 %a.coerce1, i64* %2
  %3 = bitcast %struct.num* %b to { i8, i64 }*
  %4 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 0
  store i8 %b.coerce0, i8* %4
  %5 = getelementptr { i8, i64 }, { i8, i64 }* %3, i32 0, i32 1
  store i64 %b.coerce1, i64* %5
  %6 = bitcast %struct.num* %a to { i8, i64 }*
  %7 = getelementptr { i8, i64 }, { i8, i64 }* %6, i32 0, i32 0
  %8 = load i8, i8* %7, align 1
  %9 = getelementptr { i8, i64 }, { i8, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 1
  %11 = bitcast %struct.num* %b to { i8, i64 }*
  %12 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 0
  %13 = load i8, i8* %12, align 1
  %14 = getelementptr { i8, i64 }, { i8, i64 }* %11, i32 0, i32 1
  %15 = load i64, i64* %14, align 1
  %call = call i32 @num_lt(i8 %8, i64 %10, i8 %13, i64 %15)
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

; Function Attrs: nounwind uwtable
define internal i32 @Cisalpha(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_isalpha(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @Cisdigit(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_isdigit(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @Cisspace(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_isspace(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @Cisupper(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_isupper(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @Cislower(i32 %c) #0 {
entry:
  %c.addr = alloca i32, align 4
  store i32 %c, i32* %c.addr, align 4
  %0 = load i32, i32* %c.addr, align 4
  %call = call i32 @g_unichar_islower(i32 %0) #7
  ret i32 %call
}

; Function Attrs: nounwind readnone
declare i32 @g_unichar_isalpha(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_isdigit(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_isupper(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_islower(i32) #5

; Function Attrs: nounwind uwtable
define internal %struct.cell* @reverse(%struct.scheme* %sc, %struct.cell* %a) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %1, %struct.cell** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call = call i32 @is_pair(%struct.cell* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %4 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %5 = load %struct.cell*, %struct.cell** %_car, align 8
  %6 = load %struct.cell*, %struct.cell** %p, align 8
  %call1 = call %struct.cell* @_cons(%struct.scheme* %3, %struct.cell* %5, %struct.cell* %6, i32 0)
  store %struct.cell* %call1, %struct.cell** %p, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons3 = bitcast %union.anon* %_object2 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons3, i32 0, i32 1
  %8 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %8, %struct.cell** %a.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct.cell*, %struct.cell** %p, align 8
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @revappend(%struct.scheme* %sc, %struct.cell* %a, %struct.cell* %b) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  %b.addr = alloca %struct.cell*, align 8
  %result = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* %b, %struct.cell** %b.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %a.addr, align 8
  store %struct.cell* %0, %struct.cell** %result, align 8
  %1 = load %struct.cell*, %struct.cell** %b.addr, align 8
  store %struct.cell* %1, %struct.cell** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load %struct.cell*, %struct.cell** %p, align 8
  %call = call i32 @is_pair(%struct.cell* %2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %4 = load %struct.cell*, %struct.cell** %p, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %5 = load %struct.cell*, %struct.cell** %_car, align 8
  %6 = load %struct.cell*, %struct.cell** %result, align 8
  %call1 = call %struct.cell* @_cons(%struct.scheme* %3, %struct.cell* %5, %struct.cell* %6, i32 0)
  store %struct.cell* %call1, %struct.cell** %result, align 8
  %7 = load %struct.cell*, %struct.cell** %p, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_cons3 = bitcast %union.anon* %_object2 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons3, i32 0, i32 1
  %8 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %8, %struct.cell** %p, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load %struct.cell*, %struct.cell** %p, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  %11 = load %struct.cell*, %struct.cell** %NIL, align 8
  %cmp = icmp eq %struct.cell* %9, %11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %12 = load %struct.cell*, %struct.cell** %result, align 8
  store %struct.cell* %12, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %while.end
  %13 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %13, i32 0, i32 21
  %14 = load %struct.cell*, %struct.cell** %F, align 8
  store %struct.cell* %14, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %15 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %15
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @oblist_all_symbols(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %i = alloca i32, align 4
  %x = alloca %struct.cell*, align 8
  %ob_list = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %1, %struct.cell** %ob_list, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc.10, %entry
  %2 = load i32, i32* %i, align 4
  %conv = sext i32 %2 to i64
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 24
  %4 = load %struct.cell*, %struct.cell** %oblist, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %5 = load i64, i64* %ivalue, align 8
  %cmp = icmp slt i64 %conv, %5
  br i1 %cmp, label %for.body, label %for.end.11

for.body:                                         ; preds = %for.cond
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %oblist2 = getelementptr inbounds %struct.scheme, %struct.scheme* %6, i32 0, i32 24
  %7 = load %struct.cell*, %struct.cell** %oblist2, align 8
  %8 = load i32, i32* %i, align 4
  %call = call %struct.cell* @vector_elem(%struct.cell* %7, i32 %8)
  store %struct.cell* %call, %struct.cell** %x, align 8
  br label %for.cond.3

for.cond.3:                                       ; preds = %for.inc, %for.body
  %9 = load %struct.cell*, %struct.cell** %x, align 8
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL4 = getelementptr inbounds %struct.scheme, %struct.scheme* %10, i32 0, i32 17
  %11 = load %struct.cell*, %struct.cell** %NIL4, align 8
  %cmp5 = icmp ne %struct.cell* %9, %11
  br i1 %cmp5, label %for.body.7, label %for.end

for.body.7:                                       ; preds = %for.cond.3
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %13 = load %struct.cell*, %struct.cell** %x, align 8
  %14 = load %struct.cell*, %struct.cell** %ob_list, align 8
  %call8 = call %struct.cell* @_cons(%struct.scheme* %12, %struct.cell* %13, %struct.cell* %14, i32 0)
  store %struct.cell* %call8, %struct.cell** %ob_list, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body.7
  %15 = load %struct.cell*, %struct.cell** %x, align 8
  %_object9 = getelementptr inbounds %struct.cell, %struct.cell* %15, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object9 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 1
  %16 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %16, %struct.cell** %x, align 8
  br label %for.cond.3

for.end:                                          ; preds = %for.cond.3
  br label %for.inc.10

for.inc.10:                                       ; preds = %for.end
  %17 = load i32, i32* %i, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end.11:                                       ; preds = %for.cond
  %18 = load %struct.cell*, %struct.cell** %ob_list, align 8
  ret %struct.cell* %18
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @port_from_filename(%struct.scheme* %sc, i8* %fn, i32 %prop) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %fn.addr = alloca i8*, align 8
  %prop.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %fn, i8** %fn.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load i8*, i8** %fn.addr, align 8
  %2 = load i32, i32* %prop.addr, align 4
  %call = call %struct.port* @port_rep_from_filename(%struct.scheme* %0, i8* %1, i32 %2)
  store %struct.port* %call, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 17
  %5 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %5, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %call1 = call %struct.cell* @mk_port(%struct.scheme* %6, %struct.port* %7)
  store %struct.cell* %call1, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %8
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @port_from_scratch(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call %struct.port* @port_rep_from_scratch(%struct.scheme* %0)
  store %struct.port* %call, %struct.port** %pt, align 8
  %1 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 17
  %3 = load %struct.cell*, %struct.cell** %NIL, align 8
  store %struct.cell* %3, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %call1 = call %struct.cell* @mk_port(%struct.scheme* %4, %struct.port* %5)
  store %struct.cell* %call1, %struct.cell** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %6
}

; Function Attrs: nounwind
declare i32 @sprintf(i8*, i8*, ...) #3

; Function Attrs: nounwind uwtable
define internal %struct.port* @port_rep_from_filename(%struct.scheme* %sc, i8* %fn, i32 %prop) #0 {
entry:
  %retval = alloca %struct.port*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %fn.addr = alloca i8*, align 8
  %prop.addr = alloca i32, align 4
  %f = alloca %struct._IO_FILE*, align 8
  %rw = alloca i8*, align 8
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %fn, i8** %fn.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load i32, i32* %prop.addr, align 4
  %cmp = icmp eq i32 %0, 48
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.255, i32 0, i32 0), i8** %rw, align 8
  br label %if.end.4

if.else:                                          ; preds = %entry
  %1 = load i32, i32* %prop.addr, align 4
  %cmp1 = icmp eq i32 %1, 32
  br i1 %cmp1, label %if.then.2, label %if.else.3

if.then.2:                                        ; preds = %if.else
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.256, i32 0, i32 0), i8** %rw, align 8
  br label %if.end

if.else.3:                                        ; preds = %if.else
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.190, i32 0, i32 0), i8** %rw, align 8
  br label %if.end

if.end:                                           ; preds = %if.else.3, %if.then.2
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %if.then
  %2 = load i8*, i8** %fn.addr, align 8
  %3 = load i8*, i8** %rw, align 8
  %call = call %struct._IO_FILE* @fopen(i8* %2, i8* %3)
  store %struct._IO_FILE* %call, %struct._IO_FILE** %f, align 8
  %4 = load %struct._IO_FILE*, %struct._IO_FILE** %f, align 8
  %cmp5 = icmp eq %struct._IO_FILE* %4, null
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end.4
  store %struct.port* null, %struct.port** %retval
  br label %return

if.end.7:                                         ; preds = %if.end.4
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** %f, align 8
  %7 = load i32, i32* %prop.addr, align 4
  %call8 = call %struct.port* @port_rep_from_file(%struct.scheme* %5, %struct._IO_FILE* %6, i32 %7)
  store %struct.port* %call8, %struct.port** %pt, align 8
  %8 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %8, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %closeit = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 1
  store i32 1, i32* %closeit, align 4
  %9 = load i8*, i8** %fn.addr, align 8
  %tobool = icmp ne i8* %9, null
  br i1 %tobool, label %if.then.9, label %if.end.14

if.then.9:                                        ; preds = %if.end.7
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load i8*, i8** %fn.addr, align 8
  %call10 = call i64 @strlen(i8* %11) #6
  %conv = trunc i64 %call10 to i32
  %12 = load i8*, i8** %fn.addr, align 8
  %call11 = call i8* @store_string(%struct.scheme* %10, i32 %conv, i8* %12, i32 0)
  %13 = load %struct.port*, %struct.port** %pt, align 8
  %rep12 = getelementptr inbounds %struct.port, %struct.port* %13, i32 0, i32 1
  %stdio13 = bitcast %union.anon.1* %rep12 to %struct.anon.2*
  %filename = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio13, i32 0, i32 3
  store i8* %call11, i8** %filename, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.9, %if.end.7
  %14 = load %struct.port*, %struct.port** %pt, align 8
  %rep15 = getelementptr inbounds %struct.port, %struct.port* %14, i32 0, i32 1
  %stdio16 = bitcast %union.anon.1* %rep15 to %struct.anon.2*
  %curr_line = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio16, i32 0, i32 2
  store i32 0, i32* %curr_line, align 4
  %15 = load %struct.port*, %struct.port** %pt, align 8
  store %struct.port* %15, %struct.port** %retval
  br label %return

return:                                           ; preds = %if.end.14, %if.then.6
  %16 = load %struct.port*, %struct.port** %retval
  ret %struct.port* %16
}

; Function Attrs: nounwind uwtable
define internal %struct.port* @port_rep_from_file(%struct.scheme* %sc, %struct._IO_FILE* %f, i32 %prop) #0 {
entry:
  %retval = alloca %struct.port*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %f.addr = alloca %struct._IO_FILE*, align 8
  %prop.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct._IO_FILE* %f, %struct._IO_FILE** %f.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 0
  %1 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %call = call i8* %1(i64 32)
  %2 = bitcast i8* %call to %struct.port*
  store %struct.port* %2, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.port* null, %struct.port** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %prop.addr, align 4
  %or = or i32 1, %4
  %conv = trunc i32 %or to i8
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %5, i32 0, i32 0
  store i8 %conv, i8* %kind, align 1
  %6 = load %struct._IO_FILE*, %struct._IO_FILE** %f.addr, align 8
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %file = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 0
  store %struct._IO_FILE* %6, %struct._IO_FILE** %file, align 8
  %8 = load %struct.port*, %struct.port** %pt, align 8
  %rep1 = getelementptr inbounds %struct.port, %struct.port* %8, i32 0, i32 1
  %stdio2 = bitcast %union.anon.1* %rep1 to %struct.anon.2*
  %closeit = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio2, i32 0, i32 1
  store i32 0, i32* %closeit, align 4
  %9 = load %struct.port*, %struct.port** %pt, align 8
  store %struct.port* %9, %struct.port** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load %struct.port*, %struct.port** %retval
  ret %struct.port* %10
}

; Function Attrs: nounwind uwtable
define internal %struct.port* @port_rep_from_scratch(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca %struct.port*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %pt = alloca %struct.port*, align 8
  %start = alloca i8*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 0
  %1 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %call = call i8* %1(i64 32)
  %2 = bitcast i8* %call to %struct.port*
  store %struct.port* %2, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.port* null, %struct.port** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc1 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 0
  %5 = load i8* (i64)*, i8* (i64)** %malloc1, align 8
  %call2 = call i8* %5(i64 256)
  store i8* %call2, i8** %start, align 8
  %6 = load i8*, i8** %start, align 8
  %cmp3 = icmp eq i8* %6, null
  br i1 %cmp3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  store %struct.port* null, %struct.port** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %7 = load i8*, i8** %start, align 8
  call void @llvm.memset.p0i8.i64(i8* %7, i8 32, i64 255, i32 1, i1 false)
  %8 = load i8*, i8** %start, align 8
  %arrayidx = getelementptr inbounds i8, i8* %8, i64 255
  store i8 0, i8* %arrayidx, align 1
  %9 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %9, i32 0, i32 0
  store i8 38, i8* %kind, align 1
  %10 = load i8*, i8** %start, align 8
  %11 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %11, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %start6 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 0
  store i8* %10, i8** %start6, align 8
  %12 = load i8*, i8** %start, align 8
  %13 = load %struct.port*, %struct.port** %pt, align 8
  %rep7 = getelementptr inbounds %struct.port, %struct.port* %13, i32 0, i32 1
  %string8 = bitcast %union.anon.1* %rep7 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string8, i32 0, i32 2
  store i8* %12, i8** %curr, align 8
  %14 = load i8*, i8** %start, align 8
  %add.ptr = getelementptr inbounds i8, i8* %14, i64 256
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %15 = load %struct.port*, %struct.port** %pt, align 8
  %rep10 = getelementptr inbounds %struct.port, %struct.port* %15, i32 0, i32 1
  %string11 = bitcast %union.anon.1* %rep10 to %struct.anon.3*
  %past_the_end = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string11, i32 0, i32 1
  store i8* %add.ptr9, i8** %past_the_end, align 8
  %16 = load %struct.port*, %struct.port** %pt, align 8
  store %struct.port* %16, %struct.port** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.4, %if.then
  %17 = load %struct.port*, %struct.port** %retval
  ret %struct.port* %17
}

; Function Attrs: nounwind uwtable
define internal i8* @readstr_upto(%struct.scheme* %sc, i8* %delim) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %delim.addr = alloca i8*, align 8
  %p = alloca i8*, align 8
  %c = alloca i32, align 4
  %c_prev = alloca i32, align 4
  %len = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %delim, i8** %delim.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  store i8* %arraydecay, i8** %p, align 8
  store i32 0, i32* %c, align 4
  store i32 0, i32* %c_prev, align 4
  store i32 0, i32* %len, align 4
  br label %do.body

do.body:                                          ; preds = %land.end.7, %entry
  %1 = load i32, i32* %c, align 4
  store i32 %1, i32* %c_prev, align 4
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @inchar(%struct.scheme* %2)
  store i32 %call, i32* %c, align 4
  %3 = load i32, i32* %c, align 4
  %4 = load i8*, i8** %p, align 8
  %call1 = call i32 @g_unichar_to_utf8(i32 %3, i8* %4)
  store i32 %call1, i32* %len, align 4
  %5 = load i32, i32* %len, align 4
  %6 = load i8*, i8** %p, align 8
  %idx.ext = sext i32 %5 to i64
  %add.ptr = getelementptr inbounds i8, i8* %6, i64 %idx.ext
  store i8* %add.ptr, i8** %p, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %7 = load i8*, i8** %p, align 8
  %8 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff2 = getelementptr inbounds %struct.scheme, %struct.scheme* %8, i32 0, i32 50
  %arraydecay3 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff2, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp = icmp ult i64 %sub.ptr.sub, 1024
  br i1 %cmp, label %land.rhs, label %land.end.7

land.rhs:                                         ; preds = %do.cond
  %9 = load i32, i32* %c, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %land.rhs.4, label %land.end

land.rhs.4:                                       ; preds = %land.rhs
  %10 = load i8*, i8** %delim.addr, align 8
  %11 = load i32, i32* %c, align 4
  %call5 = call i32 @is_one_of(i8* %10, i32 %11)
  %tobool6 = icmp ne i32 %call5, 0
  %lnot = xor i1 %tobool6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs.4, %land.rhs
  %12 = phi i1 [ false, %land.rhs ], [ %lnot, %land.rhs.4 ]
  br label %land.end.7

land.end.7:                                       ; preds = %land.end, %do.cond
  %13 = phi i1 [ false, %do.cond ], [ %12, %land.end ]
  br i1 %13, label %do.body, label %do.end

do.end:                                           ; preds = %land.end.7
  %14 = load i8*, i8** %p, align 8
  %15 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff8 = getelementptr inbounds %struct.scheme, %struct.scheme* %15, i32 0, i32 50
  %arraydecay9 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff8, i32 0, i32 0
  %add.ptr10 = getelementptr inbounds i8, i8* %arraydecay9, i64 2
  %cmp11 = icmp eq i8* %14, %add.ptr10
  br i1 %cmp11, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.end
  %16 = load i32, i32* %c_prev, align 4
  %cmp12 = icmp eq i32 %16, 92
  br i1 %cmp12, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %17 = load i8*, i8** %p, align 8
  store i8 0, i8* %17, align 1
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %do.end
  %18 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %19 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %18, i32 %19)
  %20 = load i32, i32* %len, align 4
  %sub = sub nsw i32 0, %20
  %idxprom = sext i32 %sub to i64
  %21 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %21, i64 %idxprom
  store i8 0, i8* %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %22 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff13 = getelementptr inbounds %struct.scheme, %struct.scheme* %22, i32 0, i32 50
  %arraydecay14 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff13, i32 0, i32 0
  ret i8* %arraydecay14
}

; Function Attrs: nounwind uwtable
define internal %struct.cell* @readstrexp(%struct.scheme* %sc) #0 {
entry:
  %retval = alloca %struct.cell*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %p = alloca i8*, align 8
  %c = alloca i32, align 4
  %c1 = alloca i32, align 4
  %len = alloca i32, align 4
  %state = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 50
  %arraydecay = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff, i32 0, i32 0
  store i8* %arraydecay, i8** %p, align 8
  store i32 0, i32* %c1, align 4
  store i32 0, i32* %state, align 4
  br label %for.cond

for.cond:                                         ; preds = %sw.epilog.70, %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %call = call i32 @inchar(%struct.scheme* %1)
  store i32 %call, i32* %c, align 4
  %2 = load i32, i32* %c, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %3 = load i8*, i8** %p, align 8
  %4 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff1 = getelementptr inbounds %struct.scheme, %struct.scheme* %4, i32 0, i32 50
  %arraydecay2 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff1, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %3 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp3 = icmp ugt i64 %sub.ptr.sub, 1023
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %for.cond
  %5 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F = getelementptr inbounds %struct.scheme, %struct.scheme* %5, i32 0, i32 21
  %6 = load %struct.cell*, %struct.cell** %F, align 8
  store %struct.cell* %6, %struct.cell** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load i32, i32* %state, align 4
  switch i32 %7, label %sw.epilog.70 [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.13
    i32 2, label %sw.bb.29
    i32 3, label %sw.bb.29
    i32 4, label %sw.bb.41
    i32 5, label %sw.bb.41
  ]

sw.bb:                                            ; preds = %if.end
  %8 = load i32, i32* %c, align 4
  switch i32 %8, label %sw.default [
    i32 92, label %sw.bb.4
    i32 34, label %sw.bb.5
  ]

sw.bb.4:                                          ; preds = %sw.bb
  store i32 1, i32* %state, align 4
  br label %sw.epilog

sw.bb.5:                                          ; preds = %sw.bb
  %9 = load i8*, i8** %p, align 8
  store i8 0, i8* %9, align 1
  %10 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %11 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff6 = getelementptr inbounds %struct.scheme, %struct.scheme* %11, i32 0, i32 50
  %arraydecay7 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff6, i32 0, i32 0
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %strbuff8 = getelementptr inbounds %struct.scheme, %struct.scheme* %12, i32 0, i32 50
  %arraydecay9 = getelementptr inbounds [1024 x i8], [1024 x i8]* %strbuff8, i32 0, i32 0
  %call10 = call i64 @g_utf8_strlen(i8* %arraydecay9, i64 1024) #6
  %conv = trunc i64 %call10 to i32
  %call11 = call %struct.cell* @mk_counted_string(%struct.scheme* %10, i8* %arraydecay7, i32 %conv)
  store %struct.cell* %call11, %struct.cell** %retval
  br label %return

sw.default:                                       ; preds = %sw.bb
  %13 = load i32, i32* %c, align 4
  %14 = load i8*, i8** %p, align 8
  %call12 = call i32 @g_unichar_to_utf8(i32 %13, i8* %14)
  store i32 %call12, i32* %len, align 4
  %15 = load i32, i32* %len, align 4
  %16 = load i8*, i8** %p, align 8
  %idx.ext = sext i32 %15 to i64
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 %idx.ext
  store i8* %add.ptr, i8** %p, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.4
  br label %sw.epilog.70

sw.bb.13:                                         ; preds = %if.end
  %17 = load i32, i32* %c, align 4
  switch i32 %17, label %sw.default.24 [
    i32 48, label %sw.bb.14
    i32 49, label %sw.bb.14
    i32 50, label %sw.bb.14
    i32 51, label %sw.bb.14
    i32 52, label %sw.bb.14
    i32 53, label %sw.bb.14
    i32 54, label %sw.bb.14
    i32 55, label %sw.bb.14
    i32 120, label %sw.bb.16
    i32 88, label %sw.bb.16
    i32 110, label %sw.bb.17
    i32 116, label %sw.bb.18
    i32 114, label %sw.bb.20
    i32 34, label %sw.bb.22
  ]

sw.bb.14:                                         ; preds = %sw.bb.13, %sw.bb.13, %sw.bb.13, %sw.bb.13, %sw.bb.13, %sw.bb.13, %sw.bb.13, %sw.bb.13
  store i32 4, i32* %state, align 4
  %18 = load i32, i32* %c, align 4
  %call15 = call i32 @g_unichar_digit_value(i32 %18) #7
  store i32 %call15, i32* %c1, align 4
  br label %sw.epilog.28

sw.bb.16:                                         ; preds = %sw.bb.13, %sw.bb.13
  store i32 2, i32* %state, align 4
  store i32 0, i32* %c1, align 4
  br label %sw.epilog.28

sw.bb.17:                                         ; preds = %sw.bb.13
  %19 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %19, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  store i8 10, i8* %19, align 1
  store i32 0, i32* %state, align 4
  br label %sw.epilog.28

sw.bb.18:                                         ; preds = %sw.bb.13
  %20 = load i8*, i8** %p, align 8
  %incdec.ptr19 = getelementptr inbounds i8, i8* %20, i32 1
  store i8* %incdec.ptr19, i8** %p, align 8
  store i8 9, i8* %20, align 1
  store i32 0, i32* %state, align 4
  br label %sw.epilog.28

sw.bb.20:                                         ; preds = %sw.bb.13
  %21 = load i8*, i8** %p, align 8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr21, i8** %p, align 8
  store i8 13, i8* %21, align 1
  store i32 0, i32* %state, align 4
  br label %sw.epilog.28

sw.bb.22:                                         ; preds = %sw.bb.13
  %22 = load i8*, i8** %p, align 8
  %incdec.ptr23 = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr23, i8** %p, align 8
  store i8 34, i8* %22, align 1
  store i32 0, i32* %state, align 4
  br label %sw.epilog.28

sw.default.24:                                    ; preds = %sw.bb.13
  %23 = load i32, i32* %c, align 4
  %24 = load i8*, i8** %p, align 8
  %call25 = call i32 @g_unichar_to_utf8(i32 %23, i8* %24)
  store i32 %call25, i32* %len, align 4
  %25 = load i32, i32* %len, align 4
  %26 = load i8*, i8** %p, align 8
  %idx.ext26 = sext i32 %25 to i64
  %add.ptr27 = getelementptr inbounds i8, i8* %26, i64 %idx.ext26
  store i8* %add.ptr27, i8** %p, align 8
  store i32 0, i32* %state, align 4
  br label %sw.epilog.28

sw.epilog.28:                                     ; preds = %sw.default.24, %sw.bb.22, %sw.bb.20, %sw.bb.18, %sw.bb.17, %sw.bb.16, %sw.bb.14
  br label %sw.epilog.70

sw.bb.29:                                         ; preds = %if.end, %if.end
  %27 = load i32, i32* %c, align 4
  %call30 = call i32 @g_unichar_isxdigit(i32 %27) #7
  %tobool = icmp ne i32 %call30, 0
  br i1 %tobool, label %if.end.33, label %if.then.31

if.then.31:                                       ; preds = %sw.bb.29
  %28 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F32 = getelementptr inbounds %struct.scheme, %struct.scheme* %28, i32 0, i32 21
  %29 = load %struct.cell*, %struct.cell** %F32, align 8
  store %struct.cell* %29, %struct.cell** %retval
  br label %return

if.end.33:                                        ; preds = %sw.bb.29
  %30 = load i32, i32* %c1, align 4
  %shl = shl i32 %30, 4
  %31 = load i32, i32* %c, align 4
  %call34 = call i32 @g_unichar_xdigit_value(i32 %31) #7
  %add = add nsw i32 %shl, %call34
  store i32 %add, i32* %c1, align 4
  %32 = load i32, i32* %state, align 4
  %cmp35 = icmp eq i32 %32, 2
  br i1 %cmp35, label %if.then.37, label %if.else

if.then.37:                                       ; preds = %if.end.33
  store i32 3, i32* %state, align 4
  br label %if.end.40

if.else:                                          ; preds = %if.end.33
  %33 = load i32, i32* %c1, align 4
  %conv38 = trunc i32 %33 to i8
  %34 = load i8*, i8** %p, align 8
  %incdec.ptr39 = getelementptr inbounds i8, i8* %34, i32 1
  store i8* %incdec.ptr39, i8** %p, align 8
  store i8 %conv38, i8* %34, align 1
  store i32 0, i32* %state, align 4
  br label %if.end.40

if.end.40:                                        ; preds = %if.else, %if.then.37
  br label %sw.epilog.70

sw.bb.41:                                         ; preds = %if.end, %if.end
  %35 = load i32, i32* %c, align 4
  %call42 = call i32 @g_unichar_isdigit(i32 %35) #7
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %lor.lhs.false.44, label %if.then.48

lor.lhs.false.44:                                 ; preds = %sw.bb.41
  %36 = load i32, i32* %c, align 4
  %call45 = call i32 @g_unichar_digit_value(i32 %36) #7
  %cmp46 = icmp sgt i32 %call45, 7
  br i1 %cmp46, label %if.then.48, label %if.else.51

if.then.48:                                       ; preds = %lor.lhs.false.44, %sw.bb.41
  %37 = load i32, i32* %c1, align 4
  %conv49 = trunc i32 %37 to i8
  %38 = load i8*, i8** %p, align 8
  %incdec.ptr50 = getelementptr inbounds i8, i8* %38, i32 1
  store i8* %incdec.ptr50, i8** %p, align 8
  store i8 %conv49, i8* %38, align 1
  %39 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %40 = load i32, i32* %c, align 4
  call void @backchar(%struct.scheme* %39, i32 %40)
  store i32 0, i32* %state, align 4
  br label %if.end.69

if.else.51:                                       ; preds = %lor.lhs.false.44
  %41 = load i32, i32* %state, align 4
  %cmp52 = icmp eq i32 %41, 5
  br i1 %cmp52, label %land.lhs.true, label %if.end.58

land.lhs.true:                                    ; preds = %if.else.51
  %42 = load i32, i32* %c1, align 4
  %cmp54 = icmp sge i32 %42, 32
  br i1 %cmp54, label %if.then.56, label %if.end.58

if.then.56:                                       ; preds = %land.lhs.true
  %43 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %F57 = getelementptr inbounds %struct.scheme, %struct.scheme* %43, i32 0, i32 21
  %44 = load %struct.cell*, %struct.cell** %F57, align 8
  store %struct.cell* %44, %struct.cell** %retval
  br label %return

if.end.58:                                        ; preds = %land.lhs.true, %if.else.51
  %45 = load i32, i32* %c1, align 4
  %shl59 = shl i32 %45, 3
  %46 = load i32, i32* %c, align 4
  %call60 = call i32 @g_unichar_digit_value(i32 %46) #7
  %add61 = add nsw i32 %shl59, %call60
  store i32 %add61, i32* %c1, align 4
  %47 = load i32, i32* %state, align 4
  %cmp62 = icmp eq i32 %47, 4
  br i1 %cmp62, label %if.then.64, label %if.else.65

if.then.64:                                       ; preds = %if.end.58
  store i32 5, i32* %state, align 4
  br label %if.end.68

if.else.65:                                       ; preds = %if.end.58
  %48 = load i32, i32* %c1, align 4
  %conv66 = trunc i32 %48 to i8
  %49 = load i8*, i8** %p, align 8
  %incdec.ptr67 = getelementptr inbounds i8, i8* %49, i32 1
  store i8* %incdec.ptr67, i8** %p, align 8
  store i8 %conv66, i8* %49, align 1
  store i32 0, i32* %state, align 4
  br label %if.end.68

if.end.68:                                        ; preds = %if.else.65, %if.then.64
  br label %if.end.69

if.end.69:                                        ; preds = %if.end.68, %if.then.48
  br label %sw.epilog.70

sw.epilog.70:                                     ; preds = %if.end, %if.end.69, %if.end.40, %sw.epilog.28, %sw.epilog
  br label %for.cond

return:                                           ; preds = %if.then.56, %if.then.31, %sw.bb.5, %if.then
  %50 = load %struct.cell*, %struct.cell** %retval
  ret %struct.cell* %50
}

; Function Attrs: nounwind
declare i8* @gettext(i8*) #3

; Function Attrs: nounwind uwtable
define internal void @printatom(%struct.scheme* %sc, %struct.cell* %l, i32 %f) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %l.addr = alloca %struct.cell*, align 8
  %f.addr = alloca i32, align 4
  %p = alloca i8*, align 8
  %len = alloca i32, align 4
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %l, %struct.cell** %l.addr, align 8
  store i32 %f, i32* %f.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.cell*, %struct.cell** %l.addr, align 8
  %2 = load i32, i32* %f.addr, align 4
  call void @atom2str(%struct.scheme* %0, %struct.cell* %1, i32 %2, i8** %p, i32* %len)
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %4 = load i8*, i8** %p, align 8
  %5 = load i32, i32* %len, align 4
  call void @putchars(%struct.scheme* %3, i8* %4, i32 %5)
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @g_unichar_digit_value(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_isxdigit(i32) #5

; Function Attrs: nounwind readnone
declare i32 @g_unichar_xdigit_value(i32) #5

; Function Attrs: nounwind uwtable
define internal %struct.cell* @mk_proc(%struct.scheme* %sc, i32 %op) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %op.addr = alloca i32, align 4
  %y = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i32 %op, i32* %op.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 17
  %2 = load %struct.cell*, %struct.cell** %NIL, align 8
  %3 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL1 = getelementptr inbounds %struct.scheme, %struct.scheme* %3, i32 0, i32 17
  %4 = load %struct.cell*, %struct.cell** %NIL1, align 8
  %call = call %struct.cell* @get_cell(%struct.scheme* %0, %struct.cell* %2, %struct.cell* %4)
  store %struct.cell* %call, %struct.cell** %y, align 8
  %5 = load %struct.cell*, %struct.cell** %y, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %5, i32 0, i32 0
  store i32 16388, i32* %_flag, align 4
  %6 = load i32, i32* %op.addr, align 4
  %conv = zext i32 %6 to i64
  %7 = load %struct.cell*, %struct.cell** %y, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %7, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  store i64 %conv, i64* %ivalue, align 8
  %8 = load %struct.cell*, %struct.cell** %y, align 8
  %_object2 = getelementptr inbounds %struct.cell, %struct.cell* %8, i32 0, i32 1
  %_number3 = bitcast %union.anon* %_object2 to %struct.num*
  %is_fixnum = getelementptr inbounds %struct.num, %struct.num* %_number3, i32 0, i32 0
  store i8 1, i8* %is_fixnum, align 1
  %9 = load %struct.cell*, %struct.cell** %y, align 8
  ret %struct.cell* %9
}

; Function Attrs: nounwind uwtable
define internal %struct.port* @port_rep_from_string(%struct.scheme* %sc, i8* %start, i8* %past_the_end, i32 %prop) #0 {
entry:
  %retval = alloca %struct.port*, align 8
  %sc.addr = alloca %struct.scheme*, align 8
  %start.addr = alloca i8*, align 8
  %past_the_end.addr = alloca i8*, align 8
  %prop.addr = alloca i32, align 4
  %pt = alloca %struct.port*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store i8* %start, i8** %start.addr, align 8
  store i8* %past_the_end, i8** %past_the_end.addr, align 8
  store i32 %prop, i32* %prop.addr, align 4
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %malloc = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 0
  %1 = load i8* (i64)*, i8* (i64)** %malloc, align 8
  %call = call i8* %1(i64 32)
  %2 = bitcast i8* %call to %struct.port*
  store %struct.port* %2, %struct.port** %pt, align 8
  %3 = load %struct.port*, %struct.port** %pt, align 8
  %cmp = icmp eq %struct.port* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct.port* null, %struct.port** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, i32* %prop.addr, align 4
  %or = or i32 2, %4
  %conv = trunc i32 %or to i8
  %5 = load %struct.port*, %struct.port** %pt, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %5, i32 0, i32 0
  store i8 %conv, i8* %kind, align 1
  %6 = load i8*, i8** %start.addr, align 8
  %7 = load %struct.port*, %struct.port** %pt, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 1
  %string = bitcast %union.anon.1* %rep to %struct.anon.3*
  %start1 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string, i32 0, i32 0
  store i8* %6, i8** %start1, align 8
  %8 = load i8*, i8** %start.addr, align 8
  %9 = load %struct.port*, %struct.port** %pt, align 8
  %rep2 = getelementptr inbounds %struct.port, %struct.port* %9, i32 0, i32 1
  %string3 = bitcast %union.anon.1* %rep2 to %struct.anon.3*
  %curr = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string3, i32 0, i32 2
  store i8* %8, i8** %curr, align 8
  %10 = load i8*, i8** %past_the_end.addr, align 8
  %11 = load %struct.port*, %struct.port** %pt, align 8
  %rep4 = getelementptr inbounds %struct.port, %struct.port* %11, i32 0, i32 1
  %string5 = bitcast %union.anon.1* %rep4 to %struct.anon.3*
  %past_the_end6 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %string5, i32 0, i32 1
  store i8* %10, i8** %past_the_end6, align 8
  %12 = load %struct.port*, %struct.port** %pt, align 8
  store %struct.port* %12, %struct.port** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %13 = load %struct.port*, %struct.port** %retval
  ret %struct.port* %13
}

; Function Attrs: nounwind uwtable
define internal void @mark(%struct.cell* %a) #0 {
entry:
  %a.addr = alloca %struct.cell*, align 8
  %t = alloca %struct.cell*, align 8
  %q = alloca %struct.cell*, align 8
  %p = alloca %struct.cell*, align 8
  %i = alloca i32, align 4
  %num = alloca i32, align 4
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  store %struct.cell* null, %struct.cell** %t, align 8
  %0 = load %struct.cell*, %struct.cell** %a.addr, align 8
  store %struct.cell* %0, %struct.cell** %p, align 8
  br label %E2

E2:                                               ; preds = %if.then.30, %if.then.16, %entry
  %1 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag = getelementptr inbounds %struct.cell, %struct.cell* %1, i32 0, i32 0
  %2 = load i32, i32* %_flag, align 4
  %or = or i32 %2, 32768
  store i32 %or, i32* %_flag, align 4
  %3 = load %struct.cell*, %struct.cell** %p, align 8
  %call = call i32 @is_vector(%struct.cell* %3)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %E2
  %4 = load %struct.cell*, %struct.cell** %p, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %4, i32 0, i32 1
  %_number = bitcast %union.anon* %_object to %struct.num*
  %value = getelementptr inbounds %struct.num, %struct.num* %_number, i32 0, i32 1
  %ivalue = bitcast %union.anon.0* %value to i64*
  %5 = load i64, i64* %ivalue, align 8
  %div = sdiv i64 %5, 2
  %6 = load %struct.cell*, %struct.cell** %p, align 8
  %_object1 = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_number2 = bitcast %union.anon* %_object1 to %struct.num*
  %value3 = getelementptr inbounds %struct.num, %struct.num* %_number2, i32 0, i32 1
  %ivalue4 = bitcast %union.anon.0* %value3 to i64*
  %7 = load i64, i64* %ivalue4, align 8
  %rem = srem i64 %7, 2
  %add = add nsw i64 %div, %rem
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %num, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %8 = load i32, i32* %i, align 4
  %9 = load i32, i32* %num, align 4
  %cmp = icmp slt i32 %8, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.cell*, %struct.cell** %p, align 8
  %add.ptr = getelementptr inbounds %struct.cell, %struct.cell* %10, i64 1
  %11 = load i32, i32* %i, align 4
  %idx.ext = sext i32 %11 to i64
  %add.ptr6 = getelementptr inbounds %struct.cell, %struct.cell* %add.ptr, i64 %idx.ext
  call void @mark(%struct.cell* %add.ptr6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32, i32* %i, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %E2
  %13 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag7 = getelementptr inbounds %struct.cell, %struct.cell* %13, i32 0, i32 0
  %14 = load i32, i32* %_flag7, align 4
  %and = and i32 %14, 16384
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.end
  br label %E6

if.end.10:                                        ; preds = %if.end
  %15 = load %struct.cell*, %struct.cell** %p, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %15, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object11 to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  %16 = load %struct.cell*, %struct.cell** %_car, align 8
  store %struct.cell* %16, %struct.cell** %q, align 8
  %17 = load %struct.cell*, %struct.cell** %q, align 8
  %tobool12 = icmp ne %struct.cell* %17, null
  br i1 %tobool12, label %land.lhs.true, label %if.end.22

land.lhs.true:                                    ; preds = %if.end.10
  %18 = load %struct.cell*, %struct.cell** %q, align 8
  %_flag13 = getelementptr inbounds %struct.cell, %struct.cell* %18, i32 0, i32 0
  %19 = load i32, i32* %_flag13, align 4
  %and14 = and i32 %19, 32768
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.end.22, label %if.then.16

if.then.16:                                       ; preds = %land.lhs.true
  %20 = load %struct.cell*, %struct.cell** %p, align 8
  %_flag17 = getelementptr inbounds %struct.cell, %struct.cell* %20, i32 0, i32 0
  %21 = load i32, i32* %_flag17, align 4
  %or18 = or i32 %21, 16384
  store i32 %or18, i32* %_flag17, align 4
  %22 = load %struct.cell*, %struct.cell** %t, align 8
  %23 = load %struct.cell*, %struct.cell** %p, align 8
  %_object19 = getelementptr inbounds %struct.cell, %struct.cell* %23, i32 0, i32 1
  %_cons20 = bitcast %union.anon* %_object19 to %struct.anon.4*
  %_car21 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons20, i32 0, i32 0
  store %struct.cell* %22, %struct.cell** %_car21, align 8
  %24 = load %struct.cell*, %struct.cell** %p, align 8
  store %struct.cell* %24, %struct.cell** %t, align 8
  %25 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %25, %struct.cell** %p, align 8
  br label %E2

if.end.22:                                        ; preds = %land.lhs.true, %if.end.10
  br label %E5

E5:                                               ; preds = %if.then.41, %if.end.22
  %26 = load %struct.cell*, %struct.cell** %p, align 8
  %_object23 = getelementptr inbounds %struct.cell, %struct.cell* %26, i32 0, i32 1
  %_cons24 = bitcast %union.anon* %_object23 to %struct.anon.4*
  %_cdr = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons24, i32 0, i32 1
  %27 = load %struct.cell*, %struct.cell** %_cdr, align 8
  store %struct.cell* %27, %struct.cell** %q, align 8
  %28 = load %struct.cell*, %struct.cell** %q, align 8
  %tobool25 = icmp ne %struct.cell* %28, null
  br i1 %tobool25, label %land.lhs.true.26, label %if.end.34

land.lhs.true.26:                                 ; preds = %E5
  %29 = load %struct.cell*, %struct.cell** %q, align 8
  %_flag27 = getelementptr inbounds %struct.cell, %struct.cell* %29, i32 0, i32 0
  %30 = load i32, i32* %_flag27, align 4
  %and28 = and i32 %30, 32768
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.end.34, label %if.then.30

if.then.30:                                       ; preds = %land.lhs.true.26
  %31 = load %struct.cell*, %struct.cell** %t, align 8
  %32 = load %struct.cell*, %struct.cell** %p, align 8
  %_object31 = getelementptr inbounds %struct.cell, %struct.cell* %32, i32 0, i32 1
  %_cons32 = bitcast %union.anon* %_object31 to %struct.anon.4*
  %_cdr33 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons32, i32 0, i32 1
  store %struct.cell* %31, %struct.cell** %_cdr33, align 8
  %33 = load %struct.cell*, %struct.cell** %p, align 8
  store %struct.cell* %33, %struct.cell** %t, align 8
  %34 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %34, %struct.cell** %p, align 8
  br label %E2

if.end.34:                                        ; preds = %land.lhs.true.26, %E5
  br label %E6

E6:                                               ; preds = %if.else, %if.end.34, %if.then.9
  %35 = load %struct.cell*, %struct.cell** %t, align 8
  %tobool35 = icmp ne %struct.cell* %35, null
  br i1 %tobool35, label %if.end.37, label %if.then.36

if.then.36:                                       ; preds = %E6
  ret void

if.end.37:                                        ; preds = %E6
  %36 = load %struct.cell*, %struct.cell** %t, align 8
  store %struct.cell* %36, %struct.cell** %q, align 8
  %37 = load %struct.cell*, %struct.cell** %q, align 8
  %_flag38 = getelementptr inbounds %struct.cell, %struct.cell* %37, i32 0, i32 0
  %38 = load i32, i32* %_flag38, align 4
  %and39 = and i32 %38, 16384
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.else

if.then.41:                                       ; preds = %if.end.37
  %39 = load %struct.cell*, %struct.cell** %q, align 8
  %_flag42 = getelementptr inbounds %struct.cell, %struct.cell* %39, i32 0, i32 0
  %40 = load i32, i32* %_flag42, align 4
  %and43 = and i32 %40, 49151
  store i32 %and43, i32* %_flag42, align 4
  %41 = load %struct.cell*, %struct.cell** %q, align 8
  %_object44 = getelementptr inbounds %struct.cell, %struct.cell* %41, i32 0, i32 1
  %_cons45 = bitcast %union.anon* %_object44 to %struct.anon.4*
  %_car46 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons45, i32 0, i32 0
  %42 = load %struct.cell*, %struct.cell** %_car46, align 8
  store %struct.cell* %42, %struct.cell** %t, align 8
  %43 = load %struct.cell*, %struct.cell** %p, align 8
  %44 = load %struct.cell*, %struct.cell** %q, align 8
  %_object47 = getelementptr inbounds %struct.cell, %struct.cell* %44, i32 0, i32 1
  %_cons48 = bitcast %union.anon* %_object47 to %struct.anon.4*
  %_car49 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons48, i32 0, i32 0
  store %struct.cell* %43, %struct.cell** %_car49, align 8
  %45 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %45, %struct.cell** %p, align 8
  br label %E5

if.else:                                          ; preds = %if.end.37
  %46 = load %struct.cell*, %struct.cell** %q, align 8
  %_object50 = getelementptr inbounds %struct.cell, %struct.cell* %46, i32 0, i32 1
  %_cons51 = bitcast %union.anon* %_object50 to %struct.anon.4*
  %_cdr52 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons51, i32 0, i32 1
  %47 = load %struct.cell*, %struct.cell** %_cdr52, align 8
  store %struct.cell* %47, %struct.cell** %t, align 8
  %48 = load %struct.cell*, %struct.cell** %p, align 8
  %49 = load %struct.cell*, %struct.cell** %q, align 8
  %_object53 = getelementptr inbounds %struct.cell, %struct.cell* %49, i32 0, i32 1
  %_cons54 = bitcast %union.anon* %_object53 to %struct.anon.4*
  %_cdr55 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons54, i32 0, i32 1
  store %struct.cell* %48, %struct.cell** %_cdr55, align 8
  %50 = load %struct.cell*, %struct.cell** %q, align 8
  store %struct.cell* %50, %struct.cell** %p, align 8
  br label %E6
}

; Function Attrs: nounwind uwtable
define internal void @dump_stack_mark(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %dump = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 10
  %1 = load %struct.cell*, %struct.cell** %dump, align 8
  call void @mark(%struct.cell* %1)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @finalize_cell(%struct.scheme* %sc, %struct.cell* %a) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  %a.addr = alloca %struct.cell*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  store %struct.cell* %a, %struct.cell** %a.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call = call i32 @is_string(%struct.cell* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free = getelementptr inbounds %struct.scheme, %struct.scheme* %1, i32 0, i32 1
  %2 = load void (i8*)*, void (i8*)** %free, align 8
  %3 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_string = bitcast %union.anon* %_object to %struct.anon*
  %_svalue = getelementptr inbounds %struct.anon, %struct.anon* %_string, i32 0, i32 0
  %4 = load i8*, i8** %_svalue, align 8
  call void %2(i8* %4)
  br label %if.end.14

if.else:                                          ; preds = %entry
  %5 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %call1 = call i32 @is_port(%struct.cell* %5)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.13

if.then.3:                                        ; preds = %if.else
  %6 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object4 = getelementptr inbounds %struct.cell, %struct.cell* %6, i32 0, i32 1
  %_port = bitcast %union.anon* %_object4 to %struct.port**
  %7 = load %struct.port*, %struct.port** %_port, align 8
  %kind = getelementptr inbounds %struct.port, %struct.port* %7, i32 0, i32 0
  %8 = load i8, i8* %kind, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 1
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then.3
  %9 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object6 = getelementptr inbounds %struct.cell, %struct.cell* %9, i32 0, i32 1
  %_port7 = bitcast %union.anon* %_object6 to %struct.port**
  %10 = load %struct.port*, %struct.port** %_port7, align 8
  %rep = getelementptr inbounds %struct.port, %struct.port* %10, i32 0, i32 1
  %stdio = bitcast %union.anon.1* %rep to %struct.anon.2*
  %closeit = getelementptr inbounds %struct.anon.2, %struct.anon.2* %stdio, i32 0, i32 1
  %11 = load i32, i32* %closeit, align 4
  %tobool8 = icmp ne i32 %11, 0
  br i1 %tobool8, label %if.then.9, label %if.end

if.then.9:                                        ; preds = %land.lhs.true
  %12 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %13 = load %struct.cell*, %struct.cell** %a.addr, align 8
  call void @port_close(%struct.scheme* %12, %struct.cell* %13, i32 48)
  br label %if.end

if.end:                                           ; preds = %if.then.9, %land.lhs.true, %if.then.3
  %14 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %free10 = getelementptr inbounds %struct.scheme, %struct.scheme* %14, i32 0, i32 1
  %15 = load void (i8*)*, void (i8*)** %free10, align 8
  %16 = load %struct.cell*, %struct.cell** %a.addr, align 8
  %_object11 = getelementptr inbounds %struct.cell, %struct.cell* %16, i32 0, i32 1
  %_port12 = bitcast %union.anon* %_object11 to %struct.port**
  %17 = load %struct.port*, %struct.port** %_port12, align 8
  %18 = bitcast %struct.port* %17 to i8*
  call void %15(i8* %18)
  br label %if.end.13

if.end.13:                                        ; preds = %if.end, %if.else
  br label %if.end.14

if.end.14:                                        ; preds = %if.end.13, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @ok_to_freely_gc(%struct.scheme* %sc) #0 {
entry:
  %sc.addr = alloca %struct.scheme*, align 8
  store %struct.scheme* %sc, %struct.scheme** %sc.addr, align 8
  %0 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %NIL = getelementptr inbounds %struct.scheme, %struct.scheme* %0, i32 0, i32 17
  %1 = load %struct.cell*, %struct.cell** %NIL, align 8
  %2 = load %struct.scheme*, %struct.scheme** %sc.addr, align 8
  %sink = getelementptr inbounds %struct.scheme, %struct.scheme* %2, i32 0, i32 15
  %3 = load %struct.cell*, %struct.cell** %sink, align 8
  %_object = getelementptr inbounds %struct.cell, %struct.cell* %3, i32 0, i32 1
  %_cons = bitcast %union.anon* %_object to %struct.anon.4*
  %_car = getelementptr inbounds %struct.anon.4, %struct.anon.4* %_cons, i32 0, i32 0
  store %struct.cell* %1, %struct.cell** %_car, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal i32 @is_any(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal i32 @is_nonneg(%struct.cell* %p) #0 {
entry:
  %p.addr = alloca %struct.cell*, align 8
  store %struct.cell* %p, %struct.cell** %p.addr, align 8
  %0 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call = call i64 @ivalue(%struct.cell* %0)
  %cmp = icmp sge i64 %call, 0
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %1 = load %struct.cell*, %struct.cell** %p.addr, align 8
  %call1 = call i32 @is_integer(%struct.cell* %1)
  %tobool = icmp ne i32 %call1, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %2 to i32
  ret i32 %land.ext
}

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind readonly }
attributes #7 = { nounwind readnone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
