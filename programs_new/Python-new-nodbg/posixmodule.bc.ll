; ModuleID = './posixmodule.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._object = type { i64, %struct._typeobject* }
%struct._typeobject = type { %struct.PyVarObject, i8*, i64, i64, void (%struct._object*)*, i32 (%struct._object*, %struct._IO_FILE*, i32)*, %struct._object* (%struct._object*, i8*)*, i32 (%struct._object*, i8*, %struct._object*)*, i8*, %struct._object* (%struct._object*)*, %struct.PyNumberMethods*, %struct.PySequenceMethods*, %struct.PyMappingMethods*, i64 (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*, %struct._object*)*, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, i32 (%struct._object*, %struct._object*, %struct._object*)*, %struct.PyBufferProcs*, i64, i8*, i32 (%struct._object*, i32 (%struct._object*, i8*)*, i8*)*, i32 (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*, i32)*, i64, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*)*, %struct.PyMethodDef*, %struct.PyMemberDef*, %struct.PyGetSetDef*, %struct._typeobject*, %struct._object*, %struct._object* (%struct._object*, %struct._object*, %struct._object*)*, i32 (%struct._object*, %struct._object*, %struct._object*)*, i64, i32 (%struct._object*, %struct._object*, %struct._object*)*, %struct._object* (%struct._typeobject*, i64)*, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)*, void (i8*)*, i32 (%struct._object*)*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, void (%struct._object*)*, i32, void (%struct._object*)* }
%struct.PyVarObject = type { %struct._object, i64 }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.PyNumberMethods = type { %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*, %struct._object*)*, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*)*, i32 (%struct._object*)*, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*)*, i8*, %struct._object* (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*)* }
%struct.PySequenceMethods = type { i64 (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, i64)*, %struct._object* (%struct._object*, i64)*, i8*, i32 (%struct._object*, i64, %struct._object*)*, i8*, i32 (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, %struct._object* (%struct._object*, i64)* }
%struct.PyMappingMethods = type { i64 (%struct._object*)*, %struct._object* (%struct._object*, %struct._object*)*, i32 (%struct._object*, %struct._object*, %struct._object*)* }
%struct.PyBufferProcs = type { i32 (%struct._object*, %struct.bufferinfo*, i32)*, void (%struct._object*, %struct.bufferinfo*)* }
%struct.bufferinfo = type { i8*, %struct._object*, i64, i64, i32, i32, i8*, i64*, i64*, i64*, i8* }
%struct.PyMethodDef = type { i8*, %struct._object* (%struct._object*, %struct._object*)*, i32, i8* }
%struct.PyMemberDef = type opaque
%struct.PyGetSetDef = type { i8*, %struct._object* (%struct._object*, i8*)*, i32 (%struct._object*, %struct._object*, i8*)*, i8*, i8* }
%struct.PyModuleDef = type { %struct.PyModuleDef_Base, i8*, i8*, i64, %struct.PyMethodDef*, i32 (%struct._object*)*, i32 (%struct._object*, i32 (%struct._object*, i8*)*, i8*)*, i32 (%struct._object*)*, void (i8*)* }
%struct.PyModuleDef_Base = type { %struct._object, %struct._object* ()*, i64, %struct._object* }
%struct.PyStructSequence_Desc = type { i8*, i8*, %struct.PyStructSequence_Field*, i32 }
%struct.PyStructSequence_Field = type { i8*, i8* }
%struct._Py_Identifier = type { %struct._Py_Identifier*, i8*, %struct._object* }
%struct.constdef = type { i8*, i64 }
%struct.PyTupleObject = type { %struct.PyVarObject, [1 x %struct._object*] }
%struct.path_t = type { i8*, i8*, i32, i32, i32*, i8*, i32, i64, %struct._object*, %struct._object* }
%struct._ts = type { %struct._ts*, %struct._ts*, %struct._is*, %struct._frame*, i32, i8, i8, i32, i32, i32 (%struct._object*, %struct._frame*, i32, %struct._object*)*, i32 (%struct._object*, %struct._frame*, i32, %struct._object*)*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, i32, %struct._object*, i64, i32, %struct._object*, void (i8*)*, i8* }
%struct._is = type { %struct._is*, %struct._ts*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, %struct._object*, i32, i32, i32, %struct._object* }
%struct._frame = type opaque
%struct.utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.utime_t = type { i32, i64, i64, i64, i64 }
%struct.tms = type { i64, i64, i64, i64 }
%struct.sched_param = type { i32 }
%struct.timespec = type { i64, i64 }
%struct.cpu_set_t = type { [16 x i64] }
%struct.termios = type { i32, i32, i32, i32, i8, [32 x i8], i32, i32 }
%struct.winsize = type { i16, i16, i16, i16 }
%struct.PyListObject = type { %struct.PyVarObject, %struct._object**, i64 }
%struct.PyBytesObject = type { %struct.PyVarObject, i64, [1 x i8] }
%union.__WAIT_STATUS = type { %union.wait* }
%union.wait = type { i32 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon, %union.anon.1, %union.anon.2, %union.anon.3, %union.anon.4, %union.anon.5, %union.anon.6, %union.anon.7, %union.anon.8, %union.anon.9, %union.anon.10, %union.anon.11, %union.anon.12, %union.anon.13 }
%struct.timeval = type { i64, i64 }
%union.anon = type { i64 }
%union.anon.1 = type { i64 }
%union.anon.2 = type { i64 }
%union.anon.3 = type { i64 }
%union.anon.4 = type { i64 }
%union.anon.5 = type { i64 }
%union.anon.6 = type { i64 }
%union.anon.7 = type { i64 }
%union.anon.8 = type { i64 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.11 = type { i64 }
%union.anon.12 = type { i64 }
%union.anon.13 = type { i64 }
%struct.siginfo_t = type { i32, i32, i32, %union.anon.14 }
%union.anon.14 = type { %struct.anon.18, [80 x i8] }
%struct.anon.18 = type { i32, i32, i32, i64, i64 }
%struct.anon.15 = type { i32, i32 }
%struct.iovec = type { i8*, i64 }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%union.anon.22 = type { i32 }
%union.anon.23 = type { i32 }
%union.anon.24 = type { i32 }
%union.anon.25 = type { i32 }
%union.anon.26 = type { i32 }
%union.anon.27 = type { i32 }
%union.anon.28 = type { i32 }
%union.anon.29 = type { i32 }
%struct.statvfs = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [6 x i32] }
%struct.__dirstream = type opaque
%struct.dirent = type { i64, i64, i16, i8, [256 x i8] }

@PyExc_TypeError = external global %struct._object*, align 8
@.str = private unnamed_addr constant [34 x i8] c"uid should be integer, not %.200s\00", align 1
@PyExc_OverflowError = external global %struct._object*, align 8
@.str.1 = private unnamed_addr constant [25 x i8] c"uid is less than minimum\00", align 1
@.str.2 = private unnamed_addr constant [28 x i8] c"uid is greater than maximum\00", align 1
@.str.3 = private unnamed_addr constant [34 x i8] c"gid should be integer, not %.200s\00", align 1
@.str.4 = private unnamed_addr constant [25 x i8] c"gid is less than minimum\00", align 1
@.str.5 = private unnamed_addr constant [28 x i8] c"gid is greater than maximum\00", align 1
@posixmodule = internal global %struct.PyModuleDef { %struct.PyModuleDef_Base { %struct._object { i64 1, %struct._typeobject* null }, %struct._object* ()* null, i64 0, %struct._object* null }, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([259 x i8], [259 x i8]* @posix__doc__, i32 0, i32 0), i64 -1, %struct.PyMethodDef* getelementptr inbounds ([146 x %struct.PyMethodDef], [146 x %struct.PyMethodDef]* @posix_methods, i32 0, i32 0), i32 (%struct._object*)* null, i32 (%struct._object*, i32 (%struct._object*, i8*)*, i8*)* null, i32 (%struct._object*)* null, void (i8*)* null }, align 8
@.str.6 = private unnamed_addr constant [8 x i8] c"environ\00", align 1
@PyExc_OSError = external global %struct._object*, align 8
@.str.7 = private unnamed_addr constant [6 x i8] c"error\00", align 1
@posix_putenv_garbage = internal global %struct._object* null, align 8
@initialized = internal global i32 0, align 4
@.str.8 = private unnamed_addr constant [20 x i8] c"posix.waitid_result\00", align 1
@waitid_result_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.12, i32 0, i32 0), i8* getelementptr inbounds ([221 x i8], [221 x i8]* @waitid_result__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([6 x %struct.PyStructSequence_Field], [6 x %struct.PyStructSequence_Field]* @waitid_result_fields, i32 0, i32 0), i32 5 }, align 8
@WaitidResultType = internal global %struct._typeobject zeroinitializer, align 8
@.str.9 = private unnamed_addr constant [15 x i8] c"os.stat_result\00", align 1
@stat_result_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13, i32 0, i32 0), i8* getelementptr inbounds ([398 x i8], [398 x i8]* @stat_result__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([20 x %struct.PyStructSequence_Field], [20 x %struct.PyStructSequence_Field]* @stat_result_fields, i32 0, i32 0), i32 10 }, align 8
@PyStructSequence_UnnamedField = external global i8*, align 8
@StatResultType = internal global %struct._typeobject zeroinitializer, align 8
@structseq_new = internal global %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)* null, align 8
@.str.10 = private unnamed_addr constant [18 x i8] c"os.statvfs_result\00", align 1
@statvfs_result_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14, i32 0, i32 0), i8* getelementptr inbounds ([287 x i8], [287 x i8]* @statvfs_result__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([11 x %struct.PyStructSequence_Field], [11 x %struct.PyStructSequence_Field]* @statvfs_result_fields, i32 0, i32 0), i32 10 }, align 8
@StatVFSResultType = internal global %struct._typeobject zeroinitializer, align 8
@ticks_per_second = internal global i64 -1, align 8
@.str.11 = private unnamed_addr constant [18 x i8] c"posix.sched_param\00", align 1
@sched_param_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([97 x i8], [97 x i8]* @sched_param__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([2 x %struct.PyStructSequence_Field], [2 x %struct.PyStructSequence_Field]* @sched_param_fields, i32 0, i32 0), i32 1 }, align 8
@SchedParamType = internal global %struct._typeobject zeroinitializer, align 8
@TerminalSizeType = internal global %struct._typeobject zeroinitializer, align 8
@TerminalSize_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.696, i32 0, i32 0), i8* getelementptr inbounds ([61 x i8], [61 x i8]* @TerminalSize_docstring, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([3 x %struct.PyStructSequence_Field], [3 x %struct.PyStructSequence_Field]* @TerminalSize_fields, i32 0, i32 0), i32 2 }, align 8
@.str.12 = private unnamed_addr constant [14 x i8] c"waitid_result\00", align 1
@.str.13 = private unnamed_addr constant [12 x i8] c"stat_result\00", align 1
@.str.14 = private unnamed_addr constant [15 x i8] c"statvfs_result\00", align 1
@.str.15 = private unnamed_addr constant [12 x i8] c"sched_param\00", align 1
@.str.16 = private unnamed_addr constant [19 x i8] c"posix.times_result\00", align 1
@times_result_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.17, i32 0, i32 0), i8* getelementptr inbounds ([264 x i8], [264 x i8]* @times_result__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([6 x %struct.PyStructSequence_Field], [6 x %struct.PyStructSequence_Field]* @times_result_fields, i32 0, i32 0), i32 5 }, align 8
@TimesResultType = internal global %struct._typeobject zeroinitializer, align 8
@.str.17 = private unnamed_addr constant [13 x i8] c"times_result\00", align 1
@.str.18 = private unnamed_addr constant [19 x i8] c"posix.uname_result\00", align 1
@uname_result_desc = internal global %struct.PyStructSequence_Desc { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19, i32 0, i32 0), i8* getelementptr inbounds ([246 x i8], [246 x i8]* @uname_result__doc__, i32 0, i32 0), %struct.PyStructSequence_Field* getelementptr inbounds ([6 x %struct.PyStructSequence_Field], [6 x %struct.PyStructSequence_Field]* @uname_result_fields, i32 0, i32 0), i32 5 }, align 8
@UnameResultType = internal global %struct._typeobject zeroinitializer, align 8
@.str.19 = private unnamed_addr constant [13 x i8] c"uname_result\00", align 1
@.str.20 = private unnamed_addr constant [14 x i8] c"terminal_size\00", align 1
@billion = internal global %struct._object* null, align 8
@.str.21 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.22 = private unnamed_addr constant [6 x i8] c"chmod\00", align 1
@_Py_NoneStruct = external global %struct._object, align 8
@have_functions = internal global [29 x i8*] [i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.723, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.724, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.725, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.726, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.727, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.728, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.729, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.730, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.731, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.732, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.733, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.734, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.735, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.736, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.737, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.738, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.739, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.740, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.741, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.742, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.743, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.744, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.745, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.746, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.747, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.748, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.749, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.750, i32 0, i32 0), i8* null], align 16
@.str.23 = private unnamed_addr constant [16 x i8] c"_have_functions\00", align 1
@.str.24 = private unnamed_addr constant [6 x i8] c"posix\00", align 1
@posix__doc__ = internal global [259 x i8] c"This module provides access to operating system functionality that is\0Astandardized by the C Standard and the POSIX standard (a thinly\0Adisguised Unix interface).  Refer to the library manual and\0Acorresponding Unix manual entries for more information on calls.\00", align 16
@posix_methods = internal global [146 x %struct.PyMethodDef] [%struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct.PyModuleDef*, %struct._object*, %struct._object*)* @os_stat to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([784 x i8], [784 x i8]* @os_stat__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct.PyModuleDef*, %struct._object*, %struct._object*)* @os_access to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([1149 x i8], [1149 x i8]* @os_access__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.27, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct.PyModuleDef*, %struct._object*)* @os_ttyname to %struct._object* (%struct._object*, %struct._object*)*), i32 1, i8* getelementptr inbounds ([128 x i8], [128 x i8]* @os_ttyname__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.28, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_chdir to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([260 x i8], [260 x i8]* @posix_chdir__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_chmod to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([845 x i8], [845 x i8]* @posix_chmod__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.29, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fchmod, i32 1, i8* getelementptr inbounds ([124 x i8], [124 x i8]* @posix_fchmod__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_chown to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([874 x i8], [874 x i8]* @posix_chown__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.31, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fchown, i32 1, i8* getelementptr inbounds ([159 x i8], [159 x i8]* @posix_fchown__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.32, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_lchown, i32 1, i8* getelementptr inbounds ([199 x i8], [199 x i8]* @posix_lchown__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.33, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_chroot, i32 1, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @posix_chroot__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.34, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_ctermid, i32 4, i8* getelementptr inbounds ([83 x i8], [83 x i8]* @posix_ctermid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.35, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*)* @posix_getcwd_unicode to %struct._object* (%struct._object*, %struct._object*)*), i32 4, i8* getelementptr inbounds ([86 x i8], [86 x i8]* @posix_getcwd__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.36, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*)* @posix_getcwd_bytes to %struct._object* (%struct._object*, %struct._object*)*), i32 4, i8* getelementptr inbounds ([85 x i8], [85 x i8]* @posix_getcwdb__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_link to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([657 x i8], [657 x i8]* @posix_link__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.38, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_listdir to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([611 x i8], [611 x i8]* @posix_listdir__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.39, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_lstat to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([140 x i8], [140 x i8]* @posix_lstat__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.40, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_mkdir to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([371 x i8], [371 x i8]* @posix_mkdir__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.41, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_nice, i32 1, i8* getelementptr inbounds ([96 x i8], [96 x i8]* @posix_nice__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getpriority, i32 1, i8* getelementptr inbounds ([78 x i8], [78 x i8]* @posix_getpriority__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.43, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setpriority, i32 1, i8* getelementptr inbounds ([72 x i8], [72 x i8]* @posix_setpriority__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.44, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_readlink to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([381 x i8], [381 x i8]* @readlink__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_rename to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([442 x i8], [442 x i8]* @posix_rename__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_replace to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([472 x i8], [472 x i8]* @posix_replace__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.47, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_rmdir to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([317 x i8], [317 x i8]* @posix_rmdir__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.48, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @stat_float_times, i32 1, i8* getelementptr inbounds ([260 x i8], [260 x i8]* @stat_float_times__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_symlink to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([638 x i8], [638 x i8]* @posix_symlink__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_system, i32 1, i8* getelementptr inbounds ([78 x i8], [78 x i8]* @posix_system__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_umask, i32 1, i8* getelementptr inbounds ([90 x i8], [90 x i8]* @posix_umask__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.52, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_uname, i32 4, i8* getelementptr inbounds ([198 x i8], [198 x i8]* @posix_uname__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.53, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_unlink to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([332 x i8], [332 x i8]* @posix_unlink__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.54, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_unlink to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([332 x i8], [332 x i8]* @posix_remove__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_utime to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([1254 x i8], [1254 x i8]* @posix_utime__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_times, i32 4, i8* getelementptr inbounds ([207 x i8], [207 x i8]* @posix_times__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.57, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix__exit, i32 1, i8* getelementptr inbounds ([89 x i8], [89 x i8]* @posix__exit__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.58, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_execv, i32 1, i8* getelementptr inbounds ([159 x i8], [159 x i8]* @posix_execv__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_execve to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([434 x i8], [434 x i8]* @posix_execve__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.60, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fork, i32 4, i8* getelementptr inbounds ([99 x i8], [99 x i8]* @posix_fork__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.61, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_get_priority_max, i32 1, i8* getelementptr inbounds ([82 x i8], [82 x i8]* @posix_sched_get_priority_max__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.62, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_get_priority_min, i32 1, i8* getelementptr inbounds ([82 x i8], [82 x i8]* @posix_sched_get_priority_min__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.63, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_getparam, i32 1, i8* getelementptr inbounds ([172 x i8], [172 x i8]* @posix_sched_getparam__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.64, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_getscheduler, i32 1, i8* getelementptr inbounds ([162 x i8], [162 x i8]* @posix_sched_getscheduler__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.65, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_rr_get_interval, i32 1, i8* getelementptr inbounds ([111 x i8], [111 x i8]* @posix_sched_rr_get_interval__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.66, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_setparam, i32 1, i8* getelementptr inbounds ([122 x i8], [122 x i8]* @posix_sched_setparam__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_setscheduler, i32 1, i8* getelementptr inbounds ([174 x i8], [174 x i8]* @posix_sched_setscheduler__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.68, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_yield, i32 4, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @posix_sched_yield__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.69, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_setaffinity, i32 1, i8* getelementptr inbounds ([94 x i8], [94 x i8]* @posix_sched_setaffinity__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.70, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sched_getaffinity, i32 1, i8* getelementptr inbounds ([139 x i8], [139 x i8]* @posix_sched_getaffinity__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.71, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_openpty, i32 4, i8* getelementptr inbounds ([112 x i8], [112 x i8]* @posix_openpty__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.72, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_forkpty, i32 4, i8* getelementptr inbounds ([226 x i8], [226 x i8]* @posix_forkpty__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.73, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getegid, i32 4, i8* getelementptr inbounds ([68 x i8], [68 x i8]* @posix_getegid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.74, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_geteuid, i32 4, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @posix_geteuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.75, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getgid, i32 4, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @posix_getgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.76, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getgrouplist, i32 1, i8* getelementptr inbounds ([186 x i8], [186 x i8]* @posix_getgrouplist__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.77, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getgroups, i32 4, i8* getelementptr inbounds ([89 x i8], [89 x i8]* @posix_getgroups__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.78, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getpid, i32 4, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @posix_getpid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getpgrp, i32 4, i8* getelementptr inbounds ([56 x i8], [56 x i8]* @posix_getpgrp__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.80, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getppid, i32 4, i8* getelementptr inbounds ([198 x i8], [198 x i8]* @posix_getppid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.81, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getuid, i32 4, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @posix_getuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.82, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getlogin, i32 4, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @posix_getlogin__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.83, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_kill, i32 1, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @posix_kill__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.84, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_killpg, i32 1, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @posix_killpg__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.85, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setuid, i32 1, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @posix_setuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.86, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_seteuid, i32 1, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @posix_seteuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.87, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setegid, i32 1, i8* getelementptr inbounds ([60 x i8], [60 x i8]* @posix_setegid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.88, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setreuid, i32 1, i8* getelementptr inbounds ([77 x i8], [77 x i8]* @posix_setreuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.89, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setregid, i32 1, i8* getelementptr inbounds ([78 x i8], [78 x i8]* @posix_setregid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.90, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setgid, i32 1, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @posix_setgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.91, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setgroups, i32 8, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @posix_setgroups__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.92, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_initgroups, i32 1, i8* getelementptr inbounds ([197 x i8], [197 x i8]* @posix_initgroups__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.93, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getpgid, i32 1, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @posix_getpgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.94, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setpgrp, i32 4, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @posix_setpgrp__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.95, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_wait, i32 4, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @posix_wait__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.96, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_wait3, i32 1, i8* getelementptr inbounds ([81 x i8], [81 x i8]* @posix_wait3__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.97, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_wait4, i32 1, i8* getelementptr inbounds ([92 x i8], [92 x i8]* @posix_wait4__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.98, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_waitid, i32 1, i8* getelementptr inbounds ([424 x i8], [424 x i8]* @posix_waitid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.99, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_waitpid, i32 1, i8* getelementptr inbounds ([86 x i8], [86 x i8]* @posix_waitpid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.100, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getsid, i32 1, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @posix_getsid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.101, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setsid, i32 4, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @posix_setsid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.102, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setpgid, i32 1, i8* getelementptr inbounds ([52 x i8], [52 x i8]* @posix_setpgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.103, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_tcgetpgrp, i32 1, i8* getelementptr inbounds ([92 x i8], [92 x i8]* @posix_tcgetpgrp__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.104, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_tcsetpgrp, i32 1, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @posix_tcsetpgrp__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.105, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_open to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([379 x i8], [379 x i8]* @posix_open__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.106, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_close_, i32 1, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @posix_close__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.107, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_closerange, i32 1, i8* getelementptr inbounds ([96 x i8], [96 x i8]* @posix_closerange__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.108, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @device_encoding, i32 1, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @device_encoding__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.109, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_dup, i32 1, i8* getelementptr inbounds ([57 x i8], [57 x i8]* @posix_dup__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.110, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_dup2 to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @posix_dup2__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_lockf, i32 1, i8* getelementptr inbounds ([241 x i8], [241 x i8]* @posix_lockf__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.112, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_lseek, i32 1, i8* getelementptr inbounds ([148 x i8], [148 x i8]* @posix_lseek__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.113, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_read, i32 1, i8* getelementptr inbounds ([55 x i8], [55 x i8]* @posix_read__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.114, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_readv, i32 1, i8* getelementptr inbounds ([373 x i8], [373 x i8]* @posix_readv__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.115, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_pread, i32 1, i8* getelementptr inbounds ([181 x i8], [181 x i8]* @posix_pread__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_write, i32 1, i8* getelementptr inbounds ([67 x i8], [67 x i8]* @posix_write__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.117, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_writev, i32 1, i8* getelementptr inbounds ([259 x i8], [259 x i8]* @posix_writev__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.118, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_pwrite, i32 1, i8* getelementptr inbounds ([131 x i8], [131 x i8]* @posix_pwrite__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.119, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_sendfile to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([216 x i8], [216 x i8]* @posix_sendfile__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.120, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fstat, i32 1, i8* getelementptr inbounds ([99 x i8], [99 x i8]* @posix_fstat__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.121, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_isatty, i32 1, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @posix_isatty__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.122, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_pipe, i32 4, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @posix_pipe__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.123, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_pipe2, i32 8, i8* getelementptr inbounds ([176 x i8], [176 x i8]* @posix_pipe2__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.124, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_mkfifo to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([346 x i8], [346 x i8]* @posix_mkfifo__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.125, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_mknod to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([699 x i8], [699 x i8]* @posix_mknod__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.126, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_major, i32 1, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @posix_major__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.127, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_minor, i32 1, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @posix_minor__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.128, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_makedev, i32 1, i8* getelementptr inbounds ([109 x i8], [109 x i8]* @posix_makedev__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.129, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_ftruncate, i32 1, i8* getelementptr inbounds ([62 x i8], [62 x i8]* @posix_ftruncate__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.130, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_truncate to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([217 x i8], [217 x i8]* @posix_truncate__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.131, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_posix_fallocate, i32 1, i8* getelementptr inbounds ([158 x i8], [158 x i8]* @posix_posix_fallocate__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.132, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_posix_fadvise, i32 1, i8* getelementptr inbounds ([400 x i8], [400 x i8]* @posix_posix_fadvise__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.133, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_putenv, i32 1, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @posix_putenv__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.134, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_unsetenv, i32 1, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @posix_unsetenv__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.135, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_strerror, i32 1, i8* getelementptr inbounds ([71 x i8], [71 x i8]* @posix_strerror__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.136, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fchdir, i32 8, i8* getelementptr inbounds ([142 x i8], [142 x i8]* @posix_fchdir__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.137, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fsync, i32 8, i8* getelementptr inbounds ([64 x i8], [64 x i8]* @posix_fsync__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.138, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sync, i32 4, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @posix_sync__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.139, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fdatasync, i32 8, i8* getelementptr inbounds ([104 x i8], [104 x i8]* @posix_fdatasync__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.140, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WCOREDUMP, i32 1, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @posix_WCOREDUMP__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.141, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WIFCONTINUED, i32 1, i8* getelementptr inbounds ([115 x i8], [115 x i8]* @posix_WIFCONTINUED__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.142, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WIFSTOPPED, i32 1, i8* getelementptr inbounds ([87 x i8], [87 x i8]* @posix_WIFSTOPPED__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.143, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WIFSIGNALED, i32 1, i8* getelementptr inbounds ([103 x i8], [103 x i8]* @posix_WIFSIGNALED__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.144, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WIFEXITED, i32 1, i8* getelementptr inbounds ([110 x i8], [110 x i8]* @posix_WIFEXITED__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.145, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WEXITSTATUS, i32 1, i8* getelementptr inbounds ([78 x i8], [78 x i8]* @posix_WEXITSTATUS__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.146, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WTERMSIG, i32 1, i8* getelementptr inbounds ([109 x i8], [109 x i8]* @posix_WTERMSIG__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.147, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_WSTOPSIG, i32 1, i8* getelementptr inbounds ([106 x i8], [106 x i8]* @posix_WSTOPSIG__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.148, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fstatvfs, i32 1, i8* getelementptr inbounds ([108 x i8], [108 x i8]* @posix_fstatvfs__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_statvfs to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([251 x i8], [251 x i8]* @posix_statvfs__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.150, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_confstr, i32 1, i8* getelementptr inbounds ([79 x i8], [79 x i8]* @posix_confstr__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.151, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_sysconf, i32 1, i8* getelementptr inbounds ([82 x i8], [82 x i8]* @posix_sysconf__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.152, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_fpathconf, i32 1, i8* getelementptr inbounds ([129 x i8], [129 x i8]* @posix_fpathconf__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.153, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_pathconf to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([278 x i8], [278 x i8]* @posix_pathconf__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.154, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_abort, i32 4, i8* getelementptr inbounds ([163 x i8], [163 x i8]* @posix_abort__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.155, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getloadavg, i32 4, i8* getelementptr inbounds ([193 x i8], [193 x i8]* @posix_getloadavg__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.156, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_urandom, i32 1, i8* getelementptr inbounds ([73 x i8], [73 x i8]* @posix_urandom__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.157, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setresuid, i32 1, i8* getelementptr inbounds ([92 x i8], [92 x i8]* @posix_setresuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.158, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_setresgid, i32 1, i8* getelementptr inbounds ([93 x i8], [93 x i8]* @posix_setresgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.159, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getresuid, i32 4, i8* getelementptr inbounds ([107 x i8], [107 x i8]* @posix_getresuid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.160, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_getresgid, i32 4, i8* getelementptr inbounds ([108 x i8], [108 x i8]* @posix_getresgid__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.161, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_setxattr to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([347 x i8], [347 x i8]* @posix_setxattr__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_getxattr to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([349 x i8], [349 x i8]* @posix_getxattr__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.163, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_removexattr to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([331 x i8], [331 x i8]* @posix_removexattr__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.164, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*, %struct._object*, %struct._object*)* @posix_listxattr to %struct._object* (%struct._object*, %struct._object*)*), i32 3, i8* getelementptr inbounds ([393 x i8], [393 x i8]* @posix_listxattr__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.165, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @get_terminal_size, i32 1, i8* getelementptr inbounds ([467 x i8], [467 x i8]* @termsize__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.166, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* bitcast (%struct._object* (%struct._object*)* @posix_cpu_count to %struct._object* (%struct._object*, %struct._object*)*), i32 4, i8* getelementptr inbounds ([110 x i8], [110 x i8]* @posix_cpu_count__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.167, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_get_inheritable, i32 1, i8* getelementptr inbounds ([89 x i8], [89 x i8]* @get_inheritable__doc__, i32 0, i32 0) }, %struct.PyMethodDef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.168, i32 0, i32 0), %struct._object* (%struct._object*, %struct._object*)* @posix_set_inheritable, i32 1, i8* getelementptr inbounds ([93 x i8], [93 x i8]* @set_inheritable__doc__, i32 0, i32 0) }, %struct.PyMethodDef zeroinitializer], align 16
@.str.25 = private unnamed_addr constant [5 x i8] c"stat\00", align 1
@os_stat__doc__ = internal global [784 x i8] c"stat($module, /, path, *, dir_fd=None, follow_symlinks=True)\0A--\0A\0APerform a stat system call on the given path.\0A\0A  path\0A    Path to be examined; can be string, bytes, or open-file-descriptor int.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be a relative string; path will then be relative to\0A    that directory.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    stat will examine the symbolic link itself instead of the file\0A    the link points to.\0A\0Adir_fd and follow_symlinks may not be implemented\0A  on your platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\0A\0AIt's an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\00", align 16
@.str.26 = private unnamed_addr constant [7 x i8] c"access\00", align 1
@os_access__doc__ = internal global [1149 x i8] c"access($module, /, path, mode, *, dir_fd=None, effective_ids=False,\0A       follow_symlinks=True)\0A--\0A\0AUse the real uid/gid to test for access to a path.\0A\0A  path\0A    Path to be tested; can be string, bytes, or open-file-descriptor int.\0A  mode\0A    Operating-system mode bitfield.  Can be F_OK to test existence,\0A    or the inclusive-OR of R_OK, W_OK, and X_OK.\0A  dir_fd\0A    If not None, it should be a file descriptor open to a directory,\0A    and path should be relative; path will then be relative to that\0A    directory.\0A  effective_ids\0A    If True, access will use the effective uid/gid instead of\0A    the real uid/gid.\0A  follow_symlinks\0A    If False, and the last element of the path is a symbolic link,\0A    access will examine the symbolic link itself instead of the file\0A    the link points to.\0A\0Adir_fd, effective_ids, and follow_symlinks may not be implemented\0A  on your platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\0A\0ANote that most operations will use the effective uid/gid, therefore this\0A  routine can be used in a suid/sgid environment to test if the invoking user\0A  has the specified access to the path.\00", align 16
@.str.27 = private unnamed_addr constant [8 x i8] c"ttyname\00", align 1
@os_ttyname__doc__ = internal global [128 x i8] c"ttyname($module, fd, /)\0A--\0A\0AReturn the name of the terminal device connected to 'fd'.\0A\0A  fd\0A    Integer file descriptor handle.\00", align 16
@.str.28 = private unnamed_addr constant [6 x i8] c"chdir\00", align 1
@posix_chdir__doc__ = internal global [260 x i8] c"chdir(path)\0A\0AChange the current working directory to the specified path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@posix_chmod__doc__ = internal global [845 x i8] c"chmod(path, mode, *, dir_fd=None, follow_symlinks=True)\0A\0AChange the access permissions of a file.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, chmod will modify the symbolic link itself instead of the file the\0A  link points to.\0AIt is an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\0Adir_fd and follow_symlinks may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.29 = private unnamed_addr constant [7 x i8] c"fchmod\00", align 1
@posix_fchmod__doc__ = internal global [124 x i8] c"fchmod(fd, mode)\0A\0AChange the access permissions of the file given by file\0Adescriptor fd.  Equivalent to os.chmod(fd, mode).\00", align 16
@.str.30 = private unnamed_addr constant [6 x i8] c"chown\00", align 1
@posix_chown__doc__ = internal global [874 x i8] c"chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)\0A\0AChange the owner and group id of path to the numeric uid and gid.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, chown will modify the symbolic link itself instead of the file the\0A  link points to.\0AIt is an error to use dir_fd or follow_symlinks when specifying path as\0A  an open file descriptor.\0Adir_fd and follow_symlinks may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.31 = private unnamed_addr constant [7 x i8] c"fchown\00", align 1
@posix_fchown__doc__ = internal global [159 x i8] c"fchown(fd, uid, gid)\0A\0AChange the owner and group id of the file given by file descriptor\0Afd to the numeric uid and gid.  Equivalent to os.chown(fd, uid, gid).\00", align 16
@.str.32 = private unnamed_addr constant [7 x i8] c"lchown\00", align 1
@posix_lchown__doc__ = internal global [199 x i8] c"lchown(path, uid, gid)\0A\0AChange the owner and group id of path to the numeric uid and gid.\0AThis function will not follow symbolic links.\0AEquivalent to os.chown(path, uid, gid, follow_symlinks=False).\00", align 16
@.str.33 = private unnamed_addr constant [7 x i8] c"chroot\00", align 1
@posix_chroot__doc__ = internal global [45 x i8] c"chroot(path)\0A\0AChange root directory to path.\00", align 16
@.str.34 = private unnamed_addr constant [8 x i8] c"ctermid\00", align 1
@posix_ctermid__doc__ = internal global [83 x i8] c"ctermid() -> string\0A\0AReturn the name of the controlling terminal for this process.\00", align 16
@.str.35 = private unnamed_addr constant [7 x i8] c"getcwd\00", align 1
@posix_getcwd__doc__ = internal global [86 x i8] c"getcwd() -> path\0A\0AReturn a unicode string representing the current working directory.\00", align 16
@.str.36 = private unnamed_addr constant [8 x i8] c"getcwdb\00", align 1
@posix_getcwdb__doc__ = internal global [85 x i8] c"getcwdb() -> path\0A\0AReturn a bytes string representing the current working directory.\00", align 16
@.str.37 = private unnamed_addr constant [5 x i8] c"link\00", align 1
@posix_link__doc__ = internal global [657 x i8] c"link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)\0A\0ACreate a hard link to a file.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of src is a symbolic\0A  link, link will create a link to the symbolic link itself instead of the\0A  file the link points to.\0Asrc_dir_fd, dst_dir_fd, and follow_symlinks may not be implemented on your\0A  platform.  If they are unavailable, using them will raise a\0A  NotImplementedError.\00", align 16
@.str.38 = private unnamed_addr constant [8 x i8] c"listdir\00", align 1
@posix_listdir__doc__ = internal global [611 x i8] c"listdir(path='.') -> list_of_filenames\0A\0AReturn a list containing the names of the files in the directory.\0AThe list is in arbitrary order.  It does not include the special\0Aentries '.' and '..' even if they are present in the directory.\0A\0Apath can be specified as either str or bytes.  If path is bytes,\0A  the filenames returned will also be bytes; in all other circumstances\0A  the filenames returned will be str.\0AOn some platforms, path may also be specified as an open file descriptor;\0A  the file descriptor must refer to a directory.\0A  If this functionality is unavailable, using it raises NotImplementedError.\00", align 16
@.str.39 = private unnamed_addr constant [6 x i8] c"lstat\00", align 1
@posix_lstat__doc__ = internal global [140 x i8] c"lstat(path, *, dir_fd=None) -> stat result\0A\0ALike stat(), but do not follow symbolic links.\0AEquivalent to stat(path, follow_symlinks=False).\00", align 16
@.str.40 = private unnamed_addr constant [6 x i8] c"mkdir\00", align 1
@posix_mkdir__doc__ = internal global [371 x i8] c"mkdir(path, mode=0o777, *, dir_fd=None)\0A\0ACreate a directory.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\0A\0AThe mode argument is ignored on Windows.\00", align 16
@.str.41 = private unnamed_addr constant [5 x i8] c"nice\00", align 1
@posix_nice__doc__ = internal global [96 x i8] c"nice(inc) -> new_priority\0A\0ADecrease the priority of process by inc and return the new priority.\00", align 16
@.str.42 = private unnamed_addr constant [12 x i8] c"getpriority\00", align 1
@posix_getpriority__doc__ = internal global [78 x i8] c"getpriority(which, who) -> current_priority\0A\0AGet program scheduling priority.\00", align 16
@.str.43 = private unnamed_addr constant [12 x i8] c"setpriority\00", align 1
@posix_setpriority__doc__ = internal global [72 x i8] c"setpriority(which, who, prio) -> None\0A\0ASet program scheduling priority.\00", align 16
@.str.44 = private unnamed_addr constant [9 x i8] c"readlink\00", align 1
@readlink__doc__ = internal global [381 x i8] c"readlink(path, *, dir_fd=None) -> path\0A\0AReturn a string representing the path to which the symbolic link points.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.45 = private unnamed_addr constant [7 x i8] c"rename\00", align 1
@posix_rename__doc__ = internal global [442 x i8] c"rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)\0A\0ARename a file or directory.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0Asrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.46 = private unnamed_addr constant [8 x i8] c"replace\00", align 1
@posix_replace__doc__ = internal global [472 x i8] c"replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)\0A\0ARename a file or directory, overwriting the destination.\0A\0AIf either src_dir_fd or dst_dir_fd is not None, it should be a file\0A  descriptor open to a directory, and the respective path string (src or dst)\0A  should be relative; the path will then be relative to that directory.\0Asrc_dir_fd and dst_dir_fd, may not be implemented on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.47 = private unnamed_addr constant [6 x i8] c"rmdir\00", align 1
@posix_rmdir__doc__ = internal global [317 x i8] c"rmdir(path, *, dir_fd=None)\0A\0ARemove a directory.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.48 = private unnamed_addr constant [17 x i8] c"stat_float_times\00", align 1
@stat_float_times__doc__ = internal global [260 x i8] c"stat_float_times([newval]) -> oldval\0A\0ADetermine whether os.[lf]stat represents time stamps as float objects.\0AIf newval is True, future calls to stat() return floats, if it is False,\0Afuture calls return ints. \0AIf newval is omitted, return the current setting.\0A\00", align 16
@.str.49 = private unnamed_addr constant [8 x i8] c"symlink\00", align 1
@posix_symlink__doc__ = internal global [638 x i8] c"symlink(src, dst, target_is_directory=False, *, dir_fd=None)\0A\0ACreate a symbolic link pointing to src named dst.\0A\0Atarget_is_directory is required on Windows if the target is to be\0A  interpreted as a directory.  (On Windows, symlink requires\0A  Windows 6.0 or greater, and raises a NotImplementedError otherwise.)\0A  target_is_directory is ignored on non-Windows platforms.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.50 = private unnamed_addr constant [7 x i8] c"system\00", align 1
@posix_system__doc__ = internal global [78 x i8] c"system(command) -> exit_status\0A\0AExecute the command (a string) in a subshell.\00", align 16
@.str.51 = private unnamed_addr constant [6 x i8] c"umask\00", align 1
@posix_umask__doc__ = internal global [90 x i8] c"umask(new_mask) -> old_mask\0A\0ASet the current numeric umask and return the previous umask.\00", align 16
@.str.52 = private unnamed_addr constant [6 x i8] c"uname\00", align 1
@posix_uname__doc__ = internal global [198 x i8] c"uname() -> uname_result\0A\0AReturn an object identifying the current operating system.\0AThe object behaves like a named tuple with the following fields:\0A  (sysname, nodename, release, version, machine)\00", align 16
@.str.53 = private unnamed_addr constant [7 x i8] c"unlink\00", align 1
@posix_unlink__doc__ = internal global [332 x i8] c"unlink(path, *, dir_fd=None)\0A\0ARemove a file (same as remove()).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.54 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@posix_remove__doc__ = internal global [332 x i8] c"remove(path, *, dir_fd=None)\0A\0ARemove a file (same as unlink()).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.55 = private unnamed_addr constant [6 x i8] c"utime\00", align 1
@posix_utime__doc__ = internal global [1254 x i8] c"utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True)\0ASet the access and modified time of path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\0A\0AIf times is not None, it must be a tuple (atime, mtime);\0A    atime and mtime should be expressed as float seconds since the epoch.\0AIf ns is not None, it must be a tuple (atime_ns, mtime_ns);\0A    atime_ns and mtime_ns should be expressed as integer nanoseconds\0A    since the epoch.\0AIf both times and ns are None, utime uses the current time.\0ASpecifying tuples for both times and ns is an error.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, utime will modify the symbolic link itself instead of the file the\0A  link points to.\0AIt is an error to use dir_fd or follow_symlinks when specifying path\0A  as an open file descriptor.\0Adir_fd and follow_symlinks may not be available on your platform.\0A  If they are unavailable, using them will raise a NotImplementedError.\00", align 16
@.str.56 = private unnamed_addr constant [6 x i8] c"times\00", align 1
@posix_times__doc__ = internal global [207 x i8] c"times() -> times_result\0A\0AReturn an object containing floating point numbers indicating process\0Atimes.  The object behaves like a named tuple with these fields:\0A  (utime, stime, cutime, cstime, elapsed_time)\00", align 16
@.str.57 = private unnamed_addr constant [6 x i8] c"_exit\00", align 1
@posix__exit__doc__ = internal global [89 x i8] c"_exit(status)\0A\0AExit to the system with specified status, without normal exit processing.\00", align 16
@.str.58 = private unnamed_addr constant [6 x i8] c"execv\00", align 1
@posix_execv__doc__ = internal global [159 x i8] c"execv(path, args)\0A\0AExecute an executable path with arguments, replacing current process.\0A\0A    path: path of executable file\0A    args: tuple or list of strings\00", align 16
@.str.59 = private unnamed_addr constant [7 x i8] c"execve\00", align 1
@posix_execve__doc__ = internal global [434 x i8] c"execve(path, args, env)\0A\0AExecute a path with arguments and environment, replacing current process.\0A\0A    path: path of executable file\0A    args: tuple or list of arguments\0A    env: dictionary of strings mapping to strings\0A\0AOn some platforms, you may specify an open file descriptor for path;\0A  execve will execute the program the file descriptor is open to.\0A  If this functionality is unavailable, using it raises NotImplementedError.\00", align 16
@.str.60 = private unnamed_addr constant [5 x i8] c"fork\00", align 1
@posix_fork__doc__ = internal global [99 x i8] c"fork() -> pid\0A\0AFork a child process.\0AReturn 0 to child process and PID of child to parent process.\00", align 16
@.str.61 = private unnamed_addr constant [23 x i8] c"sched_get_priority_max\00", align 1
@posix_sched_get_priority_max__doc__ = internal global [82 x i8] c"sched_get_priority_max(policy)\0A\0AGet the maximum scheduling priority for *policy*.\00", align 16
@.str.62 = private unnamed_addr constant [23 x i8] c"sched_get_priority_min\00", align 1
@posix_sched_get_priority_min__doc__ = internal global [82 x i8] c"sched_get_priority_min(policy)\0A\0AGet the minimum scheduling priority for *policy*.\00", align 16
@.str.63 = private unnamed_addr constant [15 x i8] c"sched_getparam\00", align 1
@posix_sched_getparam__doc__ = internal global [172 x i8] c"sched_getparam(pid) -> sched_param\0A\0AReturns scheduling parameters for the process with *pid* as an instance of the\0Asched_param class. A PID of 0 means the calling process.\00", align 16
@.str.64 = private unnamed_addr constant [19 x i8] c"sched_getscheduler\00", align 1
@posix_sched_getscheduler__doc__ = internal global [162 x i8] c"sched_getscheduler(pid)\0A\0AGet the scheduling policy for the process with a PID of *pid*.\0APassing a PID of 0 returns the scheduling policy for the calling process.\00", align 16
@.str.65 = private unnamed_addr constant [22 x i8] c"sched_rr_get_interval\00", align 1
@posix_sched_rr_get_interval__doc__ = internal global [111 x i8] c"sched_rr_get_interval(pid) -> float\0A\0AReturn the round-robin quantum for the process with PID *pid* in seconds.\00", align 16
@.str.66 = private unnamed_addr constant [15 x i8] c"sched_setparam\00", align 1
@posix_sched_setparam__doc__ = internal global [122 x i8] c"sched_setparam(pid, param)\0A\0ASet scheduling parameters for a process with PID *pid*.\0AA PID of 0 means the calling process.\00", align 16
@.str.67 = private unnamed_addr constant [19 x i8] c"sched_setscheduler\00", align 1
@posix_sched_setscheduler__doc__ = internal global [174 x i8] c"sched_setscheduler(pid, policy, param)\0A\0ASet the scheduling policy, *policy*, for *pid*.\0AIf *pid* is 0, the calling process is changed.\0A*param* is an instance of sched_param.\00", align 16
@.str.68 = private unnamed_addr constant [12 x i8] c"sched_yield\00", align 1
@posix_sched_yield__doc__ = internal global [47 x i8] c"sched_yield()\0A\0AVoluntarily relinquish the CPU.\00", align 16
@.str.69 = private unnamed_addr constant [18 x i8] c"sched_setaffinity\00", align 1
@posix_sched_setaffinity__doc__ = internal global [94 x i8] c"sched_setaffinity(pid, cpu_set)\0A\0ASet the affinity of the process with PID *pid* to *cpu_set*.\00", align 16
@.str.70 = private unnamed_addr constant [18 x i8] c"sched_getaffinity\00", align 1
@posix_sched_getaffinity__doc__ = internal global [139 x i8] c"sched_getaffinity(pid, ncpus) -> cpu_set\0A\0AReturn the affinity of the process with PID *pid*.\0AThe returned cpu_set will be of size *ncpus*.\00", align 16
@.str.71 = private unnamed_addr constant [8 x i8] c"openpty\00", align 1
@posix_openpty__doc__ = internal global [112 x i8] c"openpty() -> (master_fd, slave_fd)\0A\0AOpen a pseudo-terminal, returning open fd's for both master and slave end.\0A\00", align 16
@.str.72 = private unnamed_addr constant [8 x i8] c"forkpty\00", align 1
@posix_forkpty__doc__ = internal global [226 x i8] c"forkpty() -> (pid, master_fd)\0A\0AFork a new process with a new pseudo-terminal as controlling tty.\0A\0ALike fork(), return 0 as pid to child process, and PID of child to parent.\0ATo both, return fd of newly opened pseudo-terminal.\0A\00", align 16
@.str.73 = private unnamed_addr constant [8 x i8] c"getegid\00", align 1
@posix_getegid__doc__ = internal global [68 x i8] c"getegid() -> egid\0A\0AReturn the current process's effective group id.\00", align 16
@.str.74 = private unnamed_addr constant [8 x i8] c"geteuid\00", align 1
@posix_geteuid__doc__ = internal global [67 x i8] c"geteuid() -> euid\0A\0AReturn the current process's effective user id.\00", align 16
@.str.75 = private unnamed_addr constant [7 x i8] c"getgid\00", align 1
@posix_getgid__doc__ = internal global [56 x i8] c"getgid() -> gid\0A\0AReturn the current process's group id.\00", align 16
@.str.76 = private unnamed_addr constant [13 x i8] c"getgrouplist\00", align 1
@posix_getgrouplist__doc__ = internal global [186 x i8] c"getgrouplist(user, group) -> list of groups to which a user belongs\0A\0AReturns a list of groups to which a user belongs.\0A\0A    user: username to lookup\0A    group: base group id of the user\00", align 16
@.str.77 = private unnamed_addr constant [10 x i8] c"getgroups\00", align 1
@posix_getgroups__doc__ = internal global [89 x i8] c"getgroups() -> list of group IDs\0A\0AReturn list of supplemental group IDs for the process.\00", align 16
@.str.78 = private unnamed_addr constant [7 x i8] c"getpid\00", align 1
@posix_getpid__doc__ = internal global [47 x i8] c"getpid() -> pid\0A\0AReturn the current process id\00", align 16
@.str.79 = private unnamed_addr constant [8 x i8] c"getpgrp\00", align 1
@posix_getpgrp__doc__ = internal global [56 x i8] c"getpgrp() -> pgrp\0A\0AReturn the current process group id.\00", align 16
@.str.80 = private unnamed_addr constant [8 x i8] c"getppid\00", align 1
@posix_getppid__doc__ = internal global [198 x i8] c"getppid() -> ppid\0A\0AReturn the parent's process id.  If the parent process has already exited,\0AWindows machines will still return its id; others systems will return the id\0Aof the 'init' process (1).\00", align 16
@.str.81 = private unnamed_addr constant [7 x i8] c"getuid\00", align 1
@posix_getuid__doc__ = internal global [55 x i8] c"getuid() -> uid\0A\0AReturn the current process's user id.\00", align 16
@.str.82 = private unnamed_addr constant [9 x i8] c"getlogin\00", align 1
@posix_getlogin__doc__ = internal global [52 x i8] c"getlogin() -> string\0A\0AReturn the actual login name.\00", align 16
@.str.83 = private unnamed_addr constant [5 x i8] c"kill\00", align 1
@posix_kill__doc__ = internal global [46 x i8] c"kill(pid, sig)\0A\0AKill a process with a signal.\00", align 16
@.str.84 = private unnamed_addr constant [7 x i8] c"killpg\00", align 1
@posix_killpg__doc__ = internal global [55 x i8] c"killpg(pgid, sig)\0A\0AKill a process group with a signal.\00", align 16
@.str.85 = private unnamed_addr constant [7 x i8] c"setuid\00", align 1
@posix_setuid__doc__ = internal global [48 x i8] c"setuid(uid)\0A\0ASet the current process's user id.\00", align 16
@.str.86 = private unnamed_addr constant [8 x i8] c"seteuid\00", align 1
@posix_seteuid__doc__ = internal global [59 x i8] c"seteuid(uid)\0A\0ASet the current process's effective user id.\00", align 16
@.str.87 = private unnamed_addr constant [8 x i8] c"setegid\00", align 1
@posix_setegid__doc__ = internal global [60 x i8] c"setegid(gid)\0A\0ASet the current process's effective group id.\00", align 16
@.str.88 = private unnamed_addr constant [9 x i8] c"setreuid\00", align 1
@posix_setreuid__doc__ = internal global [77 x i8] c"setreuid(ruid, euid)\0A\0ASet the current process's real and effective user ids.\00", align 16
@.str.89 = private unnamed_addr constant [9 x i8] c"setregid\00", align 1
@posix_setregid__doc__ = internal global [78 x i8] c"setregid(rgid, egid)\0A\0ASet the current process's real and effective group ids.\00", align 16
@.str.90 = private unnamed_addr constant [7 x i8] c"setgid\00", align 1
@posix_setgid__doc__ = internal global [49 x i8] c"setgid(gid)\0A\0ASet the current process's group id.\00", align 16
@.str.91 = private unnamed_addr constant [10 x i8] c"setgroups\00", align 1
@posix_setgroups__doc__ = internal global [64 x i8] c"setgroups(list)\0A\0ASet the groups of the current process to list.\00", align 16
@.str.92 = private unnamed_addr constant [11 x i8] c"initgroups\00", align 1
@posix_initgroups__doc__ = internal global [197 x i8] c"initgroups(username, gid) -> None\0A\0ACall the system initgroups() to initialize the group access list with all of\0Athe groups of which the specified username is a member, plus the specified\0Agroup id.\00", align 16
@.str.93 = private unnamed_addr constant [8 x i8] c"getpgid\00", align 1
@posix_getpgid__doc__ = internal global [54 x i8] c"getpgid(pid) -> pgid\0A\0ACall the system call getpgid().\00", align 16
@.str.94 = private unnamed_addr constant [8 x i8] c"setpgrp\00", align 1
@posix_setpgrp__doc__ = internal global [55 x i8] c"setpgrp()\0A\0AMake this process the process group leader.\00", align 16
@.str.95 = private unnamed_addr constant [5 x i8] c"wait\00", align 1
@posix_wait__doc__ = internal global [65 x i8] c"wait() -> (pid, status)\0A\0AWait for completion of a child process.\00", align 16
@.str.96 = private unnamed_addr constant [6 x i8] c"wait3\00", align 1
@posix_wait3__doc__ = internal global [81 x i8] c"wait3(options) -> (pid, status, rusage)\0A\0AWait for completion of a child process.\00", align 16
@.str.97 = private unnamed_addr constant [6 x i8] c"wait4\00", align 1
@posix_wait4__doc__ = internal global [92 x i8] c"wait4(pid, options) -> (pid, status, rusage)\0A\0AWait for completion of a given child process.\00", align 16
@.str.98 = private unnamed_addr constant [7 x i8] c"waitid\00", align 1
@posix_waitid__doc__ = internal global [424 x i8] c"waitid(idtype, id, options) -> waitid_result\0A\0AWait for the completion of one or more child processes.\0A\0Aidtype can be P_PID, P_PGID or P_ALL.\0Aid specifies the pid to wait on.\0Aoptions is constructed from the ORing of one or more of WEXITED, WSTOPPED\0Aor WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT.\0AReturns either waitid_result or None if WNOHANG is specified and there are\0Ano children in a waitable state.\00", align 16
@.str.99 = private unnamed_addr constant [8 x i8] c"waitpid\00", align 1
@posix_waitpid__doc__ = internal global [86 x i8] c"waitpid(pid, options) -> (pid, status)\0A\0AWait for completion of a given child process.\00", align 16
@.str.100 = private unnamed_addr constant [7 x i8] c"getsid\00", align 1
@posix_getsid__doc__ = internal global [51 x i8] c"getsid(pid) -> sid\0A\0ACall the system call getsid().\00", align 16
@.str.101 = private unnamed_addr constant [7 x i8] c"setsid\00", align 1
@posix_setsid__doc__ = internal global [41 x i8] c"setsid()\0A\0ACall the system call setsid().\00", align 16
@.str.102 = private unnamed_addr constant [8 x i8] c"setpgid\00", align 1
@posix_setpgid__doc__ = internal global [52 x i8] c"setpgid(pid, pgrp)\0A\0ACall the system call setpgid().\00", align 16
@.str.103 = private unnamed_addr constant [10 x i8] c"tcgetpgrp\00", align 1
@posix_tcgetpgrp__doc__ = internal global [92 x i8] c"tcgetpgrp(fd) -> pgid\0A\0AReturn the process group associated with the terminal given by a fd.\00", align 16
@.str.104 = private unnamed_addr constant [10 x i8] c"tcsetpgrp\00", align 1
@posix_tcsetpgrp__doc__ = internal global [87 x i8] c"tcsetpgrp(fd, pgid)\0A\0ASet the process group associated with the terminal given by a fd.\00", align 16
@.str.105 = private unnamed_addr constant [5 x i8] c"open\00", align 1
@posix_open__doc__ = internal global [379 x i8] c"open(path, flags, mode=0o777, *, dir_fd=None)\0A\0AOpen a file for low level IO.  Returns a file handle (integer).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.106 = private unnamed_addr constant [6 x i8] c"close\00", align 1
@posix_close__doc__ = internal global [55 x i8] c"close(fd)\0A\0AClose a file descriptor (for low level IO).\00", align 16
@.str.107 = private unnamed_addr constant [11 x i8] c"closerange\00", align 1
@posix_closerange__doc__ = internal global [96 x i8] c"closerange(fd_low, fd_high)\0A\0ACloses all file descriptors in [fd_low, fd_high), ignoring errors.\00", align 16
@.str.108 = private unnamed_addr constant [16 x i8] c"device_encoding\00", align 1
@device_encoding__doc__ = internal global [129 x i8] c"device_encoding(fd) -> str\0A\0AReturn a string describing the encoding of the device\0Aif the output is a terminal; else return None.\00", align 16
@.str.109 = private unnamed_addr constant [4 x i8] c"dup\00", align 1
@posix_dup__doc__ = internal global [57 x i8] c"dup(fd) -> fd2\0A\0AReturn a duplicate of a file descriptor.\00", align 16
@.str.110 = private unnamed_addr constant [5 x i8] c"dup2\00", align 1
@posix_dup2__doc__ = internal global [49 x i8] c"dup2(old_fd, new_fd)\0A\0ADuplicate file descriptor.\00", align 16
@.str.111 = private unnamed_addr constant [6 x i8] c"lockf\00", align 1
@posix_lockf__doc__ = internal global [241 x i8] c"lockf(fd, cmd, len)\0A\0AApply, test or remove a POSIX lock on an open file descriptor.\0A\0Afd is an open file descriptor.\0Acmd specifies the command to use - one of F_LOCK, F_TLOCK, F_ULOCK or\0AF_TEST.\0Alen specifies the section of the file to lock.\00", align 16
@.str.112 = private unnamed_addr constant [6 x i8] c"lseek\00", align 1
@posix_lseek__doc__ = internal global [148 x i8] c"lseek(fd, pos, how) -> newpos\0A\0ASet the current position of a file descriptor.\0AReturn the new cursor position in bytes, starting from the beginning.\00", align 16
@.str.113 = private unnamed_addr constant [5 x i8] c"read\00", align 1
@posix_read__doc__ = internal global [55 x i8] c"read(fd, buffersize) -> bytes\0A\0ARead a file descriptor.\00", align 16
@.str.114 = private unnamed_addr constant [6 x i8] c"readv\00", align 1
@posix_readv__doc__ = internal global [373 x i8] c"readv(fd, buffers) -> bytesread\0A\0ARead from a file descriptor fd into a number of mutable, bytes-like\0Aobjects (\22buffers\22).  readv will transfer data into each buffer\0Auntil it is full and then move on to the next buffer in the sequence\0Ato hold the rest of the data.\0A\0Areadv returns the total number of bytes read (which may be less than\0Athe total capacity of all the buffers.\00", align 16
@.str.115 = private unnamed_addr constant [6 x i8] c"pread\00", align 1
@posix_pread__doc__ = internal global [181 x i8] c"pread(fd, buffersize, offset) -> string\0A\0ARead from a file descriptor, fd, at a position of offset. It will read up\0Ato buffersize number of bytes. The file offset remains unchanged.\00", align 16
@.str.116 = private unnamed_addr constant [6 x i8] c"write\00", align 1
@posix_write__doc__ = internal global [67 x i8] c"write(fd, data) -> byteswritten\0A\0AWrite bytes to a file descriptor.\00", align 16
@.str.117 = private unnamed_addr constant [7 x i8] c"writev\00", align 1
@posix_writev__doc__ = internal global [259 x i8] c"writev(fd, buffers) -> byteswritten\0A\0AWrite the contents of *buffers* to file descriptor *fd*. *buffers*\0Amust be a sequence of bytes-like objects.\0A\0Awritev writes the contents of each object to the file descriptor\0Aand returns the total number of bytes written.\00", align 16
@.str.118 = private unnamed_addr constant [7 x i8] c"pwrite\00", align 1
@posix_pwrite__doc__ = internal global [131 x i8] c"pwrite(fd, string, offset) -> byteswritten\0A\0AWrite string to a file descriptor, fd, from offset, leaving the file\0Aoffset unchanged.\00", align 16
@.str.119 = private unnamed_addr constant [9 x i8] c"sendfile\00", align 1
@posix_sendfile__doc__ = internal global [216 x i8] c"sendfile(out, in, offset, nbytes) -> byteswritten\0Asendfile(out, in, offset, nbytes, headers=None, trailers=None, flags=0)\0A            -> byteswritten\0ACopy nbytes bytes from file descriptor in to file descriptor out.\00", align 16
@.str.120 = private unnamed_addr constant [6 x i8] c"fstat\00", align 1
@posix_fstat__doc__ = internal global [99 x i8] c"fstat(fd) -> stat result\0A\0ALike stat(), but for an open file descriptor.\0AEquivalent to stat(fd=fd).\00", align 16
@.str.121 = private unnamed_addr constant [7 x i8] c"isatty\00", align 1
@posix_isatty__doc__ = internal global [129 x i8] c"isatty(fd) -> bool\0A\0AReturn True if the file descriptor 'fd' is an open file descriptor\0Aconnected to the slave end of a terminal.\00", align 16
@.str.122 = private unnamed_addr constant [5 x i8] c"pipe\00", align 1
@posix_pipe__doc__ = internal global [48 x i8] c"pipe() -> (read_end, write_end)\0A\0ACreate a pipe.\00", align 16
@.str.123 = private unnamed_addr constant [6 x i8] c"pipe2\00", align 1
@posix_pipe2__doc__ = internal global [176 x i8] c"pipe2(flags) -> (read_end, write_end)\0A\0ACreate a pipe with flags set atomically.\0Aflags can be constructed by ORing together one or more of these values:\0AO_NONBLOCK, O_CLOEXEC.\0A\00", align 16
@.str.124 = private unnamed_addr constant [7 x i8] c"mkfifo\00", align 1
@posix_mkfifo__doc__ = internal global [346 x i8] c"mkfifo(path, mode=0o666, *, dir_fd=None)\0A\0ACreate a FIFO (a POSIX named pipe).\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.125 = private unnamed_addr constant [6 x i8] c"mknod\00", align 1
@posix_mknod__doc__ = internal global [699 x i8] c"mknod(filename, mode=0o600, device=0, *, dir_fd=None)\0A\0ACreate a filesystem node (file, device special file or named pipe)\0Anamed filename. mode specifies both the permissions to use and the\0Atype of node to be created, being combined (bitwise OR) with one of\0AS_IFREG, S_IFCHR, S_IFBLK, and S_IFIFO. For S_IFCHR and S_IFBLK,\0Adevice defines the newly created device special file (probably using\0Aos.makedev()), otherwise it is ignored.\0A\0AIf dir_fd is not None, it should be a file descriptor open to a directory,\0A  and path should be relative; path will then be relative to that directory.\0Adir_fd may not be implemented on your platform.\0A  If it is unavailable, using it will raise a NotImplementedError.\00", align 16
@.str.126 = private unnamed_addr constant [6 x i8] c"major\00", align 1
@posix_major__doc__ = internal global [87 x i8] c"major(device) -> major number\0AExtracts a device major number from a raw device number.\00", align 16
@.str.127 = private unnamed_addr constant [6 x i8] c"minor\00", align 1
@posix_minor__doc__ = internal global [87 x i8] c"minor(device) -> minor number\0AExtracts a device minor number from a raw device number.\00", align 16
@.str.128 = private unnamed_addr constant [8 x i8] c"makedev\00", align 1
@posix_makedev__doc__ = internal global [109 x i8] c"makedev(major, minor) -> device number\0AComposes a raw device number from the major and minor device numbers.\00", align 16
@.str.129 = private unnamed_addr constant [10 x i8] c"ftruncate\00", align 1
@posix_ftruncate__doc__ = internal global [62 x i8] c"ftruncate(fd, length)\0A\0ATruncate a file to a specified length.\00", align 16
@.str.130 = private unnamed_addr constant [9 x i8] c"truncate\00", align 1
@posix_truncate__doc__ = internal global [217 x i8] c"truncate(path, length)\0A\0ATruncate the file given by path to length bytes.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.131 = private unnamed_addr constant [16 x i8] c"posix_fallocate\00", align 1
@posix_posix_fallocate__doc__ = internal global [158 x i8] c"posix_fallocate(fd, offset, len)\0A\0AEnsures that enough disk space is allocated for the file specified by fd\0Astarting from offset and continuing for len bytes.\00", align 16
@.str.132 = private unnamed_addr constant [14 x i8] c"posix_fadvise\00", align 1
@posix_posix_fadvise__doc__ = internal global [400 x i8] c"posix_fadvise(fd, offset, len, advice)\0A\0AAnnounces an intention to access data in a specific pattern thus allowing\0Athe kernel to make optimizations.\0AThe advice applies to the region of the file specified by fd starting at\0Aoffset and continuing for len bytes.\0Aadvice is one of POSIX_FADV_NORMAL, POSIX_FADV_SEQUENTIAL,\0APOSIX_FADV_RANDOM, POSIX_FADV_NOREUSE, POSIX_FADV_WILLNEED or\0APOSIX_FADV_DONTNEED.\00", align 16
@.str.133 = private unnamed_addr constant [7 x i8] c"putenv\00", align 1
@posix_putenv__doc__ = internal global [59 x i8] c"putenv(key, value)\0A\0AChange or add an environment variable.\00", align 16
@.str.134 = private unnamed_addr constant [9 x i8] c"unsetenv\00", align 1
@posix_unsetenv__doc__ = internal global [47 x i8] c"unsetenv(key)\0A\0ADelete an environment variable.\00", align 16
@.str.135 = private unnamed_addr constant [9 x i8] c"strerror\00", align 1
@posix_strerror__doc__ = internal global [71 x i8] c"strerror(code) -> string\0A\0ATranslate an error code to a message string.\00", align 16
@.str.136 = private unnamed_addr constant [7 x i8] c"fchdir\00", align 1
@posix_fchdir__doc__ = internal global [142 x i8] c"fchdir(fd)\0A\0AChange to the directory of the given file descriptor.  fd must be\0Aopened on a directory, not a file.  Equivalent to os.chdir(fd).\00", align 16
@.str.137 = private unnamed_addr constant [6 x i8] c"fsync\00", align 1
@posix_fsync__doc__ = internal global [64 x i8] c"fsync(fildes)\0A\0Aforce write of file with filedescriptor to disk.\00", align 16
@.str.138 = private unnamed_addr constant [5 x i8] c"sync\00", align 1
@posix_sync__doc__ = internal global [43 x i8] c"sync()\0A\0AForce write of everything to disk.\00", align 16
@.str.139 = private unnamed_addr constant [10 x i8] c"fdatasync\00", align 1
@posix_fdatasync__doc__ = internal global [104 x i8] c"fdatasync(fildes)\0A\0Aforce write of file with filedescriptor to disk.\0A does not force update of metadata.\00", align 16
@.str.140 = private unnamed_addr constant [10 x i8] c"WCOREDUMP\00", align 1
@posix_WCOREDUMP__doc__ = internal global [100 x i8] c"WCOREDUMP(status) -> bool\0A\0AReturn True if the process returning 'status' was dumped to a core file.\00", align 16
@.str.141 = private unnamed_addr constant [13 x i8] c"WIFCONTINUED\00", align 1
@posix_WIFCONTINUED__doc__ = internal global [115 x i8] c"WIFCONTINUED(status) -> bool\0A\0AReturn True if the process returning 'status' was continued from a\0Ajob control stop.\00", align 16
@.str.142 = private unnamed_addr constant [11 x i8] c"WIFSTOPPED\00", align 1
@posix_WIFSTOPPED__doc__ = internal global [87 x i8] c"WIFSTOPPED(status) -> bool\0A\0AReturn True if the process returning 'status' was stopped.\00", align 16
@.str.143 = private unnamed_addr constant [12 x i8] c"WIFSIGNALED\00", align 1
@posix_WIFSIGNALED__doc__ = internal global [103 x i8] c"WIFSIGNALED(status) -> bool\0A\0AReturn True if the process returning 'status' was terminated by a signal.\00", align 16
@.str.144 = private unnamed_addr constant [10 x i8] c"WIFEXITED\00", align 1
@posix_WIFEXITED__doc__ = internal global [110 x i8] c"WIFEXITED(status) -> bool\0A\0AReturn true if the process returning 'status' exited using the exit()\0Asystem call.\00", align 16
@.str.145 = private unnamed_addr constant [12 x i8] c"WEXITSTATUS\00", align 1
@posix_WEXITSTATUS__doc__ = internal global [78 x i8] c"WEXITSTATUS(status) -> integer\0A\0AReturn the process return code from 'status'.\00", align 16
@.str.146 = private unnamed_addr constant [9 x i8] c"WTERMSIG\00", align 1
@posix_WTERMSIG__doc__ = internal global [109 x i8] c"WTERMSIG(status) -> integer\0A\0AReturn the signal that terminated the process that provided the 'status'\0Avalue.\00", align 16
@.str.147 = private unnamed_addr constant [9 x i8] c"WSTOPSIG\00", align 1
@posix_WSTOPSIG__doc__ = internal global [106 x i8] c"WSTOPSIG(status) -> integer\0A\0AReturn the signal that stopped the process that provided\0Athe 'status' value.\00", align 16
@.str.148 = private unnamed_addr constant [9 x i8] c"fstatvfs\00", align 1
@posix_fstatvfs__doc__ = internal global [108 x i8] c"fstatvfs(fd) -> statvfs result\0A\0APerform an fstatvfs system call on the given fd.\0AEquivalent to statvfs(fd).\00", align 16
@.str.149 = private unnamed_addr constant [8 x i8] c"statvfs\00", align 1
@posix_statvfs__doc__ = internal global [251 x i8] c"statvfs(path)\0A\0APerform a statvfs system call on the given path.\0A\0Apath may always be specified as a string.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.150 = private unnamed_addr constant [8 x i8] c"confstr\00", align 1
@posix_confstr__doc__ = internal global [79 x i8] c"confstr(name) -> string\0A\0AReturn a string-valued system configuration variable.\00", align 16
@.str.151 = private unnamed_addr constant [8 x i8] c"sysconf\00", align 1
@posix_sysconf__doc__ = internal global [82 x i8] c"sysconf(name) -> integer\0A\0AReturn an integer-valued system configuration variable.\00", align 16
@.str.152 = private unnamed_addr constant [10 x i8] c"fpathconf\00", align 1
@posix_fpathconf__doc__ = internal global [129 x i8] c"fpathconf(fd, name) -> integer\0A\0AReturn the configuration limit name for the file descriptor fd.\0AIf there is no limit, return -1.\00", align 16
@.str.153 = private unnamed_addr constant [9 x i8] c"pathconf\00", align 1
@posix_pathconf__doc__ = internal global [278 x i8] c"pathconf(path, name) -> integer\0A\0AReturn the configuration limit name for the file or directory path.\0AIf there is no limit, return -1.\0AOn some platforms, path may also be specified as an open file descriptor.\0A  If this functionality is unavailable, using it raises an exception.\00", align 16
@.str.154 = private unnamed_addr constant [6 x i8] c"abort\00", align 1
@posix_abort__doc__ = internal global [163 x i8] c"abort() -> does not return!\0A\0AAbort the interpreter immediately.  This 'dumps core' or otherwise fails\0Ain the hardest way possible on the hosting operating system.\00", align 16
@.str.155 = private unnamed_addr constant [11 x i8] c"getloadavg\00", align 1
@posix_getloadavg__doc__ = internal global [193 x i8] c"getloadavg() -> (float, float, float)\0A\0AReturn the number of processes in the system run queue averaged over\0Athe last 1, 5, and 15 minutes or raises OSError if the load average\0Awas unobtainable\00", align 16
@.str.156 = private unnamed_addr constant [8 x i8] c"urandom\00", align 1
@posix_urandom__doc__ = internal global [73 x i8] c"urandom(n) -> str\0A\0AReturn n random bytes suitable for cryptographic use.\00", align 16
@.str.157 = private unnamed_addr constant [10 x i8] c"setresuid\00", align 1
@posix_setresuid__doc__ = internal global [92 x i8] c"setresuid(ruid, euid, suid)\0A\0ASet the current process's real, effective, and saved user ids.\00", align 16
@.str.158 = private unnamed_addr constant [10 x i8] c"setresgid\00", align 1
@posix_setresgid__doc__ = internal global [93 x i8] c"setresgid(rgid, egid, sgid)\0A\0ASet the current process's real, effective, and saved group ids.\00", align 16
@.str.159 = private unnamed_addr constant [10 x i8] c"getresuid\00", align 1
@posix_getresuid__doc__ = internal global [107 x i8] c"getresuid() -> (ruid, euid, suid)\0A\0AGet tuple of the current process's real, effective, and saved user ids.\00", align 16
@.str.160 = private unnamed_addr constant [10 x i8] c"getresgid\00", align 1
@posix_getresgid__doc__ = internal global [108 x i8] c"getresgid() -> (rgid, egid, sgid)\0A\0AGet tuple of the current process's real, effective, and saved group ids.\00", align 16
@.str.161 = private unnamed_addr constant [9 x i8] c"setxattr\00", align 1
@posix_setxattr__doc__ = internal global [347 x i8] c"setxattr(path, attribute, value, flags=0, *, follow_symlinks=True)\0A\0ASet extended attribute attribute on path to value.\0Apath may be either a string or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, setxattr will modify the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.162 = private unnamed_addr constant [9 x i8] c"getxattr\00", align 1
@posix_getxattr__doc__ = internal global [349 x i8] c"getxattr(path, attribute, *, follow_symlinks=True) -> value\0A\0AReturn the value of extended attribute attribute on path.\0A\0Apath may be either a string or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, getxattr will examine the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.163 = private unnamed_addr constant [12 x i8] c"removexattr\00", align 1
@posix_removexattr__doc__ = internal global [331 x i8] c"removexattr(path, attribute, *, follow_symlinks=True)\0A\0ARemove extended attribute attribute on path.\0Apath may be either a string or an open file descriptor.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, removexattr will modify the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.164 = private unnamed_addr constant [10 x i8] c"listxattr\00", align 1
@posix_listxattr__doc__ = internal global [393 x i8] c"listxattr(path='.', *, follow_symlinks=True)\0A\0AReturn a list of extended attributes on path.\0A\0Apath may be either None, a string, or an open file descriptor.\0Aif path is None, listxattr will examine the current directory.\0AIf follow_symlinks is False, and the last element of the path is a symbolic\0A  link, listxattr will examine the symbolic link itself instead of the file\0A  the link points to.\00", align 16
@.str.165 = private unnamed_addr constant [18 x i8] c"get_terminal_size\00", align 1
@termsize__doc__ = internal global [467 x i8] c"Return the size of the terminal window as (columns, lines).\0A\0AThe optional argument fd (default standard output) specifies\0Awhich file descriptor should be queried.\0A\0AIf the file descriptor is not connected to a terminal, an OSError\0Ais thrown.\0A\0AThis function will only be defined if an implementation is\0Aavailable for this system.\0A\0Ashutil.get_terminal_size is the high-level function which should \0Anormally be used, os.get_terminal_size is the low-level implementation.\00", align 16
@.str.166 = private unnamed_addr constant [10 x i8] c"cpu_count\00", align 1
@posix_cpu_count__doc__ = internal global [110 x i8] c"cpu_count() -> integer\0A\0AReturn the number of CPUs in the system, or None if this value cannot be\0Aestablished.\00", align 16
@.str.167 = private unnamed_addr constant [16 x i8] c"get_inheritable\00", align 1
@get_inheritable__doc__ = internal global [89 x i8] c"get_inheritable(fd) -> bool\0A\0AGet the close-on-exe flag of the specified file descriptor.\00", align 16
@.str.168 = private unnamed_addr constant [16 x i8] c"set_inheritable\00", align 1
@set_inheritable__doc__ = internal global [93 x i8] c"set_inheritable(fd, inheritable)\0A\0ASet the inheritable flag of the specified file descriptor.\00", align 16
@os_stat._keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.169 = private unnamed_addr constant [5 x i8] c"path\00", align 1
@.str.170 = private unnamed_addr constant [7 x i8] c"dir_fd\00", align 1
@.str.171 = private unnamed_addr constant [16 x i8] c"follow_symlinks\00", align 1
@.str.172 = private unnamed_addr constant [13 x i8] c"O&|$O&p:stat\00", align 1
@.str.173 = private unnamed_addr constant [39 x i8] c"%s%scan't specify None for %s argument\00", align 1
@.str.174 = private unnamed_addr constant [3 x i8] c": \00", align 1
@.str.175 = private unnamed_addr constant [25 x i8] c"string, bytes or integer\00", align 1
@.str.176 = private unnamed_addr constant [34 x i8] c"%s%sillegal type for %s parameter\00", align 1
@PyExc_ValueError = external global %struct._object*, align 8
@.str.177 = private unnamed_addr constant [33 x i8] c"%s%sembedded NUL character in %s\00", align 1
@.str.178 = private unnamed_addr constant [34 x i8] c"argument should be %s, not %.200s\00", align 1
@.str.179 = private unnamed_addr constant [27 x i8] c"fd is greater than maximum\00", align 1
@.str.180 = private unnamed_addr constant [24 x i8] c"fd is less than minimum\00", align 1
@.str.181 = private unnamed_addr constant [47 x i8] c"%s: can't specify dir_fd without matching path\00", align 1
@.str.182 = private unnamed_addr constant [37 x i8] c"%s: can't specify both dir_fd and fd\00", align 1
@.str.183 = private unnamed_addr constant [47 x i8] c"%s: cannot use fd and follow_symlinks together\00", align 1
@_stat_float_times = internal global i32 1, align 4
@os_access._keywords = internal global [6 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.185, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.184 = private unnamed_addr constant [5 x i8] c"mode\00", align 1
@.str.185 = private unnamed_addr constant [14 x i8] c"effective_ids\00", align 1
@.str.186 = private unnamed_addr constant [17 x i8] c"O&i|$O&pp:access\00", align 1
@.str.187 = private unnamed_addr constant [10 x i8] c"i:ttyname\00", align 1
@posix_chdir.keywords = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@.str.188 = private unnamed_addr constant [9 x i8] c"O&:chdir\00", align 1
@posix_chmod.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.189 = private unnamed_addr constant [15 x i8] c"O&i|$O&p:chmod\00", align 1
@.str.190 = private unnamed_addr constant [10 x i8] c"ii:fchmod\00", align 1
@posix_chown.keywords = internal global [6 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.191, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.192, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.191 = private unnamed_addr constant [4 x i8] c"uid\00", align 1
@.str.192 = private unnamed_addr constant [4 x i8] c"gid\00", align 1
@.str.193 = private unnamed_addr constant [18 x i8] c"O&O&O&|$O&p:chown\00", align 1
@.str.194 = private unnamed_addr constant [13 x i8] c"iO&O&:fchown\00", align 1
@.str.195 = private unnamed_addr constant [14 x i8] c"O&O&O&:lchown\00", align 1
@.str.196 = private unnamed_addr constant [10 x i8] c"O&:chroot\00", align 1
@posix_link.keywords = internal global [6 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.197, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.198, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.199, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.200, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.197 = private unnamed_addr constant [4 x i8] c"src\00", align 1
@.str.198 = private unnamed_addr constant [4 x i8] c"dst\00", align 1
@.str.199 = private unnamed_addr constant [11 x i8] c"src_dir_fd\00", align 1
@.str.200 = private unnamed_addr constant [11 x i8] c"dst_dir_fd\00", align 1
@.str.201 = private unnamed_addr constant [16 x i8] c"O&O&|O&O&p:link\00", align 1
@PyExc_NotImplementedError = external global %struct._object*, align 8
@.str.202 = private unnamed_addr constant [40 x i8] c"link: src and dst must be the same type\00", align 1
@posix_listdir.keywords = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@.str.203 = private unnamed_addr constant [12 x i8] c"|O&:listdir\00", align 1
@.str.204 = private unnamed_addr constant [2 x i8] c".\00", align 1
@posix_lstat.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.205 = private unnamed_addr constant [13 x i8] c"O&|$O&:lstat\00", align 1
@posix_mkdir.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.206 = private unnamed_addr constant [14 x i8] c"O&|i$O&:mkdir\00", align 1
@.str.207 = private unnamed_addr constant [7 x i8] c"i:nice\00", align 1
@.str.208 = private unnamed_addr constant [3 x i8] c"ii\00", align 1
@.str.209 = private unnamed_addr constant [4 x i8] c"iii\00", align 1
@posix_readlink.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.210 = private unnamed_addr constant [16 x i8] c"O&|$O&:readlink\00", align 1
@internal_rename.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.197, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.198, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.199, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.200, i32 0, i32 0), i8* null], align 16
@.str.211 = private unnamed_addr constant [12 x i8] c"O&O&|$O&O&:\00", align 1
@.str.212 = private unnamed_addr constant [38 x i8] c"%s: src and dst must be the same type\00", align 1
@posix_rmdir.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.213 = private unnamed_addr constant [13 x i8] c"O&|$O&:rmdir\00", align 1
@.str.214 = private unnamed_addr constant [20 x i8] c"|i:stat_float_times\00", align 1
@PyExc_DeprecationWarning = external global %struct._object*, align 8
@.str.215 = private unnamed_addr constant [33 x i8] c"stat_float_times() is deprecated\00", align 1
@posix_symlink.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.197, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.198, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.216, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.216 = private unnamed_addr constant [20 x i8] c"target_is_directory\00", align 1
@.str.217 = private unnamed_addr constant [18 x i8] c"O&O&|i$O&:symlink\00", align 1
@.str.218 = private unnamed_addr constant [43 x i8] c"symlink: src and dst must be the same type\00", align 1
@.str.219 = private unnamed_addr constant [10 x i8] c"O&:system\00", align 1
@.str.220 = private unnamed_addr constant [8 x i8] c"i:umask\00", align 1
@posix_unlink.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.221 = private unnamed_addr constant [14 x i8] c"O&|$O&:unlink\00", align 1
@.str.222 = private unnamed_addr constant [3 x i8] c"ns\00", align 1
@.str.223 = private unnamed_addr constant [16 x i8] c"O&|O$OO&p:utime\00", align 1
@.str.224 = private unnamed_addr constant [59 x i8] c"utime: you may specify either 'times' or 'ns' but not both\00", align 1
@PyTuple_Type = external global %struct._typeobject, align 8
@.str.225 = private unnamed_addr constant [58 x i8] c"utime: 'times' must be either a tuple of two ints or None\00", align 1
@.str.226 = private unnamed_addr constant [40 x i8] c"utime: 'ns' must be a tuple of two ints\00", align 1
@.str.227 = private unnamed_addr constant [8 x i8] c"i:_exit\00", align 1
@.str.228 = private unnamed_addr constant [10 x i8] c"O&O:execv\00", align 1
@.str.229 = private unnamed_addr constant [38 x i8] c"execv() arg 2 must be a tuple or list\00", align 1
@.str.230 = private unnamed_addr constant [32 x i8] c"execv() arg 2 must not be empty\00", align 1
@posix_execve.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.231, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.232, i32 0, i32 0), i8* null], align 16
@.str.231 = private unnamed_addr constant [5 x i8] c"argv\00", align 1
@.str.232 = private unnamed_addr constant [12 x i8] c"environment\00", align 1
@.str.233 = private unnamed_addr constant [12 x i8] c"O&OO:execve\00", align 1
@.str.234 = private unnamed_addr constant [37 x i8] c"execve: argv must be a tuple or list\00", align 1
@.str.235 = private unnamed_addr constant [45 x i8] c"execve: environment must be a mapping object\00", align 1
@.str.236 = private unnamed_addr constant [41 x i8] c"env.keys() or env.values() is not a list\00", align 1
@.str.237 = private unnamed_addr constant [6 x i8] c"%s=%s\00", align 1
@PyExc_RuntimeError = external global %struct._object*, align 8
@.str.238 = private unnamed_addr constant [28 x i8] c"not holding the import lock\00", align 1
@.str.239 = private unnamed_addr constant [25 x i8] c"i:sched_get_priority_max\00", align 1
@.str.240 = private unnamed_addr constant [25 x i8] c"i:sched_get_priority_min\00", align 1
@.str.241 = private unnamed_addr constant [17 x i8] c"i:sched_getparam\00", align 1
@.str.242 = private unnamed_addr constant [21 x i8] c"i:sched_getscheduler\00", align 1
@.str.243 = private unnamed_addr constant [24 x i8] c"i:sched_rr_get_interval\00", align 1
@.str.244 = private unnamed_addr constant [19 x i8] c"iO&:sched_setparam\00", align 1
@.str.245 = private unnamed_addr constant [31 x i8] c"must have a sched_param object\00", align 1
@.str.246 = private unnamed_addr constant [28 x i8] c"sched_priority out of range\00", align 1
@.str.247 = private unnamed_addr constant [24 x i8] c"iiO&:sched_setscheduler\00", align 1
@.str.248 = private unnamed_addr constant [21 x i8] c"iO:sched_setaffinity\00", align 1
@.str.249 = private unnamed_addr constant [54 x i8] c"expected an iterator of ints, but iterator yielded %R\00", align 1
@.str.250 = private unnamed_addr constant [20 x i8] c"negative CPU number\00", align 1
@.str.251 = private unnamed_addr constant [21 x i8] c"CPU number too large\00", align 1
@.str.252 = private unnamed_addr constant [20 x i8] c"i:sched_getaffinity\00", align 1
@.str.253 = private unnamed_addr constant [42 x i8] c"could not allocate a large enough CPU set\00", align 1
@.str.254 = private unnamed_addr constant [5 x i8] c"(ii)\00", align 1
@.str.255 = private unnamed_addr constant [5 x i8] c"(Ni)\00", align 1
@.str.256 = private unnamed_addr constant [17 x i8] c"sO&:getgrouplist\00", align 1
@.str.257 = private unnamed_addr constant [31 x i8] c"unable to determine login name\00", align 1
@.str.258 = private unnamed_addr constant [8 x i8] c"ii:kill\00", align 1
@.str.259 = private unnamed_addr constant [10 x i8] c"ii:killpg\00", align 1
@.str.260 = private unnamed_addr constant [10 x i8] c"O&:setuid\00", align 1
@.str.261 = private unnamed_addr constant [11 x i8] c"O&:seteuid\00", align 1
@.str.262 = private unnamed_addr constant [11 x i8] c"O&:setegid\00", align 1
@.str.263 = private unnamed_addr constant [14 x i8] c"O&O&:setreuid\00", align 1
@.str.264 = private unnamed_addr constant [14 x i8] c"O&O&:setregid\00", align 1
@.str.265 = private unnamed_addr constant [10 x i8] c"O&:setgid\00", align 1
@.str.266 = private unnamed_addr constant [38 x i8] c"setgroups argument must be a sequence\00", align 1
@.str.267 = private unnamed_addr constant [16 x i8] c"too many groups\00", align 1
@.str.268 = private unnamed_addr constant [24 x i8] c"groups must be integers\00", align 1
@.str.269 = private unnamed_addr constant [16 x i8] c"O&O&:initgroups\00", align 1
@.str.270 = private unnamed_addr constant [10 x i8] c"i:getpgid\00", align 1
@.str.271 = private unnamed_addr constant [3 x i8] c"Ni\00", align 1
@.str.272 = private unnamed_addr constant [8 x i8] c"i:wait3\00", align 1
@wait_helper.struct_rusage = internal global %struct._object* null, align 8
@wait_helper.PyId_struct_rusage = internal global %struct._Py_Identifier { %struct._Py_Identifier* null, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.273, i32 0, i32 0), %struct._object* null }, align 8
@.str.273 = private unnamed_addr constant [14 x i8] c"struct_rusage\00", align 1
@.str.274 = private unnamed_addr constant [9 x i8] c"resource\00", align 1
@.str.275 = private unnamed_addr constant [4 x i8] c"NiN\00", align 1
@.str.276 = private unnamed_addr constant [9 x i8] c"ii:wait4\00", align 1
@.str.277 = private unnamed_addr constant [11 x i8] c"iii:waitid\00", align 1
@.str.278 = private unnamed_addr constant [11 x i8] c"ii:waitpid\00", align 1
@.str.279 = private unnamed_addr constant [9 x i8] c"i:getsid\00", align 1
@.str.280 = private unnamed_addr constant [11 x i8] c"ii:setpgid\00", align 1
@.str.281 = private unnamed_addr constant [12 x i8] c"i:tcgetpgrp\00", align 1
@.str.282 = private unnamed_addr constant [13 x i8] c"ii:tcsetpgrp\00", align 1
@posix_open.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.283, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.283 = private unnamed_addr constant [6 x i8] c"flags\00", align 1
@_Py_open_cloexec_works = external global i32, align 4
@.str.284 = private unnamed_addr constant [14 x i8] c"O&i|i$O&:open\00", align 1
@.str.285 = private unnamed_addr constant [8 x i8] c"i:close\00", align 1
@.str.286 = private unnamed_addr constant [14 x i8] c"ii:closerange\00", align 1
@.str.287 = private unnamed_addr constant [18 x i8] c"i:device_encoding\00", align 1
@.str.288 = private unnamed_addr constant [6 x i8] c"i:dup\00", align 1
@posix_dup2.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.289, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.290, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.291, i32 0, i32 0), i8* null], align 16
@.str.289 = private unnamed_addr constant [3 x i8] c"fd\00", align 1
@.str.290 = private unnamed_addr constant [4 x i8] c"fd2\00", align 1
@.str.291 = private unnamed_addr constant [12 x i8] c"inheritable\00", align 1
@.str.292 = private unnamed_addr constant [10 x i8] c"ii|i:dup2\00", align 1
@.str.293 = private unnamed_addr constant [11 x i8] c"iiO&:lockf\00", align 1
@.str.294 = private unnamed_addr constant [10 x i8] c"iOi:lseek\00", align 1
@.str.295 = private unnamed_addr constant [8 x i8] c"ii:read\00", align 1
@.str.296 = private unnamed_addr constant [9 x i8] c"iO:readv\00", align 1
@.str.297 = private unnamed_addr constant [33 x i8] c"readv() arg 2 must be a sequence\00", align 1
@.str.298 = private unnamed_addr constant [11 x i8] c"iiO&:pread\00", align 1
@.str.299 = private unnamed_addr constant [10 x i8] c"iy*:write\00", align 1
@.str.300 = private unnamed_addr constant [10 x i8] c"iO:writev\00", align 1
@.str.301 = private unnamed_addr constant [34 x i8] c"writev() arg 2 must be a sequence\00", align 1
@.str.302 = private unnamed_addr constant [13 x i8] c"iy*O&:pwrite\00", align 1
@posix_sendfile.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.303, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.304, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.305, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.306, i32 0, i32 0), i8* null], align 16
@.str.303 = private unnamed_addr constant [4 x i8] c"out\00", align 1
@.str.304 = private unnamed_addr constant [3 x i8] c"in\00", align 1
@.str.305 = private unnamed_addr constant [7 x i8] c"offset\00", align 1
@.str.306 = private unnamed_addr constant [6 x i8] c"count\00", align 1
@.str.307 = private unnamed_addr constant [14 x i8] c"iiOn:sendfile\00", align 1
@.str.308 = private unnamed_addr constant [2 x i8] c"n\00", align 1
@.str.309 = private unnamed_addr constant [8 x i8] c"i:fstat\00", align 1
@.str.310 = private unnamed_addr constant [9 x i8] c"i:isatty\00", align 1
@posix_mkfifo.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.311 = private unnamed_addr constant [15 x i8] c"O&|i$O&:mkfifo\00", align 1
@posix_mknod.keywords = internal global [5 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.184, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.312, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8* null], align 16
@.str.312 = private unnamed_addr constant [7 x i8] c"device\00", align 1
@.str.313 = private unnamed_addr constant [15 x i8] c"O&|ii$O&:mknod\00", align 1
@.str.314 = private unnamed_addr constant [8 x i8] c"i:major\00", align 1
@.str.315 = private unnamed_addr constant [8 x i8] c"i:minor\00", align 1
@.str.316 = private unnamed_addr constant [11 x i8] c"ii:makedev\00", align 1
@.str.317 = private unnamed_addr constant [14 x i8] c"iO&:ftruncate\00", align 1
@posix_truncate.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.318, i32 0, i32 0), i8* null], align 16
@.str.318 = private unnamed_addr constant [7 x i8] c"length\00", align 1
@.str.319 = private unnamed_addr constant [14 x i8] c"O&O&:truncate\00", align 1
@.str.320 = private unnamed_addr constant [22 x i8] c"iO&O&:posix_fallocate\00", align 1
@.str.321 = private unnamed_addr constant [21 x i8] c"iO&O&i:posix_fadvise\00", align 1
@.str.322 = private unnamed_addr constant [12 x i8] c"O&O&:putenv\00", align 1
@.str.323 = private unnamed_addr constant [12 x i8] c"O&:unsetenv\00", align 1
@.str.324 = private unnamed_addr constant [11 x i8] c"i:strerror\00", align 1
@.str.325 = private unnamed_addr constant [33 x i8] c"strerror() argument out of range\00", align 1
@.str.326 = private unnamed_addr constant [16 x i8] c"surrogateescape\00", align 1
@.str.327 = private unnamed_addr constant [12 x i8] c"i:WCOREDUMP\00", align 1
@.str.328 = private unnamed_addr constant [13 x i8] c"i:WCONTINUED\00", align 1
@.str.329 = private unnamed_addr constant [13 x i8] c"i:WIFSTOPPED\00", align 1
@.str.330 = private unnamed_addr constant [14 x i8] c"i:WIFSIGNALED\00", align 1
@.str.331 = private unnamed_addr constant [12 x i8] c"i:WIFEXITED\00", align 1
@.str.332 = private unnamed_addr constant [14 x i8] c"i:WEXITSTATUS\00", align 1
@.str.333 = private unnamed_addr constant [2 x i8] c"i\00", align 1
@.str.334 = private unnamed_addr constant [11 x i8] c"i:WTERMSIG\00", align 1
@.str.335 = private unnamed_addr constant [11 x i8] c"i:WSTOPSIG\00", align 1
@.str.336 = private unnamed_addr constant [11 x i8] c"i:fstatvfs\00", align 1
@posix_statvfs.keywords = internal global [2 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* null], align 16
@.str.337 = private unnamed_addr constant [11 x i8] c"O&:statvfs\00", align 1
@.str.338 = private unnamed_addr constant [11 x i8] c"O&:confstr\00", align 1
@posix_constants_confstr = internal global [27 x %struct.constdef] [%struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.341, i32 0, i32 0), i64 2 }, %struct.constdef { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.342, i32 0, i32 0), i64 3 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.343, i32 0, i32 0), i64 1004 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.344, i32 0, i32 0), i64 1005 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.345, i32 0, i32 0), i64 1006 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.346, i32 0, i32 0), i64 1007 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.347, i32 0, i32 0), i64 1000 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.348, i32 0, i32 0), i64 1001 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.349, i32 0, i32 0), i64 1002 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.350, i32 0, i32 0), i64 1003 }, %struct.constdef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.351, i32 0, i32 0), i64 0 }, %struct.constdef { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.352, i32 0, i32 0), i64 1100 }, %struct.constdef { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.353, i32 0, i32 0), i64 1101 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.354, i32 0, i32 0), i64 1102 }, %struct.constdef { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.355, i32 0, i32 0), i64 1103 }, %struct.constdef { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.356, i32 0, i32 0), i64 1104 }, %struct.constdef { i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.357, i32 0, i32 0), i64 1105 }, %struct.constdef { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.358, i32 0, i32 0), i64 1106 }, %struct.constdef { i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.359, i32 0, i32 0), i64 1107 }, %struct.constdef { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.360, i32 0, i32 0), i64 1108 }, %struct.constdef { i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.361, i32 0, i32 0), i64 1109 }, %struct.constdef { i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.362, i32 0, i32 0), i64 1110 }, %struct.constdef { i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.363, i32 0, i32 0), i64 1111 }, %struct.constdef { i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.364, i32 0, i32 0), i64 1112 }, %struct.constdef { i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.365, i32 0, i32 0), i64 1113 }, %struct.constdef { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.366, i32 0, i32 0), i64 1114 }, %struct.constdef { i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.367, i32 0, i32 0), i64 1115 }], align 16
@.str.339 = private unnamed_addr constant [48 x i8] c"configuration names must be strings or integers\00", align 1
@.str.340 = private unnamed_addr constant [32 x i8] c"unrecognized configuration name\00", align 1
@.str.341 = private unnamed_addr constant [20 x i8] c"CS_GNU_LIBC_VERSION\00", align 1
@.str.342 = private unnamed_addr constant [26 x i8] c"CS_GNU_LIBPTHREAD_VERSION\00", align 1
@.str.343 = private unnamed_addr constant [16 x i8] c"CS_LFS64_CFLAGS\00", align 1
@.str.344 = private unnamed_addr constant [17 x i8] c"CS_LFS64_LDFLAGS\00", align 1
@.str.345 = private unnamed_addr constant [14 x i8] c"CS_LFS64_LIBS\00", align 1
@.str.346 = private unnamed_addr constant [19 x i8] c"CS_LFS64_LINTFLAGS\00", align 1
@.str.347 = private unnamed_addr constant [14 x i8] c"CS_LFS_CFLAGS\00", align 1
@.str.348 = private unnamed_addr constant [15 x i8] c"CS_LFS_LDFLAGS\00", align 1
@.str.349 = private unnamed_addr constant [12 x i8] c"CS_LFS_LIBS\00", align 1
@.str.350 = private unnamed_addr constant [17 x i8] c"CS_LFS_LINTFLAGS\00", align 1
@.str.351 = private unnamed_addr constant [8 x i8] c"CS_PATH\00", align 1
@.str.352 = private unnamed_addr constant [27 x i8] c"CS_XBS5_ILP32_OFF32_CFLAGS\00", align 1
@.str.353 = private unnamed_addr constant [28 x i8] c"CS_XBS5_ILP32_OFF32_LDFLAGS\00", align 1
@.str.354 = private unnamed_addr constant [25 x i8] c"CS_XBS5_ILP32_OFF32_LIBS\00", align 1
@.str.355 = private unnamed_addr constant [30 x i8] c"CS_XBS5_ILP32_OFF32_LINTFLAGS\00", align 1
@.str.356 = private unnamed_addr constant [28 x i8] c"CS_XBS5_ILP32_OFFBIG_CFLAGS\00", align 1
@.str.357 = private unnamed_addr constant [29 x i8] c"CS_XBS5_ILP32_OFFBIG_LDFLAGS\00", align 1
@.str.358 = private unnamed_addr constant [26 x i8] c"CS_XBS5_ILP32_OFFBIG_LIBS\00", align 1
@.str.359 = private unnamed_addr constant [31 x i8] c"CS_XBS5_ILP32_OFFBIG_LINTFLAGS\00", align 1
@.str.360 = private unnamed_addr constant [26 x i8] c"CS_XBS5_LP64_OFF64_CFLAGS\00", align 1
@.str.361 = private unnamed_addr constant [27 x i8] c"CS_XBS5_LP64_OFF64_LDFLAGS\00", align 1
@.str.362 = private unnamed_addr constant [24 x i8] c"CS_XBS5_LP64_OFF64_LIBS\00", align 1
@.str.363 = private unnamed_addr constant [29 x i8] c"CS_XBS5_LP64_OFF64_LINTFLAGS\00", align 1
@.str.364 = private unnamed_addr constant [28 x i8] c"CS_XBS5_LPBIG_OFFBIG_CFLAGS\00", align 1
@.str.365 = private unnamed_addr constant [29 x i8] c"CS_XBS5_LPBIG_OFFBIG_LDFLAGS\00", align 1
@.str.366 = private unnamed_addr constant [26 x i8] c"CS_XBS5_LPBIG_OFFBIG_LIBS\00", align 1
@.str.367 = private unnamed_addr constant [31 x i8] c"CS_XBS5_LPBIG_OFFBIG_LINTFLAGS\00", align 1
@.str.368 = private unnamed_addr constant [11 x i8] c"O&:sysconf\00", align 1
@posix_constants_sysconf = internal global [134 x %struct.constdef] [%struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.369, i32 0, i32 0), i64 95 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.370, i32 0, i32 0), i64 47 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.371, i32 0, i32 0), i64 48 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.372, i32 0, i32 0), i64 96 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.373, i32 0, i32 0), i64 49 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.374, i32 0, i32 0), i64 50 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.375, i32 0, i32 0), i64 52 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.376, i32 0, i32 0), i64 51 }, %struct.constdef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.377, i32 0, i32 0), i64 97 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.378, i32 0, i32 0), i64 46 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.379, i32 0, i32 0), i64 23 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.380, i32 0, i32 0), i64 24 }, %struct.constdef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.381, i32 0, i32 0), i64 25 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.382, i32 0, i32 0), i64 0 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.383, i32 0, i32 0), i64 12 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.384, i32 0, i32 0), i64 87 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.385, i32 0, i32 0), i64 86 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.386, i32 0, i32 0), i64 36 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.387, i32 0, i32 0), i64 37 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.388, i32 0, i32 0), i64 38 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.389, i32 0, i32 0), i64 39 }, %struct.constdef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.390, i32 0, i32 0), i64 45 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.391, i32 0, i32 0), i64 101 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.392, i32 0, i32 0), i64 102 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.393, i32 0, i32 0), i64 103 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.394, i32 0, i32 0), i64 1 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.395, i32 0, i32 0), i64 2 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.396, i32 0, i32 0), i64 40 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.397, i32 0, i32 0), i64 26 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.398, i32 0, i32 0), i64 41 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.399, i32 0, i32 0), i64 42 }, %struct.constdef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.400, i32 0, i32 0), i64 15 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.401, i32 0, i32 0), i64 69 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.402, i32 0, i32 0), i64 70 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.403, i32 0, i32 0), i64 104 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.404, i32 0, i32 0), i64 105 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.405, i32 0, i32 0), i64 60 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.406, i32 0, i32 0), i64 7 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.407, i32 0, i32 0), i64 43 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.408, i32 0, i32 0), i64 71 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.409, i32 0, i32 0), i64 106 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.410, i32 0, i32 0), i64 16 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.411, i32 0, i32 0), i64 108 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.412, i32 0, i32 0), i64 17 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.413, i32 0, i32 0), i64 18 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.414, i32 0, i32 0), i64 19 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.415, i32 0, i32 0), i64 20 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.416, i32 0, i32 0), i64 27 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.417, i32 0, i32 0), i64 28 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.418, i32 0, i32 0), i64 3 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.419, i32 0, i32 0), i64 119 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.420, i32 0, i32 0), i64 120 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.421, i32 0, i32 0), i64 121 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.422, i32 0, i32 0), i64 122 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.423, i32 0, i32 0), i64 123 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.424, i32 0, i32 0), i64 124 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.425, i32 0, i32 0), i64 83 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.426, i32 0, i32 0), i64 84 }, %struct.constdef { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.427, i32 0, i32 0), i64 109 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.428, i32 0, i32 0), i64 4 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.429, i32 0, i32 0), i64 30 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.430, i32 0, i32 0), i64 30 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.431, i32 0, i32 0), i64 88 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.432, i32 0, i32 0), i64 85 }, %struct.constdef { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.433, i32 0, i32 0), i64 53 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.434, i32 0, i32 0), i64 56 }, %struct.constdef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.435, i32 0, i32 0), i64 62 }, %struct.constdef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.436, i32 0, i32 0), i64 61 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.437, i32 0, i32 0), i64 57 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.438, i32 0, i32 0), i64 64 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.439, i32 0, i32 0), i64 63 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.440, i32 0, i32 0), i64 65 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.441, i32 0, i32 0), i64 55 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.442, i32 0, i32 0), i64 54 }, %struct.constdef { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.443, i32 0, i32 0), i64 58 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.444, i32 0, i32 0), i64 13 }, %struct.constdef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.445, i32 0, i32 0), i64 10 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.446, i32 0, i32 0), i64 9 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.447, i32 0, i32 0), i64 44 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.448, i32 0, i32 0), i64 31 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.449, i32 0, i32 0), i64 8 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.450, i32 0, i32 0), i64 111 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.451, i32 0, i32 0), i64 112 }, %struct.constdef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.452, i32 0, i32 0), i64 59 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.453, i32 0, i32 0), i64 21 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.454, i32 0, i32 0), i64 32 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.455, i32 0, i32 0), i64 33 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.456, i32 0, i32 0), i64 22 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.457, i32 0, i32 0), i64 113 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.458, i32 0, i32 0), i64 114 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.459, i32 0, i32 0), i64 34 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.460, i32 0, i32 0), i64 110 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.461, i32 0, i32 0), i64 5 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.462, i32 0, i32 0), i64 14 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.463, i32 0, i32 0), i64 67 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.464, i32 0, i32 0), i64 77 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.465, i32 0, i32 0), i64 78 }, %struct.constdef { i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.466, i32 0, i32 0), i64 73 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.467, i32 0, i32 0), i64 74 }, %struct.constdef { i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.468, i32 0, i32 0), i64 79 }, %struct.constdef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.469, i32 0, i32 0), i64 80 }, %struct.constdef { i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.470, i32 0, i32 0), i64 81 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.471, i32 0, i32 0), i64 82 }, %struct.constdef { i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.472, i32 0, i32 0), i64 68 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.473, i32 0, i32 0), i64 75 }, %struct.constdef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.474, i32 0, i32 0), i64 76 }, %struct.constdef { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.475, i32 0, i32 0), i64 11 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.476, i32 0, i32 0), i64 35 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.477, i32 0, i32 0), i64 72 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.478, i32 0, i32 0), i64 6 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.479, i32 0, i32 0), i64 66 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.480, i32 0, i32 0), i64 115 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.481, i32 0, i32 0), i64 116 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.482, i32 0, i32 0), i64 60 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.483, i32 0, i32 0), i64 117 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.484, i32 0, i32 0), i64 118 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.485, i32 0, i32 0), i64 29 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.486, i32 0, i32 0), i64 107 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.487, i32 0, i32 0), i64 125 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.488, i32 0, i32 0), i64 126 }, %struct.constdef { i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.489, i32 0, i32 0), i64 127 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.490, i32 0, i32 0), i64 128 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.491, i32 0, i32 0), i64 92 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.492, i32 0, i32 0), i64 93 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.493, i32 0, i32 0), i64 129 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.494, i32 0, i32 0), i64 130 }, %struct.constdef { i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.495, i32 0, i32 0), i64 131 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.496, i32 0, i32 0), i64 94 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.497, i32 0, i32 0), i64 91 }, %struct.constdef { i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.498, i32 0, i32 0), i64 89 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.499, i32 0, i32 0), i64 90 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.500, i32 0, i32 0), i64 98 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.501, i32 0, i32 0), i64 99 }, %struct.constdef { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.502, i32 0, i32 0), i64 100 }], align 16
@.str.369 = private unnamed_addr constant [15 x i8] c"SC_2_CHAR_TERM\00", align 1
@.str.370 = private unnamed_addr constant [12 x i8] c"SC_2_C_BIND\00", align 1
@.str.371 = private unnamed_addr constant [11 x i8] c"SC_2_C_DEV\00", align 1
@.str.372 = private unnamed_addr constant [15 x i8] c"SC_2_C_VERSION\00", align 1
@.str.373 = private unnamed_addr constant [14 x i8] c"SC_2_FORT_DEV\00", align 1
@.str.374 = private unnamed_addr constant [14 x i8] c"SC_2_FORT_RUN\00", align 1
@.str.375 = private unnamed_addr constant [15 x i8] c"SC_2_LOCALEDEF\00", align 1
@.str.376 = private unnamed_addr constant [12 x i8] c"SC_2_SW_DEV\00", align 1
@.str.377 = private unnamed_addr constant [9 x i8] c"SC_2_UPE\00", align 1
@.str.378 = private unnamed_addr constant [13 x i8] c"SC_2_VERSION\00", align 1
@.str.379 = private unnamed_addr constant [18 x i8] c"SC_AIO_LISTIO_MAX\00", align 1
@.str.380 = private unnamed_addr constant [11 x i8] c"SC_AIO_MAX\00", align 1
@.str.381 = private unnamed_addr constant [22 x i8] c"SC_AIO_PRIO_DELTA_MAX\00", align 1
@.str.382 = private unnamed_addr constant [11 x i8] c"SC_ARG_MAX\00", align 1
@.str.383 = private unnamed_addr constant [19 x i8] c"SC_ASYNCHRONOUS_IO\00", align 1
@.str.384 = private unnamed_addr constant [14 x i8] c"SC_ATEXIT_MAX\00", align 1
@.str.385 = private unnamed_addr constant [16 x i8] c"SC_AVPHYS_PAGES\00", align 1
@.str.386 = private unnamed_addr constant [15 x i8] c"SC_BC_BASE_MAX\00", align 1
@.str.387 = private unnamed_addr constant [14 x i8] c"SC_BC_DIM_MAX\00", align 1
@.str.388 = private unnamed_addr constant [16 x i8] c"SC_BC_SCALE_MAX\00", align 1
@.str.389 = private unnamed_addr constant [17 x i8] c"SC_BC_STRING_MAX\00", align 1
@.str.390 = private unnamed_addr constant [22 x i8] c"SC_CHARCLASS_NAME_MAX\00", align 1
@.str.391 = private unnamed_addr constant [12 x i8] c"SC_CHAR_BIT\00", align 1
@.str.392 = private unnamed_addr constant [12 x i8] c"SC_CHAR_MAX\00", align 1
@.str.393 = private unnamed_addr constant [12 x i8] c"SC_CHAR_MIN\00", align 1
@.str.394 = private unnamed_addr constant [13 x i8] c"SC_CHILD_MAX\00", align 1
@.str.395 = private unnamed_addr constant [11 x i8] c"SC_CLK_TCK\00", align 1
@.str.396 = private unnamed_addr constant [20 x i8] c"SC_COLL_WEIGHTS_MAX\00", align 1
@.str.397 = private unnamed_addr constant [18 x i8] c"SC_DELAYTIMER_MAX\00", align 1
@.str.398 = private unnamed_addr constant [19 x i8] c"SC_EQUIV_CLASS_MAX\00", align 1
@.str.399 = private unnamed_addr constant [17 x i8] c"SC_EXPR_NEST_MAX\00", align 1
@.str.400 = private unnamed_addr constant [9 x i8] c"SC_FSYNC\00", align 1
@.str.401 = private unnamed_addr constant [20 x i8] c"SC_GETGR_R_SIZE_MAX\00", align 1
@.str.402 = private unnamed_addr constant [20 x i8] c"SC_GETPW_R_SIZE_MAX\00", align 1
@.str.403 = private unnamed_addr constant [11 x i8] c"SC_INT_MAX\00", align 1
@.str.404 = private unnamed_addr constant [11 x i8] c"SC_INT_MIN\00", align 1
@.str.405 = private unnamed_addr constant [11 x i8] c"SC_IOV_MAX\00", align 1
@.str.406 = private unnamed_addr constant [15 x i8] c"SC_JOB_CONTROL\00", align 1
@.str.407 = private unnamed_addr constant [12 x i8] c"SC_LINE_MAX\00", align 1
@.str.408 = private unnamed_addr constant [18 x i8] c"SC_LOGIN_NAME_MAX\00", align 1
@.str.409 = private unnamed_addr constant [12 x i8] c"SC_LONG_BIT\00", align 1
@.str.410 = private unnamed_addr constant [16 x i8] c"SC_MAPPED_FILES\00", align 1
@.str.411 = private unnamed_addr constant [14 x i8] c"SC_MB_LEN_MAX\00", align 1
@.str.412 = private unnamed_addr constant [11 x i8] c"SC_MEMLOCK\00", align 1
@.str.413 = private unnamed_addr constant [17 x i8] c"SC_MEMLOCK_RANGE\00", align 1
@.str.414 = private unnamed_addr constant [21 x i8] c"SC_MEMORY_PROTECTION\00", align 1
@.str.415 = private unnamed_addr constant [19 x i8] c"SC_MESSAGE_PASSING\00", align 1
@.str.416 = private unnamed_addr constant [15 x i8] c"SC_MQ_OPEN_MAX\00", align 1
@.str.417 = private unnamed_addr constant [15 x i8] c"SC_MQ_PRIO_MAX\00", align 1
@.str.418 = private unnamed_addr constant [15 x i8] c"SC_NGROUPS_MAX\00", align 1
@.str.419 = private unnamed_addr constant [13 x i8] c"SC_NL_ARGMAX\00", align 1
@.str.420 = private unnamed_addr constant [14 x i8] c"SC_NL_LANGMAX\00", align 1
@.str.421 = private unnamed_addr constant [13 x i8] c"SC_NL_MSGMAX\00", align 1
@.str.422 = private unnamed_addr constant [11 x i8] c"SC_NL_NMAX\00", align 1
@.str.423 = private unnamed_addr constant [13 x i8] c"SC_NL_SETMAX\00", align 1
@.str.424 = private unnamed_addr constant [14 x i8] c"SC_NL_TEXTMAX\00", align 1
@.str.425 = private unnamed_addr constant [20 x i8] c"SC_NPROCESSORS_CONF\00", align 1
@.str.426 = private unnamed_addr constant [20 x i8] c"SC_NPROCESSORS_ONLN\00", align 1
@.str.427 = private unnamed_addr constant [9 x i8] c"SC_NZERO\00", align 1
@.str.428 = private unnamed_addr constant [12 x i8] c"SC_OPEN_MAX\00", align 1
@.str.429 = private unnamed_addr constant [12 x i8] c"SC_PAGESIZE\00", align 1
@.str.430 = private unnamed_addr constant [13 x i8] c"SC_PAGE_SIZE\00", align 1
@.str.431 = private unnamed_addr constant [12 x i8] c"SC_PASS_MAX\00", align 1
@.str.432 = private unnamed_addr constant [14 x i8] c"SC_PHYS_PAGES\00", align 1
@.str.433 = private unnamed_addr constant [7 x i8] c"SC_PII\00", align 1
@.str.434 = private unnamed_addr constant [16 x i8] c"SC_PII_INTERNET\00", align 1
@.str.435 = private unnamed_addr constant [22 x i8] c"SC_PII_INTERNET_DGRAM\00", align 1
@.str.436 = private unnamed_addr constant [23 x i8] c"SC_PII_INTERNET_STREAM\00", align 1
@.str.437 = private unnamed_addr constant [11 x i8] c"SC_PII_OSI\00", align 1
@.str.438 = private unnamed_addr constant [16 x i8] c"SC_PII_OSI_CLTS\00", align 1
@.str.439 = private unnamed_addr constant [16 x i8] c"SC_PII_OSI_COTS\00", align 1
@.str.440 = private unnamed_addr constant [13 x i8] c"SC_PII_OSI_M\00", align 1
@.str.441 = private unnamed_addr constant [14 x i8] c"SC_PII_SOCKET\00", align 1
@.str.442 = private unnamed_addr constant [11 x i8] c"SC_PII_XTI\00", align 1
@.str.443 = private unnamed_addr constant [8 x i8] c"SC_POLL\00", align 1
@.str.444 = private unnamed_addr constant [18 x i8] c"SC_PRIORITIZED_IO\00", align 1
@.str.445 = private unnamed_addr constant [23 x i8] c"SC_PRIORITY_SCHEDULING\00", align 1
@.str.446 = private unnamed_addr constant [20 x i8] c"SC_REALTIME_SIGNALS\00", align 1
@.str.447 = private unnamed_addr constant [14 x i8] c"SC_RE_DUP_MAX\00", align 1
@.str.448 = private unnamed_addr constant [13 x i8] c"SC_RTSIG_MAX\00", align 1
@.str.449 = private unnamed_addr constant [13 x i8] c"SC_SAVED_IDS\00", align 1
@.str.450 = private unnamed_addr constant [13 x i8] c"SC_SCHAR_MAX\00", align 1
@.str.451 = private unnamed_addr constant [13 x i8] c"SC_SCHAR_MIN\00", align 1
@.str.452 = private unnamed_addr constant [10 x i8] c"SC_SELECT\00", align 1
@.str.453 = private unnamed_addr constant [14 x i8] c"SC_SEMAPHORES\00", align 1
@.str.454 = private unnamed_addr constant [17 x i8] c"SC_SEM_NSEMS_MAX\00", align 1
@.str.455 = private unnamed_addr constant [17 x i8] c"SC_SEM_VALUE_MAX\00", align 1
@.str.456 = private unnamed_addr constant [25 x i8] c"SC_SHARED_MEMORY_OBJECTS\00", align 1
@.str.457 = private unnamed_addr constant [12 x i8] c"SC_SHRT_MAX\00", align 1
@.str.458 = private unnamed_addr constant [12 x i8] c"SC_SHRT_MIN\00", align 1
@.str.459 = private unnamed_addr constant [16 x i8] c"SC_SIGQUEUE_MAX\00", align 1
@.str.460 = private unnamed_addr constant [13 x i8] c"SC_SSIZE_MAX\00", align 1
@.str.461 = private unnamed_addr constant [14 x i8] c"SC_STREAM_MAX\00", align 1
@.str.462 = private unnamed_addr constant [19 x i8] c"SC_SYNCHRONIZED_IO\00", align 1
@.str.463 = private unnamed_addr constant [11 x i8] c"SC_THREADS\00", align 1
@.str.464 = private unnamed_addr constant [25 x i8] c"SC_THREAD_ATTR_STACKADDR\00", align 1
@.str.465 = private unnamed_addr constant [25 x i8] c"SC_THREAD_ATTR_STACKSIZE\00", align 1
@.str.466 = private unnamed_addr constant [32 x i8] c"SC_THREAD_DESTRUCTOR_ITERATIONS\00", align 1
@.str.467 = private unnamed_addr constant [19 x i8] c"SC_THREAD_KEYS_MAX\00", align 1
@.str.468 = private unnamed_addr constant [30 x i8] c"SC_THREAD_PRIORITY_SCHEDULING\00", align 1
@.str.469 = private unnamed_addr constant [23 x i8] c"SC_THREAD_PRIO_INHERIT\00", align 1
@.str.470 = private unnamed_addr constant [23 x i8] c"SC_THREAD_PRIO_PROTECT\00", align 1
@.str.471 = private unnamed_addr constant [25 x i8] c"SC_THREAD_PROCESS_SHARED\00", align 1
@.str.472 = private unnamed_addr constant [25 x i8] c"SC_THREAD_SAFE_FUNCTIONS\00", align 1
@.str.473 = private unnamed_addr constant [20 x i8] c"SC_THREAD_STACK_MIN\00", align 1
@.str.474 = private unnamed_addr constant [22 x i8] c"SC_THREAD_THREADS_MAX\00", align 1
@.str.475 = private unnamed_addr constant [10 x i8] c"SC_TIMERS\00", align 1
@.str.476 = private unnamed_addr constant [13 x i8] c"SC_TIMER_MAX\00", align 1
@.str.477 = private unnamed_addr constant [16 x i8] c"SC_TTY_NAME_MAX\00", align 1
@.str.478 = private unnamed_addr constant [14 x i8] c"SC_TZNAME_MAX\00", align 1
@.str.479 = private unnamed_addr constant [13 x i8] c"SC_T_IOV_MAX\00", align 1
@.str.480 = private unnamed_addr constant [13 x i8] c"SC_UCHAR_MAX\00", align 1
@.str.481 = private unnamed_addr constant [12 x i8] c"SC_UINT_MAX\00", align 1
@.str.482 = private unnamed_addr constant [14 x i8] c"SC_UIO_MAXIOV\00", align 1
@.str.483 = private unnamed_addr constant [13 x i8] c"SC_ULONG_MAX\00", align 1
@.str.484 = private unnamed_addr constant [13 x i8] c"SC_USHRT_MAX\00", align 1
@.str.485 = private unnamed_addr constant [11 x i8] c"SC_VERSION\00", align 1
@.str.486 = private unnamed_addr constant [12 x i8] c"SC_WORD_BIT\00", align 1
@.str.487 = private unnamed_addr constant [20 x i8] c"SC_XBS5_ILP32_OFF32\00", align 1
@.str.488 = private unnamed_addr constant [21 x i8] c"SC_XBS5_ILP32_OFFBIG\00", align 1
@.str.489 = private unnamed_addr constant [19 x i8] c"SC_XBS5_LP64_OFF64\00", align 1
@.str.490 = private unnamed_addr constant [21 x i8] c"SC_XBS5_LPBIG_OFFBIG\00", align 1
@.str.491 = private unnamed_addr constant [15 x i8] c"SC_XOPEN_CRYPT\00", align 1
@.str.492 = private unnamed_addr constant [18 x i8] c"SC_XOPEN_ENH_I18N\00", align 1
@.str.493 = private unnamed_addr constant [16 x i8] c"SC_XOPEN_LEGACY\00", align 1
@.str.494 = private unnamed_addr constant [18 x i8] c"SC_XOPEN_REALTIME\00", align 1
@.str.495 = private unnamed_addr constant [26 x i8] c"SC_XOPEN_REALTIME_THREADS\00", align 1
@.str.496 = private unnamed_addr constant [13 x i8] c"SC_XOPEN_SHM\00", align 1
@.str.497 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_UNIX\00", align 1
@.str.498 = private unnamed_addr constant [17 x i8] c"SC_XOPEN_VERSION\00", align 1
@.str.499 = private unnamed_addr constant [21 x i8] c"SC_XOPEN_XCU_VERSION\00", align 1
@.str.500 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG2\00", align 1
@.str.501 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG3\00", align 1
@.str.502 = private unnamed_addr constant [14 x i8] c"SC_XOPEN_XPG4\00", align 1
@.str.503 = private unnamed_addr constant [14 x i8] c"iO&:fpathconf\00", align 1
@posix_constants_pathconf = internal global [20 x %struct.constdef] [%struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.504, i32 0, i32 0), i64 10 }, %struct.constdef { i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.505, i32 0, i32 0), i64 6 }, %struct.constdef { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.506, i32 0, i32 0), i64 13 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.507, i32 0, i32 0), i64 0 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.508, i32 0, i32 0), i64 1 }, %struct.constdef { i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.509, i32 0, i32 0), i64 2 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.510, i32 0, i32 0), i64 3 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.511, i32 0, i32 0), i64 7 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.512, i32 0, i32 0), i64 4 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.513, i32 0, i32 0), i64 5 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.514, i32 0, i32 0), i64 11 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.515, i32 0, i32 0), i64 12 }, %struct.constdef { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.516, i32 0, i32 0), i64 9 }, %struct.constdef { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.517, i32 0, i32 0), i64 8 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.518, i32 0, i32 0), i64 18 }, %struct.constdef { i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.519, i32 0, i32 0), i64 14 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.520, i32 0, i32 0), i64 15 }, %struct.constdef { i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.521, i32 0, i32 0), i64 16 }, %struct.constdef { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.522, i32 0, i32 0), i64 17 }, %struct.constdef { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.523, i32 0, i32 0), i64 19 }], align 16
@.str.504 = private unnamed_addr constant [12 x i8] c"PC_ASYNC_IO\00", align 1
@.str.505 = private unnamed_addr constant [20 x i8] c"PC_CHOWN_RESTRICTED\00", align 1
@.str.506 = private unnamed_addr constant [16 x i8] c"PC_FILESIZEBITS\00", align 1
@.str.507 = private unnamed_addr constant [12 x i8] c"PC_LINK_MAX\00", align 1
@.str.508 = private unnamed_addr constant [13 x i8] c"PC_MAX_CANON\00", align 1
@.str.509 = private unnamed_addr constant [13 x i8] c"PC_MAX_INPUT\00", align 1
@.str.510 = private unnamed_addr constant [12 x i8] c"PC_NAME_MAX\00", align 1
@.str.511 = private unnamed_addr constant [12 x i8] c"PC_NO_TRUNC\00", align 1
@.str.512 = private unnamed_addr constant [12 x i8] c"PC_PATH_MAX\00", align 1
@.str.513 = private unnamed_addr constant [12 x i8] c"PC_PIPE_BUF\00", align 1
@.str.514 = private unnamed_addr constant [11 x i8] c"PC_PRIO_IO\00", align 1
@.str.515 = private unnamed_addr constant [15 x i8] c"PC_SOCK_MAXBUF\00", align 1
@.str.516 = private unnamed_addr constant [11 x i8] c"PC_SYNC_IO\00", align 1
@.str.517 = private unnamed_addr constant [12 x i8] c"PC_VDISABLE\00", align 1
@.str.518 = private unnamed_addr constant [18 x i8] c"PC_ALLOC_SIZE_MIN\00", align 1
@.str.519 = private unnamed_addr constant [22 x i8] c"PC_REC_INCR_XFER_SIZE\00", align 1
@.str.520 = private unnamed_addr constant [21 x i8] c"PC_REC_MAX_XFER_SIZE\00", align 1
@.str.521 = private unnamed_addr constant [21 x i8] c"PC_REC_MIN_XFER_SIZE\00", align 1
@.str.522 = private unnamed_addr constant [18 x i8] c"PC_REC_XFER_ALIGN\00", align 1
@.str.523 = private unnamed_addr constant [15 x i8] c"PC_SYMLINK_MAX\00", align 1
@posix_pathconf.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.524, i32 0, i32 0), i8* null], align 16
@.str.524 = private unnamed_addr constant [5 x i8] c"name\00", align 1
@.str.525 = private unnamed_addr constant [14 x i8] c"O&O&:pathconf\00", align 1
@.str.526 = private unnamed_addr constant [31 x i8] c"Load averages are unobtainable\00", align 1
@.str.527 = private unnamed_addr constant [4 x i8] c"ddd\00", align 1
@.str.528 = private unnamed_addr constant [10 x i8] c"n:urandom\00", align 1
@.str.529 = private unnamed_addr constant [30 x i8] c"negative argument not allowed\00", align 1
@.str.530 = private unnamed_addr constant [17 x i8] c"O&O&O&:setresuid\00", align 1
@.str.531 = private unnamed_addr constant [17 x i8] c"O&O&O&:setresgid\00", align 1
@.str.532 = private unnamed_addr constant [6 x i8] c"(NNN)\00", align 1
@posix_setxattr.keywords = internal global [6 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.533, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.534, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.283, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.533 = private unnamed_addr constant [10 x i8] c"attribute\00", align 1
@.str.534 = private unnamed_addr constant [6 x i8] c"value\00", align 1
@.str.535 = private unnamed_addr constant [20 x i8] c"O&O&y*|i$p:setxattr\00", align 1
@posix_getxattr.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.533, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.536 = private unnamed_addr constant [17 x i8] c"O&O&|$p:getxattr\00", align 1
@posix_getxattr.buffer_sizes = internal global [3 x i64] [i64 128, i64 65536, i64 0], align 16
@posix_removexattr.keywords = internal global [4 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.533, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.537 = private unnamed_addr constant [20 x i8] c"O&O&|$p:removexattr\00", align 1
@posix_listxattr.keywords = internal global [3 x i8*] [i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8* null], align 16
@.str.538 = private unnamed_addr constant [16 x i8] c"|O&$p:listxattr\00", align 1
@posix_listxattr.buffer_sizes = internal global [3 x i64] [i64 256, i64 65536, i64 0], align 16
@stdout = external global %struct._IO_FILE*, align 8
@.str.539 = private unnamed_addr constant [3 x i8] c"|i\00", align 1
@.str.540 = private unnamed_addr constant [18 x i8] c"i:get_inheritable\00", align 1
@.str.541 = private unnamed_addr constant [19 x i8] c"ii:set_inheritable\00", align 1
@environ = external global i8**, align 8
@.str.542 = private unnamed_addr constant [5 x i8] c"F_OK\00", align 1
@.str.543 = private unnamed_addr constant [5 x i8] c"R_OK\00", align 1
@.str.544 = private unnamed_addr constant [5 x i8] c"W_OK\00", align 1
@.str.545 = private unnamed_addr constant [5 x i8] c"X_OK\00", align 1
@.str.546 = private unnamed_addr constant [12 x i8] c"NGROUPS_MAX\00", align 1
@.str.547 = private unnamed_addr constant [8 x i8] c"TMP_MAX\00", align 1
@.str.548 = private unnamed_addr constant [11 x i8] c"WCONTINUED\00", align 1
@.str.549 = private unnamed_addr constant [8 x i8] c"WNOHANG\00", align 1
@.str.550 = private unnamed_addr constant [10 x i8] c"WUNTRACED\00", align 1
@.str.551 = private unnamed_addr constant [9 x i8] c"O_RDONLY\00", align 1
@.str.552 = private unnamed_addr constant [9 x i8] c"O_WRONLY\00", align 1
@.str.553 = private unnamed_addr constant [7 x i8] c"O_RDWR\00", align 1
@.str.554 = private unnamed_addr constant [9 x i8] c"O_NDELAY\00", align 1
@.str.555 = private unnamed_addr constant [11 x i8] c"O_NONBLOCK\00", align 1
@.str.556 = private unnamed_addr constant [9 x i8] c"O_APPEND\00", align 1
@.str.557 = private unnamed_addr constant [8 x i8] c"O_DSYNC\00", align 1
@.str.558 = private unnamed_addr constant [8 x i8] c"O_RSYNC\00", align 1
@.str.559 = private unnamed_addr constant [7 x i8] c"O_SYNC\00", align 1
@.str.560 = private unnamed_addr constant [9 x i8] c"O_NOCTTY\00", align 1
@.str.561 = private unnamed_addr constant [8 x i8] c"O_CREAT\00", align 1
@.str.562 = private unnamed_addr constant [7 x i8] c"O_EXCL\00", align 1
@.str.563 = private unnamed_addr constant [8 x i8] c"O_TRUNC\00", align 1
@.str.564 = private unnamed_addr constant [12 x i8] c"O_LARGEFILE\00", align 1
@.str.565 = private unnamed_addr constant [7 x i8] c"O_PATH\00", align 1
@.str.566 = private unnamed_addr constant [13 x i8] c"PRIO_PROCESS\00", align 1
@.str.567 = private unnamed_addr constant [10 x i8] c"PRIO_PGRP\00", align 1
@.str.568 = private unnamed_addr constant [10 x i8] c"PRIO_USER\00", align 1
@.str.569 = private unnamed_addr constant [10 x i8] c"O_CLOEXEC\00", align 1
@.str.570 = private unnamed_addr constant [10 x i8] c"O_ACCMODE\00", align 1
@.str.571 = private unnamed_addr constant [10 x i8] c"SEEK_HOLE\00", align 1
@.str.572 = private unnamed_addr constant [10 x i8] c"SEEK_DATA\00", align 1
@.str.573 = private unnamed_addr constant [8 x i8] c"O_ASYNC\00", align 1
@.str.574 = private unnamed_addr constant [9 x i8] c"O_DIRECT\00", align 1
@.str.575 = private unnamed_addr constant [12 x i8] c"O_DIRECTORY\00", align 1
@.str.576 = private unnamed_addr constant [11 x i8] c"O_NOFOLLOW\00", align 1
@.str.577 = private unnamed_addr constant [10 x i8] c"O_NOATIME\00", align 1
@.str.578 = private unnamed_addr constant [6 x i8] c"EX_OK\00", align 1
@.str.579 = private unnamed_addr constant [9 x i8] c"EX_USAGE\00", align 1
@.str.580 = private unnamed_addr constant [11 x i8] c"EX_DATAERR\00", align 1
@.str.581 = private unnamed_addr constant [11 x i8] c"EX_NOINPUT\00", align 1
@.str.582 = private unnamed_addr constant [10 x i8] c"EX_NOUSER\00", align 1
@.str.583 = private unnamed_addr constant [10 x i8] c"EX_NOHOST\00", align 1
@.str.584 = private unnamed_addr constant [15 x i8] c"EX_UNAVAILABLE\00", align 1
@.str.585 = private unnamed_addr constant [12 x i8] c"EX_SOFTWARE\00", align 1
@.str.586 = private unnamed_addr constant [9 x i8] c"EX_OSERR\00", align 1
@.str.587 = private unnamed_addr constant [10 x i8] c"EX_OSFILE\00", align 1
@.str.588 = private unnamed_addr constant [13 x i8] c"EX_CANTCREAT\00", align 1
@.str.589 = private unnamed_addr constant [9 x i8] c"EX_IOERR\00", align 1
@.str.590 = private unnamed_addr constant [12 x i8] c"EX_TEMPFAIL\00", align 1
@.str.591 = private unnamed_addr constant [12 x i8] c"EX_PROTOCOL\00", align 1
@.str.592 = private unnamed_addr constant [10 x i8] c"EX_NOPERM\00", align 1
@.str.593 = private unnamed_addr constant [10 x i8] c"EX_CONFIG\00", align 1
@.str.594 = private unnamed_addr constant [10 x i8] c"ST_RDONLY\00", align 1
@.str.595 = private unnamed_addr constant [10 x i8] c"ST_NOSUID\00", align 1
@.str.596 = private unnamed_addr constant [9 x i8] c"ST_NODEV\00", align 1
@.str.597 = private unnamed_addr constant [10 x i8] c"ST_NOEXEC\00", align 1
@.str.598 = private unnamed_addr constant [15 x i8] c"ST_SYNCHRONOUS\00", align 1
@.str.599 = private unnamed_addr constant [12 x i8] c"ST_MANDLOCK\00", align 1
@.str.600 = private unnamed_addr constant [9 x i8] c"ST_WRITE\00", align 1
@.str.601 = private unnamed_addr constant [10 x i8] c"ST_APPEND\00", align 1
@.str.602 = private unnamed_addr constant [11 x i8] c"ST_NOATIME\00", align 1
@.str.603 = private unnamed_addr constant [14 x i8] c"ST_NODIRATIME\00", align 1
@.str.604 = private unnamed_addr constant [12 x i8] c"ST_RELATIME\00", align 1
@.str.605 = private unnamed_addr constant [18 x i8] c"POSIX_FADV_NORMAL\00", align 1
@.str.606 = private unnamed_addr constant [22 x i8] c"POSIX_FADV_SEQUENTIAL\00", align 1
@.str.607 = private unnamed_addr constant [18 x i8] c"POSIX_FADV_RANDOM\00", align 1
@.str.608 = private unnamed_addr constant [19 x i8] c"POSIX_FADV_NOREUSE\00", align 1
@.str.609 = private unnamed_addr constant [20 x i8] c"POSIX_FADV_WILLNEED\00", align 1
@.str.610 = private unnamed_addr constant [20 x i8] c"POSIX_FADV_DONTNEED\00", align 1
@.str.611 = private unnamed_addr constant [6 x i8] c"P_PID\00", align 1
@.str.612 = private unnamed_addr constant [7 x i8] c"P_PGID\00", align 1
@.str.613 = private unnamed_addr constant [6 x i8] c"P_ALL\00", align 1
@.str.614 = private unnamed_addr constant [8 x i8] c"WEXITED\00", align 1
@.str.615 = private unnamed_addr constant [8 x i8] c"WNOWAIT\00", align 1
@.str.616 = private unnamed_addr constant [9 x i8] c"WSTOPPED\00", align 1
@.str.617 = private unnamed_addr constant [11 x i8] c"CLD_EXITED\00", align 1
@.str.618 = private unnamed_addr constant [11 x i8] c"CLD_DUMPED\00", align 1
@.str.619 = private unnamed_addr constant [12 x i8] c"CLD_TRAPPED\00", align 1
@.str.620 = private unnamed_addr constant [14 x i8] c"CLD_CONTINUED\00", align 1
@.str.621 = private unnamed_addr constant [7 x i8] c"F_LOCK\00", align 1
@.str.622 = private unnamed_addr constant [8 x i8] c"F_TLOCK\00", align 1
@.str.623 = private unnamed_addr constant [8 x i8] c"F_ULOCK\00", align 1
@.str.624 = private unnamed_addr constant [7 x i8] c"F_TEST\00", align 1
@.str.625 = private unnamed_addr constant [12 x i8] c"SCHED_OTHER\00", align 1
@.str.626 = private unnamed_addr constant [11 x i8] c"SCHED_FIFO\00", align 1
@.str.627 = private unnamed_addr constant [9 x i8] c"SCHED_RR\00", align 1
@.str.628 = private unnamed_addr constant [12 x i8] c"SCHED_BATCH\00", align 1
@.str.629 = private unnamed_addr constant [11 x i8] c"SCHED_IDLE\00", align 1
@.str.630 = private unnamed_addr constant [20 x i8] c"SCHED_RESET_ON_FORK\00", align 1
@.str.631 = private unnamed_addr constant [13 x i8] c"XATTR_CREATE\00", align 1
@.str.632 = private unnamed_addr constant [14 x i8] c"XATTR_REPLACE\00", align 1
@.str.633 = private unnamed_addr constant [15 x i8] c"XATTR_SIZE_MAX\00", align 1
@.str.634 = private unnamed_addr constant [10 x i8] c"RTLD_LAZY\00", align 1
@.str.635 = private unnamed_addr constant [9 x i8] c"RTLD_NOW\00", align 1
@.str.636 = private unnamed_addr constant [12 x i8] c"RTLD_GLOBAL\00", align 1
@.str.637 = private unnamed_addr constant [11 x i8] c"RTLD_LOCAL\00", align 1
@.str.638 = private unnamed_addr constant [14 x i8] c"RTLD_NODELETE\00", align 1
@.str.639 = private unnamed_addr constant [12 x i8] c"RTLD_NOLOAD\00", align 1
@.str.640 = private unnamed_addr constant [14 x i8] c"RTLD_DEEPBIND\00", align 1
@.str.641 = private unnamed_addr constant [15 x i8] c"pathconf_names\00", align 1
@.str.642 = private unnamed_addr constant [14 x i8] c"confstr_names\00", align 1
@.str.643 = private unnamed_addr constant [14 x i8] c"sysconf_names\00", align 1
@waitid_result__doc__ = internal global [221 x i8] c"waitid_result: Result from waitid.\0A\0AThis object may be accessed either as a tuple of\0A  (si_pid, si_uid, si_signo, si_status, si_code),\0Aor via the attributes si_pid, si_uid, and so on.\0A\0ASee os.waitid for more information.\00", align 16
@waitid_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.644, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.645, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.646, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.647, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.648, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.644 = private unnamed_addr constant [7 x i8] c"si_pid\00", align 1
@.str.645 = private unnamed_addr constant [7 x i8] c"si_uid\00", align 1
@.str.646 = private unnamed_addr constant [9 x i8] c"si_signo\00", align 1
@.str.647 = private unnamed_addr constant [10 x i8] c"si_status\00", align 1
@.str.648 = private unnamed_addr constant [8 x i8] c"si_code\00", align 1
@stat_result__doc__ = internal global [398 x i8] c"stat_result: Result from stat, fstat, or lstat.\0A\0AThis object may be accessed either as a tuple of\0A  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\0Aor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\0A\0APosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\0Aor st_flags, they are available as attributes only.\0A\0ASee os.stat for more information.\00", align 16
@stat_result_fields = internal global [20 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.649, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.650, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.651, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.652, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.653, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.312, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.654, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.655, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.656, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.657, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.658, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.659, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.660, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.661, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* null, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.662, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* null, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.663, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* null, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.664, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.665, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.666, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.667, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.668, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.669, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.670, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.671, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.672, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.673, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.674, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.675, i32 0, i32 0), i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.676, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.677, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.678, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.679, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.680, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.681, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.682, i32 0, i32 0) }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.649 = private unnamed_addr constant [8 x i8] c"st_mode\00", align 1
@.str.650 = private unnamed_addr constant [16 x i8] c"protection bits\00", align 1
@.str.651 = private unnamed_addr constant [7 x i8] c"st_ino\00", align 1
@.str.652 = private unnamed_addr constant [6 x i8] c"inode\00", align 1
@.str.653 = private unnamed_addr constant [7 x i8] c"st_dev\00", align 1
@.str.654 = private unnamed_addr constant [9 x i8] c"st_nlink\00", align 1
@.str.655 = private unnamed_addr constant [21 x i8] c"number of hard links\00", align 1
@.str.656 = private unnamed_addr constant [7 x i8] c"st_uid\00", align 1
@.str.657 = private unnamed_addr constant [17 x i8] c"user ID of owner\00", align 1
@.str.658 = private unnamed_addr constant [7 x i8] c"st_gid\00", align 1
@.str.659 = private unnamed_addr constant [18 x i8] c"group ID of owner\00", align 1
@.str.660 = private unnamed_addr constant [8 x i8] c"st_size\00", align 1
@.str.661 = private unnamed_addr constant [21 x i8] c"total size, in bytes\00", align 1
@.str.662 = private unnamed_addr constant [28 x i8] c"integer time of last access\00", align 1
@.str.663 = private unnamed_addr constant [34 x i8] c"integer time of last modification\00", align 1
@.str.664 = private unnamed_addr constant [28 x i8] c"integer time of last change\00", align 1
@.str.665 = private unnamed_addr constant [9 x i8] c"st_atime\00", align 1
@.str.666 = private unnamed_addr constant [20 x i8] c"time of last access\00", align 1
@.str.667 = private unnamed_addr constant [9 x i8] c"st_mtime\00", align 1
@.str.668 = private unnamed_addr constant [26 x i8] c"time of last modification\00", align 1
@.str.669 = private unnamed_addr constant [9 x i8] c"st_ctime\00", align 1
@.str.670 = private unnamed_addr constant [20 x i8] c"time of last change\00", align 1
@.str.671 = private unnamed_addr constant [12 x i8] c"st_atime_ns\00", align 1
@.str.672 = private unnamed_addr constant [35 x i8] c"time of last access in nanoseconds\00", align 1
@.str.673 = private unnamed_addr constant [12 x i8] c"st_mtime_ns\00", align 1
@.str.674 = private unnamed_addr constant [41 x i8] c"time of last modification in nanoseconds\00", align 1
@.str.675 = private unnamed_addr constant [12 x i8] c"st_ctime_ns\00", align 1
@.str.676 = private unnamed_addr constant [35 x i8] c"time of last change in nanoseconds\00", align 1
@.str.677 = private unnamed_addr constant [11 x i8] c"st_blksize\00", align 1
@.str.678 = private unnamed_addr constant [29 x i8] c"blocksize for filesystem I/O\00", align 1
@.str.679 = private unnamed_addr constant [10 x i8] c"st_blocks\00", align 1
@.str.680 = private unnamed_addr constant [27 x i8] c"number of blocks allocated\00", align 1
@.str.681 = private unnamed_addr constant [8 x i8] c"st_rdev\00", align 1
@.str.682 = private unnamed_addr constant [30 x i8] c"device type (if inode device)\00", align 1
@statvfs_result__doc__ = internal global [287 x i8] c"statvfs_result: Result from statvfs or fstatvfs.\0A\0AThis object may be accessed either as a tuple of\0A  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\0Aor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\0A\0ASee os.statvfs for more information.\00", align 16
@statvfs_result_fields = internal global [11 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.683, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.684, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.685, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.686, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.687, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.688, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.689, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.690, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.691, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.692, i32 0, i32 0), i8* null }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.683 = private unnamed_addr constant [8 x i8] c"f_bsize\00", align 1
@.str.684 = private unnamed_addr constant [9 x i8] c"f_frsize\00", align 1
@.str.685 = private unnamed_addr constant [9 x i8] c"f_blocks\00", align 1
@.str.686 = private unnamed_addr constant [8 x i8] c"f_bfree\00", align 1
@.str.687 = private unnamed_addr constant [9 x i8] c"f_bavail\00", align 1
@.str.688 = private unnamed_addr constant [8 x i8] c"f_files\00", align 1
@.str.689 = private unnamed_addr constant [8 x i8] c"f_ffree\00", align 1
@.str.690 = private unnamed_addr constant [9 x i8] c"f_favail\00", align 1
@.str.691 = private unnamed_addr constant [7 x i8] c"f_flag\00", align 1
@.str.692 = private unnamed_addr constant [10 x i8] c"f_namemax\00", align 1
@sched_param__doc__ = internal global [97 x i8] c"sched_param(sched_priority): A scheduling parameter.\0A\0ACurrent has only one field: sched_priority\00", align 16
@sched_param_fields = internal global [2 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.693, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.694, i32 0, i32 0) }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.693 = private unnamed_addr constant [15 x i8] c"sched_priority\00", align 1
@.str.694 = private unnamed_addr constant [24 x i8] c"the scheduling priority\00", align 1
@sched_param_new.kwlist = internal global [2 x i8*] [i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.693, i32 0, i32 0), i8* null], align 16
@.str.695 = private unnamed_addr constant [14 x i8] c"O:sched_param\00", align 1
@.str.696 = private unnamed_addr constant [17 x i8] c"os.terminal_size\00", align 1
@TerminalSize_docstring = internal global [61 x i8] c"A tuple of (columns, lines) for holding terminal window size\00", align 16
@TerminalSize_fields = internal global [3 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.697, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.698, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.699, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.700, i32 0, i32 0) }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.697 = private unnamed_addr constant [8 x i8] c"columns\00", align 1
@.str.698 = private unnamed_addr constant [43 x i8] c"width of the terminal window in characters\00", align 1
@.str.699 = private unnamed_addr constant [6 x i8] c"lines\00", align 1
@.str.700 = private unnamed_addr constant [44 x i8] c"height of the terminal window in characters\00", align 1
@times_result__doc__ = internal global [264 x i8] c"times_result: Result from os.times().\0A\0AThis object may be accessed either as a tuple of\0A  (user, system, children_user, children_system, elapsed),\0Aor via the attributes user, system, children_user, children_system,\0Aand elapsed.\0A\0ASee os.times for more information.\00", align 16
@times_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.701, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.702, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.50, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.703, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.704, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.705, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.706, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.707, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.708, i32 0, i32 0), i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.709, i32 0, i32 0) }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.701 = private unnamed_addr constant [5 x i8] c"user\00", align 1
@.str.702 = private unnamed_addr constant [10 x i8] c"user time\00", align 1
@.str.703 = private unnamed_addr constant [12 x i8] c"system time\00", align 1
@.str.704 = private unnamed_addr constant [14 x i8] c"children_user\00", align 1
@.str.705 = private unnamed_addr constant [22 x i8] c"user time of children\00", align 1
@.str.706 = private unnamed_addr constant [16 x i8] c"children_system\00", align 1
@.str.707 = private unnamed_addr constant [24 x i8] c"system time of children\00", align 1
@.str.708 = private unnamed_addr constant [8 x i8] c"elapsed\00", align 1
@.str.709 = private unnamed_addr constant [50 x i8] c"elapsed time since an arbitrary point in the past\00", align 1
@uname_result__doc__ = internal global [246 x i8] c"uname_result: Result from os.uname().\0A\0AThis object may be accessed either as a tuple of\0A  (sysname, nodename, release, version, machine),\0Aor via the attributes sysname, nodename, release, version, and machine.\0A\0ASee os.uname for more information.\00", align 16
@uname_result_fields = internal global [6 x %struct.PyStructSequence_Field] [%struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.710, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.711, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.712, i32 0, i32 0), i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.713, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.714, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.715, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.716, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.717, i32 0, i32 0) }, %struct.PyStructSequence_Field { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.718, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.719, i32 0, i32 0) }, %struct.PyStructSequence_Field zeroinitializer], align 16
@.str.710 = private unnamed_addr constant [8 x i8] c"sysname\00", align 1
@.str.711 = private unnamed_addr constant [22 x i8] c"operating system name\00", align 1
@.str.712 = private unnamed_addr constant [9 x i8] c"nodename\00", align 1
@.str.713 = private unnamed_addr constant [52 x i8] c"name of machine on network (implementation-defined)\00", align 1
@.str.714 = private unnamed_addr constant [8 x i8] c"release\00", align 1
@.str.715 = private unnamed_addr constant [25 x i8] c"operating system release\00", align 1
@.str.716 = private unnamed_addr constant [8 x i8] c"version\00", align 1
@.str.717 = private unnamed_addr constant [25 x i8] c"operating system version\00", align 1
@.str.718 = private unnamed_addr constant [8 x i8] c"machine\00", align 1
@.str.719 = private unnamed_addr constant [20 x i8] c"hardware identifier\00", align 1
@.str.720 = private unnamed_addr constant [36 x i8] c"%s%s%s unavailable on this platform\00", align 1
@.str.721 = private unnamed_addr constant [51 x i8] c"%s: cannot use dir_fd and follow_symlinks together\00", align 1
@.str.722 = private unnamed_addr constant [8 x i8] c"integer\00", align 1
@.str.723 = private unnamed_addr constant [15 x i8] c"HAVE_FACCESSAT\00", align 1
@.str.724 = private unnamed_addr constant [12 x i8] c"HAVE_FCHDIR\00", align 1
@.str.725 = private unnamed_addr constant [12 x i8] c"HAVE_FCHMOD\00", align 1
@.str.726 = private unnamed_addr constant [14 x i8] c"HAVE_FCHMODAT\00", align 1
@.str.727 = private unnamed_addr constant [12 x i8] c"HAVE_FCHOWN\00", align 1
@.str.728 = private unnamed_addr constant [14 x i8] c"HAVE_FCHOWNAT\00", align 1
@.str.729 = private unnamed_addr constant [13 x i8] c"HAVE_FEXECVE\00", align 1
@.str.730 = private unnamed_addr constant [15 x i8] c"HAVE_FDOPENDIR\00", align 1
@.str.731 = private unnamed_addr constant [15 x i8] c"HAVE_FPATHCONF\00", align 1
@.str.732 = private unnamed_addr constant [13 x i8] c"HAVE_FSTATAT\00", align 1
@.str.733 = private unnamed_addr constant [14 x i8] c"HAVE_FSTATVFS\00", align 1
@.str.734 = private unnamed_addr constant [15 x i8] c"HAVE_FTRUNCATE\00", align 1
@.str.735 = private unnamed_addr constant [14 x i8] c"HAVE_FUTIMENS\00", align 1
@.str.736 = private unnamed_addr constant [13 x i8] c"HAVE_FUTIMES\00", align 1
@.str.737 = private unnamed_addr constant [15 x i8] c"HAVE_FUTIMESAT\00", align 1
@.str.738 = private unnamed_addr constant [12 x i8] c"HAVE_LINKAT\00", align 1
@.str.739 = private unnamed_addr constant [12 x i8] c"HAVE_LCHOWN\00", align 1
@.str.740 = private unnamed_addr constant [11 x i8] c"HAVE_LSTAT\00", align 1
@.str.741 = private unnamed_addr constant [13 x i8] c"HAVE_LUTIMES\00", align 1
@.str.742 = private unnamed_addr constant [13 x i8] c"HAVE_MKDIRAT\00", align 1
@.str.743 = private unnamed_addr constant [14 x i8] c"HAVE_MKFIFOAT\00", align 1
@.str.744 = private unnamed_addr constant [13 x i8] c"HAVE_MKNODAT\00", align 1
@.str.745 = private unnamed_addr constant [12 x i8] c"HAVE_OPENAT\00", align 1
@.str.746 = private unnamed_addr constant [16 x i8] c"HAVE_READLINKAT\00", align 1
@.str.747 = private unnamed_addr constant [14 x i8] c"HAVE_RENAMEAT\00", align 1
@.str.748 = private unnamed_addr constant [15 x i8] c"HAVE_SYMLINKAT\00", align 1
@.str.749 = private unnamed_addr constant [14 x i8] c"HAVE_UNLINKAT\00", align 1
@.str.750 = private unnamed_addr constant [15 x i8] c"HAVE_UTIMENSAT\00", align 1

; Function Attrs: nounwind uwtable
define %struct._object* @_PyLong_FromUid(i32 %uid) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %uid.addr = alloca i32, align 4
  store i32 %uid, i32* %uid.addr, align 4
  %0 = load i32, i32* %uid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct._object* @PyLong_FromLong(i64 -1)
  store %struct._object* %call, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %uid.addr, align 4
  %conv = zext i32 %1 to i64
  %call1 = call %struct._object* @PyLong_FromUnsignedLong(i64 %conv)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

declare %struct._object* @PyLong_FromLong(i64) #1

declare %struct._object* @PyLong_FromUnsignedLong(i64) #1

; Function Attrs: nounwind uwtable
define %struct._object* @_PyLong_FromGid(i32 %gid) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %gid.addr = alloca i32, align 4
  store i32 %gid, i32* %gid.addr, align 4
  %0 = load i32, i32* %gid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct._object* @PyLong_FromLong(i64 -1)
  store %struct._object* %call, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %gid.addr, align 4
  %conv = zext i32 %1 to i64
  %call1 = call %struct._object* @PyLong_FromUnsignedLong(i64 %conv)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

; Function Attrs: nounwind uwtable
define i32 @_Py_Uid_Converter(%struct._object* %obj, i8* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %obj.addr = alloca %struct._object*, align 8
  %p.addr = alloca i8*, align 8
  %uid = alloca i32, align 4
  %index = alloca %struct._object*, align 8
  %overflow = alloca i32, align 4
  %result = alloca i64, align 8
  %uresult = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp52 = alloca %struct._object*, align 8
  store %struct._object* %obj, %struct._object** %obj.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct._object*, %struct._object** %obj.addr, align 8
  %call = call %struct._object* @PyNumber_Index(%struct._object* %0)
  store %struct._object* %call, %struct._object** %index, align 8
  %1 = load %struct._object*, %struct._object** %index, align 8
  %cmp = icmp eq %struct._object* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %3 = load %struct._object*, %struct._object** %obj.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %3, i32 0, i32 1
  %4 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_name = getelementptr inbounds %struct._typeobject, %struct._typeobject* %4, i32 0, i32 1
  %5 = load i8*, i8** %tp_name, align 8
  %call1 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str, i32 0, i32 0), i8* %5)
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct._object*, %struct._object** %index, align 8
  %call2 = call i64 @PyLong_AsLongAndOverflow(%struct._object* %6, i32* %overflow)
  store i64 %call2, i64* %result, align 8
  %7 = load i32, i32* %overflow, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.end.21, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %8 = load i64, i64* %result, align 8
  %conv = trunc i64 %8 to i32
  store i32 %conv, i32* %uid, align 4
  %9 = load i64, i64* %result, align 8
  %cmp4 = icmp eq i64 %9, -1
  br i1 %cmp4, label %if.then.6, label %if.end.11

if.then.6:                                        ; preds = %if.then.3
  %call7 = call %struct._object* @PyErr_Occurred()
  %tobool8 = icmp ne %struct._object* %call7, null
  br i1 %tobool8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.then.6
  br label %fail

if.end.10:                                        ; preds = %if.then.6
  br label %success

if.end.11:                                        ; preds = %if.then.3
  %10 = load i64, i64* %result, align 8
  %cmp12 = icmp slt i64 %10, 0
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.11
  br label %underflow

if.end.15:                                        ; preds = %if.end.11
  %11 = load i32, i32* %uid, align 4
  %conv16 = zext i32 %11 to i64
  %12 = load i64, i64* %result, align 8
  %cmp17 = icmp ne i64 %conv16, %12
  br i1 %cmp17, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %if.end.15
  br label %underflow

if.end.20:                                        ; preds = %if.end.15
  br label %success

if.end.21:                                        ; preds = %if.end
  %13 = load i32, i32* %overflow, align 4
  %cmp22 = icmp slt i32 %13, 0
  br i1 %cmp22, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %if.end.21
  br label %underflow

if.end.25:                                        ; preds = %if.end.21
  %14 = load %struct._object*, %struct._object** %index, align 8
  %call26 = call i64 @PyLong_AsUnsignedLong(%struct._object* %14)
  store i64 %call26, i64* %uresult, align 8
  %call27 = call %struct._object* @PyErr_Occurred()
  %tobool28 = icmp ne %struct._object* %call27, null
  br i1 %tobool28, label %if.then.29, label %if.end.34

if.then.29:                                       ; preds = %if.end.25
  %15 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  %call30 = call i32 @PyErr_ExceptionMatches(%struct._object* %15)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then.32, label %if.end.33

if.then.32:                                       ; preds = %if.then.29
  br label %overflow.50

if.end.33:                                        ; preds = %if.then.29
  br label %fail

if.end.34:                                        ; preds = %if.end.25
  %16 = load i64, i64* %uresult, align 8
  %conv35 = trunc i64 %16 to i32
  store i32 %conv35, i32* %uid, align 4
  %17 = load i32, i32* %uid, align 4
  %cmp36 = icmp eq i32 %17, -1
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.end.34
  br label %overflow.50

if.end.39:                                        ; preds = %if.end.34
  %18 = load i32, i32* %uid, align 4
  %conv40 = zext i32 %18 to i64
  %19 = load i64, i64* %uresult, align 8
  %cmp41 = icmp ne i64 %conv40, %19
  br i1 %cmp41, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %if.end.39
  br label %overflow.50

if.end.44:                                        ; preds = %if.end.39
  br label %success

success:                                          ; preds = %if.end.44, %if.end.20, %if.end.10
  br label %do.body

do.body:                                          ; preds = %success
  %20 = load %struct._object*, %struct._object** %index, align 8
  store %struct._object* %20, %struct._object** %_py_decref_tmp, align 8
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %21, i32 0, i32 0
  %22 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %22, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp45 = icmp ne i64 %dec, 0
  br i1 %cmp45, label %if.then.47, label %if.else

if.then.47:                                       ; preds = %do.body
  br label %if.end.49

if.else:                                          ; preds = %do.body
  %23 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type48 = getelementptr inbounds %struct._object, %struct._object* %23, i32 0, i32 1
  %24 = load %struct._typeobject*, %struct._typeobject** %ob_type48, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %24, i32 0, i32 4
  %25 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %26 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %25(%struct._object* %26)
  br label %if.end.49

if.end.49:                                        ; preds = %if.else, %if.then.47
  br label %do.end

do.end:                                           ; preds = %if.end.49
  %27 = load i32, i32* %uid, align 4
  %28 = load i8*, i8** %p.addr, align 8
  %29 = bitcast i8* %28 to i32*
  store i32 %27, i32* %29, align 4
  store i32 1, i32* %retval
  br label %return

underflow:                                        ; preds = %if.then.24, %if.then.19, %if.then.14
  %30 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.1, i32 0, i32 0))
  br label %fail

overflow.50:                                      ; preds = %if.then.43, %if.then.38, %if.then.32
  %31 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %31, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2, i32 0, i32 0))
  br label %fail

fail:                                             ; preds = %overflow.50, %underflow, %if.end.33, %if.then.9
  br label %do.body.51

do.body.51:                                       ; preds = %fail
  %32 = load %struct._object*, %struct._object** %index, align 8
  store %struct._object* %32, %struct._object** %_py_decref_tmp52, align 8
  %33 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  %ob_refcnt53 = getelementptr inbounds %struct._object, %struct._object* %33, i32 0, i32 0
  %34 = load i64, i64* %ob_refcnt53, align 8
  %dec54 = add i64 %34, -1
  store i64 %dec54, i64* %ob_refcnt53, align 8
  %cmp55 = icmp ne i64 %dec54, 0
  br i1 %cmp55, label %if.then.57, label %if.else.58

if.then.57:                                       ; preds = %do.body.51
  br label %if.end.61

if.else.58:                                       ; preds = %do.body.51
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  %ob_type59 = getelementptr inbounds %struct._object, %struct._object* %35, i32 0, i32 1
  %36 = load %struct._typeobject*, %struct._typeobject** %ob_type59, align 8
  %tp_dealloc60 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %36, i32 0, i32 4
  %37 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc60, align 8
  %38 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  call void %37(%struct._object* %38)
  br label %if.end.61

if.end.61:                                        ; preds = %if.else.58, %if.then.57
  br label %do.end.62

do.end.62:                                        ; preds = %if.end.61
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %do.end.62, %do.end, %if.then
  %39 = load i32, i32* %retval
  ret i32 %39
}

declare %struct._object* @PyNumber_Index(%struct._object*) #1

declare %struct._object* @PyErr_Format(%struct._object*, i8*, ...) #1

declare i64 @PyLong_AsLongAndOverflow(%struct._object*, i32*) #1

declare %struct._object* @PyErr_Occurred() #1

declare i64 @PyLong_AsUnsignedLong(%struct._object*) #1

declare i32 @PyErr_ExceptionMatches(%struct._object*) #1

declare void @PyErr_SetString(%struct._object*, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @_Py_Gid_Converter(%struct._object* %obj, i8* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %obj.addr = alloca %struct._object*, align 8
  %p.addr = alloca i8*, align 8
  %gid = alloca i32, align 4
  %index = alloca %struct._object*, align 8
  %overflow = alloca i32, align 4
  %result = alloca i64, align 8
  %uresult = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp52 = alloca %struct._object*, align 8
  store %struct._object* %obj, %struct._object** %obj.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct._object*, %struct._object** %obj.addr, align 8
  %call = call %struct._object* @PyNumber_Index(%struct._object* %0)
  store %struct._object* %call, %struct._object** %index, align 8
  %1 = load %struct._object*, %struct._object** %index, align 8
  %cmp = icmp eq %struct._object* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %3 = load %struct._object*, %struct._object** %obj.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %3, i32 0, i32 1
  %4 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_name = getelementptr inbounds %struct._typeobject, %struct._typeobject* %4, i32 0, i32 1
  %5 = load i8*, i8** %tp_name, align 8
  %call1 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.3, i32 0, i32 0), i8* %5)
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct._object*, %struct._object** %index, align 8
  %call2 = call i64 @PyLong_AsLongAndOverflow(%struct._object* %6, i32* %overflow)
  store i64 %call2, i64* %result, align 8
  %7 = load i32, i32* %overflow, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.end.21, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %8 = load i64, i64* %result, align 8
  %conv = trunc i64 %8 to i32
  store i32 %conv, i32* %gid, align 4
  %9 = load i64, i64* %result, align 8
  %cmp4 = icmp eq i64 %9, -1
  br i1 %cmp4, label %if.then.6, label %if.end.11

if.then.6:                                        ; preds = %if.then.3
  %call7 = call %struct._object* @PyErr_Occurred()
  %tobool8 = icmp ne %struct._object* %call7, null
  br i1 %tobool8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.then.6
  br label %fail

if.end.10:                                        ; preds = %if.then.6
  br label %success

if.end.11:                                        ; preds = %if.then.3
  %10 = load i64, i64* %result, align 8
  %cmp12 = icmp slt i64 %10, 0
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.11
  br label %underflow

if.end.15:                                        ; preds = %if.end.11
  %11 = load i32, i32* %gid, align 4
  %conv16 = zext i32 %11 to i64
  %12 = load i64, i64* %result, align 8
  %cmp17 = icmp ne i64 %conv16, %12
  br i1 %cmp17, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %if.end.15
  br label %underflow

if.end.20:                                        ; preds = %if.end.15
  br label %success

if.end.21:                                        ; preds = %if.end
  %13 = load i32, i32* %overflow, align 4
  %cmp22 = icmp slt i32 %13, 0
  br i1 %cmp22, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %if.end.21
  br label %underflow

if.end.25:                                        ; preds = %if.end.21
  %14 = load %struct._object*, %struct._object** %index, align 8
  %call26 = call i64 @PyLong_AsUnsignedLong(%struct._object* %14)
  store i64 %call26, i64* %uresult, align 8
  %call27 = call %struct._object* @PyErr_Occurred()
  %tobool28 = icmp ne %struct._object* %call27, null
  br i1 %tobool28, label %if.then.29, label %if.end.34

if.then.29:                                       ; preds = %if.end.25
  %15 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  %call30 = call i32 @PyErr_ExceptionMatches(%struct._object* %15)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then.32, label %if.end.33

if.then.32:                                       ; preds = %if.then.29
  br label %overflow.50

if.end.33:                                        ; preds = %if.then.29
  br label %fail

if.end.34:                                        ; preds = %if.end.25
  %16 = load i64, i64* %uresult, align 8
  %conv35 = trunc i64 %16 to i32
  store i32 %conv35, i32* %gid, align 4
  %17 = load i32, i32* %gid, align 4
  %cmp36 = icmp eq i32 %17, -1
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.end.34
  br label %overflow.50

if.end.39:                                        ; preds = %if.end.34
  %18 = load i32, i32* %gid, align 4
  %conv40 = zext i32 %18 to i64
  %19 = load i64, i64* %uresult, align 8
  %cmp41 = icmp ne i64 %conv40, %19
  br i1 %cmp41, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %if.end.39
  br label %overflow.50

if.end.44:                                        ; preds = %if.end.39
  br label %success

success:                                          ; preds = %if.end.44, %if.end.20, %if.end.10
  br label %do.body

do.body:                                          ; preds = %success
  %20 = load %struct._object*, %struct._object** %index, align 8
  store %struct._object* %20, %struct._object** %_py_decref_tmp, align 8
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %21, i32 0, i32 0
  %22 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %22, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp45 = icmp ne i64 %dec, 0
  br i1 %cmp45, label %if.then.47, label %if.else

if.then.47:                                       ; preds = %do.body
  br label %if.end.49

if.else:                                          ; preds = %do.body
  %23 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type48 = getelementptr inbounds %struct._object, %struct._object* %23, i32 0, i32 1
  %24 = load %struct._typeobject*, %struct._typeobject** %ob_type48, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %24, i32 0, i32 4
  %25 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %26 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %25(%struct._object* %26)
  br label %if.end.49

if.end.49:                                        ; preds = %if.else, %if.then.47
  br label %do.end

do.end:                                           ; preds = %if.end.49
  %27 = load i32, i32* %gid, align 4
  %28 = load i8*, i8** %p.addr, align 8
  %29 = bitcast i8* %28 to i32*
  store i32 %27, i32* %29, align 4
  store i32 1, i32* %retval
  br label %return

underflow:                                        ; preds = %if.then.24, %if.then.19, %if.then.14
  %30 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.4, i32 0, i32 0))
  br label %fail

overflow.50:                                      ; preds = %if.then.43, %if.then.38, %if.then.32
  %31 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %31, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.5, i32 0, i32 0))
  br label %fail

fail:                                             ; preds = %overflow.50, %underflow, %if.end.33, %if.then.9
  br label %do.body.51

do.body.51:                                       ; preds = %fail
  %32 = load %struct._object*, %struct._object** %index, align 8
  store %struct._object* %32, %struct._object** %_py_decref_tmp52, align 8
  %33 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  %ob_refcnt53 = getelementptr inbounds %struct._object, %struct._object* %33, i32 0, i32 0
  %34 = load i64, i64* %ob_refcnt53, align 8
  %dec54 = add i64 %34, -1
  store i64 %dec54, i64* %ob_refcnt53, align 8
  %cmp55 = icmp ne i64 %dec54, 0
  br i1 %cmp55, label %if.then.57, label %if.else.58

if.then.57:                                       ; preds = %do.body.51
  br label %if.end.61

if.else.58:                                       ; preds = %do.body.51
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  %ob_type59 = getelementptr inbounds %struct._object, %struct._object* %35, i32 0, i32 1
  %36 = load %struct._typeobject*, %struct._typeobject** %ob_type59, align 8
  %tp_dealloc60 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %36, i32 0, i32 4
  %37 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc60, align 8
  %38 = load %struct._object*, %struct._object** %_py_decref_tmp52, align 8
  call void %37(%struct._object* %38)
  br label %if.end.61

if.end.61:                                        ; preds = %if.else.58, %if.then.57
  br label %do.end.62

do.end.62:                                        ; preds = %if.end.61
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %do.end.62, %do.end, %if.then
  %39 = load i32, i32* %retval
  ret i32 %39
}

; Function Attrs: nounwind uwtable
define %struct._object* @PyInit_posix() #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %m = alloca %struct._object*, align 8
  %v = alloca %struct._object*, align 8
  %list = alloca %struct._object*, align 8
  %trace = alloca i8**, align 8
  %_py_xincref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %ignored = alloca i32, align 4
  %unicode = alloca %struct._object*, align 8
  %_py_decref_tmp102 = alloca %struct._object*, align 8
  %call = call %struct._object* @PyModule_Create2(%struct.PyModuleDef* @posixmodule, i32 1013)
  store %struct._object* %call, %struct._object** %m, align 8
  %0 = load %struct._object*, %struct._object** %m, align 8
  %cmp = icmp eq %struct._object* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._object* @convertenviron()
  store %struct._object* %call1, %struct._object** %v, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %1 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %1, %struct._object** %_py_xincref_tmp, align 8
  %2 = load %struct._object*, %struct._object** %_py_xincref_tmp, align 8
  %cmp2 = icmp ne %struct._object* %2, null
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %do.body
  %3 = load %struct._object*, %struct._object** %_py_xincref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %3, i32 0, i32 0
  %4 = load i64, i64* %ob_refcnt, align 8
  %inc = add i64 %4, 1
  store i64 %inc, i64* %ob_refcnt, align 8
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.4
  %5 = load %struct._object*, %struct._object** %v, align 8
  %cmp5 = icmp eq %struct._object* %5, null
  br i1 %cmp5, label %if.then.8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %6 = load %struct._object*, %struct._object** %m, align 8
  %7 = load %struct._object*, %struct._object** %v, align 8
  %call6 = call i32 @PyModule_AddObject(%struct._object* %6, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.6, i32 0, i32 0), %struct._object* %7)
  %cmp7 = icmp ne i32 %call6, 0
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %lor.lhs.false, %do.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %lor.lhs.false
  br label %do.body.10

do.body.10:                                       ; preds = %if.end.9
  %8 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %8, %struct._object** %_py_decref_tmp, align 8
  %9 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt11 = getelementptr inbounds %struct._object, %struct._object* %9, i32 0, i32 0
  %10 = load i64, i64* %ob_refcnt11, align 8
  %dec = add i64 %10, -1
  store i64 %dec, i64* %ob_refcnt11, align 8
  %cmp12 = icmp ne i64 %dec, 0
  br i1 %cmp12, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %do.body.10
  br label %if.end.14

if.else:                                          ; preds = %do.body.10
  %11 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %11, i32 0, i32 1
  %12 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %12, i32 0, i32 4
  %13 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %13(%struct._object* %14)
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.then.13
  br label %do.end.15

do.end.15:                                        ; preds = %if.end.14
  %15 = load %struct._object*, %struct._object** %m, align 8
  %call16 = call i32 @all_ins(%struct._object* %15)
  %tobool = icmp ne i32 %call16, 0
  br i1 %tobool, label %if.then.17, label %if.end.18

if.then.17:                                       ; preds = %do.end.15
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.18:                                        ; preds = %do.end.15
  %16 = load %struct._object*, %struct._object** %m, align 8
  %call19 = call i32 @setup_confname_tables(%struct._object* %16)
  %tobool20 = icmp ne i32 %call19, 0
  br i1 %tobool20, label %if.then.21, label %if.end.22

if.then.21:                                       ; preds = %if.end.18
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.22:                                        ; preds = %if.end.18
  %17 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %ob_refcnt23 = getelementptr inbounds %struct._object, %struct._object* %17, i32 0, i32 0
  %18 = load i64, i64* %ob_refcnt23, align 8
  %inc24 = add i64 %18, 1
  store i64 %inc24, i64* %ob_refcnt23, align 8
  %19 = load %struct._object*, %struct._object** %m, align 8
  %20 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %call25 = call i32 @PyModule_AddObject(%struct._object* %19, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.7, i32 0, i32 0), %struct._object* %20)
  %21 = load %struct._object*, %struct._object** @posix_putenv_garbage, align 8
  %cmp26 = icmp eq %struct._object* %21, null
  br i1 %cmp26, label %if.then.27, label %if.end.29

if.then.27:                                       ; preds = %if.end.22
  %call28 = call %struct._object* @PyDict_New()
  store %struct._object* %call28, %struct._object** @posix_putenv_garbage, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.27, %if.end.22
  %22 = load i32, i32* @initialized, align 4
  %tobool30 = icmp ne i32 %22, 0
  br i1 %tobool30, label %if.end.57, label %if.then.31

if.then.31:                                       ; preds = %if.end.29
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.8, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @waitid_result_desc, i32 0, i32 0), align 8
  %call32 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @WaitidResultType, %struct.PyStructSequence_Desc* @waitid_result_desc)
  %cmp33 = icmp slt i32 %call32, 0
  br i1 %cmp33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.then.31
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.35:                                        ; preds = %if.then.31
  store i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.9, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @stat_result_desc, i32 0, i32 0), align 8
  %23 = load i8*, i8** @PyStructSequence_UnnamedField, align 8
  %24 = load %struct.PyStructSequence_Field*, %struct.PyStructSequence_Field** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx = getelementptr %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %24, i64 7
  %name = getelementptr inbounds %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %arrayidx, i32 0, i32 0
  store i8* %23, i8** %name, align 8
  %25 = load i8*, i8** @PyStructSequence_UnnamedField, align 8
  %26 = load %struct.PyStructSequence_Field*, %struct.PyStructSequence_Field** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx36 = getelementptr %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %26, i64 8
  %name37 = getelementptr inbounds %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %arrayidx36, i32 0, i32 0
  store i8* %25, i8** %name37, align 8
  %27 = load i8*, i8** @PyStructSequence_UnnamedField, align 8
  %28 = load %struct.PyStructSequence_Field*, %struct.PyStructSequence_Field** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @stat_result_desc, i32 0, i32 2), align 8
  %arrayidx38 = getelementptr %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %28, i64 9
  %name39 = getelementptr inbounds %struct.PyStructSequence_Field, %struct.PyStructSequence_Field* %arrayidx38, i32 0, i32 0
  store i8* %27, i8** %name39, align 8
  %call40 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @StatResultType, %struct.PyStructSequence_Desc* @stat_result_desc)
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %if.then.42, label %if.end.43

if.then.42:                                       ; preds = %if.end.35
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.43:                                        ; preds = %if.end.35
  %29 = load %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)*, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)** getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatResultType, i32 0, i32 37), align 8
  store %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)* %29, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)** @structseq_new, align 8
  store %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)* @statresult_new, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)** getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatResultType, i32 0, i32 37), align 8
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.10, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @statvfs_result_desc, i32 0, i32 0), align 8
  %call44 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @StatVFSResultType, %struct.PyStructSequence_Desc* @statvfs_result_desc)
  %cmp45 = icmp slt i32 %call44, 0
  br i1 %cmp45, label %if.then.46, label %if.end.47

if.then.46:                                       ; preds = %if.end.43
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.47:                                        ; preds = %if.end.43
  %call48 = call i64 @sysconf(i32 2) #4
  store i64 %call48, i64* @ticks_per_second, align 8
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.11, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @sched_param_desc, i32 0, i32 0), align 8
  %call49 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @SchedParamType, %struct.PyStructSequence_Desc* @sched_param_desc)
  %cmp50 = icmp slt i32 %call49, 0
  br i1 %cmp50, label %if.then.51, label %if.end.52

if.then.51:                                       ; preds = %if.end.47
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.52:                                        ; preds = %if.end.47
  store %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)* @sched_param_new, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)** getelementptr inbounds (%struct._typeobject, %struct._typeobject* @SchedParamType, i32 0, i32 37), align 8
  %call53 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @TerminalSizeType, %struct.PyStructSequence_Desc* @TerminalSize_desc)
  %cmp54 = icmp slt i32 %call53, 0
  br i1 %cmp54, label %if.then.55, label %if.end.56

if.then.55:                                       ; preds = %if.end.52
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.56:                                        ; preds = %if.end.52
  br label %if.end.57

if.end.57:                                        ; preds = %if.end.56, %if.end.29
  %30 = load i64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @WaitidResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %inc58 = add i64 %30, 1
  store i64 %inc58, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @WaitidResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %31 = load %struct._object*, %struct._object** %m, align 8
  %call59 = call i32 @PyModule_AddObject(%struct._object* %31, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.12, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @WaitidResultType, i32 0, i32 0, i32 0))
  %32 = load i64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %inc60 = add i64 %32, 1
  store i64 %inc60, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %33 = load %struct._object*, %struct._object** %m, align 8
  %call61 = call i32 @PyModule_AddObject(%struct._object* %33, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.13, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatResultType, i32 0, i32 0, i32 0))
  %34 = load i64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatVFSResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %inc62 = add i64 %34, 1
  store i64 %inc62, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatVFSResultType, i32 0, i32 0, i32 0, i32 0), align 8
  %35 = load %struct._object*, %struct._object** %m, align 8
  %call63 = call i32 @PyModule_AddObject(%struct._object* %35, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.14, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @StatVFSResultType, i32 0, i32 0, i32 0))
  %36 = load i64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @SchedParamType, i32 0, i32 0, i32 0, i32 0), align 8
  %inc64 = add i64 %36, 1
  store i64 %inc64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @SchedParamType, i32 0, i32 0, i32 0, i32 0), align 8
  %37 = load %struct._object*, %struct._object** %m, align 8
  %call65 = call i32 @PyModule_AddObject(%struct._object* %37, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.15, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @SchedParamType, i32 0, i32 0, i32 0))
  store i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.16, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @times_result_desc, i32 0, i32 0), align 8
  %call66 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @TimesResultType, %struct.PyStructSequence_Desc* @times_result_desc)
  %cmp67 = icmp slt i32 %call66, 0
  br i1 %cmp67, label %if.then.68, label %if.end.69

if.then.68:                                       ; preds = %if.end.57
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.69:                                        ; preds = %if.end.57
  %38 = load %struct._object*, %struct._object** %m, align 8
  %call70 = call i32 @PyModule_AddObject(%struct._object* %38, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.17, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @TimesResultType, i32 0, i32 0, i32 0))
  store i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.18, i32 0, i32 0), i8** getelementptr inbounds (%struct.PyStructSequence_Desc, %struct.PyStructSequence_Desc* @uname_result_desc, i32 0, i32 0), align 8
  %call71 = call i32 @PyStructSequence_InitType2(%struct._typeobject* @UnameResultType, %struct.PyStructSequence_Desc* @uname_result_desc)
  %cmp72 = icmp slt i32 %call71, 0
  br i1 %cmp72, label %if.then.73, label %if.end.74

if.then.73:                                       ; preds = %if.end.69
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.74:                                        ; preds = %if.end.69
  %39 = load %struct._object*, %struct._object** %m, align 8
  %call75 = call i32 @PyModule_AddObject(%struct._object* %39, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.19, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @UnameResultType, i32 0, i32 0, i32 0))
  %40 = load i64, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @TerminalSizeType, i32 0, i32 0, i32 0, i32 0), align 8
  %inc76 = add i64 %40, 1
  store i64 %inc76, i64* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @TerminalSizeType, i32 0, i32 0, i32 0, i32 0), align 8
  %41 = load %struct._object*, %struct._object** %m, align 8
  %call77 = call i32 @PyModule_AddObject(%struct._object* %41, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.20, i32 0, i32 0), %struct._object* getelementptr inbounds (%struct._typeobject, %struct._typeobject* @TerminalSizeType, i32 0, i32 0, i32 0))
  %call78 = call %struct._object* @PyLong_FromLong(i64 1000000000)
  store %struct._object* %call78, %struct._object** @billion, align 8
  %42 = load %struct._object*, %struct._object** @billion, align 8
  %tobool79 = icmp ne %struct._object* %42, null
  br i1 %tobool79, label %if.end.81, label %if.then.80

if.then.80:                                       ; preds = %if.end.74
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.81:                                        ; preds = %if.end.74
  %call82 = call i32 @fd_specified(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), i32 -1)
  %call83 = call i32 @follow_symlinks_specified(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), i32 1)
  %call84 = call i32 @dir_fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22, i32 0, i32 0), i32 -100, i32 1)
  %43 = bitcast i32* %ignored to i8*
  %call85 = call i32 @dir_fd_converter(%struct._object* @_Py_NoneStruct, i8* %43)
  %44 = bitcast i32* %ignored to i8*
  %call86 = call i32 @dir_fd_unavailable(%struct._object* @_Py_NoneStruct, i8* %44)
  %call87 = call %struct._object* @PyList_New(i64 0)
  store %struct._object* %call87, %struct._object** %list, align 8
  %45 = load %struct._object*, %struct._object** %list, align 8
  %tobool88 = icmp ne %struct._object* %45, null
  br i1 %tobool88, label %if.end.90, label %if.then.89

if.then.89:                                       ; preds = %if.end.81
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.90:                                        ; preds = %if.end.81
  store i8** getelementptr inbounds ([29 x i8*], [29 x i8*]* @have_functions, i32 0, i32 0), i8*** %trace, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.90
  %46 = load i8**, i8*** %trace, align 8
  %47 = load i8*, i8** %46, align 8
  %tobool91 = icmp ne i8* %47, null
  br i1 %tobool91, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %48 = load i8**, i8*** %trace, align 8
  %49 = load i8*, i8** %48, align 8
  %50 = load i8**, i8*** %trace, align 8
  %51 = load i8*, i8** %50, align 8
  %call92 = call i64 @strlen(i8* %51) #8
  %call93 = call %struct._object* @PyUnicode_DecodeASCII(i8* %49, i64 %call92, i8* null)
  store %struct._object* %call93, %struct._object** %unicode, align 8
  %52 = load %struct._object*, %struct._object** %unicode, align 8
  %tobool94 = icmp ne %struct._object* %52, null
  br i1 %tobool94, label %if.end.96, label %if.then.95

if.then.95:                                       ; preds = %for.body
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.96:                                        ; preds = %for.body
  %53 = load %struct._object*, %struct._object** %list, align 8
  %54 = load %struct._object*, %struct._object** %unicode, align 8
  %call97 = call i32 @PyList_Append(%struct._object* %53, %struct._object* %54)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.then.99, label %if.end.100

if.then.99:                                       ; preds = %if.end.96
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.100:                                       ; preds = %if.end.96
  br label %do.body.101

do.body.101:                                      ; preds = %if.end.100
  %55 = load %struct._object*, %struct._object** %unicode, align 8
  store %struct._object* %55, %struct._object** %_py_decref_tmp102, align 8
  %56 = load %struct._object*, %struct._object** %_py_decref_tmp102, align 8
  %ob_refcnt103 = getelementptr inbounds %struct._object, %struct._object* %56, i32 0, i32 0
  %57 = load i64, i64* %ob_refcnt103, align 8
  %dec104 = add i64 %57, -1
  store i64 %dec104, i64* %ob_refcnt103, align 8
  %cmp105 = icmp ne i64 %dec104, 0
  br i1 %cmp105, label %if.then.106, label %if.else.107

if.then.106:                                      ; preds = %do.body.101
  br label %if.end.110

if.else.107:                                      ; preds = %do.body.101
  %58 = load %struct._object*, %struct._object** %_py_decref_tmp102, align 8
  %ob_type108 = getelementptr inbounds %struct._object, %struct._object* %58, i32 0, i32 1
  %59 = load %struct._typeobject*, %struct._typeobject** %ob_type108, align 8
  %tp_dealloc109 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %59, i32 0, i32 4
  %60 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc109, align 8
  %61 = load %struct._object*, %struct._object** %_py_decref_tmp102, align 8
  call void %60(%struct._object* %61)
  br label %if.end.110

if.end.110:                                       ; preds = %if.else.107, %if.then.106
  br label %do.end.111

do.end.111:                                       ; preds = %if.end.110
  br label %for.inc

for.inc:                                          ; preds = %do.end.111
  %62 = load i8**, i8*** %trace, align 8
  %incdec.ptr = getelementptr i8*, i8** %62, i32 1
  store i8** %incdec.ptr, i8*** %trace, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %63 = load %struct._object*, %struct._object** %m, align 8
  %64 = load %struct._object*, %struct._object** %list, align 8
  %call112 = call i32 @PyModule_AddObject(%struct._object* %63, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.23, i32 0, i32 0), %struct._object* %64)
  store i32 1, i32* @initialized, align 4
  %65 = load %struct._object*, %struct._object** %m, align 8
  store %struct._object* %65, %struct._object** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.99, %if.then.95, %if.then.89, %if.then.80, %if.then.73, %if.then.68, %if.then.55, %if.then.51, %if.then.46, %if.then.42, %if.then.34, %if.then.21, %if.then.17, %if.then.8, %if.then
  %66 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %66
}

declare %struct._object* @PyModule_Create2(%struct.PyModuleDef*, i32) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @convertenviron() #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %d = alloca %struct._object*, align 8
  %e = alloca i8**, align 8
  %k = alloca %struct._object*, align 8
  %v = alloca %struct._object*, align 8
  %p = alloca i8*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp37 = alloca %struct._object*, align 8
  %_py_decref_tmp49 = alloca %struct._object*, align 8
  %call = call %struct._object* @PyDict_New()
  store %struct._object* %call, %struct._object** %d, align 8
  %0 = load %struct._object*, %struct._object** %d, align 8
  %cmp = icmp eq %struct._object* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8**, i8*** @environ, align 8
  %cmp1 = icmp eq i8** %1, null
  br i1 %cmp1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %2 = load %struct._object*, %struct._object** %d, align 8
  store %struct._object* %2, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i8**, i8*** @environ, align 8
  store i8** %3, i8*** %e, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.3
  %4 = load i8**, i8*** %e, align 8
  %5 = load i8*, i8** %4, align 8
  %cmp4 = icmp ne i8* %5, null
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i8**, i8*** %e, align 8
  %7 = load i8*, i8** %6, align 8
  %call5 = call i8* @strchr(i8* %7, i32 61) #8
  store i8* %call5, i8** %p, align 8
  %8 = load i8*, i8** %p, align 8
  %cmp6 = icmp eq i8* %8, null
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %for.body
  br label %for.inc

if.end.8:                                         ; preds = %for.body
  %9 = load i8**, i8*** %e, align 8
  %10 = load i8*, i8** %9, align 8
  %11 = load i8*, i8** %p, align 8
  %12 = load i8**, i8*** %e, align 8
  %13 = load i8*, i8** %12, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %11 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %conv9 = sext i32 %conv to i64
  %call10 = call %struct._object* @PyBytes_FromStringAndSize(i8* %10, i64 %conv9)
  store %struct._object* %call10, %struct._object** %k, align 8
  %14 = load %struct._object*, %struct._object** %k, align 8
  %cmp11 = icmp eq %struct._object* %14, null
  br i1 %cmp11, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %if.end.8
  call void @PyErr_Clear()
  br label %for.inc

if.end.14:                                        ; preds = %if.end.8
  %15 = load i8*, i8** %p, align 8
  %add.ptr = getelementptr i8, i8* %15, i64 1
  %16 = load i8*, i8** %p, align 8
  %add.ptr15 = getelementptr i8, i8* %16, i64 1
  %call16 = call i64 @strlen(i8* %add.ptr15) #8
  %call17 = call %struct._object* @PyBytes_FromStringAndSize(i8* %add.ptr, i64 %call16)
  store %struct._object* %call17, %struct._object** %v, align 8
  %17 = load %struct._object*, %struct._object** %v, align 8
  %cmp18 = icmp eq %struct._object* %17, null
  br i1 %cmp18, label %if.then.20, label %if.end.25

if.then.20:                                       ; preds = %if.end.14
  call void @PyErr_Clear()
  br label %do.body

do.body:                                          ; preds = %if.then.20
  %18 = load %struct._object*, %struct._object** %k, align 8
  store %struct._object* %18, %struct._object** %_py_decref_tmp, align 8
  %19 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %19, i32 0, i32 0
  %20 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %20, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp21 = icmp ne i64 %dec, 0
  br i1 %cmp21, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %do.body
  br label %if.end.24

if.else:                                          ; preds = %do.body
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %21, i32 0, i32 1
  %22 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %22, i32 0, i32 4
  %23 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %24 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %23(%struct._object* %24)
  br label %if.end.24

if.end.24:                                        ; preds = %if.else, %if.then.23
  br label %do.end

do.end:                                           ; preds = %if.end.24
  br label %for.inc

if.end.25:                                        ; preds = %if.end.14
  %25 = load %struct._object*, %struct._object** %d, align 8
  %26 = load %struct._object*, %struct._object** %k, align 8
  %call26 = call %struct._object* @PyDict_GetItem(%struct._object* %25, %struct._object* %26)
  %cmp27 = icmp eq %struct._object* %call26, null
  br i1 %cmp27, label %if.then.29, label %if.end.35

if.then.29:                                       ; preds = %if.end.25
  %27 = load %struct._object*, %struct._object** %d, align 8
  %28 = load %struct._object*, %struct._object** %k, align 8
  %29 = load %struct._object*, %struct._object** %v, align 8
  %call30 = call i32 @PyDict_SetItem(%struct._object* %27, %struct._object* %28, %struct._object* %29)
  %cmp31 = icmp ne i32 %call30, 0
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.then.29
  call void @PyErr_Clear()
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.33, %if.then.29
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34, %if.end.25
  br label %do.body.36

do.body.36:                                       ; preds = %if.end.35
  %30 = load %struct._object*, %struct._object** %k, align 8
  store %struct._object* %30, %struct._object** %_py_decref_tmp37, align 8
  %31 = load %struct._object*, %struct._object** %_py_decref_tmp37, align 8
  %ob_refcnt38 = getelementptr inbounds %struct._object, %struct._object* %31, i32 0, i32 0
  %32 = load i64, i64* %ob_refcnt38, align 8
  %dec39 = add i64 %32, -1
  store i64 %dec39, i64* %ob_refcnt38, align 8
  %cmp40 = icmp ne i64 %dec39, 0
  br i1 %cmp40, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %do.body.36
  br label %if.end.46

if.else.43:                                       ; preds = %do.body.36
  %33 = load %struct._object*, %struct._object** %_py_decref_tmp37, align 8
  %ob_type44 = getelementptr inbounds %struct._object, %struct._object* %33, i32 0, i32 1
  %34 = load %struct._typeobject*, %struct._typeobject** %ob_type44, align 8
  %tp_dealloc45 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %34, i32 0, i32 4
  %35 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc45, align 8
  %36 = load %struct._object*, %struct._object** %_py_decref_tmp37, align 8
  call void %35(%struct._object* %36)
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.43, %if.then.42
  br label %do.end.47

do.end.47:                                        ; preds = %if.end.46
  br label %do.body.48

do.body.48:                                       ; preds = %do.end.47
  %37 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %37, %struct._object** %_py_decref_tmp49, align 8
  %38 = load %struct._object*, %struct._object** %_py_decref_tmp49, align 8
  %ob_refcnt50 = getelementptr inbounds %struct._object, %struct._object* %38, i32 0, i32 0
  %39 = load i64, i64* %ob_refcnt50, align 8
  %dec51 = add i64 %39, -1
  store i64 %dec51, i64* %ob_refcnt50, align 8
  %cmp52 = icmp ne i64 %dec51, 0
  br i1 %cmp52, label %if.then.54, label %if.else.55

if.then.54:                                       ; preds = %do.body.48
  br label %if.end.58

if.else.55:                                       ; preds = %do.body.48
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp49, align 8
  %ob_type56 = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 1
  %41 = load %struct._typeobject*, %struct._typeobject** %ob_type56, align 8
  %tp_dealloc57 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %41, i32 0, i32 4
  %42 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc57, align 8
  %43 = load %struct._object*, %struct._object** %_py_decref_tmp49, align 8
  call void %42(%struct._object* %43)
  br label %if.end.58

if.end.58:                                        ; preds = %if.else.55, %if.then.54
  br label %do.end.59

do.end.59:                                        ; preds = %if.end.58
  br label %for.inc

for.inc:                                          ; preds = %do.end.59, %do.end, %if.then.13, %if.then.7
  %44 = load i8**, i8*** %e, align 8
  %incdec.ptr = getelementptr i8*, i8** %44, i32 1
  store i8** %incdec.ptr, i8*** %e, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %45 = load %struct._object*, %struct._object** %d, align 8
  store %struct._object* %45, %struct._object** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.2, %if.then
  %46 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %46
}

declare i32 @PyModule_AddObject(%struct._object*, i8*, %struct._object*) #1

; Function Attrs: nounwind uwtable
define internal i32 @all_ins(%struct._object* %m) #0 {
entry:
  %retval = alloca i32, align 4
  %m.addr = alloca %struct._object*, align 8
  store %struct._object* %m, %struct._object** %m.addr, align 8
  %0 = load %struct._object*, %struct._object** %m.addr, align 8
  %call = call i32 @PyModule_AddIntConstant(%struct._object* %0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.542, i32 0, i32 0), i64 0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %m.addr, align 8
  %call1 = call i32 @PyModule_AddIntConstant(%struct._object* %1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.543, i32 0, i32 0), i64 4)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  store i32 -1, i32* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load %struct._object*, %struct._object** %m.addr, align 8
  %call5 = call i32 @PyModule_AddIntConstant(%struct._object* %2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.544, i32 0, i32 0), i64 2)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.4
  store i32 -1, i32* %retval
  br label %return

if.end.8:                                         ; preds = %if.end.4
  %3 = load %struct._object*, %struct._object** %m.addr, align 8
  %call9 = call i32 @PyModule_AddIntConstant(%struct._object* %3, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.545, i32 0, i32 0), i64 1)
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %if.end.8
  store i32 -1, i32* %retval
  br label %return

if.end.12:                                        ; preds = %if.end.8
  %4 = load %struct._object*, %struct._object** %m.addr, align 8
  %call13 = call i32 @PyModule_AddIntConstant(%struct._object* %4, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.546, i32 0, i32 0), i64 65536)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %if.end.12
  store i32 -1, i32* %retval
  br label %return

if.end.16:                                        ; preds = %if.end.12
  %5 = load %struct._object*, %struct._object** %m.addr, align 8
  %call17 = call i32 @PyModule_AddIntConstant(%struct._object* %5, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.547, i32 0, i32 0), i64 238328)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %if.end.16
  store i32 -1, i32* %retval
  br label %return

if.end.20:                                        ; preds = %if.end.16
  %6 = load %struct._object*, %struct._object** %m.addr, align 8
  %call21 = call i32 @PyModule_AddIntConstant(%struct._object* %6, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.548, i32 0, i32 0), i64 8)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.then.23, label %if.end.24

if.then.23:                                       ; preds = %if.end.20
  store i32 -1, i32* %retval
  br label %return

if.end.24:                                        ; preds = %if.end.20
  %7 = load %struct._object*, %struct._object** %m.addr, align 8
  %call25 = call i32 @PyModule_AddIntConstant(%struct._object* %7, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.549, i32 0, i32 0), i64 1)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end.24
  store i32 -1, i32* %retval
  br label %return

if.end.28:                                        ; preds = %if.end.24
  %8 = load %struct._object*, %struct._object** %m.addr, align 8
  %call29 = call i32 @PyModule_AddIntConstant(%struct._object* %8, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.550, i32 0, i32 0), i64 2)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %if.end.28
  store i32 -1, i32* %retval
  br label %return

if.end.32:                                        ; preds = %if.end.28
  %9 = load %struct._object*, %struct._object** %m.addr, align 8
  %call33 = call i32 @PyModule_AddIntConstant(%struct._object* %9, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.551, i32 0, i32 0), i64 0)
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.then.35, label %if.end.36

if.then.35:                                       ; preds = %if.end.32
  store i32 -1, i32* %retval
  br label %return

if.end.36:                                        ; preds = %if.end.32
  %10 = load %struct._object*, %struct._object** %m.addr, align 8
  %call37 = call i32 @PyModule_AddIntConstant(%struct._object* %10, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.552, i32 0, i32 0), i64 1)
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.then.39, label %if.end.40

if.then.39:                                       ; preds = %if.end.36
  store i32 -1, i32* %retval
  br label %return

if.end.40:                                        ; preds = %if.end.36
  %11 = load %struct._object*, %struct._object** %m.addr, align 8
  %call41 = call i32 @PyModule_AddIntConstant(%struct._object* %11, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.553, i32 0, i32 0), i64 2)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %if.end.40
  store i32 -1, i32* %retval
  br label %return

if.end.44:                                        ; preds = %if.end.40
  %12 = load %struct._object*, %struct._object** %m.addr, align 8
  %call45 = call i32 @PyModule_AddIntConstant(%struct._object* %12, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.554, i32 0, i32 0), i64 2048)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %if.end.44
  store i32 -1, i32* %retval
  br label %return

if.end.48:                                        ; preds = %if.end.44
  %13 = load %struct._object*, %struct._object** %m.addr, align 8
  %call49 = call i32 @PyModule_AddIntConstant(%struct._object* %13, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.555, i32 0, i32 0), i64 2048)
  %tobool50 = icmp ne i32 %call49, 0
  br i1 %tobool50, label %if.then.51, label %if.end.52

if.then.51:                                       ; preds = %if.end.48
  store i32 -1, i32* %retval
  br label %return

if.end.52:                                        ; preds = %if.end.48
  %14 = load %struct._object*, %struct._object** %m.addr, align 8
  %call53 = call i32 @PyModule_AddIntConstant(%struct._object* %14, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.556, i32 0, i32 0), i64 1024)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then.55, label %if.end.56

if.then.55:                                       ; preds = %if.end.52
  store i32 -1, i32* %retval
  br label %return

if.end.56:                                        ; preds = %if.end.52
  %15 = load %struct._object*, %struct._object** %m.addr, align 8
  %call57 = call i32 @PyModule_AddIntConstant(%struct._object* %15, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.557, i32 0, i32 0), i64 4096)
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then.59, label %if.end.60

if.then.59:                                       ; preds = %if.end.56
  store i32 -1, i32* %retval
  br label %return

if.end.60:                                        ; preds = %if.end.56
  %16 = load %struct._object*, %struct._object** %m.addr, align 8
  %call61 = call i32 @PyModule_AddIntConstant(%struct._object* %16, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.558, i32 0, i32 0), i64 1052672)
  %tobool62 = icmp ne i32 %call61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.64

if.then.63:                                       ; preds = %if.end.60
  store i32 -1, i32* %retval
  br label %return

if.end.64:                                        ; preds = %if.end.60
  %17 = load %struct._object*, %struct._object** %m.addr, align 8
  %call65 = call i32 @PyModule_AddIntConstant(%struct._object* %17, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.559, i32 0, i32 0), i64 1052672)
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.then.67, label %if.end.68

if.then.67:                                       ; preds = %if.end.64
  store i32 -1, i32* %retval
  br label %return

if.end.68:                                        ; preds = %if.end.64
  %18 = load %struct._object*, %struct._object** %m.addr, align 8
  %call69 = call i32 @PyModule_AddIntConstant(%struct._object* %18, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.560, i32 0, i32 0), i64 256)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.then.71, label %if.end.72

if.then.71:                                       ; preds = %if.end.68
  store i32 -1, i32* %retval
  br label %return

if.end.72:                                        ; preds = %if.end.68
  %19 = load %struct._object*, %struct._object** %m.addr, align 8
  %call73 = call i32 @PyModule_AddIntConstant(%struct._object* %19, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.561, i32 0, i32 0), i64 64)
  %tobool74 = icmp ne i32 %call73, 0
  br i1 %tobool74, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %if.end.72
  store i32 -1, i32* %retval
  br label %return

if.end.76:                                        ; preds = %if.end.72
  %20 = load %struct._object*, %struct._object** %m.addr, align 8
  %call77 = call i32 @PyModule_AddIntConstant(%struct._object* %20, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.562, i32 0, i32 0), i64 128)
  %tobool78 = icmp ne i32 %call77, 0
  br i1 %tobool78, label %if.then.79, label %if.end.80

if.then.79:                                       ; preds = %if.end.76
  store i32 -1, i32* %retval
  br label %return

if.end.80:                                        ; preds = %if.end.76
  %21 = load %struct._object*, %struct._object** %m.addr, align 8
  %call81 = call i32 @PyModule_AddIntConstant(%struct._object* %21, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.563, i32 0, i32 0), i64 512)
  %tobool82 = icmp ne i32 %call81, 0
  br i1 %tobool82, label %if.then.83, label %if.end.84

if.then.83:                                       ; preds = %if.end.80
  store i32 -1, i32* %retval
  br label %return

if.end.84:                                        ; preds = %if.end.80
  %22 = load %struct._object*, %struct._object** %m.addr, align 8
  %call85 = call i32 @PyModule_AddIntConstant(%struct._object* %22, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.564, i32 0, i32 0), i64 0)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.then.87, label %if.end.88

if.then.87:                                       ; preds = %if.end.84
  store i32 -1, i32* %retval
  br label %return

if.end.88:                                        ; preds = %if.end.84
  %23 = load %struct._object*, %struct._object** %m.addr, align 8
  %call89 = call i32 @PyModule_AddIntConstant(%struct._object* %23, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.565, i32 0, i32 0), i64 2097152)
  %tobool90 = icmp ne i32 %call89, 0
  br i1 %tobool90, label %if.then.91, label %if.end.92

if.then.91:                                       ; preds = %if.end.88
  store i32 -1, i32* %retval
  br label %return

if.end.92:                                        ; preds = %if.end.88
  %24 = load %struct._object*, %struct._object** %m.addr, align 8
  %call93 = call i32 @PyModule_AddIntConstant(%struct._object* %24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.566, i32 0, i32 0), i64 0)
  %tobool94 = icmp ne i32 %call93, 0
  br i1 %tobool94, label %if.then.95, label %if.end.96

if.then.95:                                       ; preds = %if.end.92
  store i32 -1, i32* %retval
  br label %return

if.end.96:                                        ; preds = %if.end.92
  %25 = load %struct._object*, %struct._object** %m.addr, align 8
  %call97 = call i32 @PyModule_AddIntConstant(%struct._object* %25, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.567, i32 0, i32 0), i64 1)
  %tobool98 = icmp ne i32 %call97, 0
  br i1 %tobool98, label %if.then.99, label %if.end.100

if.then.99:                                       ; preds = %if.end.96
  store i32 -1, i32* %retval
  br label %return

if.end.100:                                       ; preds = %if.end.96
  %26 = load %struct._object*, %struct._object** %m.addr, align 8
  %call101 = call i32 @PyModule_AddIntConstant(%struct._object* %26, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.568, i32 0, i32 0), i64 2)
  %tobool102 = icmp ne i32 %call101, 0
  br i1 %tobool102, label %if.then.103, label %if.end.104

if.then.103:                                      ; preds = %if.end.100
  store i32 -1, i32* %retval
  br label %return

if.end.104:                                       ; preds = %if.end.100
  %27 = load %struct._object*, %struct._object** %m.addr, align 8
  %call105 = call i32 @PyModule_AddIntConstant(%struct._object* %27, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.569, i32 0, i32 0), i64 524288)
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then.107, label %if.end.108

if.then.107:                                      ; preds = %if.end.104
  store i32 -1, i32* %retval
  br label %return

if.end.108:                                       ; preds = %if.end.104
  %28 = load %struct._object*, %struct._object** %m.addr, align 8
  %call109 = call i32 @PyModule_AddIntConstant(%struct._object* %28, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.570, i32 0, i32 0), i64 3)
  %tobool110 = icmp ne i32 %call109, 0
  br i1 %tobool110, label %if.then.111, label %if.end.112

if.then.111:                                      ; preds = %if.end.108
  store i32 -1, i32* %retval
  br label %return

if.end.112:                                       ; preds = %if.end.108
  %29 = load %struct._object*, %struct._object** %m.addr, align 8
  %call113 = call i32 @PyModule_AddIntConstant(%struct._object* %29, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.571, i32 0, i32 0), i64 4)
  %tobool114 = icmp ne i32 %call113, 0
  br i1 %tobool114, label %if.then.115, label %if.end.116

if.then.115:                                      ; preds = %if.end.112
  store i32 -1, i32* %retval
  br label %return

if.end.116:                                       ; preds = %if.end.112
  %30 = load %struct._object*, %struct._object** %m.addr, align 8
  %call117 = call i32 @PyModule_AddIntConstant(%struct._object* %30, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.572, i32 0, i32 0), i64 3)
  %tobool118 = icmp ne i32 %call117, 0
  br i1 %tobool118, label %if.then.119, label %if.end.120

if.then.119:                                      ; preds = %if.end.116
  store i32 -1, i32* %retval
  br label %return

if.end.120:                                       ; preds = %if.end.116
  %31 = load %struct._object*, %struct._object** %m.addr, align 8
  %call121 = call i32 @PyModule_AddIntConstant(%struct._object* %31, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.573, i32 0, i32 0), i64 8192)
  %tobool122 = icmp ne i32 %call121, 0
  br i1 %tobool122, label %if.then.123, label %if.end.124

if.then.123:                                      ; preds = %if.end.120
  store i32 -1, i32* %retval
  br label %return

if.end.124:                                       ; preds = %if.end.120
  %32 = load %struct._object*, %struct._object** %m.addr, align 8
  %call125 = call i32 @PyModule_AddIntConstant(%struct._object* %32, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.574, i32 0, i32 0), i64 16384)
  %tobool126 = icmp ne i32 %call125, 0
  br i1 %tobool126, label %if.then.127, label %if.end.128

if.then.127:                                      ; preds = %if.end.124
  store i32 -1, i32* %retval
  br label %return

if.end.128:                                       ; preds = %if.end.124
  %33 = load %struct._object*, %struct._object** %m.addr, align 8
  %call129 = call i32 @PyModule_AddIntConstant(%struct._object* %33, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.575, i32 0, i32 0), i64 65536)
  %tobool130 = icmp ne i32 %call129, 0
  br i1 %tobool130, label %if.then.131, label %if.end.132

if.then.131:                                      ; preds = %if.end.128
  store i32 -1, i32* %retval
  br label %return

if.end.132:                                       ; preds = %if.end.128
  %34 = load %struct._object*, %struct._object** %m.addr, align 8
  %call133 = call i32 @PyModule_AddIntConstant(%struct._object* %34, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.576, i32 0, i32 0), i64 131072)
  %tobool134 = icmp ne i32 %call133, 0
  br i1 %tobool134, label %if.then.135, label %if.end.136

if.then.135:                                      ; preds = %if.end.132
  store i32 -1, i32* %retval
  br label %return

if.end.136:                                       ; preds = %if.end.132
  %35 = load %struct._object*, %struct._object** %m.addr, align 8
  %call137 = call i32 @PyModule_AddIntConstant(%struct._object* %35, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.577, i32 0, i32 0), i64 262144)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then.139, label %if.end.140

if.then.139:                                      ; preds = %if.end.136
  store i32 -1, i32* %retval
  br label %return

if.end.140:                                       ; preds = %if.end.136
  %36 = load %struct._object*, %struct._object** %m.addr, align 8
  %call141 = call i32 @PyModule_AddIntConstant(%struct._object* %36, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.578, i32 0, i32 0), i64 0)
  %tobool142 = icmp ne i32 %call141, 0
  br i1 %tobool142, label %if.then.143, label %if.end.144

if.then.143:                                      ; preds = %if.end.140
  store i32 -1, i32* %retval
  br label %return

if.end.144:                                       ; preds = %if.end.140
  %37 = load %struct._object*, %struct._object** %m.addr, align 8
  %call145 = call i32 @PyModule_AddIntConstant(%struct._object* %37, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.579, i32 0, i32 0), i64 64)
  %tobool146 = icmp ne i32 %call145, 0
  br i1 %tobool146, label %if.then.147, label %if.end.148

if.then.147:                                      ; preds = %if.end.144
  store i32 -1, i32* %retval
  br label %return

if.end.148:                                       ; preds = %if.end.144
  %38 = load %struct._object*, %struct._object** %m.addr, align 8
  %call149 = call i32 @PyModule_AddIntConstant(%struct._object* %38, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.580, i32 0, i32 0), i64 65)
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %if.then.151, label %if.end.152

if.then.151:                                      ; preds = %if.end.148
  store i32 -1, i32* %retval
  br label %return

if.end.152:                                       ; preds = %if.end.148
  %39 = load %struct._object*, %struct._object** %m.addr, align 8
  %call153 = call i32 @PyModule_AddIntConstant(%struct._object* %39, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.581, i32 0, i32 0), i64 66)
  %tobool154 = icmp ne i32 %call153, 0
  br i1 %tobool154, label %if.then.155, label %if.end.156

if.then.155:                                      ; preds = %if.end.152
  store i32 -1, i32* %retval
  br label %return

if.end.156:                                       ; preds = %if.end.152
  %40 = load %struct._object*, %struct._object** %m.addr, align 8
  %call157 = call i32 @PyModule_AddIntConstant(%struct._object* %40, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.582, i32 0, i32 0), i64 67)
  %tobool158 = icmp ne i32 %call157, 0
  br i1 %tobool158, label %if.then.159, label %if.end.160

if.then.159:                                      ; preds = %if.end.156
  store i32 -1, i32* %retval
  br label %return

if.end.160:                                       ; preds = %if.end.156
  %41 = load %struct._object*, %struct._object** %m.addr, align 8
  %call161 = call i32 @PyModule_AddIntConstant(%struct._object* %41, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.583, i32 0, i32 0), i64 68)
  %tobool162 = icmp ne i32 %call161, 0
  br i1 %tobool162, label %if.then.163, label %if.end.164

if.then.163:                                      ; preds = %if.end.160
  store i32 -1, i32* %retval
  br label %return

if.end.164:                                       ; preds = %if.end.160
  %42 = load %struct._object*, %struct._object** %m.addr, align 8
  %call165 = call i32 @PyModule_AddIntConstant(%struct._object* %42, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.584, i32 0, i32 0), i64 69)
  %tobool166 = icmp ne i32 %call165, 0
  br i1 %tobool166, label %if.then.167, label %if.end.168

if.then.167:                                      ; preds = %if.end.164
  store i32 -1, i32* %retval
  br label %return

if.end.168:                                       ; preds = %if.end.164
  %43 = load %struct._object*, %struct._object** %m.addr, align 8
  %call169 = call i32 @PyModule_AddIntConstant(%struct._object* %43, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.585, i32 0, i32 0), i64 70)
  %tobool170 = icmp ne i32 %call169, 0
  br i1 %tobool170, label %if.then.171, label %if.end.172

if.then.171:                                      ; preds = %if.end.168
  store i32 -1, i32* %retval
  br label %return

if.end.172:                                       ; preds = %if.end.168
  %44 = load %struct._object*, %struct._object** %m.addr, align 8
  %call173 = call i32 @PyModule_AddIntConstant(%struct._object* %44, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.586, i32 0, i32 0), i64 71)
  %tobool174 = icmp ne i32 %call173, 0
  br i1 %tobool174, label %if.then.175, label %if.end.176

if.then.175:                                      ; preds = %if.end.172
  store i32 -1, i32* %retval
  br label %return

if.end.176:                                       ; preds = %if.end.172
  %45 = load %struct._object*, %struct._object** %m.addr, align 8
  %call177 = call i32 @PyModule_AddIntConstant(%struct._object* %45, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.587, i32 0, i32 0), i64 72)
  %tobool178 = icmp ne i32 %call177, 0
  br i1 %tobool178, label %if.then.179, label %if.end.180

if.then.179:                                      ; preds = %if.end.176
  store i32 -1, i32* %retval
  br label %return

if.end.180:                                       ; preds = %if.end.176
  %46 = load %struct._object*, %struct._object** %m.addr, align 8
  %call181 = call i32 @PyModule_AddIntConstant(%struct._object* %46, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.588, i32 0, i32 0), i64 73)
  %tobool182 = icmp ne i32 %call181, 0
  br i1 %tobool182, label %if.then.183, label %if.end.184

if.then.183:                                      ; preds = %if.end.180
  store i32 -1, i32* %retval
  br label %return

if.end.184:                                       ; preds = %if.end.180
  %47 = load %struct._object*, %struct._object** %m.addr, align 8
  %call185 = call i32 @PyModule_AddIntConstant(%struct._object* %47, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.589, i32 0, i32 0), i64 74)
  %tobool186 = icmp ne i32 %call185, 0
  br i1 %tobool186, label %if.then.187, label %if.end.188

if.then.187:                                      ; preds = %if.end.184
  store i32 -1, i32* %retval
  br label %return

if.end.188:                                       ; preds = %if.end.184
  %48 = load %struct._object*, %struct._object** %m.addr, align 8
  %call189 = call i32 @PyModule_AddIntConstant(%struct._object* %48, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.590, i32 0, i32 0), i64 75)
  %tobool190 = icmp ne i32 %call189, 0
  br i1 %tobool190, label %if.then.191, label %if.end.192

if.then.191:                                      ; preds = %if.end.188
  store i32 -1, i32* %retval
  br label %return

if.end.192:                                       ; preds = %if.end.188
  %49 = load %struct._object*, %struct._object** %m.addr, align 8
  %call193 = call i32 @PyModule_AddIntConstant(%struct._object* %49, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.591, i32 0, i32 0), i64 76)
  %tobool194 = icmp ne i32 %call193, 0
  br i1 %tobool194, label %if.then.195, label %if.end.196

if.then.195:                                      ; preds = %if.end.192
  store i32 -1, i32* %retval
  br label %return

if.end.196:                                       ; preds = %if.end.192
  %50 = load %struct._object*, %struct._object** %m.addr, align 8
  %call197 = call i32 @PyModule_AddIntConstant(%struct._object* %50, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.592, i32 0, i32 0), i64 77)
  %tobool198 = icmp ne i32 %call197, 0
  br i1 %tobool198, label %if.then.199, label %if.end.200

if.then.199:                                      ; preds = %if.end.196
  store i32 -1, i32* %retval
  br label %return

if.end.200:                                       ; preds = %if.end.196
  %51 = load %struct._object*, %struct._object** %m.addr, align 8
  %call201 = call i32 @PyModule_AddIntConstant(%struct._object* %51, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.593, i32 0, i32 0), i64 78)
  %tobool202 = icmp ne i32 %call201, 0
  br i1 %tobool202, label %if.then.203, label %if.end.204

if.then.203:                                      ; preds = %if.end.200
  store i32 -1, i32* %retval
  br label %return

if.end.204:                                       ; preds = %if.end.200
  %52 = load %struct._object*, %struct._object** %m.addr, align 8
  %call205 = call i32 @PyModule_AddIntConstant(%struct._object* %52, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.594, i32 0, i32 0), i64 1)
  %tobool206 = icmp ne i32 %call205, 0
  br i1 %tobool206, label %if.then.207, label %if.end.208

if.then.207:                                      ; preds = %if.end.204
  store i32 -1, i32* %retval
  br label %return

if.end.208:                                       ; preds = %if.end.204
  %53 = load %struct._object*, %struct._object** %m.addr, align 8
  %call209 = call i32 @PyModule_AddIntConstant(%struct._object* %53, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.595, i32 0, i32 0), i64 2)
  %tobool210 = icmp ne i32 %call209, 0
  br i1 %tobool210, label %if.then.211, label %if.end.212

if.then.211:                                      ; preds = %if.end.208
  store i32 -1, i32* %retval
  br label %return

if.end.212:                                       ; preds = %if.end.208
  %54 = load %struct._object*, %struct._object** %m.addr, align 8
  %call213 = call i32 @PyModule_AddIntConstant(%struct._object* %54, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.596, i32 0, i32 0), i64 4)
  %tobool214 = icmp ne i32 %call213, 0
  br i1 %tobool214, label %if.then.215, label %if.end.216

if.then.215:                                      ; preds = %if.end.212
  store i32 -1, i32* %retval
  br label %return

if.end.216:                                       ; preds = %if.end.212
  %55 = load %struct._object*, %struct._object** %m.addr, align 8
  %call217 = call i32 @PyModule_AddIntConstant(%struct._object* %55, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.597, i32 0, i32 0), i64 8)
  %tobool218 = icmp ne i32 %call217, 0
  br i1 %tobool218, label %if.then.219, label %if.end.220

if.then.219:                                      ; preds = %if.end.216
  store i32 -1, i32* %retval
  br label %return

if.end.220:                                       ; preds = %if.end.216
  %56 = load %struct._object*, %struct._object** %m.addr, align 8
  %call221 = call i32 @PyModule_AddIntConstant(%struct._object* %56, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.598, i32 0, i32 0), i64 16)
  %tobool222 = icmp ne i32 %call221, 0
  br i1 %tobool222, label %if.then.223, label %if.end.224

if.then.223:                                      ; preds = %if.end.220
  store i32 -1, i32* %retval
  br label %return

if.end.224:                                       ; preds = %if.end.220
  %57 = load %struct._object*, %struct._object** %m.addr, align 8
  %call225 = call i32 @PyModule_AddIntConstant(%struct._object* %57, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.599, i32 0, i32 0), i64 64)
  %tobool226 = icmp ne i32 %call225, 0
  br i1 %tobool226, label %if.then.227, label %if.end.228

if.then.227:                                      ; preds = %if.end.224
  store i32 -1, i32* %retval
  br label %return

if.end.228:                                       ; preds = %if.end.224
  %58 = load %struct._object*, %struct._object** %m.addr, align 8
  %call229 = call i32 @PyModule_AddIntConstant(%struct._object* %58, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.600, i32 0, i32 0), i64 128)
  %tobool230 = icmp ne i32 %call229, 0
  br i1 %tobool230, label %if.then.231, label %if.end.232

if.then.231:                                      ; preds = %if.end.228
  store i32 -1, i32* %retval
  br label %return

if.end.232:                                       ; preds = %if.end.228
  %59 = load %struct._object*, %struct._object** %m.addr, align 8
  %call233 = call i32 @PyModule_AddIntConstant(%struct._object* %59, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.601, i32 0, i32 0), i64 256)
  %tobool234 = icmp ne i32 %call233, 0
  br i1 %tobool234, label %if.then.235, label %if.end.236

if.then.235:                                      ; preds = %if.end.232
  store i32 -1, i32* %retval
  br label %return

if.end.236:                                       ; preds = %if.end.232
  %60 = load %struct._object*, %struct._object** %m.addr, align 8
  %call237 = call i32 @PyModule_AddIntConstant(%struct._object* %60, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.602, i32 0, i32 0), i64 1024)
  %tobool238 = icmp ne i32 %call237, 0
  br i1 %tobool238, label %if.then.239, label %if.end.240

if.then.239:                                      ; preds = %if.end.236
  store i32 -1, i32* %retval
  br label %return

if.end.240:                                       ; preds = %if.end.236
  %61 = load %struct._object*, %struct._object** %m.addr, align 8
  %call241 = call i32 @PyModule_AddIntConstant(%struct._object* %61, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.603, i32 0, i32 0), i64 2048)
  %tobool242 = icmp ne i32 %call241, 0
  br i1 %tobool242, label %if.then.243, label %if.end.244

if.then.243:                                      ; preds = %if.end.240
  store i32 -1, i32* %retval
  br label %return

if.end.244:                                       ; preds = %if.end.240
  %62 = load %struct._object*, %struct._object** %m.addr, align 8
  %call245 = call i32 @PyModule_AddIntConstant(%struct._object* %62, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.604, i32 0, i32 0), i64 4096)
  %tobool246 = icmp ne i32 %call245, 0
  br i1 %tobool246, label %if.then.247, label %if.end.248

if.then.247:                                      ; preds = %if.end.244
  store i32 -1, i32* %retval
  br label %return

if.end.248:                                       ; preds = %if.end.244
  %63 = load %struct._object*, %struct._object** %m.addr, align 8
  %call249 = call i32 @PyModule_AddIntConstant(%struct._object* %63, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.605, i32 0, i32 0), i64 0)
  %tobool250 = icmp ne i32 %call249, 0
  br i1 %tobool250, label %if.then.251, label %if.end.252

if.then.251:                                      ; preds = %if.end.248
  store i32 -1, i32* %retval
  br label %return

if.end.252:                                       ; preds = %if.end.248
  %64 = load %struct._object*, %struct._object** %m.addr, align 8
  %call253 = call i32 @PyModule_AddIntConstant(%struct._object* %64, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.606, i32 0, i32 0), i64 2)
  %tobool254 = icmp ne i32 %call253, 0
  br i1 %tobool254, label %if.then.255, label %if.end.256

if.then.255:                                      ; preds = %if.end.252
  store i32 -1, i32* %retval
  br label %return

if.end.256:                                       ; preds = %if.end.252
  %65 = load %struct._object*, %struct._object** %m.addr, align 8
  %call257 = call i32 @PyModule_AddIntConstant(%struct._object* %65, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.607, i32 0, i32 0), i64 1)
  %tobool258 = icmp ne i32 %call257, 0
  br i1 %tobool258, label %if.then.259, label %if.end.260

if.then.259:                                      ; preds = %if.end.256
  store i32 -1, i32* %retval
  br label %return

if.end.260:                                       ; preds = %if.end.256
  %66 = load %struct._object*, %struct._object** %m.addr, align 8
  %call261 = call i32 @PyModule_AddIntConstant(%struct._object* %66, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.608, i32 0, i32 0), i64 5)
  %tobool262 = icmp ne i32 %call261, 0
  br i1 %tobool262, label %if.then.263, label %if.end.264

if.then.263:                                      ; preds = %if.end.260
  store i32 -1, i32* %retval
  br label %return

if.end.264:                                       ; preds = %if.end.260
  %67 = load %struct._object*, %struct._object** %m.addr, align 8
  %call265 = call i32 @PyModule_AddIntConstant(%struct._object* %67, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.609, i32 0, i32 0), i64 3)
  %tobool266 = icmp ne i32 %call265, 0
  br i1 %tobool266, label %if.then.267, label %if.end.268

if.then.267:                                      ; preds = %if.end.264
  store i32 -1, i32* %retval
  br label %return

if.end.268:                                       ; preds = %if.end.264
  %68 = load %struct._object*, %struct._object** %m.addr, align 8
  %call269 = call i32 @PyModule_AddIntConstant(%struct._object* %68, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.610, i32 0, i32 0), i64 4)
  %tobool270 = icmp ne i32 %call269, 0
  br i1 %tobool270, label %if.then.271, label %if.end.272

if.then.271:                                      ; preds = %if.end.268
  store i32 -1, i32* %retval
  br label %return

if.end.272:                                       ; preds = %if.end.268
  %69 = load %struct._object*, %struct._object** %m.addr, align 8
  %call273 = call i32 @PyModule_AddIntConstant(%struct._object* %69, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.611, i32 0, i32 0), i64 1)
  %tobool274 = icmp ne i32 %call273, 0
  br i1 %tobool274, label %if.then.275, label %if.end.276

if.then.275:                                      ; preds = %if.end.272
  store i32 -1, i32* %retval
  br label %return

if.end.276:                                       ; preds = %if.end.272
  %70 = load %struct._object*, %struct._object** %m.addr, align 8
  %call277 = call i32 @PyModule_AddIntConstant(%struct._object* %70, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.612, i32 0, i32 0), i64 2)
  %tobool278 = icmp ne i32 %call277, 0
  br i1 %tobool278, label %if.then.279, label %if.end.280

if.then.279:                                      ; preds = %if.end.276
  store i32 -1, i32* %retval
  br label %return

if.end.280:                                       ; preds = %if.end.276
  %71 = load %struct._object*, %struct._object** %m.addr, align 8
  %call281 = call i32 @PyModule_AddIntConstant(%struct._object* %71, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.613, i32 0, i32 0), i64 0)
  %tobool282 = icmp ne i32 %call281, 0
  br i1 %tobool282, label %if.then.283, label %if.end.284

if.then.283:                                      ; preds = %if.end.280
  store i32 -1, i32* %retval
  br label %return

if.end.284:                                       ; preds = %if.end.280
  %72 = load %struct._object*, %struct._object** %m.addr, align 8
  %call285 = call i32 @PyModule_AddIntConstant(%struct._object* %72, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.614, i32 0, i32 0), i64 4)
  %tobool286 = icmp ne i32 %call285, 0
  br i1 %tobool286, label %if.then.287, label %if.end.288

if.then.287:                                      ; preds = %if.end.284
  store i32 -1, i32* %retval
  br label %return

if.end.288:                                       ; preds = %if.end.284
  %73 = load %struct._object*, %struct._object** %m.addr, align 8
  %call289 = call i32 @PyModule_AddIntConstant(%struct._object* %73, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.615, i32 0, i32 0), i64 16777216)
  %tobool290 = icmp ne i32 %call289, 0
  br i1 %tobool290, label %if.then.291, label %if.end.292

if.then.291:                                      ; preds = %if.end.288
  store i32 -1, i32* %retval
  br label %return

if.end.292:                                       ; preds = %if.end.288
  %74 = load %struct._object*, %struct._object** %m.addr, align 8
  %call293 = call i32 @PyModule_AddIntConstant(%struct._object* %74, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.616, i32 0, i32 0), i64 2)
  %tobool294 = icmp ne i32 %call293, 0
  br i1 %tobool294, label %if.then.295, label %if.end.296

if.then.295:                                      ; preds = %if.end.292
  store i32 -1, i32* %retval
  br label %return

if.end.296:                                       ; preds = %if.end.292
  %75 = load %struct._object*, %struct._object** %m.addr, align 8
  %call297 = call i32 @PyModule_AddIntConstant(%struct._object* %75, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.617, i32 0, i32 0), i64 1)
  %tobool298 = icmp ne i32 %call297, 0
  br i1 %tobool298, label %if.then.299, label %if.end.300

if.then.299:                                      ; preds = %if.end.296
  store i32 -1, i32* %retval
  br label %return

if.end.300:                                       ; preds = %if.end.296
  %76 = load %struct._object*, %struct._object** %m.addr, align 8
  %call301 = call i32 @PyModule_AddIntConstant(%struct._object* %76, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.618, i32 0, i32 0), i64 3)
  %tobool302 = icmp ne i32 %call301, 0
  br i1 %tobool302, label %if.then.303, label %if.end.304

if.then.303:                                      ; preds = %if.end.300
  store i32 -1, i32* %retval
  br label %return

if.end.304:                                       ; preds = %if.end.300
  %77 = load %struct._object*, %struct._object** %m.addr, align 8
  %call305 = call i32 @PyModule_AddIntConstant(%struct._object* %77, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.619, i32 0, i32 0), i64 4)
  %tobool306 = icmp ne i32 %call305, 0
  br i1 %tobool306, label %if.then.307, label %if.end.308

if.then.307:                                      ; preds = %if.end.304
  store i32 -1, i32* %retval
  br label %return

if.end.308:                                       ; preds = %if.end.304
  %78 = load %struct._object*, %struct._object** %m.addr, align 8
  %call309 = call i32 @PyModule_AddIntConstant(%struct._object* %78, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.620, i32 0, i32 0), i64 6)
  %tobool310 = icmp ne i32 %call309, 0
  br i1 %tobool310, label %if.then.311, label %if.end.312

if.then.311:                                      ; preds = %if.end.308
  store i32 -1, i32* %retval
  br label %return

if.end.312:                                       ; preds = %if.end.308
  %79 = load %struct._object*, %struct._object** %m.addr, align 8
  %call313 = call i32 @PyModule_AddIntConstant(%struct._object* %79, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.621, i32 0, i32 0), i64 1)
  %tobool314 = icmp ne i32 %call313, 0
  br i1 %tobool314, label %if.then.315, label %if.end.316

if.then.315:                                      ; preds = %if.end.312
  store i32 -1, i32* %retval
  br label %return

if.end.316:                                       ; preds = %if.end.312
  %80 = load %struct._object*, %struct._object** %m.addr, align 8
  %call317 = call i32 @PyModule_AddIntConstant(%struct._object* %80, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.622, i32 0, i32 0), i64 2)
  %tobool318 = icmp ne i32 %call317, 0
  br i1 %tobool318, label %if.then.319, label %if.end.320

if.then.319:                                      ; preds = %if.end.316
  store i32 -1, i32* %retval
  br label %return

if.end.320:                                       ; preds = %if.end.316
  %81 = load %struct._object*, %struct._object** %m.addr, align 8
  %call321 = call i32 @PyModule_AddIntConstant(%struct._object* %81, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.623, i32 0, i32 0), i64 0)
  %tobool322 = icmp ne i32 %call321, 0
  br i1 %tobool322, label %if.then.323, label %if.end.324

if.then.323:                                      ; preds = %if.end.320
  store i32 -1, i32* %retval
  br label %return

if.end.324:                                       ; preds = %if.end.320
  %82 = load %struct._object*, %struct._object** %m.addr, align 8
  %call325 = call i32 @PyModule_AddIntConstant(%struct._object* %82, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.624, i32 0, i32 0), i64 3)
  %tobool326 = icmp ne i32 %call325, 0
  br i1 %tobool326, label %if.then.327, label %if.end.328

if.then.327:                                      ; preds = %if.end.324
  store i32 -1, i32* %retval
  br label %return

if.end.328:                                       ; preds = %if.end.324
  %83 = load %struct._object*, %struct._object** %m.addr, align 8
  %call329 = call i32 @PyModule_AddIntConstant(%struct._object* %83, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.625, i32 0, i32 0), i64 0)
  %tobool330 = icmp ne i32 %call329, 0
  br i1 %tobool330, label %if.then.331, label %if.end.332

if.then.331:                                      ; preds = %if.end.328
  store i32 -1, i32* %retval
  br label %return

if.end.332:                                       ; preds = %if.end.328
  %84 = load %struct._object*, %struct._object** %m.addr, align 8
  %call333 = call i32 @PyModule_AddIntConstant(%struct._object* %84, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.626, i32 0, i32 0), i64 1)
  %tobool334 = icmp ne i32 %call333, 0
  br i1 %tobool334, label %if.then.335, label %if.end.336

if.then.335:                                      ; preds = %if.end.332
  store i32 -1, i32* %retval
  br label %return

if.end.336:                                       ; preds = %if.end.332
  %85 = load %struct._object*, %struct._object** %m.addr, align 8
  %call337 = call i32 @PyModule_AddIntConstant(%struct._object* %85, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.627, i32 0, i32 0), i64 2)
  %tobool338 = icmp ne i32 %call337, 0
  br i1 %tobool338, label %if.then.339, label %if.end.340

if.then.339:                                      ; preds = %if.end.336
  store i32 -1, i32* %retval
  br label %return

if.end.340:                                       ; preds = %if.end.336
  %86 = load %struct._object*, %struct._object** %m.addr, align 8
  %call341 = call i32 @PyModule_AddIntConstant(%struct._object* %86, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.628, i32 0, i32 0), i64 3)
  %tobool342 = icmp ne i32 %call341, 0
  br i1 %tobool342, label %if.then.343, label %if.end.344

if.then.343:                                      ; preds = %if.end.340
  store i32 -1, i32* %retval
  br label %return

if.end.344:                                       ; preds = %if.end.340
  %87 = load %struct._object*, %struct._object** %m.addr, align 8
  %call345 = call i32 @PyModule_AddIntConstant(%struct._object* %87, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.629, i32 0, i32 0), i64 5)
  %tobool346 = icmp ne i32 %call345, 0
  br i1 %tobool346, label %if.then.347, label %if.end.348

if.then.347:                                      ; preds = %if.end.344
  store i32 -1, i32* %retval
  br label %return

if.end.348:                                       ; preds = %if.end.344
  %88 = load %struct._object*, %struct._object** %m.addr, align 8
  %call349 = call i32 @PyModule_AddIntConstant(%struct._object* %88, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.630, i32 0, i32 0), i64 1073741824)
  %tobool350 = icmp ne i32 %call349, 0
  br i1 %tobool350, label %if.then.351, label %if.end.352

if.then.351:                                      ; preds = %if.end.348
  store i32 -1, i32* %retval
  br label %return

if.end.352:                                       ; preds = %if.end.348
  %89 = load %struct._object*, %struct._object** %m.addr, align 8
  %call353 = call i32 @PyModule_AddIntConstant(%struct._object* %89, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.631, i32 0, i32 0), i64 1)
  %tobool354 = icmp ne i32 %call353, 0
  br i1 %tobool354, label %if.then.355, label %if.end.356

if.then.355:                                      ; preds = %if.end.352
  store i32 -1, i32* %retval
  br label %return

if.end.356:                                       ; preds = %if.end.352
  %90 = load %struct._object*, %struct._object** %m.addr, align 8
  %call357 = call i32 @PyModule_AddIntConstant(%struct._object* %90, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.632, i32 0, i32 0), i64 2)
  %tobool358 = icmp ne i32 %call357, 0
  br i1 %tobool358, label %if.then.359, label %if.end.360

if.then.359:                                      ; preds = %if.end.356
  store i32 -1, i32* %retval
  br label %return

if.end.360:                                       ; preds = %if.end.356
  %91 = load %struct._object*, %struct._object** %m.addr, align 8
  %call361 = call i32 @PyModule_AddIntConstant(%struct._object* %91, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.633, i32 0, i32 0), i64 65536)
  %tobool362 = icmp ne i32 %call361, 0
  br i1 %tobool362, label %if.then.363, label %if.end.364

if.then.363:                                      ; preds = %if.end.360
  store i32 -1, i32* %retval
  br label %return

if.end.364:                                       ; preds = %if.end.360
  %92 = load %struct._object*, %struct._object** %m.addr, align 8
  %call365 = call i32 @PyModule_AddIntConstant(%struct._object* %92, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.634, i32 0, i32 0), i64 1)
  %tobool366 = icmp ne i32 %call365, 0
  br i1 %tobool366, label %if.then.367, label %if.end.368

if.then.367:                                      ; preds = %if.end.364
  store i32 -1, i32* %retval
  br label %return

if.end.368:                                       ; preds = %if.end.364
  %93 = load %struct._object*, %struct._object** %m.addr, align 8
  %call369 = call i32 @PyModule_AddIntConstant(%struct._object* %93, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.635, i32 0, i32 0), i64 2)
  %tobool370 = icmp ne i32 %call369, 0
  br i1 %tobool370, label %if.then.371, label %if.end.372

if.then.371:                                      ; preds = %if.end.368
  store i32 -1, i32* %retval
  br label %return

if.end.372:                                       ; preds = %if.end.368
  %94 = load %struct._object*, %struct._object** %m.addr, align 8
  %call373 = call i32 @PyModule_AddIntConstant(%struct._object* %94, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.636, i32 0, i32 0), i64 256)
  %tobool374 = icmp ne i32 %call373, 0
  br i1 %tobool374, label %if.then.375, label %if.end.376

if.then.375:                                      ; preds = %if.end.372
  store i32 -1, i32* %retval
  br label %return

if.end.376:                                       ; preds = %if.end.372
  %95 = load %struct._object*, %struct._object** %m.addr, align 8
  %call377 = call i32 @PyModule_AddIntConstant(%struct._object* %95, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.637, i32 0, i32 0), i64 0)
  %tobool378 = icmp ne i32 %call377, 0
  br i1 %tobool378, label %if.then.379, label %if.end.380

if.then.379:                                      ; preds = %if.end.376
  store i32 -1, i32* %retval
  br label %return

if.end.380:                                       ; preds = %if.end.376
  %96 = load %struct._object*, %struct._object** %m.addr, align 8
  %call381 = call i32 @PyModule_AddIntConstant(%struct._object* %96, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.638, i32 0, i32 0), i64 4096)
  %tobool382 = icmp ne i32 %call381, 0
  br i1 %tobool382, label %if.then.383, label %if.end.384

if.then.383:                                      ; preds = %if.end.380
  store i32 -1, i32* %retval
  br label %return

if.end.384:                                       ; preds = %if.end.380
  %97 = load %struct._object*, %struct._object** %m.addr, align 8
  %call385 = call i32 @PyModule_AddIntConstant(%struct._object* %97, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.639, i32 0, i32 0), i64 4)
  %tobool386 = icmp ne i32 %call385, 0
  br i1 %tobool386, label %if.then.387, label %if.end.388

if.then.387:                                      ; preds = %if.end.384
  store i32 -1, i32* %retval
  br label %return

if.end.388:                                       ; preds = %if.end.384
  %98 = load %struct._object*, %struct._object** %m.addr, align 8
  %call389 = call i32 @PyModule_AddIntConstant(%struct._object* %98, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.640, i32 0, i32 0), i64 8)
  %tobool390 = icmp ne i32 %call389, 0
  br i1 %tobool390, label %if.then.391, label %if.end.392

if.then.391:                                      ; preds = %if.end.388
  store i32 -1, i32* %retval
  br label %return

if.end.392:                                       ; preds = %if.end.388
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.392, %if.then.391, %if.then.387, %if.then.383, %if.then.379, %if.then.375, %if.then.371, %if.then.367, %if.then.363, %if.then.359, %if.then.355, %if.then.351, %if.then.347, %if.then.343, %if.then.339, %if.then.335, %if.then.331, %if.then.327, %if.then.323, %if.then.319, %if.then.315, %if.then.311, %if.then.307, %if.then.303, %if.then.299, %if.then.295, %if.then.291, %if.then.287, %if.then.283, %if.then.279, %if.then.275, %if.then.271, %if.then.267, %if.then.263, %if.then.259, %if.then.255, %if.then.251, %if.then.247, %if.then.243, %if.then.239, %if.then.235, %if.then.231, %if.then.227, %if.then.223, %if.then.219, %if.then.215, %if.then.211, %if.then.207, %if.then.203, %if.then.199, %if.then.195, %if.then.191, %if.then.187, %if.then.183, %if.then.179, %if.then.175, %if.then.171, %if.then.167, %if.then.163, %if.then.159, %if.then.155, %if.then.151, %if.then.147, %if.then.143, %if.then.139, %if.then.135, %if.then.131, %if.then.127, %if.then.123, %if.then.119, %if.then.115, %if.then.111, %if.then.107, %if.then.103, %if.then.99, %if.then.95, %if.then.91, %if.then.87, %if.then.83, %if.then.79, %if.then.75, %if.then.71, %if.then.67, %if.then.63, %if.then.59, %if.then.55, %if.then.51, %if.then.47, %if.then.43, %if.then.39, %if.then.35, %if.then.31, %if.then.27, %if.then.23, %if.then.19, %if.then.15, %if.then.11, %if.then.7, %if.then.3, %if.then
  %99 = load i32, i32* %retval
  ret i32 %99
}

; Function Attrs: nounwind uwtable
define internal i32 @setup_confname_tables(%struct._object* %module) #0 {
entry:
  %retval = alloca i32, align 4
  %module.addr = alloca %struct._object*, align 8
  store %struct._object* %module, %struct._object** %module.addr, align 8
  %0 = load %struct._object*, %struct._object** %module.addr, align 8
  %call = call i32 @setup_confname_table(%struct.constdef* getelementptr inbounds ([20 x %struct.constdef], [20 x %struct.constdef]* @posix_constants_pathconf, i32 0, i32 0), i64 20, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.641, i32 0, i32 0), %struct._object* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %module.addr, align 8
  %call1 = call i32 @setup_confname_table(%struct.constdef* getelementptr inbounds ([27 x %struct.constdef], [27 x %struct.constdef]* @posix_constants_confstr, i32 0, i32 0), i64 27, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.642, i32 0, i32 0), %struct._object* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  store i32 -1, i32* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load %struct._object*, %struct._object** %module.addr, align 8
  %call5 = call i32 @setup_confname_table(%struct.constdef* getelementptr inbounds ([134 x %struct.constdef], [134 x %struct.constdef]* @posix_constants_sysconf, i32 0, i32 0), i64 134, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.643, i32 0, i32 0), %struct._object* %2)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.4
  store i32 -1, i32* %retval
  br label %return

if.end.8:                                         ; preds = %if.end.4
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.7, %if.then.3, %if.then
  %3 = load i32, i32* %retval
  ret i32 %3
}

declare %struct._object* @PyDict_New() #1

declare i32 @PyStructSequence_InitType2(%struct._typeobject*, %struct.PyStructSequence_Desc*) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @statresult_new(%struct._typeobject* %type, %struct._object* %args, %struct._object* %kwds) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %type.addr = alloca %struct._typeobject*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwds.addr = alloca %struct._object*, align 8
  %result = alloca %struct.PyTupleObject*, align 8
  %i = alloca i32, align 4
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._typeobject* %type, %struct._typeobject** %type.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwds, %struct._object** %kwds.addr, align 8
  %0 = load %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)*, %struct._object* (%struct._typeobject*, %struct._object*, %struct._object*)** @structseq_new, align 8
  %1 = load %struct._typeobject*, %struct._typeobject** %type.addr, align 8
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load %struct._object*, %struct._object** %kwds.addr, align 8
  %call = call %struct._object* %0(%struct._typeobject* %1, %struct._object* %2, %struct._object* %3)
  %4 = bitcast %struct._object* %call to %struct.PyTupleObject*
  store %struct.PyTupleObject* %4, %struct.PyTupleObject** %result, align 8
  %5 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %tobool = icmp ne %struct.PyTupleObject* %5, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 7, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %cmp = icmp sle i32 %6, 9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %i, align 4
  %add = add i32 %7, 3
  %idxprom = sext i32 %add to i64
  %8 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %8, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 %idxprom
  %9 = load %struct._object*, %struct._object** %arrayidx, align 8
  %cmp1 = icmp eq %struct._object* %9, @_Py_NoneStruct
  br i1 %cmp1, label %if.then.2, label %if.end.17

if.then.2:                                        ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then.2
  store %struct._object* @_Py_NoneStruct, %struct._object** %_py_decref_tmp, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %10, i32 0, i32 0
  %11 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %11, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp3 = icmp ne i64 %dec, 0
  br i1 %cmp3, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %do.body
  br label %if.end.5

if.else:                                          ; preds = %do.body
  %12 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %12, i32 0, i32 1
  %13 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %13, i32 0, i32 4
  %14 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %15 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %14(%struct._object* %15)
  br label %if.end.5

if.end.5:                                         ; preds = %if.else, %if.then.4
  br label %do.end

do.end:                                           ; preds = %if.end.5
  %16 = load i32, i32* %i, align 4
  %idxprom6 = sext i32 %16 to i64
  %17 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %ob_item7 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %17, i32 0, i32 1
  %arrayidx8 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item7, i32 0, i64 %idxprom6
  %18 = load %struct._object*, %struct._object** %arrayidx8, align 8
  %ob_refcnt9 = getelementptr inbounds %struct._object, %struct._object* %18, i32 0, i32 0
  %19 = load i64, i64* %ob_refcnt9, align 8
  %inc = add i64 %19, 1
  store i64 %inc, i64* %ob_refcnt9, align 8
  %20 = load i32, i32* %i, align 4
  %idxprom10 = sext i32 %20 to i64
  %21 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %ob_item11 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %21, i32 0, i32 1
  %arrayidx12 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item11, i32 0, i64 %idxprom10
  %22 = load %struct._object*, %struct._object** %arrayidx12, align 8
  %23 = load i32, i32* %i, align 4
  %add13 = add i32 %23, 3
  %idxprom14 = sext i32 %add13 to i64
  %24 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %ob_item15 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx16 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item15, i32 0, i64 %idxprom14
  store %struct._object* %22, %struct._object** %arrayidx16, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %do.end, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.17
  %25 = load i32, i32* %i, align 4
  %inc18 = add i32 %25, 1
  store i32 %inc18, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = load %struct.PyTupleObject*, %struct.PyTupleObject** %result, align 8
  %27 = bitcast %struct.PyTupleObject* %26 to %struct._object*
  store %struct._object* %27, %struct._object** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %28 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %28
}

; Function Attrs: nounwind
declare i64 @sysconf(i32) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @sched_param_new(%struct._typeobject* %type, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %type.addr = alloca %struct._typeobject*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %res = alloca %struct._object*, align 8
  %priority = alloca %struct._object*, align 8
  store %struct._typeobject* %type, %struct._typeobject** %type.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %1 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %0, %struct._object* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.695, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @sched_param_new.kwlist, i32 0, i32 0), %struct._object** %priority)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._typeobject*, %struct._typeobject** %type.addr, align 8
  %call1 = call %struct._object* @PyStructSequence_New(%struct._typeobject* %2)
  store %struct._object* %call1, %struct._object** %res, align 8
  %3 = load %struct._object*, %struct._object** %res, align 8
  %tobool2 = icmp ne %struct._object* %3, null
  br i1 %tobool2, label %if.end.4, label %if.then.3

if.then.3:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %4 = load %struct._object*, %struct._object** %priority, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %4, i32 0, i32 0
  %5 = load i64, i64* %ob_refcnt, align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* %ob_refcnt, align 8
  %6 = load %struct._object*, %struct._object** %priority, align 8
  %7 = load %struct._object*, %struct._object** %res, align 8
  %8 = bitcast %struct._object* %7 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %8, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %6, %struct._object** %arrayidx, align 8
  %9 = load %struct._object*, %struct._object** %res, align 8
  store %struct._object* %9, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.3, %if.then
  %10 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %10
}

; Function Attrs: nounwind uwtable
define internal i32 @fd_specified(i8* %function_name, i32 %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %fd.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %function_name.addr, align 8
  call void @argument_unavailable_error(i8* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.289, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @follow_symlinks_specified(i8* %function_name, i32 %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %follow_symlinks.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i8*, i8** %function_name.addr, align 8
  call void @argument_unavailable_error(i8* %1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load i32, i32* %retval
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_and_follow_symlinks_invalid(i8* %function_name, i32 %dir_fd, i32 %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load i32, i32* %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %3 = load i8*, i8** %function_name.addr, align 8
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.721, i32 0, i32 0), i8* %3)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_converter(%struct._object* %o, i8* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct._object*, align 8
  %p.addr = alloca i8*, align 8
  store %struct._object* %o, %struct._object** %o.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct._object*, %struct._object** %o.addr, align 8
  %cmp = icmp eq %struct._object* %0, @_Py_NoneStruct
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %p.addr, align 8
  %2 = bitcast i8* %1 to i32*
  store i32 -100, i32* %2, align 4
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct._object*, %struct._object** %o.addr, align 8
  %4 = load i8*, i8** %p.addr, align 8
  %5 = bitcast i8* %4 to i32*
  %call = call i32 @_fd_converter(%struct._object* %3, i32* %5, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.722, i32 0, i32 0))
  store i32 %call, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i32, i32* %retval
  ret i32 %6
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_unavailable(%struct._object* %o, i8* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct._object*, align 8
  %p.addr = alloca i8*, align 8
  %dir_fd = alloca i32, align 4
  store %struct._object* %o, %struct._object** %o.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct._object*, %struct._object** %o.addr, align 8
  %1 = bitcast i32* %dir_fd to i8*
  %call = call i32 @dir_fd_converter(%struct._object* %0, i8* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %2, -100
  br i1 %cmp, label %if.then.1, label %if.end.2

if.then.1:                                        ; preds = %if.end
  call void @argument_unavailable_error(i8* null, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.2:                                         ; preds = %if.end
  %3 = load i32, i32* %dir_fd, align 4
  %4 = load i8*, i8** %p.addr, align 8
  %5 = bitcast i8* %4 to i32*
  store i32 %3, i32* %5, align 4
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.2, %if.then.1, %if.then
  %6 = load i32, i32* %retval
  ret i32 %6
}

declare %struct._object* @PyList_New(i64) #1

declare %struct._object* @PyUnicode_DecodeASCII(i8*, i64, i8*) #1

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #3

declare i32 @PyList_Append(%struct._object*, %struct._object*) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @os_stat(%struct.PyModuleDef* %module, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %return_value = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = bitcast i8* %0 to %struct.path_t*
  %2 = getelementptr %struct.path_t, %struct.path_t* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), i8** %2
  %3 = getelementptr %struct.path_t, %struct.path_t* %1, i32 0, i32 3
  store i32 1, i32* %3
  store i32 -100, i32* %dir_fd, align 4
  store i32 1, i32* %follow_symlinks, align 4
  %4 = load %struct._object*, %struct._object** %args.addr, align 8
  %5 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %4, %struct._object* %5, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.172, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @os_stat._keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %6 = load %struct.PyModuleDef*, %struct.PyModuleDef** %module.addr, align 8
  %7 = load i32, i32* %dir_fd, align 4
  %8 = load i32, i32* %follow_symlinks, align 4
  %call1 = call %struct._object* @os_stat_impl(%struct.PyModuleDef* %6, %struct.path_t* %path, i32 %7, i32 %8)
  store %struct._object* %call1, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  call void @path_cleanup(%struct.path_t* %path)
  %9 = load %struct._object*, %struct._object** %return_value, align 8
  ret %struct._object* %9
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @os_access(%struct.PyModuleDef* %module, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %return_value = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %effective_ids = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = bitcast i8* %0 to %struct.path_t*
  %2 = getelementptr %struct.path_t, %struct.path_t* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.26, i32 0, i32 0), i8** %2
  %3 = getelementptr %struct.path_t, %struct.path_t* %1, i32 0, i32 3
  store i32 1, i32* %3
  store i32 -100, i32* %dir_fd, align 4
  store i32 0, i32* %effective_ids, align 4
  store i32 1, i32* %follow_symlinks, align 4
  %4 = load %struct._object*, %struct._object** %args.addr, align 8
  %5 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %4, %struct._object* %5, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.186, i32 0, i32 0), i8** getelementptr inbounds ([6 x i8*], [6 x i8*]* @os_access._keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %mode, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd, i32* %effective_ids, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %6 = load %struct.PyModuleDef*, %struct.PyModuleDef** %module.addr, align 8
  %7 = load i32, i32* %mode, align 4
  %8 = load i32, i32* %dir_fd, align 4
  %9 = load i32, i32* %effective_ids, align 4
  %10 = load i32, i32* %follow_symlinks, align 4
  %call1 = call %struct._object* @os_access_impl(%struct.PyModuleDef* %6, %struct.path_t* %path, i32 %7, i32 %8, i32 %9, i32 %10)
  store %struct._object* %call1, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end, %if.then
  call void @path_cleanup(%struct.path_t* %path)
  %11 = load %struct._object*, %struct._object** %return_value, align 8
  ret %struct._object* %11
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @os_ttyname(%struct.PyModuleDef* %module, %struct._object* %args) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %args.addr = alloca %struct._object*, align 8
  %return_value = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %_return_value = alloca i8*, align 8
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.187, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %1 = load %struct.PyModuleDef*, %struct.PyModuleDef** %module.addr, align 8
  %2 = load i32, i32* %fd, align 4
  %call1 = call i8* @os_ttyname_impl(%struct.PyModuleDef* %1, i32 %2)
  store i8* %call1, i8** %_return_value, align 8
  %3 = load i8*, i8** %_return_value, align 8
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  br label %exit

if.end.3:                                         ; preds = %if.end
  %4 = load i8*, i8** %_return_value, align 8
  %call4 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %4)
  store %struct._object* %call4, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.3, %if.then.2, %if.then
  %5 = load %struct._object*, %struct._object** %return_value, align 8
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_chdir(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.28, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.188, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @posix_chdir.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd3, align 4
  %call4 = call i32 @fchdir(i32 %4) #4
  store i32 %call4, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %call5 = call i32 @chdir(i8* %5) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i32, i32* %result, align 4
  %tobool7 = icmp ne i32 %7, 0
  br i1 %tobool7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %8 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %8, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %9 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %9, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %10 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %10
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_chmod(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %fchmodat_nofollow_unsupported = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  store i32 0, i32* %fchmodat_nofollow_unsupported, align 4
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.189, i32 0, i32 0), i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @posix_chmod.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %mode, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd3, align 4
  %5 = load i32, i32* %mode, align 4
  %call4 = call i32 @fchmod(i32 %4, i32 %5) #4
  store i32 %call4, i32* %result, align 4
  br label %if.end.21

if.else:                                          ; preds = %if.end
  %6 = load i32, i32* %dir_fd, align 4
  %cmp5 = icmp ne i32 %6, -100
  br i1 %cmp5, label %if.then.7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %7 = load i32, i32* %follow_symlinks, align 4
  %tobool6 = icmp ne i32 %7, 0
  br i1 %tobool6, label %if.else.17, label %if.then.7

if.then.7:                                        ; preds = %lor.lhs.false, %if.else
  %8 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %9 = load i8*, i8** %narrow, align 8
  %10 = load i32, i32* %mode, align 4
  %11 = load i32, i32* %follow_symlinks, align 4
  %tobool8 = icmp ne i32 %11, 0
  %cond = select i1 %tobool8, i32 0, i32 256
  %call9 = call i32 @fchmodat(i32 %8, i8* %9, i32 %10, i32 %cond) #4
  store i32 %call9, i32* %result, align 4
  %12 = load i32, i32* %result, align 4
  %tobool10 = icmp ne i32 %12, 0
  br i1 %tobool10, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %if.then.7
  %call11 = call i32* @__errno_location() #9
  %13 = load i32, i32* %call11, align 4
  %cmp12 = icmp eq i32 %13, 95
  br i1 %cmp12, label %land.rhs, label %lor.lhs.false.13

lor.lhs.false.13:                                 ; preds = %land.lhs.true
  %call14 = call i32* @__errno_location() #9
  %14 = load i32, i32* %call14, align 4
  %cmp15 = icmp eq i32 %14, 95
  br i1 %cmp15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.lhs.false.13, %land.lhs.true
  %15 = load i32, i32* %follow_symlinks, align 4
  %tobool16 = icmp ne i32 %15, 0
  %lnot = xor i1 %tobool16, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.lhs.false.13, %if.then.7
  %16 = phi i1 [ false, %lor.lhs.false.13 ], [ false, %if.then.7 ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %16 to i32
  store i32 %land.ext, i32* %fchmodat_nofollow_unsupported, align 4
  br label %if.end.20

if.else.17:                                       ; preds = %lor.lhs.false
  %narrow18 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %17 = load i8*, i8** %narrow18, align 8
  %18 = load i32, i32* %mode, align 4
  %call19 = call i32 @chmod(i8* %17, i32 %18) #4
  store i32 %call19, i32* %result, align 4
  br label %if.end.20

if.end.20:                                        ; preds = %if.else.17, %land.end
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %if.then.2
  %19 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %19)
  %20 = load i32, i32* %result, align 4
  %tobool22 = icmp ne i32 %20, 0
  br i1 %tobool22, label %if.then.23, label %if.end.35

if.then.23:                                       ; preds = %if.end.21
  %21 = load i32, i32* %fchmodat_nofollow_unsupported, align 4
  %tobool24 = icmp ne i32 %21, 0
  br i1 %tobool24, label %if.then.25, label %if.else.32

if.then.25:                                       ; preds = %if.then.23
  %22 = load i32, i32* %dir_fd, align 4
  %cmp26 = icmp ne i32 %22, -100
  br i1 %cmp26, label %if.then.27, label %if.else.29

if.then.27:                                       ; preds = %if.then.25
  %23 = load i32, i32* %dir_fd, align 4
  %24 = load i32, i32* %follow_symlinks, align 4
  %call28 = call i32 @dir_fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22, i32 0, i32 0), i32 %23, i32 %24)
  br label %if.end.31

if.else.29:                                       ; preds = %if.then.25
  %25 = load i32, i32* %follow_symlinks, align 4
  %call30 = call i32 @follow_symlinks_specified(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.22, i32 0, i32 0), i32 %25)
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.27
  br label %if.end.34

if.else.32:                                       ; preds = %if.then.23
  %call33 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call33, %struct._object** %return_value, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.else.32, %if.end.31
  br label %exit

if.end.35:                                        ; preds = %if.end.21
  %26 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %26, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.35, %if.end.34
  call void @path_cleanup(%struct.path_t* %path)
  %27 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %27, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %28 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %28
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fchmod(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %mode = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.190, i32 0, i32 0), i32* %fd, i32* %mode)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %mode, align 4
  %call2 = call i32 @fchmod(i32 %1, i32 %2) #4
  store i32 %call2, i32* %res, align 4
  %3 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  %4 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_chown(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.193, i32 0, i32 0), i8** getelementptr inbounds ([6 x i8*], [6 x i8*]* @posix_chown.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %uid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %gid, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %dir_fd, align 4
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd, align 4
  %call1 = call i32 @dir_fd_and_fd_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30, i32 0, i32 0), i32 %3, i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %5 = load i32, i32* %fd3, align 4
  %6 = load i32, i32* %follow_symlinks, align 4
  %call4 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.30, i32 0, i32 0), i32 %5, i32 %6)
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %lor.lhs.false, %if.end
  br label %exit

if.end.7:                                         ; preds = %lor.lhs.false
  %call8 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call8, %struct._ts** %_save, align 8
  %fd9 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %7 = load i32, i32* %fd9, align 4
  %cmp = icmp ne i32 %7, -1
  br i1 %cmp, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %if.end.7
  %fd11 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %8 = load i32, i32* %fd11, align 4
  %9 = load i32, i32* %uid, align 4
  %10 = load i32, i32* %gid, align 4
  %call12 = call i32 @fchown(i32 %8, i32 %9, i32 %10) #4
  store i32 %call12, i32* %result, align 4
  br label %if.end.30

if.else:                                          ; preds = %if.end.7
  %11 = load i32, i32* %follow_symlinks, align 4
  %tobool13 = icmp ne i32 %11, 0
  br i1 %tobool13, label %if.else.17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %12 = load i32, i32* %dir_fd, align 4
  %cmp14 = icmp eq i32 %12, -100
  br i1 %cmp14, label %if.then.15, label %if.else.17

if.then.15:                                       ; preds = %land.lhs.true
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %13 = load i8*, i8** %narrow, align 8
  %14 = load i32, i32* %uid, align 4
  %15 = load i32, i32* %gid, align 4
  %call16 = call i32 @lchown(i8* %13, i32 %14, i32 %15) #4
  store i32 %call16, i32* %result, align 4
  br label %if.end.29

if.else.17:                                       ; preds = %land.lhs.true, %if.else
  %16 = load i32, i32* %dir_fd, align 4
  %cmp18 = icmp ne i32 %16, -100
  br i1 %cmp18, label %if.then.21, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.else.17
  %17 = load i32, i32* %follow_symlinks, align 4
  %tobool20 = icmp ne i32 %17, 0
  br i1 %tobool20, label %if.else.25, label %if.then.21

if.then.21:                                       ; preds = %lor.lhs.false.19, %if.else.17
  %18 = load i32, i32* %dir_fd, align 4
  %narrow22 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %19 = load i8*, i8** %narrow22, align 8
  %20 = load i32, i32* %uid, align 4
  %21 = load i32, i32* %gid, align 4
  %22 = load i32, i32* %follow_symlinks, align 4
  %tobool23 = icmp ne i32 %22, 0
  %cond = select i1 %tobool23, i32 0, i32 256
  %call24 = call i32 @fchownat(i32 %18, i8* %19, i32 %20, i32 %21, i32 %cond) #4
  store i32 %call24, i32* %result, align 4
  br label %if.end.28

if.else.25:                                       ; preds = %lor.lhs.false.19
  %narrow26 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %23 = load i8*, i8** %narrow26, align 8
  %24 = load i32, i32* %uid, align 4
  %25 = load i32, i32* %gid, align 4
  %call27 = call i32 @chown(i8* %23, i32 %24, i32 %25) #4
  store i32 %call27, i32* %result, align 4
  br label %if.end.28

if.end.28:                                        ; preds = %if.else.25, %if.then.21
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %if.then.15
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %if.then.10
  %26 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %26)
  %27 = load i32, i32* %result, align 4
  %tobool31 = icmp ne i32 %27, 0
  br i1 %tobool31, label %if.then.32, label %if.end.34

if.then.32:                                       ; preds = %if.end.30
  %call33 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call33, %struct._object** %return_value, align 8
  br label %exit

if.end.34:                                        ; preds = %if.end.30
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %28 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %28, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.34, %if.then.32, %if.then.6
  call void @path_cleanup(%struct.path_t* %path)
  %29 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %29, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %30 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %30
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fchown(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.194, i32 0, i32 0), i32* %fd, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %uid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %gid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %uid, align 4
  %3 = load i32, i32* %gid, align 4
  %call2 = call i32 @fchown(i32 %1, i32 %2, i32 %3) #4
  store i32 %call2, i32* %res, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %6 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %6, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %7 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %7
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_lchown(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.32, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.195, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %uid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %gid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %2 = load i8*, i8** %narrow, align 8
  %3 = load i32, i32* %uid, align 4
  %4 = load i32, i32* %gid, align 4
  %call2 = call i32 @lchown(i8* %2, i32 %3, i32 %4) #4
  store i32 %call2, i32* %res, align 4
  %5 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %5)
  %6 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %6, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @path_error(%struct.path_t* %path)
  call void @path_cleanup(%struct.path_t* %path)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  call void @path_cleanup(%struct.path_t* %path)
  %7 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_chroot(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call %struct._object* @posix_1str(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.33, i32 0, i32 0), %struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.196, i32 0, i32 0), i32 (i8*)* @chroot)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_ctermid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %ret = alloca i8*, align 8
  %buffer = alloca [9 x i8], align 1
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %arraydecay = getelementptr inbounds [9 x i8], [9 x i8]* %buffer, i32 0, i32 0
  %call = call i8* @ctermid(i8* %arraydecay) #4
  store i8* %call, i8** %ret, align 8
  %0 = load i8*, i8** %ret, align 8
  %cmp = icmp eq i8* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %arraydecay2 = getelementptr inbounds [9 x i8], [9 x i8]* %buffer, i32 0, i32 0
  %call3 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay2)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getcwd_unicode(%struct._object* %self) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  %call = call %struct._object* @posix_getcwd(i32 0)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getcwd_bytes(%struct._object* %self) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  %call = call %struct._object* @posix_getcwd(i32 1)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_link(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %src_dir_fd = alloca i32, align 4
  %dst_dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %src_dir_fd, align 4
  store i32 -100, i32* %dst_dir_fd, align 4
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %src to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = bitcast %struct.path_t* %dst to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i8** %function_name, align 8
  %function_name1 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.37, i32 0, i32 0), i8** %function_name1, align 8
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %2, %struct._object* %3, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.201, i32 0, i32 0), i8** getelementptr inbounds ([6 x i8*], [6 x i8*]* @posix_link.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %src, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %dst, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %src_dir_fd, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dst_dir_fd, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %4 = load i8*, i8** %narrow, align 8
  %tobool2 = icmp ne i8* %4, null
  br i1 %tobool2, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %wide = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 4
  %5 = load i32*, i32** %wide, align 8
  %tobool3 = icmp ne i32* %5, null
  br i1 %tobool3, label %if.then.9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %wide4 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 4
  %6 = load i32*, i32** %wide4, align 8
  %tobool5 = icmp ne i32* %6, null
  br i1 %tobool5, label %land.lhs.true.6, label %if.end.10

land.lhs.true.6:                                  ; preds = %lor.lhs.false
  %narrow7 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %7 = load i8*, i8** %narrow7, align 8
  %tobool8 = icmp ne i8* %7, null
  br i1 %tobool8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %land.lhs.true.6, %land.lhs.true
  %8 = load %struct._object*, %struct._object** @PyExc_NotImplementedError, align 8
  call void @PyErr_SetString(%struct._object* %8, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.202, i32 0, i32 0))
  br label %exit

if.end.10:                                        ; preds = %land.lhs.true.6, %lor.lhs.false
  %call11 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call11, %struct._ts** %_save, align 8
  %9 = load i32, i32* %src_dir_fd, align 4
  %cmp = icmp ne i32 %9, -100
  br i1 %cmp, label %if.then.16, label %lor.lhs.false.12

lor.lhs.false.12:                                 ; preds = %if.end.10
  %10 = load i32, i32* %dst_dir_fd, align 4
  %cmp13 = icmp ne i32 %10, -100
  br i1 %cmp13, label %if.then.16, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false.12
  %11 = load i32, i32* %follow_symlinks, align 4
  %tobool15 = icmp ne i32 %11, 0
  br i1 %tobool15, label %if.else, label %if.then.16

if.then.16:                                       ; preds = %lor.lhs.false.14, %lor.lhs.false.12, %if.end.10
  %12 = load i32, i32* %src_dir_fd, align 4
  %narrow17 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %13 = load i8*, i8** %narrow17, align 8
  %14 = load i32, i32* %dst_dir_fd, align 4
  %narrow18 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %15 = load i8*, i8** %narrow18, align 8
  %16 = load i32, i32* %follow_symlinks, align 4
  %tobool19 = icmp ne i32 %16, 0
  %cond = select i1 %tobool19, i32 1024, i32 0
  %call20 = call i32 @linkat(i32 %12, i8* %13, i32 %14, i8* %15, i32 %cond) #4
  store i32 %call20, i32* %result, align 4
  br label %if.end.24

if.else:                                          ; preds = %lor.lhs.false.14
  %narrow21 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %17 = load i8*, i8** %narrow21, align 8
  %narrow22 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %18 = load i8*, i8** %narrow22, align 8
  %call23 = call i32 @link(i8* %17, i8* %18) #4
  store i32 %call23, i32* %result, align 4
  br label %if.end.24

if.end.24:                                        ; preds = %if.else, %if.then.16
  %19 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %19)
  %20 = load i32, i32* %result, align 4
  %tobool25 = icmp ne i32 %20, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.end.24
  %call27 = call %struct._object* @path_error2(%struct.path_t* %src, %struct.path_t* %dst)
  store %struct._object* %call27, %struct._object** %return_value, align 8
  br label %exit

if.end.28:                                        ; preds = %if.end.24
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %21 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %21, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.28, %if.then.26, %if.then.9
  call void @path_cleanup(%struct.path_t* %src)
  call void @path_cleanup(%struct.path_t* %dst)
  %22 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %22, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %23 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %23
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_listdir(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %list = alloca %struct._object*, align 8
  %return_value = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %list, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.38, i32 0, i32 0), i8** %function_name, align 8
  %nullable = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 2
  store i32 1, i32* %nullable, align 4
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  store i32 -1, i32* %fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.203, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @posix_listdir.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct._object*, %struct._object** %list, align 8
  %call1 = call %struct._object* @_posix_listdir(%struct.path_t* %path, %struct._object* %3)
  store %struct._object* %call1, %struct._object** %return_value, align 8
  call void @path_cleanup(%struct.path_t* %path)
  %4 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_lstat(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store i32 0, i32* %follow_symlinks, align 4
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.39, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.205, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_lstat.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %dir_fd, align 4
  %4 = load i32, i32* %follow_symlinks, align 4
  %call1 = call %struct._object* @posix_do_stat(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.39, i32 0, i32 0), %struct.path_t* %path, i32 %3, i32 %4)
  store %struct._object* %call1, %struct._object** %return_value, align 8
  call void @path_cleanup(%struct.path_t* %path)
  %5 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_mkdir(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 511, i32* %mode, align 4
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.40, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.206, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_mkdir.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %mode, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %6 = load i32, i32* %mode, align 4
  %call3 = call i32 @mkdirat(i32 %4, i8* %5, i32 %6) #4
  store i32 %call3, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %7 = load i8*, i8** %narrow4, align 8
  %8 = load i32, i32* %mode, align 4
  %call5 = call i32 @mkdir(i8* %7, i32 %8) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %9 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %9)
  %10 = load i32, i32* %result, align 4
  %cmp7 = icmp slt i32 %10, 0
  br i1 %cmp7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %11 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %11, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %12 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %12, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %13 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %13
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_nice(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %increment = alloca i32, align 4
  %value = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.207, i32 0, i32 0), i32* %increment)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %1 = load i32, i32* %increment, align 4
  %call2 = call i32 @nice(i32 %1) #4
  store i32 %call2, i32* %value, align 4
  %2 = load i32, i32* %value, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %land.lhs.true, label %if.end.7

land.lhs.true:                                    ; preds = %if.end
  %call3 = call i32* @__errno_location() #9
  %3 = load i32, i32* %call3, align 4
  %cmp4 = icmp ne i32 %3, 0
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %land.lhs.true
  %call6 = call %struct._object* @posix_error()
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %land.lhs.true, %if.end
  %4 = load i32, i32* %value, align 4
  %conv = sext i32 %4 to i64
  %call8 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call8, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.5, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getpriority(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %which = alloca i32, align 4
  %who = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.208, i32 0, i32 0), i32* %which, i32* %who)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i32* @__errno_location() #9
  store i32 0, i32* %call2, align 4
  %1 = load i32, i32* %which, align 4
  %2 = load i32, i32* %who, align 4
  %call3 = call i32 @getpriority(i32 %1, i32 %2) #4
  store i32 %call3, i32* %retval1, align 4
  %call4 = call i32* @__errno_location() #9
  %3 = load i32, i32* %call4, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %if.end
  %call6 = call %struct._object* @posix_error()
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %if.end
  %4 = load i32, i32* %retval1, align 4
  %conv = sext i32 %4 to i64
  %call8 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call8, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.5, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setpriority(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %which = alloca i32, align 4
  %who = alloca i32, align 4
  %prio = alloca i32, align 4
  %retval1 = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.209, i32 0, i32 0), i32* %which, i32* %who, i32* %prio)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %which, align 4
  %2 = load i32, i32* %who, align 4
  %3 = load i32, i32* %prio, align 4
  %call2 = call i32 @setpriority(i32 %1, i32 %2, i32 %3) #4
  store i32 %call2, i32* %retval1, align 4
  %4 = load i32, i32* %retval1, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_readlink(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %buffer = alloca [4096 x i8], align 16
  %length = alloca i64, align 8
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.44, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.210, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_readlink.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %buffer, i32 0, i32 0
  %call3 = call i64 @readlinkat(i32 %4, i8* %5, i8* %arraydecay, i64 4096) #4
  store i64 %call3, i64* %length, align 8
  br label %if.end.7

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow4, align 8
  %arraydecay5 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buffer, i32 0, i32 0
  %call6 = call i64 @readlink(i8* %6, i8* %arraydecay5, i64 4096) #4
  store i64 %call6, i64* %length, align 8
  br label %if.end.7

if.end.7:                                         ; preds = %if.else, %if.then.2
  %7 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %7)
  %8 = load i64, i64* %length, align 8
  %cmp8 = icmp slt i64 %8, 0
  br i1 %cmp8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end.7
  %call10 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call10, %struct._object** %return_value, align 8
  br label %exit

if.end.11:                                        ; preds = %if.end.7
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 8
  %9 = load %struct._object*, %struct._object** %object, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %9, i32 0, i32 1
  %10 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %10, i32 0, i32 19
  %11 = load i64, i64* %tp_flags, align 8
  %and = and i64 %11, 268435456
  %cmp12 = icmp ne i64 %and, 0
  br i1 %cmp12, label %if.then.13, label %if.else.16

if.then.13:                                       ; preds = %if.end.11
  %arraydecay14 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buffer, i32 0, i32 0
  %12 = load i64, i64* %length, align 8
  %call15 = call %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8* %arraydecay14, i64 %12)
  store %struct._object* %call15, %struct._object** %return_value, align 8
  br label %if.end.19

if.else.16:                                       ; preds = %if.end.11
  %arraydecay17 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buffer, i32 0, i32 0
  %13 = load i64, i64* %length, align 8
  %call18 = call %struct._object* @PyBytes_FromStringAndSize(i8* %arraydecay17, i64 %13)
  store %struct._object* %call18, %struct._object** %return_value, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else.16, %if.then.13
  br label %exit

exit:                                             ; preds = %if.end.19, %if.then.9
  call void @path_cleanup(%struct.path_t* %path)
  %14 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %14, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_rename(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %1 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call %struct._object* @internal_rename(%struct._object* %0, %struct._object* %1, i32 0)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_replace(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %1 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call %struct._object* @internal_rename(%struct._object* %0, %struct._object* %1, i32 1)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_rmdir(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.47, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.213, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_rmdir.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %call3 = call i32 @unlinkat(i32 %4, i8* %5, i32 512) #4
  store i32 %call3, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow4, align 8
  %call5 = call i32 @rmdir(i8* %6) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %7 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %7)
  %8 = load i32, i32* %result, align 4
  %tobool7 = icmp ne i32 %8, 0
  br i1 %tobool7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %9 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %9, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %10 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %10, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %11 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %11
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @stat_float_times(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %newval = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 -1, i32* %newval, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.214, i32 0, i32 0), i32* %newval)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** @PyExc_DeprecationWarning, align 8
  %call1 = call i32 @PyErr_WarnEx(%struct._object* %1, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.215, i32 0, i32 0), i64 1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load i32, i32* %newval, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %if.end.4
  %3 = load i32, i32* @_stat_float_times, align 4
  %conv = sext i32 %3 to i64
  %call6 = call %struct._object* @PyBool_FromLong(i64 %conv)
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %if.end.4
  %4 = load i32, i32* %newval, align 4
  store i32 %4, i32* @_stat_float_times, align 4
  %5 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.5, %if.then.3, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_symlink(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %target_is_directory = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store i32 0, i32* %target_is_directory, align 4
  %0 = bitcast %struct.path_t* %src to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), i8** %function_name, align 8
  %argument_name = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 1
  store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.197, i32 0, i32 0), i8** %argument_name, align 8
  %1 = bitcast %struct.path_t* %dst to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %function_name1 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.49, i32 0, i32 0), i8** %function_name1, align 8
  %argument_name2 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 1
  store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.198, i32 0, i32 0), i8** %argument_name2, align 8
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %2, %struct._object* %3, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.217, i32 0, i32 0), i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @posix_symlink.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %src, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %dst, i32* %target_is_directory, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %4 = load i8*, i8** %narrow, align 8
  %tobool3 = icmp ne i8* %4, null
  br i1 %tobool3, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %if.end
  %wide = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 4
  %5 = load i32*, i32** %wide, align 8
  %tobool4 = icmp ne i32* %5, null
  br i1 %tobool4, label %if.then.10, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %if.end
  %wide5 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 4
  %6 = load i32*, i32** %wide5, align 8
  %tobool6 = icmp ne i32* %6, null
  br i1 %tobool6, label %land.lhs.true.7, label %if.end.11

land.lhs.true.7:                                  ; preds = %lor.lhs.false
  %narrow8 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %7 = load i8*, i8** %narrow8, align 8
  %tobool9 = icmp ne i8* %7, null
  br i1 %tobool9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %land.lhs.true.7, %land.lhs.true
  %8 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %8, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.218, i32 0, i32 0))
  store %struct._object* null, %struct._object** %return_value, align 8
  br label %exit

if.end.11:                                        ; preds = %land.lhs.true.7, %lor.lhs.false
  %call12 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call12, %struct._ts** %_save, align 8
  %9 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %9, -100
  br i1 %cmp, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %if.end.11
  %narrow14 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %10 = load i8*, i8** %narrow14, align 8
  %11 = load i32, i32* %dir_fd, align 4
  %narrow15 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %12 = load i8*, i8** %narrow15, align 8
  %call16 = call i32 @symlinkat(i8* %10, i32 %11, i8* %12) #4
  store i32 %call16, i32* %result, align 4
  br label %if.end.20

if.else:                                          ; preds = %if.end.11
  %narrow17 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %13 = load i8*, i8** %narrow17, align 8
  %narrow18 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %14 = load i8*, i8** %narrow18, align 8
  %call19 = call i32 @symlink(i8* %13, i8* %14) #4
  store i32 %call19, i32* %result, align 4
  br label %if.end.20

if.end.20:                                        ; preds = %if.else, %if.then.13
  %15 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %15)
  %16 = load i32, i32* %result, align 4
  %tobool21 = icmp ne i32 %16, 0
  br i1 %tobool21, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %if.end.20
  %call23 = call %struct._object* @path_error2(%struct.path_t* %src, %struct.path_t* %dst)
  store %struct._object* %call23, %struct._object** %return_value, align 8
  br label %exit

if.end.24:                                        ; preds = %if.end.20
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %17 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %17, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.24, %if.then.22, %if.then.10
  call void @path_cleanup(%struct.path_t* %src)
  call void @path_cleanup(%struct.path_t* %dst)
  %18 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %18, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %19 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %19
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_system(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %sts = alloca i64, align 8
  %command_obj = alloca %struct._object*, align 8
  %command = alloca i8*, align 8
  %_save = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.219, i32 0, i32 0), i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %command_obj)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %command_obj, align 8
  %call1 = call i8* @PyBytes_AsString(%struct._object* %1)
  store i8* %call1, i8** %command, align 8
  %call2 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call2, %struct._ts** %_save, align 8
  %2 = load i8*, i8** %command, align 8
  %call3 = call i32 @system(i8* %2)
  %conv = sext i32 %call3 to i64
  store i64 %conv, i64* %sts, align 8
  %3 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  br label %do.body

do.body:                                          ; preds = %if.end
  %4 = load %struct._object*, %struct._object** %command_obj, align 8
  store %struct._object* %4, %struct._object** %_py_decref_tmp, align 8
  %5 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %5, i32 0, i32 0
  %6 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %6, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp = icmp ne i64 %dec, 0
  br i1 %cmp, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %do.body
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %7 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %7, i32 0, i32 1
  %8 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %8, i32 0, i32 4
  %9 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %9(%struct._object* %10)
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.5
  br label %do.end

do.end:                                           ; preds = %if.end.6
  %11 = load i64, i64* %sts, align 8
  %call7 = call %struct._object* @PyLong_FromLong(i64 %11)
  store %struct._object* %call7, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %12 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %12
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_umask(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %i = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.220, i32 0, i32 0), i32* %i)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %i, align 4
  %call1 = call i32 @umask(i32 %1) #4
  store i32 %call1, i32* %i, align 4
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %i, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_uname(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %u = alloca %struct.utsname, align 1
  %res = alloca i32, align 4
  %value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  %o = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %o13 = alloca %struct._object*, align 8
  %_py_decref_tmp19 = alloca %struct._object*, align 8
  %o32 = alloca %struct._object*, align 8
  %_py_decref_tmp38 = alloca %struct._object*, align 8
  %o51 = alloca %struct._object*, align 8
  %_py_decref_tmp57 = alloca %struct._object*, align 8
  %o70 = alloca %struct._object*, align 8
  %_py_decref_tmp76 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  %call1 = call i32 @uname(%struct.utsname* %u) #4
  store i32 %call1, i32* %res, align 4
  %0 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %0)
  %1 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call %struct._object* @posix_error()
  store %struct._object* %call2, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call3 = call %struct._object* @PyStructSequence_New(%struct._typeobject* @UnameResultType)
  store %struct._object* %call3, %struct._object** %value, align 8
  %2 = load %struct._object*, %struct._object** %value, align 8
  %cmp4 = icmp eq %struct._object* %2, null
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %sysname = getelementptr inbounds %struct.utsname, %struct.utsname* %u, i32 0, i32 0
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %sysname, i32 0, i32 0
  %call7 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay)
  store %struct._object* %call7, %struct._object** %o, align 8
  %3 = load %struct._object*, %struct._object** %o, align 8
  %tobool = icmp ne %struct._object* %3, null
  br i1 %tobool, label %if.end.12, label %if.then.8

if.then.8:                                        ; preds = %if.end.6
  br label %do.body

do.body:                                          ; preds = %if.then.8
  %4 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %4, %struct._object** %_py_decref_tmp, align 8
  %5 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %5, i32 0, i32 0
  %6 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %6, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp9 = icmp ne i64 %dec, 0
  br i1 %cmp9, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %do.body
  br label %if.end.11

if.else:                                          ; preds = %do.body
  %7 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %7, i32 0, i32 1
  %8 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %8, i32 0, i32 4
  %9 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %9(%struct._object* %10)
  br label %if.end.11

if.end.11:                                        ; preds = %if.else, %if.then.10
  br label %do.end

do.end:                                           ; preds = %if.end.11
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.12:                                        ; preds = %if.end.6
  %11 = load %struct._object*, %struct._object** %o, align 8
  %12 = load %struct._object*, %struct._object** %value, align 8
  %13 = bitcast %struct._object* %12 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %13, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %11, %struct._object** %arrayidx, align 8
  %nodename = getelementptr inbounds %struct.utsname, %struct.utsname* %u, i32 0, i32 1
  %arraydecay14 = getelementptr inbounds [65 x i8], [65 x i8]* %nodename, i32 0, i32 0
  %call15 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay14)
  store %struct._object* %call15, %struct._object** %o13, align 8
  %14 = load %struct._object*, %struct._object** %o13, align 8
  %tobool16 = icmp ne %struct._object* %14, null
  br i1 %tobool16, label %if.end.29, label %if.then.17

if.then.17:                                       ; preds = %if.end.12
  br label %do.body.18

do.body.18:                                       ; preds = %if.then.17
  %15 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %15, %struct._object** %_py_decref_tmp19, align 8
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp19, align 8
  %ob_refcnt20 = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 0
  %17 = load i64, i64* %ob_refcnt20, align 8
  %dec21 = add i64 %17, -1
  store i64 %dec21, i64* %ob_refcnt20, align 8
  %cmp22 = icmp ne i64 %dec21, 0
  br i1 %cmp22, label %if.then.23, label %if.else.24

if.then.23:                                       ; preds = %do.body.18
  br label %if.end.27

if.else.24:                                       ; preds = %do.body.18
  %18 = load %struct._object*, %struct._object** %_py_decref_tmp19, align 8
  %ob_type25 = getelementptr inbounds %struct._object, %struct._object* %18, i32 0, i32 1
  %19 = load %struct._typeobject*, %struct._typeobject** %ob_type25, align 8
  %tp_dealloc26 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %19, i32 0, i32 4
  %20 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc26, align 8
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp19, align 8
  call void %20(%struct._object* %21)
  br label %if.end.27

if.end.27:                                        ; preds = %if.else.24, %if.then.23
  br label %do.end.28

do.end.28:                                        ; preds = %if.end.27
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.29:                                        ; preds = %if.end.12
  %22 = load %struct._object*, %struct._object** %o13, align 8
  %23 = load %struct._object*, %struct._object** %value, align 8
  %24 = bitcast %struct._object* %23 to %struct.PyTupleObject*
  %ob_item30 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx31 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item30, i32 0, i64 1
  store %struct._object* %22, %struct._object** %arrayidx31, align 8
  %release = getelementptr inbounds %struct.utsname, %struct.utsname* %u, i32 0, i32 2
  %arraydecay33 = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call34 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay33)
  store %struct._object* %call34, %struct._object** %o32, align 8
  %25 = load %struct._object*, %struct._object** %o32, align 8
  %tobool35 = icmp ne %struct._object* %25, null
  br i1 %tobool35, label %if.end.48, label %if.then.36

if.then.36:                                       ; preds = %if.end.29
  br label %do.body.37

do.body.37:                                       ; preds = %if.then.36
  %26 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %26, %struct._object** %_py_decref_tmp38, align 8
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp38, align 8
  %ob_refcnt39 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 0
  %28 = load i64, i64* %ob_refcnt39, align 8
  %dec40 = add i64 %28, -1
  store i64 %dec40, i64* %ob_refcnt39, align 8
  %cmp41 = icmp ne i64 %dec40, 0
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %do.body.37
  br label %if.end.46

if.else.43:                                       ; preds = %do.body.37
  %29 = load %struct._object*, %struct._object** %_py_decref_tmp38, align 8
  %ob_type44 = getelementptr inbounds %struct._object, %struct._object* %29, i32 0, i32 1
  %30 = load %struct._typeobject*, %struct._typeobject** %ob_type44, align 8
  %tp_dealloc45 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %30, i32 0, i32 4
  %31 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc45, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp38, align 8
  call void %31(%struct._object* %32)
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.43, %if.then.42
  br label %do.end.47

do.end.47:                                        ; preds = %if.end.46
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.48:                                        ; preds = %if.end.29
  %33 = load %struct._object*, %struct._object** %o32, align 8
  %34 = load %struct._object*, %struct._object** %value, align 8
  %35 = bitcast %struct._object* %34 to %struct.PyTupleObject*
  %ob_item49 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %35, i32 0, i32 1
  %arrayidx50 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item49, i32 0, i64 2
  store %struct._object* %33, %struct._object** %arrayidx50, align 8
  %version = getelementptr inbounds %struct.utsname, %struct.utsname* %u, i32 0, i32 3
  %arraydecay52 = getelementptr inbounds [65 x i8], [65 x i8]* %version, i32 0, i32 0
  %call53 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay52)
  store %struct._object* %call53, %struct._object** %o51, align 8
  %36 = load %struct._object*, %struct._object** %o51, align 8
  %tobool54 = icmp ne %struct._object* %36, null
  br i1 %tobool54, label %if.end.67, label %if.then.55

if.then.55:                                       ; preds = %if.end.48
  br label %do.body.56

do.body.56:                                       ; preds = %if.then.55
  %37 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %37, %struct._object** %_py_decref_tmp57, align 8
  %38 = load %struct._object*, %struct._object** %_py_decref_tmp57, align 8
  %ob_refcnt58 = getelementptr inbounds %struct._object, %struct._object* %38, i32 0, i32 0
  %39 = load i64, i64* %ob_refcnt58, align 8
  %dec59 = add i64 %39, -1
  store i64 %dec59, i64* %ob_refcnt58, align 8
  %cmp60 = icmp ne i64 %dec59, 0
  br i1 %cmp60, label %if.then.61, label %if.else.62

if.then.61:                                       ; preds = %do.body.56
  br label %if.end.65

if.else.62:                                       ; preds = %do.body.56
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp57, align 8
  %ob_type63 = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 1
  %41 = load %struct._typeobject*, %struct._typeobject** %ob_type63, align 8
  %tp_dealloc64 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %41, i32 0, i32 4
  %42 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc64, align 8
  %43 = load %struct._object*, %struct._object** %_py_decref_tmp57, align 8
  call void %42(%struct._object* %43)
  br label %if.end.65

if.end.65:                                        ; preds = %if.else.62, %if.then.61
  br label %do.end.66

do.end.66:                                        ; preds = %if.end.65
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.67:                                        ; preds = %if.end.48
  %44 = load %struct._object*, %struct._object** %o51, align 8
  %45 = load %struct._object*, %struct._object** %value, align 8
  %46 = bitcast %struct._object* %45 to %struct.PyTupleObject*
  %ob_item68 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %46, i32 0, i32 1
  %arrayidx69 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item68, i32 0, i64 3
  store %struct._object* %44, %struct._object** %arrayidx69, align 8
  %machine = getelementptr inbounds %struct.utsname, %struct.utsname* %u, i32 0, i32 4
  %arraydecay71 = getelementptr inbounds [65 x i8], [65 x i8]* %machine, i32 0, i32 0
  %call72 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay71)
  store %struct._object* %call72, %struct._object** %o70, align 8
  %47 = load %struct._object*, %struct._object** %o70, align 8
  %tobool73 = icmp ne %struct._object* %47, null
  br i1 %tobool73, label %if.end.86, label %if.then.74

if.then.74:                                       ; preds = %if.end.67
  br label %do.body.75

do.body.75:                                       ; preds = %if.then.74
  %48 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %48, %struct._object** %_py_decref_tmp76, align 8
  %49 = load %struct._object*, %struct._object** %_py_decref_tmp76, align 8
  %ob_refcnt77 = getelementptr inbounds %struct._object, %struct._object* %49, i32 0, i32 0
  %50 = load i64, i64* %ob_refcnt77, align 8
  %dec78 = add i64 %50, -1
  store i64 %dec78, i64* %ob_refcnt77, align 8
  %cmp79 = icmp ne i64 %dec78, 0
  br i1 %cmp79, label %if.then.80, label %if.else.81

if.then.80:                                       ; preds = %do.body.75
  br label %if.end.84

if.else.81:                                       ; preds = %do.body.75
  %51 = load %struct._object*, %struct._object** %_py_decref_tmp76, align 8
  %ob_type82 = getelementptr inbounds %struct._object, %struct._object* %51, i32 0, i32 1
  %52 = load %struct._typeobject*, %struct._typeobject** %ob_type82, align 8
  %tp_dealloc83 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %52, i32 0, i32 4
  %53 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc83, align 8
  %54 = load %struct._object*, %struct._object** %_py_decref_tmp76, align 8
  call void %53(%struct._object* %54)
  br label %if.end.84

if.end.84:                                        ; preds = %if.else.81, %if.then.80
  br label %do.end.85

do.end.85:                                        ; preds = %if.end.84
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.86:                                        ; preds = %if.end.67
  %55 = load %struct._object*, %struct._object** %o70, align 8
  %56 = load %struct._object*, %struct._object** %value, align 8
  %57 = bitcast %struct._object* %56 to %struct.PyTupleObject*
  %ob_item87 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %57, i32 0, i32 1
  %arrayidx88 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item87, i32 0, i64 4
  store %struct._object* %55, %struct._object** %arrayidx88, align 8
  %58 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %58, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.86, %do.end.85, %do.end.66, %do.end.47, %do.end.28, %do.end, %if.then.5, %if.then
  %59 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %59
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_unlink(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %dir_fd = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.53, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.221, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_unlink.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %call3 = call i32 @unlinkat(i32 %4, i8* %5, i32 0) #4
  store i32 %call3, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow4, align 8
  %call5 = call i32 @unlink(i8* %6) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %7 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %7)
  %8 = load i32, i32* %result, align 4
  %tobool7 = icmp ne i32 %8, 0
  br i1 %tobool7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %9 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %9, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %10 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %10, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %11 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %11
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_utime(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %times = alloca %struct._object*, align 8
  %ns = alloca %struct._object*, align 8
  %dir_fd = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %keywords = alloca [6 x i8*], align 16
  %utime = alloca %struct.utime_t, align 8
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %a_sec = alloca i64, align 8
  %m_sec = alloca i64, align 8
  %a_nsec = alloca i64, align 8
  %m_nsec = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %times, align 8
  store %struct._object* null, %struct._object** %ns, align 8
  store i32 -100, i32* %dir_fd, align 4
  store i32 1, i32* %follow_symlinks, align 4
  %0 = bitcast [6 x i8*]* %keywords to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 48, i32 16, i1 false)
  %1 = bitcast i8* %0 to [6 x i8*]*
  %2 = getelementptr [6 x i8*], [6 x i8*]* %1, i32 0, i32 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), i8** %2
  %3 = getelementptr [6 x i8*], [6 x i8*]* %1, i32 0, i32 1
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i32 0, i32 0), i8** %3
  %4 = getelementptr [6 x i8*], [6 x i8*]* %1, i32 0, i32 2
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.222, i32 0, i32 0), i8** %4
  %5 = getelementptr [6 x i8*], [6 x i8*]* %1, i32 0, i32 3
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.170, i32 0, i32 0), i8** %5
  %6 = getelementptr [6 x i8*], [6 x i8*]* %1, i32 0, i32 4
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.171, i32 0, i32 0), i8** %6
  store %struct._object* null, %struct._object** %return_value, align 8
  %7 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %7, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0), i8** %function_name, align 8
  %8 = bitcast %struct.utime_t* %utime to i8*
  call void @llvm.memset.p0i8.i64(i8* %8, i8 0, i64 40, i32 8, i1 false)
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %9 = load %struct._object*, %struct._object** %args.addr, align 8
  %10 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %arraydecay = getelementptr inbounds [6 x i8*], [6 x i8*]* %keywords, i32 0, i32 0
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %9, %struct._object* %10, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.223, i32 0, i32 0), i8** %arraydecay, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, %struct._object** %times, %struct._object** %ns, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct._object*, %struct._object** %times, align 8
  %tobool1 = icmp ne %struct._object* %11, null
  br i1 %tobool1, label %land.lhs.true, label %if.end.5

land.lhs.true:                                    ; preds = %if.end
  %12 = load %struct._object*, %struct._object** %times, align 8
  %cmp = icmp ne %struct._object* %12, @_Py_NoneStruct
  br i1 %cmp, label %land.lhs.true.2, label %if.end.5

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %13 = load %struct._object*, %struct._object** %ns, align 8
  %tobool3 = icmp ne %struct._object* %13, null
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %land.lhs.true.2
  %14 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %14, i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.224, i32 0, i32 0))
  br label %exit

if.end.5:                                         ; preds = %land.lhs.true.2, %land.lhs.true, %if.end
  %15 = load %struct._object*, %struct._object** %times, align 8
  %tobool6 = icmp ne %struct._object* %15, null
  br i1 %tobool6, label %land.lhs.true.7, label %if.else

land.lhs.true.7:                                  ; preds = %if.end.5
  %16 = load %struct._object*, %struct._object** %times, align 8
  %cmp8 = icmp ne %struct._object* %16, @_Py_NoneStruct
  br i1 %cmp8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %land.lhs.true.7
  %17 = load %struct._object*, %struct._object** %times, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %17, i32 0, i32 1
  %18 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %cmp10 = icmp eq %struct._typeobject* %18, @PyTuple_Type
  br i1 %cmp10, label %lor.lhs.false, label %if.then.13

lor.lhs.false:                                    ; preds = %if.then.9
  %19 = load %struct._object*, %struct._object** %times, align 8
  %call11 = call i64 @PyTuple_Size(%struct._object* %19)
  %cmp12 = icmp ne i64 %call11, 2
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %lor.lhs.false, %if.then.9
  %20 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %20, i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.225, i32 0, i32 0))
  br label %exit

if.end.14:                                        ; preds = %lor.lhs.false
  %now = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 0
  store i32 0, i32* %now, align 4
  %21 = load %struct._object*, %struct._object** %times, align 8
  %22 = bitcast %struct._object* %21 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %22, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  %23 = load %struct._object*, %struct._object** %arrayidx, align 8
  %call15 = call i32 @_PyTime_ObjectToTimespec(%struct._object* %23, i64* %a_sec, i64* %a_nsec, i32 0)
  %cmp16 = icmp eq i32 %call15, -1
  br i1 %cmp16, label %if.then.22, label %lor.lhs.false.17

lor.lhs.false.17:                                 ; preds = %if.end.14
  %24 = load %struct._object*, %struct._object** %times, align 8
  %25 = bitcast %struct._object* %24 to %struct.PyTupleObject*
  %ob_item18 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %25, i32 0, i32 1
  %arrayidx19 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item18, i32 0, i64 1
  %26 = load %struct._object*, %struct._object** %arrayidx19, align 8
  %call20 = call i32 @_PyTime_ObjectToTimespec(%struct._object* %26, i64* %m_sec, i64* %m_nsec, i32 0)
  %cmp21 = icmp eq i32 %call20, -1
  br i1 %cmp21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %lor.lhs.false.17, %if.end.14
  br label %exit

if.end.23:                                        ; preds = %lor.lhs.false.17
  %27 = load i64, i64* %a_sec, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 1
  store i64 %27, i64* %atime_s, align 8
  %28 = load i64, i64* %a_nsec, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 2
  store i64 %28, i64* %atime_ns, align 8
  %29 = load i64, i64* %m_sec, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 3
  store i64 %29, i64* %mtime_s, align 8
  %30 = load i64, i64* %m_nsec, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 4
  store i64 %30, i64* %mtime_ns, align 8
  br label %if.end.52

if.else:                                          ; preds = %land.lhs.true.7, %if.end.5
  %31 = load %struct._object*, %struct._object** %ns, align 8
  %tobool24 = icmp ne %struct._object* %31, null
  br i1 %tobool24, label %if.then.25, label %if.else.49

if.then.25:                                       ; preds = %if.else
  %32 = load %struct._object*, %struct._object** %ns, align 8
  %ob_type26 = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 1
  %33 = load %struct._typeobject*, %struct._typeobject** %ob_type26, align 8
  %cmp27 = icmp eq %struct._typeobject* %33, @PyTuple_Type
  br i1 %cmp27, label %lor.lhs.false.28, label %if.then.31

lor.lhs.false.28:                                 ; preds = %if.then.25
  %34 = load %struct._object*, %struct._object** %ns, align 8
  %call29 = call i64 @PyTuple_Size(%struct._object* %34)
  %cmp30 = icmp ne i64 %call29, 2
  br i1 %cmp30, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %lor.lhs.false.28, %if.then.25
  %35 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %35, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.226, i32 0, i32 0))
  br label %exit

if.end.32:                                        ; preds = %lor.lhs.false.28
  %now33 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 0
  store i32 0, i32* %now33, align 4
  %36 = load %struct._object*, %struct._object** %ns, align 8
  %37 = bitcast %struct._object* %36 to %struct.PyTupleObject*
  %ob_item34 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %37, i32 0, i32 1
  %arrayidx35 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item34, i32 0, i64 0
  %38 = load %struct._object*, %struct._object** %arrayidx35, align 8
  %atime_s36 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 1
  %atime_ns37 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 2
  %call38 = call i32 @split_py_long_to_s_and_ns(%struct._object* %38, i64* %atime_s36, i64* %atime_ns37)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %lor.lhs.false.40, label %if.then.47

lor.lhs.false.40:                                 ; preds = %if.end.32
  %39 = load %struct._object*, %struct._object** %ns, align 8
  %40 = bitcast %struct._object* %39 to %struct.PyTupleObject*
  %ob_item41 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %40, i32 0, i32 1
  %arrayidx42 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item41, i32 0, i64 1
  %41 = load %struct._object*, %struct._object** %arrayidx42, align 8
  %mtime_s43 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 3
  %mtime_ns44 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 4
  %call45 = call i32 @split_py_long_to_s_and_ns(%struct._object* %41, i64* %mtime_s43, i64* %mtime_ns44)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %if.end.48, label %if.then.47

if.then.47:                                       ; preds = %lor.lhs.false.40, %if.end.32
  br label %exit

if.end.48:                                        ; preds = %lor.lhs.false.40
  br label %if.end.51

if.else.49:                                       ; preds = %if.else
  %now50 = getelementptr inbounds %struct.utime_t, %struct.utime_t* %utime, i32 0, i32 0
  store i32 1, i32* %now50, align 4
  br label %if.end.51

if.end.51:                                        ; preds = %if.else.49, %if.end.48
  br label %if.end.52

if.end.52:                                        ; preds = %if.end.51, %if.end.23
  %42 = load i32, i32* %dir_fd, align 4
  %call53 = call i32 @path_and_dir_fd_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0), %struct.path_t* %path, i32 %42)
  %tobool54 = icmp ne i32 %call53, 0
  br i1 %tobool54, label %if.then.62, label %lor.lhs.false.55

lor.lhs.false.55:                                 ; preds = %if.end.52
  %43 = load i32, i32* %dir_fd, align 4
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %44 = load i32, i32* %fd, align 4
  %call56 = call i32 @dir_fd_and_fd_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0), i32 %43, i32 %44)
  %tobool57 = icmp ne i32 %call56, 0
  br i1 %tobool57, label %if.then.62, label %lor.lhs.false.58

lor.lhs.false.58:                                 ; preds = %lor.lhs.false.55
  %fd59 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %45 = load i32, i32* %fd59, align 4
  %46 = load i32, i32* %follow_symlinks, align 4
  %call60 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.55, i32 0, i32 0), i32 %45, i32 %46)
  %tobool61 = icmp ne i32 %call60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %lor.lhs.false.58, %lor.lhs.false.55, %if.end.52
  br label %exit

if.end.63:                                        ; preds = %lor.lhs.false.58
  %call64 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call64, %struct._ts** %_save, align 8
  %47 = load i32, i32* %follow_symlinks, align 4
  %tobool65 = icmp ne i32 %47, 0
  br i1 %tobool65, label %if.else.70, label %land.lhs.true.66

land.lhs.true.66:                                 ; preds = %if.end.63
  %48 = load i32, i32* %dir_fd, align 4
  %cmp67 = icmp eq i32 %48, -100
  br i1 %cmp67, label %if.then.68, label %if.else.70

if.then.68:                                       ; preds = %land.lhs.true.66
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %49 = load i8*, i8** %narrow, align 8
  %call69 = call i32 @utime_nofollow_symlinks(%struct.utime_t* %utime, i8* %49)
  store i32 %call69, i32* %result, align 4
  br label %if.end.88

if.else.70:                                       ; preds = %land.lhs.true.66, %if.end.63
  %50 = load i32, i32* %dir_fd, align 4
  %cmp71 = icmp ne i32 %50, -100
  br i1 %cmp71, label %if.then.74, label %lor.lhs.false.72

lor.lhs.false.72:                                 ; preds = %if.else.70
  %51 = load i32, i32* %follow_symlinks, align 4
  %tobool73 = icmp ne i32 %51, 0
  br i1 %tobool73, label %if.else.77, label %if.then.74

if.then.74:                                       ; preds = %lor.lhs.false.72, %if.else.70
  %52 = load i32, i32* %dir_fd, align 4
  %narrow75 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %53 = load i8*, i8** %narrow75, align 8
  %54 = load i32, i32* %follow_symlinks, align 4
  %call76 = call i32 @utime_dir_fd(%struct.utime_t* %utime, i32 %52, i8* %53, i32 %54)
  store i32 %call76, i32* %result, align 4
  br label %if.end.87

if.else.77:                                       ; preds = %lor.lhs.false.72
  %fd78 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %55 = load i32, i32* %fd78, align 4
  %cmp79 = icmp ne i32 %55, -1
  br i1 %cmp79, label %if.then.80, label %if.else.83

if.then.80:                                       ; preds = %if.else.77
  %fd81 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %56 = load i32, i32* %fd81, align 4
  %call82 = call i32 @utime_fd(%struct.utime_t* %utime, i32 %56)
  store i32 %call82, i32* %result, align 4
  br label %if.end.86

if.else.83:                                       ; preds = %if.else.77
  %narrow84 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %57 = load i8*, i8** %narrow84, align 8
  %call85 = call i32 @utime_default(%struct.utime_t* %utime, i8* %57)
  store i32 %call85, i32* %result, align 4
  br label %if.end.86

if.end.86:                                        ; preds = %if.else.83, %if.then.80
  br label %if.end.87

if.end.87:                                        ; preds = %if.end.86, %if.then.74
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %if.then.68
  %58 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %58)
  %59 = load i32, i32* %result, align 4
  %cmp89 = icmp slt i32 %59, 0
  br i1 %cmp89, label %if.then.90, label %if.end.92

if.then.90:                                       ; preds = %if.end.88
  %call91 = call %struct._object* @posix_error()
  store %struct._object* %call91, %struct._object** %return_value, align 8
  br label %exit

if.end.92:                                        ; preds = %if.end.88
  %60 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %60, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.92, %if.then.90, %if.then.62, %if.then.47, %if.then.31, %if.then.22, %if.then.13, %if.then.4
  call void @path_cleanup(%struct.path_t* %path)
  %61 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %61, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %62 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %62
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_times(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %t = alloca %struct.tms, align 8
  %c = alloca i64, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32* @__errno_location() #9
  store i32 0, i32* %call, align 4
  %call1 = call i64 @times(%struct.tms* %t) #4
  store i64 %call1, i64* %c, align 8
  %0 = load i64, i64* %c, align 8
  %cmp = icmp eq i64 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call %struct._object* @posix_error()
  store %struct._object* %call2, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %tms_utime = getelementptr inbounds %struct.tms, %struct.tms* %t, i32 0, i32 0
  %1 = load i64, i64* %tms_utime, align 8
  %conv = sitofp i64 %1 to double
  %2 = load i64, i64* @ticks_per_second, align 8
  %conv3 = sitofp i64 %2 to double
  %div = fdiv double %conv, %conv3
  %tms_stime = getelementptr inbounds %struct.tms, %struct.tms* %t, i32 0, i32 1
  %3 = load i64, i64* %tms_stime, align 8
  %conv4 = sitofp i64 %3 to double
  %4 = load i64, i64* @ticks_per_second, align 8
  %conv5 = sitofp i64 %4 to double
  %div6 = fdiv double %conv4, %conv5
  %tms_cutime = getelementptr inbounds %struct.tms, %struct.tms* %t, i32 0, i32 2
  %5 = load i64, i64* %tms_cutime, align 8
  %conv7 = sitofp i64 %5 to double
  %6 = load i64, i64* @ticks_per_second, align 8
  %conv8 = sitofp i64 %6 to double
  %div9 = fdiv double %conv7, %conv8
  %tms_cstime = getelementptr inbounds %struct.tms, %struct.tms* %t, i32 0, i32 3
  %7 = load i64, i64* %tms_cstime, align 8
  %conv10 = sitofp i64 %7 to double
  %8 = load i64, i64* @ticks_per_second, align 8
  %conv11 = sitofp i64 %8 to double
  %div12 = fdiv double %conv10, %conv11
  %9 = load i64, i64* %c, align 8
  %conv13 = sitofp i64 %9 to double
  %10 = load i64, i64* @ticks_per_second, align 8
  %conv14 = sitofp i64 %10 to double
  %div15 = fdiv double %conv13, %conv14
  %call16 = call %struct._object* @build_times_result(double %div, double %div6, double %div9, double %div12, double %div15)
  store %struct._object* %call16, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %11
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix__exit(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %sts = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.227, i32 0, i32 0), i32* %sts)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  ret %struct._object* null

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %sts, align 4
  call void @_exit(i32 %1) #10
  unreachable
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_execv(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %opath = alloca %struct._object*, align 8
  %path = alloca i8*, align 8
  %argv = alloca %struct._object*, align 8
  %argvlist = alloca i8**, align 8
  %argc = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp16 = alloca %struct._object*, align 8
  %_py_decref_tmp31 = alloca %struct._object*, align 8
  %_py_decref_tmp44 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.228, i32 0, i32 0), i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %opath, %struct._object** %argv)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %opath, align 8
  %call1 = call i8* @PyBytes_AsString(%struct._object* %1)
  store i8* %call1, i8** %path, align 8
  %2 = load %struct._object*, %struct._object** %argv, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %2, i32 0, i32 1
  %3 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %3, i32 0, i32 19
  %4 = load i64, i64* %tp_flags, align 8
  %and = and i64 %4, 33554432
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.end.11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %5 = load %struct._object*, %struct._object** %argv, align 8
  %ob_type2 = getelementptr inbounds %struct._object, %struct._object* %5, i32 0, i32 1
  %6 = load %struct._typeobject*, %struct._typeobject** %ob_type2, align 8
  %tp_flags3 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %6, i32 0, i32 19
  %7 = load i64, i64* %tp_flags3, align 8
  %and4 = and i64 %7, 67108864
  %cmp5 = icmp ne i64 %and4, 0
  br i1 %cmp5, label %if.end.11, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true
  %8 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %8, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.229, i32 0, i32 0))
  br label %do.body

do.body:                                          ; preds = %if.then.6
  %9 = load %struct._object*, %struct._object** %opath, align 8
  store %struct._object* %9, %struct._object** %_py_decref_tmp, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %10, i32 0, i32 0
  %11 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %11, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp7 = icmp ne i64 %dec, 0
  br i1 %cmp7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %do.body
  br label %if.end.10

if.else:                                          ; preds = %do.body
  %12 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type9 = getelementptr inbounds %struct._object, %struct._object* %12, i32 0, i32 1
  %13 = load %struct._typeobject*, %struct._typeobject** %ob_type9, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %13, i32 0, i32 4
  %14 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %15 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %14(%struct._object* %15)
  br label %if.end.10

if.end.10:                                        ; preds = %if.else, %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.11:                                        ; preds = %land.lhs.true, %if.end
  %16 = load %struct._object*, %struct._object** %argv, align 8
  %call12 = call i64 @PySequence_Size(%struct._object* %16)
  store i64 %call12, i64* %argc, align 8
  %17 = load i64, i64* %argc, align 8
  %cmp13 = icmp slt i64 %17, 1
  br i1 %cmp13, label %if.then.14, label %if.end.26

if.then.14:                                       ; preds = %if.end.11
  %18 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %18, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.230, i32 0, i32 0))
  br label %do.body.15

do.body.15:                                       ; preds = %if.then.14
  %19 = load %struct._object*, %struct._object** %opath, align 8
  store %struct._object* %19, %struct._object** %_py_decref_tmp16, align 8
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp16, align 8
  %ob_refcnt17 = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 0
  %21 = load i64, i64* %ob_refcnt17, align 8
  %dec18 = add i64 %21, -1
  store i64 %dec18, i64* %ob_refcnt17, align 8
  %cmp19 = icmp ne i64 %dec18, 0
  br i1 %cmp19, label %if.then.20, label %if.else.21

if.then.20:                                       ; preds = %do.body.15
  br label %if.end.24

if.else.21:                                       ; preds = %do.body.15
  %22 = load %struct._object*, %struct._object** %_py_decref_tmp16, align 8
  %ob_type22 = getelementptr inbounds %struct._object, %struct._object* %22, i32 0, i32 1
  %23 = load %struct._typeobject*, %struct._typeobject** %ob_type22, align 8
  %tp_dealloc23 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %23, i32 0, i32 4
  %24 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc23, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp16, align 8
  call void %24(%struct._object* %25)
  br label %if.end.24

if.end.24:                                        ; preds = %if.else.21, %if.then.20
  br label %do.end.25

do.end.25:                                        ; preds = %if.end.24
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.26:                                        ; preds = %if.end.11
  %26 = load %struct._object*, %struct._object** %argv, align 8
  %call27 = call i8** @parse_arglist(%struct._object* %26, i64* %argc)
  store i8** %call27, i8*** %argvlist, align 8
  %27 = load i8**, i8*** %argvlist, align 8
  %cmp28 = icmp eq i8** %27, null
  br i1 %cmp28, label %if.then.29, label %if.end.41

if.then.29:                                       ; preds = %if.end.26
  br label %do.body.30

do.body.30:                                       ; preds = %if.then.29
  %28 = load %struct._object*, %struct._object** %opath, align 8
  store %struct._object* %28, %struct._object** %_py_decref_tmp31, align 8
  %29 = load %struct._object*, %struct._object** %_py_decref_tmp31, align 8
  %ob_refcnt32 = getelementptr inbounds %struct._object, %struct._object* %29, i32 0, i32 0
  %30 = load i64, i64* %ob_refcnt32, align 8
  %dec33 = add i64 %30, -1
  store i64 %dec33, i64* %ob_refcnt32, align 8
  %cmp34 = icmp ne i64 %dec33, 0
  br i1 %cmp34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %do.body.30
  br label %if.end.39

if.else.36:                                       ; preds = %do.body.30
  %31 = load %struct._object*, %struct._object** %_py_decref_tmp31, align 8
  %ob_type37 = getelementptr inbounds %struct._object, %struct._object* %31, i32 0, i32 1
  %32 = load %struct._typeobject*, %struct._typeobject** %ob_type37, align 8
  %tp_dealloc38 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %32, i32 0, i32 4
  %33 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc38, align 8
  %34 = load %struct._object*, %struct._object** %_py_decref_tmp31, align 8
  call void %33(%struct._object* %34)
  br label %if.end.39

if.end.39:                                        ; preds = %if.else.36, %if.then.35
  br label %do.end.40

do.end.40:                                        ; preds = %if.end.39
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.41:                                        ; preds = %if.end.26
  %35 = load i8*, i8** %path, align 8
  %36 = load i8**, i8*** %argvlist, align 8
  %call42 = call i32 @execv(i8* %35, i8** %36) #4
  %37 = load i8**, i8*** %argvlist, align 8
  %38 = load i64, i64* %argc, align 8
  call void @free_string_array(i8** %37, i64 %38)
  br label %do.body.43

do.body.43:                                       ; preds = %if.end.41
  %39 = load %struct._object*, %struct._object** %opath, align 8
  store %struct._object* %39, %struct._object** %_py_decref_tmp44, align 8
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  %ob_refcnt45 = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 0
  %41 = load i64, i64* %ob_refcnt45, align 8
  %dec46 = add i64 %41, -1
  store i64 %dec46, i64* %ob_refcnt45, align 8
  %cmp47 = icmp ne i64 %dec46, 0
  br i1 %cmp47, label %if.then.48, label %if.else.49

if.then.48:                                       ; preds = %do.body.43
  br label %if.end.52

if.else.49:                                       ; preds = %do.body.43
  %42 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  %ob_type50 = getelementptr inbounds %struct._object, %struct._object* %42, i32 0, i32 1
  %43 = load %struct._typeobject*, %struct._typeobject** %ob_type50, align 8
  %tp_dealloc51 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %43, i32 0, i32 4
  %44 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc51, align 8
  %45 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  call void %44(%struct._object* %45)
  br label %if.end.52

if.end.52:                                        ; preds = %if.else.49, %if.then.48
  br label %do.end.53

do.end.53:                                        ; preds = %if.end.52
  %call54 = call %struct._object* @posix_error()
  store %struct._object* %call54, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end.53, %do.end.40, %do.end.25, %do.end, %if.then
  %46 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %46
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_execve(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %argv = alloca %struct._object*, align 8
  %env = alloca %struct._object*, align 8
  %argvlist = alloca i8**, align 8
  %envlist = alloca i8**, align 8
  %argc = alloca i64, align 8
  %envc = alloca i64, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i8** null, i8*** %argvlist, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.233, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_execve.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, %struct._object** %argv, %struct._object** %env)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct._object*, %struct._object** %argv, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %3, i32 0, i32 1
  %4 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %4, i32 0, i32 19
  %5 = load i64, i64* %tp_flags, align 8
  %and = and i64 %5, 33554432
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.end.6, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct._object*, %struct._object** %argv, align 8
  %ob_type1 = getelementptr inbounds %struct._object, %struct._object* %6, i32 0, i32 1
  %7 = load %struct._typeobject*, %struct._typeobject** %ob_type1, align 8
  %tp_flags2 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %7, i32 0, i32 19
  %8 = load i64, i64* %tp_flags2, align 8
  %and3 = and i64 %8, 67108864
  %cmp4 = icmp ne i64 %and3, 0
  br i1 %cmp4, label %if.end.6, label %if.then.5

if.then.5:                                        ; preds = %land.lhs.true
  %9 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %9, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.234, i32 0, i32 0))
  br label %fail

if.end.6:                                         ; preds = %land.lhs.true, %if.end
  %10 = load %struct._object*, %struct._object** %argv, align 8
  %call7 = call i64 @PySequence_Size(%struct._object* %10)
  store i64 %call7, i64* %argc, align 8
  %11 = load %struct._object*, %struct._object** %env, align 8
  %call8 = call i32 @PyMapping_Check(%struct._object* %11)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end.11, label %if.then.10

if.then.10:                                       ; preds = %if.end.6
  %12 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %12, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.235, i32 0, i32 0))
  br label %fail

if.end.11:                                        ; preds = %if.end.6
  %13 = load %struct._object*, %struct._object** %argv, align 8
  %call12 = call i8** @parse_arglist(%struct._object* %13, i64* %argc)
  store i8** %call12, i8*** %argvlist, align 8
  %14 = load i8**, i8*** %argvlist, align 8
  %cmp13 = icmp eq i8** %14, null
  br i1 %cmp13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.11
  br label %fail

if.end.15:                                        ; preds = %if.end.11
  %15 = load %struct._object*, %struct._object** %env, align 8
  %call16 = call i8** @parse_envlist(%struct._object* %15, i64* %envc)
  store i8** %call16, i8*** %envlist, align 8
  %16 = load i8**, i8*** %envlist, align 8
  %cmp17 = icmp eq i8** %16, null
  br i1 %cmp17, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %if.end.15
  br label %fail

if.end.19:                                        ; preds = %if.end.15
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %17 = load i32, i32* %fd, align 4
  %cmp20 = icmp sgt i32 %17, -1
  br i1 %cmp20, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %if.end.19
  %fd22 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %18 = load i32, i32* %fd22, align 4
  %19 = load i8**, i8*** %argvlist, align 8
  %20 = load i8**, i8*** %envlist, align 8
  %call23 = call i32 @fexecve(i32 %18, i8** %19, i8** %20) #4
  br label %if.end.25

if.else:                                          ; preds = %if.end.19
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %21 = load i8*, i8** %narrow, align 8
  %22 = load i8**, i8*** %argvlist, align 8
  %23 = load i8**, i8*** %envlist, align 8
  %call24 = call i32 @execve(i8* %21, i8** %22, i8** %23) #4
  br label %if.end.25

if.end.25:                                        ; preds = %if.else, %if.then.21
  %call26 = call %struct._object* @path_error(%struct.path_t* %path)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.25
  %24 = load i64, i64* %envc, align 8
  %dec = add i64 %24, -1
  store i64 %dec, i64* %envc, align 8
  %cmp27 = icmp sge i64 %dec, 0
  br i1 %cmp27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load i64, i64* %envc, align 8
  %26 = load i8**, i8*** %envlist, align 8
  %arrayidx = getelementptr i8*, i8** %26, i64 %25
  %27 = load i8*, i8** %arrayidx, align 8
  call void @PyMem_Free(i8* %27)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %28 = load i8**, i8*** %envlist, align 8
  %29 = bitcast i8** %28 to i8*
  call void @PyMem_Free(i8* %29)
  br label %fail

fail:                                             ; preds = %while.end, %if.then.18, %if.then.14, %if.then.10, %if.then.5
  %30 = load i8**, i8*** %argvlist, align 8
  %tobool28 = icmp ne i8** %30, null
  br i1 %tobool28, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %fail
  %31 = load i8**, i8*** %argvlist, align 8
  %32 = load i64, i64* %argc, align 8
  call void @free_string_array(i8** %31, i64 %32)
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.29, %fail
  call void @path_cleanup(%struct.path_t* %path)
  store %struct._object* null, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.30, %if.then
  %33 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %33
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fork(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %result = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store i32 0, i32* %result, align 4
  call void @_PyImport_AcquireLock()
  %call = call i32 @fork() #4
  store i32 %call, i32* %pid, align 4
  %0 = load i32, i32* %pid, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @PyOS_AfterFork()
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 @_PyImport_ReleaseLock()
  store i32 %call1, i32* %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %1 = load i32, i32* %pid, align 4
  %cmp2 = icmp eq i32 %1, -1
  br i1 %cmp2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %2 = load i32, i32* %result, align 4
  %cmp6 = icmp slt i32 %2, 0
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.5
  %3 = load %struct._object*, %struct._object** @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(%struct._object* %3, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.238, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.8:                                         ; preds = %if.end.5
  %4 = load i32, i32* %pid, align 4
  %conv = sext i32 %4 to i64
  %call9 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call9, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.7, %if.then.3
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_get_priority_max(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %policy = alloca i32, align 4
  %max = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.239, i32 0, i32 0), i32* %policy)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %policy, align 4
  %call1 = call i32 @sched_get_priority_max(i32 %1) #4
  store i32 %call1, i32* %max, align 4
  %2 = load i32, i32* %max, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %max, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_get_priority_min(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %policy = alloca i32, align 4
  %min = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.240, i32 0, i32 0), i32* %policy)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %policy, align 4
  %call1 = call i32 @sched_get_priority_min(i32 %1) #4
  store i32 %call1, i32* %min, align 4
  %2 = load i32, i32* %min, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %min, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_getparam(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %param = alloca %struct.sched_param, align 4
  %res = alloca %struct._object*, align 8
  %priority = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.241, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @sched_getparam(i32 %1, %struct.sched_param* %param) #4
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %call6 = call %struct._object* @PyStructSequence_New(%struct._typeobject* @SchedParamType)
  store %struct._object* %call6, %struct._object** %res, align 8
  %2 = load %struct._object*, %struct._object** %res, align 8
  %tobool7 = icmp ne %struct._object* %2, null
  br i1 %tobool7, label %if.end.9, label %if.then.8

if.then.8:                                        ; preds = %if.end.5
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.5
  %__sched_priority = getelementptr inbounds %struct.sched_param, %struct.sched_param* %param, i32 0, i32 0
  %3 = load i32, i32* %__sched_priority, align 4
  %conv = sext i32 %3 to i64
  %call10 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call10, %struct._object** %priority, align 8
  %4 = load %struct._object*, %struct._object** %priority, align 8
  %tobool11 = icmp ne %struct._object* %4, null
  br i1 %tobool11, label %if.end.16, label %if.then.12

if.then.12:                                       ; preds = %if.end.9
  br label %do.body

do.body:                                          ; preds = %if.then.12
  %5 = load %struct._object*, %struct._object** %res, align 8
  store %struct._object* %5, %struct._object** %_py_decref_tmp, align 8
  %6 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %6, i32 0, i32 0
  %7 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %7, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp = icmp ne i64 %dec, 0
  br i1 %cmp, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %do.body
  br label %if.end.15

if.else:                                          ; preds = %do.body
  %8 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %8, i32 0, i32 1
  %9 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %9, i32 0, i32 4
  %10 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %11 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %10(%struct._object* %11)
  br label %if.end.15

if.end.15:                                        ; preds = %if.else, %if.then.14
  br label %do.end

do.end:                                           ; preds = %if.end.15
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.16:                                        ; preds = %if.end.9
  %12 = load %struct._object*, %struct._object** %priority, align 8
  %13 = load %struct._object*, %struct._object** %res, align 8
  %14 = bitcast %struct._object* %13 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %14, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %12, %struct._object** %arrayidx, align 8
  %15 = load %struct._object*, %struct._object** %res, align 8
  store %struct._object* %15, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.16, %do.end, %if.then.8, %if.then.3, %if.then
  %16 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %16
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_getscheduler(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %policy = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.242, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @sched_getscheduler(i32 %1) #4
  store i32 %call1, i32* %policy, align 4
  %2 = load i32, i32* %policy, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %policy, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_rr_get_interval(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %interval = alloca %struct.timespec, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.243, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @sched_rr_get_interval(i32 %1, %struct.timespec* %interval) #4
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %interval, i32 0, i32 0
  %2 = load i64, i64* %tv_sec, align 8
  %conv = sitofp i64 %2 to double
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %interval, i32 0, i32 1
  %3 = load i64, i64* %tv_nsec, align 8
  %conv6 = sitofp i64 %3 to double
  %mul = fmul double 1.000000e-09, %conv6
  %add = fadd double %conv, %mul
  %call7 = call %struct._object* @PyFloat_FromDouble(double %add)
  store %struct._object* %call7, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_setparam(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %param = alloca %struct.sched_param, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.244, i32 0, i32 0), i32* %pid, i32 (%struct._object*, %struct.sched_param*)* @convert_sched_param, %struct.sched_param* %param)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @sched_setparam(i32 %1, %struct.sched_param* %param) #4
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_setscheduler(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %policy = alloca i32, align 4
  %param = alloca %struct.sched_param, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.247, i32 0, i32 0), i32* %pid, i32* %policy, i32 (%struct._object*, %struct.sched_param*)* @convert_sched_param, %struct.sched_param* %param)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %2 = load i32, i32* %policy, align 4
  %call1 = call i32 @sched_setscheduler(i32 %1, i32 %2, %struct.sched_param* %param) #4
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_yield(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @sched_yield() #4
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %0, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_setaffinity(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %ncpus = alloca i32, align 4
  %setsize = alloca i64, align 8
  %mask = alloca %struct.cpu_set_t*, align 8
  %iterable = alloca %struct._object*, align 8
  %iterator = alloca %struct._object*, align 8
  %item = alloca %struct._object*, align 8
  %cpu = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp28 = alloca %struct._object*, align 8
  %newncpus = alloca i32, align 4
  %newmask = alloca %struct.cpu_set_t*, align 8
  %newsetsize = alloca i64, align 8
  %__cpu = alloca i64, align 8
  %tmp = alloca i64, align 8
  %_py_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp95 = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp123 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct.cpu_set_t* null, %struct.cpu_set_t** %mask, align 8
  store %struct._object* null, %struct._object** %iterator, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.248, i32 0, i32 0), i32* %pid, %struct._object** %iterable)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %iterable, align 8
  %call1 = call %struct._object* @PyObject_GetIter(%struct._object* %1)
  store %struct._object* %call1, %struct._object** %iterator, align 8
  %2 = load %struct._object*, %struct._object** %iterator, align 8
  %cmp = icmp eq %struct._object* %2, null
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  store i32 64, i32* %ncpus, align 4
  %3 = load i32, i32* %ncpus, align 4
  %conv = sext i32 %3 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  store i64 %mul, i64* %setsize, align 8
  %4 = load i32, i32* %ncpus, align 4
  %conv4 = sext i32 %4 to i64
  %call5 = call %struct.cpu_set_t* @__sched_cpualloc(i64 %conv4) #4
  store %struct.cpu_set_t* %call5, %struct.cpu_set_t** %mask, align 8
  %5 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %cmp6 = icmp eq %struct.cpu_set_t* %5, null
  br i1 %cmp6, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.3
  %call9 = call %struct._object* @PyErr_NoMemory()
  br label %error

if.end.10:                                        ; preds = %if.end.3
  br label %do.body

do.body:                                          ; preds = %if.end.10
  %6 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %7 = bitcast %struct.cpu_set_t* %6 to i8*
  %8 = load i64, i64* %setsize, align 8
  call void @llvm.memset.p0i8.i64(i8* %7, i8 0, i64 %8, i32 8, i1 false)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %do.end
  %9 = load %struct._object*, %struct._object** %iterator, align 8
  %call11 = call %struct._object* @PyIter_Next(%struct._object* %9)
  store %struct._object* %call11, %struct._object** %item, align 8
  %tobool12 = icmp ne %struct._object* %call11, null
  br i1 %tobool12, label %while.body, label %while.end.87

while.body:                                       ; preds = %while.cond
  %10 = load %struct._object*, %struct._object** %item, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %10, i32 0, i32 1
  %11 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %11, i32 0, i32 19
  %12 = load i64, i64* %tp_flags, align 8
  %and = and i64 %12, 16777216
  %cmp13 = icmp ne i64 %and, 0
  br i1 %cmp13, label %if.end.25, label %if.then.15

if.then.15:                                       ; preds = %while.body
  %13 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %14 = load %struct._object*, %struct._object** %item, align 8
  %ob_type16 = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 1
  %15 = load %struct._typeobject*, %struct._typeobject** %ob_type16, align 8
  %call17 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %13, i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.249, i32 0, i32 0), %struct._typeobject* %15)
  br label %do.body.18

do.body.18:                                       ; preds = %if.then.15
  %16 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %16, %struct._object** %_py_decref_tmp, align 8
  %17 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %17, i32 0, i32 0
  %18 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %18, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp19 = icmp ne i64 %dec, 0
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %do.body.18
  br label %if.end.23

if.else:                                          ; preds = %do.body.18
  %19 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type22 = getelementptr inbounds %struct._object, %struct._object* %19, i32 0, i32 1
  %20 = load %struct._typeobject*, %struct._typeobject** %ob_type22, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %20, i32 0, i32 4
  %21 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %22 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %21(%struct._object* %22)
  br label %if.end.23

if.end.23:                                        ; preds = %if.else, %if.then.21
  br label %do.end.24

do.end.24:                                        ; preds = %if.end.23
  br label %error

if.end.25:                                        ; preds = %while.body
  %23 = load %struct._object*, %struct._object** %item, align 8
  %call26 = call i64 @PyLong_AsLong(%struct._object* %23)
  store i64 %call26, i64* %cpu, align 8
  br label %do.body.27

do.body.27:                                       ; preds = %if.end.25
  %24 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %24, %struct._object** %_py_decref_tmp28, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp28, align 8
  %ob_refcnt29 = getelementptr inbounds %struct._object, %struct._object* %25, i32 0, i32 0
  %26 = load i64, i64* %ob_refcnt29, align 8
  %dec30 = add i64 %26, -1
  store i64 %dec30, i64* %ob_refcnt29, align 8
  %cmp31 = icmp ne i64 %dec30, 0
  br i1 %cmp31, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %do.body.27
  br label %if.end.37

if.else.34:                                       ; preds = %do.body.27
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp28, align 8
  %ob_type35 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 1
  %28 = load %struct._typeobject*, %struct._typeobject** %ob_type35, align 8
  %tp_dealloc36 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %28, i32 0, i32 4
  %29 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc36, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp28, align 8
  call void %29(%struct._object* %30)
  br label %if.end.37

if.end.37:                                        ; preds = %if.else.34, %if.then.33
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %31 = load i64, i64* %cpu, align 8
  %cmp39 = icmp slt i64 %31, 0
  br i1 %cmp39, label %if.then.41, label %if.end.46

if.then.41:                                       ; preds = %do.end.38
  %call42 = call %struct._object* @PyErr_Occurred()
  %tobool43 = icmp ne %struct._object* %call42, null
  br i1 %tobool43, label %if.end.45, label %if.then.44

if.then.44:                                       ; preds = %if.then.41
  %32 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %32, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.250, i32 0, i32 0))
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.44, %if.then.41
  br label %error

if.end.46:                                        ; preds = %do.end.38
  %33 = load i64, i64* %cpu, align 8
  %cmp47 = icmp sgt i64 %33, 2147483646
  br i1 %cmp47, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.end.46
  %34 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %34, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.251, i32 0, i32 0))
  br label %error

if.end.50:                                        ; preds = %if.end.46
  %35 = load i64, i64* %cpu, align 8
  %36 = load i32, i32* %ncpus, align 4
  %conv51 = sext i32 %36 to i64
  %cmp52 = icmp sge i64 %35, %conv51
  br i1 %cmp52, label %if.then.54, label %if.end.82

if.then.54:                                       ; preds = %if.end.50
  %37 = load i32, i32* %ncpus, align 4
  store i32 %37, i32* %newncpus, align 4
  br label %while.cond.55

while.cond.55:                                    ; preds = %if.end.67, %if.then.54
  %38 = load i32, i32* %newncpus, align 4
  %conv56 = sext i32 %38 to i64
  %39 = load i64, i64* %cpu, align 8
  %cmp57 = icmp sle i64 %conv56, %39
  br i1 %cmp57, label %while.body.59, label %while.end

while.body.59:                                    ; preds = %while.cond.55
  %40 = load i32, i32* %newncpus, align 4
  %cmp60 = icmp sgt i32 %40, 1073741823
  br i1 %cmp60, label %if.then.62, label %if.else.65

if.then.62:                                       ; preds = %while.body.59
  %41 = load i64, i64* %cpu, align 8
  %add63 = add i64 %41, 1
  %conv64 = trunc i64 %add63 to i32
  store i32 %conv64, i32* %newncpus, align 4
  br label %if.end.67

if.else.65:                                       ; preds = %while.body.59
  %42 = load i32, i32* %newncpus, align 4
  %mul66 = mul i32 %42, 2
  store i32 %mul66, i32* %newncpus, align 4
  br label %if.end.67

if.end.67:                                        ; preds = %if.else.65, %if.then.62
  br label %while.cond.55

while.end:                                        ; preds = %while.cond.55
  %43 = load i32, i32* %newncpus, align 4
  %conv68 = sext i32 %43 to i64
  %call69 = call %struct.cpu_set_t* @__sched_cpualloc(i64 %conv68) #4
  store %struct.cpu_set_t* %call69, %struct.cpu_set_t** %newmask, align 8
  %44 = load %struct.cpu_set_t*, %struct.cpu_set_t** %newmask, align 8
  %cmp70 = icmp eq %struct.cpu_set_t* %44, null
  br i1 %cmp70, label %if.then.72, label %if.end.74

if.then.72:                                       ; preds = %while.end
  %call73 = call %struct._object* @PyErr_NoMemory()
  br label %error

if.end.74:                                        ; preds = %while.end
  %45 = load i32, i32* %newncpus, align 4
  %conv75 = sext i32 %45 to i64
  %add76 = add i64 %conv75, 64
  %sub77 = sub i64 %add76, 1
  %div78 = udiv i64 %sub77, 64
  %mul79 = mul i64 %div78, 8
  store i64 %mul79, i64* %newsetsize, align 8
  br label %do.body.80

do.body.80:                                       ; preds = %if.end.74
  %46 = load %struct.cpu_set_t*, %struct.cpu_set_t** %newmask, align 8
  %47 = bitcast %struct.cpu_set_t* %46 to i8*
  %48 = load i64, i64* %newsetsize, align 8
  call void @llvm.memset.p0i8.i64(i8* %47, i8 0, i64 %48, i32 8, i1 false)
  br label %do.end.81

do.end.81:                                        ; preds = %do.body.80
  %49 = load %struct.cpu_set_t*, %struct.cpu_set_t** %newmask, align 8
  %50 = bitcast %struct.cpu_set_t* %49 to i8*
  %51 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %52 = bitcast %struct.cpu_set_t* %51 to i8*
  %53 = load i64, i64* %setsize, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %50, i8* %52, i64 %53, i32 8, i1 false)
  %54 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %54) #4
  %55 = load i64, i64* %newsetsize, align 8
  store i64 %55, i64* %setsize, align 8
  %56 = load %struct.cpu_set_t*, %struct.cpu_set_t** %newmask, align 8
  store %struct.cpu_set_t* %56, %struct.cpu_set_t** %mask, align 8
  %57 = load i32, i32* %newncpus, align 4
  store i32 %57, i32* %ncpus, align 4
  br label %if.end.82

if.end.82:                                        ; preds = %do.end.81, %if.end.50
  %58 = load i64, i64* %cpu, align 8
  store i64 %58, i64* %__cpu, align 8
  %59 = load i64, i64* %__cpu, align 8
  %60 = load i64, i64* %setsize, align 8
  %mul83 = mul i64 8, %60
  %cmp84 = icmp ult i64 %59, %mul83
  br i1 %cmp84, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.82
  %61 = load i64, i64* %__cpu, align 8
  %rem = urem i64 %61, 64
  %shl = shl i64 1, %rem
  %62 = load i64, i64* %__cpu, align 8
  %div86 = udiv i64 %62, 64
  %63 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %__bits = getelementptr inbounds %struct.cpu_set_t, %struct.cpu_set_t* %63, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], [16 x i64]* %__bits, i32 0, i32 0
  %arrayidx = getelementptr i64, i64* %arraydecay, i64 %div86
  %64 = load i64, i64* %arrayidx, align 8
  %or = or i64 %64, %shl
  store i64 %or, i64* %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.82
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %or, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, i64* %tmp
  %65 = load i64, i64* %tmp
  br label %while.cond

while.end.87:                                     ; preds = %while.cond
  br label %do.body.88

do.body.88:                                       ; preds = %while.end.87
  %66 = load %struct._object*, %struct._object** %iterator, align 8
  store %struct._object* %66, %struct._object** %_py_tmp, align 8
  %67 = load %struct._object*, %struct._object** %_py_tmp, align 8
  %cmp90 = icmp ne %struct._object* %67, null
  br i1 %cmp90, label %if.then.92, label %if.end.106

if.then.92:                                       ; preds = %do.body.88
  store %struct._object* null, %struct._object** %iterator, align 8
  br label %do.body.93

do.body.93:                                       ; preds = %if.then.92
  %68 = load %struct._object*, %struct._object** %_py_tmp, align 8
  store %struct._object* %68, %struct._object** %_py_decref_tmp95, align 8
  %69 = load %struct._object*, %struct._object** %_py_decref_tmp95, align 8
  %ob_refcnt96 = getelementptr inbounds %struct._object, %struct._object* %69, i32 0, i32 0
  %70 = load i64, i64* %ob_refcnt96, align 8
  %dec97 = add i64 %70, -1
  store i64 %dec97, i64* %ob_refcnt96, align 8
  %cmp98 = icmp ne i64 %dec97, 0
  br i1 %cmp98, label %if.then.100, label %if.else.101

if.then.100:                                      ; preds = %do.body.93
  br label %if.end.104

if.else.101:                                      ; preds = %do.body.93
  %71 = load %struct._object*, %struct._object** %_py_decref_tmp95, align 8
  %ob_type102 = getelementptr inbounds %struct._object, %struct._object* %71, i32 0, i32 1
  %72 = load %struct._typeobject*, %struct._typeobject** %ob_type102, align 8
  %tp_dealloc103 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %72, i32 0, i32 4
  %73 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc103, align 8
  %74 = load %struct._object*, %struct._object** %_py_decref_tmp95, align 8
  call void %73(%struct._object* %74)
  br label %if.end.104

if.end.104:                                       ; preds = %if.else.101, %if.then.100
  br label %do.end.105

do.end.105:                                       ; preds = %if.end.104
  br label %if.end.106

if.end.106:                                       ; preds = %do.end.105, %do.body.88
  br label %do.end.107

do.end.107:                                       ; preds = %if.end.106
  %75 = load i32, i32* %pid, align 4
  %76 = load i64, i64* %setsize, align 8
  %77 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %call108 = call i32 @sched_setaffinity(i32 %75, i64 %76, %struct.cpu_set_t* %77) #4
  %tobool109 = icmp ne i32 %call108, 0
  br i1 %tobool109, label %if.then.110, label %if.end.112

if.then.110:                                      ; preds = %do.end.107
  %call111 = call %struct._object* @posix_error()
  br label %error

if.end.112:                                       ; preds = %do.end.107
  %78 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %78) #4
  %79 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %79, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

error:                                            ; preds = %if.then.110, %if.then.72, %if.then.49, %if.end.45, %do.end.24, %if.then.8
  %80 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %tobool113 = icmp ne %struct.cpu_set_t* %80, null
  br i1 %tobool113, label %if.then.114, label %if.end.115

if.then.114:                                      ; preds = %error
  %81 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %81) #4
  br label %if.end.115

if.end.115:                                       ; preds = %if.then.114, %error
  br label %do.body.116

do.body.116:                                      ; preds = %if.end.115
  %82 = load %struct._object*, %struct._object** %iterator, align 8
  store %struct._object* %82, %struct._object** %_py_xdecref_tmp, align 8
  %83 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp118 = icmp ne %struct._object* %83, null
  br i1 %cmp118, label %if.then.120, label %if.end.134

if.then.120:                                      ; preds = %do.body.116
  br label %do.body.121

do.body.121:                                      ; preds = %if.then.120
  %84 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %84, %struct._object** %_py_decref_tmp123, align 8
  %85 = load %struct._object*, %struct._object** %_py_decref_tmp123, align 8
  %ob_refcnt124 = getelementptr inbounds %struct._object, %struct._object* %85, i32 0, i32 0
  %86 = load i64, i64* %ob_refcnt124, align 8
  %dec125 = add i64 %86, -1
  store i64 %dec125, i64* %ob_refcnt124, align 8
  %cmp126 = icmp ne i64 %dec125, 0
  br i1 %cmp126, label %if.then.128, label %if.else.129

if.then.128:                                      ; preds = %do.body.121
  br label %if.end.132

if.else.129:                                      ; preds = %do.body.121
  %87 = load %struct._object*, %struct._object** %_py_decref_tmp123, align 8
  %ob_type130 = getelementptr inbounds %struct._object, %struct._object* %87, i32 0, i32 1
  %88 = load %struct._typeobject*, %struct._typeobject** %ob_type130, align 8
  %tp_dealloc131 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %88, i32 0, i32 4
  %89 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc131, align 8
  %90 = load %struct._object*, %struct._object** %_py_decref_tmp123, align 8
  call void %89(%struct._object* %90)
  br label %if.end.132

if.end.132:                                       ; preds = %if.else.129, %if.then.128
  br label %do.end.133

do.end.133:                                       ; preds = %if.end.132
  br label %if.end.134

if.end.134:                                       ; preds = %do.end.133, %do.body.116
  br label %do.end.135

do.end.135:                                       ; preds = %if.end.134
  store %struct._object* null, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end.135, %if.end.112, %if.then.2, %if.then
  %91 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %91
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sched_getaffinity(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %cpu = alloca i32, align 4
  %ncpus = alloca i32, align 4
  %count = alloca i32, align 4
  %setsize = alloca i64, align 8
  %mask = alloca %struct.cpu_set_t*, align 8
  %res = alloca %struct._object*, align 8
  %__cpu = alloca i64, align 8
  %tmp = alloca i32, align 4
  %cpu_num = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp58 = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp80 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct.cpu_set_t* null, %struct.cpu_set_t** %mask, align 8
  store %struct._object* null, %struct._object** %res, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.252, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 64, i32* %ncpus, align 4
  br label %while.body

while.body:                                       ; preds = %if.end, %if.end.21
  %1 = load i32, i32* %ncpus, align 4
  %conv = sext i32 %1 to i64
  %add = add i64 %conv, 64
  %sub = sub i64 %add, 1
  %div = udiv i64 %sub, 64
  %mul = mul i64 %div, 8
  store i64 %mul, i64* %setsize, align 8
  %2 = load i32, i32* %ncpus, align 4
  %conv1 = sext i32 %2 to i64
  %call2 = call %struct.cpu_set_t* @__sched_cpualloc(i64 %conv1) #4
  store %struct.cpu_set_t* %call2, %struct.cpu_set_t** %mask, align 8
  %3 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %cmp = icmp eq %struct.cpu_set_t* %3, null
  br i1 %cmp, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %while.body
  %call5 = call %struct._object* @PyErr_NoMemory()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %while.body
  %4 = load i32, i32* %pid, align 4
  %5 = load i64, i64* %setsize, align 8
  %6 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %call7 = call i32 @sched_getaffinity(i32 %4, i64 %5, %struct.cpu_set_t* %6) #4
  %cmp8 = icmp eq i32 %call7, 0
  br i1 %cmp8, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.6
  br label %while.end

if.end.11:                                        ; preds = %if.end.6
  %7 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %7) #4
  %call12 = call i32* @__errno_location() #9
  %8 = load i32, i32* %call12, align 4
  %cmp13 = icmp ne i32 %8, 22
  br i1 %cmp13, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.end.11
  %call16 = call %struct._object* @posix_error()
  store %struct._object* %call16, %struct._object** %retval
  br label %return

if.end.17:                                        ; preds = %if.end.11
  %9 = load i32, i32* %ncpus, align 4
  %cmp18 = icmp sgt i32 %9, 1073741823
  br i1 %cmp18, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.end.17
  %10 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %10, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.253, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.21:                                        ; preds = %if.end.17
  %11 = load i32, i32* %ncpus, align 4
  %mul22 = mul i32 %11, 2
  store i32 %mul22, i32* %ncpus, align 4
  br label %while.body

while.end:                                        ; preds = %if.then.10
  %call23 = call %struct._object* @PySet_New(%struct._object* null)
  store %struct._object* %call23, %struct._object** %res, align 8
  %12 = load %struct._object*, %struct._object** %res, align 8
  %cmp24 = icmp eq %struct._object* %12, null
  br i1 %cmp24, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %while.end
  br label %error

if.end.27:                                        ; preds = %while.end
  store i32 0, i32* %cpu, align 4
  %13 = load i64, i64* %setsize, align 8
  %14 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %call28 = call i32 @__sched_cpucount(i64 %13, %struct.cpu_set_t* %14) #4
  store i32 %call28, i32* %count, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.27
  %15 = load i32, i32* %count, align 4
  %tobool29 = icmp ne i32 %15, 0
  br i1 %tobool29, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, i32* %cpu, align 4
  %conv30 = sext i32 %16 to i64
  store i64 %conv30, i64* %__cpu, align 8
  %17 = load i64, i64* %__cpu, align 8
  %18 = load i64, i64* %setsize, align 8
  %mul31 = mul i64 8, %18
  %cmp32 = icmp ult i64 %17, %mul31
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %19 = load i64, i64* %__cpu, align 8
  %div34 = udiv i64 %19, 64
  %20 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %__bits = getelementptr inbounds %struct.cpu_set_t, %struct.cpu_set_t* %20, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i64], [16 x i64]* %__bits, i32 0, i32 0
  %arrayidx = getelementptr i64, i64* %arraydecay, i64 %div34
  %21 = load i64, i64* %arrayidx, align 8
  %22 = load i64, i64* %__cpu, align 8
  %rem = urem i64 %22, 64
  %shl = shl i64 1, %rem
  %and = and i64 %21, %shl
  %cmp35 = icmp ne i64 %and, 0
  %conv36 = zext i1 %cmp35 to i32
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv36, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %tmp
  %23 = load i32, i32* %tmp
  %tobool37 = icmp ne i32 %23, 0
  br i1 %tobool37, label %if.then.38, label %if.end.69

if.then.38:                                       ; preds = %cond.end
  %24 = load i32, i32* %cpu, align 4
  %conv40 = sext i32 %24 to i64
  %call41 = call %struct._object* @PyLong_FromLong(i64 %conv40)
  store %struct._object* %call41, %struct._object** %cpu_num, align 8
  %25 = load i32, i32* %count, align 4
  %dec = add i32 %25, -1
  store i32 %dec, i32* %count, align 4
  %26 = load %struct._object*, %struct._object** %cpu_num, align 8
  %cmp42 = icmp eq %struct._object* %26, null
  br i1 %cmp42, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %if.then.38
  br label %error

if.end.45:                                        ; preds = %if.then.38
  %27 = load %struct._object*, %struct._object** %res, align 8
  %28 = load %struct._object*, %struct._object** %cpu_num, align 8
  %call46 = call i32 @PySet_Add(%struct._object* %27, %struct._object* %28)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.then.48, label %if.end.55

if.then.48:                                       ; preds = %if.end.45
  br label %do.body

do.body:                                          ; preds = %if.then.48
  %29 = load %struct._object*, %struct._object** %cpu_num, align 8
  store %struct._object* %29, %struct._object** %_py_decref_tmp, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %30, i32 0, i32 0
  %31 = load i64, i64* %ob_refcnt, align 8
  %dec50 = add i64 %31, -1
  store i64 %dec50, i64* %ob_refcnt, align 8
  %cmp51 = icmp ne i64 %dec50, 0
  br i1 %cmp51, label %if.then.53, label %if.else

if.then.53:                                       ; preds = %do.body
  br label %if.end.54

if.else:                                          ; preds = %do.body
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 1
  %33 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %33, i32 0, i32 4
  %34 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %34(%struct._object* %35)
  br label %if.end.54

if.end.54:                                        ; preds = %if.else, %if.then.53
  br label %do.end

do.end:                                           ; preds = %if.end.54
  br label %error

if.end.55:                                        ; preds = %if.end.45
  br label %do.body.56

do.body.56:                                       ; preds = %if.end.55
  %36 = load %struct._object*, %struct._object** %cpu_num, align 8
  store %struct._object* %36, %struct._object** %_py_decref_tmp58, align 8
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp58, align 8
  %ob_refcnt59 = getelementptr inbounds %struct._object, %struct._object* %37, i32 0, i32 0
  %38 = load i64, i64* %ob_refcnt59, align 8
  %dec60 = add i64 %38, -1
  store i64 %dec60, i64* %ob_refcnt59, align 8
  %cmp61 = icmp ne i64 %dec60, 0
  br i1 %cmp61, label %if.then.63, label %if.else.64

if.then.63:                                       ; preds = %do.body.56
  br label %if.end.67

if.else.64:                                       ; preds = %do.body.56
  %39 = load %struct._object*, %struct._object** %_py_decref_tmp58, align 8
  %ob_type65 = getelementptr inbounds %struct._object, %struct._object* %39, i32 0, i32 1
  %40 = load %struct._typeobject*, %struct._typeobject** %ob_type65, align 8
  %tp_dealloc66 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %40, i32 0, i32 4
  %41 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc66, align 8
  %42 = load %struct._object*, %struct._object** %_py_decref_tmp58, align 8
  call void %41(%struct._object* %42)
  br label %if.end.67

if.end.67:                                        ; preds = %if.else.64, %if.then.63
  br label %do.end.68

do.end.68:                                        ; preds = %if.end.67
  br label %if.end.69

if.end.69:                                        ; preds = %do.end.68, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.69
  %43 = load i32, i32* %cpu, align 4
  %inc = add i32 %43, 1
  store i32 %inc, i32* %cpu, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %44 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %44) #4
  %45 = load %struct._object*, %struct._object** %res, align 8
  store %struct._object* %45, %struct._object** %retval
  br label %return

error:                                            ; preds = %do.end, %if.then.44, %if.then.26
  %46 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  %tobool70 = icmp ne %struct.cpu_set_t* %46, null
  br i1 %tobool70, label %if.then.71, label %if.end.72

if.then.71:                                       ; preds = %error
  %47 = load %struct.cpu_set_t*, %struct.cpu_set_t** %mask, align 8
  call void @__sched_cpufree(%struct.cpu_set_t* %47) #4
  br label %if.end.72

if.end.72:                                        ; preds = %if.then.71, %error
  br label %do.body.73

do.body.73:                                       ; preds = %if.end.72
  %48 = load %struct._object*, %struct._object** %res, align 8
  store %struct._object* %48, %struct._object** %_py_xdecref_tmp, align 8
  %49 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp75 = icmp ne %struct._object* %49, null
  br i1 %cmp75, label %if.then.77, label %if.end.91

if.then.77:                                       ; preds = %do.body.73
  br label %do.body.78

do.body.78:                                       ; preds = %if.then.77
  %50 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %50, %struct._object** %_py_decref_tmp80, align 8
  %51 = load %struct._object*, %struct._object** %_py_decref_tmp80, align 8
  %ob_refcnt81 = getelementptr inbounds %struct._object, %struct._object* %51, i32 0, i32 0
  %52 = load i64, i64* %ob_refcnt81, align 8
  %dec82 = add i64 %52, -1
  store i64 %dec82, i64* %ob_refcnt81, align 8
  %cmp83 = icmp ne i64 %dec82, 0
  br i1 %cmp83, label %if.then.85, label %if.else.86

if.then.85:                                       ; preds = %do.body.78
  br label %if.end.89

if.else.86:                                       ; preds = %do.body.78
  %53 = load %struct._object*, %struct._object** %_py_decref_tmp80, align 8
  %ob_type87 = getelementptr inbounds %struct._object, %struct._object* %53, i32 0, i32 1
  %54 = load %struct._typeobject*, %struct._typeobject** %ob_type87, align 8
  %tp_dealloc88 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %54, i32 0, i32 4
  %55 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc88, align 8
  %56 = load %struct._object*, %struct._object** %_py_decref_tmp80, align 8
  call void %55(%struct._object* %56)
  br label %if.end.89

if.end.89:                                        ; preds = %if.else.86, %if.then.85
  br label %do.end.90

do.end.90:                                        ; preds = %if.end.89
  br label %if.end.91

if.end.91:                                        ; preds = %do.end.90, %do.body.73
  br label %do.end.92

do.end.92:                                        ; preds = %if.end.91
  store %struct._object* null, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end.92, %for.end, %if.then.20, %if.then.15, %if.then.4, %if.then
  %57 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %57
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_openpty(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %master_fd = alloca i32, align 4
  %slave_fd = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store i32 -1, i32* %master_fd, align 4
  store i32 -1, i32* %slave_fd, align 4
  %call = call i32 @openpty(i32* %master_fd, i32* %slave_fd, i8* null, %struct.termios* null, %struct.winsize* null) #4
  %cmp = icmp ne i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %posix_error

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %master_fd, align 4
  %call1 = call i32 @_Py_set_inheritable(i32 %0, i32 0, i32* null)
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  br label %error

if.end.4:                                         ; preds = %if.end
  %1 = load i32, i32* %slave_fd, align 4
  %call5 = call i32 @_Py_set_inheritable(i32 %1, i32 0, i32* null)
  %cmp6 = icmp slt i32 %call5, 0
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.4
  br label %error

if.end.8:                                         ; preds = %if.end.4
  %2 = load i32, i32* %master_fd, align 4
  %3 = load i32, i32* %slave_fd, align 4
  %call9 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.254, i32 0, i32 0), i32 %2, i32 %3)
  store %struct._object* %call9, %struct._object** %retval
  br label %return

posix_error:                                      ; preds = %if.then
  %call10 = call %struct._object* @posix_error()
  br label %error

error:                                            ; preds = %posix_error, %if.then.7, %if.then.3
  %4 = load i32, i32* %master_fd, align 4
  %cmp11 = icmp ne i32 %4, -1
  br i1 %cmp11, label %if.then.12, label %if.end.14

if.then.12:                                       ; preds = %error
  %5 = load i32, i32* %master_fd, align 4
  %call13 = call i32 @close(i32 %5)
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.12, %error
  %6 = load i32, i32* %slave_fd, align 4
  %cmp15 = icmp ne i32 %6, -1
  br i1 %cmp15, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %if.end.14
  %7 = load i32, i32* %slave_fd, align 4
  %call17 = call i32 @close(i32 %7)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %if.end.14
  store %struct._object* null, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.18, %if.end.8
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_forkpty(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %master_fd = alloca i32, align 4
  %result = alloca i32, align 4
  %pid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store i32 -1, i32* %master_fd, align 4
  store i32 0, i32* %result, align 4
  call void @_PyImport_AcquireLock()
  %call = call i32 @forkpty(i32* %master_fd, i8* null, %struct.termios* null, %struct.winsize* null) #4
  store i32 %call, i32* %pid, align 4
  %0 = load i32, i32* %pid, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @PyOS_AfterFork()
  br label %if.end

if.else:                                          ; preds = %entry
  %call1 = call i32 @_PyImport_ReleaseLock()
  store i32 %call1, i32* %result, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %1 = load i32, i32* %pid, align 4
  %cmp2 = icmp eq i32 %1, -1
  br i1 %cmp2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %2 = load i32, i32* %result, align 4
  %cmp6 = icmp slt i32 %2, 0
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end.5
  %3 = load %struct._object*, %struct._object** @PyExc_RuntimeError, align 8
  call void @PyErr_SetString(%struct._object* %3, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.238, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.8:                                         ; preds = %if.end.5
  %4 = load i32, i32* %pid, align 4
  %conv = sext i32 %4 to i64
  %call9 = call %struct._object* @PyLong_FromLong(i64 %conv)
  %5 = load i32, i32* %master_fd, align 4
  %call10 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.255, i32 0, i32 0), %struct._object* %call9, i32 %5)
  store %struct._object* %call10, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.7, %if.then.3
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getegid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getegid() #4
  %call1 = call %struct._object* @_PyLong_FromGid(i32 %call)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_geteuid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @geteuid() #4
  %call1 = call %struct._object* @_PyLong_FromUid(i32 %call)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getgid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getgid() #4
  %call1 = call %struct._object* @_PyLong_FromGid(i32 %call)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getgrouplist(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %user = alloca i8*, align 8
  %i = alloca i32, align 4
  %ngroups = alloca i32, align 4
  %list = alloca %struct._object*, align 8
  %groups = alloca i32*, align 8
  %basegid = alloca i32, align 4
  %o = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 65536, i32* %ngroups, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.256, i32 0, i32 0), i8** %user, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %basegid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %ngroups, align 4
  %conv = sext i32 %1 to i64
  %mul = mul i64 %conv, 4
  %call1 = call i8* @PyMem_Malloc(i64 %mul)
  %2 = bitcast i8* %call1 to i32*
  store i32* %2, i32** %groups, align 8
  %3 = load i32*, i32** %groups, align 8
  %cmp = icmp eq i32* %3, null
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @PyErr_NoMemory()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %4 = load i8*, i8** %user, align 8
  %5 = load i32, i32* %basegid, align 4
  %6 = load i32*, i32** %groups, align 8
  %call6 = call i32 @getgrouplist(i8* %4, i32 %5, i32* %6, i32* %ngroups)
  %cmp7 = icmp eq i32 %call6, -1
  br i1 %cmp7, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end.5
  %7 = load i32*, i32** %groups, align 8
  %8 = bitcast i32* %7 to i8*
  call void @PyMem_Free(i8* %8)
  %call10 = call %struct._object* @posix_error()
  store %struct._object* %call10, %struct._object** %retval
  br label %return

if.end.11:                                        ; preds = %if.end.5
  %9 = load i32, i32* %ngroups, align 4
  %conv12 = sext i32 %9 to i64
  %call13 = call %struct._object* @PyList_New(i64 %conv12)
  store %struct._object* %call13, %struct._object** %list, align 8
  %10 = load %struct._object*, %struct._object** %list, align 8
  %cmp14 = icmp eq %struct._object* %10, null
  br i1 %cmp14, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %if.end.11
  %11 = load i32*, i32** %groups, align 8
  %12 = bitcast i32* %11 to i8*
  call void @PyMem_Free(i8* %12)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.17:                                        ; preds = %if.end.11
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.17
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* %ngroups, align 4
  %cmp18 = icmp slt i32 %13, %14
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i32, i32* %i, align 4
  %idxprom = sext i32 %15 to i64
  %16 = load i32*, i32** %groups, align 8
  %arrayidx = getelementptr i32, i32* %16, i64 %idxprom
  %17 = load i32, i32* %arrayidx, align 4
  %call20 = call %struct._object* @_PyLong_FromGid(i32 %17)
  store %struct._object* %call20, %struct._object** %o, align 8
  %18 = load %struct._object*, %struct._object** %o, align 8
  %cmp21 = icmp eq %struct._object* %18, null
  br i1 %cmp21, label %if.then.23, label %if.end.28

if.then.23:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then.23
  %19 = load %struct._object*, %struct._object** %list, align 8
  store %struct._object* %19, %struct._object** %_py_decref_tmp, align 8
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 0
  %21 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %21, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp24 = icmp ne i64 %dec, 0
  br i1 %cmp24, label %if.then.26, label %if.else

if.then.26:                                       ; preds = %do.body
  br label %if.end.27

if.else:                                          ; preds = %do.body
  %22 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %22, i32 0, i32 1
  %23 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %23, i32 0, i32 4
  %24 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %24(%struct._object* %25)
  br label %if.end.27

if.end.27:                                        ; preds = %if.else, %if.then.26
  br label %do.end

do.end:                                           ; preds = %if.end.27
  %26 = load i32*, i32** %groups, align 8
  %27 = bitcast i32* %26 to i8*
  call void @PyMem_Free(i8* %27)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.28:                                        ; preds = %for.body
  %28 = load %struct._object*, %struct._object** %o, align 8
  %29 = load i32, i32* %i, align 4
  %idxprom29 = sext i32 %29 to i64
  %30 = load %struct._object*, %struct._object** %list, align 8
  %31 = bitcast %struct._object* %30 to %struct.PyListObject*
  %ob_item = getelementptr inbounds %struct.PyListObject, %struct.PyListObject* %31, i32 0, i32 1
  %32 = load %struct._object**, %struct._object*** %ob_item, align 8
  %arrayidx30 = getelementptr %struct._object*, %struct._object** %32, i64 %idxprom29
  store %struct._object* %28, %struct._object** %arrayidx30, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %33 = load i32, i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load i32*, i32** %groups, align 8
  %35 = bitcast i32* %34 to i8*
  call void @PyMem_Free(i8* %35)
  %36 = load %struct._object*, %struct._object** %list, align 8
  store %struct._object* %36, %struct._object** %retval
  br label %return

return:                                           ; preds = %for.end, %do.end, %if.then.16, %if.then.9, %if.then.3, %if.then
  %37 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %37
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getgroups(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %grouplist = alloca [65536 x i32], align 16
  %alt_grouplist = alloca i32*, align 8
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %o = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %arraydecay = getelementptr inbounds [65536 x i32], [65536 x i32]* %grouplist, i32 0, i32 0
  store i32* %arraydecay, i32** %alt_grouplist, align 8
  %arraydecay1 = getelementptr inbounds [65536 x i32], [65536 x i32]* %grouplist, i32 0, i32 0
  %call = call i32 @getgroups(i32 65536, i32* %arraydecay1) #4
  store i32 %call, i32* %n, align 4
  %0 = load i32, i32* %n, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end.29

if.then:                                          ; preds = %entry
  %call2 = call i32* @__errno_location() #9
  %1 = load i32, i32* %call2, align 4
  %cmp3 = icmp eq i32 %1, 22
  br i1 %cmp3, label %if.then.4, label %if.else.26

if.then.4:                                        ; preds = %if.then
  %call5 = call i32 @getgroups(i32 0, i32* null) #4
  store i32 %call5, i32* %n, align 4
  %2 = load i32, i32* %n, align 4
  %cmp6 = icmp eq i32 %2, -1
  br i1 %cmp6, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.then.4
  %call8 = call %struct._object* @posix_error()
  store %struct._object* %call8, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %if.then.4
  %3 = load i32, i32* %n, align 4
  %cmp9 = icmp eq i32 %3, 0
  br i1 %cmp9, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %if.end
  %arraydecay11 = getelementptr inbounds [65536 x i32], [65536 x i32]* %grouplist, i32 0, i32 0
  store i32* %arraydecay11, i32** %alt_grouplist, align 8
  br label %if.end.25

if.else:                                          ; preds = %if.end
  %4 = load i32, i32* %n, align 4
  %conv = sext i32 %4 to i64
  %mul = mul i64 %conv, 4
  %call12 = call i8* @PyMem_Malloc(i64 %mul)
  %5 = bitcast i8* %call12 to i32*
  store i32* %5, i32** %alt_grouplist, align 8
  %6 = load i32*, i32** %alt_grouplist, align 8
  %cmp13 = icmp eq i32* %6, null
  br i1 %cmp13, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %if.else
  %call16 = call i32* @__errno_location() #9
  store i32 22, i32* %call16, align 4
  %call17 = call %struct._object* @posix_error()
  store %struct._object* %call17, %struct._object** %retval
  br label %return

if.end.18:                                        ; preds = %if.else
  %7 = load i32, i32* %n, align 4
  %8 = load i32*, i32** %alt_grouplist, align 8
  %call19 = call i32 @getgroups(i32 %7, i32* %8) #4
  store i32 %call19, i32* %n, align 4
  %9 = load i32, i32* %n, align 4
  %cmp20 = icmp eq i32 %9, -1
  br i1 %cmp20, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %if.end.18
  %10 = load i32*, i32** %alt_grouplist, align 8
  %11 = bitcast i32* %10 to i8*
  call void @PyMem_Free(i8* %11)
  %call23 = call %struct._object* @posix_error()
  store %struct._object* %call23, %struct._object** %retval
  br label %return

if.end.24:                                        ; preds = %if.end.18
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.24, %if.then.10
  br label %if.end.28

if.else.26:                                       ; preds = %if.then
  %call27 = call %struct._object* @posix_error()
  store %struct._object* %call27, %struct._object** %retval
  br label %return

if.end.28:                                        ; preds = %if.end.25
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %entry
  %12 = load i32, i32* %n, align 4
  %conv30 = sext i32 %12 to i64
  %call31 = call %struct._object* @PyList_New(i64 %conv30)
  store %struct._object* %call31, %struct._object** %result, align 8
  %13 = load %struct._object*, %struct._object** %result, align 8
  %cmp32 = icmp ne %struct._object* %13, null
  br i1 %cmp32, label %if.then.34, label %if.end.49

if.then.34:                                       ; preds = %if.end.29
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.34
  %14 = load i32, i32* %i, align 4
  %15 = load i32, i32* %n, align 4
  %cmp35 = icmp slt i32 %14, %15
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load i32, i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %17 = load i32*, i32** %alt_grouplist, align 8
  %arrayidx = getelementptr i32, i32* %17, i64 %idxprom
  %18 = load i32, i32* %arrayidx, align 4
  %call37 = call %struct._object* @_PyLong_FromGid(i32 %18)
  store %struct._object* %call37, %struct._object** %o, align 8
  %19 = load %struct._object*, %struct._object** %o, align 8
  %cmp38 = icmp eq %struct._object* %19, null
  br i1 %cmp38, label %if.then.40, label %if.end.46

if.then.40:                                       ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then.40
  %20 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %20, %struct._object** %_py_decref_tmp, align 8
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %21, i32 0, i32 0
  %22 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %22, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp41 = icmp ne i64 %dec, 0
  br i1 %cmp41, label %if.then.43, label %if.else.44

if.then.43:                                       ; preds = %do.body
  br label %if.end.45

if.else.44:                                       ; preds = %do.body
  %23 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %23, i32 0, i32 1
  %24 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %24, i32 0, i32 4
  %25 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %26 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %25(%struct._object* %26)
  br label %if.end.45

if.end.45:                                        ; preds = %if.else.44, %if.then.43
  br label %do.end

do.end:                                           ; preds = %if.end.45
  store %struct._object* null, %struct._object** %result, align 8
  br label %for.end

if.end.46:                                        ; preds = %for.body
  %27 = load %struct._object*, %struct._object** %o, align 8
  %28 = load i32, i32* %i, align 4
  %idxprom47 = sext i32 %28 to i64
  %29 = load %struct._object*, %struct._object** %result, align 8
  %30 = bitcast %struct._object* %29 to %struct.PyListObject*
  %ob_item = getelementptr inbounds %struct.PyListObject, %struct.PyListObject* %30, i32 0, i32 1
  %31 = load %struct._object**, %struct._object*** %ob_item, align 8
  %arrayidx48 = getelementptr %struct._object*, %struct._object** %31, i64 %idxprom47
  store %struct._object* %27, %struct._object** %arrayidx48, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.46
  %32 = load i32, i32* %i, align 4
  %inc = add i32 %32, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %do.end, %for.cond
  br label %if.end.49

if.end.49:                                        ; preds = %for.end, %if.end.29
  %33 = load i32*, i32** %alt_grouplist, align 8
  %arraydecay50 = getelementptr inbounds [65536 x i32], [65536 x i32]* %grouplist, i32 0, i32 0
  %cmp51 = icmp ne i32* %33, %arraydecay50
  br i1 %cmp51, label %if.then.53, label %if.end.54

if.then.53:                                       ; preds = %if.end.49
  %34 = load i32*, i32** %alt_grouplist, align 8
  %35 = bitcast i32* %34 to i8*
  call void @PyMem_Free(i8* %35)
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.53, %if.end.49
  %36 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %36, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.54, %if.else.26, %if.then.22, %if.then.15, %if.then.7
  %37 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %37
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getpid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getpid() #4
  %conv = sext i32 %call to i64
  %call1 = call %struct._object* @PyLong_FromLong(i64 %conv)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getpgrp(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getpgrp() #4
  %conv = sext i32 %call to i64
  %call1 = call %struct._object* @PyLong_FromLong(i64 %conv)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getppid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getppid() #4
  %conv = sext i32 %call to i64
  %call1 = call %struct._object* @PyLong_FromLong(i64 %conv)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getuid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getuid() #4
  %call1 = call %struct._object* @_PyLong_FromUid(i32 %call)
  ret %struct._object* %call1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getlogin(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %name = alloca i8*, align 8
  %old_errno = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %call = call i32* @__errno_location() #9
  %0 = load i32, i32* %call, align 4
  store i32 %0, i32* %old_errno, align 4
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %call2 = call i8* @getlogin()
  store i8* %call2, i8** %name, align 8
  %1 = load i8*, i8** %name, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.else.6

if.then:                                          ; preds = %entry
  %call3 = call i32* @__errno_location() #9
  %2 = load i32, i32* %call3, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.then
  %call5 = call %struct._object* @posix_error()
  br label %if.end

if.else:                                          ; preds = %if.then
  %3 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  call void @PyErr_SetString(%struct._object* %3, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.257, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.4
  br label %if.end.8

if.else.6:                                        ; preds = %entry
  %4 = load i8*, i8** %name, align 8
  %call7 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %4)
  store %struct._object* %call7, %struct._object** %result, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.else.6, %if.end
  %5 = load i32, i32* %old_errno, align 4
  %call9 = call i32* @__errno_location() #9
  store i32 %5, i32* %call9, align 4
  %6 = load %struct._object*, %struct._object** %result, align 8
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_kill(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %sig = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.258, i32 0, i32 0), i32* %pid, i32* %sig)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %2 = load i32, i32* %sig, align 4
  %call1 = call i32 @kill(i32 %1, i32 %2) #4
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_killpg(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %sig = alloca i32, align 4
  %pgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.259, i32 0, i32 0), i32* %pgid, i32* %sig)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pgid, align 4
  %2 = load i32, i32* %sig, align 4
  %call1 = call i32 @killpg(i32 %1, i32 %2) #4
  %cmp = icmp eq i32 %call1, -1
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setuid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %uid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.260, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %uid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %uid, align 4
  %call1 = call i32 @setuid(i32 %1) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_seteuid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %euid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.261, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %euid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %euid, align 4
  %call1 = call i32 @seteuid(i32 %1) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.2, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setegid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %egid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.262, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %egid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %egid, align 4
  %call1 = call i32 @setegid(i32 %1) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.2, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setreuid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.263, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %ruid, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %euid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %ruid, align 4
  %2 = load i32, i32* %euid, align 4
  %call1 = call i32 @setreuid(i32 %1, i32 %2) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setregid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.264, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %rgid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %egid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %rgid, align 4
  %2 = load i32, i32* %egid, align 4
  %call1 = call i32 @setregid(i32 %1, i32 %2) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setgid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %gid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.265, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %gid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %gid, align 4
  %call1 = call i32 @setgid(i32 %1) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setgroups(%struct._object* %self, %struct._object* %groups) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %groups.addr = alloca %struct._object*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %grouplist = alloca [65536 x i32], align 16
  %elem = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp25 = alloca %struct._object*, align 8
  %_py_decref_tmp39 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %groups, %struct._object** %groups.addr, align 8
  %0 = load %struct._object*, %struct._object** %groups.addr, align 8
  %call = call i32 @PySequence_Check(%struct._object* %0)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %1, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.266, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._object*, %struct._object** %groups.addr, align 8
  %call1 = call i64 @PySequence_Size(%struct._object* %2)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %len, align 4
  %3 = load i32, i32* %len, align 4
  %cmp = icmp sgt i32 %3, 65536
  br i1 %cmp, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  %4 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.267, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.4
  %5 = load i32, i32* %i, align 4
  %6 = load i32, i32* %len, align 4
  %cmp5 = icmp slt i32 %5, %6
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct._object*, %struct._object** %groups.addr, align 8
  %8 = load i32, i32* %i, align 4
  %conv7 = sext i32 %8 to i64
  %call8 = call %struct._object* @PySequence_GetItem(%struct._object* %7, i64 %conv7)
  store %struct._object* %call8, %struct._object** %elem, align 8
  %9 = load %struct._object*, %struct._object** %elem, align 8
  %tobool9 = icmp ne %struct._object* %9, null
  br i1 %tobool9, label %if.end.11, label %if.then.10

if.then.10:                                       ; preds = %for.body
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.11:                                        ; preds = %for.body
  %10 = load %struct._object*, %struct._object** %elem, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %10, i32 0, i32 1
  %11 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %11, i32 0, i32 19
  %12 = load i64, i64* %tp_flags, align 8
  %and = and i64 %12, 16777216
  %cmp12 = icmp ne i64 %and, 0
  br i1 %cmp12, label %if.else.20, label %if.then.14

if.then.14:                                       ; preds = %if.end.11
  %13 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %13, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.268, i32 0, i32 0))
  br label %do.body

do.body:                                          ; preds = %if.then.14
  %14 = load %struct._object*, %struct._object** %elem, align 8
  store %struct._object* %14, %struct._object** %_py_decref_tmp, align 8
  %15 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %15, i32 0, i32 0
  %16 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %16, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp15 = icmp ne i64 %dec, 0
  br i1 %cmp15, label %if.then.17, label %if.else

if.then.17:                                       ; preds = %do.body
  br label %if.end.19

if.else:                                          ; preds = %do.body
  %17 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type18 = getelementptr inbounds %struct._object, %struct._object* %17, i32 0, i32 1
  %18 = load %struct._typeobject*, %struct._typeobject** %ob_type18, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %18, i32 0, i32 4
  %19 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %19(%struct._object* %20)
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.then.17
  br label %do.end

do.end:                                           ; preds = %if.end.19
  store %struct._object* null, %struct._object** %retval
  br label %return

if.else.20:                                       ; preds = %if.end.11
  %21 = load %struct._object*, %struct._object** %elem, align 8
  %22 = load i32, i32* %i, align 4
  %idxprom = sext i32 %22 to i64
  %arrayidx = getelementptr [65536 x i32], [65536 x i32]* %grouplist, i32 0, i64 %idxprom
  %23 = bitcast i32* %arrayidx to i8*
  %call21 = call i32 @_Py_Gid_Converter(%struct._object* %21, i8* %23)
  %tobool22 = icmp ne i32 %call21, 0
  br i1 %tobool22, label %if.end.36, label %if.then.23

if.then.23:                                       ; preds = %if.else.20
  br label %do.body.24

do.body.24:                                       ; preds = %if.then.23
  %24 = load %struct._object*, %struct._object** %elem, align 8
  store %struct._object* %24, %struct._object** %_py_decref_tmp25, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp25, align 8
  %ob_refcnt26 = getelementptr inbounds %struct._object, %struct._object* %25, i32 0, i32 0
  %26 = load i64, i64* %ob_refcnt26, align 8
  %dec27 = add i64 %26, -1
  store i64 %dec27, i64* %ob_refcnt26, align 8
  %cmp28 = icmp ne i64 %dec27, 0
  br i1 %cmp28, label %if.then.30, label %if.else.31

if.then.30:                                       ; preds = %do.body.24
  br label %if.end.34

if.else.31:                                       ; preds = %do.body.24
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp25, align 8
  %ob_type32 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 1
  %28 = load %struct._typeobject*, %struct._typeobject** %ob_type32, align 8
  %tp_dealloc33 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %28, i32 0, i32 4
  %29 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc33, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp25, align 8
  call void %29(%struct._object* %30)
  br label %if.end.34

if.end.34:                                        ; preds = %if.else.31, %if.then.30
  br label %do.end.35

do.end.35:                                        ; preds = %if.end.34
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.36:                                        ; preds = %if.else.20
  br label %if.end.37

if.end.37:                                        ; preds = %if.end.36
  br label %do.body.38

do.body.38:                                       ; preds = %if.end.37
  %31 = load %struct._object*, %struct._object** %elem, align 8
  store %struct._object* %31, %struct._object** %_py_decref_tmp39, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  %ob_refcnt40 = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 0
  %33 = load i64, i64* %ob_refcnt40, align 8
  %dec41 = add i64 %33, -1
  store i64 %dec41, i64* %ob_refcnt40, align 8
  %cmp42 = icmp ne i64 %dec41, 0
  br i1 %cmp42, label %if.then.44, label %if.else.45

if.then.44:                                       ; preds = %do.body.38
  br label %if.end.48

if.else.45:                                       ; preds = %do.body.38
  %34 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  %ob_type46 = getelementptr inbounds %struct._object, %struct._object* %34, i32 0, i32 1
  %35 = load %struct._typeobject*, %struct._typeobject** %ob_type46, align 8
  %tp_dealloc47 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %35, i32 0, i32 4
  %36 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc47, align 8
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  call void %36(%struct._object* %37)
  br label %if.end.48

if.end.48:                                        ; preds = %if.else.45, %if.then.44
  br label %do.end.49

do.end.49:                                        ; preds = %if.end.48
  br label %for.inc

for.inc:                                          ; preds = %do.end.49
  %38 = load i32, i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %39 = load i32, i32* %len, align 4
  %conv50 = sext i32 %39 to i64
  %arraydecay = getelementptr inbounds [65536 x i32], [65536 x i32]* %grouplist, i32 0, i32 0
  %call51 = call i32 @setgroups(i64 %conv50, i32* %arraydecay) #4
  %cmp52 = icmp slt i32 %call51, 0
  br i1 %cmp52, label %if.then.54, label %if.end.56

if.then.54:                                       ; preds = %for.end
  %call55 = call %struct._object* @posix_error()
  store %struct._object* %call55, %struct._object** %retval
  br label %return

if.end.56:                                        ; preds = %for.end
  %40 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc57 = add i64 %40, 1
  store i64 %inc57, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.56, %if.then.54, %do.end.35, %do.end, %if.then.10, %if.then.3, %if.then
  %41 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %41
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_initgroups(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %oname = alloca %struct._object*, align 8
  %username = alloca i8*, align 8
  %res = alloca i32, align 4
  %gid = alloca i32, align 4
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.269, i32 0, i32 0), i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %oname, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %gid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %oname, align 8
  %2 = bitcast %struct._object* %1 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  store i8* %arraydecay, i8** %username, align 8
  %3 = load i8*, i8** %username, align 8
  %4 = load i32, i32* %gid, align 4
  %call1 = call i32 @initgroups(i8* %3, i32 %4)
  store i32 %call1, i32* %res, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %5 = load %struct._object*, %struct._object** %oname, align 8
  store %struct._object* %5, %struct._object** %_py_decref_tmp, align 8
  %6 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %6, i32 0, i32 0
  %7 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %7, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp = icmp ne i64 %dec, 0
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %do.body
  br label %if.end.3

if.else:                                          ; preds = %do.body
  %8 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %8, i32 0, i32 1
  %9 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %9, i32 0, i32 4
  %10 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %11 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %10(%struct._object* %11)
  br label %if.end.3

if.end.3:                                         ; preds = %if.else, %if.then.2
  br label %do.end

do.end:                                           ; preds = %if.end.3
  %12 = load i32, i32* %res, align 4
  %cmp4 = icmp eq i32 %12, -1
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %do.end
  %13 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %call6 = call %struct._object* @PyErr_SetFromErrno(%struct._object* %13)
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %do.end
  %14 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %14, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.5, %if.then
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getpgid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %pgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.270, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @getpgid(i32 %1) #4
  store i32 %call1, i32* %pgid, align 4
  %2 = load i32, i32* %pgid, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %pgid, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setpgrp(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @setpgrp() #4
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %0, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_wait(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %agg.tmp = alloca %union.__WAIT_STATUS, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  store i32 0, i32* %status, align 4
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  %__iptr = bitcast %union.__WAIT_STATUS* %agg.tmp to i32**
  store i32* %status, i32** %__iptr, align 8
  %coerce.dive = getelementptr %union.__WAIT_STATUS, %union.__WAIT_STATUS* %agg.tmp, i32 0, i32 0
  %0 = load %union.wait*, %union.wait** %coerce.dive, align 8
  %call1 = call i32 @wait(%union.wait* %0)
  store i32 %call1, i32* %pid, align 4
  %1 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %1)
  %2 = load i32, i32* %pid, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call %struct._object* @posix_error()
  store %struct._object* %call2, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %pid, align 4
  %conv = sext i32 %3 to i64
  %call3 = call %struct._object* @PyLong_FromLong(i64 %conv)
  %4 = load i32, i32* %status, align 4
  %call4 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.271, i32 0, i32 0), %struct._object* %call3, i32 %4)
  store %struct._object* %call4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_wait3(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %options = alloca i32, align 4
  %ru = alloca %struct.rusage, align 8
  %status = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %agg.tmp = alloca %union.__WAIT_STATUS, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.272, i32 0, i32 0), i32* %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %__iptr = bitcast %union.__WAIT_STATUS* %agg.tmp to i32**
  store i32* %status, i32** %__iptr, align 8
  %1 = load i32, i32* %options, align 4
  %coerce.dive = getelementptr %union.__WAIT_STATUS, %union.__WAIT_STATUS* %agg.tmp, i32 0, i32 0
  %2 = load %union.wait*, %union.wait** %coerce.dive, align 8
  %call2 = call i32 @wait3(%union.wait* %2, i32 %1, %struct.rusage* %ru) #4
  store i32 %call2, i32* %pid, align 4
  %3 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  %4 = load i32, i32* %pid, align 4
  %5 = load i32, i32* %status, align 4
  %call3 = call %struct._object* @wait_helper(i32 %4, i32 %5, %struct.rusage* %ru)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_wait4(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %options = alloca i32, align 4
  %ru = alloca %struct.rusage, align 8
  %status = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %agg.tmp = alloca %union.__WAIT_STATUS, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.276, i32 0, i32 0), i32* %pid, i32* %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %pid, align 4
  %__iptr = bitcast %union.__WAIT_STATUS* %agg.tmp to i32**
  store i32* %status, i32** %__iptr, align 8
  %2 = load i32, i32* %options, align 4
  %coerce.dive = getelementptr %union.__WAIT_STATUS, %union.__WAIT_STATUS* %agg.tmp, i32 0, i32 0
  %3 = load %union.wait*, %union.wait** %coerce.dive, align 8
  %call2 = call i32 @wait4(i32 %1, %union.wait* %3, i32 %2, %struct.rusage* %ru) #4
  store i32 %call2, i32* %pid, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %pid, align 4
  %6 = load i32, i32* %status, align 4
  %call3 = call %struct._object* @wait_helper(i32 %5, i32 %6, %struct.rusage* %ru)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %7
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_waitid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %idtype = alloca i32, align 4
  %id = alloca i32, align 4
  %options = alloca i32, align 4
  %res = alloca i32, align 4
  %si = alloca %struct.siginfo_t, align 8
  %_save = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %_sifields = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 3
  %_kill = bitcast %union.anon.14* %_sifields to %struct.anon.15*
  %si_pid = getelementptr inbounds %struct.anon.15, %struct.anon.15* %_kill, i32 0, i32 0
  store i32 0, i32* %si_pid, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.277, i32 0, i32 0), i32* %idtype, i32* %id, i32* %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %idtype, align 4
  %2 = load i32, i32* %id, align 4
  %3 = load i32, i32* %options, align 4
  %call2 = call i32 @waitid(i32 %1, i32 %2, %struct.siginfo_t* %si, i32 %3)
  store i32 %call2, i32* %res, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %res, align 4
  %cmp = icmp eq i32 %5, -1
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %_sifields6 = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 3
  %_kill7 = bitcast %union.anon.14* %_sifields6 to %struct.anon.15*
  %si_pid8 = getelementptr inbounds %struct.anon.15, %struct.anon.15* %_kill7, i32 0, i32 0
  %6 = load i32, i32* %si_pid8, align 4
  %cmp9 = icmp eq i32 %6, 0
  br i1 %cmp9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.5
  %7 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

if.end.11:                                        ; preds = %if.end.5
  %call12 = call %struct._object* @PyStructSequence_New(%struct._typeobject* @WaitidResultType)
  store %struct._object* %call12, %struct._object** %result, align 8
  %8 = load %struct._object*, %struct._object** %result, align 8
  %tobool13 = icmp ne %struct._object* %8, null
  br i1 %tobool13, label %if.end.15, label %if.then.14

if.then.14:                                       ; preds = %if.end.11
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.15:                                        ; preds = %if.end.11
  %_sifields16 = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 3
  %_kill17 = bitcast %union.anon.14* %_sifields16 to %struct.anon.15*
  %si_pid18 = getelementptr inbounds %struct.anon.15, %struct.anon.15* %_kill17, i32 0, i32 0
  %9 = load i32, i32* %si_pid18, align 4
  %conv = sext i32 %9 to i64
  %call19 = call %struct._object* @PyLong_FromLong(i64 %conv)
  %10 = load %struct._object*, %struct._object** %result, align 8
  %11 = bitcast %struct._object* %10 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %11, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %call19, %struct._object** %arrayidx, align 8
  %_sifields20 = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 3
  %_kill21 = bitcast %union.anon.14* %_sifields20 to %struct.anon.15*
  %si_uid = getelementptr inbounds %struct.anon.15, %struct.anon.15* %_kill21, i32 0, i32 1
  %12 = load i32, i32* %si_uid, align 4
  %call22 = call %struct._object* @_PyLong_FromUid(i32 %12)
  %13 = load %struct._object*, %struct._object** %result, align 8
  %14 = bitcast %struct._object* %13 to %struct.PyTupleObject*
  %ob_item23 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %14, i32 0, i32 1
  %arrayidx24 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item23, i32 0, i64 1
  store %struct._object* %call22, %struct._object** %arrayidx24, align 8
  %si_signo = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 0
  %15 = load i32, i32* %si_signo, align 4
  %conv25 = sext i32 %15 to i64
  %call26 = call %struct._object* @PyLong_FromLong(i64 %conv25)
  %16 = load %struct._object*, %struct._object** %result, align 8
  %17 = bitcast %struct._object* %16 to %struct.PyTupleObject*
  %ob_item27 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %17, i32 0, i32 1
  %arrayidx28 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item27, i32 0, i64 2
  store %struct._object* %call26, %struct._object** %arrayidx28, align 8
  %_sifields29 = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 3
  %_sigchld = bitcast %union.anon.14* %_sifields29 to %struct.anon.18*
  %si_status = getelementptr inbounds %struct.anon.18, %struct.anon.18* %_sigchld, i32 0, i32 2
  %18 = load i32, i32* %si_status, align 4
  %conv30 = sext i32 %18 to i64
  %call31 = call %struct._object* @PyLong_FromLong(i64 %conv30)
  %19 = load %struct._object*, %struct._object** %result, align 8
  %20 = bitcast %struct._object* %19 to %struct.PyTupleObject*
  %ob_item32 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %20, i32 0, i32 1
  %arrayidx33 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item32, i32 0, i64 3
  store %struct._object* %call31, %struct._object** %arrayidx33, align 8
  %si_code = getelementptr inbounds %struct.siginfo_t, %struct.siginfo_t* %si, i32 0, i32 2
  %21 = load i32, i32* %si_code, align 4
  %conv34 = sext i32 %21 to i64
  %call35 = call %struct._object* @PyLong_FromLong(i64 %conv34)
  %22 = load %struct._object*, %struct._object** %result, align 8
  %23 = bitcast %struct._object* %22 to %struct.PyTupleObject*
  %ob_item36 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %23, i32 0, i32 1
  %arrayidx37 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item36, i32 0, i64 4
  store %struct._object* %call35, %struct._object** %arrayidx37, align 8
  %call38 = call %struct._object* @PyErr_Occurred()
  %tobool39 = icmp ne %struct._object* %call38, null
  br i1 %tobool39, label %if.then.40, label %if.end.45

if.then.40:                                       ; preds = %if.end.15
  br label %do.body

do.body:                                          ; preds = %if.then.40
  %24 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %24, %struct._object** %_py_decref_tmp, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %25, i32 0, i32 0
  %26 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %26, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp41 = icmp ne i64 %dec, 0
  br i1 %cmp41, label %if.then.43, label %if.else

if.then.43:                                       ; preds = %do.body
  br label %if.end.44

if.else:                                          ; preds = %do.body
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 1
  %28 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %28, i32 0, i32 4
  %29 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %29(%struct._object* %30)
  br label %if.end.44

if.end.44:                                        ; preds = %if.else, %if.then.43
  br label %do.end

do.end:                                           ; preds = %if.end.44
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.45:                                        ; preds = %if.end.15
  %31 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %31, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.45, %do.end, %if.then.14, %if.then.10, %if.then.3, %if.then
  %32 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %32
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_waitpid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %options = alloca i32, align 4
  %status = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.278, i32 0, i32 0), i32* %pid, i32* %options)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %pid, align 4
  %2 = load i32, i32* %options, align 4
  %call2 = call i32 @waitpid(i32 %1, i32* %status, i32 %2)
  store i32 %call2, i32* %pid, align 4
  %3 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  %4 = load i32, i32* %pid, align 4
  %cmp = icmp eq i32 %4, -1
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load i32, i32* %pid, align 4
  %conv = sext i32 %5 to i64
  %call6 = call %struct._object* @PyLong_FromLong(i64 %conv)
  %6 = load i32, i32* %status, align 4
  %call7 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.271, i32 0, i32 0), %struct._object* %call6, i32 %6)
  store %struct._object* %call7, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %7 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %7
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getsid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %sid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.279, i32 0, i32 0), i32* %pid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %call1 = call i32 @getsid(i32 %1) #4
  store i32 %call1, i32* %sid, align 4
  %2 = load i32, i32* %sid, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %sid, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setsid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @setsid() #4
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %0, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %1
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setpgid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pid = alloca i32, align 4
  %pgrp = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.280, i32 0, i32 0), i32* %pid, i32* %pgrp)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %2 = load i32, i32* %pgrp, align 4
  %call1 = call i32 @setpgid(i32 %1, i32 %2) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_tcgetpgrp(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %pgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.281, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %call1 = call i32 @tcgetpgrp(i32 %1) #4
  store i32 %call1, i32* %pgid, align 4
  %2 = load i32, i32* %pgid, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i32, i32* %pgid, align 4
  %conv = sext i32 %3 to i64
  %call5 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_tcsetpgrp(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %pgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.282, i32 0, i32 0), i32* %fd, i32* %pgid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %pgid, align 4
  %call1 = call i32 @tcsetpgrp(i32 %1, i32 %2) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_open(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %flags = alloca i32, align 4
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %fd = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %atomic_flag_works = alloca i32*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 511, i32* %mode, align 4
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  store i32* @_Py_open_cloexec_works, i32** %atomic_flag_works, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.105, i32 0, i32 0), i8** %function_name, align 8
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.284, i32 0, i32 0), i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @posix_open.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %flags, i32* %mode, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %flags, align 4
  %or = or i32 %3, 524288
  store i32 %or, i32* %flags, align 4
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %4 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %4, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %5 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow, align 8
  %7 = load i32, i32* %flags, align 4
  %8 = load i32, i32* %mode, align 4
  %call3 = call i32 (i32, i8*, i32, ...) @openat64(i32 %5, i8* %6, i32 %7, i32 %8)
  store i32 %call3, i32* %fd, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %9 = load i8*, i8** %narrow4, align 8
  %10 = load i32, i32* %flags, align 4
  %11 = load i32, i32* %mode, align 4
  %call5 = call i32 (i8*, i32, ...) @open64(i8* %9, i32 %10, i32 %11)
  store i32 %call5, i32* %fd, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %12 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %12)
  %13 = load i32, i32* %fd, align 4
  %cmp7 = icmp eq i32 %13, -1
  br i1 %cmp7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %14 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 8
  %15 = load %struct._object*, %struct._object** %object, align 8
  %call9 = call %struct._object* @PyErr_SetFromErrnoWithFilenameObject(%struct._object* %14, %struct._object* %15)
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  %16 = load i32, i32* %fd, align 4
  %17 = load i32*, i32** %atomic_flag_works, align 8
  %call11 = call i32 @_Py_set_inheritable(i32 %16, i32 0, i32* %17)
  %cmp12 = icmp slt i32 %call11, 0
  br i1 %cmp12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.end.10
  %18 = load i32, i32* %fd, align 4
  %call14 = call i32 @close(i32 %18)
  br label %exit

if.end.15:                                        ; preds = %if.end.10
  %19 = load i32, i32* %fd, align 4
  %conv = sext i32 %19 to i64
  %call16 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call16, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.15, %if.then.13, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %20 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %20, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %21 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %21
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_close_(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.285, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %call2 = call i32 @close(i32 %1)
  store i32 %call2, i32* %res, align 4
  %2 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %2)
  %3 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %4 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %4, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_closerange(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd_from = alloca i32, align 4
  %fd_to = alloca i32, align 4
  %i = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.286, i32 0, i32 0), i32* %fd_from, i32* %fd_to)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd_from, align 4
  store i32 %1, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %fd_to, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %call2 = call i32 @close(i32 %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i32, i32* %i, align 4
  %inc = add i32 %5, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc3 = add i64 %7, 1
  store i64 %inc3, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @device_encoding(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.287, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %call1 = call %struct._object* @_Py_device_encoding(i32 %1)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_dup(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.288, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %call1 = call i32 @_Py_dup(i32 %1)
  store i32 %call1, i32* %fd, align 4
  %2 = load i32, i32* %fd, align 4
  %cmp = icmp eq i32 %2, -1
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i32, i32* %fd, align 4
  %conv = sext i32 %3 to i64
  %call4 = call %struct._object* @PyLong_FromLong(i64 %conv)
  store %struct._object* %call4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.3, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_dup2(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %fd2 = alloca i32, align 4
  %inheritable = alloca i32, align 4
  %res = alloca i32, align 4
  %dup3_works = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %_save22 = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 1, i32* %inheritable, align 4
  store i32 -1, i32* %dup3_works, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %1 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %0, %struct._object* %1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.292, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_dup2.keywords, i32 0, i32 0), i32* %fd, i32* %fd2, i32* %inheritable)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %inheritable, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.end.17, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %3 = load i32, i32* %dup3_works, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then.2, label %if.end.17

if.then.2:                                        ; preds = %land.lhs.true
  %call3 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call3, %struct._ts** %_save, align 8
  %4 = load i32, i32* %fd, align 4
  %5 = load i32, i32* %fd2, align 4
  %call4 = call i32 @dup3(i32 %4, i32 %5, i32 524288) #4
  store i32 %call4, i32* %res, align 4
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i32, i32* %res, align 4
  %cmp5 = icmp slt i32 %7, 0
  br i1 %cmp5, label %if.then.6, label %if.end.16

if.then.6:                                        ; preds = %if.then.2
  %8 = load i32, i32* %dup3_works, align 4
  %cmp7 = icmp eq i32 %8, -1
  br i1 %cmp7, label %if.then.8, label %if.end.11

if.then.8:                                        ; preds = %if.then.6
  %call9 = call i32* @__errno_location() #9
  %9 = load i32, i32* %call9, align 4
  %cmp10 = icmp ne i32 %9, 38
  %conv = zext i1 %cmp10 to i32
  store i32 %conv, i32* %dup3_works, align 4
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.8, %if.then.6
  %10 = load i32, i32* %dup3_works, align 4
  %tobool12 = icmp ne i32 %10, 0
  br i1 %tobool12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.end.11
  %call14 = call %struct._object* @posix_error()
  store %struct._object* %call14, %struct._object** %retval
  br label %return

if.end.15:                                        ; preds = %if.end.11
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %if.then.2
  br label %if.end.17

if.end.17:                                        ; preds = %if.end.16, %land.lhs.true, %if.end
  %11 = load i32, i32* %inheritable, align 4
  %tobool18 = icmp ne i32 %11, 0
  br i1 %tobool18, label %if.then.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.17
  %12 = load i32, i32* %dup3_works, align 4
  %cmp19 = icmp eq i32 %12, 0
  br i1 %cmp19, label %if.then.21, label %if.end.38

if.then.21:                                       ; preds = %lor.lhs.false, %if.end.17
  %call23 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call23, %struct._ts** %_save22, align 8
  %13 = load i32, i32* %fd, align 4
  %14 = load i32, i32* %fd2, align 4
  %call24 = call i32 @dup2(i32 %13, i32 %14) #4
  store i32 %call24, i32* %res, align 4
  %15 = load %struct._ts*, %struct._ts** %_save22, align 8
  call void @PyEval_RestoreThread(%struct._ts* %15)
  %16 = load i32, i32* %res, align 4
  %cmp25 = icmp slt i32 %16, 0
  br i1 %cmp25, label %if.then.27, label %if.end.29

if.then.27:                                       ; preds = %if.then.21
  %call28 = call %struct._object* @posix_error()
  store %struct._object* %call28, %struct._object** %retval
  br label %return

if.end.29:                                        ; preds = %if.then.21
  %17 = load i32, i32* %inheritable, align 4
  %tobool30 = icmp ne i32 %17, 0
  br i1 %tobool30, label %if.end.37, label %land.lhs.true.31

land.lhs.true.31:                                 ; preds = %if.end.29
  %18 = load i32, i32* %fd2, align 4
  %call32 = call i32 @_Py_set_inheritable(i32 %18, i32 0, i32* null)
  %cmp33 = icmp slt i32 %call32, 0
  br i1 %cmp33, label %if.then.35, label %if.end.37

if.then.35:                                       ; preds = %land.lhs.true.31
  %19 = load i32, i32* %fd2, align 4
  %call36 = call i32 @close(i32 %19)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.37:                                        ; preds = %land.lhs.true.31, %if.end.29
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.37, %lor.lhs.false
  %20 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %20, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.38, %if.then.35, %if.then.27, %if.then.13, %if.then
  %21 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %21
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_lockf(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %cmd = alloca i32, align 4
  %res = alloca i32, align 4
  %len = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.293, i32 0, i32 0), i32* %fd, i32* %cmd, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %len)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %cmd, align 4
  %3 = load i64, i64* %len, align 8
  %call2 = call i32 @lockf64(i32 %1, i32 %2, i64 %3)
  store i32 %call2, i32* %res, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %5, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %6 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %6, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %7 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %7
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_lseek(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %how = alloca i32, align 4
  %pos = alloca i64, align 8
  %res = alloca i64, align 8
  %posobj = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.294, i32 0, i32 0), i32* %fd, %struct._object** %posobj, i32* %how)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %how, align 4
  switch i32 %1, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.1
    i32 2, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %if.end
  store i32 0, i32* %how, align 4
  br label %sw.epilog

sw.bb.1:                                          ; preds = %if.end
  store i32 1, i32* %how, align 4
  br label %sw.epilog

sw.bb.2:                                          ; preds = %if.end
  store i32 2, i32* %how, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.bb.2, %sw.bb.1, %sw.bb
  %2 = load %struct._object*, %struct._object** %posobj, align 8
  %call3 = call i64 @PyLong_AsLong(%struct._object* %2)
  store i64 %call3, i64* %pos, align 8
  %call4 = call %struct._object* @PyErr_Occurred()
  %tobool5 = icmp ne %struct._object* %call4, null
  br i1 %tobool5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %sw.epilog
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %sw.epilog
  %call8 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call8, %struct._ts** %_save, align 8
  %3 = load i32, i32* %fd, align 4
  %4 = load i64, i64* %pos, align 8
  %5 = load i32, i32* %how, align 4
  %call9 = call i64 @lseek64(i32 %3, i64 %4, i32 %5) #4
  store i64 %call9, i64* %res, align 8
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i64, i64* %res, align 8
  %cmp = icmp slt i64 %7, 0
  br i1 %cmp, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end.7
  %call11 = call %struct._object* @posix_error()
  store %struct._object* %call11, %struct._object** %retval
  br label %return

if.end.12:                                        ; preds = %if.end.7
  %8 = load i64, i64* %res, align 8
  %call13 = call %struct._object* @PyLong_FromLong(i64 %8)
  store %struct._object* %call13, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.12, %if.then.10, %if.then.6, %if.then
  %9 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %9
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_read(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %size = alloca i32, align 4
  %n = alloca i64, align 8
  %buffer = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.295, i32 0, i32 0), i32* %fd, i32* %size)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %size, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then.1, label %if.end.4

if.then.1:                                        ; preds = %if.end
  %call2 = call i32* @__errno_location() #9
  store i32 22, i32* %call2, align 4
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load i32, i32* %size, align 4
  %conv = sext i32 %2 to i64
  %call5 = call %struct._object* @PyBytes_FromStringAndSize(i8* null, i64 %conv)
  store %struct._object* %call5, %struct._object** %buffer, align 8
  %3 = load %struct._object*, %struct._object** %buffer, align 8
  %cmp6 = icmp eq %struct._object* %3, null
  br i1 %cmp6, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.4
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.4
  %call10 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call10, %struct._ts** %_save, align 8
  %4 = load i32, i32* %fd, align 4
  %5 = load %struct._object*, %struct._object** %buffer, align 8
  %6 = bitcast %struct._object* %5 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %6, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  %7 = load i32, i32* %size, align 4
  %conv11 = sext i32 %7 to i64
  %call12 = call i64 @read(i32 %4, i8* %arraydecay, i64 %conv11)
  store i64 %call12, i64* %n, align 8
  %8 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %8)
  %9 = load i64, i64* %n, align 8
  %cmp13 = icmp slt i64 %9, 0
  br i1 %cmp13, label %if.then.15, label %if.end.21

if.then.15:                                       ; preds = %if.end.9
  br label %do.body

do.body:                                          ; preds = %if.then.15
  %10 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %10, %struct._object** %_py_decref_tmp, align 8
  %11 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %11, i32 0, i32 0
  %12 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %12, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp16 = icmp ne i64 %dec, 0
  br i1 %cmp16, label %if.then.18, label %if.else

if.then.18:                                       ; preds = %do.body
  br label %if.end.19

if.else:                                          ; preds = %do.body
  %13 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %13, i32 0, i32 1
  %14 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %14, i32 0, i32 4
  %15 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %15(%struct._object* %16)
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.then.18
  br label %do.end

do.end:                                           ; preds = %if.end.19
  %call20 = call %struct._object* @posix_error()
  store %struct._object* %call20, %struct._object** %retval
  br label %return

if.end.21:                                        ; preds = %if.end.9
  %17 = load i64, i64* %n, align 8
  %18 = load i32, i32* %size, align 4
  %conv22 = sext i32 %18 to i64
  %cmp23 = icmp ne i64 %17, %conv22
  br i1 %cmp23, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %19 = load i64, i64* %n, align 8
  %call26 = call i32 @_PyBytes_Resize(%struct._object** %buffer, i64 %19)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %20 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %20, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.27, %do.end, %if.then.8, %if.then.1, %if.then
  %21 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %21
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_readv(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %cnt = alloca i32, align 4
  %n = alloca i64, align 8
  %seq = alloca %struct._object*, align 8
  %iov = alloca %struct.iovec*, align 8
  %buf = alloca %struct.bufferinfo*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.296, i32 0, i32 0), i32* %fd, %struct._object** %seq)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %seq, align 8
  %call1 = call i32 @PySequence_Check(%struct._object* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end.4, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.297, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load %struct._object*, %struct._object** %seq, align 8
  %call5 = call i64 @PySequence_Size(%struct._object* %3)
  %conv = trunc i64 %call5 to i32
  store i32 %conv, i32* %cnt, align 4
  %4 = load %struct._object*, %struct._object** %seq, align 8
  %5 = load i32, i32* %cnt, align 4
  %call6 = call i64 @iov_setup(%struct.iovec** %iov, %struct.bufferinfo** %buf, %struct._object* %4, i32 %5, i32 1)
  %cmp = icmp slt i64 %call6, 0
  br i1 %cmp, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.4
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.4
  %call10 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call10, %struct._ts** %_save, align 8
  %6 = load i32, i32* %fd, align 4
  %7 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %8 = load i32, i32* %cnt, align 4
  %call11 = call i64 @readv(i32 %6, %struct.iovec* %7, i32 %8)
  store i64 %call11, i64* %n, align 8
  %9 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %9)
  %10 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %11 = load %struct.bufferinfo*, %struct.bufferinfo** %buf, align 8
  %12 = load i32, i32* %cnt, align 4
  call void @iov_cleanup(%struct.iovec* %10, %struct.bufferinfo* %11, i32 %12)
  %13 = load i64, i64* %n, align 8
  %cmp12 = icmp slt i64 %13, 0
  br i1 %cmp12, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %if.end.9
  %call15 = call %struct._object* @posix_error()
  store %struct._object* %call15, %struct._object** %retval
  br label %return

if.end.16:                                        ; preds = %if.end.9
  %14 = load i64, i64* %n, align 8
  %call17 = call %struct._object* @PyLong_FromSsize_t(i64 %14)
  store %struct._object* %call17, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.14, %if.then.8, %if.then.3, %if.then
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_pread(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %size = alloca i32, align 4
  %offset = alloca i64, align 8
  %n = alloca i64, align 8
  %buffer = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.298, i32 0, i32 0), i32* %fd, i32* %size, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %offset)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %size, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then.1, label %if.end.4

if.then.1:                                        ; preds = %if.end
  %call2 = call i32* @__errno_location() #9
  store i32 22, i32* %call2, align 4
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %2 = load i32, i32* %size, align 4
  %conv = sext i32 %2 to i64
  %call5 = call %struct._object* @PyBytes_FromStringAndSize(i8* null, i64 %conv)
  store %struct._object* %call5, %struct._object** %buffer, align 8
  %3 = load %struct._object*, %struct._object** %buffer, align 8
  %cmp6 = icmp eq %struct._object* %3, null
  br i1 %cmp6, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.4
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.4
  %call10 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call10, %struct._ts** %_save, align 8
  %4 = load i32, i32* %fd, align 4
  %5 = load %struct._object*, %struct._object** %buffer, align 8
  %6 = bitcast %struct._object* %5 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %6, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  %7 = load i32, i32* %size, align 4
  %conv11 = sext i32 %7 to i64
  %8 = load i64, i64* %offset, align 8
  %call12 = call i64 @pread64(i32 %4, i8* %arraydecay, i64 %conv11, i64 %8)
  store i64 %call12, i64* %n, align 8
  %9 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %9)
  %10 = load i64, i64* %n, align 8
  %cmp13 = icmp slt i64 %10, 0
  br i1 %cmp13, label %if.then.15, label %if.end.21

if.then.15:                                       ; preds = %if.end.9
  br label %do.body

do.body:                                          ; preds = %if.then.15
  %11 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %11, %struct._object** %_py_decref_tmp, align 8
  %12 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %12, i32 0, i32 0
  %13 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %13, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp16 = icmp ne i64 %dec, 0
  br i1 %cmp16, label %if.then.18, label %if.else

if.then.18:                                       ; preds = %do.body
  br label %if.end.19

if.else:                                          ; preds = %do.body
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 1
  %15 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %15, i32 0, i32 4
  %16 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %17 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %16(%struct._object* %17)
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.then.18
  br label %do.end

do.end:                                           ; preds = %if.end.19
  %call20 = call %struct._object* @posix_error()
  store %struct._object* %call20, %struct._object** %retval
  br label %return

if.end.21:                                        ; preds = %if.end.9
  %18 = load i64, i64* %n, align 8
  %19 = load i32, i32* %size, align 4
  %conv22 = sext i32 %19 to i64
  %cmp23 = icmp ne i64 %18, %conv22
  br i1 %cmp23, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %20 = load i64, i64* %n, align 8
  %call26 = call i32 @_PyBytes_Resize(%struct._object** %buffer, i64 %20)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %21 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %21, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.27, %do.end, %if.then.8, %if.then.1, %if.then
  %22 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %22
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_write(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pbuf = alloca %struct.bufferinfo, align 8
  %fd = alloca i32, align 4
  %size = alloca i64, align 8
  %len = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.299, i32 0, i32 0), i32* %fd, %struct.bufferinfo* %pbuf)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %len1 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %pbuf, i32 0, i32 2
  %1 = load i64, i64* %len1, align 8
  store i64 %1, i64* %len, align 8
  %call2 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call2, %struct._ts** %_save, align 8
  %2 = load i32, i32* %fd, align 4
  %buf = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %pbuf, i32 0, i32 0
  %3 = load i8*, i8** %buf, align 8
  %4 = load i64, i64* %len, align 8
  %call3 = call i64 @write(i32 %2, i8* %3, i64 %4)
  store i64 %call3, i64* %size, align 8
  %5 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %5)
  call void @PyBuffer_Release(%struct.bufferinfo* %pbuf)
  %6 = load i64, i64* %size, align 8
  %cmp = icmp slt i64 %6, 0
  br i1 %cmp, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %call5 = call %struct._object* @posix_error()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %7 = load i64, i64* %size, align 8
  %call7 = call %struct._object* @PyLong_FromSsize_t(i64 %7)
  store %struct._object* %call7, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.4, %if.then
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_writev(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %cnt = alloca i32, align 4
  %res = alloca i64, align 8
  %seq = alloca %struct._object*, align 8
  %iov = alloca %struct.iovec*, align 8
  %buf = alloca %struct.bufferinfo*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.300, i32 0, i32 0), i32* %fd, %struct._object** %seq)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %seq, align 8
  %call1 = call i32 @PySequence_Check(%struct._object* %1)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end.4, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.301, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load %struct._object*, %struct._object** %seq, align 8
  %call5 = call i64 @PySequence_Size(%struct._object* %3)
  %conv = trunc i64 %call5 to i32
  store i32 %conv, i32* %cnt, align 4
  %4 = load %struct._object*, %struct._object** %seq, align 8
  %5 = load i32, i32* %cnt, align 4
  %call6 = call i64 @iov_setup(%struct.iovec** %iov, %struct.bufferinfo** %buf, %struct._object* %4, i32 %5, i32 0)
  %cmp = icmp slt i64 %call6, 0
  br i1 %cmp, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.4
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end.4
  %call10 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call10, %struct._ts** %_save, align 8
  %6 = load i32, i32* %fd, align 4
  %7 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %8 = load i32, i32* %cnt, align 4
  %call11 = call i64 @writev(i32 %6, %struct.iovec* %7, i32 %8)
  store i64 %call11, i64* %res, align 8
  %9 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %9)
  %10 = load %struct.iovec*, %struct.iovec** %iov, align 8
  %11 = load %struct.bufferinfo*, %struct.bufferinfo** %buf, align 8
  %12 = load i32, i32* %cnt, align 4
  call void @iov_cleanup(%struct.iovec* %10, %struct.bufferinfo* %11, i32 %12)
  %13 = load i64, i64* %res, align 8
  %cmp12 = icmp slt i64 %13, 0
  br i1 %cmp12, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %if.end.9
  %call15 = call %struct._object* @posix_error()
  store %struct._object* %call15, %struct._object** %retval
  br label %return

if.end.16:                                        ; preds = %if.end.9
  %14 = load i64, i64* %res, align 8
  %call17 = call %struct._object* @PyLong_FromSsize_t(i64 %14)
  store %struct._object* %call17, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.14, %if.then.8, %if.then.3, %if.then
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_pwrite(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %pbuf = alloca %struct.bufferinfo, align 8
  %fd = alloca i32, align 4
  %offset = alloca i64, align 8
  %size = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.302, i32 0, i32 0), i32* %fd, %struct.bufferinfo* %pbuf, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %offset)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %buf = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %pbuf, i32 0, i32 0
  %2 = load i8*, i8** %buf, align 8
  %len = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %pbuf, i32 0, i32 2
  %3 = load i64, i64* %len, align 8
  %4 = load i64, i64* %offset, align 8
  %call2 = call i64 @pwrite64(i32 %1, i8* %2, i64 %3, i64 %4)
  store i64 %call2, i64* %size, align 8
  %5 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %5)
  call void @PyBuffer_Release(%struct.bufferinfo* %pbuf)
  %6 = load i64, i64* %size, align 8
  %cmp = icmp slt i64 %6, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %7 = load i64, i64* %size, align 8
  %call6 = call %struct._object* @PyLong_FromSsize_t(i64 %7)
  store %struct._object* %call6, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sendfile(%struct._object* %self, %struct._object* %args, %struct._object* %kwdict) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwdict.addr = alloca %struct._object*, align 8
  %in = alloca i32, align 4
  %out = alloca i32, align 4
  %ret = alloca i64, align 8
  %offset = alloca i64, align 8
  %count = alloca i64, align 8
  %offobj = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  %_save14 = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwdict, %struct._object** %kwdict.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %1 = load %struct._object*, %struct._object** %kwdict.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %0, %struct._object* %1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.307, i32 0, i32 0), i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @posix_sendfile.keywords, i32 0, i32 0), i32* %out, i32* %in, %struct._object** %offobj, i64* %count)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._object*, %struct._object** %offobj, align 8
  %cmp = icmp eq %struct._object* %2, @_Py_NoneStruct
  br i1 %cmp, label %if.then.1, label %if.end.9

if.then.1:                                        ; preds = %if.end
  %call2 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call2, %struct._ts** %_save, align 8
  %3 = load i32, i32* %out, align 4
  %4 = load i32, i32* %in, align 4
  %5 = load i64, i64* %count, align 8
  %call3 = call i64 @sendfile64(i32 %3, i32 %4, i64* null, i64 %5) #4
  store i64 %call3, i64* %ret, align 8
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i64, i64* %ret, align 8
  %cmp4 = icmp slt i64 %7, 0
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %if.then.1
  %call6 = call %struct._object* @posix_error()
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %if.then.1
  %8 = load i64, i64* %ret, align 8
  %call8 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.308, i32 0, i32 0), i64 %8)
  store %struct._object* %call8, %struct._object** %retval
  br label %return

if.end.9:                                         ; preds = %if.end
  %9 = load %struct._object*, %struct._object** %offobj, align 8
  %10 = bitcast i64* %offset to i8*
  %call10 = call i32 @_parse_off_t(%struct._object* %9, i8* %10)
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end.13, label %if.then.12

if.then.12:                                       ; preds = %if.end.9
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.13:                                        ; preds = %if.end.9
  %call15 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call15, %struct._ts** %_save14, align 8
  %11 = load i32, i32* %out, align 4
  %12 = load i32, i32* %in, align 4
  %13 = load i64, i64* %count, align 8
  %call16 = call i64 @sendfile64(i32 %11, i32 %12, i64* %offset, i64 %13) #4
  store i64 %call16, i64* %ret, align 8
  %14 = load %struct._ts*, %struct._ts** %_save14, align 8
  call void @PyEval_RestoreThread(%struct._ts* %14)
  %15 = load i64, i64* %ret, align 8
  %cmp17 = icmp slt i64 %15, 0
  br i1 %cmp17, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.end.13
  %call19 = call %struct._object* @posix_error()
  store %struct._object* %call19, %struct._object** %retval
  br label %return

if.end.20:                                        ; preds = %if.end.13
  %16 = load i64, i64* %ret, align 8
  %call21 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.308, i32 0, i32 0), i64 %16)
  store %struct._object* %call21, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.20, %if.then.18, %if.then.12, %if.end.7, %if.then.5, %if.then
  %17 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %17
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fstat(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.309, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %call2 = call i32 @fstat64(i32 %1, %struct.stat* %st) #4
  store i32 %call2, i32* %res, align 4
  %2 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %2)
  %3 = load i32, i32* %res, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %call6 = call %struct._object* @_pystat_fromstructstat(%struct.stat* %st)
  store %struct._object* %call6, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_isatty(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.310, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %call1 = call i32 @isatty(i32 %1) #4
  %conv = sext i32 %call1 to i64
  %call2 = call %struct._object* @PyBool_FromLong(i64 %conv)
  store %struct._object* %call2, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_pipe(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %fds = alloca [2 x i32], align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %_save4 = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %fds, i32 0, i32 0
  %call1 = call i32 @pipe2(i32* %arraydecay, i32 524288) #4
  store i32 %call1, i32* %res, align 4
  %0 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %0)
  %1 = load i32, i32* %res, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %land.lhs.true, label %if.end.27

land.lhs.true:                                    ; preds = %entry
  %call2 = call i32* @__errno_location() #9
  %2 = load i32, i32* %call2, align 4
  %cmp3 = icmp eq i32 %2, 38
  br i1 %cmp3, label %if.then, label %if.end.27

if.then:                                          ; preds = %land.lhs.true
  %call5 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call5, %struct._ts** %_save4, align 8
  %arraydecay6 = getelementptr inbounds [2 x i32], [2 x i32]* %fds, i32 0, i32 0
  %call7 = call i32 @pipe(i32* %arraydecay6) #4
  store i32 %call7, i32* %res, align 4
  %3 = load %struct._ts*, %struct._ts** %_save4, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  %4 = load i32, i32* %res, align 4
  %cmp8 = icmp eq i32 %4, 0
  br i1 %cmp8, label %if.then.9, label %if.end.26

if.then.9:                                        ; preds = %if.then
  %arrayidx = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 0
  %5 = load i32, i32* %arrayidx, align 4
  %call10 = call i32 @_Py_set_inheritable(i32 %5, i32 0, i32* null)
  %cmp11 = icmp slt i32 %call10, 0
  br i1 %cmp11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.9
  %arrayidx13 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 0
  %6 = load i32, i32* %arrayidx13, align 4
  %call14 = call i32 @close(i32 %6)
  %arrayidx15 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 1
  %7 = load i32, i32* %arrayidx15, align 4
  %call16 = call i32 @close(i32 %7)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %if.then.9
  %arrayidx17 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 1
  %8 = load i32, i32* %arrayidx17, align 4
  %call18 = call i32 @_Py_set_inheritable(i32 %8, i32 0, i32* null)
  %cmp19 = icmp slt i32 %call18, 0
  br i1 %cmp19, label %if.then.20, label %if.end.25

if.then.20:                                       ; preds = %if.end
  %arrayidx21 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 0
  %9 = load i32, i32* %arrayidx21, align 4
  %call22 = call i32 @close(i32 %9)
  %arrayidx23 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 1
  %10 = load i32, i32* %arrayidx23, align 4
  %call24 = call i32 @close(i32 %10)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.25:                                        ; preds = %if.end
  br label %if.end.26

if.end.26:                                        ; preds = %if.end.25, %if.then
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26, %land.lhs.true, %entry
  %11 = load i32, i32* %res, align 4
  %cmp28 = icmp ne i32 %11, 0
  br i1 %cmp28, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.27
  %12 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %call30 = call %struct._object* @PyErr_SetFromErrno(%struct._object* %12)
  store %struct._object* %call30, %struct._object** %retval
  br label %return

if.end.31:                                        ; preds = %if.end.27
  %arrayidx32 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 0
  %13 = load i32, i32* %arrayidx32, align 4
  %arrayidx33 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 1
  %14 = load i32, i32* %arrayidx33, align 4
  %call34 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.254, i32 0, i32 0), i32 %13, i32 %14)
  store %struct._object* %call34, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.31, %if.then.29, %if.then.20, %if.then.12
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_pipe2(%struct._object* %self, %struct._object* %arg) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %arg.addr = alloca %struct._object*, align 8
  %flags = alloca i32, align 4
  %fds = alloca [2 x i32], align 4
  %res = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %call = call i32 @_PyLong_AsInt(%struct._object* %0)
  store i32 %call, i32* %flags, align 4
  %1 = load i32, i32* %flags, align 4
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call1 = call %struct._object* @PyErr_Occurred()
  %tobool = icmp ne %struct._object* %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %arraydecay = getelementptr inbounds [2 x i32], [2 x i32]* %fds, i32 0, i32 0
  %2 = load i32, i32* %flags, align 4
  %call2 = call i32 @pipe2(i32* %arraydecay, i32 %2) #4
  store i32 %call2, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  %cmp3 = icmp ne i32 %3, 0
  br i1 %cmp3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %call5 = call %struct._object* @posix_error()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %arrayidx = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 0
  %4 = load i32, i32* %arrayidx, align 4
  %arrayidx7 = getelementptr [2 x i32], [2 x i32]* %fds, i32 0, i64 1
  %5 = load i32, i32* %arrayidx7, align 4
  %call8 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.254, i32 0, i32 0), i32 %4, i32 %5)
  store %struct._object* %call8, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.4, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_mkfifo(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 438, i32* %mode, align 4
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.311, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_mkfifo.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %mode, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %6 = load i32, i32* %mode, align 4
  %call3 = call i32 @mkfifoat(i32 %4, i8* %5, i32 %6) #4
  store i32 %call3, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %7 = load i8*, i8** %narrow4, align 8
  %8 = load i32, i32* %mode, align 4
  %call5 = call i32 @mkfifo(i8* %7, i32 %8) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %9 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %9)
  %10 = load i32, i32* %result, align 4
  %cmp7 = icmp slt i32 %10, 0
  br i1 %cmp7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @posix_error()
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %11 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %11, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %12 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %12, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %13 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %13
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_mknod(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %mode = alloca i32, align 4
  %device = alloca i32, align 4
  %dir_fd = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 438, i32* %mode, align 4
  store i32 0, i32* %device, align 4
  store i32 -100, i32* %dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.313, i32 0, i32 0), i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @posix_mknod.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %mode, i32* %device, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dir_fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %3 = load i32, i32* %dir_fd, align 4
  %cmp = icmp ne i32 %3, -100
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %4 = load i32, i32* %dir_fd, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %6 = load i32, i32* %mode, align 4
  %7 = load i32, i32* %device, align 4
  %conv = sext i32 %7 to i64
  %call3 = call i32 @mknodat(i32 %4, i8* %5, i32 %6, i64 %conv) #4
  store i32 %call3, i32* %result, align 4
  br label %if.end.7

if.else:                                          ; preds = %if.end
  %narrow4 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %8 = load i8*, i8** %narrow4, align 8
  %9 = load i32, i32* %mode, align 4
  %10 = load i32, i32* %device, align 4
  %conv5 = sext i32 %10 to i64
  %call6 = call i32 @mknod(i8* %8, i32 %9, i64 %conv5) #4
  store i32 %call6, i32* %result, align 4
  br label %if.end.7

if.end.7:                                         ; preds = %if.else, %if.then.2
  %11 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %11)
  %12 = load i32, i32* %result, align 4
  %cmp8 = icmp slt i32 %12, 0
  br i1 %cmp8, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end.7
  %call11 = call %struct._object* @posix_error()
  store %struct._object* %call11, %struct._object** %return_value, align 8
  br label %exit

if.end.12:                                        ; preds = %if.end.7
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %13 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %13, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  br label %exit

exit:                                             ; preds = %if.end.12, %if.then.10
  call void @path_cleanup(%struct.path_t* %path)
  %14 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %14, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %15 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %15
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_major(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %device = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.314, i32 0, i32 0), i32* %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %device, align 4
  %conv = sext i32 %1 to i64
  %call1 = call i32 @gnu_dev_major(i64 %conv) #9
  %conv2 = zext i32 %call1 to i64
  %call3 = call %struct._object* @PyLong_FromLong(i64 %conv2)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_minor(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %device = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.315, i32 0, i32 0), i32* %device)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %device, align 4
  %conv = sext i32 %1 to i64
  %call1 = call i32 @gnu_dev_minor(i64 %conv) #9
  %conv2 = zext i32 %call1 to i64
  %call3 = call %struct._object* @PyLong_FromLong(i64 %conv2)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %2 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %2
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_makedev(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %major = alloca i32, align 4
  %minor = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.316, i32 0, i32 0), i32* %major, i32* %minor)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %major, align 4
  %2 = load i32, i32* %minor, align 4
  %call1 = call i64 @gnu_dev_makedev(i32 %1, i32 %2) #9
  %call2 = call %struct._object* @PyLong_FromLong(i64 %call1)
  store %struct._object* %call2, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_ftruncate(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %length = alloca i64, align 8
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.317, i32 0, i32 0), i32* %fd, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %length)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i64, i64* %length, align 8
  %call2 = call i32 @ftruncate64(i32 %1, i64 %2) #4
  store i32 %call2, i32* %res, align 4
  %3 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %3)
  %4 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %4, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %5 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %6 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_truncate(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %length = alloca i64, align 8
  %res = alloca i32, align 4
  %result = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.130, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.319, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_truncate.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %length)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd3, align 4
  %5 = load i64, i64* %length, align 8
  %call4 = call i32 @ftruncate64(i32 %4, i64 %5) #4
  store i32 %call4, i32* %res, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow, align 8
  %7 = load i64, i64* %length, align 8
  %call5 = call i32 @truncate64(i8* %6, i64 %7) #4
  store i32 %call5, i32* %res, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %8 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %8)
  %9 = load i32, i32* %res, align 4
  %cmp7 = icmp slt i32 %9, 0
  br i1 %cmp7, label %if.then.8, label %if.else.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %result, align 8
  br label %if.end.11

if.else.10:                                       ; preds = %if.end.6
  %10 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %10, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %result, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.else.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %11 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %11, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.11, %if.then
  %12 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %12
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_posix_fallocate(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %len = alloca i64, align 8
  %offset = alloca i64, align 8
  %res = alloca i32, align 4
  %fd = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.320, i32 0, i32 0), i32* %fd, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %offset, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %len)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i64, i64* %offset, align 8
  %3 = load i64, i64* %len, align 8
  %call2 = call i32 @posix_fallocate64(i32 %1, i64 %2, i64 %3)
  store i32 %call2, i32* %res, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %res, align 4
  %cmp = icmp ne i32 %5, 0
  br i1 %cmp, label %if.then.3, label %if.end.6

if.then.3:                                        ; preds = %if.end
  %6 = load i32, i32* %res, align 4
  %call4 = call i32* @__errno_location() #9
  store i32 %6, i32* %call4, align 4
  %call5 = call %struct._object* @posix_error()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %7 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.3, %if.then
  %8 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %8
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_posix_fadvise(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %len = alloca i64, align 8
  %offset = alloca i64, align 8
  %res = alloca i32, align 4
  %fd = alloca i32, align 4
  %advice = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.321, i32 0, i32 0), i32* %fd, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %offset, i32 (%struct._object*, i8*)* @_parse_off_t, i64* %len, i32* %advice)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %2 = load i64, i64* %offset, align 8
  %3 = load i64, i64* %len, align 8
  %4 = load i32, i32* %advice, align 4
  %call2 = call i32 @posix_fadvise64(i32 %1, i64 %2, i64 %3, i32 %4) #4
  store i32 %call2, i32* %res, align 4
  %5 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %5)
  %6 = load i32, i32* %res, align 4
  %cmp = icmp ne i32 %6, 0
  br i1 %cmp, label %if.then.3, label %if.end.6

if.then.3:                                        ; preds = %if.end
  %7 = load i32, i32* %res, align 4
  %call4 = call i32* @__errno_location() #9
  store i32 %7, i32* %call4, align 4
  %call5 = call %struct._object* @posix_error()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %8 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %8, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.3, %if.then
  %9 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %9
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_putenv(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %newstr = alloca %struct._object*, align 8
  %os1 = alloca %struct._object*, align 8
  %os2 = alloca %struct._object*, align 8
  %s1 = alloca i8*, align 8
  %s2 = alloca i8*, align 8
  %newenv = alloca i8*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp21 = alloca %struct._object*, align 8
  %_py_decref_tmp32 = alloca %struct._object*, align 8
  %_py_decref_tmp43 = alloca %struct._object*, align 8
  %_py_decref_tmp54 = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp68 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* null, %struct._object** %newstr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.322, i32 0, i32 0), i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %os1, i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %os2)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %os1, align 8
  %call1 = call i8* @PyBytes_AsString(%struct._object* %1)
  store i8* %call1, i8** %s1, align 8
  %2 = load %struct._object*, %struct._object** %os2, align 8
  %call2 = call i8* @PyBytes_AsString(%struct._object* %2)
  store i8* %call2, i8** %s2, align 8
  %3 = load i8*, i8** %s1, align 8
  %4 = load i8*, i8** %s2, align 8
  %call3 = call %struct._object* (i8*, ...) @PyBytes_FromFormat(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.237, i32 0, i32 0), i8* %3, i8* %4)
  store %struct._object* %call3, %struct._object** %newstr, align 8
  %5 = load %struct._object*, %struct._object** %newstr, align 8
  %cmp = icmp eq %struct._object* %5, null
  br i1 %cmp, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %call5 = call %struct._object* @PyErr_NoMemory()
  br label %error

if.end.6:                                         ; preds = %if.end
  %6 = load %struct._object*, %struct._object** %newstr, align 8
  %7 = bitcast %struct._object* %6 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %7, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  store i8* %arraydecay, i8** %newenv, align 8
  %8 = load i8*, i8** %newenv, align 8
  %call7 = call i32 @putenv(i8* %8) #4
  %tobool8 = icmp ne i32 %call7, 0
  br i1 %tobool8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end.6
  %call10 = call %struct._object* @posix_error()
  br label %error

if.end.11:                                        ; preds = %if.end.6
  %9 = load %struct._object*, %struct._object** @posix_putenv_garbage, align 8
  %10 = load %struct._object*, %struct._object** %os1, align 8
  %11 = load %struct._object*, %struct._object** %newstr, align 8
  %call12 = call i32 @PyDict_SetItem(%struct._object* %9, %struct._object* %10, %struct._object* %11)
  %tobool13 = icmp ne i32 %call12, 0
  br i1 %tobool13, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %if.end.11
  call void @PyErr_Clear()
  br label %if.end.19

if.else:                                          ; preds = %if.end.11
  br label %do.body

do.body:                                          ; preds = %if.else
  %12 = load %struct._object*, %struct._object** %newstr, align 8
  store %struct._object* %12, %struct._object** %_py_decref_tmp, align 8
  %13 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %13, i32 0, i32 0
  %14 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %14, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp15 = icmp ne i64 %dec, 0
  br i1 %cmp15, label %if.then.16, label %if.else.17

if.then.16:                                       ; preds = %do.body
  br label %if.end.18

if.else.17:                                       ; preds = %do.body
  %15 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %15, i32 0, i32 1
  %16 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %16, i32 0, i32 4
  %17 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %18 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %17(%struct._object* %18)
  br label %if.end.18

if.end.18:                                        ; preds = %if.else.17, %if.then.16
  br label %do.end

do.end:                                           ; preds = %if.end.18
  br label %if.end.19

if.end.19:                                        ; preds = %do.end, %if.then.14
  br label %do.body.20

do.body.20:                                       ; preds = %if.end.19
  %19 = load %struct._object*, %struct._object** %os1, align 8
  store %struct._object* %19, %struct._object** %_py_decref_tmp21, align 8
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  %ob_refcnt22 = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 0
  %21 = load i64, i64* %ob_refcnt22, align 8
  %dec23 = add i64 %21, -1
  store i64 %dec23, i64* %ob_refcnt22, align 8
  %cmp24 = icmp ne i64 %dec23, 0
  br i1 %cmp24, label %if.then.25, label %if.else.26

if.then.25:                                       ; preds = %do.body.20
  br label %if.end.29

if.else.26:                                       ; preds = %do.body.20
  %22 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  %ob_type27 = getelementptr inbounds %struct._object, %struct._object* %22, i32 0, i32 1
  %23 = load %struct._typeobject*, %struct._typeobject** %ob_type27, align 8
  %tp_dealloc28 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %23, i32 0, i32 4
  %24 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc28, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  call void %24(%struct._object* %25)
  br label %if.end.29

if.end.29:                                        ; preds = %if.else.26, %if.then.25
  br label %do.end.30

do.end.30:                                        ; preds = %if.end.29
  br label %do.body.31

do.body.31:                                       ; preds = %do.end.30
  %26 = load %struct._object*, %struct._object** %os2, align 8
  store %struct._object* %26, %struct._object** %_py_decref_tmp32, align 8
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp32, align 8
  %ob_refcnt33 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 0
  %28 = load i64, i64* %ob_refcnt33, align 8
  %dec34 = add i64 %28, -1
  store i64 %dec34, i64* %ob_refcnt33, align 8
  %cmp35 = icmp ne i64 %dec34, 0
  br i1 %cmp35, label %if.then.36, label %if.else.37

if.then.36:                                       ; preds = %do.body.31
  br label %if.end.40

if.else.37:                                       ; preds = %do.body.31
  %29 = load %struct._object*, %struct._object** %_py_decref_tmp32, align 8
  %ob_type38 = getelementptr inbounds %struct._object, %struct._object* %29, i32 0, i32 1
  %30 = load %struct._typeobject*, %struct._typeobject** %ob_type38, align 8
  %tp_dealloc39 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %30, i32 0, i32 4
  %31 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc39, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp32, align 8
  call void %31(%struct._object* %32)
  br label %if.end.40

if.end.40:                                        ; preds = %if.else.37, %if.then.36
  br label %do.end.41

do.end.41:                                        ; preds = %if.end.40
  %33 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %33, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

error:                                            ; preds = %if.then.9, %if.then.4
  br label %do.body.42

do.body.42:                                       ; preds = %error
  %34 = load %struct._object*, %struct._object** %os1, align 8
  store %struct._object* %34, %struct._object** %_py_decref_tmp43, align 8
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp43, align 8
  %ob_refcnt44 = getelementptr inbounds %struct._object, %struct._object* %35, i32 0, i32 0
  %36 = load i64, i64* %ob_refcnt44, align 8
  %dec45 = add i64 %36, -1
  store i64 %dec45, i64* %ob_refcnt44, align 8
  %cmp46 = icmp ne i64 %dec45, 0
  br i1 %cmp46, label %if.then.47, label %if.else.48

if.then.47:                                       ; preds = %do.body.42
  br label %if.end.51

if.else.48:                                       ; preds = %do.body.42
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp43, align 8
  %ob_type49 = getelementptr inbounds %struct._object, %struct._object* %37, i32 0, i32 1
  %38 = load %struct._typeobject*, %struct._typeobject** %ob_type49, align 8
  %tp_dealloc50 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %38, i32 0, i32 4
  %39 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc50, align 8
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp43, align 8
  call void %39(%struct._object* %40)
  br label %if.end.51

if.end.51:                                        ; preds = %if.else.48, %if.then.47
  br label %do.end.52

do.end.52:                                        ; preds = %if.end.51
  br label %do.body.53

do.body.53:                                       ; preds = %do.end.52
  %41 = load %struct._object*, %struct._object** %os2, align 8
  store %struct._object* %41, %struct._object** %_py_decref_tmp54, align 8
  %42 = load %struct._object*, %struct._object** %_py_decref_tmp54, align 8
  %ob_refcnt55 = getelementptr inbounds %struct._object, %struct._object* %42, i32 0, i32 0
  %43 = load i64, i64* %ob_refcnt55, align 8
  %dec56 = add i64 %43, -1
  store i64 %dec56, i64* %ob_refcnt55, align 8
  %cmp57 = icmp ne i64 %dec56, 0
  br i1 %cmp57, label %if.then.58, label %if.else.59

if.then.58:                                       ; preds = %do.body.53
  br label %if.end.62

if.else.59:                                       ; preds = %do.body.53
  %44 = load %struct._object*, %struct._object** %_py_decref_tmp54, align 8
  %ob_type60 = getelementptr inbounds %struct._object, %struct._object* %44, i32 0, i32 1
  %45 = load %struct._typeobject*, %struct._typeobject** %ob_type60, align 8
  %tp_dealloc61 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %45, i32 0, i32 4
  %46 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc61, align 8
  %47 = load %struct._object*, %struct._object** %_py_decref_tmp54, align 8
  call void %46(%struct._object* %47)
  br label %if.end.62

if.end.62:                                        ; preds = %if.else.59, %if.then.58
  br label %do.end.63

do.end.63:                                        ; preds = %if.end.62
  br label %do.body.64

do.body.64:                                       ; preds = %do.end.63
  %48 = load %struct._object*, %struct._object** %newstr, align 8
  store %struct._object* %48, %struct._object** %_py_xdecref_tmp, align 8
  %49 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp65 = icmp ne %struct._object* %49, null
  br i1 %cmp65, label %if.then.66, label %if.end.78

if.then.66:                                       ; preds = %do.body.64
  br label %do.body.67

do.body.67:                                       ; preds = %if.then.66
  %50 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %50, %struct._object** %_py_decref_tmp68, align 8
  %51 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  %ob_refcnt69 = getelementptr inbounds %struct._object, %struct._object* %51, i32 0, i32 0
  %52 = load i64, i64* %ob_refcnt69, align 8
  %dec70 = add i64 %52, -1
  store i64 %dec70, i64* %ob_refcnt69, align 8
  %cmp71 = icmp ne i64 %dec70, 0
  br i1 %cmp71, label %if.then.72, label %if.else.73

if.then.72:                                       ; preds = %do.body.67
  br label %if.end.76

if.else.73:                                       ; preds = %do.body.67
  %53 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  %ob_type74 = getelementptr inbounds %struct._object, %struct._object* %53, i32 0, i32 1
  %54 = load %struct._typeobject*, %struct._typeobject** %ob_type74, align 8
  %tp_dealloc75 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %54, i32 0, i32 4
  %55 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc75, align 8
  %56 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  call void %55(%struct._object* %56)
  br label %if.end.76

if.end.76:                                        ; preds = %if.else.73, %if.then.72
  br label %do.end.77

do.end.77:                                        ; preds = %if.end.76
  br label %if.end.78

if.end.78:                                        ; preds = %do.end.77, %do.body.64
  br label %do.end.79

do.end.79:                                        ; preds = %if.end.78
  store %struct._object* null, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end.79, %do.end.41, %if.then
  %57 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %57
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_unsetenv(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %name = alloca %struct._object*, align 8
  %err = alloca i32, align 4
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp13 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.323, i32 0, i32 0), i32 (%struct._object*, i8*)* @PyUnicode_FSConverter, %struct._object** %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** %name, align 8
  %2 = bitcast %struct._object* %1 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %2, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  %call1 = call i32 @unsetenv(i8* %arraydecay) #4
  store i32 %call1, i32* %err, align 4
  %3 = load i32, i32* %err, align 4
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %if.then.3, label %if.end.7

if.then.3:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then.3
  %4 = load %struct._object*, %struct._object** %name, align 8
  store %struct._object* %4, %struct._object** %_py_decref_tmp, align 8
  %5 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %5, i32 0, i32 0
  %6 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %6, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp = icmp ne i64 %dec, 0
  br i1 %cmp, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %do.body
  br label %if.end.5

if.else:                                          ; preds = %do.body
  %7 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %7, i32 0, i32 1
  %8 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %8, i32 0, i32 4
  %9 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %9(%struct._object* %10)
  br label %if.end.5

if.end.5:                                         ; preds = %if.else, %if.then.4
  br label %do.end

do.end:                                           ; preds = %if.end.5
  %call6 = call %struct._object* @posix_error()
  store %struct._object* %call6, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %if.end
  %11 = load %struct._object*, %struct._object** @posix_putenv_garbage, align 8
  %12 = load %struct._object*, %struct._object** %name, align 8
  %call8 = call i32 @PyDict_DelItem(%struct._object* %11, %struct._object* %12)
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.7
  call void @PyErr_Clear()
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.10, %if.end.7
  br label %do.body.12

do.body.12:                                       ; preds = %if.end.11
  %13 = load %struct._object*, %struct._object** %name, align 8
  store %struct._object* %13, %struct._object** %_py_decref_tmp13, align 8
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp13, align 8
  %ob_refcnt14 = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 0
  %15 = load i64, i64* %ob_refcnt14, align 8
  %dec15 = add i64 %15, -1
  store i64 %dec15, i64* %ob_refcnt14, align 8
  %cmp16 = icmp ne i64 %dec15, 0
  br i1 %cmp16, label %if.then.17, label %if.else.18

if.then.17:                                       ; preds = %do.body.12
  br label %if.end.21

if.else.18:                                       ; preds = %do.body.12
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp13, align 8
  %ob_type19 = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 1
  %17 = load %struct._typeobject*, %struct._typeobject** %ob_type19, align 8
  %tp_dealloc20 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %17, i32 0, i32 4
  %18 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc20, align 8
  %19 = load %struct._object*, %struct._object** %_py_decref_tmp13, align 8
  call void %18(%struct._object* %19)
  br label %if.end.21

if.end.21:                                        ; preds = %if.else.18, %if.then.17
  br label %do.end.22

do.end.22:                                        ; preds = %if.end.21
  %20 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %20, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %do.end.22, %do.end, %if.then
  %21 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %21
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_strerror(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %code = alloca i32, align 4
  %message = alloca i8*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.324, i32 0, i32 0), i32* %code)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %code, align 4
  %call1 = call i8* @strerror(i32 %1) #4
  store i8* %call1, i8** %message, align 8
  %2 = load i8*, i8** %message, align 8
  %cmp = icmp eq i8* %2, null
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %3 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %3, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.325, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %4 = load i8*, i8** %message, align 8
  %call4 = call %struct._object* @PyUnicode_DecodeLocale(i8* %4, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.326, i32 0, i32 0))
  store %struct._object* %call4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.3, %if.then.2, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fchdir(%struct._object* %self, %struct._object* %fdobj) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %fdobj.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %fdobj, %struct._object** %fdobj.addr, align 8
  %0 = load %struct._object*, %struct._object** %fdobj.addr, align 8
  %call = call %struct._object* @posix_fildes(%struct._object* %0, i32 (i32)* @fchdir)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fsync(%struct._object* %self, %struct._object* %fdobj) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %fdobj.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %fdobj, %struct._object** %fdobj.addr, align 8
  %0 = load %struct._object*, %struct._object** %fdobj.addr, align 8
  %call = call %struct._object* @posix_fildes(%struct._object* %0, i32 (i32)* @fsync)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sync(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  call void @sync() #4
  %0 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %0)
  %1 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %1, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  ret %struct._object* @_Py_NoneStruct
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fdatasync(%struct._object* %self, %struct._object* %fdobj) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %fdobj.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %fdobj, %struct._object** %fdobj.addr, align 8
  %0 = load %struct._object*, %struct._object** %fdobj.addr, align 8
  %call = call %struct._object* @posix_fildes(%struct._object* %0, i32 (i32)* @fdatasync)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WCOREDUMP(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.22, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.327, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.22* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.22* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 128
  %conv = sext i32 %and to i64
  %call1 = call %struct._object* @PyBool_FromLong(i64 %conv)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WIFCONTINUED(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.23, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.328, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.23* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.23* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %cmp = icmp eq i32 %2, 65535
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %call2 = call %struct._object* @PyBool_FromLong(i64 %conv1)
  store %struct._object* %call2, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WIFSTOPPED(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.24, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.329, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.24* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.24* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 255
  %cmp = icmp eq i32 %and, 127
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %call2 = call %struct._object* @PyBool_FromLong(i64 %conv1)
  store %struct._object* %call2, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WIFSIGNALED(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.25, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.330, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.25* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.25* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 127
  %add = add i32 %and, 1
  %conv = trunc i32 %add to i8
  %conv1 = sext i8 %conv to i32
  %shr = ashr i32 %conv1, 1
  %cmp = icmp sgt i32 %shr, 0
  %conv2 = zext i1 %cmp to i32
  %conv3 = sext i32 %conv2 to i64
  %call4 = call %struct._object* @PyBool_FromLong(i64 %conv3)
  store %struct._object* %call4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WIFEXITED(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.26, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.331, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.26* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.26* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 127
  %cmp = icmp eq i32 %and, 0
  %conv = zext i1 %cmp to i32
  %conv1 = sext i32 %conv to i64
  %call2 = call %struct._object* @PyBool_FromLong(i64 %conv1)
  store %struct._object* %call2, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WEXITSTATUS(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.27, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.332, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.27* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.27* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 65280
  %shr = ashr i32 %and, 8
  %call1 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.333, i32 0, i32 0), i32 %shr)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WTERMSIG(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.28, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.334, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.28* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.28* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 127
  %call1 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.333, i32 0, i32 0), i32 %and)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_WSTOPSIG(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %status = alloca i32, align 4
  %.compoundliteral = alloca %union.anon.29, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.335, i32 0, i32 0), i32* %status)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %__in = bitcast %union.anon.29* %.compoundliteral to i32*
  %1 = load i32, i32* %status, align 4
  store i32 %1, i32* %__in, align 4
  %__i = bitcast %union.anon.29* %.compoundliteral to i32*
  %2 = load i32, i32* %__i, align 4
  %and = and i32 %2, 65280
  %shr = ashr i32 %and, 8
  %call1 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.333, i32 0, i32 0), i32 %shr)
  store %struct._object* %call1, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fstatvfs(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %res = alloca i32, align 4
  %st = alloca %struct.statvfs, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.336, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %1 = load i32, i32* %fd, align 4
  %call2 = call i32 @fstatvfs64(i32 %1, %struct.statvfs* %st) #4
  store i32 %call2, i32* %res, align 4
  %2 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %2)
  %3 = load i32, i32* %res, align 4
  %cmp = icmp ne i32 %3, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @posix_error()
  store %struct._object* %call4, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %call6 = call %struct._object* @_pystatvfs_fromstructstatvfs(%struct.statvfs* byval align 8 %st)
  store %struct._object* %call6, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_statvfs(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %st = alloca %struct.statvfs, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.149, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.337, i32 0, i32 0), i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @posix_statvfs.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd3, align 4
  %call4 = call i32 @fstatvfs64(i32 %4, %struct.statvfs* %st) #4
  store i32 %call4, i32* %result, align 4
  br label %if.end.6

if.else:                                          ; preds = %if.end
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %call5 = call i32 @statvfs64(i8* %5, %struct.statvfs* %st) #4
  store i32 %call5, i32* %result, align 4
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.2
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i32, i32* %result, align 4
  %tobool7 = icmp ne i32 %7, 0
  br i1 %tobool7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end.6
  %call9 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call9, %struct._object** %return_value, align 8
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  %call11 = call %struct._object* @_pystatvfs_fromstructstatvfs(%struct.statvfs* byval align 8 %st)
  store %struct._object* %call11, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.10, %if.then.8
  call void @path_cleanup(%struct.path_t* %path)
  %8 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %8, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %9 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %9
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_confstr(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %name = alloca i32, align 4
  %buffer = alloca [255 x i8], align 16
  %len = alloca i64, align 8
  %buf = alloca i8*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.338, i32 0, i32 0), i32 (%struct._object*, i32*)* @conv_confstr_confname, i32* %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %1 = load i32, i32* %name, align 4
  %arraydecay = getelementptr inbounds [255 x i8], [255 x i8]* %buffer, i32 0, i32 0
  %call2 = call i64 @confstr(i32 %1, i8* %arraydecay, i64 255) #4
  store i64 %call2, i64* %len, align 8
  %2 = load i64, i64* %len, align 8
  %cmp = icmp eq i64 %2, 0
  br i1 %cmp, label %if.then.3, label %if.end.8

if.then.3:                                        ; preds = %if.end
  %call4 = call i32* @__errno_location() #9
  %3 = load i32, i32* %call4, align 4
  %tobool5 = icmp ne i32 %3, 0
  br i1 %tobool5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.then.3
  %call7 = call %struct._object* @posix_error()
  store %struct._object* null, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %if.then.3
  %4 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %4, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

if.end.8:                                         ; preds = %if.end
  %5 = load i64, i64* %len, align 8
  %cmp9 = icmp uge i64 %5, 255
  br i1 %cmp9, label %if.then.10, label %if.else.18

if.then.10:                                       ; preds = %if.end.8
  %6 = load i64, i64* %len, align 8
  %call11 = call i8* @PyMem_Malloc(i64 %6)
  store i8* %call11, i8** %buf, align 8
  %7 = load i8*, i8** %buf, align 8
  %cmp12 = icmp eq i8* %7, null
  br i1 %cmp12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.then.10
  %call14 = call %struct._object* @PyErr_NoMemory()
  store %struct._object* %call14, %struct._object** %retval
  br label %return

if.end.15:                                        ; preds = %if.then.10
  %8 = load i32, i32* %name, align 4
  %9 = load i8*, i8** %buf, align 8
  %10 = load i64, i64* %len, align 8
  %call16 = call i64 @confstr(i32 %8, i8* %9, i64 %10) #4
  %11 = load i8*, i8** %buf, align 8
  %12 = load i64, i64* %len, align 8
  %sub = sub i64 %12, 1
  %call17 = call %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8* %11, i64 %sub)
  store %struct._object* %call17, %struct._object** %result, align 8
  %13 = load i8*, i8** %buf, align 8
  call void @PyMem_Free(i8* %13)
  br label %if.end.22

if.else.18:                                       ; preds = %if.end.8
  %arraydecay19 = getelementptr inbounds [255 x i8], [255 x i8]* %buffer, i32 0, i32 0
  %14 = load i64, i64* %len, align 8
  %sub20 = sub i64 %14, 1
  %call21 = call %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8* %arraydecay19, i64 %sub20)
  store %struct._object* %call21, %struct._object** %result, align 8
  br label %if.end.22

if.end.22:                                        ; preds = %if.else.18, %if.end.15
  %15 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %15, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.22, %if.then.13, %if.else, %if.then.6, %if.then
  %16 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %16
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_sysconf(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %name = alloca i32, align 4
  %value = alloca i64, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.368, i32 0, i32 0), i32 (%struct._object*, i32*)* @conv_sysconf_confname, i32* %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end.8

if.then:                                          ; preds = %entry
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %1 = load i32, i32* %name, align 4
  %call2 = call i64 @sysconf(i32 %1) #4
  store i64 %call2, i64* %value, align 8
  %2 = load i64, i64* %value, align 8
  %cmp = icmp eq i64 %2, -1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %call3 = call i32* @__errno_location() #9
  %3 = load i32, i32* %call3, align 4
  %cmp4 = icmp ne i32 %3, 0
  br i1 %cmp4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %land.lhs.true
  %call6 = call %struct._object* @posix_error()
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %if.then
  %4 = load i64, i64* %value, align 8
  %call7 = call %struct._object* @PyLong_FromLong(i64 %4)
  store %struct._object* %call7, %struct._object** %result, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.5
  br label %if.end.8

if.end.8:                                         ; preds = %if.end, %entry
  %5 = load %struct._object*, %struct._object** %result, align 8
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fpathconf(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %result = alloca %struct._object*, align 8
  %name = alloca i32, align 4
  %fd = alloca i32, align 4
  %limit = alloca i64, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.503, i32 0, i32 0), i32* %fd, i32 (%struct._object*, i32*)* @conv_path_confname, i32* %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end.8

if.then:                                          ; preds = %entry
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %name, align 4
  %call2 = call i64 @fpathconf(i32 %1, i32 %2) #4
  store i64 %call2, i64* %limit, align 8
  %3 = load i64, i64* %limit, align 8
  %cmp = icmp eq i64 %3, -1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %call3 = call i32* @__errno_location() #9
  %4 = load i32, i32* %call3, align 4
  %cmp4 = icmp ne i32 %4, 0
  br i1 %cmp4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %land.lhs.true
  %call6 = call %struct._object* @posix_error()
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %if.then
  %5 = load i64, i64* %limit, align 8
  %call7 = call %struct._object* @PyLong_FromLong(i64 %5)
  store %struct._object* %call7, %struct._object** %result, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.5
  br label %if.end.8

if.end.8:                                         ; preds = %if.end, %entry
  %6 = load %struct._object*, %struct._object** %result, align 8
  ret %struct._object* %6
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_pathconf(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %result = alloca %struct._object*, align 8
  %name = alloca i32, align 4
  %limit = alloca i64, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store %struct._object* null, %struct._object** %result, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.153, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.525, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_pathconf.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i32*)* @conv_path_confname, i32* %name)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end.20

if.then:                                          ; preds = %entry
  %call1 = call i32* @__errno_location() #9
  store i32 0, i32* %call1, align 4
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd, align 4
  %cmp = icmp ne i32 %3, -1
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  %fd3 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd3, align 4
  %5 = load i32, i32* %name, align 4
  %call4 = call i64 @fpathconf(i32 %4, i32 %5) #4
  store i64 %call4, i64* %limit, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow, align 8
  %7 = load i32, i32* %name, align 4
  %call5 = call i64 @pathconf(i8* %6, i32 %7) #4
  store i64 %call5, i64* %limit, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.2
  %8 = load i64, i64* %limit, align 8
  %cmp6 = icmp eq i64 %8, -1
  br i1 %cmp6, label %land.lhs.true, label %if.else.17

land.lhs.true:                                    ; preds = %if.end
  %call7 = call i32* @__errno_location() #9
  %9 = load i32, i32* %call7, align 4
  %cmp8 = icmp ne i32 %9, 0
  br i1 %cmp8, label %if.then.9, label %if.else.17

if.then.9:                                        ; preds = %land.lhs.true
  %call10 = call i32* @__errno_location() #9
  %10 = load i32, i32* %call10, align 4
  %cmp11 = icmp eq i32 %10, 22
  br i1 %cmp11, label %if.then.12, label %if.else.14

if.then.12:                                       ; preds = %if.then.9
  %call13 = call %struct._object* @posix_error()
  br label %if.end.16

if.else.14:                                       ; preds = %if.then.9
  %call15 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call15, %struct._object** %result, align 8
  br label %if.end.16

if.end.16:                                        ; preds = %if.else.14, %if.then.12
  br label %if.end.19

if.else.17:                                       ; preds = %land.lhs.true, %if.end
  %11 = load i64, i64* %limit, align 8
  %call18 = call %struct._object* @PyLong_FromLong(i64 %11)
  store %struct._object* %call18, %struct._object** %result, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else.17, %if.end.16
  br label %if.end.20

if.end.20:                                        ; preds = %if.end.19, %entry
  call void @path_cleanup(%struct.path_t* %path)
  %12 = load %struct._object*, %struct._object** %result, align 8
  ret %struct._object* %12
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_abort(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  call void @abort() #11
  unreachable

return:                                           ; No predecessors!
  %0 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %0
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getloadavg(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %loadavg = alloca [3 x double], align 16
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %loadavg, i32 0, i32 0
  %call = call i32 @getloadavg(double* %arraydecay, i32 3) #4
  %cmp = icmp ne i32 %call, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %0 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  call void @PyErr_SetString(%struct._object* %0, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.526, i32 0, i32 0))
  store %struct._object* null, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %entry
  %arrayidx = getelementptr [3 x double], [3 x double]* %loadavg, i32 0, i64 0
  %1 = load double, double* %arrayidx, align 8
  %arrayidx1 = getelementptr [3 x double], [3 x double]* %loadavg, i32 0, i64 1
  %2 = load double, double* %arrayidx1, align 8
  %arrayidx2 = getelementptr [3 x double], [3 x double]* %loadavg, i32 0, i64 2
  %3 = load double, double* %arrayidx2, align 8
  %call3 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.527, i32 0, i32 0), double %1, double %2, double %3)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_urandom(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %size = alloca i64, align 8
  %result = alloca %struct._object*, align 8
  %ret = alloca i32, align 4
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.528, i32 0, i32 0), i64* %size)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %size, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then.1, label %if.end.3

if.then.1:                                        ; preds = %if.end
  %2 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %call2 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.529, i32 0, i32 0))
  store %struct._object* %call2, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i64, i64* %size, align 8
  %call4 = call %struct._object* @PyBytes_FromStringAndSize(i8* null, i64 %3)
  store %struct._object* %call4, %struct._object** %result, align 8
  %4 = load %struct._object*, %struct._object** %result, align 8
  %cmp5 = icmp eq %struct._object* %4, null
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end.3
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.7:                                         ; preds = %if.end.3
  %5 = load %struct._object*, %struct._object** %result, align 8
  %6 = bitcast %struct._object* %5 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %6, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  %7 = load %struct._object*, %struct._object** %result, align 8
  %8 = bitcast %struct._object* %7 to %struct.PyVarObject*
  %ob_size = getelementptr inbounds %struct.PyVarObject, %struct.PyVarObject* %8, i32 0, i32 1
  %9 = load i64, i64* %ob_size, align 8
  %call8 = call i32 @_PyOS_URandom(i8* %arraydecay, i64 %9)
  store i32 %call8, i32* %ret, align 4
  %10 = load i32, i32* %ret, align 4
  %cmp9 = icmp eq i32 %10, -1
  br i1 %cmp9, label %if.then.10, label %if.end.14

if.then.10:                                       ; preds = %if.end.7
  br label %do.body

do.body:                                          ; preds = %if.then.10
  %11 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %11, %struct._object** %_py_decref_tmp, align 8
  %12 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %12, i32 0, i32 0
  %13 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %13, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp11 = icmp ne i64 %dec, 0
  br i1 %cmp11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %do.body
  br label %if.end.13

if.else:                                          ; preds = %do.body
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 1
  %15 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %15, i32 0, i32 4
  %16 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %17 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %16(%struct._object* %17)
  br label %if.end.13

if.end.13:                                        ; preds = %if.else, %if.then.12
  br label %do.end

do.end:                                           ; preds = %if.end.13
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.14:                                        ; preds = %if.end.7
  %18 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %18, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.14, %do.end, %if.then.6, %if.then.1, %if.then
  %19 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %19
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setresuid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  %suid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.530, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %ruid, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %euid, i32 (%struct._object*, i8*)* @_Py_Uid_Converter, i32* %suid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %ruid, align 4
  %2 = load i32, i32* %euid, align 4
  %3 = load i32, i32* %suid, align 4
  %call1 = call i32 @setresuid(i32 %1, i32 %2, i32 %3) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %4 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %4, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setresgid(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  %sgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.531, i32 0, i32 0), i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %rgid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %egid, i32 (%struct._object*, i8*)* @_Py_Gid_Converter, i32* %sgid)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %rgid, align 4
  %2 = load i32, i32* %egid, align 4
  %3 = load i32, i32* %sgid, align 4
  %call1 = call i32 @setresgid(i32 %1, i32 %2, i32 %3) #4
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @posix_error()
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %4 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %4, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.4, %if.then.2, %if.then
  %5 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %5
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getresuid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %ruid = alloca i32, align 4
  %euid = alloca i32, align 4
  %suid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getresuid(i32* %ruid, i32* %euid, i32* %suid) #4
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %ruid, align 4
  %call2 = call %struct._object* @_PyLong_FromUid(i32 %0)
  %1 = load i32, i32* %euid, align 4
  %call3 = call %struct._object* @_PyLong_FromUid(i32 %1)
  %2 = load i32, i32* %suid, align 4
  %call4 = call %struct._object* @_PyLong_FromUid(i32 %2)
  %call5 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.532, i32 0, i32 0), %struct._object* %call2, %struct._object* %call3, %struct._object* %call4)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getresgid(%struct._object* %self, %struct._object* %noargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %noargs.addr = alloca %struct._object*, align 8
  %rgid = alloca i32, align 4
  %egid = alloca i32, align 4
  %sgid = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %noargs, %struct._object** %noargs.addr, align 8
  %call = call i32 @getresgid(i32* %rgid, i32* %egid, i32* %sgid) #4
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  store %struct._object* %call1, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %0 = load i32, i32* %rgid, align 4
  %call2 = call %struct._object* @_PyLong_FromGid(i32 %0)
  %1 = load i32, i32* %egid, align 4
  %call3 = call %struct._object* @_PyLong_FromGid(i32 %1)
  %2 = load i32, i32* %sgid, align 4
  %call4 = call %struct._object* @_PyLong_FromGid(i32 %2)
  %call5 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.532, i32 0, i32 0), %struct._object* %call2, %struct._object* %call3, %struct._object* %call4)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_setxattr(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %value = alloca %struct.bufferinfo, align 8
  %flags = alloca i32, align 4
  %follow_symlinks = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 0, i32* %flags, align 4
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.161, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %1 = bitcast %struct.path_t* %attribute to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %2 = bitcast %struct.bufferinfo* %value to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 80, i32 8, i1 false)
  %3 = load %struct._object*, %struct._object** %args.addr, align 8
  %4 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %3, %struct._object* %4, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.535, i32 0, i32 0), i8** getelementptr inbounds ([6 x i8*], [6 x i8*]* @posix_setxattr.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %attribute, %struct.bufferinfo* %value, i32* %flags, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %5 = load i32, i32* %fd, align 4
  %6 = load i32, i32* %follow_symlinks, align 4
  %call1 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.161, i32 0, i32 0), i32 %5, i32 %6)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  br label %exit

if.end.4:                                         ; preds = %if.end
  %call5 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call5, %struct._ts** %_save, align 8
  %fd6 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %7 = load i32, i32* %fd6, align 4
  %cmp = icmp sgt i32 %7, -1
  br i1 %cmp, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.end.4
  %fd8 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %8 = load i32, i32* %fd8, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %9 = load i8*, i8** %narrow, align 8
  %buf = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 0
  %10 = load i8*, i8** %buf, align 8
  %len = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 2
  %11 = load i64, i64* %len, align 8
  %12 = load i32, i32* %flags, align 4
  %call9 = call i32 @fsetxattr(i32 %8, i8* %9, i8* %10, i64 %11, i32 %12) #4
  store i32 %call9, i32* %result, align 4
  br label %if.end.24

if.else:                                          ; preds = %if.end.4
  %13 = load i32, i32* %follow_symlinks, align 4
  %tobool10 = icmp ne i32 %13, 0
  br i1 %tobool10, label %if.then.11, label %if.else.17

if.then.11:                                       ; preds = %if.else
  %narrow12 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %14 = load i8*, i8** %narrow12, align 8
  %narrow13 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %15 = load i8*, i8** %narrow13, align 8
  %buf14 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 0
  %16 = load i8*, i8** %buf14, align 8
  %len15 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 2
  %17 = load i64, i64* %len15, align 8
  %18 = load i32, i32* %flags, align 4
  %call16 = call i32 @setxattr(i8* %14, i8* %15, i8* %16, i64 %17, i32 %18) #4
  store i32 %call16, i32* %result, align 4
  br label %if.end.23

if.else.17:                                       ; preds = %if.else
  %narrow18 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %19 = load i8*, i8** %narrow18, align 8
  %narrow19 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %20 = load i8*, i8** %narrow19, align 8
  %buf20 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 0
  %21 = load i8*, i8** %buf20, align 8
  %len21 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %value, i32 0, i32 2
  %22 = load i64, i64* %len21, align 8
  %23 = load i32, i32* %flags, align 4
  %call22 = call i32 @lsetxattr(i8* %19, i8* %20, i8* %21, i64 %22, i32 %23) #4
  store i32 %call22, i32* %result, align 4
  br label %if.end.23

if.end.23:                                        ; preds = %if.else.17, %if.then.11
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.then.7
  %24 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %24)
  %25 = load i32, i32* %result, align 4
  %tobool25 = icmp ne i32 %25, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.end.24
  %call27 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call27, %struct._object** %return_value, align 8
  br label %exit

if.end.28:                                        ; preds = %if.end.24
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %26 = load %struct._object*, %struct._object** %return_value, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %26, i32 0, i32 0
  %27 = load i64, i64* %ob_refcnt, align 8
  %inc = add i64 %27, 1
  store i64 %inc, i64* %ob_refcnt, align 8
  br label %exit

exit:                                             ; preds = %if.end.28, %if.then.26, %if.then.3
  call void @path_cleanup(%struct.path_t* %path)
  call void @path_cleanup(%struct.path_t* %attribute)
  call void @PyBuffer_Release(%struct.bufferinfo* %value)
  %28 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %28, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %29 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %29
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getxattr(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  %buffer = alloca %struct._object*, align 8
  %i = alloca i32, align 4
  %ptr = alloca i8*, align 8
  %result = alloca i64, align 8
  %buffer_size = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %buffer, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = bitcast %struct.path_t* %attribute to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i8** %function_name, align 8
  %function_name1 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 0
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i8** %function_name1, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %2, %struct._object* %3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.536, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_getxattr.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %attribute, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd, align 4
  %5 = load i32, i32* %follow_symlinks, align 4
  %call2 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.162, i32 0, i32 0), i32 %4, i32 %5)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  br label %exit

if.end.5:                                         ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.5
  %6 = load i32, i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr [3 x i64], [3 x i64]* @posix_getxattr.buffer_sizes, i32 0, i64 %idxprom
  %7 = load i64, i64* %arrayidx, align 8
  store i64 %7, i64* %buffer_size, align 8
  %8 = load i64, i64* %buffer_size, align 8
  %tobool6 = icmp ne i64 %8, 0
  br i1 %tobool6, label %if.end.9, label %if.then.7

if.then.7:                                        ; preds = %for.cond
  %call8 = call %struct._object* @path_error(%struct.path_t* %path)
  br label %exit

if.end.9:                                         ; preds = %for.cond
  %9 = load i64, i64* %buffer_size, align 8
  %call10 = call %struct._object* @PyBytes_FromStringAndSize(i8* null, i64 %9)
  store %struct._object* %call10, %struct._object** %buffer, align 8
  %10 = load %struct._object*, %struct._object** %buffer, align 8
  %tobool11 = icmp ne %struct._object* %10, null
  br i1 %tobool11, label %if.end.13, label %if.then.12

if.then.12:                                       ; preds = %if.end.9
  br label %exit

if.end.13:                                        ; preds = %if.end.9
  %11 = load %struct._object*, %struct._object** %buffer, align 8
  %12 = bitcast %struct._object* %11 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %12, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  store i8* %arraydecay, i8** %ptr, align 8
  %call14 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call14, %struct._ts** %_save, align 8
  %fd15 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %13 = load i32, i32* %fd15, align 4
  %cmp = icmp sge i32 %13, 0
  br i1 %cmp, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %if.end.13
  %fd17 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %14 = load i32, i32* %fd17, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %15 = load i8*, i8** %narrow, align 8
  %16 = load i8*, i8** %ptr, align 8
  %17 = load i64, i64* %buffer_size, align 8
  %call18 = call i64 @fgetxattr(i32 %14, i8* %15, i8* %16, i64 %17) #4
  store i64 %call18, i64* %result, align 8
  br label %if.end.29

if.else:                                          ; preds = %if.end.13
  %18 = load i32, i32* %follow_symlinks, align 4
  %tobool19 = icmp ne i32 %18, 0
  br i1 %tobool19, label %if.then.20, label %if.else.24

if.then.20:                                       ; preds = %if.else
  %narrow21 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %19 = load i8*, i8** %narrow21, align 8
  %narrow22 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %20 = load i8*, i8** %narrow22, align 8
  %21 = load i8*, i8** %ptr, align 8
  %22 = load i64, i64* %buffer_size, align 8
  %call23 = call i64 @getxattr(i8* %19, i8* %20, i8* %21, i64 %22) #4
  store i64 %call23, i64* %result, align 8
  br label %if.end.28

if.else.24:                                       ; preds = %if.else
  %narrow25 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %23 = load i8*, i8** %narrow25, align 8
  %narrow26 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %24 = load i8*, i8** %narrow26, align 8
  %25 = load i8*, i8** %ptr, align 8
  %26 = load i64, i64* %buffer_size, align 8
  %call27 = call i64 @lgetxattr(i8* %23, i8* %24, i8* %25, i64 %26) #4
  store i64 %call27, i64* %result, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.else.24, %if.then.20
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %if.then.16
  %27 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %27)
  %28 = load i64, i64* %result, align 8
  %cmp30 = icmp slt i64 %28, 0
  br i1 %cmp30, label %if.then.31, label %if.end.41

if.then.31:                                       ; preds = %if.end.29
  br label %do.body

do.body:                                          ; preds = %if.then.31
  %29 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %29, %struct._object** %_py_decref_tmp, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %30, i32 0, i32 0
  %31 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %31, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp32 = icmp ne i64 %dec, 0
  br i1 %cmp32, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %do.body
  br label %if.end.35

if.else.34:                                       ; preds = %do.body
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 1
  %33 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %33, i32 0, i32 4
  %34 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %34(%struct._object* %35)
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.34, %if.then.33
  br label %do.end

do.end:                                           ; preds = %if.end.35
  store %struct._object* null, %struct._object** %buffer, align 8
  %call36 = call i32* @__errno_location() #9
  %36 = load i32, i32* %call36, align 4
  %cmp37 = icmp eq i32 %36, 34
  br i1 %cmp37, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %do.end
  br label %for.inc

if.end.39:                                        ; preds = %do.end
  %call40 = call %struct._object* @path_error(%struct.path_t* %path)
  br label %exit

if.end.41:                                        ; preds = %if.end.29
  %37 = load i64, i64* %result, align 8
  %38 = load i64, i64* %buffer_size, align 8
  %cmp42 = icmp ne i64 %37, %38
  br i1 %cmp42, label %if.then.43, label %if.end.45

if.then.43:                                       ; preds = %if.end.41
  %39 = load i64, i64* %result, align 8
  %call44 = call i32 @_PyBytes_Resize(%struct._object** %buffer, i64 %39)
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.43, %if.end.41
  br label %for.end

for.inc:                                          ; preds = %if.then.38
  %40 = load i32, i32* %i, align 4
  %inc = add i32 %40, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.end.45
  br label %exit

exit:                                             ; preds = %for.end, %if.end.39, %if.then.12, %if.then.7, %if.then.4
  call void @path_cleanup(%struct.path_t* %path)
  call void @path_cleanup(%struct.path_t* %attribute)
  %41 = load %struct._object*, %struct._object** %buffer, align 8
  store %struct._object* %41, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %42 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %42
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_removexattr(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %attribute = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  %result = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.163, i32 0, i32 0), i8** %function_name, align 8
  %1 = bitcast %struct.path_t* %attribute to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %function_name1 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 0
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.163, i32 0, i32 0), i8** %function_name1, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %2, %struct._object* %3, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.537, i32 0, i32 0), i8** getelementptr inbounds ([4 x i8*], [4 x i8*]* @posix_removexattr.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %attribute, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %4 = load i32, i32* %fd, align 4
  %5 = load i32, i32* %follow_symlinks, align 4
  %call2 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.163, i32 0, i32 0), i32 %4, i32 %5)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  br label %exit

if.end.5:                                         ; preds = %if.end
  %call6 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call6, %struct._ts** %_save, align 8
  %fd7 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %6 = load i32, i32* %fd7, align 4
  %cmp = icmp sgt i32 %6, -1
  br i1 %cmp, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.end.5
  %fd9 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %7 = load i32, i32* %fd9, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %8 = load i8*, i8** %narrow, align 8
  %call10 = call i32 @fremovexattr(i32 %7, i8* %8) #4
  store i32 %call10, i32* %result, align 4
  br label %if.end.21

if.else:                                          ; preds = %if.end.5
  %9 = load i32, i32* %follow_symlinks, align 4
  %tobool11 = icmp ne i32 %9, 0
  br i1 %tobool11, label %if.then.12, label %if.else.16

if.then.12:                                       ; preds = %if.else
  %narrow13 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %10 = load i8*, i8** %narrow13, align 8
  %narrow14 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %11 = load i8*, i8** %narrow14, align 8
  %call15 = call i32 @removexattr(i8* %10, i8* %11) #4
  store i32 %call15, i32* %result, align 4
  br label %if.end.20

if.else.16:                                       ; preds = %if.else
  %narrow17 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %12 = load i8*, i8** %narrow17, align 8
  %narrow18 = getelementptr inbounds %struct.path_t, %struct.path_t* %attribute, i32 0, i32 5
  %13 = load i8*, i8** %narrow18, align 8
  %call19 = call i32 @lremovexattr(i8* %12, i8* %13) #4
  store i32 %call19, i32* %result, align 4
  br label %if.end.20

if.end.20:                                        ; preds = %if.else.16, %if.then.12
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %if.then.8
  %14 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %14)
  %15 = load i32, i32* %result, align 4
  %tobool22 = icmp ne i32 %15, 0
  br i1 %tobool22, label %if.then.23, label %if.end.25

if.then.23:                                       ; preds = %if.end.21
  %call24 = call %struct._object* @path_error(%struct.path_t* %path)
  store %struct._object* %call24, %struct._object** %return_value, align 8
  br label %exit

if.end.25:                                        ; preds = %if.end.21
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  %16 = load %struct._object*, %struct._object** %return_value, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 0
  %17 = load i64, i64* %ob_refcnt, align 8
  %inc = add i64 %17, 1
  store i64 %inc, i64* %ob_refcnt, align 8
  br label %exit

exit:                                             ; preds = %if.end.25, %if.then.23, %if.then.4
  call void @path_cleanup(%struct.path_t* %path)
  call void @path_cleanup(%struct.path_t* %attribute)
  %18 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %18, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %19 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %19
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_listxattr(%struct._object* %self, %struct._object* %args, %struct._object* %kwargs) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %path = alloca %struct.path_t, align 8
  %follow_symlinks = alloca i32, align 4
  %i = alloca i64, align 8
  %result = alloca %struct._object*, align 8
  %buffer = alloca i8*, align 8
  %name = alloca i8*, align 8
  %start = alloca i8*, align 8
  %trace = alloca i8*, align 8
  %end = alloca i8*, align 8
  %length = alloca i64, align 8
  %buffer_size = alloca i64, align 8
  %_save = alloca %struct._ts*, align 8
  %error = alloca i32, align 4
  %attribute = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp55 = alloca %struct._object*, align 8
  %_py_decref_tmp68 = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 1, i32* %follow_symlinks, align 4
  store %struct._object* null, %struct._object** %result, align 8
  store i8* null, i8** %buffer, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.164, i32 0, i32 0), i8** %function_name, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 3
  store i32 1, i32* %allow_fd, align 4
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  store i32 -1, i32* %fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %2 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %call = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %1, %struct._object* %2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.538, i32 0, i32 0), i8** getelementptr inbounds ([3 x i8*], [3 x i8*]* @posix_listxattr.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path, i32* %follow_symlinks)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %fd1 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %3 = load i32, i32* %fd1, align 4
  %4 = load i32, i32* %follow_symlinks, align 4
  %call2 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.164, i32 0, i32 0), i32 %3, i32 %4)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  br label %exit

if.end.5:                                         ; preds = %if.end
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %tobool6 = icmp ne i8* %5, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.5
  %narrow7 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %6 = load i8*, i8** %narrow7, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %6, %cond.true ], [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.204, i32 0, i32 0), %cond.false ]
  store i8* %cond, i8** %name, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.81, %cond.end
  %7 = load i64, i64* %i, align 8
  %arrayidx = getelementptr [3 x i64], [3 x i64]* @posix_listxattr.buffer_sizes, i32 0, i64 %7
  %8 = load i64, i64* %arrayidx, align 8
  store i64 %8, i64* %buffer_size, align 8
  %9 = load i64, i64* %buffer_size, align 8
  %tobool8 = icmp ne i64 %9, 0
  br i1 %tobool8, label %if.end.11, label %if.then.9

if.then.9:                                        ; preds = %for.cond
  %call10 = call %struct._object* @path_error(%struct.path_t* %path)
  br label %for.end.82

if.end.11:                                        ; preds = %for.cond
  %10 = load i64, i64* %buffer_size, align 8
  %call12 = call i8* @PyMem_Malloc(i64 %10)
  store i8* %call12, i8** %buffer, align 8
  %11 = load i8*, i8** %buffer, align 8
  %tobool13 = icmp ne i8* %11, null
  br i1 %tobool13, label %if.end.16, label %if.then.14

if.then.14:                                       ; preds = %if.end.11
  %call15 = call %struct._object* @PyErr_NoMemory()
  br label %for.end.82

if.end.16:                                        ; preds = %if.end.11
  %call17 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call17, %struct._ts** %_save, align 8
  %fd18 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %12 = load i32, i32* %fd18, align 4
  %cmp = icmp sgt i32 %12, -1
  br i1 %cmp, label %if.then.19, label %if.else

if.then.19:                                       ; preds = %if.end.16
  %fd20 = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 6
  %13 = load i32, i32* %fd20, align 4
  %14 = load i8*, i8** %buffer, align 8
  %15 = load i64, i64* %buffer_size, align 8
  %call21 = call i64 @flistxattr(i32 %13, i8* %14, i64 %15) #4
  store i64 %call21, i64* %length, align 8
  br label %if.end.28

if.else:                                          ; preds = %if.end.16
  %16 = load i32, i32* %follow_symlinks, align 4
  %tobool22 = icmp ne i32 %16, 0
  br i1 %tobool22, label %if.then.23, label %if.else.25

if.then.23:                                       ; preds = %if.else
  %17 = load i8*, i8** %name, align 8
  %18 = load i8*, i8** %buffer, align 8
  %19 = load i64, i64* %buffer_size, align 8
  %call24 = call i64 @listxattr(i8* %17, i8* %18, i64 %19) #4
  store i64 %call24, i64* %length, align 8
  br label %if.end.27

if.else.25:                                       ; preds = %if.else
  %20 = load i8*, i8** %name, align 8
  %21 = load i8*, i8** %buffer, align 8
  %22 = load i64, i64* %buffer_size, align 8
  %call26 = call i64 @llistxattr(i8* %20, i8* %21, i64 %22) #4
  store i64 %call26, i64* %length, align 8
  br label %if.end.27

if.end.27:                                        ; preds = %if.else.25, %if.then.23
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.then.19
  %23 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %23)
  %24 = load i64, i64* %length, align 8
  %cmp29 = icmp slt i64 %24, 0
  br i1 %cmp29, label %if.then.30, label %if.end.36

if.then.30:                                       ; preds = %if.end.28
  %call31 = call i32* @__errno_location() #9
  %25 = load i32, i32* %call31, align 4
  %cmp32 = icmp eq i32 %25, 34
  br i1 %cmp32, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.then.30
  %26 = load i8*, i8** %buffer, align 8
  call void @PyMem_Free(i8* %26)
  store i8* null, i8** %buffer, align 8
  br label %for.inc.81

if.end.34:                                        ; preds = %if.then.30
  %call35 = call %struct._object* @path_error(%struct.path_t* %path)
  br label %for.end.82

if.end.36:                                        ; preds = %if.end.28
  %call37 = call %struct._object* @PyList_New(i64 0)
  store %struct._object* %call37, %struct._object** %result, align 8
  %27 = load %struct._object*, %struct._object** %result, align 8
  %tobool38 = icmp ne %struct._object* %27, null
  br i1 %tobool38, label %if.end.40, label %if.then.39

if.then.39:                                       ; preds = %if.end.36
  br label %exit

if.end.40:                                        ; preds = %if.end.36
  %28 = load i8*, i8** %buffer, align 8
  %29 = load i64, i64* %length, align 8
  %add.ptr = getelementptr i8, i8* %28, i64 %29
  store i8* %add.ptr, i8** %end, align 8
  %30 = load i8*, i8** %buffer, align 8
  store i8* %30, i8** %start, align 8
  store i8* %30, i8** %trace, align 8
  br label %for.cond.41

for.cond.41:                                      ; preds = %for.inc, %if.end.40
  %31 = load i8*, i8** %trace, align 8
  %32 = load i8*, i8** %end, align 8
  %cmp42 = icmp ne i8* %31, %32
  br i1 %cmp42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond.41
  %33 = load i8*, i8** %trace, align 8
  %34 = load i8, i8* %33, align 1
  %tobool43 = icmp ne i8 %34, 0
  br i1 %tobool43, label %if.end.80, label %if.then.44

if.then.44:                                       ; preds = %for.body
  %35 = load i8*, i8** %start, align 8
  %36 = load i8*, i8** %trace, align 8
  %37 = load i8*, i8** %start, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %36 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %37 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call45 = call %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8* %35, i64 %sub.ptr.sub)
  store %struct._object* %call45, %struct._object** %attribute, align 8
  %38 = load %struct._object*, %struct._object** %attribute, align 8
  %tobool46 = icmp ne %struct._object* %38, null
  br i1 %tobool46, label %if.end.52, label %if.then.47

if.then.47:                                       ; preds = %if.then.44
  br label %do.body

do.body:                                          ; preds = %if.then.47
  %39 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %39, %struct._object** %_py_decref_tmp, align 8
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 0
  %41 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %41, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp48 = icmp ne i64 %dec, 0
  br i1 %cmp48, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %do.body
  br label %if.end.51

if.else.50:                                       ; preds = %do.body
  %42 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %42, i32 0, i32 1
  %43 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %43, i32 0, i32 4
  %44 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %45 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %44(%struct._object* %45)
  br label %if.end.51

if.end.51:                                        ; preds = %if.else.50, %if.then.49
  br label %do.end

do.end:                                           ; preds = %if.end.51
  store %struct._object* null, %struct._object** %result, align 8
  br label %exit

if.end.52:                                        ; preds = %if.then.44
  %46 = load %struct._object*, %struct._object** %result, align 8
  %47 = load %struct._object*, %struct._object** %attribute, align 8
  %call53 = call i32 @PyList_Append(%struct._object* %46, %struct._object* %47)
  store i32 %call53, i32* %error, align 4
  br label %do.body.54

do.body.54:                                       ; preds = %if.end.52
  %48 = load %struct._object*, %struct._object** %attribute, align 8
  store %struct._object* %48, %struct._object** %_py_decref_tmp55, align 8
  %49 = load %struct._object*, %struct._object** %_py_decref_tmp55, align 8
  %ob_refcnt56 = getelementptr inbounds %struct._object, %struct._object* %49, i32 0, i32 0
  %50 = load i64, i64* %ob_refcnt56, align 8
  %dec57 = add i64 %50, -1
  store i64 %dec57, i64* %ob_refcnt56, align 8
  %cmp58 = icmp ne i64 %dec57, 0
  br i1 %cmp58, label %if.then.59, label %if.else.60

if.then.59:                                       ; preds = %do.body.54
  br label %if.end.63

if.else.60:                                       ; preds = %do.body.54
  %51 = load %struct._object*, %struct._object** %_py_decref_tmp55, align 8
  %ob_type61 = getelementptr inbounds %struct._object, %struct._object* %51, i32 0, i32 1
  %52 = load %struct._typeobject*, %struct._typeobject** %ob_type61, align 8
  %tp_dealloc62 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %52, i32 0, i32 4
  %53 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc62, align 8
  %54 = load %struct._object*, %struct._object** %_py_decref_tmp55, align 8
  call void %53(%struct._object* %54)
  br label %if.end.63

if.end.63:                                        ; preds = %if.else.60, %if.then.59
  br label %do.end.64

do.end.64:                                        ; preds = %if.end.63
  %55 = load i32, i32* %error, align 4
  %tobool65 = icmp ne i32 %55, 0
  br i1 %tobool65, label %if.then.66, label %if.end.78

if.then.66:                                       ; preds = %do.end.64
  br label %do.body.67

do.body.67:                                       ; preds = %if.then.66
  %56 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %56, %struct._object** %_py_decref_tmp68, align 8
  %57 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  %ob_refcnt69 = getelementptr inbounds %struct._object, %struct._object* %57, i32 0, i32 0
  %58 = load i64, i64* %ob_refcnt69, align 8
  %dec70 = add i64 %58, -1
  store i64 %dec70, i64* %ob_refcnt69, align 8
  %cmp71 = icmp ne i64 %dec70, 0
  br i1 %cmp71, label %if.then.72, label %if.else.73

if.then.72:                                       ; preds = %do.body.67
  br label %if.end.76

if.else.73:                                       ; preds = %do.body.67
  %59 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  %ob_type74 = getelementptr inbounds %struct._object, %struct._object* %59, i32 0, i32 1
  %60 = load %struct._typeobject*, %struct._typeobject** %ob_type74, align 8
  %tp_dealloc75 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %60, i32 0, i32 4
  %61 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc75, align 8
  %62 = load %struct._object*, %struct._object** %_py_decref_tmp68, align 8
  call void %61(%struct._object* %62)
  br label %if.end.76

if.end.76:                                        ; preds = %if.else.73, %if.then.72
  br label %do.end.77

do.end.77:                                        ; preds = %if.end.76
  store %struct._object* null, %struct._object** %result, align 8
  br label %exit

if.end.78:                                        ; preds = %do.end.64
  %63 = load i8*, i8** %trace, align 8
  %add.ptr79 = getelementptr i8, i8* %63, i64 1
  store i8* %add.ptr79, i8** %start, align 8
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.78, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.80
  %64 = load i8*, i8** %trace, align 8
  %incdec.ptr = getelementptr i8, i8* %64, i32 1
  store i8* %incdec.ptr, i8** %trace, align 8
  br label %for.cond.41

for.end:                                          ; preds = %for.cond.41
  br label %for.end.82

for.inc.81:                                       ; preds = %if.then.33
  %65 = load i64, i64* %i, align 8
  %inc = add i64 %65, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end.82:                                       ; preds = %for.end, %if.end.34, %if.then.14, %if.then.9
  br label %exit

exit:                                             ; preds = %for.end.82, %do.end.77, %do.end, %if.then.39, %if.then.4
  call void @path_cleanup(%struct.path_t* %path)
  %66 = load i8*, i8** %buffer, align 8
  %tobool83 = icmp ne i8* %66, null
  br i1 %tobool83, label %if.then.84, label %if.end.85

if.then.84:                                       ; preds = %exit
  %67 = load i8*, i8** %buffer, align 8
  call void @PyMem_Free(i8* %67)
  br label %if.end.85

if.end.85:                                        ; preds = %if.then.84, %exit
  %68 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %68, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.85, %if.then
  %69 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %69
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @get_terminal_size(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %columns = alloca i32, align 4
  %lines = alloca i32, align 4
  %termsize = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %w = alloca %struct.winsize, align 2
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %call = call i32 @fileno(%struct._IO_FILE* %0) #4
  store i32 %call, i32* %fd, align 4
  %1 = load %struct._object*, %struct._object** %args.addr, align 8
  %call1 = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.539, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %fd, align 4
  %call2 = call i32 (i32, i64, ...) @ioctl(i32 %2, i64 21523, %struct.winsize* %w) #4
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %3 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %call5 = call %struct._object* @PyErr_SetFromErrno(%struct._object* %3)
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %ws_col = getelementptr inbounds %struct.winsize, %struct.winsize* %w, i32 0, i32 1
  %4 = load i16, i16* %ws_col, align 2
  %conv = zext i16 %4 to i32
  store i32 %conv, i32* %columns, align 4
  %ws_row = getelementptr inbounds %struct.winsize, %struct.winsize* %w, i32 0, i32 0
  %5 = load i16, i16* %ws_row, align 2
  %conv7 = zext i16 %5 to i32
  store i32 %conv7, i32* %lines, align 4
  %call8 = call %struct._object* @PyStructSequence_New(%struct._typeobject* @TerminalSizeType)
  store %struct._object* %call8, %struct._object** %termsize, align 8
  %6 = load %struct._object*, %struct._object** %termsize, align 8
  %cmp = icmp eq %struct._object* %6, null
  br i1 %cmp, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.6
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.11:                                        ; preds = %if.end.6
  %7 = load i32, i32* %columns, align 4
  %conv12 = sext i32 %7 to i64
  %call13 = call %struct._object* @PyLong_FromLong(i64 %conv12)
  %8 = load %struct._object*, %struct._object** %termsize, align 8
  %9 = bitcast %struct._object* %8 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %9, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %call13, %struct._object** %arrayidx, align 8
  %10 = load i32, i32* %lines, align 4
  %conv14 = sext i32 %10 to i64
  %call15 = call %struct._object* @PyLong_FromLong(i64 %conv14)
  %11 = load %struct._object*, %struct._object** %termsize, align 8
  %12 = bitcast %struct._object* %11 to %struct.PyTupleObject*
  %ob_item16 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %12, i32 0, i32 1
  %arrayidx17 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item16, i32 0, i64 1
  store %struct._object* %call15, %struct._object** %arrayidx17, align 8
  %call18 = call %struct._object* @PyErr_Occurred()
  %tobool19 = icmp ne %struct._object* %call18, null
  br i1 %tobool19, label %if.then.20, label %if.end.25

if.then.20:                                       ; preds = %if.end.11
  br label %do.body

do.body:                                          ; preds = %if.then.20
  %13 = load %struct._object*, %struct._object** %termsize, align 8
  store %struct._object* %13, %struct._object** %_py_decref_tmp, align 8
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 0
  %15 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %15, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp21 = icmp ne i64 %dec, 0
  br i1 %cmp21, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %do.body
  br label %if.end.24

if.else:                                          ; preds = %do.body
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 1
  %17 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %17, i32 0, i32 4
  %18 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %19 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %18(%struct._object* %19)
  br label %if.end.24

if.end.24:                                        ; preds = %if.else, %if.then.23
  br label %do.end

do.end:                                           ; preds = %if.end.24
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.25:                                        ; preds = %if.end.11
  %20 = load %struct._object*, %struct._object** %termsize, align 8
  store %struct._object* %20, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.25, %do.end, %if.then.10, %if.then.4, %if.then
  %21 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %21
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_cpu_count(%struct._object* %self) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %ncpu = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store i32 0, i32* %ncpu, align 4
  %call = call i64 @sysconf(i32 84) #4
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %ncpu, align 4
  %0 = load i32, i32* %ncpu, align 4
  %cmp = icmp sge i32 %0, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %ncpu, align 4
  %conv2 = sext i32 %1 to i64
  %call3 = call %struct._object* @PyLong_FromLong(i64 %conv2)
  store %struct._object* %call3, %struct._object** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %2, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_get_inheritable(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %inheritable = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.540, i32 0, i32 0), i32* %fd)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %call1 = call i32 @_Py_get_inheritable(i32 %1)
  store i32 %call1, i32* %inheritable, align 4
  %2 = load i32, i32* %inheritable, align 4
  %cmp = icmp slt i32 %2, 0
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i32, i32* %inheritable, align 4
  %conv = sext i32 %3 to i64
  %call4 = call %struct._object* @PyBool_FromLong(i64 %conv)
  store %struct._object* %call4, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.3, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_set_inheritable(%struct._object* %self, %struct._object* %args) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %self.addr = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %fd = alloca i32, align 4
  %inheritable = alloca i32, align 4
  store %struct._object* %self, %struct._object** %self.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  %0 = load %struct._object*, %struct._object** %args.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %0, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.541, i32 0, i32 0), i32* %fd, i32* %inheritable)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i32, i32* %fd, align 4
  %2 = load i32, i32* %inheritable, align 4
  %call1 = call i32 @_Py_set_inheritable(i32 %1, i32 %2, i32* null)
  %cmp = icmp slt i32 %call1, 0
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %3 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %3, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.3, %if.then.2, %if.then
  %4 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %4
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #4

declare i32 @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object*, %struct._object*, i8*, i8**, ...) #1

; Function Attrs: nounwind uwtable
define internal i32 @path_converter(%struct._object* %o, i8* %p) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct._object*, align 8
  %p.addr = alloca i8*, align 8
  %path = alloca %struct.path_t*, align 8
  %unicode = alloca %struct._object*, align 8
  %bytes = alloca %struct._object*, align 8
  %length = alloca i64, align 8
  %narrow = alloca i8*, align 8
  %converted = alloca i32, align 4
  %_py_decref_tmp = alloca %struct._object*, align 8
  %fd43 = alloca i32, align 4
  %result = alloca i32, align 4
  %_py_decref_tmp103 = alloca %struct._object*, align 8
  store %struct._object* %o, %struct._object** %o.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  %1 = bitcast i8* %0 to %struct.path_t*
  store %struct.path_t* %1, %struct.path_t** %path, align 8
  %2 = load %struct._object*, %struct._object** %o.addr, align 8
  %cmp = icmp eq %struct._object* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.path_t*, %struct.path_t** %path, align 8
  call void @path_cleanup(%struct.path_t* %3)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.path_t*, %struct.path_t** %path, align 8
  %cleanup = getelementptr inbounds %struct.path_t, %struct.path_t* %4, i32 0, i32 9
  store %struct._object* null, %struct._object** %cleanup, align 8
  %5 = load %struct._object*, %struct._object** %o.addr, align 8
  %cmp1 = icmp eq %struct._object* %5, @_Py_NoneStruct
  br i1 %cmp1, label %if.then.2, label %if.end.18

if.then.2:                                        ; preds = %if.end
  %6 = load %struct.path_t*, %struct.path_t** %path, align 8
  %nullable = getelementptr inbounds %struct.path_t, %struct.path_t* %6, i32 0, i32 2
  %7 = load i32, i32* %nullable, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.end.15, label %if.then.3

if.then.3:                                        ; preds = %if.then.2
  %8 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %9 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %9, i32 0, i32 0
  %10 = load i8*, i8** %function_name, align 8
  %tobool4 = icmp ne i8* %10, null
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.3
  %11 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name5 = getelementptr inbounds %struct.path_t, %struct.path_t* %11, i32 0, i32 0
  %12 = load i8*, i8** %function_name5, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %12, %cond.true ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), %cond.false ]
  %13 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name6 = getelementptr inbounds %struct.path_t, %struct.path_t* %13, i32 0, i32 0
  %14 = load i8*, i8** %function_name6, align 8
  %tobool7 = icmp ne i8* %14, null
  %cond8 = select i1 %tobool7, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0)
  %15 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name = getelementptr inbounds %struct.path_t, %struct.path_t* %15, i32 0, i32 1
  %16 = load i8*, i8** %argument_name, align 8
  %tobool9 = icmp ne i8* %16, null
  br i1 %tobool9, label %cond.true.10, label %cond.false.12

cond.true.10:                                     ; preds = %cond.end
  %17 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name11 = getelementptr inbounds %struct.path_t, %struct.path_t* %17, i32 0, i32 1
  %18 = load i8*, i8** %argument_name11, align 8
  br label %cond.end.13

cond.false.12:                                    ; preds = %cond.end
  br label %cond.end.13

cond.end.13:                                      ; preds = %cond.false.12, %cond.true.10
  %cond14 = phi i8* [ %18, %cond.true.10 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), %cond.false.12 ]
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %8, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.173, i32 0, i32 0), i8* %cond, i8* %cond8, i8* %cond14)
  store i32 0, i32* %retval
  br label %return

if.end.15:                                        ; preds = %if.then.2
  %19 = load %struct.path_t*, %struct.path_t** %path, align 8
  %wide = getelementptr inbounds %struct.path_t, %struct.path_t* %19, i32 0, i32 4
  store i32* null, i32** %wide, align 8
  %20 = load %struct.path_t*, %struct.path_t** %path, align 8
  %narrow16 = getelementptr inbounds %struct.path_t, %struct.path_t* %20, i32 0, i32 5
  store i8* null, i8** %narrow16, align 8
  %21 = load %struct.path_t*, %struct.path_t** %path, align 8
  %length17 = getelementptr inbounds %struct.path_t, %struct.path_t* %21, i32 0, i32 7
  store i64 0, i64* %length17, align 8
  %22 = load %struct._object*, %struct._object** %o.addr, align 8
  %23 = load %struct.path_t*, %struct.path_t** %path, align 8
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %23, i32 0, i32 8
  store %struct._object* %22, %struct._object** %object, align 8
  %24 = load %struct.path_t*, %struct.path_t** %path, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %24, i32 0, i32 6
  store i32 -1, i32* %fd, align 4
  store i32 1, i32* %retval
  br label %return

if.end.18:                                        ; preds = %if.end
  %25 = load %struct._object*, %struct._object** %o.addr, align 8
  %call19 = call %struct._object* @PyUnicode_FromObject(%struct._object* %25)
  store %struct._object* %call19, %struct._object** %unicode, align 8
  %26 = load %struct._object*, %struct._object** %unicode, align 8
  %tobool20 = icmp ne %struct._object* %26, null
  br i1 %tobool20, label %if.then.21, label %if.else.29

if.then.21:                                       ; preds = %if.end.18
  %27 = load %struct._object*, %struct._object** %unicode, align 8
  %28 = bitcast %struct._object** %bytes to i8*
  %call22 = call i32 @PyUnicode_FSConverter(%struct._object* %27, i8* %28)
  store i32 %call22, i32* %converted, align 4
  br label %do.body

do.body:                                          ; preds = %if.then.21
  %29 = load %struct._object*, %struct._object** %unicode, align 8
  store %struct._object* %29, %struct._object** %_py_decref_tmp, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %30, i32 0, i32 0
  %31 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %31, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp23 = icmp ne i64 %dec, 0
  br i1 %cmp23, label %if.then.24, label %if.else

if.then.24:                                       ; preds = %do.body
  br label %if.end.25

if.else:                                          ; preds = %do.body
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 1
  %33 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %33, i32 0, i32 4
  %34 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %34(%struct._object* %35)
  br label %if.end.25

if.end.25:                                        ; preds = %if.else, %if.then.24
  br label %do.end

do.end:                                           ; preds = %if.end.25
  %36 = load i32, i32* %converted, align 4
  %tobool26 = icmp ne i32 %36, 0
  br i1 %tobool26, label %if.end.28, label %if.then.27

if.then.27:                                       ; preds = %do.end
  store %struct._object* null, %struct._object** %bytes, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %do.end
  br label %if.end.55

if.else.29:                                       ; preds = %if.end.18
  call void @PyErr_Clear()
  %37 = load %struct._object*, %struct._object** %o.addr, align 8
  %ob_type30 = getelementptr inbounds %struct._object, %struct._object* %37, i32 0, i32 1
  %38 = load %struct._typeobject*, %struct._typeobject** %ob_type30, align 8
  %tp_as_buffer = getelementptr inbounds %struct._typeobject, %struct._typeobject* %38, i32 0, i32 18
  %39 = load %struct.PyBufferProcs*, %struct.PyBufferProcs** %tp_as_buffer, align 8
  %cmp31 = icmp ne %struct.PyBufferProcs* %39, null
  br i1 %cmp31, label %land.lhs.true, label %if.else.37

land.lhs.true:                                    ; preds = %if.else.29
  %40 = load %struct._object*, %struct._object** %o.addr, align 8
  %ob_type32 = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 1
  %41 = load %struct._typeobject*, %struct._typeobject** %ob_type32, align 8
  %tp_as_buffer33 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %41, i32 0, i32 18
  %42 = load %struct.PyBufferProcs*, %struct.PyBufferProcs** %tp_as_buffer33, align 8
  %bf_getbuffer = getelementptr inbounds %struct.PyBufferProcs, %struct.PyBufferProcs* %42, i32 0, i32 0
  %43 = load i32 (%struct._object*, %struct.bufferinfo*, i32)*, i32 (%struct._object*, %struct.bufferinfo*, i32)** %bf_getbuffer, align 8
  %cmp34 = icmp ne i32 (%struct._object*, %struct.bufferinfo*, i32)* %43, null
  br i1 %cmp34, label %if.then.35, label %if.else.37

if.then.35:                                       ; preds = %land.lhs.true
  %44 = load %struct._object*, %struct._object** %o.addr, align 8
  %call36 = call %struct._object* @PyBytes_FromObject(%struct._object* %44)
  store %struct._object* %call36, %struct._object** %bytes, align 8
  br label %if.end.38

if.else.37:                                       ; preds = %land.lhs.true, %if.else.29
  store %struct._object* null, %struct._object** %bytes, align 8
  br label %if.end.38

if.end.38:                                        ; preds = %if.else.37, %if.then.35
  %45 = load %struct._object*, %struct._object** %bytes, align 8
  %tobool39 = icmp ne %struct._object* %45, null
  br i1 %tobool39, label %if.end.54, label %if.then.40

if.then.40:                                       ; preds = %if.end.38
  call void @PyErr_Clear()
  %46 = load %struct.path_t*, %struct.path_t** %path, align 8
  %allow_fd = getelementptr inbounds %struct.path_t, %struct.path_t* %46, i32 0, i32 3
  %47 = load i32, i32* %allow_fd, align 4
  %tobool41 = icmp ne i32 %47, 0
  br i1 %tobool41, label %if.then.42, label %if.end.53

if.then.42:                                       ; preds = %if.then.40
  %48 = load %struct._object*, %struct._object** %o.addr, align 8
  %call44 = call i32 @_fd_converter(%struct._object* %48, i32* %fd43, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.175, i32 0, i32 0))
  store i32 %call44, i32* %result, align 4
  %49 = load i32, i32* %result, align 4
  %tobool45 = icmp ne i32 %49, 0
  br i1 %tobool45, label %if.then.46, label %if.end.52

if.then.46:                                       ; preds = %if.then.42
  %50 = load %struct.path_t*, %struct.path_t** %path, align 8
  %wide47 = getelementptr inbounds %struct.path_t, %struct.path_t* %50, i32 0, i32 4
  store i32* null, i32** %wide47, align 8
  %51 = load %struct.path_t*, %struct.path_t** %path, align 8
  %narrow48 = getelementptr inbounds %struct.path_t, %struct.path_t* %51, i32 0, i32 5
  store i8* null, i8** %narrow48, align 8
  %52 = load %struct.path_t*, %struct.path_t** %path, align 8
  %length49 = getelementptr inbounds %struct.path_t, %struct.path_t* %52, i32 0, i32 7
  store i64 0, i64* %length49, align 8
  %53 = load %struct._object*, %struct._object** %o.addr, align 8
  %54 = load %struct.path_t*, %struct.path_t** %path, align 8
  %object50 = getelementptr inbounds %struct.path_t, %struct.path_t* %54, i32 0, i32 8
  store %struct._object* %53, %struct._object** %object50, align 8
  %55 = load i32, i32* %fd43, align 4
  %56 = load %struct.path_t*, %struct.path_t** %path, align 8
  %fd51 = getelementptr inbounds %struct.path_t, %struct.path_t* %56, i32 0, i32 6
  store i32 %55, i32* %fd51, align 4
  %57 = load i32, i32* %result, align 4
  store i32 %57, i32* %retval
  br label %return

if.end.52:                                        ; preds = %if.then.42
  br label %if.end.53

if.end.53:                                        ; preds = %if.end.52, %if.then.40
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.end.38
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %if.end.28
  %58 = load %struct._object*, %struct._object** %bytes, align 8
  %tobool56 = icmp ne %struct._object* %58, null
  br i1 %tobool56, label %if.end.80, label %if.then.57

if.then.57:                                       ; preds = %if.end.55
  %call58 = call %struct._object* @PyErr_Occurred()
  %tobool59 = icmp ne %struct._object* %call58, null
  br i1 %tobool59, label %if.end.79, label %if.then.60

if.then.60:                                       ; preds = %if.then.57
  %59 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %60 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name61 = getelementptr inbounds %struct.path_t, %struct.path_t* %60, i32 0, i32 0
  %61 = load i8*, i8** %function_name61, align 8
  %tobool62 = icmp ne i8* %61, null
  br i1 %tobool62, label %cond.true.63, label %cond.false.65

cond.true.63:                                     ; preds = %if.then.60
  %62 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name64 = getelementptr inbounds %struct.path_t, %struct.path_t* %62, i32 0, i32 0
  %63 = load i8*, i8** %function_name64, align 8
  br label %cond.end.66

cond.false.65:                                    ; preds = %if.then.60
  br label %cond.end.66

cond.end.66:                                      ; preds = %cond.false.65, %cond.true.63
  %cond67 = phi i8* [ %63, %cond.true.63 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), %cond.false.65 ]
  %64 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name68 = getelementptr inbounds %struct.path_t, %struct.path_t* %64, i32 0, i32 0
  %65 = load i8*, i8** %function_name68, align 8
  %tobool69 = icmp ne i8* %65, null
  %cond70 = select i1 %tobool69, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0)
  %66 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name71 = getelementptr inbounds %struct.path_t, %struct.path_t* %66, i32 0, i32 1
  %67 = load i8*, i8** %argument_name71, align 8
  %tobool72 = icmp ne i8* %67, null
  br i1 %tobool72, label %cond.true.73, label %cond.false.75

cond.true.73:                                     ; preds = %cond.end.66
  %68 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name74 = getelementptr inbounds %struct.path_t, %struct.path_t* %68, i32 0, i32 1
  %69 = load i8*, i8** %argument_name74, align 8
  br label %cond.end.76

cond.false.75:                                    ; preds = %cond.end.66
  br label %cond.end.76

cond.end.76:                                      ; preds = %cond.false.75, %cond.true.73
  %cond77 = phi i8* [ %69, %cond.true.73 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), %cond.false.75 ]
  %call78 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %59, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.176, i32 0, i32 0), i8* %cond67, i8* %cond70, i8* %cond77)
  br label %if.end.79

if.end.79:                                        ; preds = %cond.end.76, %if.then.57
  store i32 0, i32* %retval
  br label %return

if.end.80:                                        ; preds = %if.end.55
  %70 = load %struct._object*, %struct._object** %bytes, align 8
  %71 = bitcast %struct._object* %70 to %struct.PyVarObject*
  %ob_size = getelementptr inbounds %struct.PyVarObject, %struct.PyVarObject* %71, i32 0, i32 1
  %72 = load i64, i64* %ob_size, align 8
  store i64 %72, i64* %length, align 8
  %73 = load %struct._object*, %struct._object** %bytes, align 8
  %74 = bitcast %struct._object* %73 to %struct.PyBytesObject*
  %ob_sval = getelementptr inbounds %struct.PyBytesObject, %struct.PyBytesObject* %74, i32 0, i32 2
  %arraydecay = getelementptr inbounds [1 x i8], [1 x i8]* %ob_sval, i32 0, i32 0
  store i8* %arraydecay, i8** %narrow, align 8
  %75 = load i64, i64* %length, align 8
  %76 = load i8*, i8** %narrow, align 8
  %call81 = call i64 @strlen(i8* %76) #8
  %cmp82 = icmp ne i64 %75, %call81
  br i1 %cmp82, label %if.then.83, label %if.end.113

if.then.83:                                       ; preds = %if.end.80
  %77 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %78 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name84 = getelementptr inbounds %struct.path_t, %struct.path_t* %78, i32 0, i32 0
  %79 = load i8*, i8** %function_name84, align 8
  %tobool85 = icmp ne i8* %79, null
  br i1 %tobool85, label %cond.true.86, label %cond.false.88

cond.true.86:                                     ; preds = %if.then.83
  %80 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name87 = getelementptr inbounds %struct.path_t, %struct.path_t* %80, i32 0, i32 0
  %81 = load i8*, i8** %function_name87, align 8
  br label %cond.end.89

cond.false.88:                                    ; preds = %if.then.83
  br label %cond.end.89

cond.end.89:                                      ; preds = %cond.false.88, %cond.true.86
  %cond90 = phi i8* [ %81, %cond.true.86 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), %cond.false.88 ]
  %82 = load %struct.path_t*, %struct.path_t** %path, align 8
  %function_name91 = getelementptr inbounds %struct.path_t, %struct.path_t* %82, i32 0, i32 0
  %83 = load i8*, i8** %function_name91, align 8
  %tobool92 = icmp ne i8* %83, null
  %cond93 = select i1 %tobool92, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0)
  %84 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name94 = getelementptr inbounds %struct.path_t, %struct.path_t* %84, i32 0, i32 1
  %85 = load i8*, i8** %argument_name94, align 8
  %tobool95 = icmp ne i8* %85, null
  br i1 %tobool95, label %cond.true.96, label %cond.false.98

cond.true.96:                                     ; preds = %cond.end.89
  %86 = load %struct.path_t*, %struct.path_t** %path, align 8
  %argument_name97 = getelementptr inbounds %struct.path_t, %struct.path_t* %86, i32 0, i32 1
  %87 = load i8*, i8** %argument_name97, align 8
  br label %cond.end.99

cond.false.98:                                    ; preds = %cond.end.89
  br label %cond.end.99

cond.end.99:                                      ; preds = %cond.false.98, %cond.true.96
  %cond100 = phi i8* [ %87, %cond.true.96 ], [ getelementptr inbounds ([5 x i8], [5 x i8]* @.str.169, i32 0, i32 0), %cond.false.98 ]
  %call101 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %77, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.177, i32 0, i32 0), i8* %cond90, i8* %cond93, i8* %cond100)
  br label %do.body.102

do.body.102:                                      ; preds = %cond.end.99
  %88 = load %struct._object*, %struct._object** %bytes, align 8
  store %struct._object* %88, %struct._object** %_py_decref_tmp103, align 8
  %89 = load %struct._object*, %struct._object** %_py_decref_tmp103, align 8
  %ob_refcnt104 = getelementptr inbounds %struct._object, %struct._object* %89, i32 0, i32 0
  %90 = load i64, i64* %ob_refcnt104, align 8
  %dec105 = add i64 %90, -1
  store i64 %dec105, i64* %ob_refcnt104, align 8
  %cmp106 = icmp ne i64 %dec105, 0
  br i1 %cmp106, label %if.then.107, label %if.else.108

if.then.107:                                      ; preds = %do.body.102
  br label %if.end.111

if.else.108:                                      ; preds = %do.body.102
  %91 = load %struct._object*, %struct._object** %_py_decref_tmp103, align 8
  %ob_type109 = getelementptr inbounds %struct._object, %struct._object* %91, i32 0, i32 1
  %92 = load %struct._typeobject*, %struct._typeobject** %ob_type109, align 8
  %tp_dealloc110 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %92, i32 0, i32 4
  %93 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc110, align 8
  %94 = load %struct._object*, %struct._object** %_py_decref_tmp103, align 8
  call void %93(%struct._object* %94)
  br label %if.end.111

if.end.111:                                       ; preds = %if.else.108, %if.then.107
  br label %do.end.112

do.end.112:                                       ; preds = %if.end.111
  store i32 0, i32* %retval
  br label %return

if.end.113:                                       ; preds = %if.end.80
  %95 = load %struct.path_t*, %struct.path_t** %path, align 8
  %wide114 = getelementptr inbounds %struct.path_t, %struct.path_t* %95, i32 0, i32 4
  store i32* null, i32** %wide114, align 8
  %96 = load i8*, i8** %narrow, align 8
  %97 = load %struct.path_t*, %struct.path_t** %path, align 8
  %narrow115 = getelementptr inbounds %struct.path_t, %struct.path_t* %97, i32 0, i32 5
  store i8* %96, i8** %narrow115, align 8
  %98 = load i64, i64* %length, align 8
  %99 = load %struct.path_t*, %struct.path_t** %path, align 8
  %length116 = getelementptr inbounds %struct.path_t, %struct.path_t* %99, i32 0, i32 7
  store i64 %98, i64* %length116, align 8
  %100 = load %struct._object*, %struct._object** %o.addr, align 8
  %101 = load %struct.path_t*, %struct.path_t** %path, align 8
  %object117 = getelementptr inbounds %struct.path_t, %struct.path_t* %101, i32 0, i32 8
  store %struct._object* %100, %struct._object** %object117, align 8
  %102 = load %struct.path_t*, %struct.path_t** %path, align 8
  %fd118 = getelementptr inbounds %struct.path_t, %struct.path_t* %102, i32 0, i32 6
  store i32 -1, i32* %fd118, align 4
  %103 = load %struct._object*, %struct._object** %bytes, align 8
  %104 = load %struct.path_t*, %struct.path_t** %path, align 8
  %cleanup119 = getelementptr inbounds %struct.path_t, %struct.path_t* %104, i32 0, i32 9
  store %struct._object* %103, %struct._object** %cleanup119, align 8
  store i32 131072, i32* %retval
  br label %return

return:                                           ; preds = %if.end.113, %do.end.112, %if.end.79, %if.then.46, %if.end.15, %cond.end.13, %if.then
  %105 = load i32, i32* %retval
  ret i32 %105
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @os_stat_impl(%struct.PyModuleDef* %module, %struct.path_t* %path, i32 %dir_fd, i32 %follow_symlinks) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %path.addr = alloca %struct.path_t*, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %1 = load i32, i32* %dir_fd.addr, align 4
  %2 = load i32, i32* %follow_symlinks.addr, align 4
  %call = call %struct._object* @posix_do_stat(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), %struct.path_t* %0, i32 %1, i32 %2)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal void @path_cleanup(%struct.path_t* %path) #0 {
entry:
  %path.addr = alloca %struct.path_t*, align 8
  %_py_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  %0 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %cleanup = getelementptr inbounds %struct.path_t, %struct.path_t* %0, i32 0, i32 9
  %1 = load %struct._object*, %struct._object** %cleanup, align 8
  %tobool = icmp ne %struct._object* %1, null
  br i1 %tobool, label %if.then, label %if.end.9

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %cleanup1 = getelementptr inbounds %struct.path_t, %struct.path_t* %2, i32 0, i32 9
  %3 = load %struct._object*, %struct._object** %cleanup1, align 8
  store %struct._object* %3, %struct._object** %_py_tmp, align 8
  %4 = load %struct._object*, %struct._object** %_py_tmp, align 8
  %cmp = icmp ne %struct._object* %4, null
  br i1 %cmp, label %if.then.2, label %if.end.7

if.then.2:                                        ; preds = %do.body
  %5 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %cleanup3 = getelementptr inbounds %struct.path_t, %struct.path_t* %5, i32 0, i32 9
  store %struct._object* null, %struct._object** %cleanup3, align 8
  br label %do.body.4

do.body.4:                                        ; preds = %if.then.2
  %6 = load %struct._object*, %struct._object** %_py_tmp, align 8
  store %struct._object* %6, %struct._object** %_py_decref_tmp, align 8
  %7 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %7, i32 0, i32 0
  %8 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %8, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp5 = icmp ne i64 %dec, 0
  br i1 %cmp5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %do.body.4
  br label %if.end

if.else:                                          ; preds = %do.body.4
  %9 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %9, i32 0, i32 1
  %10 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %10, i32 0, i32 4
  %11 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %12 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %11(%struct._object* %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.6
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end.7

if.end.7:                                         ; preds = %do.end, %do.body
  br label %do.end.8

do.end.8:                                         ; preds = %if.end.7
  br label %if.end.9

if.end.9:                                         ; preds = %do.end.8, %entry
  ret void
}

declare %struct._object* @PyUnicode_FromObject(%struct._object*) #1

declare i32 @PyUnicode_FSConverter(%struct._object*, i8*) #1

declare void @PyErr_Clear() #1

declare %struct._object* @PyBytes_FromObject(%struct._object*) #1

; Function Attrs: nounwind uwtable
define internal i32 @_fd_converter(%struct._object* %o, i32* %p, i8* %allowed) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct._object*, align 8
  %p.addr = alloca i32*, align 8
  %allowed.addr = alloca i8*, align 8
  %overflow = alloca i32, align 4
  %long_value = alloca i64, align 8
  %index = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %o, %struct._object** %o.addr, align 8
  store i32* %p, i32** %p.addr, align 8
  store i8* %allowed, i8** %allowed.addr, align 8
  %0 = load %struct._object*, %struct._object** %o.addr, align 8
  %call = call %struct._object* @PyNumber_Index(%struct._object* %0)
  store %struct._object* %call, %struct._object** %index, align 8
  %1 = load %struct._object*, %struct._object** %index, align 8
  %cmp = icmp eq %struct._object* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %3 = load i8*, i8** %allowed.addr, align 8
  %4 = load %struct._object*, %struct._object** %o.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %4, i32 0, i32 1
  %5 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_name = getelementptr inbounds %struct._typeobject, %struct._typeobject* %5, i32 0, i32 1
  %6 = load i8*, i8** %tp_name, align 8
  %call1 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.178, i32 0, i32 0), i8* %3, i8* %6)
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct._object*, %struct._object** %index, align 8
  %call2 = call i64 @PyLong_AsLongAndOverflow(%struct._object* %7, i32* %overflow)
  store i64 %call2, i64* %long_value, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %8 = load %struct._object*, %struct._object** %index, align 8
  store %struct._object* %8, %struct._object** %_py_decref_tmp, align 8
  %9 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %9, i32 0, i32 0
  %10 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %10, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp3 = icmp ne i64 %dec, 0
  br i1 %cmp3, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %do.body
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %11 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type5 = getelementptr inbounds %struct._object, %struct._object* %11, i32 0, i32 1
  %12 = load %struct._typeobject*, %struct._typeobject** %ob_type5, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %12, i32 0, i32 4
  %13 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %13(%struct._object* %14)
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.4
  br label %do.end

do.end:                                           ; preds = %if.end.6
  %15 = load i32, i32* %overflow, align 4
  %cmp7 = icmp sgt i32 %15, 0
  br i1 %cmp7, label %if.then.9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %16 = load i64, i64* %long_value, align 8
  %cmp8 = icmp sgt i64 %16, 2147483647
  br i1 %cmp8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %lor.lhs.false, %do.end
  %17 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %17, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.179, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %lor.lhs.false
  %18 = load i32, i32* %overflow, align 4
  %cmp11 = icmp slt i32 %18, 0
  br i1 %cmp11, label %if.then.14, label %lor.lhs.false.12

lor.lhs.false.12:                                 ; preds = %if.end.10
  %19 = load i64, i64* %long_value, align 8
  %cmp13 = icmp slt i64 %19, -2147483648
  br i1 %cmp13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %lor.lhs.false.12, %if.end.10
  %20 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %20, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.180, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.15:                                        ; preds = %lor.lhs.false.12
  %21 = load i64, i64* %long_value, align 8
  %conv = trunc i64 %21 to i32
  %22 = load i32*, i32** %p.addr, align 8
  store i32 %conv, i32* %22, align 4
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.15, %if.then.14, %if.then.9, %if.then
  %23 = load i32, i32* %retval
  ret i32 %23
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_do_stat(i8* %function_name, %struct.path_t* %path, i32 %dir_fd, i32 %follow_symlinks) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %function_name.addr = alloca i8*, align 8
  %path.addr = alloca %struct.path_t*, align 8
  %dir_fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store i8* %function_name, i8** %function_name.addr, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %1 = load i32, i32* %dir_fd.addr, align 4
  %call = call i32 @path_and_dir_fd_invalid(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), %struct.path_t* %0, i32 %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i32, i32* %dir_fd.addr, align 4
  %3 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd = getelementptr inbounds %struct.path_t, %struct.path_t* %3, i32 0, i32 6
  %4 = load i32, i32* %fd, align 4
  %call1 = call i32 @dir_fd_and_fd_invalid(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), i32 %2, i32 %4)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.then, label %lor.lhs.false.3

lor.lhs.false.3:                                  ; preds = %lor.lhs.false
  %5 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd4 = getelementptr inbounds %struct.path_t, %struct.path_t* %5, i32 0, i32 6
  %6 = load i32, i32* %fd4, align 4
  %7 = load i32, i32* %follow_symlinks.addr, align 4
  %call5 = call i32 @fd_and_follow_symlinks_invalid(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), i32 %6, i32 %7)
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.3, %lor.lhs.false, %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.3
  %call7 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call7, %struct._ts** %_save, align 8
  %8 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd8 = getelementptr inbounds %struct.path_t, %struct.path_t* %8, i32 0, i32 6
  %9 = load i32, i32* %fd8, align 4
  %cmp = icmp ne i32 %9, -1
  br i1 %cmp, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %if.end
  %10 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd10 = getelementptr inbounds %struct.path_t, %struct.path_t* %10, i32 0, i32 6
  %11 = load i32, i32* %fd10, align 4
  %call11 = call i32 @fstat64(i32 %11, %struct.stat* %st) #4
  store i32 %call11, i32* %result, align 4
  br label %if.end.29

if.else:                                          ; preds = %if.end
  %12 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool12 = icmp ne i32 %12, 0
  br i1 %tobool12, label %if.else.16, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %13 = load i32, i32* %dir_fd.addr, align 4
  %cmp13 = icmp eq i32 %13, -100
  br i1 %cmp13, label %if.then.14, label %if.else.16

if.then.14:                                       ; preds = %land.lhs.true
  %14 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %14, i32 0, i32 5
  %15 = load i8*, i8** %narrow, align 8
  %call15 = call i32 @lstat64(i8* %15, %struct.stat* %st) #4
  store i32 %call15, i32* %result, align 4
  br label %if.end.28

if.else.16:                                       ; preds = %land.lhs.true, %if.else
  %16 = load i32, i32* %dir_fd.addr, align 4
  %cmp17 = icmp ne i32 %16, -100
  br i1 %cmp17, label %if.then.20, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %if.else.16
  %17 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool19 = icmp ne i32 %17, 0
  br i1 %tobool19, label %if.else.24, label %if.then.20

if.then.20:                                       ; preds = %lor.lhs.false.18, %if.else.16
  %18 = load i32, i32* %dir_fd.addr, align 4
  %19 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow21 = getelementptr inbounds %struct.path_t, %struct.path_t* %19, i32 0, i32 5
  %20 = load i8*, i8** %narrow21, align 8
  %21 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool22 = icmp ne i32 %21, 0
  %cond = select i1 %tobool22, i32 0, i32 256
  %call23 = call i32 @fstatat64(i32 %18, i8* %20, %struct.stat* %st, i32 %cond) #4
  store i32 %call23, i32* %result, align 4
  br label %if.end.27

if.else.24:                                       ; preds = %lor.lhs.false.18
  %22 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow25 = getelementptr inbounds %struct.path_t, %struct.path_t* %22, i32 0, i32 5
  %23 = load i8*, i8** %narrow25, align 8
  %call26 = call i32 @stat64(i8* %23, %struct.stat* %st) #4
  store i32 %call26, i32* %result, align 4
  br label %if.end.27

if.end.27:                                        ; preds = %if.else.24, %if.then.20
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.then.14
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %if.then.9
  %24 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %24)
  %25 = load i32, i32* %result, align 4
  %cmp30 = icmp ne i32 %25, 0
  br i1 %cmp30, label %if.then.31, label %if.end.33

if.then.31:                                       ; preds = %if.end.29
  %26 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %call32 = call %struct._object* @path_error(%struct.path_t* %26)
  store %struct._object* %call32, %struct._object** %retval
  br label %return

if.end.33:                                        ; preds = %if.end.29
  %call34 = call %struct._object* @_pystat_fromstructstat(%struct.stat* %st)
  store %struct._object* %call34, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.33, %if.then.31, %if.then
  %27 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %27
}

; Function Attrs: nounwind uwtable
define internal i32 @path_and_dir_fd_invalid(i8* %function_name, %struct.path_t* %path, i32 %dir_fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %path.addr = alloca %struct.path_t*, align 8
  %dir_fd.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  %0 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %0, i32 0, i32 5
  %1 = load i8*, i8** %narrow, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %wide = getelementptr inbounds %struct.path_t, %struct.path_t* %2, i32 0, i32 4
  %3 = load i32*, i32** %wide, align 8
  %tobool1 = icmp ne i32* %3, null
  br i1 %tobool1, label %if.end, label %land.lhs.true.2

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %4 = load i32, i32* %dir_fd.addr, align 4
  %cmp = icmp ne i32 %4, -100
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.2
  %5 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %6 = load i8*, i8** %function_name.addr, align 8
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %5, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.181, i32 0, i32 0), i8* %6)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.2, %land.lhs.true, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32, i32* %retval
  ret i32 %7
}

; Function Attrs: nounwind uwtable
define internal i32 @dir_fd_and_fd_invalid(i8* %function_name, i32 %dir_fd, i32 %fd) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %dir_fd.addr = alloca i32, align 4
  %fd.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %fd.addr, align 4
  %cmp1 = icmp ne i32 %1, -1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %2 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %3 = load i8*, i8** %function_name.addr, align 8
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.182, i32 0, i32 0), i8* %3)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval
  ret i32 %4
}

; Function Attrs: nounwind uwtable
define internal i32 @fd_and_follow_symlinks_invalid(i8* %function_name, i32 %fd, i32 %follow_symlinks) #0 {
entry:
  %retval = alloca i32, align 4
  %function_name.addr = alloca i8*, align 8
  %fd.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  store i8* %function_name, i8** %function_name.addr, align 8
  store i32 %fd, i32* %fd.addr, align 4
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %cmp = icmp sgt i32 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %3 = load i8*, i8** %function_name.addr, align 8
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %2, i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.183, i32 0, i32 0), i8* %3)
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32, i32* %retval
  ret i32 %4
}

declare %struct._ts* @PyEval_SaveThread() #1

; Function Attrs: nounwind
declare i32 @fstat64(i32, %struct.stat*) #2

; Function Attrs: nounwind
declare i32 @lstat64(i8*, %struct.stat*) #2

; Function Attrs: nounwind
declare i32 @fstatat64(i32, i8*, %struct.stat*, i32) #2

; Function Attrs: nounwind
declare i32 @stat64(i8*, %struct.stat*) #2

declare void @PyEval_RestoreThread(%struct._ts*) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @path_error(%struct.path_t* %path) #0 {
entry:
  %path.addr = alloca %struct.path_t*, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  %0 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %1 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %1, i32 0, i32 8
  %2 = load %struct._object*, %struct._object** %object, align 8
  %call = call %struct._object* @PyErr_SetFromErrnoWithFilenameObject(%struct._object* %0, %struct._object* %2)
  ret %struct._object* %call
}

; Function Attrs: nounwind uwtable
define internal %struct._object* @_pystat_fromstructstat(%struct.stat* %st) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %st.addr = alloca %struct.stat*, align 8
  %ansec = alloca i64, align 8
  %mnsec = alloca i64, align 8
  %cnsec = alloca i64, align 8
  %v = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct.stat* %st, %struct.stat** %st.addr, align 8
  %call = call %struct._object* @PyStructSequence_New(%struct._typeobject* @StatResultType)
  store %struct._object* %call, %struct._object** %v, align 8
  %0 = load %struct._object*, %struct._object** %v, align 8
  %cmp = icmp eq %struct._object* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %1, i32 0, i32 3
  %2 = load i32, i32* %st_mode, align 4
  %conv = zext i32 %2 to i64
  %call1 = call %struct._object* @PyLong_FromLong(i64 %conv)
  %3 = load %struct._object*, %struct._object** %v, align 8
  %4 = bitcast %struct._object* %3 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %4, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %call1, %struct._object** %arrayidx, align 8
  %5 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_ino = getelementptr inbounds %struct.stat, %struct.stat* %5, i32 0, i32 1
  %6 = load i64, i64* %st_ino, align 8
  %call2 = call %struct._object* @PyLong_FromLong(i64 %6)
  %7 = load %struct._object*, %struct._object** %v, align 8
  %8 = bitcast %struct._object* %7 to %struct.PyTupleObject*
  %ob_item3 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %8, i32 0, i32 1
  %arrayidx4 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item3, i32 0, i64 1
  store %struct._object* %call2, %struct._object** %arrayidx4, align 8
  %9 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_dev = getelementptr inbounds %struct.stat, %struct.stat* %9, i32 0, i32 0
  %10 = load i64, i64* %st_dev, align 8
  %call5 = call %struct._object* @PyLong_FromLongLong(i64 %10)
  %11 = load %struct._object*, %struct._object** %v, align 8
  %12 = bitcast %struct._object* %11 to %struct.PyTupleObject*
  %ob_item6 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %12, i32 0, i32 1
  %arrayidx7 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item6, i32 0, i64 2
  store %struct._object* %call5, %struct._object** %arrayidx7, align 8
  %13 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_nlink = getelementptr inbounds %struct.stat, %struct.stat* %13, i32 0, i32 2
  %14 = load i64, i64* %st_nlink, align 8
  %call8 = call %struct._object* @PyLong_FromLong(i64 %14)
  %15 = load %struct._object*, %struct._object** %v, align 8
  %16 = bitcast %struct._object* %15 to %struct.PyTupleObject*
  %ob_item9 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %16, i32 0, i32 1
  %arrayidx10 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item9, i32 0, i64 3
  store %struct._object* %call8, %struct._object** %arrayidx10, align 8
  %17 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_uid = getelementptr inbounds %struct.stat, %struct.stat* %17, i32 0, i32 4
  %18 = load i32, i32* %st_uid, align 4
  %call11 = call %struct._object* @_PyLong_FromUid(i32 %18)
  %19 = load %struct._object*, %struct._object** %v, align 8
  %20 = bitcast %struct._object* %19 to %struct.PyTupleObject*
  %ob_item12 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %20, i32 0, i32 1
  %arrayidx13 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item12, i32 0, i64 4
  store %struct._object* %call11, %struct._object** %arrayidx13, align 8
  %21 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_gid = getelementptr inbounds %struct.stat, %struct.stat* %21, i32 0, i32 5
  %22 = load i32, i32* %st_gid, align 4
  %call14 = call %struct._object* @_PyLong_FromGid(i32 %22)
  %23 = load %struct._object*, %struct._object** %v, align 8
  %24 = bitcast %struct._object* %23 to %struct.PyTupleObject*
  %ob_item15 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx16 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item15, i32 0, i64 5
  store %struct._object* %call14, %struct._object** %arrayidx16, align 8
  %25 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_size = getelementptr inbounds %struct.stat, %struct.stat* %25, i32 0, i32 8
  %26 = load i64, i64* %st_size, align 8
  %call17 = call %struct._object* @PyLong_FromLong(i64 %26)
  %27 = load %struct._object*, %struct._object** %v, align 8
  %28 = bitcast %struct._object* %27 to %struct.PyTupleObject*
  %ob_item18 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %28, i32 0, i32 1
  %arrayidx19 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item18, i32 0, i64 6
  store %struct._object* %call17, %struct._object** %arrayidx19, align 8
  %29 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_atim = getelementptr inbounds %struct.stat, %struct.stat* %29, i32 0, i32 11
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %st_atim, i32 0, i32 1
  %30 = load i64, i64* %tv_nsec, align 8
  store i64 %30, i64* %ansec, align 8
  %31 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_mtim = getelementptr inbounds %struct.stat, %struct.stat* %31, i32 0, i32 12
  %tv_nsec20 = getelementptr inbounds %struct.timespec, %struct.timespec* %st_mtim, i32 0, i32 1
  %32 = load i64, i64* %tv_nsec20, align 8
  store i64 %32, i64* %mnsec, align 8
  %33 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_ctim = getelementptr inbounds %struct.stat, %struct.stat* %33, i32 0, i32 13
  %tv_nsec21 = getelementptr inbounds %struct.timespec, %struct.timespec* %st_ctim, i32 0, i32 1
  %34 = load i64, i64* %tv_nsec21, align 8
  store i64 %34, i64* %cnsec, align 8
  %35 = load %struct._object*, %struct._object** %v, align 8
  %36 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_atim22 = getelementptr inbounds %struct.stat, %struct.stat* %36, i32 0, i32 11
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %st_atim22, i32 0, i32 0
  %37 = load i64, i64* %tv_sec, align 8
  %38 = load i64, i64* %ansec, align 8
  call void @fill_time(%struct._object* %35, i32 7, i64 %37, i64 %38)
  %39 = load %struct._object*, %struct._object** %v, align 8
  %40 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_mtim23 = getelementptr inbounds %struct.stat, %struct.stat* %40, i32 0, i32 12
  %tv_sec24 = getelementptr inbounds %struct.timespec, %struct.timespec* %st_mtim23, i32 0, i32 0
  %41 = load i64, i64* %tv_sec24, align 8
  %42 = load i64, i64* %mnsec, align 8
  call void @fill_time(%struct._object* %39, i32 8, i64 %41, i64 %42)
  %43 = load %struct._object*, %struct._object** %v, align 8
  %44 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_ctim25 = getelementptr inbounds %struct.stat, %struct.stat* %44, i32 0, i32 13
  %tv_sec26 = getelementptr inbounds %struct.timespec, %struct.timespec* %st_ctim25, i32 0, i32 0
  %45 = load i64, i64* %tv_sec26, align 8
  %46 = load i64, i64* %cnsec, align 8
  call void @fill_time(%struct._object* %43, i32 9, i64 %45, i64 %46)
  %47 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_blksize = getelementptr inbounds %struct.stat, %struct.stat* %47, i32 0, i32 9
  %48 = load i64, i64* %st_blksize, align 8
  %call27 = call %struct._object* @PyLong_FromLong(i64 %48)
  %49 = load %struct._object*, %struct._object** %v, align 8
  %50 = bitcast %struct._object* %49 to %struct.PyTupleObject*
  %ob_item28 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %50, i32 0, i32 1
  %arrayidx29 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item28, i32 0, i64 16
  store %struct._object* %call27, %struct._object** %arrayidx29, align 8
  %51 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_blocks = getelementptr inbounds %struct.stat, %struct.stat* %51, i32 0, i32 10
  %52 = load i64, i64* %st_blocks, align 8
  %call30 = call %struct._object* @PyLong_FromLong(i64 %52)
  %53 = load %struct._object*, %struct._object** %v, align 8
  %54 = bitcast %struct._object* %53 to %struct.PyTupleObject*
  %ob_item31 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %54, i32 0, i32 1
  %arrayidx32 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item31, i32 0, i64 17
  store %struct._object* %call30, %struct._object** %arrayidx32, align 8
  %55 = load %struct.stat*, %struct.stat** %st.addr, align 8
  %st_rdev = getelementptr inbounds %struct.stat, %struct.stat* %55, i32 0, i32 7
  %56 = load i64, i64* %st_rdev, align 8
  %call33 = call %struct._object* @PyLong_FromLong(i64 %56)
  %57 = load %struct._object*, %struct._object** %v, align 8
  %58 = bitcast %struct._object* %57 to %struct.PyTupleObject*
  %ob_item34 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %58, i32 0, i32 1
  %arrayidx35 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item34, i32 0, i64 18
  store %struct._object* %call33, %struct._object** %arrayidx35, align 8
  %call36 = call %struct._object* @PyErr_Occurred()
  %tobool = icmp ne %struct._object* %call36, null
  br i1 %tobool, label %if.then.37, label %if.end.42

if.then.37:                                       ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then.37
  %59 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %59, %struct._object** %_py_decref_tmp, align 8
  %60 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %60, i32 0, i32 0
  %61 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %61, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp38 = icmp ne i64 %dec, 0
  br i1 %cmp38, label %if.then.40, label %if.else

if.then.40:                                       ; preds = %do.body
  br label %if.end.41

if.else:                                          ; preds = %do.body
  %62 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %62, i32 0, i32 1
  %63 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %63, i32 0, i32 4
  %64 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %65 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %64(%struct._object* %65)
  br label %if.end.41

if.end.41:                                        ; preds = %if.else, %if.then.40
  br label %do.end

do.end:                                           ; preds = %if.end.41
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.42:                                        ; preds = %if.end
  %66 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %66, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.42, %do.end, %if.then
  %67 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %67
}

declare %struct._object* @PyErr_SetFromErrnoWithFilenameObject(%struct._object*, %struct._object*) #1

declare %struct._object* @PyStructSequence_New(%struct._typeobject*) #1

declare %struct._object* @PyLong_FromLongLong(i64) #1

; Function Attrs: nounwind uwtable
define internal void @fill_time(%struct._object* %v, i32 %index, i64 %sec, i64 %nsec) #0 {
entry:
  %v.addr = alloca %struct._object*, align 8
  %index.addr = alloca i32, align 4
  %sec.addr = alloca i64, align 8
  %nsec.addr = alloca i64, align 8
  %s = alloca %struct._object*, align 8
  %ns_fractional = alloca %struct._object*, align 8
  %s_in_ns = alloca %struct._object*, align 8
  %ns_total = alloca %struct._object*, align 8
  %float_s = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_xdecref_tmp39 = alloca %struct._object*, align 8
  %_py_decref_tmp44 = alloca %struct._object*, align 8
  %_py_xdecref_tmp58 = alloca %struct._object*, align 8
  %_py_decref_tmp63 = alloca %struct._object*, align 8
  %_py_xdecref_tmp77 = alloca %struct._object*, align 8
  %_py_decref_tmp82 = alloca %struct._object*, align 8
  %_py_xdecref_tmp96 = alloca %struct._object*, align 8
  %_py_decref_tmp101 = alloca %struct._object*, align 8
  store %struct._object* %v, %struct._object** %v.addr, align 8
  store i32 %index, i32* %index.addr, align 4
  store i64 %sec, i64* %sec.addr, align 8
  store i64 %nsec, i64* %nsec.addr, align 8
  %0 = load i64, i64* %sec.addr, align 8
  %call = call %struct._object* @_PyLong_FromTime_t(i64 %0)
  store %struct._object* %call, %struct._object** %s, align 8
  %1 = load i64, i64* %nsec.addr, align 8
  %call1 = call %struct._object* @PyLong_FromUnsignedLong(i64 %1)
  store %struct._object* %call1, %struct._object** %ns_fractional, align 8
  store %struct._object* null, %struct._object** %s_in_ns, align 8
  store %struct._object* null, %struct._object** %ns_total, align 8
  store %struct._object* null, %struct._object** %float_s, align 8
  %2 = load %struct._object*, %struct._object** %s, align 8
  %tobool = icmp ne %struct._object* %2, null
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct._object*, %struct._object** %ns_fractional, align 8
  %tobool2 = icmp ne %struct._object* %3, null
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  br label %exit

if.end:                                           ; preds = %land.lhs.true
  %4 = load %struct._object*, %struct._object** %s, align 8
  %5 = load %struct._object*, %struct._object** @billion, align 8
  %call3 = call %struct._object* @PyNumber_Multiply(%struct._object* %4, %struct._object* %5)
  store %struct._object* %call3, %struct._object** %s_in_ns, align 8
  %6 = load %struct._object*, %struct._object** %s_in_ns, align 8
  %tobool4 = icmp ne %struct._object* %6, null
  br i1 %tobool4, label %if.end.6, label %if.then.5

if.then.5:                                        ; preds = %if.end
  br label %exit

if.end.6:                                         ; preds = %if.end
  %7 = load %struct._object*, %struct._object** %s_in_ns, align 8
  %8 = load %struct._object*, %struct._object** %ns_fractional, align 8
  %call7 = call %struct._object* @PyNumber_Add(%struct._object* %7, %struct._object* %8)
  store %struct._object* %call7, %struct._object** %ns_total, align 8
  %9 = load %struct._object*, %struct._object** %ns_total, align 8
  %tobool8 = icmp ne %struct._object* %9, null
  br i1 %tobool8, label %if.end.10, label %if.then.9

if.then.9:                                        ; preds = %if.end.6
  br label %exit

if.end.10:                                        ; preds = %if.end.6
  %10 = load i32, i32* @_stat_float_times, align 4
  %tobool11 = icmp ne i32 %10, 0
  br i1 %tobool11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %if.end.10
  %11 = load i64, i64* %sec.addr, align 8
  %conv = sitofp i64 %11 to double
  %12 = load i64, i64* %nsec.addr, align 8
  %conv13 = uitofp i64 %12 to double
  %mul = fmul double 1.000000e-09, %conv13
  %add = fadd double %conv, %mul
  %call14 = call %struct._object* @PyFloat_FromDouble(double %add)
  store %struct._object* %call14, %struct._object** %float_s, align 8
  %13 = load %struct._object*, %struct._object** %float_s, align 8
  %tobool15 = icmp ne %struct._object* %13, null
  br i1 %tobool15, label %if.end.17, label %if.then.16

if.then.16:                                       ; preds = %if.then.12
  br label %exit

if.end.17:                                        ; preds = %if.then.12
  br label %if.end.18

if.else:                                          ; preds = %if.end.10
  %14 = load %struct._object*, %struct._object** %s, align 8
  store %struct._object* %14, %struct._object** %float_s, align 8
  %15 = load %struct._object*, %struct._object** %float_s, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %15, i32 0, i32 0
  %16 = load i64, i64* %ob_refcnt, align 8
  %inc = add i64 %16, 1
  store i64 %inc, i64* %ob_refcnt, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.else, %if.end.17
  %17 = load %struct._object*, %struct._object** %s, align 8
  %18 = load i32, i32* %index.addr, align 4
  %idxprom = sext i32 %18 to i64
  %19 = load %struct._object*, %struct._object** %v.addr, align 8
  %20 = bitcast %struct._object* %19 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %20, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 %idxprom
  store %struct._object* %17, %struct._object** %arrayidx, align 8
  %21 = load %struct._object*, %struct._object** %float_s, align 8
  %22 = load i32, i32* %index.addr, align 4
  %add19 = add i32 %22, 3
  %idxprom20 = sext i32 %add19 to i64
  %23 = load %struct._object*, %struct._object** %v.addr, align 8
  %24 = bitcast %struct._object* %23 to %struct.PyTupleObject*
  %ob_item21 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx22 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item21, i32 0, i64 %idxprom20
  store %struct._object* %21, %struct._object** %arrayidx22, align 8
  %25 = load %struct._object*, %struct._object** %ns_total, align 8
  %26 = load i32, i32* %index.addr, align 4
  %add23 = add i32 %26, 6
  %idxprom24 = sext i32 %add23 to i64
  %27 = load %struct._object*, %struct._object** %v.addr, align 8
  %28 = bitcast %struct._object* %27 to %struct.PyTupleObject*
  %ob_item25 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %28, i32 0, i32 1
  %arrayidx26 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item25, i32 0, i64 %idxprom24
  store %struct._object* %25, %struct._object** %arrayidx26, align 8
  store %struct._object* null, %struct._object** %s, align 8
  store %struct._object* null, %struct._object** %float_s, align 8
  store %struct._object* null, %struct._object** %ns_total, align 8
  br label %exit

exit:                                             ; preds = %if.end.18, %if.then.16, %if.then.9, %if.then.5, %if.then
  br label %do.body

do.body:                                          ; preds = %exit
  %29 = load %struct._object*, %struct._object** %s, align 8
  store %struct._object* %29, %struct._object** %_py_xdecref_tmp, align 8
  %30 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp = icmp ne %struct._object* %30, null
  br i1 %cmp, label %if.then.28, label %if.end.36

if.then.28:                                       ; preds = %do.body
  br label %do.body.29

do.body.29:                                       ; preds = %if.then.28
  %31 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %31, %struct._object** %_py_decref_tmp, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt30 = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 0
  %33 = load i64, i64* %ob_refcnt30, align 8
  %dec = add i64 %33, -1
  store i64 %dec, i64* %ob_refcnt30, align 8
  %cmp31 = icmp ne i64 %dec, 0
  br i1 %cmp31, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %do.body.29
  br label %if.end.35

if.else.34:                                       ; preds = %do.body.29
  %34 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %34, i32 0, i32 1
  %35 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %35, i32 0, i32 4
  %36 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %36(%struct._object* %37)
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.34, %if.then.33
  br label %do.end

do.end:                                           ; preds = %if.end.35
  br label %if.end.36

if.end.36:                                        ; preds = %do.end, %do.body
  br label %do.end.37

do.end.37:                                        ; preds = %if.end.36
  br label %do.body.38

do.body.38:                                       ; preds = %do.end.37
  %38 = load %struct._object*, %struct._object** %ns_fractional, align 8
  store %struct._object* %38, %struct._object** %_py_xdecref_tmp39, align 8
  %39 = load %struct._object*, %struct._object** %_py_xdecref_tmp39, align 8
  %cmp40 = icmp ne %struct._object* %39, null
  br i1 %cmp40, label %if.then.42, label %if.end.55

if.then.42:                                       ; preds = %do.body.38
  br label %do.body.43

do.body.43:                                       ; preds = %if.then.42
  %40 = load %struct._object*, %struct._object** %_py_xdecref_tmp39, align 8
  store %struct._object* %40, %struct._object** %_py_decref_tmp44, align 8
  %41 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  %ob_refcnt45 = getelementptr inbounds %struct._object, %struct._object* %41, i32 0, i32 0
  %42 = load i64, i64* %ob_refcnt45, align 8
  %dec46 = add i64 %42, -1
  store i64 %dec46, i64* %ob_refcnt45, align 8
  %cmp47 = icmp ne i64 %dec46, 0
  br i1 %cmp47, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %do.body.43
  br label %if.end.53

if.else.50:                                       ; preds = %do.body.43
  %43 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  %ob_type51 = getelementptr inbounds %struct._object, %struct._object* %43, i32 0, i32 1
  %44 = load %struct._typeobject*, %struct._typeobject** %ob_type51, align 8
  %tp_dealloc52 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %44, i32 0, i32 4
  %45 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc52, align 8
  %46 = load %struct._object*, %struct._object** %_py_decref_tmp44, align 8
  call void %45(%struct._object* %46)
  br label %if.end.53

if.end.53:                                        ; preds = %if.else.50, %if.then.49
  br label %do.end.54

do.end.54:                                        ; preds = %if.end.53
  br label %if.end.55

if.end.55:                                        ; preds = %do.end.54, %do.body.38
  br label %do.end.56

do.end.56:                                        ; preds = %if.end.55
  br label %do.body.57

do.body.57:                                       ; preds = %do.end.56
  %47 = load %struct._object*, %struct._object** %s_in_ns, align 8
  store %struct._object* %47, %struct._object** %_py_xdecref_tmp58, align 8
  %48 = load %struct._object*, %struct._object** %_py_xdecref_tmp58, align 8
  %cmp59 = icmp ne %struct._object* %48, null
  br i1 %cmp59, label %if.then.61, label %if.end.74

if.then.61:                                       ; preds = %do.body.57
  br label %do.body.62

do.body.62:                                       ; preds = %if.then.61
  %49 = load %struct._object*, %struct._object** %_py_xdecref_tmp58, align 8
  store %struct._object* %49, %struct._object** %_py_decref_tmp63, align 8
  %50 = load %struct._object*, %struct._object** %_py_decref_tmp63, align 8
  %ob_refcnt64 = getelementptr inbounds %struct._object, %struct._object* %50, i32 0, i32 0
  %51 = load i64, i64* %ob_refcnt64, align 8
  %dec65 = add i64 %51, -1
  store i64 %dec65, i64* %ob_refcnt64, align 8
  %cmp66 = icmp ne i64 %dec65, 0
  br i1 %cmp66, label %if.then.68, label %if.else.69

if.then.68:                                       ; preds = %do.body.62
  br label %if.end.72

if.else.69:                                       ; preds = %do.body.62
  %52 = load %struct._object*, %struct._object** %_py_decref_tmp63, align 8
  %ob_type70 = getelementptr inbounds %struct._object, %struct._object* %52, i32 0, i32 1
  %53 = load %struct._typeobject*, %struct._typeobject** %ob_type70, align 8
  %tp_dealloc71 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %53, i32 0, i32 4
  %54 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc71, align 8
  %55 = load %struct._object*, %struct._object** %_py_decref_tmp63, align 8
  call void %54(%struct._object* %55)
  br label %if.end.72

if.end.72:                                        ; preds = %if.else.69, %if.then.68
  br label %do.end.73

do.end.73:                                        ; preds = %if.end.72
  br label %if.end.74

if.end.74:                                        ; preds = %do.end.73, %do.body.57
  br label %do.end.75

do.end.75:                                        ; preds = %if.end.74
  br label %do.body.76

do.body.76:                                       ; preds = %do.end.75
  %56 = load %struct._object*, %struct._object** %ns_total, align 8
  store %struct._object* %56, %struct._object** %_py_xdecref_tmp77, align 8
  %57 = load %struct._object*, %struct._object** %_py_xdecref_tmp77, align 8
  %cmp78 = icmp ne %struct._object* %57, null
  br i1 %cmp78, label %if.then.80, label %if.end.93

if.then.80:                                       ; preds = %do.body.76
  br label %do.body.81

do.body.81:                                       ; preds = %if.then.80
  %58 = load %struct._object*, %struct._object** %_py_xdecref_tmp77, align 8
  store %struct._object* %58, %struct._object** %_py_decref_tmp82, align 8
  %59 = load %struct._object*, %struct._object** %_py_decref_tmp82, align 8
  %ob_refcnt83 = getelementptr inbounds %struct._object, %struct._object* %59, i32 0, i32 0
  %60 = load i64, i64* %ob_refcnt83, align 8
  %dec84 = add i64 %60, -1
  store i64 %dec84, i64* %ob_refcnt83, align 8
  %cmp85 = icmp ne i64 %dec84, 0
  br i1 %cmp85, label %if.then.87, label %if.else.88

if.then.87:                                       ; preds = %do.body.81
  br label %if.end.91

if.else.88:                                       ; preds = %do.body.81
  %61 = load %struct._object*, %struct._object** %_py_decref_tmp82, align 8
  %ob_type89 = getelementptr inbounds %struct._object, %struct._object* %61, i32 0, i32 1
  %62 = load %struct._typeobject*, %struct._typeobject** %ob_type89, align 8
  %tp_dealloc90 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %62, i32 0, i32 4
  %63 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc90, align 8
  %64 = load %struct._object*, %struct._object** %_py_decref_tmp82, align 8
  call void %63(%struct._object* %64)
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.88, %if.then.87
  br label %do.end.92

do.end.92:                                        ; preds = %if.end.91
  br label %if.end.93

if.end.93:                                        ; preds = %do.end.92, %do.body.76
  br label %do.end.94

do.end.94:                                        ; preds = %if.end.93
  br label %do.body.95

do.body.95:                                       ; preds = %do.end.94
  %65 = load %struct._object*, %struct._object** %float_s, align 8
  store %struct._object* %65, %struct._object** %_py_xdecref_tmp96, align 8
  %66 = load %struct._object*, %struct._object** %_py_xdecref_tmp96, align 8
  %cmp97 = icmp ne %struct._object* %66, null
  br i1 %cmp97, label %if.then.99, label %if.end.112

if.then.99:                                       ; preds = %do.body.95
  br label %do.body.100

do.body.100:                                      ; preds = %if.then.99
  %67 = load %struct._object*, %struct._object** %_py_xdecref_tmp96, align 8
  store %struct._object* %67, %struct._object** %_py_decref_tmp101, align 8
  %68 = load %struct._object*, %struct._object** %_py_decref_tmp101, align 8
  %ob_refcnt102 = getelementptr inbounds %struct._object, %struct._object* %68, i32 0, i32 0
  %69 = load i64, i64* %ob_refcnt102, align 8
  %dec103 = add i64 %69, -1
  store i64 %dec103, i64* %ob_refcnt102, align 8
  %cmp104 = icmp ne i64 %dec103, 0
  br i1 %cmp104, label %if.then.106, label %if.else.107

if.then.106:                                      ; preds = %do.body.100
  br label %if.end.110

if.else.107:                                      ; preds = %do.body.100
  %70 = load %struct._object*, %struct._object** %_py_decref_tmp101, align 8
  %ob_type108 = getelementptr inbounds %struct._object, %struct._object* %70, i32 0, i32 1
  %71 = load %struct._typeobject*, %struct._typeobject** %ob_type108, align 8
  %tp_dealloc109 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %71, i32 0, i32 4
  %72 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc109, align 8
  %73 = load %struct._object*, %struct._object** %_py_decref_tmp101, align 8
  call void %72(%struct._object* %73)
  br label %if.end.110

if.end.110:                                       ; preds = %if.else.107, %if.then.106
  br label %do.end.111

do.end.111:                                       ; preds = %if.end.110
  br label %if.end.112

if.end.112:                                       ; preds = %do.end.111, %do.body.95
  br label %do.end.113

do.end.113:                                       ; preds = %if.end.112
  ret void
}

declare %struct._object* @_PyLong_FromTime_t(i64) #1

declare %struct._object* @PyNumber_Multiply(%struct._object*, %struct._object*) #1

declare %struct._object* @PyNumber_Add(%struct._object*, %struct._object*) #1

declare %struct._object* @PyFloat_FromDouble(double) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @os_access_impl(%struct.PyModuleDef* %module, %struct.path_t* %path, i32 %mode, i32 %dir_fd, i32 %effective_ids, i32 %follow_symlinks) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %path.addr = alloca %struct.path_t*, align 8
  %mode.addr = alloca i32, align 4
  %dir_fd.addr = alloca i32, align 4
  %effective_ids.addr = alloca i32, align 4
  %follow_symlinks.addr = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %flags = alloca i32, align 4
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store i32 %mode, i32* %mode.addr, align 4
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i32 %effective_ids, i32* %effective_ids.addr, align 4
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  %0 = load i32, i32* %dir_fd.addr, align 4
  %cmp = icmp ne i32 %0, -100
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %effective_ids.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false.1

lor.lhs.false.1:                                  ; preds = %lor.lhs.false
  %2 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool2 = icmp ne i32 %2, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false.1, %lor.lhs.false, %entry
  store i32 0, i32* %flags, align 4
  %3 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.end, label %if.then.4

if.then.4:                                        ; preds = %if.then
  %4 = load i32, i32* %flags, align 4
  %or = or i32 %4, 256
  store i32 %or, i32* %flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.4, %if.then
  %5 = load i32, i32* %effective_ids.addr, align 4
  %tobool5 = icmp ne i32 %5, 0
  br i1 %tobool5, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %6 = load i32, i32* %flags, align 4
  %or7 = or i32 %6, 512
  store i32 %or7, i32* %flags, align 4
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %7 = load i32, i32* %dir_fd.addr, align 4
  %8 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %8, i32 0, i32 5
  %9 = load i8*, i8** %narrow, align 8
  %10 = load i32, i32* %mode.addr, align 4
  %11 = load i32, i32* %flags, align 4
  %call9 = call i32 @faccessat(i32 %7, i8* %9, i32 %10, i32 %11) #4
  store i32 %call9, i32* %result, align 4
  br label %if.end.12

if.else:                                          ; preds = %lor.lhs.false.1
  %12 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow10 = getelementptr inbounds %struct.path_t, %struct.path_t* %12, i32 0, i32 5
  %13 = load i8*, i8** %narrow10, align 8
  %14 = load i32, i32* %mode.addr, align 4
  %call11 = call i32 @access(i8* %13, i32 %14) #4
  store i32 %call11, i32* %result, align 4
  br label %if.end.12

if.end.12:                                        ; preds = %if.else, %if.end.8
  %15 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %15)
  %16 = load i32, i32* %result, align 4
  %tobool13 = icmp ne i32 %16, 0
  %lnot = xor i1 %tobool13, true
  %lnot.ext = zext i1 %lnot to i32
  %conv = sext i32 %lnot.ext to i64
  %call14 = call %struct._object* @PyBool_FromLong(i64 %conv)
  store %struct._object* %call14, %struct._object** %return_value, align 8
  %17 = load %struct._object*, %struct._object** %return_value, align 8
  ret %struct._object* %17
}

; Function Attrs: nounwind
declare i32 @faccessat(i32, i8*, i32, i32) #2

; Function Attrs: nounwind
declare i32 @access(i8*, i32) #2

declare %struct._object* @PyBool_FromLong(i64) #1

declare i32 @_PyArg_ParseTuple_SizeT(%struct._object*, i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal i8* @os_ttyname_impl(%struct.PyModuleDef* %module, i32 %fd) #0 {
entry:
  %module.addr = alloca %struct.PyModuleDef*, align 8
  %fd.addr = alloca i32, align 4
  %ret = alloca i8*, align 8
  store %struct.PyModuleDef* %module, %struct.PyModuleDef** %module.addr, align 8
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load i32, i32* %fd.addr, align 4
  %call = call i8* @ttyname(i32 %0) #4
  store i8* %call, i8** %ret, align 8
  %1 = load i8*, i8** %ret, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call %struct._object* @posix_error()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i8*, i8** %ret, align 8
  ret i8* %2
}

declare %struct._object* @PyUnicode_DecodeFSDefault(i8*) #1

; Function Attrs: nounwind
declare i8* @ttyname(i32) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_error() #0 {
entry:
  %0 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %call = call %struct._object* @PyErr_SetFromErrno(%struct._object* %0)
  ret %struct._object* %call
}

declare %struct._object* @PyErr_SetFromErrno(%struct._object*) #1

; Function Attrs: nounwind
declare i32 @fchdir(i32) #2

; Function Attrs: nounwind
declare i32 @chdir(i8*) #2

; Function Attrs: nounwind
declare i32 @fchmod(i32, i32) #2

; Function Attrs: nounwind
declare i32 @fchmodat(i32, i8*, i32, i32) #2

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #5

; Function Attrs: nounwind
declare i32 @chmod(i8*, i32) #2

; Function Attrs: nounwind
declare i32 @fchown(i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @lchown(i8*, i32, i32) #2

; Function Attrs: nounwind
declare i32 @fchownat(i32, i8*, i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @chown(i8*, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_1str(i8* %func_name, %struct._object* %args, i8* %format, i32 (i8*)* %func) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %func_name.addr = alloca i8*, align 8
  %args.addr = alloca %struct._object*, align 8
  %format.addr = alloca i8*, align 8
  %func.addr = alloca i32 (i8*)*, align 8
  %path = alloca %struct.path_t, align 8
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store i8* %func_name, i8** %func_name.addr, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store i8* %format, i8** %format.addr, align 8
  store i32 (i8*)* %func, i32 (i8*)** %func.addr, align 8
  %0 = bitcast %struct.path_t* %path to i8*
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 72, i32 8, i1 false)
  %1 = load i8*, i8** %func_name.addr, align 8
  %function_name = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 0
  store i8* %1, i8** %function_name, align 8
  %2 = load %struct._object*, %struct._object** %args.addr, align 8
  %3 = load i8*, i8** %format.addr, align 8
  %call = call i32 (%struct._object*, i8*, ...) @_PyArg_ParseTuple_SizeT(%struct._object* %2, i8* %3, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %path)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %4 = load i32 (i8*)*, i32 (i8*)** %func.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %path, i32 0, i32 5
  %5 = load i8*, i8** %narrow, align 8
  %call2 = call i32 %4(i8* %5)
  store i32 %call2, i32* %res, align 4
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  %7 = load i32, i32* %res, align 4
  %cmp = icmp slt i32 %7, 0
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @path_error(%struct.path_t* %path)
  call void @path_cleanup(%struct.path_t* %path)
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  call void @path_cleanup(%struct.path_t* %path)
  %8 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %8, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.5, %if.then.3, %if.then
  %9 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %9
}

; Function Attrs: nounwind
declare i32 @chroot(i8*) #2

; Function Attrs: nounwind
declare i8* @ctermid(i8*) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_getcwd(i32 %use_bytes) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %use_bytes.addr = alloca i32, align 4
  %buf = alloca [1026 x i8], align 16
  %res = alloca i8*, align 8
  %_save = alloca %struct._ts*, align 8
  store i32 %use_bytes, i32* %use_bytes.addr, align 4
  %call = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call, %struct._ts** %_save, align 8
  %arraydecay = getelementptr inbounds [1026 x i8], [1026 x i8]* %buf, i32 0, i32 0
  %call1 = call i8* @getcwd(i8* %arraydecay, i64 1026) #4
  store i8* %call1, i8** %res, align 8
  %0 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %0)
  %1 = load i8*, i8** %res, align 8
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call %struct._object* @posix_error()
  store %struct._object* %call2, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %use_bytes.addr, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then.3, label %if.end.8

if.then.3:                                        ; preds = %if.end
  %arraydecay4 = getelementptr inbounds [1026 x i8], [1026 x i8]* %buf, i32 0, i32 0
  %arraydecay5 = getelementptr inbounds [1026 x i8], [1026 x i8]* %buf, i32 0, i32 0
  %call6 = call i64 @strlen(i8* %arraydecay5) #8
  %call7 = call %struct._object* @PyBytes_FromStringAndSize(i8* %arraydecay4, i64 %call6)
  store %struct._object* %call7, %struct._object** %retval
  br label %return

if.end.8:                                         ; preds = %if.end
  %arraydecay9 = getelementptr inbounds [1026 x i8], [1026 x i8]* %buf, i32 0, i32 0
  %call10 = call %struct._object* @PyUnicode_DecodeFSDefault(i8* %arraydecay9)
  store %struct._object* %call10, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.3, %if.then
  %3 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %3
}

; Function Attrs: nounwind
declare i8* @getcwd(i8*, i64) #2

declare %struct._object* @PyBytes_FromStringAndSize(i8*, i64) #1

; Function Attrs: nounwind
declare i32 @linkat(i32, i8*, i32, i8*, i32) #2

; Function Attrs: nounwind
declare i32 @link(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @path_error2(%struct.path_t* %path, %struct.path_t* %path2) #0 {
entry:
  %path.addr = alloca %struct.path_t*, align 8
  %path2.addr = alloca %struct.path_t*, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store %struct.path_t* %path2, %struct.path_t** %path2.addr, align 8
  %0 = load %struct._object*, %struct._object** @PyExc_OSError, align 8
  %1 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %1, i32 0, i32 8
  %2 = load %struct._object*, %struct._object** %object, align 8
  %3 = load %struct.path_t*, %struct.path_t** %path2.addr, align 8
  %object1 = getelementptr inbounds %struct.path_t, %struct.path_t* %3, i32 0, i32 8
  %4 = load %struct._object*, %struct._object** %object1, align 8
  %call = call %struct._object* @PyErr_SetFromErrnoWithFilenameObjects(%struct._object* %0, %struct._object* %2, %struct._object* %4)
  ret %struct._object* %call
}

declare %struct._object* @PyErr_SetFromErrnoWithFilenameObjects(%struct._object*, %struct._object*, %struct._object*) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @_posix_listdir(%struct.path_t* %path, %struct._object* %list) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %path.addr = alloca %struct.path_t*, align 8
  %list.addr = alloca %struct._object*, align 8
  %v = alloca %struct._object*, align 8
  %dirp = alloca %struct.__dirstream*, align 8
  %ep = alloca %struct.dirent*, align 8
  %return_str = alloca i32, align 4
  %fd = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  %name = alloca i8*, align 8
  %_save13 = alloca %struct._ts*, align 8
  %_save22 = alloca %struct._ts*, align 8
  %_save32 = alloca %struct._ts*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp91 = alloca %struct._object*, align 8
  %_py_decref_tmp110 = alloca %struct._object*, align 8
  %_py_tmp122 = alloca %struct._object*, align 8
  %_py_decref_tmp127 = alloca %struct._object*, align 8
  %_py_decref_tmp142 = alloca %struct._object*, align 8
  %_save156 = alloca %struct._ts*, align 8
  store %struct.path_t* %path, %struct.path_t** %path.addr, align 8
  store %struct._object* %list, %struct._object** %list.addr, align 8
  store %struct.__dirstream* null, %struct.__dirstream** %dirp, align 8
  store i32 -1, i32* %fd, align 4
  %call = call i32* @__errno_location() #9
  store i32 0, i32* %call, align 4
  %0 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd1 = getelementptr inbounds %struct.path_t, %struct.path_t* %0, i32 0, i32 6
  %1 = load i32, i32* %fd1, align 4
  %cmp = icmp ne i32 %1, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %fd2 = getelementptr inbounds %struct.path_t, %struct.path_t* %2, i32 0, i32 6
  %3 = load i32, i32* %fd2, align 4
  %call3 = call i32 @_Py_dup(i32 %3)
  store i32 %call3, i32* %fd, align 4
  %4 = load i32, i32* %fd, align 4
  %cmp4 = icmp eq i32 %4, -1
  br i1 %cmp4, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %if.then
  store i32 1, i32* %return_str, align 4
  %call6 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call6, %struct._ts** %_save, align 8
  %5 = load i32, i32* %fd, align 4
  %call7 = call %struct.__dirstream* @fdopendir(i32 %5)
  store %struct.__dirstream* %call7, %struct.__dirstream** %dirp, align 8
  %6 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %6)
  br label %if.end.16

if.else:                                          ; preds = %entry
  %7 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %7, i32 0, i32 5
  %8 = load i8*, i8** %narrow, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %if.then.8, label %if.else.11

if.then.8:                                        ; preds = %if.else
  %9 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %narrow9 = getelementptr inbounds %struct.path_t, %struct.path_t* %9, i32 0, i32 5
  %10 = load i8*, i8** %narrow9, align 8
  store i8* %10, i8** %name, align 8
  %11 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %object = getelementptr inbounds %struct.path_t, %struct.path_t* %11, i32 0, i32 8
  %12 = load %struct._object*, %struct._object** %object, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %12, i32 0, i32 1
  %13 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %13, i32 0, i32 19
  %14 = load i64, i64* %tp_flags, align 8
  %and = and i64 %14, 134217728
  %cmp10 = icmp ne i64 %and, 0
  %lnot = xor i1 %cmp10, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %return_str, align 4
  br label %if.end.12

if.else.11:                                       ; preds = %if.else
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.204, i32 0, i32 0), i8** %name, align 8
  store i32 1, i32* %return_str, align 4
  br label %if.end.12

if.end.12:                                        ; preds = %if.else.11, %if.then.8
  %call14 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call14, %struct._ts** %_save13, align 8
  %15 = load i8*, i8** %name, align 8
  %call15 = call %struct.__dirstream* @opendir(i8* %15)
  store %struct.__dirstream* %call15, %struct.__dirstream** %dirp, align 8
  %16 = load %struct._ts*, %struct._ts** %_save13, align 8
  call void @PyEval_RestoreThread(%struct._ts* %16)
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.12, %if.end
  %17 = load %struct.__dirstream*, %struct.__dirstream** %dirp, align 8
  %cmp17 = icmp eq %struct.__dirstream* %17, null
  br i1 %cmp17, label %if.then.18, label %if.end.26

if.then.18:                                       ; preds = %if.end.16
  %18 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %call19 = call %struct._object* @path_error(%struct.path_t* %18)
  store %struct._object* %call19, %struct._object** %list.addr, align 8
  %19 = load i32, i32* %fd, align 4
  %cmp20 = icmp ne i32 %19, -1
  br i1 %cmp20, label %if.then.21, label %if.end.25

if.then.21:                                       ; preds = %if.then.18
  %call23 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call23, %struct._ts** %_save22, align 8
  %20 = load i32, i32* %fd, align 4
  %call24 = call i32 @close(i32 %20)
  %21 = load %struct._ts*, %struct._ts** %_save22, align 8
  call void @PyEval_RestoreThread(%struct._ts* %21)
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.21, %if.then.18
  br label %exit

if.end.26:                                        ; preds = %if.end.16
  %call27 = call %struct._object* @PyList_New(i64 0)
  store %struct._object* %call27, %struct._object** %list.addr, align 8
  %cmp28 = icmp eq %struct._object* %call27, null
  br i1 %cmp28, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %if.end.26
  br label %exit

if.end.30:                                        ; preds = %if.end.26
  br label %for.cond

for.cond:                                         ; preds = %do.end.152, %if.then.65, %if.end.30
  %call31 = call i32* @__errno_location() #9
  store i32 0, i32* %call31, align 4
  %call33 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call33, %struct._ts** %_save32, align 8
  %22 = load %struct.__dirstream*, %struct.__dirstream** %dirp, align 8
  %call34 = call %struct.dirent* @readdir64(%struct.__dirstream* %22)
  store %struct.dirent* %call34, %struct.dirent** %ep, align 8
  %23 = load %struct._ts*, %struct._ts** %_save32, align 8
  call void @PyEval_RestoreThread(%struct._ts* %23)
  %24 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %cmp35 = icmp eq %struct.dirent* %24, null
  br i1 %cmp35, label %if.then.36, label %if.end.47

if.then.36:                                       ; preds = %for.cond
  %call37 = call i32* @__errno_location() #9
  %25 = load i32, i32* %call37, align 4
  %cmp38 = icmp eq i32 %25, 0
  br i1 %cmp38, label %if.then.39, label %if.else.40

if.then.39:                                       ; preds = %if.then.36
  br label %for.end

if.else.40:                                       ; preds = %if.then.36
  br label %do.body

do.body:                                          ; preds = %if.else.40
  %26 = load %struct._object*, %struct._object** %list.addr, align 8
  store %struct._object* %26, %struct._object** %_py_decref_tmp, align 8
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 0
  %28 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %28, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp41 = icmp ne i64 %dec, 0
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %do.body
  br label %if.end.45

if.else.43:                                       ; preds = %do.body
  %29 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type44 = getelementptr inbounds %struct._object, %struct._object* %29, i32 0, i32 1
  %30 = load %struct._typeobject*, %struct._typeobject** %ob_type44, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %30, i32 0, i32 4
  %31 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %31(%struct._object* %32)
  br label %if.end.45

if.end.45:                                        ; preds = %if.else.43, %if.then.42
  br label %do.end

do.end:                                           ; preds = %if.end.45
  %33 = load %struct.path_t*, %struct.path_t** %path.addr, align 8
  %call46 = call %struct._object* @path_error(%struct.path_t* %33)
  store %struct._object* %call46, %struct._object** %list.addr, align 8
  br label %exit

if.end.47:                                        ; preds = %for.cond
  %34 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name = getelementptr inbounds %struct.dirent, %struct.dirent* %34, i32 0, i32 4
  %arrayidx = getelementptr [256 x i8], [256 x i8]* %d_name, i32 0, i64 0
  %35 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %35 to i32
  %cmp48 = icmp eq i32 %conv, 46
  br i1 %cmp48, label %land.lhs.true, label %if.end.66

land.lhs.true:                                    ; preds = %if.end.47
  %36 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name50 = getelementptr inbounds %struct.dirent, %struct.dirent* %36, i32 0, i32 4
  %arraydecay = getelementptr inbounds [256 x i8], [256 x i8]* %d_name50, i32 0, i32 0
  %call51 = call i64 @strlen(i8* %arraydecay) #8
  %cmp52 = icmp eq i64 %call51, 1
  br i1 %cmp52, label %if.then.65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %37 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name54 = getelementptr inbounds %struct.dirent, %struct.dirent* %37, i32 0, i32 4
  %arrayidx55 = getelementptr [256 x i8], [256 x i8]* %d_name54, i32 0, i64 1
  %38 = load i8, i8* %arrayidx55, align 1
  %conv56 = sext i8 %38 to i32
  %cmp57 = icmp eq i32 %conv56, 46
  br i1 %cmp57, label %land.lhs.true.59, label %if.end.66

land.lhs.true.59:                                 ; preds = %lor.lhs.false
  %39 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name60 = getelementptr inbounds %struct.dirent, %struct.dirent* %39, i32 0, i32 4
  %arraydecay61 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name60, i32 0, i32 0
  %call62 = call i64 @strlen(i8* %arraydecay61) #8
  %cmp63 = icmp eq i64 %call62, 2
  br i1 %cmp63, label %if.then.65, label %if.end.66

if.then.65:                                       ; preds = %land.lhs.true.59, %land.lhs.true
  br label %for.cond

if.end.66:                                        ; preds = %land.lhs.true.59, %lor.lhs.false, %if.end.47
  %40 = load i32, i32* %return_str, align 4
  %tobool67 = icmp ne i32 %40, 0
  br i1 %tobool67, label %if.then.68, label %if.else.75

if.then.68:                                       ; preds = %if.end.66
  %41 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name69 = getelementptr inbounds %struct.dirent, %struct.dirent* %41, i32 0, i32 4
  %arraydecay70 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name69, i32 0, i32 0
  %42 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name71 = getelementptr inbounds %struct.dirent, %struct.dirent* %42, i32 0, i32 4
  %arraydecay72 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name71, i32 0, i32 0
  %call73 = call i64 @strlen(i8* %arraydecay72) #8
  %call74 = call %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8* %arraydecay70, i64 %call73)
  store %struct._object* %call74, %struct._object** %v, align 8
  br label %if.end.82

if.else.75:                                       ; preds = %if.end.66
  %43 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name76 = getelementptr inbounds %struct.dirent, %struct.dirent* %43, i32 0, i32 4
  %arraydecay77 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name76, i32 0, i32 0
  %44 = load %struct.dirent*, %struct.dirent** %ep, align 8
  %d_name78 = getelementptr inbounds %struct.dirent, %struct.dirent* %44, i32 0, i32 4
  %arraydecay79 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name78, i32 0, i32 0
  %call80 = call i64 @strlen(i8* %arraydecay79) #8
  %call81 = call %struct._object* @PyBytes_FromStringAndSize(i8* %arraydecay77, i64 %call80)
  store %struct._object* %call81, %struct._object** %v, align 8
  br label %if.end.82

if.end.82:                                        ; preds = %if.else.75, %if.then.68
  %45 = load %struct._object*, %struct._object** %v, align 8
  %cmp83 = icmp eq %struct._object* %45, null
  br i1 %cmp83, label %if.then.85, label %if.end.104

if.then.85:                                       ; preds = %if.end.82
  br label %do.body.86

do.body.86:                                       ; preds = %if.then.85
  %46 = load %struct._object*, %struct._object** %list.addr, align 8
  store %struct._object* %46, %struct._object** %_py_tmp, align 8
  %47 = load %struct._object*, %struct._object** %_py_tmp, align 8
  %cmp87 = icmp ne %struct._object* %47, null
  br i1 %cmp87, label %if.then.89, label %if.end.102

if.then.89:                                       ; preds = %do.body.86
  store %struct._object* null, %struct._object** %list.addr, align 8
  br label %do.body.90

do.body.90:                                       ; preds = %if.then.89
  %48 = load %struct._object*, %struct._object** %_py_tmp, align 8
  store %struct._object* %48, %struct._object** %_py_decref_tmp91, align 8
  %49 = load %struct._object*, %struct._object** %_py_decref_tmp91, align 8
  %ob_refcnt92 = getelementptr inbounds %struct._object, %struct._object* %49, i32 0, i32 0
  %50 = load i64, i64* %ob_refcnt92, align 8
  %dec93 = add i64 %50, -1
  store i64 %dec93, i64* %ob_refcnt92, align 8
  %cmp94 = icmp ne i64 %dec93, 0
  br i1 %cmp94, label %if.then.96, label %if.else.97

if.then.96:                                       ; preds = %do.body.90
  br label %if.end.100

if.else.97:                                       ; preds = %do.body.90
  %51 = load %struct._object*, %struct._object** %_py_decref_tmp91, align 8
  %ob_type98 = getelementptr inbounds %struct._object, %struct._object* %51, i32 0, i32 1
  %52 = load %struct._typeobject*, %struct._typeobject** %ob_type98, align 8
  %tp_dealloc99 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %52, i32 0, i32 4
  %53 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc99, align 8
  %54 = load %struct._object*, %struct._object** %_py_decref_tmp91, align 8
  call void %53(%struct._object* %54)
  br label %if.end.100

if.end.100:                                       ; preds = %if.else.97, %if.then.96
  br label %do.end.101

do.end.101:                                       ; preds = %if.end.100
  br label %if.end.102

if.end.102:                                       ; preds = %do.end.101, %do.body.86
  br label %do.end.103

do.end.103:                                       ; preds = %if.end.102
  br label %for.end

if.end.104:                                       ; preds = %if.end.82
  %55 = load %struct._object*, %struct._object** %list.addr, align 8
  %56 = load %struct._object*, %struct._object** %v, align 8
  %call105 = call i32 @PyList_Append(%struct._object* %55, %struct._object* %56)
  %cmp106 = icmp ne i32 %call105, 0
  br i1 %cmp106, label %if.then.108, label %if.end.140

if.then.108:                                      ; preds = %if.end.104
  br label %do.body.109

do.body.109:                                      ; preds = %if.then.108
  %57 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %57, %struct._object** %_py_decref_tmp110, align 8
  %58 = load %struct._object*, %struct._object** %_py_decref_tmp110, align 8
  %ob_refcnt111 = getelementptr inbounds %struct._object, %struct._object* %58, i32 0, i32 0
  %59 = load i64, i64* %ob_refcnt111, align 8
  %dec112 = add i64 %59, -1
  store i64 %dec112, i64* %ob_refcnt111, align 8
  %cmp113 = icmp ne i64 %dec112, 0
  br i1 %cmp113, label %if.then.115, label %if.else.116

if.then.115:                                      ; preds = %do.body.109
  br label %if.end.119

if.else.116:                                      ; preds = %do.body.109
  %60 = load %struct._object*, %struct._object** %_py_decref_tmp110, align 8
  %ob_type117 = getelementptr inbounds %struct._object, %struct._object* %60, i32 0, i32 1
  %61 = load %struct._typeobject*, %struct._typeobject** %ob_type117, align 8
  %tp_dealloc118 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %61, i32 0, i32 4
  %62 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc118, align 8
  %63 = load %struct._object*, %struct._object** %_py_decref_tmp110, align 8
  call void %62(%struct._object* %63)
  br label %if.end.119

if.end.119:                                       ; preds = %if.else.116, %if.then.115
  br label %do.end.120

do.end.120:                                       ; preds = %if.end.119
  br label %do.body.121

do.body.121:                                      ; preds = %do.end.120
  %64 = load %struct._object*, %struct._object** %list.addr, align 8
  store %struct._object* %64, %struct._object** %_py_tmp122, align 8
  %65 = load %struct._object*, %struct._object** %_py_tmp122, align 8
  %cmp123 = icmp ne %struct._object* %65, null
  br i1 %cmp123, label %if.then.125, label %if.end.138

if.then.125:                                      ; preds = %do.body.121
  store %struct._object* null, %struct._object** %list.addr, align 8
  br label %do.body.126

do.body.126:                                      ; preds = %if.then.125
  %66 = load %struct._object*, %struct._object** %_py_tmp122, align 8
  store %struct._object* %66, %struct._object** %_py_decref_tmp127, align 8
  %67 = load %struct._object*, %struct._object** %_py_decref_tmp127, align 8
  %ob_refcnt128 = getelementptr inbounds %struct._object, %struct._object* %67, i32 0, i32 0
  %68 = load i64, i64* %ob_refcnt128, align 8
  %dec129 = add i64 %68, -1
  store i64 %dec129, i64* %ob_refcnt128, align 8
  %cmp130 = icmp ne i64 %dec129, 0
  br i1 %cmp130, label %if.then.132, label %if.else.133

if.then.132:                                      ; preds = %do.body.126
  br label %if.end.136

if.else.133:                                      ; preds = %do.body.126
  %69 = load %struct._object*, %struct._object** %_py_decref_tmp127, align 8
  %ob_type134 = getelementptr inbounds %struct._object, %struct._object* %69, i32 0, i32 1
  %70 = load %struct._typeobject*, %struct._typeobject** %ob_type134, align 8
  %tp_dealloc135 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %70, i32 0, i32 4
  %71 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc135, align 8
  %72 = load %struct._object*, %struct._object** %_py_decref_tmp127, align 8
  call void %71(%struct._object* %72)
  br label %if.end.136

if.end.136:                                       ; preds = %if.else.133, %if.then.132
  br label %do.end.137

do.end.137:                                       ; preds = %if.end.136
  br label %if.end.138

if.end.138:                                       ; preds = %do.end.137, %do.body.121
  br label %do.end.139

do.end.139:                                       ; preds = %if.end.138
  br label %for.end

if.end.140:                                       ; preds = %if.end.104
  br label %do.body.141

do.body.141:                                      ; preds = %if.end.140
  %73 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %73, %struct._object** %_py_decref_tmp142, align 8
  %74 = load %struct._object*, %struct._object** %_py_decref_tmp142, align 8
  %ob_refcnt143 = getelementptr inbounds %struct._object, %struct._object* %74, i32 0, i32 0
  %75 = load i64, i64* %ob_refcnt143, align 8
  %dec144 = add i64 %75, -1
  store i64 %dec144, i64* %ob_refcnt143, align 8
  %cmp145 = icmp ne i64 %dec144, 0
  br i1 %cmp145, label %if.then.147, label %if.else.148

if.then.147:                                      ; preds = %do.body.141
  br label %if.end.151

if.else.148:                                      ; preds = %do.body.141
  %76 = load %struct._object*, %struct._object** %_py_decref_tmp142, align 8
  %ob_type149 = getelementptr inbounds %struct._object, %struct._object* %76, i32 0, i32 1
  %77 = load %struct._typeobject*, %struct._typeobject** %ob_type149, align 8
  %tp_dealloc150 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %77, i32 0, i32 4
  %78 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc150, align 8
  %79 = load %struct._object*, %struct._object** %_py_decref_tmp142, align 8
  call void %78(%struct._object* %79)
  br label %if.end.151

if.end.151:                                       ; preds = %if.else.148, %if.then.147
  br label %do.end.152

do.end.152:                                       ; preds = %if.end.151
  br label %for.cond

for.end:                                          ; preds = %do.end.139, %do.end.103, %if.then.39
  br label %exit

exit:                                             ; preds = %for.end, %do.end, %if.then.29, %if.end.25
  %80 = load %struct.__dirstream*, %struct.__dirstream** %dirp, align 8
  %cmp153 = icmp ne %struct.__dirstream* %80, null
  br i1 %cmp153, label %if.then.155, label %if.end.163

if.then.155:                                      ; preds = %exit
  %call157 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call157, %struct._ts** %_save156, align 8
  %81 = load i32, i32* %fd, align 4
  %cmp158 = icmp sgt i32 %81, -1
  br i1 %cmp158, label %if.then.160, label %if.end.161

if.then.160:                                      ; preds = %if.then.155
  %82 = load %struct.__dirstream*, %struct.__dirstream** %dirp, align 8
  call void @rewinddir(%struct.__dirstream* %82) #4
  br label %if.end.161

if.end.161:                                       ; preds = %if.then.160, %if.then.155
  %83 = load %struct.__dirstream*, %struct.__dirstream** %dirp, align 8
  %call162 = call i32 @closedir(%struct.__dirstream* %83)
  %84 = load %struct._ts*, %struct._ts** %_save156, align 8
  call void @PyEval_RestoreThread(%struct._ts* %84)
  br label %if.end.163

if.end.163:                                       ; preds = %if.end.161, %exit
  %85 = load %struct._object*, %struct._object** %list.addr, align 8
  store %struct._object* %85, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.163, %if.then.5
  %86 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %86
}

declare i32 @_Py_dup(i32) #1

declare %struct.__dirstream* @fdopendir(i32) #1

declare %struct.__dirstream* @opendir(i8*) #1

declare i32 @close(i32) #1

declare %struct.dirent* @readdir64(%struct.__dirstream*) #1

declare %struct._object* @PyUnicode_DecodeFSDefaultAndSize(i8*, i64) #1

; Function Attrs: nounwind
declare void @rewinddir(%struct.__dirstream*) #2

declare i32 @closedir(%struct.__dirstream*) #1

; Function Attrs: nounwind
declare i32 @mkdirat(i32, i8*, i32) #2

; Function Attrs: nounwind
declare i32 @mkdir(i8*, i32) #2

; Function Attrs: nounwind
declare i32 @nice(i32) #2

; Function Attrs: nounwind
declare i32 @getpriority(i32, i32) #2

; Function Attrs: nounwind
declare i32 @setpriority(i32, i32, i32) #2

; Function Attrs: nounwind
declare i64 @readlinkat(i32, i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @readlink(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @internal_rename(%struct._object* %args, %struct._object* %kwargs, i32 %is_replace) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %args.addr = alloca %struct._object*, align 8
  %kwargs.addr = alloca %struct._object*, align 8
  %is_replace.addr = alloca i32, align 4
  %function_name = alloca i8*, align 8
  %src = alloca %struct.path_t, align 8
  %dst = alloca %struct.path_t, align 8
  %src_dir_fd = alloca i32, align 4
  %dst_dir_fd = alloca i32, align 4
  %dir_fd_specified = alloca i32, align 4
  %return_value = alloca %struct._object*, align 8
  %format = alloca [24 x i8], align 16
  %result = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %args, %struct._object** %args.addr, align 8
  store %struct._object* %kwargs, %struct._object** %kwargs.addr, align 8
  store i32 %is_replace, i32* %is_replace.addr, align 4
  %0 = load i32, i32* %is_replace.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0)
  store i8* %cond, i8** %function_name, align 8
  store i32 -100, i32* %src_dir_fd, align 4
  store i32 -100, i32* %dst_dir_fd, align 4
  store %struct._object* null, %struct._object** %return_value, align 8
  %1 = bitcast %struct.path_t* %src to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 72, i32 8, i1 false)
  %2 = bitcast %struct.path_t* %dst to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 72, i32 8, i1 false)
  %3 = load i8*, i8** %function_name, align 8
  %function_name1 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 0
  store i8* %3, i8** %function_name1, align 8
  %4 = load i8*, i8** %function_name, align 8
  %function_name2 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 0
  store i8* %4, i8** %function_name2, align 8
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %format, i32 0, i32 0
  %call = call i8* @strcpy(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.211, i32 0, i32 0)) #4
  %arraydecay3 = getelementptr inbounds [24 x i8], [24 x i8]* %format, i32 0, i32 0
  %5 = load i8*, i8** %function_name, align 8
  %call4 = call i8* @strcat(i8* %arraydecay3, i8* %5) #4
  %6 = load %struct._object*, %struct._object** %args.addr, align 8
  %7 = load %struct._object*, %struct._object** %kwargs.addr, align 8
  %arraydecay5 = getelementptr inbounds [24 x i8], [24 x i8]* %format, i32 0, i32 0
  %call6 = call i32 (%struct._object*, %struct._object*, i8*, i8**, ...) @_PyArg_ParseTupleAndKeywords_SizeT(%struct._object* %6, %struct._object* %7, i8* %arraydecay5, i8** getelementptr inbounds ([5 x i8*], [5 x i8*]* @internal_rename.keywords, i32 0, i32 0), i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %src, i32 (%struct._object*, i8*)* @path_converter, %struct.path_t* %dst, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %src_dir_fd, i32 (%struct._object*, i8*)* @dir_fd_converter, i32* %dst_dir_fd)
  %tobool7 = icmp ne i32 %call6, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32, i32* %src_dir_fd, align 4
  %cmp = icmp ne i32 %8, -100
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  %9 = load i32, i32* %dst_dir_fd, align 4
  %cmp8 = icmp ne i32 %9, -100
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end
  %10 = phi i1 [ true, %if.end ], [ %cmp8, %lor.rhs ]
  %lor.ext = zext i1 %10 to i32
  store i32 %lor.ext, i32* %dir_fd_specified, align 4
  %narrow = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %11 = load i8*, i8** %narrow, align 8
  %tobool9 = icmp ne i8* %11, null
  br i1 %tobool9, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %lor.end
  %wide = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 4
  %12 = load i32*, i32** %wide, align 8
  %tobool10 = icmp ne i32* %12, null
  br i1 %tobool10, label %if.then.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %lor.end
  %wide11 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 4
  %13 = load i32*, i32** %wide11, align 8
  %tobool12 = icmp ne i32* %13, null
  br i1 %tobool12, label %land.lhs.true.13, label %if.end.18

land.lhs.true.13:                                 ; preds = %lor.lhs.false
  %narrow14 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %14 = load i8*, i8** %narrow14, align 8
  %tobool15 = icmp ne i8* %14, null
  br i1 %tobool15, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %land.lhs.true.13, %land.lhs.true
  %15 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  %16 = load i8*, i8** %function_name, align 8
  %call17 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %15, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.212, i32 0, i32 0), i8* %16)
  br label %exit

if.end.18:                                        ; preds = %land.lhs.true.13, %lor.lhs.false
  %call19 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call19, %struct._ts** %_save, align 8
  %17 = load i32, i32* %dir_fd_specified, align 4
  %tobool20 = icmp ne i32 %17, 0
  br i1 %tobool20, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %if.end.18
  %18 = load i32, i32* %src_dir_fd, align 4
  %narrow22 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %19 = load i8*, i8** %narrow22, align 8
  %20 = load i32, i32* %dst_dir_fd, align 4
  %narrow23 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %21 = load i8*, i8** %narrow23, align 8
  %call24 = call i32 @renameat(i32 %18, i8* %19, i32 %20, i8* %21) #4
  store i32 %call24, i32* %result, align 4
  br label %if.end.28

if.else:                                          ; preds = %if.end.18
  %narrow25 = getelementptr inbounds %struct.path_t, %struct.path_t* %src, i32 0, i32 5
  %22 = load i8*, i8** %narrow25, align 8
  %narrow26 = getelementptr inbounds %struct.path_t, %struct.path_t* %dst, i32 0, i32 5
  %23 = load i8*, i8** %narrow26, align 8
  %call27 = call i32 @rename(i8* %22, i8* %23) #4
  store i32 %call27, i32* %result, align 4
  br label %if.end.28

if.end.28:                                        ; preds = %if.else, %if.then.21
  %24 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %24)
  %25 = load i32, i32* %result, align 4
  %tobool29 = icmp ne i32 %25, 0
  br i1 %tobool29, label %if.then.30, label %if.end.32

if.then.30:                                       ; preds = %if.end.28
  %call31 = call %struct._object* @path_error2(%struct.path_t* %src, %struct.path_t* %dst)
  store %struct._object* %call31, %struct._object** %return_value, align 8
  br label %exit

if.end.32:                                        ; preds = %if.end.28
  %26 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %26, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %return_value, align 8
  br label %exit

exit:                                             ; preds = %if.end.32, %if.then.30, %if.then.16
  call void @path_cleanup(%struct.path_t* %src)
  call void @path_cleanup(%struct.path_t* %dst)
  %27 = load %struct._object*, %struct._object** %return_value, align 8
  store %struct._object* %27, %struct._object** %retval
  br label %return

return:                                           ; preds = %exit, %if.then
  %28 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %28
}

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8*) #2

; Function Attrs: nounwind
declare i8* @strcat(i8*, i8*) #2

; Function Attrs: nounwind
declare i32 @renameat(i32, i8*, i32, i8*) #2

; Function Attrs: nounwind
declare i32 @rename(i8*, i8*) #2

; Function Attrs: nounwind
declare i32 @unlinkat(i32, i8*, i32) #2

; Function Attrs: nounwind
declare i32 @rmdir(i8*) #2

declare i32 @PyErr_WarnEx(%struct._object*, i8*, i64) #1

; Function Attrs: nounwind
declare i32 @symlinkat(i8*, i32, i8*) #2

; Function Attrs: nounwind
declare i32 @symlink(i8*, i8*) #2

declare i8* @PyBytes_AsString(%struct._object*) #1

declare i32 @system(i8*) #1

; Function Attrs: nounwind
declare i32 @umask(i32) #2

; Function Attrs: nounwind
declare i32 @uname(%struct.utsname*) #2

; Function Attrs: nounwind
declare i32 @unlink(i8*) #2

declare i64 @PyTuple_Size(%struct._object*) #1

declare i32 @_PyTime_ObjectToTimespec(%struct._object*, i64*, i64*, i32) #1

; Function Attrs: nounwind uwtable
define internal i32 @split_py_long_to_s_and_ns(%struct._object* %py_long, i64* %s, i64* %ns) #0 {
entry:
  %py_long.addr = alloca %struct._object*, align 8
  %s.addr = alloca i64*, align 8
  %ns.addr = alloca i64*, align 8
  %result = alloca i32, align 4
  %divmod = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %py_long, %struct._object** %py_long.addr, align 8
  store i64* %s, i64** %s.addr, align 8
  store i64* %ns, i64** %ns.addr, align 8
  store i32 0, i32* %result, align 4
  %0 = load %struct._object*, %struct._object** %py_long.addr, align 8
  %1 = load %struct._object*, %struct._object** @billion, align 8
  %call = call %struct._object* @PyNumber_Divmod(%struct._object* %0, %struct._object* %1)
  store %struct._object* %call, %struct._object** %divmod, align 8
  %2 = load %struct._object*, %struct._object** %divmod, align 8
  %tobool = icmp ne %struct._object* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %exit

if.end:                                           ; preds = %entry
  %3 = load %struct._object*, %struct._object** %divmod, align 8
  %4 = bitcast %struct._object* %3 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %4, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  %5 = load %struct._object*, %struct._object** %arrayidx, align 8
  %call1 = call i64 @_PyLong_AsTime_t(%struct._object* %5)
  %6 = load i64*, i64** %s.addr, align 8
  store i64 %call1, i64* %6, align 8
  %7 = load i64*, i64** %s.addr, align 8
  %8 = load i64, i64* %7, align 8
  %cmp = icmp eq i64 %8, -1
  br i1 %cmp, label %land.lhs.true, label %if.end.5

land.lhs.true:                                    ; preds = %if.end
  %call2 = call %struct._object* @PyErr_Occurred()
  %tobool3 = icmp ne %struct._object* %call2, null
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %land.lhs.true
  br label %exit

if.end.5:                                         ; preds = %land.lhs.true, %if.end
  %9 = load %struct._object*, %struct._object** %divmod, align 8
  %10 = bitcast %struct._object* %9 to %struct.PyTupleObject*
  %ob_item6 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %10, i32 0, i32 1
  %arrayidx7 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item6, i32 0, i64 1
  %11 = load %struct._object*, %struct._object** %arrayidx7, align 8
  %call8 = call i64 @PyLong_AsLong(%struct._object* %11)
  %12 = load i64*, i64** %ns.addr, align 8
  store i64 %call8, i64* %12, align 8
  %13 = load i64*, i64** %ns.addr, align 8
  %14 = load i64, i64* %13, align 8
  %cmp9 = icmp eq i64 %14, -1
  br i1 %cmp9, label %land.lhs.true.10, label %if.end.14

land.lhs.true.10:                                 ; preds = %if.end.5
  %call11 = call %struct._object* @PyErr_Occurred()
  %tobool12 = icmp ne %struct._object* %call11, null
  br i1 %tobool12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %land.lhs.true.10
  br label %exit

if.end.14:                                        ; preds = %land.lhs.true.10, %if.end.5
  store i32 1, i32* %result, align 4
  br label %exit

exit:                                             ; preds = %if.end.14, %if.then.13, %if.then.4, %if.then
  br label %do.body

do.body:                                          ; preds = %exit
  %15 = load %struct._object*, %struct._object** %divmod, align 8
  store %struct._object* %15, %struct._object** %_py_xdecref_tmp, align 8
  %16 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp15 = icmp ne %struct._object* %16, null
  br i1 %cmp15, label %if.then.16, label %if.end.21

if.then.16:                                       ; preds = %do.body
  br label %do.body.17

do.body.17:                                       ; preds = %if.then.16
  %17 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %17, %struct._object** %_py_decref_tmp, align 8
  %18 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %18, i32 0, i32 0
  %19 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %19, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp18 = icmp ne i64 %dec, 0
  br i1 %cmp18, label %if.then.19, label %if.else

if.then.19:                                       ; preds = %do.body.17
  br label %if.end.20

if.else:                                          ; preds = %do.body.17
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 1
  %21 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %21, i32 0, i32 4
  %22 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %23 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %22(%struct._object* %23)
  br label %if.end.20

if.end.20:                                        ; preds = %if.else, %if.then.19
  br label %do.end

do.end:                                           ; preds = %if.end.20
  br label %if.end.21

if.end.21:                                        ; preds = %do.end, %do.body
  br label %do.end.22

do.end.22:                                        ; preds = %if.end.21
  %24 = load i32, i32* %result, align 4
  ret i32 %24
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_nofollow_symlinks(%struct.utime_t* %utime, i8* %path) #0 {
entry:
  %utime.addr = alloca %struct.utime_t*, align 8
  %path.addr = alloca i8*, align 8
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca %struct.timespec*, align 8
  store %struct.utime_t* %utime, %struct.utime_t** %utime.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  %0 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, %struct.utime_t* %0, i32 0, i32 0
  %1 = load i32, i32* %now, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.timespec* null, %struct.timespec** %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %2, i32 0, i32 1
  %3 = load i64, i64* %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx, i32 0, i32 0
  store i64 %3, i64* %tv_sec, align 8
  %4 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %4, i32 0, i32 2
  %5 = load i64, i64* %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx1, i32 0, i32 1
  store i64 %5, i64* %tv_nsec, align 8
  %6 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %6, i32 0, i32 3
  %7 = load i64, i64* %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx2, i32 0, i32 0
  store i64 %7, i64* %tv_sec3, align 8
  %8 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %8, i32 0, i32 4
  %9 = load i64, i64* %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx4, i32 0, i32 1
  store i64 %9, i64* %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i32 0
  store %struct.timespec* %arraydecay, %struct.timespec** %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i8*, i8** %path.addr, align 8
  %11 = load %struct.timespec*, %struct.timespec** %time, align 8
  %call = call i32 @utimensat(i32 -100, i8* %10, %struct.timespec* %11, i32 256) #4
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_dir_fd(%struct.utime_t* %utime, i32 %dir_fd, i8* %path, i32 %follow_symlinks) #0 {
entry:
  %utime.addr = alloca %struct.utime_t*, align 8
  %dir_fd.addr = alloca i32, align 4
  %path.addr = alloca i8*, align 8
  %follow_symlinks.addr = alloca i32, align 4
  %flags = alloca i32, align 4
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca %struct.timespec*, align 8
  store %struct.utime_t* %utime, %struct.utime_t** %utime.addr, align 8
  store i32 %dir_fd, i32* %dir_fd.addr, align 4
  store i8* %path, i8** %path.addr, align 8
  store i32 %follow_symlinks, i32* %follow_symlinks.addr, align 4
  %0 = load i32, i32* %follow_symlinks.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %cond = select i1 %tobool, i32 0, i32 256
  store i32 %cond, i32* %flags, align 4
  %1 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, %struct.utime_t* %1, i32 0, i32 0
  %2 = load i32, i32* %now, align 4
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.timespec* null, %struct.timespec** %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %3, i32 0, i32 1
  %4 = load i64, i64* %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx, i32 0, i32 0
  store i64 %4, i64* %tv_sec, align 8
  %5 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %5, i32 0, i32 2
  %6 = load i64, i64* %atime_ns, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx2, i32 0, i32 1
  store i64 %6, i64* %tv_nsec, align 8
  %7 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %7, i32 0, i32 3
  %8 = load i64, i64* %mtime_s, align 8
  %arrayidx3 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_sec4 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx3, i32 0, i32 0
  store i64 %8, i64* %tv_sec4, align 8
  %9 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %9, i32 0, i32 4
  %10 = load i64, i64* %mtime_ns, align 8
  %arrayidx5 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_nsec6 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx5, i32 0, i32 1
  store i64 %10, i64* %tv_nsec6, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i32 0
  store %struct.timespec* %arraydecay, %struct.timespec** %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load i32, i32* %dir_fd.addr, align 4
  %12 = load i8*, i8** %path.addr, align 8
  %13 = load %struct.timespec*, %struct.timespec** %time, align 8
  %14 = load i32, i32* %flags, align 4
  %call = call i32 @utimensat(i32 %11, i8* %12, %struct.timespec* %13, i32 %14) #4
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_fd(%struct.utime_t* %utime, i32 %fd) #0 {
entry:
  %utime.addr = alloca %struct.utime_t*, align 8
  %fd.addr = alloca i32, align 4
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca %struct.timespec*, align 8
  store %struct.utime_t* %utime, %struct.utime_t** %utime.addr, align 8
  store i32 %fd, i32* %fd.addr, align 4
  %0 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, %struct.utime_t* %0, i32 0, i32 0
  %1 = load i32, i32* %now, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.timespec* null, %struct.timespec** %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %2, i32 0, i32 1
  %3 = load i64, i64* %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx, i32 0, i32 0
  store i64 %3, i64* %tv_sec, align 8
  %4 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %4, i32 0, i32 2
  %5 = load i64, i64* %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx1, i32 0, i32 1
  store i64 %5, i64* %tv_nsec, align 8
  %6 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %6, i32 0, i32 3
  %7 = load i64, i64* %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx2, i32 0, i32 0
  store i64 %7, i64* %tv_sec3, align 8
  %8 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %8, i32 0, i32 4
  %9 = load i64, i64* %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx4, i32 0, i32 1
  store i64 %9, i64* %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i32 0
  store %struct.timespec* %arraydecay, %struct.timespec** %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i32, i32* %fd.addr, align 4
  %11 = load %struct.timespec*, %struct.timespec** %time, align 8
  %call = call i32 @futimens(i32 %10, %struct.timespec* %11) #4
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @utime_default(%struct.utime_t* %utime, i8* %path) #0 {
entry:
  %utime.addr = alloca %struct.utime_t*, align 8
  %path.addr = alloca i8*, align 8
  %ts = alloca [2 x %struct.timespec], align 16
  %time = alloca %struct.timespec*, align 8
  store %struct.utime_t* %utime, %struct.utime_t** %utime.addr, align 8
  store i8* %path, i8** %path.addr, align 8
  %0 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %now = getelementptr inbounds %struct.utime_t, %struct.utime_t* %0, i32 0, i32 0
  %1 = load i32, i32* %now, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store %struct.timespec* null, %struct.timespec** %time, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %2, i32 0, i32 1
  %3 = load i64, i64* %atime_s, align 8
  %arrayidx = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx, i32 0, i32 0
  store i64 %3, i64* %tv_sec, align 8
  %4 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %atime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %4, i32 0, i32 2
  %5 = load i64, i64* %atime_ns, align 8
  %arrayidx1 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 0
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx1, i32 0, i32 1
  store i64 %5, i64* %tv_nsec, align 8
  %6 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_s = getelementptr inbounds %struct.utime_t, %struct.utime_t* %6, i32 0, i32 3
  %7 = load i64, i64* %mtime_s, align 8
  %arrayidx2 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_sec3 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx2, i32 0, i32 0
  store i64 %7, i64* %tv_sec3, align 8
  %8 = load %struct.utime_t*, %struct.utime_t** %utime.addr, align 8
  %mtime_ns = getelementptr inbounds %struct.utime_t, %struct.utime_t* %8, i32 0, i32 4
  %9 = load i64, i64* %mtime_ns, align 8
  %arrayidx4 = getelementptr [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i64 1
  %tv_nsec5 = getelementptr inbounds %struct.timespec, %struct.timespec* %arrayidx4, i32 0, i32 1
  store i64 %9, i64* %tv_nsec5, align 8
  %arraydecay = getelementptr inbounds [2 x %struct.timespec], [2 x %struct.timespec]* %ts, i32 0, i32 0
  store %struct.timespec* %arraydecay, %struct.timespec** %time, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %10 = load i8*, i8** %path.addr, align 8
  %11 = load %struct.timespec*, %struct.timespec** %time, align 8
  %call = call i32 @utimensat(i32 -100, i8* %10, %struct.timespec* %11, i32 0) #4
  ret i32 %call
}

declare %struct._object* @PyNumber_Divmod(%struct._object*, %struct._object*) #1

declare i64 @_PyLong_AsTime_t(%struct._object*) #1

declare i64 @PyLong_AsLong(%struct._object*) #1

; Function Attrs: nounwind
declare i32 @utimensat(i32, i8*, %struct.timespec*, i32) #2

; Function Attrs: nounwind
declare i32 @futimens(i32, %struct.timespec*) #2

; Function Attrs: nounwind
declare i64 @times(%struct.tms*) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @build_times_result(double %user, double %system, double %children_user, double %children_system, double %elapsed) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %user.addr = alloca double, align 8
  %system.addr = alloca double, align 8
  %children_user.addr = alloca double, align 8
  %children_system.addr = alloca double, align 8
  %elapsed.addr = alloca double, align 8
  %value = alloca %struct._object*, align 8
  %o = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %o7 = alloca %struct._object*, align 8
  %_py_decref_tmp12 = alloca %struct._object*, align 8
  %o25 = alloca %struct._object*, align 8
  %_py_decref_tmp30 = alloca %struct._object*, align 8
  %o43 = alloca %struct._object*, align 8
  %_py_decref_tmp48 = alloca %struct._object*, align 8
  %o61 = alloca %struct._object*, align 8
  %_py_decref_tmp66 = alloca %struct._object*, align 8
  store double %user, double* %user.addr, align 8
  store double %system, double* %system.addr, align 8
  store double %children_user, double* %children_user.addr, align 8
  store double %children_system, double* %children_system.addr, align 8
  store double %elapsed, double* %elapsed.addr, align 8
  %call = call %struct._object* @PyStructSequence_New(%struct._typeobject* @TimesResultType)
  store %struct._object* %call, %struct._object** %value, align 8
  %0 = load %struct._object*, %struct._object** %value, align 8
  %cmp = icmp eq %struct._object* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load double, double* %user.addr, align 8
  %call1 = call %struct._object* @PyFloat_FromDouble(double %1)
  store %struct._object* %call1, %struct._object** %o, align 8
  %2 = load %struct._object*, %struct._object** %o, align 8
  %tobool = icmp ne %struct._object* %2, null
  br i1 %tobool, label %if.end.6, label %if.then.2

if.then.2:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then.2
  %3 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %3, %struct._object** %_py_decref_tmp, align 8
  %4 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %4, i32 0, i32 0
  %5 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %5, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp3 = icmp ne i64 %dec, 0
  br i1 %cmp3, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %do.body
  br label %if.end.5

if.else:                                          ; preds = %do.body
  %6 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %6, i32 0, i32 1
  %7 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %7, i32 0, i32 4
  %8 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %9 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %8(%struct._object* %9)
  br label %if.end.5

if.end.5:                                         ; preds = %if.else, %if.then.4
  br label %do.end

do.end:                                           ; preds = %if.end.5
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %10 = load %struct._object*, %struct._object** %o, align 8
  %11 = load %struct._object*, %struct._object** %value, align 8
  %12 = bitcast %struct._object* %11 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %12, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %10, %struct._object** %arrayidx, align 8
  %13 = load double, double* %system.addr, align 8
  %call8 = call %struct._object* @PyFloat_FromDouble(double %13)
  store %struct._object* %call8, %struct._object** %o7, align 8
  %14 = load %struct._object*, %struct._object** %o7, align 8
  %tobool9 = icmp ne %struct._object* %14, null
  br i1 %tobool9, label %if.end.22, label %if.then.10

if.then.10:                                       ; preds = %if.end.6
  br label %do.body.11

do.body.11:                                       ; preds = %if.then.10
  %15 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %15, %struct._object** %_py_decref_tmp12, align 8
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp12, align 8
  %ob_refcnt13 = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 0
  %17 = load i64, i64* %ob_refcnt13, align 8
  %dec14 = add i64 %17, -1
  store i64 %dec14, i64* %ob_refcnt13, align 8
  %cmp15 = icmp ne i64 %dec14, 0
  br i1 %cmp15, label %if.then.16, label %if.else.17

if.then.16:                                       ; preds = %do.body.11
  br label %if.end.20

if.else.17:                                       ; preds = %do.body.11
  %18 = load %struct._object*, %struct._object** %_py_decref_tmp12, align 8
  %ob_type18 = getelementptr inbounds %struct._object, %struct._object* %18, i32 0, i32 1
  %19 = load %struct._typeobject*, %struct._typeobject** %ob_type18, align 8
  %tp_dealloc19 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %19, i32 0, i32 4
  %20 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc19, align 8
  %21 = load %struct._object*, %struct._object** %_py_decref_tmp12, align 8
  call void %20(%struct._object* %21)
  br label %if.end.20

if.end.20:                                        ; preds = %if.else.17, %if.then.16
  br label %do.end.21

do.end.21:                                        ; preds = %if.end.20
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.22:                                        ; preds = %if.end.6
  %22 = load %struct._object*, %struct._object** %o7, align 8
  %23 = load %struct._object*, %struct._object** %value, align 8
  %24 = bitcast %struct._object* %23 to %struct.PyTupleObject*
  %ob_item23 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx24 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item23, i32 0, i64 1
  store %struct._object* %22, %struct._object** %arrayidx24, align 8
  %25 = load double, double* %children_user.addr, align 8
  %call26 = call %struct._object* @PyFloat_FromDouble(double %25)
  store %struct._object* %call26, %struct._object** %o25, align 8
  %26 = load %struct._object*, %struct._object** %o25, align 8
  %tobool27 = icmp ne %struct._object* %26, null
  br i1 %tobool27, label %if.end.40, label %if.then.28

if.then.28:                                       ; preds = %if.end.22
  br label %do.body.29

do.body.29:                                       ; preds = %if.then.28
  %27 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %27, %struct._object** %_py_decref_tmp30, align 8
  %28 = load %struct._object*, %struct._object** %_py_decref_tmp30, align 8
  %ob_refcnt31 = getelementptr inbounds %struct._object, %struct._object* %28, i32 0, i32 0
  %29 = load i64, i64* %ob_refcnt31, align 8
  %dec32 = add i64 %29, -1
  store i64 %dec32, i64* %ob_refcnt31, align 8
  %cmp33 = icmp ne i64 %dec32, 0
  br i1 %cmp33, label %if.then.34, label %if.else.35

if.then.34:                                       ; preds = %do.body.29
  br label %if.end.38

if.else.35:                                       ; preds = %do.body.29
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp30, align 8
  %ob_type36 = getelementptr inbounds %struct._object, %struct._object* %30, i32 0, i32 1
  %31 = load %struct._typeobject*, %struct._typeobject** %ob_type36, align 8
  %tp_dealloc37 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %31, i32 0, i32 4
  %32 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc37, align 8
  %33 = load %struct._object*, %struct._object** %_py_decref_tmp30, align 8
  call void %32(%struct._object* %33)
  br label %if.end.38

if.end.38:                                        ; preds = %if.else.35, %if.then.34
  br label %do.end.39

do.end.39:                                        ; preds = %if.end.38
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.40:                                        ; preds = %if.end.22
  %34 = load %struct._object*, %struct._object** %o25, align 8
  %35 = load %struct._object*, %struct._object** %value, align 8
  %36 = bitcast %struct._object* %35 to %struct.PyTupleObject*
  %ob_item41 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %36, i32 0, i32 1
  %arrayidx42 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item41, i32 0, i64 2
  store %struct._object* %34, %struct._object** %arrayidx42, align 8
  %37 = load double, double* %children_system.addr, align 8
  %call44 = call %struct._object* @PyFloat_FromDouble(double %37)
  store %struct._object* %call44, %struct._object** %o43, align 8
  %38 = load %struct._object*, %struct._object** %o43, align 8
  %tobool45 = icmp ne %struct._object* %38, null
  br i1 %tobool45, label %if.end.58, label %if.then.46

if.then.46:                                       ; preds = %if.end.40
  br label %do.body.47

do.body.47:                                       ; preds = %if.then.46
  %39 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %39, %struct._object** %_py_decref_tmp48, align 8
  %40 = load %struct._object*, %struct._object** %_py_decref_tmp48, align 8
  %ob_refcnt49 = getelementptr inbounds %struct._object, %struct._object* %40, i32 0, i32 0
  %41 = load i64, i64* %ob_refcnt49, align 8
  %dec50 = add i64 %41, -1
  store i64 %dec50, i64* %ob_refcnt49, align 8
  %cmp51 = icmp ne i64 %dec50, 0
  br i1 %cmp51, label %if.then.52, label %if.else.53

if.then.52:                                       ; preds = %do.body.47
  br label %if.end.56

if.else.53:                                       ; preds = %do.body.47
  %42 = load %struct._object*, %struct._object** %_py_decref_tmp48, align 8
  %ob_type54 = getelementptr inbounds %struct._object, %struct._object* %42, i32 0, i32 1
  %43 = load %struct._typeobject*, %struct._typeobject** %ob_type54, align 8
  %tp_dealloc55 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %43, i32 0, i32 4
  %44 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc55, align 8
  %45 = load %struct._object*, %struct._object** %_py_decref_tmp48, align 8
  call void %44(%struct._object* %45)
  br label %if.end.56

if.end.56:                                        ; preds = %if.else.53, %if.then.52
  br label %do.end.57

do.end.57:                                        ; preds = %if.end.56
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.58:                                        ; preds = %if.end.40
  %46 = load %struct._object*, %struct._object** %o43, align 8
  %47 = load %struct._object*, %struct._object** %value, align 8
  %48 = bitcast %struct._object* %47 to %struct.PyTupleObject*
  %ob_item59 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %48, i32 0, i32 1
  %arrayidx60 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item59, i32 0, i64 3
  store %struct._object* %46, %struct._object** %arrayidx60, align 8
  %49 = load double, double* %elapsed.addr, align 8
  %call62 = call %struct._object* @PyFloat_FromDouble(double %49)
  store %struct._object* %call62, %struct._object** %o61, align 8
  %50 = load %struct._object*, %struct._object** %o61, align 8
  %tobool63 = icmp ne %struct._object* %50, null
  br i1 %tobool63, label %if.end.76, label %if.then.64

if.then.64:                                       ; preds = %if.end.58
  br label %do.body.65

do.body.65:                                       ; preds = %if.then.64
  %51 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %51, %struct._object** %_py_decref_tmp66, align 8
  %52 = load %struct._object*, %struct._object** %_py_decref_tmp66, align 8
  %ob_refcnt67 = getelementptr inbounds %struct._object, %struct._object* %52, i32 0, i32 0
  %53 = load i64, i64* %ob_refcnt67, align 8
  %dec68 = add i64 %53, -1
  store i64 %dec68, i64* %ob_refcnt67, align 8
  %cmp69 = icmp ne i64 %dec68, 0
  br i1 %cmp69, label %if.then.70, label %if.else.71

if.then.70:                                       ; preds = %do.body.65
  br label %if.end.74

if.else.71:                                       ; preds = %do.body.65
  %54 = load %struct._object*, %struct._object** %_py_decref_tmp66, align 8
  %ob_type72 = getelementptr inbounds %struct._object, %struct._object* %54, i32 0, i32 1
  %55 = load %struct._typeobject*, %struct._typeobject** %ob_type72, align 8
  %tp_dealloc73 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %55, i32 0, i32 4
  %56 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc73, align 8
  %57 = load %struct._object*, %struct._object** %_py_decref_tmp66, align 8
  call void %56(%struct._object* %57)
  br label %if.end.74

if.end.74:                                        ; preds = %if.else.71, %if.then.70
  br label %do.end.75

do.end.75:                                        ; preds = %if.end.74
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.76:                                        ; preds = %if.end.58
  %58 = load %struct._object*, %struct._object** %o61, align 8
  %59 = load %struct._object*, %struct._object** %value, align 8
  %60 = bitcast %struct._object* %59 to %struct.PyTupleObject*
  %ob_item77 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %60, i32 0, i32 1
  %arrayidx78 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item77, i32 0, i64 4
  store %struct._object* %58, %struct._object** %arrayidx78, align 8
  %61 = load %struct._object*, %struct._object** %value, align 8
  store %struct._object* %61, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.76, %do.end.75, %do.end.57, %do.end.39, %do.end.21, %do.end, %if.then
  %62 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %62
}

; Function Attrs: noreturn
declare void @_exit(i32) #6

declare i64 @PySequence_Size(%struct._object*) #1

; Function Attrs: nounwind uwtable
define internal i8** @parse_arglist(%struct._object* %argv, i64* %argc) #0 {
entry:
  %retval = alloca i8**, align 8
  %argv.addr = alloca %struct._object*, align 8
  %argc.addr = alloca i64*, align 8
  %i = alloca i32, align 4
  %argvlist = alloca i8**, align 8
  %item = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp21 = alloca %struct._object*, align 8
  store %struct._object* %argv, %struct._object** %argv.addr, align 8
  store i64* %argc, i64** %argc.addr, align 8
  %0 = load i64*, i64** %argc.addr, align 8
  %1 = load i64, i64* %0, align 8
  %add = add i64 %1, 1
  %cmp = icmp ugt i64 %add, 1152921504606846975
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64*, i64** %argc.addr, align 8
  %3 = load i64, i64* %2, align 8
  %add1 = add i64 %3, 1
  %mul = mul i64 %add1, 8
  %call = call i8* @PyMem_Malloc(i64 %mul)
  %4 = bitcast i8* %call to i8**
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8** [ null, %cond.true ], [ %4, %cond.false ]
  store i8** %cond, i8*** %argvlist, align 8
  %5 = load i8**, i8*** %argvlist, align 8
  %cmp2 = icmp eq i8** %5, null
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call3 = call %struct._object* @PyErr_NoMemory()
  store i8** null, i8*** %retval
  br label %return

if.end:                                           ; preds = %cond.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i32, i32* %i, align 4
  %conv = sext i32 %6 to i64
  %7 = load i64*, i64** %argc.addr, align 8
  %8 = load i64, i64* %7, align 8
  %cmp4 = icmp slt i64 %conv, %8
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load %struct._object*, %struct._object** %argv.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %9, i32 0, i32 1
  %10 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_as_sequence = getelementptr inbounds %struct._typeobject, %struct._typeobject* %10, i32 0, i32 11
  %11 = load %struct.PySequenceMethods*, %struct.PySequenceMethods** %tp_as_sequence, align 8
  %sq_item = getelementptr inbounds %struct.PySequenceMethods, %struct.PySequenceMethods* %11, i32 0, i32 3
  %12 = load %struct._object* (%struct._object*, i64)*, %struct._object* (%struct._object*, i64)** %sq_item, align 8
  %13 = load %struct._object*, %struct._object** %argv.addr, align 8
  %14 = load i32, i32* %i, align 4
  %conv6 = sext i32 %14 to i64
  %call7 = call %struct._object* %12(%struct._object* %13, i64 %conv6)
  store %struct._object* %call7, %struct._object** %item, align 8
  %15 = load %struct._object*, %struct._object** %item, align 8
  %cmp8 = icmp eq %struct._object* %15, null
  br i1 %cmp8, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %for.body
  br label %fail

if.end.11:                                        ; preds = %for.body
  %16 = load %struct._object*, %struct._object** %item, align 8
  %17 = load i32, i32* %i, align 4
  %idxprom = sext i32 %17 to i64
  %18 = load i8**, i8*** %argvlist, align 8
  %arrayidx = getelementptr i8*, i8** %18, i64 %idxprom
  %call12 = call i32 @fsconvert_strdup(%struct._object* %16, i8** %arrayidx)
  %tobool = icmp ne i32 %call12, 0
  br i1 %tobool, label %if.end.19, label %if.then.13

if.then.13:                                       ; preds = %if.end.11
  br label %do.body

do.body:                                          ; preds = %if.then.13
  %19 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %19, %struct._object** %_py_decref_tmp, align 8
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 0
  %21 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %21, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp14 = icmp ne i64 %dec, 0
  br i1 %cmp14, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %do.body
  br label %if.end.18

if.else:                                          ; preds = %do.body
  %22 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type17 = getelementptr inbounds %struct._object, %struct._object* %22, i32 0, i32 1
  %23 = load %struct._typeobject*, %struct._typeobject** %ob_type17, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %23, i32 0, i32 4
  %24 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %24(%struct._object* %25)
  br label %if.end.18

if.end.18:                                        ; preds = %if.else, %if.then.16
  br label %do.end

do.end:                                           ; preds = %if.end.18
  br label %fail

if.end.19:                                        ; preds = %if.end.11
  br label %do.body.20

do.body.20:                                       ; preds = %if.end.19
  %26 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %26, %struct._object** %_py_decref_tmp21, align 8
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  %ob_refcnt22 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 0
  %28 = load i64, i64* %ob_refcnt22, align 8
  %dec23 = add i64 %28, -1
  store i64 %dec23, i64* %ob_refcnt22, align 8
  %cmp24 = icmp ne i64 %dec23, 0
  br i1 %cmp24, label %if.then.26, label %if.else.27

if.then.26:                                       ; preds = %do.body.20
  br label %if.end.30

if.else.27:                                       ; preds = %do.body.20
  %29 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  %ob_type28 = getelementptr inbounds %struct._object, %struct._object* %29, i32 0, i32 1
  %30 = load %struct._typeobject*, %struct._typeobject** %ob_type28, align 8
  %tp_dealloc29 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %30, i32 0, i32 4
  %31 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc29, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp21, align 8
  call void %31(%struct._object* %32)
  br label %if.end.30

if.end.30:                                        ; preds = %if.else.27, %if.then.26
  br label %do.end.31

do.end.31:                                        ; preds = %if.end.30
  br label %for.inc

for.inc:                                          ; preds = %do.end.31
  %33 = load i32, i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load i64*, i64** %argc.addr, align 8
  %35 = load i64, i64* %34, align 8
  %36 = load i8**, i8*** %argvlist, align 8
  %arrayidx32 = getelementptr i8*, i8** %36, i64 %35
  store i8* null, i8** %arrayidx32, align 8
  %37 = load i8**, i8*** %argvlist, align 8
  store i8** %37, i8*** %retval
  br label %return

fail:                                             ; preds = %do.end, %if.then.10
  %38 = load i32, i32* %i, align 4
  %conv33 = sext i32 %38 to i64
  %39 = load i64*, i64** %argc.addr, align 8
  store i64 %conv33, i64* %39, align 8
  %40 = load i8**, i8*** %argvlist, align 8
  %41 = load i64*, i64** %argc.addr, align 8
  %42 = load i64, i64* %41, align 8
  call void @free_string_array(i8** %40, i64 %42)
  store i8** null, i8*** %retval
  br label %return

return:                                           ; preds = %fail, %for.end, %if.then
  %43 = load i8**, i8*** %retval
  ret i8** %43
}

; Function Attrs: nounwind
declare i32 @execv(i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal void @free_string_array(i8** %array, i64 %count) #0 {
entry:
  %array.addr = alloca i8**, align 8
  %count.addr = alloca i64, align 8
  %i = alloca i64, align 8
  store i8** %array, i8*** %array.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %i, align 8
  %1 = load i64, i64* %count.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %i, align 8
  %3 = load i8**, i8*** %array.addr, align 8
  %arrayidx = getelementptr i8*, i8** %3, i64 %2
  %4 = load i8*, i8** %arrayidx, align 8
  call void @PyMem_Free(i8* %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i64, i64* %i, align 8
  %inc = add i64 %5, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %6 = load i8**, i8*** %array.addr, align 8
  %7 = bitcast i8** %6 to i8*
  call void @PyMem_Free(i8* %7)
  ret void
}

declare i8* @PyMem_Malloc(i64) #1

declare %struct._object* @PyErr_NoMemory() #1

; Function Attrs: nounwind uwtable
define internal i32 @fsconvert_strdup(%struct._object* %o, i8** %out) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct._object*, align 8
  %out.addr = alloca i8**, align 8
  %bytes = alloca %struct._object*, align 8
  %size = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  store %struct._object* %o, %struct._object** %o.addr, align 8
  store i8** %out, i8*** %out.addr, align 8
  %0 = load %struct._object*, %struct._object** %o.addr, align 8
  %1 = bitcast %struct._object** %bytes to i8*
  %call = call i32 @PyUnicode_FSConverter(%struct._object* %0, i8* %1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct._object*, %struct._object** %bytes, align 8
  %3 = bitcast %struct._object* %2 to %struct.PyVarObject*
  %ob_size = getelementptr inbounds %struct.PyVarObject, %struct.PyVarObject* %3, i32 0, i32 1
  %4 = load i64, i64* %ob_size, align 8
  store i64 %4, i64* %size, align 8
  %5 = load i64, i64* %size, align 8
  %add = add i64 %5, 1
  %call1 = call i8* @PyMem_Malloc(i64 %add)
  %6 = load i8**, i8*** %out.addr, align 8
  store i8* %call1, i8** %6, align 8
  %7 = load i8**, i8*** %out.addr, align 8
  %8 = load i8*, i8** %7, align 8
  %tobool2 = icmp ne i8* %8, null
  br i1 %tobool2, label %if.end.5, label %if.then.3

if.then.3:                                        ; preds = %if.end
  %call4 = call %struct._object* @PyErr_NoMemory()
  store i32 0, i32* %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %9 = load i8**, i8*** %out.addr, align 8
  %10 = load i8*, i8** %9, align 8
  %11 = load %struct._object*, %struct._object** %bytes, align 8
  %call6 = call i8* @PyBytes_AsString(%struct._object* %11)
  %12 = load i64, i64* %size, align 8
  %add7 = add i64 %12, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %10, i8* %call6, i64 %add7, i32 1, i1 false)
  br label %do.body

do.body:                                          ; preds = %if.end.5
  %13 = load %struct._object*, %struct._object** %bytes, align 8
  store %struct._object* %13, %struct._object** %_py_decref_tmp, align 8
  %14 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %14, i32 0, i32 0
  %15 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %15, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp = icmp ne i64 %dec, 0
  br i1 %cmp, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %do.body
  br label %if.end.9

if.else:                                          ; preds = %do.body
  %16 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %16, i32 0, i32 1
  %17 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %17, i32 0, i32 4
  %18 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %19 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %18(%struct._object* %19)
  br label %if.end.9

if.end.9:                                         ; preds = %if.else, %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.9
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then.3, %if.then
  %20 = load i32, i32* %retval
  ret i32 %20
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #4

declare void @PyMem_Free(i8*) #1

declare i32 @PyMapping_Check(%struct._object*) #1

; Function Attrs: nounwind uwtable
define internal i8** @parse_envlist(%struct._object* %env, i64* %envc_ptr) #0 {
entry:
  %retval = alloca i8**, align 8
  %env.addr = alloca %struct._object*, align 8
  %envc_ptr.addr = alloca i64*, align 8
  %envlist = alloca i8**, align 8
  %i = alloca i64, align 8
  %pos = alloca i64, align 8
  %envc = alloca i64, align 8
  %keys = alloca %struct._object*, align 8
  %vals = alloca %struct._object*, align 8
  %key = alloca %struct._object*, align 8
  %val = alloca %struct._object*, align 8
  %key2 = alloca %struct._object*, align 8
  %val2 = alloca %struct._object*, align 8
  %p = alloca i8*, align 8
  %k = alloca i8*, align 8
  %v = alloca i8*, align 8
  %len = alloca i64, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp59 = alloca %struct._object*, align 8
  %_py_decref_tmp70 = alloca %struct._object*, align 8
  %_py_decref_tmp83 = alloca %struct._object*, align 8
  %_py_decref_tmp94 = alloca %struct._object*, align 8
  %_py_decref_tmp106 = alloca %struct._object*, align 8
  %_py_decref_tmp117 = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp132 = alloca %struct._object*, align 8
  %_py_xdecref_tmp145 = alloca %struct._object*, align 8
  %_py_decref_tmp149 = alloca %struct._object*, align 8
  store %struct._object* %env, %struct._object** %env.addr, align 8
  store i64* %envc_ptr, i64** %envc_ptr.addr, align 8
  store %struct._object* null, %struct._object** %keys, align 8
  store %struct._object* null, %struct._object** %vals, align 8
  %0 = load %struct._object*, %struct._object** %env.addr, align 8
  %call = call i64 @PyMapping_Size(%struct._object* %0)
  store i64 %call, i64* %i, align 8
  %1 = load i64, i64* %i, align 8
  %cmp = icmp slt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8** null, i8*** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %i, align 8
  %add = add i64 %2, 1
  %cmp1 = icmp ugt i64 %add, 1152921504606846975
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %3 = load i64, i64* %i, align 8
  %add2 = add i64 %3, 1
  %mul = mul i64 %add2, 8
  %call3 = call i8* @PyMem_Malloc(i64 %mul)
  %4 = bitcast i8* %call3 to i8**
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8** [ null, %cond.true ], [ %4, %cond.false ]
  store i8** %cond, i8*** %envlist, align 8
  %5 = load i8**, i8*** %envlist, align 8
  %cmp4 = icmp eq i8** %5, null
  br i1 %cmp4, label %if.then.5, label %if.end.7

if.then.5:                                        ; preds = %cond.end
  %call6 = call %struct._object* @PyErr_NoMemory()
  store i8** null, i8*** %retval
  br label %return

if.end.7:                                         ; preds = %cond.end
  store i64 0, i64* %envc, align 8
  %6 = load %struct._object*, %struct._object** %env.addr, align 8
  %call8 = call %struct._object* @PyMapping_Keys(%struct._object* %6)
  store %struct._object* %call8, %struct._object** %keys, align 8
  %7 = load %struct._object*, %struct._object** %keys, align 8
  %tobool = icmp ne %struct._object* %7, null
  br i1 %tobool, label %if.end.10, label %if.then.9

if.then.9:                                        ; preds = %if.end.7
  br label %error

if.end.10:                                        ; preds = %if.end.7
  %8 = load %struct._object*, %struct._object** %env.addr, align 8
  %call11 = call %struct._object* @PyMapping_Values(%struct._object* %8)
  store %struct._object* %call11, %struct._object** %vals, align 8
  %9 = load %struct._object*, %struct._object** %vals, align 8
  %tobool12 = icmp ne %struct._object* %9, null
  br i1 %tobool12, label %if.end.14, label %if.then.13

if.then.13:                                       ; preds = %if.end.10
  br label %error

if.end.14:                                        ; preds = %if.end.10
  %10 = load %struct._object*, %struct._object** %keys, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %10, i32 0, i32 1
  %11 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %11, i32 0, i32 19
  %12 = load i64, i64* %tp_flags, align 8
  %and = and i64 %12, 33554432
  %cmp15 = icmp ne i64 %and, 0
  br i1 %cmp15, label %lor.lhs.false, label %if.then.20

lor.lhs.false:                                    ; preds = %if.end.14
  %13 = load %struct._object*, %struct._object** %vals, align 8
  %ob_type16 = getelementptr inbounds %struct._object, %struct._object* %13, i32 0, i32 1
  %14 = load %struct._typeobject*, %struct._typeobject** %ob_type16, align 8
  %tp_flags17 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %14, i32 0, i32 19
  %15 = load i64, i64* %tp_flags17, align 8
  %and18 = and i64 %15, 33554432
  %cmp19 = icmp ne i64 %and18, 0
  br i1 %cmp19, label %if.end.22, label %if.then.20

if.then.20:                                       ; preds = %lor.lhs.false, %if.end.14
  %16 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  %call21 = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %16, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.236, i32 0, i32 0))
  br label %error

if.end.22:                                        ; preds = %lor.lhs.false
  store i64 0, i64* %pos, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.22
  %17 = load i64, i64* %pos, align 8
  %18 = load i64, i64* %i, align 8
  %cmp23 = icmp slt i64 %17, %18
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load %struct._object*, %struct._object** %keys, align 8
  %20 = load i64, i64* %pos, align 8
  %call24 = call %struct._object* @PyList_GetItem(%struct._object* %19, i64 %20)
  store %struct._object* %call24, %struct._object** %key, align 8
  %21 = load %struct._object*, %struct._object** %vals, align 8
  %22 = load i64, i64* %pos, align 8
  %call25 = call %struct._object* @PyList_GetItem(%struct._object* %21, i64 %22)
  store %struct._object* %call25, %struct._object** %val, align 8
  %23 = load %struct._object*, %struct._object** %key, align 8
  %tobool26 = icmp ne %struct._object* %23, null
  br i1 %tobool26, label %lor.lhs.false.27, label %if.then.29

lor.lhs.false.27:                                 ; preds = %for.body
  %24 = load %struct._object*, %struct._object** %val, align 8
  %tobool28 = icmp ne %struct._object* %24, null
  br i1 %tobool28, label %if.end.30, label %if.then.29

if.then.29:                                       ; preds = %lor.lhs.false.27, %for.body
  br label %error

if.end.30:                                        ; preds = %lor.lhs.false.27
  %25 = load %struct._object*, %struct._object** %key, align 8
  %26 = bitcast %struct._object** %key2 to i8*
  %call31 = call i32 @PyUnicode_FSConverter(%struct._object* %25, i8* %26)
  %cmp32 = icmp eq i32 %call31, 0
  br i1 %cmp32, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.end.30
  br label %error

if.end.34:                                        ; preds = %if.end.30
  %27 = load %struct._object*, %struct._object** %val, align 8
  %28 = bitcast %struct._object** %val2 to i8*
  %call35 = call i32 @PyUnicode_FSConverter(%struct._object* %27, i8* %28)
  %cmp36 = icmp eq i32 %call35, 0
  br i1 %cmp36, label %if.then.37, label %if.end.42

if.then.37:                                       ; preds = %if.end.34
  br label %do.body

do.body:                                          ; preds = %if.then.37
  %29 = load %struct._object*, %struct._object** %key2, align 8
  store %struct._object* %29, %struct._object** %_py_decref_tmp, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %30, i32 0, i32 0
  %31 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %31, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp38 = icmp ne i64 %dec, 0
  br i1 %cmp38, label %if.then.39, label %if.else

if.then.39:                                       ; preds = %do.body
  br label %if.end.41

if.else:                                          ; preds = %do.body
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type40 = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 1
  %33 = load %struct._typeobject*, %struct._typeobject** %ob_type40, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %33, i32 0, i32 4
  %34 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %34(%struct._object* %35)
  br label %if.end.41

if.end.41:                                        ; preds = %if.else, %if.then.39
  br label %do.end

do.end:                                           ; preds = %if.end.41
  br label %error

if.end.42:                                        ; preds = %if.end.34
  %36 = load %struct._object*, %struct._object** %key2, align 8
  %call43 = call i8* @PyBytes_AsString(%struct._object* %36)
  store i8* %call43, i8** %k, align 8
  %37 = load %struct._object*, %struct._object** %val2, align 8
  %call44 = call i8* @PyBytes_AsString(%struct._object* %37)
  store i8* %call44, i8** %v, align 8
  %38 = load %struct._object*, %struct._object** %key2, align 8
  %39 = bitcast %struct._object* %38 to %struct.PyVarObject*
  %ob_size = getelementptr inbounds %struct.PyVarObject, %struct.PyVarObject* %39, i32 0, i32 1
  %40 = load i64, i64* %ob_size, align 8
  %41 = load %struct._object*, %struct._object** %val2, align 8
  %42 = bitcast %struct._object* %41 to %struct.PyVarObject*
  %ob_size45 = getelementptr inbounds %struct.PyVarObject, %struct.PyVarObject* %42, i32 0, i32 1
  %43 = load i64, i64* %ob_size45, align 8
  %add46 = add i64 %40, %43
  %add47 = add i64 %add46, 2
  store i64 %add47, i64* %len, align 8
  %44 = load i64, i64* %len, align 8
  %cmp48 = icmp ugt i64 %44, 9223372036854775807
  br i1 %cmp48, label %cond.true.49, label %cond.false.50

cond.true.49:                                     ; preds = %if.end.42
  br label %cond.end.53

cond.false.50:                                    ; preds = %if.end.42
  %45 = load i64, i64* %len, align 8
  %mul51 = mul i64 %45, 1
  %call52 = call i8* @PyMem_Malloc(i64 %mul51)
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.50, %cond.true.49
  %cond54 = phi i8* [ null, %cond.true.49 ], [ %call52, %cond.false.50 ]
  store i8* %cond54, i8** %p, align 8
  %46 = load i8*, i8** %p, align 8
  %cmp55 = icmp eq i8* %46, null
  br i1 %cmp55, label %if.then.56, label %if.end.80

if.then.56:                                       ; preds = %cond.end.53
  %call57 = call %struct._object* @PyErr_NoMemory()
  br label %do.body.58

do.body.58:                                       ; preds = %if.then.56
  %47 = load %struct._object*, %struct._object** %key2, align 8
  store %struct._object* %47, %struct._object** %_py_decref_tmp59, align 8
  %48 = load %struct._object*, %struct._object** %_py_decref_tmp59, align 8
  %ob_refcnt60 = getelementptr inbounds %struct._object, %struct._object* %48, i32 0, i32 0
  %49 = load i64, i64* %ob_refcnt60, align 8
  %dec61 = add i64 %49, -1
  store i64 %dec61, i64* %ob_refcnt60, align 8
  %cmp62 = icmp ne i64 %dec61, 0
  br i1 %cmp62, label %if.then.63, label %if.else.64

if.then.63:                                       ; preds = %do.body.58
  br label %if.end.67

if.else.64:                                       ; preds = %do.body.58
  %50 = load %struct._object*, %struct._object** %_py_decref_tmp59, align 8
  %ob_type65 = getelementptr inbounds %struct._object, %struct._object* %50, i32 0, i32 1
  %51 = load %struct._typeobject*, %struct._typeobject** %ob_type65, align 8
  %tp_dealloc66 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %51, i32 0, i32 4
  %52 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc66, align 8
  %53 = load %struct._object*, %struct._object** %_py_decref_tmp59, align 8
  call void %52(%struct._object* %53)
  br label %if.end.67

if.end.67:                                        ; preds = %if.else.64, %if.then.63
  br label %do.end.68

do.end.68:                                        ; preds = %if.end.67
  br label %do.body.69

do.body.69:                                       ; preds = %do.end.68
  %54 = load %struct._object*, %struct._object** %val2, align 8
  store %struct._object* %54, %struct._object** %_py_decref_tmp70, align 8
  %55 = load %struct._object*, %struct._object** %_py_decref_tmp70, align 8
  %ob_refcnt71 = getelementptr inbounds %struct._object, %struct._object* %55, i32 0, i32 0
  %56 = load i64, i64* %ob_refcnt71, align 8
  %dec72 = add i64 %56, -1
  store i64 %dec72, i64* %ob_refcnt71, align 8
  %cmp73 = icmp ne i64 %dec72, 0
  br i1 %cmp73, label %if.then.74, label %if.else.75

if.then.74:                                       ; preds = %do.body.69
  br label %if.end.78

if.else.75:                                       ; preds = %do.body.69
  %57 = load %struct._object*, %struct._object** %_py_decref_tmp70, align 8
  %ob_type76 = getelementptr inbounds %struct._object, %struct._object* %57, i32 0, i32 1
  %58 = load %struct._typeobject*, %struct._typeobject** %ob_type76, align 8
  %tp_dealloc77 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %58, i32 0, i32 4
  %59 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc77, align 8
  %60 = load %struct._object*, %struct._object** %_py_decref_tmp70, align 8
  call void %59(%struct._object* %60)
  br label %if.end.78

if.end.78:                                        ; preds = %if.else.75, %if.then.74
  br label %do.end.79

do.end.79:                                        ; preds = %if.end.78
  br label %error

if.end.80:                                        ; preds = %cond.end.53
  %61 = load i8*, i8** %p, align 8
  %62 = load i64, i64* %len, align 8
  %63 = load i8*, i8** %k, align 8
  %64 = load i8*, i8** %v, align 8
  %call81 = call i32 (i8*, i64, i8*, ...) @PyOS_snprintf(i8* %61, i64 %62, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.237, i32 0, i32 0), i8* %63, i8* %64)
  %65 = load i8*, i8** %p, align 8
  %66 = load i64, i64* %envc, align 8
  %inc = add i64 %66, 1
  store i64 %inc, i64* %envc, align 8
  %67 = load i8**, i8*** %envlist, align 8
  %arrayidx = getelementptr i8*, i8** %67, i64 %66
  store i8* %65, i8** %arrayidx, align 8
  br label %do.body.82

do.body.82:                                       ; preds = %if.end.80
  %68 = load %struct._object*, %struct._object** %key2, align 8
  store %struct._object* %68, %struct._object** %_py_decref_tmp83, align 8
  %69 = load %struct._object*, %struct._object** %_py_decref_tmp83, align 8
  %ob_refcnt84 = getelementptr inbounds %struct._object, %struct._object* %69, i32 0, i32 0
  %70 = load i64, i64* %ob_refcnt84, align 8
  %dec85 = add i64 %70, -1
  store i64 %dec85, i64* %ob_refcnt84, align 8
  %cmp86 = icmp ne i64 %dec85, 0
  br i1 %cmp86, label %if.then.87, label %if.else.88

if.then.87:                                       ; preds = %do.body.82
  br label %if.end.91

if.else.88:                                       ; preds = %do.body.82
  %71 = load %struct._object*, %struct._object** %_py_decref_tmp83, align 8
  %ob_type89 = getelementptr inbounds %struct._object, %struct._object* %71, i32 0, i32 1
  %72 = load %struct._typeobject*, %struct._typeobject** %ob_type89, align 8
  %tp_dealloc90 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %72, i32 0, i32 4
  %73 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc90, align 8
  %74 = load %struct._object*, %struct._object** %_py_decref_tmp83, align 8
  call void %73(%struct._object* %74)
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.88, %if.then.87
  br label %do.end.92

do.end.92:                                        ; preds = %if.end.91
  br label %do.body.93

do.body.93:                                       ; preds = %do.end.92
  %75 = load %struct._object*, %struct._object** %val2, align 8
  store %struct._object* %75, %struct._object** %_py_decref_tmp94, align 8
  %76 = load %struct._object*, %struct._object** %_py_decref_tmp94, align 8
  %ob_refcnt95 = getelementptr inbounds %struct._object, %struct._object* %76, i32 0, i32 0
  %77 = load i64, i64* %ob_refcnt95, align 8
  %dec96 = add i64 %77, -1
  store i64 %dec96, i64* %ob_refcnt95, align 8
  %cmp97 = icmp ne i64 %dec96, 0
  br i1 %cmp97, label %if.then.98, label %if.else.99

if.then.98:                                       ; preds = %do.body.93
  br label %if.end.102

if.else.99:                                       ; preds = %do.body.93
  %78 = load %struct._object*, %struct._object** %_py_decref_tmp94, align 8
  %ob_type100 = getelementptr inbounds %struct._object, %struct._object* %78, i32 0, i32 1
  %79 = load %struct._typeobject*, %struct._typeobject** %ob_type100, align 8
  %tp_dealloc101 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %79, i32 0, i32 4
  %80 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc101, align 8
  %81 = load %struct._object*, %struct._object** %_py_decref_tmp94, align 8
  call void %80(%struct._object* %81)
  br label %if.end.102

if.end.102:                                       ; preds = %if.else.99, %if.then.98
  br label %do.end.103

do.end.103:                                       ; preds = %if.end.102
  br label %for.inc

for.inc:                                          ; preds = %do.end.103
  %82 = load i64, i64* %pos, align 8
  %inc104 = add i64 %82, 1
  store i64 %inc104, i64* %pos, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %do.body.105

do.body.105:                                      ; preds = %for.end
  %83 = load %struct._object*, %struct._object** %vals, align 8
  store %struct._object* %83, %struct._object** %_py_decref_tmp106, align 8
  %84 = load %struct._object*, %struct._object** %_py_decref_tmp106, align 8
  %ob_refcnt107 = getelementptr inbounds %struct._object, %struct._object* %84, i32 0, i32 0
  %85 = load i64, i64* %ob_refcnt107, align 8
  %dec108 = add i64 %85, -1
  store i64 %dec108, i64* %ob_refcnt107, align 8
  %cmp109 = icmp ne i64 %dec108, 0
  br i1 %cmp109, label %if.then.110, label %if.else.111

if.then.110:                                      ; preds = %do.body.105
  br label %if.end.114

if.else.111:                                      ; preds = %do.body.105
  %86 = load %struct._object*, %struct._object** %_py_decref_tmp106, align 8
  %ob_type112 = getelementptr inbounds %struct._object, %struct._object* %86, i32 0, i32 1
  %87 = load %struct._typeobject*, %struct._typeobject** %ob_type112, align 8
  %tp_dealloc113 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %87, i32 0, i32 4
  %88 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc113, align 8
  %89 = load %struct._object*, %struct._object** %_py_decref_tmp106, align 8
  call void %88(%struct._object* %89)
  br label %if.end.114

if.end.114:                                       ; preds = %if.else.111, %if.then.110
  br label %do.end.115

do.end.115:                                       ; preds = %if.end.114
  br label %do.body.116

do.body.116:                                      ; preds = %do.end.115
  %90 = load %struct._object*, %struct._object** %keys, align 8
  store %struct._object* %90, %struct._object** %_py_decref_tmp117, align 8
  %91 = load %struct._object*, %struct._object** %_py_decref_tmp117, align 8
  %ob_refcnt118 = getelementptr inbounds %struct._object, %struct._object* %91, i32 0, i32 0
  %92 = load i64, i64* %ob_refcnt118, align 8
  %dec119 = add i64 %92, -1
  store i64 %dec119, i64* %ob_refcnt118, align 8
  %cmp120 = icmp ne i64 %dec119, 0
  br i1 %cmp120, label %if.then.121, label %if.else.122

if.then.121:                                      ; preds = %do.body.116
  br label %if.end.125

if.else.122:                                      ; preds = %do.body.116
  %93 = load %struct._object*, %struct._object** %_py_decref_tmp117, align 8
  %ob_type123 = getelementptr inbounds %struct._object, %struct._object* %93, i32 0, i32 1
  %94 = load %struct._typeobject*, %struct._typeobject** %ob_type123, align 8
  %tp_dealloc124 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %94, i32 0, i32 4
  %95 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc124, align 8
  %96 = load %struct._object*, %struct._object** %_py_decref_tmp117, align 8
  call void %95(%struct._object* %96)
  br label %if.end.125

if.end.125:                                       ; preds = %if.else.122, %if.then.121
  br label %do.end.126

do.end.126:                                       ; preds = %if.end.125
  %97 = load i64, i64* %envc, align 8
  %98 = load i8**, i8*** %envlist, align 8
  %arrayidx127 = getelementptr i8*, i8** %98, i64 %97
  store i8* null, i8** %arrayidx127, align 8
  %99 = load i64, i64* %envc, align 8
  %100 = load i64*, i64** %envc_ptr.addr, align 8
  store i64 %99, i64* %100, align 8
  %101 = load i8**, i8*** %envlist, align 8
  store i8** %101, i8*** %retval
  br label %return

error:                                            ; preds = %do.end.79, %do.end, %if.then.33, %if.then.29, %if.then.20, %if.then.13, %if.then.9
  br label %do.body.128

do.body.128:                                      ; preds = %error
  %102 = load %struct._object*, %struct._object** %keys, align 8
  store %struct._object* %102, %struct._object** %_py_xdecref_tmp, align 8
  %103 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp129 = icmp ne %struct._object* %103, null
  br i1 %cmp129, label %if.then.130, label %if.end.142

if.then.130:                                      ; preds = %do.body.128
  br label %do.body.131

do.body.131:                                      ; preds = %if.then.130
  %104 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %104, %struct._object** %_py_decref_tmp132, align 8
  %105 = load %struct._object*, %struct._object** %_py_decref_tmp132, align 8
  %ob_refcnt133 = getelementptr inbounds %struct._object, %struct._object* %105, i32 0, i32 0
  %106 = load i64, i64* %ob_refcnt133, align 8
  %dec134 = add i64 %106, -1
  store i64 %dec134, i64* %ob_refcnt133, align 8
  %cmp135 = icmp ne i64 %dec134, 0
  br i1 %cmp135, label %if.then.136, label %if.else.137

if.then.136:                                      ; preds = %do.body.131
  br label %if.end.140

if.else.137:                                      ; preds = %do.body.131
  %107 = load %struct._object*, %struct._object** %_py_decref_tmp132, align 8
  %ob_type138 = getelementptr inbounds %struct._object, %struct._object* %107, i32 0, i32 1
  %108 = load %struct._typeobject*, %struct._typeobject** %ob_type138, align 8
  %tp_dealloc139 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %108, i32 0, i32 4
  %109 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc139, align 8
  %110 = load %struct._object*, %struct._object** %_py_decref_tmp132, align 8
  call void %109(%struct._object* %110)
  br label %if.end.140

if.end.140:                                       ; preds = %if.else.137, %if.then.136
  br label %do.end.141

do.end.141:                                       ; preds = %if.end.140
  br label %if.end.142

if.end.142:                                       ; preds = %do.end.141, %do.body.128
  br label %do.end.143

do.end.143:                                       ; preds = %if.end.142
  br label %do.body.144

do.body.144:                                      ; preds = %do.end.143
  %111 = load %struct._object*, %struct._object** %vals, align 8
  store %struct._object* %111, %struct._object** %_py_xdecref_tmp145, align 8
  %112 = load %struct._object*, %struct._object** %_py_xdecref_tmp145, align 8
  %cmp146 = icmp ne %struct._object* %112, null
  br i1 %cmp146, label %if.then.147, label %if.end.159

if.then.147:                                      ; preds = %do.body.144
  br label %do.body.148

do.body.148:                                      ; preds = %if.then.147
  %113 = load %struct._object*, %struct._object** %_py_xdecref_tmp145, align 8
  store %struct._object* %113, %struct._object** %_py_decref_tmp149, align 8
  %114 = load %struct._object*, %struct._object** %_py_decref_tmp149, align 8
  %ob_refcnt150 = getelementptr inbounds %struct._object, %struct._object* %114, i32 0, i32 0
  %115 = load i64, i64* %ob_refcnt150, align 8
  %dec151 = add i64 %115, -1
  store i64 %dec151, i64* %ob_refcnt150, align 8
  %cmp152 = icmp ne i64 %dec151, 0
  br i1 %cmp152, label %if.then.153, label %if.else.154

if.then.153:                                      ; preds = %do.body.148
  br label %if.end.157

if.else.154:                                      ; preds = %do.body.148
  %116 = load %struct._object*, %struct._object** %_py_decref_tmp149, align 8
  %ob_type155 = getelementptr inbounds %struct._object, %struct._object* %116, i32 0, i32 1
  %117 = load %struct._typeobject*, %struct._typeobject** %ob_type155, align 8
  %tp_dealloc156 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %117, i32 0, i32 4
  %118 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc156, align 8
  %119 = load %struct._object*, %struct._object** %_py_decref_tmp149, align 8
  call void %118(%struct._object* %119)
  br label %if.end.157

if.end.157:                                       ; preds = %if.else.154, %if.then.153
  br label %do.end.158

do.end.158:                                       ; preds = %if.end.157
  br label %if.end.159

if.end.159:                                       ; preds = %do.end.158, %do.body.144
  br label %do.end.160

do.end.160:                                       ; preds = %if.end.159
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end.160
  %120 = load i64, i64* %envc, align 8
  %dec161 = add i64 %120, -1
  store i64 %dec161, i64* %envc, align 8
  %cmp162 = icmp sge i64 %dec161, 0
  br i1 %cmp162, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %121 = load i64, i64* %envc, align 8
  %122 = load i8**, i8*** %envlist, align 8
  %arrayidx163 = getelementptr i8*, i8** %122, i64 %121
  %123 = load i8*, i8** %arrayidx163, align 8
  call void @PyMem_Free(i8* %123)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %124 = load i8**, i8*** %envlist, align 8
  %125 = bitcast i8** %124 to i8*
  call void @PyMem_Free(i8* %125)
  store i8** null, i8*** %retval
  br label %return

return:                                           ; preds = %while.end, %do.end.126, %if.then.5, %if.then
  %126 = load i8**, i8*** %retval
  ret i8** %126
}

; Function Attrs: nounwind
declare i32 @fexecve(i32, i8**, i8**) #2

; Function Attrs: nounwind
declare i32 @execve(i8*, i8**, i8**) #2

declare i64 @PyMapping_Size(%struct._object*) #1

declare %struct._object* @PyMapping_Keys(%struct._object*) #1

declare %struct._object* @PyMapping_Values(%struct._object*) #1

declare %struct._object* @PyList_GetItem(%struct._object*, i64) #1

declare i32 @PyOS_snprintf(i8*, i64, i8*, ...) #1

declare void @_PyImport_AcquireLock() #1

; Function Attrs: nounwind
declare i32 @fork() #2

declare void @PyOS_AfterFork() #1

declare i32 @_PyImport_ReleaseLock() #1

; Function Attrs: nounwind
declare i32 @sched_get_priority_max(i32) #2

; Function Attrs: nounwind
declare i32 @sched_get_priority_min(i32) #2

; Function Attrs: nounwind
declare i32 @sched_getparam(i32, %struct.sched_param*) #2

; Function Attrs: nounwind
declare i32 @sched_getscheduler(i32) #2

; Function Attrs: nounwind
declare i32 @sched_rr_get_interval(i32, %struct.timespec*) #2

; Function Attrs: nounwind uwtable
define internal i32 @convert_sched_param(%struct._object* %param, %struct.sched_param* %res) #0 {
entry:
  %retval = alloca i32, align 4
  %param.addr = alloca %struct._object*, align 8
  %res.addr = alloca %struct.sched_param*, align 8
  %priority = alloca i64, align 8
  store %struct._object* %param, %struct._object** %param.addr, align 8
  store %struct.sched_param* %res, %struct.sched_param** %res.addr, align 8
  %0 = load %struct._object*, %struct._object** %param.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %0, i32 0, i32 1
  %1 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %cmp = icmp ne %struct._typeobject* %1, @SchedParamType
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.245, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct._object*, %struct._object** %param.addr, align 8
  %4 = bitcast %struct._object* %3 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %4, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  %5 = load %struct._object*, %struct._object** %arrayidx, align 8
  %call = call i64 @PyLong_AsLong(%struct._object* %5)
  store i64 %call, i64* %priority, align 8
  %6 = load i64, i64* %priority, align 8
  %cmp1 = icmp eq i64 %6, -1
  br i1 %cmp1, label %land.lhs.true, label %if.end.4

land.lhs.true:                                    ; preds = %if.end
  %call2 = call %struct._object* @PyErr_Occurred()
  %tobool = icmp ne %struct._object* %call2, null
  br i1 %tobool, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 0, i32* %retval
  br label %return

if.end.4:                                         ; preds = %land.lhs.true, %if.end
  %7 = load i64, i64* %priority, align 8
  %cmp5 = icmp sgt i64 %7, 2147483647
  br i1 %cmp5, label %if.then.7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.4
  %8 = load i64, i64* %priority, align 8
  %cmp6 = icmp slt i64 %8, -2147483648
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %lor.lhs.false, %if.end.4
  %9 = load %struct._object*, %struct._object** @PyExc_OverflowError, align 8
  call void @PyErr_SetString(%struct._object* %9, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.246, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.8:                                         ; preds = %lor.lhs.false
  %10 = load i64, i64* %priority, align 8
  %conv = trunc i64 %10 to i32
  %11 = load %struct.sched_param*, %struct.sched_param** %res.addr, align 8
  %__sched_priority = getelementptr inbounds %struct.sched_param, %struct.sched_param* %11, i32 0, i32 0
  store i32 %conv, i32* %__sched_priority, align 4
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.7, %if.then.3, %if.then
  %12 = load i32, i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind
declare i32 @sched_setparam(i32, %struct.sched_param*) #2

; Function Attrs: nounwind
declare i32 @sched_setscheduler(i32, i32, %struct.sched_param*) #2

; Function Attrs: nounwind
declare i32 @sched_yield() #2

declare %struct._object* @PyObject_GetIter(%struct._object*) #1

; Function Attrs: nounwind
declare %struct.cpu_set_t* @__sched_cpualloc(i64) #2

declare %struct._object* @PyIter_Next(%struct._object*) #1

; Function Attrs: nounwind
declare void @__sched_cpufree(%struct.cpu_set_t*) #2

; Function Attrs: nounwind
declare i32 @sched_setaffinity(i32, i64, %struct.cpu_set_t*) #2

; Function Attrs: nounwind
declare i32 @sched_getaffinity(i32, i64, %struct.cpu_set_t*) #2

declare %struct._object* @PySet_New(%struct._object*) #1

; Function Attrs: nounwind
declare i32 @__sched_cpucount(i64, %struct.cpu_set_t*) #2

declare i32 @PySet_Add(%struct._object*, %struct._object*) #1

; Function Attrs: nounwind
declare i32 @openpty(i32*, i32*, i8*, %struct.termios*, %struct.winsize*) #2

declare i32 @_Py_set_inheritable(i32, i32, i32*) #1

declare %struct._object* @_Py_BuildValue_SizeT(i8*, ...) #1

; Function Attrs: nounwind
declare i32 @forkpty(i32*, i8*, %struct.termios*, %struct.winsize*) #2

; Function Attrs: nounwind
declare i32 @getegid() #2

; Function Attrs: nounwind
declare i32 @geteuid() #2

; Function Attrs: nounwind
declare i32 @getgid() #2

declare i32 @getgrouplist(i8*, i32, i32*, i32*) #1

; Function Attrs: nounwind
declare i32 @getgroups(i32, i32*) #2

; Function Attrs: nounwind
declare i32 @getpid() #2

; Function Attrs: nounwind
declare i32 @getpgrp() #2

; Function Attrs: nounwind
declare i32 @getppid() #2

; Function Attrs: nounwind
declare i32 @getuid() #2

declare i8* @getlogin() #1

; Function Attrs: nounwind
declare i32 @kill(i32, i32) #2

; Function Attrs: nounwind
declare i32 @killpg(i32, i32) #2

; Function Attrs: nounwind
declare i32 @setuid(i32) #2

; Function Attrs: nounwind
declare i32 @seteuid(i32) #2

; Function Attrs: nounwind
declare i32 @setegid(i32) #2

; Function Attrs: nounwind
declare i32 @setreuid(i32, i32) #2

; Function Attrs: nounwind
declare i32 @setregid(i32, i32) #2

; Function Attrs: nounwind
declare i32 @setgid(i32) #2

declare i32 @PySequence_Check(%struct._object*) #1

declare %struct._object* @PySequence_GetItem(%struct._object*, i64) #1

; Function Attrs: nounwind
declare i32 @setgroups(i64, i32*) #2

declare i32 @initgroups(i8*, i32) #1

; Function Attrs: nounwind
declare i32 @getpgid(i32) #2

; Function Attrs: nounwind
declare i32 @setpgrp() #2

declare i32 @wait(%union.wait*) #1

; Function Attrs: nounwind
declare i32 @wait3(%union.wait*, i32, %struct.rusage*) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @wait_helper(i32 %pid, i32 %status, %struct.rusage* %ru) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %pid.addr = alloca i32, align 4
  %status.addr = alloca i32, align 4
  %ru.addr = alloca %struct.rusage*, align 8
  %result = alloca %struct._object*, align 8
  %m = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp77 = alloca %struct._object*, align 8
  store i32 %pid, i32* %pid.addr, align 4
  store i32 %status, i32* %status.addr, align 4
  store %struct.rusage* %ru, %struct.rusage** %ru.addr, align 8
  %0 = load i32, i32* %pid.addr, align 4
  %cmp = icmp eq i32 %0, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct._object* @posix_error()
  store %struct._object* %call, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct._object*, %struct._object** @wait_helper.struct_rusage, align 8
  %cmp1 = icmp eq %struct._object* %1, null
  br i1 %cmp1, label %if.then.2, label %if.end.14

if.then.2:                                        ; preds = %if.end
  %call3 = call %struct._object* @PyImport_ImportModuleNoBlock(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.274, i32 0, i32 0))
  store %struct._object* %call3, %struct._object** %m, align 8
  %2 = load %struct._object*, %struct._object** %m, align 8
  %cmp4 = icmp eq %struct._object* %2, null
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.then.2
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.then.2
  %3 = load %struct._object*, %struct._object** %m, align 8
  %call7 = call %struct._object* @_PyObject_GetAttrId(%struct._object* %3, %struct._Py_Identifier* @wait_helper.PyId_struct_rusage)
  store %struct._object* %call7, %struct._object** @wait_helper.struct_rusage, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.6
  %4 = load %struct._object*, %struct._object** %m, align 8
  store %struct._object* %4, %struct._object** %_py_decref_tmp, align 8
  %5 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %5, i32 0, i32 0
  %6 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %6, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp8 = icmp ne i64 %dec, 0
  br i1 %cmp8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %do.body
  br label %if.end.10

if.else:                                          ; preds = %do.body
  %7 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %7, i32 0, i32 1
  %8 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %8, i32 0, i32 4
  %9 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %10 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %9(%struct._object* %10)
  br label %if.end.10

if.end.10:                                        ; preds = %if.else, %if.then.9
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %11 = load %struct._object*, %struct._object** @wait_helper.struct_rusage, align 8
  %cmp11 = icmp eq %struct._object* %11, null
  br i1 %cmp11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %do.end
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.13:                                        ; preds = %do.end
  br label %if.end.14

if.end.14:                                        ; preds = %if.end.13, %if.end
  %12 = load %struct._object*, %struct._object** @wait_helper.struct_rusage, align 8
  %13 = bitcast %struct._object* %12 to %struct._typeobject*
  %call15 = call %struct._object* @PyStructSequence_New(%struct._typeobject* %13)
  store %struct._object* %call15, %struct._object** %result, align 8
  %14 = load %struct._object*, %struct._object** %result, align 8
  %tobool = icmp ne %struct._object* %14, null
  br i1 %tobool, label %if.end.17, label %if.then.16

if.then.16:                                       ; preds = %if.end.14
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.17:                                        ; preds = %if.end.14
  %15 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %ru_utime = getelementptr inbounds %struct.rusage, %struct.rusage* %15, i32 0, i32 0
  %tv_sec = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_utime, i32 0, i32 0
  %16 = load i64, i64* %tv_sec, align 8
  %conv = sitofp i64 %16 to double
  %17 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %ru_utime18 = getelementptr inbounds %struct.rusage, %struct.rusage* %17, i32 0, i32 0
  %tv_usec = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_utime18, i32 0, i32 1
  %18 = load i64, i64* %tv_usec, align 8
  %conv19 = sitofp i64 %18 to double
  %mul = fmul double %conv19, 1.000000e-06
  %add = fadd double %conv, %mul
  %call20 = call %struct._object* @PyFloat_FromDouble(double %add)
  %19 = load %struct._object*, %struct._object** %result, align 8
  %20 = bitcast %struct._object* %19 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %20, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %call20, %struct._object** %arrayidx, align 8
  %21 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, %struct.rusage* %21, i32 0, i32 1
  %tv_sec21 = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_stime, i32 0, i32 0
  %22 = load i64, i64* %tv_sec21, align 8
  %conv22 = sitofp i64 %22 to double
  %23 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %ru_stime23 = getelementptr inbounds %struct.rusage, %struct.rusage* %23, i32 0, i32 1
  %tv_usec24 = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_stime23, i32 0, i32 1
  %24 = load i64, i64* %tv_usec24, align 8
  %conv25 = sitofp i64 %24 to double
  %mul26 = fmul double %conv25, 1.000000e-06
  %add27 = fadd double %conv22, %mul26
  %call28 = call %struct._object* @PyFloat_FromDouble(double %add27)
  %25 = load %struct._object*, %struct._object** %result, align 8
  %26 = bitcast %struct._object* %25 to %struct.PyTupleObject*
  %ob_item29 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %26, i32 0, i32 1
  %arrayidx30 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item29, i32 0, i64 1
  store %struct._object* %call28, %struct._object** %arrayidx30, align 8
  %27 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %28 = getelementptr inbounds %struct.rusage, %struct.rusage* %27, i32 0, i32 2
  %ru_maxrss = bitcast %union.anon* %28 to i64*
  %29 = load i64, i64* %ru_maxrss, align 8
  %call31 = call %struct._object* @PyLong_FromLong(i64 %29)
  %30 = load %struct._object*, %struct._object** %result, align 8
  %31 = bitcast %struct._object* %30 to %struct.PyTupleObject*
  %ob_item32 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %31, i32 0, i32 1
  %arrayidx33 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item32, i32 0, i64 2
  store %struct._object* %call31, %struct._object** %arrayidx33, align 8
  %32 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %33 = getelementptr inbounds %struct.rusage, %struct.rusage* %32, i32 0, i32 3
  %ru_ixrss = bitcast %union.anon.1* %33 to i64*
  %34 = load i64, i64* %ru_ixrss, align 8
  %call34 = call %struct._object* @PyLong_FromLong(i64 %34)
  %35 = load %struct._object*, %struct._object** %result, align 8
  %36 = bitcast %struct._object* %35 to %struct.PyTupleObject*
  %ob_item35 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %36, i32 0, i32 1
  %arrayidx36 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item35, i32 0, i64 3
  store %struct._object* %call34, %struct._object** %arrayidx36, align 8
  %37 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %38 = getelementptr inbounds %struct.rusage, %struct.rusage* %37, i32 0, i32 4
  %ru_idrss = bitcast %union.anon.2* %38 to i64*
  %39 = load i64, i64* %ru_idrss, align 8
  %call37 = call %struct._object* @PyLong_FromLong(i64 %39)
  %40 = load %struct._object*, %struct._object** %result, align 8
  %41 = bitcast %struct._object* %40 to %struct.PyTupleObject*
  %ob_item38 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %41, i32 0, i32 1
  %arrayidx39 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item38, i32 0, i64 4
  store %struct._object* %call37, %struct._object** %arrayidx39, align 8
  %42 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %43 = getelementptr inbounds %struct.rusage, %struct.rusage* %42, i32 0, i32 5
  %ru_isrss = bitcast %union.anon.3* %43 to i64*
  %44 = load i64, i64* %ru_isrss, align 8
  %call40 = call %struct._object* @PyLong_FromLong(i64 %44)
  %45 = load %struct._object*, %struct._object** %result, align 8
  %46 = bitcast %struct._object* %45 to %struct.PyTupleObject*
  %ob_item41 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %46, i32 0, i32 1
  %arrayidx42 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item41, i32 0, i64 5
  store %struct._object* %call40, %struct._object** %arrayidx42, align 8
  %47 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %48 = getelementptr inbounds %struct.rusage, %struct.rusage* %47, i32 0, i32 6
  %ru_minflt = bitcast %union.anon.4* %48 to i64*
  %49 = load i64, i64* %ru_minflt, align 8
  %call43 = call %struct._object* @PyLong_FromLong(i64 %49)
  %50 = load %struct._object*, %struct._object** %result, align 8
  %51 = bitcast %struct._object* %50 to %struct.PyTupleObject*
  %ob_item44 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %51, i32 0, i32 1
  %arrayidx45 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item44, i32 0, i64 6
  store %struct._object* %call43, %struct._object** %arrayidx45, align 8
  %52 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %53 = getelementptr inbounds %struct.rusage, %struct.rusage* %52, i32 0, i32 7
  %ru_majflt = bitcast %union.anon.5* %53 to i64*
  %54 = load i64, i64* %ru_majflt, align 8
  %call46 = call %struct._object* @PyLong_FromLong(i64 %54)
  %55 = load %struct._object*, %struct._object** %result, align 8
  %56 = bitcast %struct._object* %55 to %struct.PyTupleObject*
  %ob_item47 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %56, i32 0, i32 1
  %arrayidx48 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item47, i32 0, i64 7
  store %struct._object* %call46, %struct._object** %arrayidx48, align 8
  %57 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %58 = getelementptr inbounds %struct.rusage, %struct.rusage* %57, i32 0, i32 8
  %ru_nswap = bitcast %union.anon.6* %58 to i64*
  %59 = load i64, i64* %ru_nswap, align 8
  %call49 = call %struct._object* @PyLong_FromLong(i64 %59)
  %60 = load %struct._object*, %struct._object** %result, align 8
  %61 = bitcast %struct._object* %60 to %struct.PyTupleObject*
  %ob_item50 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %61, i32 0, i32 1
  %arrayidx51 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item50, i32 0, i64 8
  store %struct._object* %call49, %struct._object** %arrayidx51, align 8
  %62 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %63 = getelementptr inbounds %struct.rusage, %struct.rusage* %62, i32 0, i32 9
  %ru_inblock = bitcast %union.anon.7* %63 to i64*
  %64 = load i64, i64* %ru_inblock, align 8
  %call52 = call %struct._object* @PyLong_FromLong(i64 %64)
  %65 = load %struct._object*, %struct._object** %result, align 8
  %66 = bitcast %struct._object* %65 to %struct.PyTupleObject*
  %ob_item53 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %66, i32 0, i32 1
  %arrayidx54 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item53, i32 0, i64 9
  store %struct._object* %call52, %struct._object** %arrayidx54, align 8
  %67 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %68 = getelementptr inbounds %struct.rusage, %struct.rusage* %67, i32 0, i32 10
  %ru_oublock = bitcast %union.anon.8* %68 to i64*
  %69 = load i64, i64* %ru_oublock, align 8
  %call55 = call %struct._object* @PyLong_FromLong(i64 %69)
  %70 = load %struct._object*, %struct._object** %result, align 8
  %71 = bitcast %struct._object* %70 to %struct.PyTupleObject*
  %ob_item56 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %71, i32 0, i32 1
  %arrayidx57 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item56, i32 0, i64 10
  store %struct._object* %call55, %struct._object** %arrayidx57, align 8
  %72 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %73 = getelementptr inbounds %struct.rusage, %struct.rusage* %72, i32 0, i32 11
  %ru_msgsnd = bitcast %union.anon.9* %73 to i64*
  %74 = load i64, i64* %ru_msgsnd, align 8
  %call58 = call %struct._object* @PyLong_FromLong(i64 %74)
  %75 = load %struct._object*, %struct._object** %result, align 8
  %76 = bitcast %struct._object* %75 to %struct.PyTupleObject*
  %ob_item59 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %76, i32 0, i32 1
  %arrayidx60 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item59, i32 0, i64 11
  store %struct._object* %call58, %struct._object** %arrayidx60, align 8
  %77 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %78 = getelementptr inbounds %struct.rusage, %struct.rusage* %77, i32 0, i32 12
  %ru_msgrcv = bitcast %union.anon.10* %78 to i64*
  %79 = load i64, i64* %ru_msgrcv, align 8
  %call61 = call %struct._object* @PyLong_FromLong(i64 %79)
  %80 = load %struct._object*, %struct._object** %result, align 8
  %81 = bitcast %struct._object* %80 to %struct.PyTupleObject*
  %ob_item62 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %81, i32 0, i32 1
  %arrayidx63 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item62, i32 0, i64 12
  store %struct._object* %call61, %struct._object** %arrayidx63, align 8
  %82 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %83 = getelementptr inbounds %struct.rusage, %struct.rusage* %82, i32 0, i32 13
  %ru_nsignals = bitcast %union.anon.11* %83 to i64*
  %84 = load i64, i64* %ru_nsignals, align 8
  %call64 = call %struct._object* @PyLong_FromLong(i64 %84)
  %85 = load %struct._object*, %struct._object** %result, align 8
  %86 = bitcast %struct._object* %85 to %struct.PyTupleObject*
  %ob_item65 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %86, i32 0, i32 1
  %arrayidx66 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item65, i32 0, i64 13
  store %struct._object* %call64, %struct._object** %arrayidx66, align 8
  %87 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %88 = getelementptr inbounds %struct.rusage, %struct.rusage* %87, i32 0, i32 14
  %ru_nvcsw = bitcast %union.anon.12* %88 to i64*
  %89 = load i64, i64* %ru_nvcsw, align 8
  %call67 = call %struct._object* @PyLong_FromLong(i64 %89)
  %90 = load %struct._object*, %struct._object** %result, align 8
  %91 = bitcast %struct._object* %90 to %struct.PyTupleObject*
  %ob_item68 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %91, i32 0, i32 1
  %arrayidx69 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item68, i32 0, i64 14
  store %struct._object* %call67, %struct._object** %arrayidx69, align 8
  %92 = load %struct.rusage*, %struct.rusage** %ru.addr, align 8
  %93 = getelementptr inbounds %struct.rusage, %struct.rusage* %92, i32 0, i32 15
  %ru_nivcsw = bitcast %union.anon.13* %93 to i64*
  %94 = load i64, i64* %ru_nivcsw, align 8
  %call70 = call %struct._object* @PyLong_FromLong(i64 %94)
  %95 = load %struct._object*, %struct._object** %result, align 8
  %96 = bitcast %struct._object* %95 to %struct.PyTupleObject*
  %ob_item71 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %96, i32 0, i32 1
  %arrayidx72 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item71, i32 0, i64 15
  store %struct._object* %call70, %struct._object** %arrayidx72, align 8
  %call73 = call %struct._object* @PyErr_Occurred()
  %tobool74 = icmp ne %struct._object* %call73, null
  br i1 %tobool74, label %if.then.75, label %if.end.88

if.then.75:                                       ; preds = %if.end.17
  br label %do.body.76

do.body.76:                                       ; preds = %if.then.75
  %97 = load %struct._object*, %struct._object** %result, align 8
  store %struct._object* %97, %struct._object** %_py_decref_tmp77, align 8
  %98 = load %struct._object*, %struct._object** %_py_decref_tmp77, align 8
  %ob_refcnt78 = getelementptr inbounds %struct._object, %struct._object* %98, i32 0, i32 0
  %99 = load i64, i64* %ob_refcnt78, align 8
  %dec79 = add i64 %99, -1
  store i64 %dec79, i64* %ob_refcnt78, align 8
  %cmp80 = icmp ne i64 %dec79, 0
  br i1 %cmp80, label %if.then.82, label %if.else.83

if.then.82:                                       ; preds = %do.body.76
  br label %if.end.86

if.else.83:                                       ; preds = %do.body.76
  %100 = load %struct._object*, %struct._object** %_py_decref_tmp77, align 8
  %ob_type84 = getelementptr inbounds %struct._object, %struct._object* %100, i32 0, i32 1
  %101 = load %struct._typeobject*, %struct._typeobject** %ob_type84, align 8
  %tp_dealloc85 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %101, i32 0, i32 4
  %102 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc85, align 8
  %103 = load %struct._object*, %struct._object** %_py_decref_tmp77, align 8
  call void %102(%struct._object* %103)
  br label %if.end.86

if.end.86:                                        ; preds = %if.else.83, %if.then.82
  br label %do.end.87

do.end.87:                                        ; preds = %if.end.86
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.88:                                        ; preds = %if.end.17
  %104 = load i32, i32* %pid.addr, align 4
  %conv89 = sext i32 %104 to i64
  %call90 = call %struct._object* @PyLong_FromLong(i64 %conv89)
  %105 = load i32, i32* %status.addr, align 4
  %106 = load %struct._object*, %struct._object** %result, align 8
  %call91 = call %struct._object* (i8*, ...) @_Py_BuildValue_SizeT(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.275, i32 0, i32 0), %struct._object* %call90, i32 %105, %struct._object* %106)
  store %struct._object* %call91, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.88, %do.end.87, %if.then.16, %if.then.12, %if.then.5, %if.then
  %107 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %107
}

declare %struct._object* @PyImport_ImportModuleNoBlock(i8*) #1

declare %struct._object* @_PyObject_GetAttrId(%struct._object*, %struct._Py_Identifier*) #1

; Function Attrs: nounwind
declare i32 @wait4(i32, %union.wait*, i32, %struct.rusage*) #2

declare i32 @waitid(i32, i32, %struct.siginfo_t*, i32) #1

declare i32 @waitpid(i32, i32*, i32) #1

; Function Attrs: nounwind
declare i32 @getsid(i32) #2

; Function Attrs: nounwind
declare i32 @setsid() #2

; Function Attrs: nounwind
declare i32 @setpgid(i32, i32) #2

; Function Attrs: nounwind
declare i32 @tcgetpgrp(i32) #2

; Function Attrs: nounwind
declare i32 @tcsetpgrp(i32, i32) #2

declare i32 @openat64(i32, i8*, i32, ...) #1

declare i32 @open64(i8*, i32, ...) #1

declare %struct._object* @_Py_device_encoding(i32) #1

; Function Attrs: nounwind
declare i32 @dup3(i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @dup2(i32, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @_parse_off_t(%struct._object* %arg, i8* %addr) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca %struct._object*, align 8
  %addr.addr = alloca i8*, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %call = call i64 @PyLong_AsLong(%struct._object* %0)
  %1 = load i8*, i8** %addr.addr, align 8
  %2 = bitcast i8* %1 to i64*
  store i64 %call, i64* %2, align 8
  %call1 = call %struct._object* @PyErr_Occurred()
  %tobool = icmp ne %struct._object* %call1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load i32, i32* %retval
  ret i32 %3
}

declare i32 @lockf64(i32, i32, i64) #1

; Function Attrs: nounwind
declare i64 @lseek64(i32, i64, i32) #2

declare i64 @read(i32, i8*, i64) #1

declare i32 @_PyBytes_Resize(%struct._object**, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @iov_setup(%struct.iovec** %iov, %struct.bufferinfo** %buf, %struct._object* %seq, i32 %cnt, i32 %type) #0 {
entry:
  %retval = alloca i64, align 8
  %iov.addr = alloca %struct.iovec**, align 8
  %buf.addr = alloca %struct.bufferinfo**, align 8
  %seq.addr = alloca %struct._object*, align 8
  %cnt.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %blen = alloca i64, align 8
  %total = alloca i64, align 8
  %item = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp39 = alloca %struct._object*, align 8
  store %struct.iovec** %iov, %struct.iovec*** %iov.addr, align 8
  store %struct.bufferinfo** %buf, %struct.bufferinfo*** %buf.addr, align 8
  store %struct._object* %seq, %struct._object** %seq.addr, align 8
  store i32 %cnt, i32* %cnt.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  store i64 0, i64* %total, align 8
  %0 = load i32, i32* %cnt.addr, align 4
  %conv = sext i32 %0 to i64
  %cmp = icmp ugt i64 %conv, 576460752303423487
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i32, i32* %cnt.addr, align 4
  %conv2 = sext i32 %1 to i64
  %mul = mul i64 %conv2, 16
  %call = call i8* @PyMem_Malloc(i64 %mul)
  %2 = bitcast i8* %call to %struct.iovec*
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.iovec* [ null, %cond.true ], [ %2, %cond.false ]
  %3 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  store %struct.iovec* %cond, %struct.iovec** %3, align 8
  %4 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  %5 = load %struct.iovec*, %struct.iovec** %4, align 8
  %cmp3 = icmp eq %struct.iovec* %5, null
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call5 = call %struct._object* @PyErr_NoMemory()
  store i64 -1, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %6 = load i32, i32* %cnt.addr, align 4
  %conv6 = sext i32 %6 to i64
  %cmp7 = icmp ugt i64 %conv6, 115292150460684697
  br i1 %cmp7, label %cond.true.9, label %cond.false.10

cond.true.9:                                      ; preds = %if.end
  br label %cond.end.14

cond.false.10:                                    ; preds = %if.end
  %7 = load i32, i32* %cnt.addr, align 4
  %conv11 = sext i32 %7 to i64
  %mul12 = mul i64 %conv11, 80
  %call13 = call i8* @PyMem_Malloc(i64 %mul12)
  %8 = bitcast i8* %call13 to %struct.bufferinfo*
  br label %cond.end.14

cond.end.14:                                      ; preds = %cond.false.10, %cond.true.9
  %cond15 = phi %struct.bufferinfo* [ null, %cond.true.9 ], [ %8, %cond.false.10 ]
  %9 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  store %struct.bufferinfo* %cond15, %struct.bufferinfo** %9, align 8
  %10 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %11 = load %struct.bufferinfo*, %struct.bufferinfo** %10, align 8
  %cmp16 = icmp eq %struct.bufferinfo* %11, null
  br i1 %cmp16, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %cond.end.14
  %12 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  %13 = load %struct.iovec*, %struct.iovec** %12, align 8
  %14 = bitcast %struct.iovec* %13 to i8*
  call void @PyMem_Free(i8* %14)
  %call19 = call %struct._object* @PyErr_NoMemory()
  store i64 -1, i64* %retval
  br label %return

if.end.20:                                        ; preds = %cond.end.14
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.20
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %cnt.addr, align 4
  %cmp21 = icmp slt i32 %15, %16
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load %struct._object*, %struct._object** %seq.addr, align 8
  %18 = load i32, i32* %i, align 4
  %conv23 = sext i32 %18 to i64
  %call24 = call %struct._object* @PySequence_GetItem(%struct._object* %17, i64 %conv23)
  store %struct._object* %call24, %struct._object** %item, align 8
  %19 = load %struct._object*, %struct._object** %item, align 8
  %cmp25 = icmp eq %struct._object* %19, null
  br i1 %cmp25, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %for.body
  br label %fail

if.end.28:                                        ; preds = %for.body
  %20 = load %struct._object*, %struct._object** %item, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom = sext i32 %21 to i64
  %22 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %23 = load %struct.bufferinfo*, %struct.bufferinfo** %22, align 8
  %arrayidx = getelementptr %struct.bufferinfo, %struct.bufferinfo* %23, i64 %idxprom
  %24 = load i32, i32* %type.addr, align 4
  %call29 = call i32 @PyObject_GetBuffer(%struct._object* %20, %struct.bufferinfo* %arrayidx, i32 %24)
  %cmp30 = icmp eq i32 %call29, -1
  br i1 %cmp30, label %if.then.32, label %if.end.37

if.then.32:                                       ; preds = %if.end.28
  br label %do.body

do.body:                                          ; preds = %if.then.32
  %25 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %25, %struct._object** %_py_decref_tmp, align 8
  %26 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %26, i32 0, i32 0
  %27 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %27, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp33 = icmp ne i64 %dec, 0
  br i1 %cmp33, label %if.then.35, label %if.else

if.then.35:                                       ; preds = %do.body
  br label %if.end.36

if.else:                                          ; preds = %do.body
  %28 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %28, i32 0, i32 1
  %29 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %29, i32 0, i32 4
  %30 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %31 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %30(%struct._object* %31)
  br label %if.end.36

if.end.36:                                        ; preds = %if.else, %if.then.35
  br label %do.end

do.end:                                           ; preds = %if.end.36
  br label %fail

if.end.37:                                        ; preds = %if.end.28
  br label %do.body.38

do.body.38:                                       ; preds = %if.end.37
  %32 = load %struct._object*, %struct._object** %item, align 8
  store %struct._object* %32, %struct._object** %_py_decref_tmp39, align 8
  %33 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  %ob_refcnt40 = getelementptr inbounds %struct._object, %struct._object* %33, i32 0, i32 0
  %34 = load i64, i64* %ob_refcnt40, align 8
  %dec41 = add i64 %34, -1
  store i64 %dec41, i64* %ob_refcnt40, align 8
  %cmp42 = icmp ne i64 %dec41, 0
  br i1 %cmp42, label %if.then.44, label %if.else.45

if.then.44:                                       ; preds = %do.body.38
  br label %if.end.48

if.else.45:                                       ; preds = %do.body.38
  %35 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  %ob_type46 = getelementptr inbounds %struct._object, %struct._object* %35, i32 0, i32 1
  %36 = load %struct._typeobject*, %struct._typeobject** %ob_type46, align 8
  %tp_dealloc47 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %36, i32 0, i32 4
  %37 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc47, align 8
  %38 = load %struct._object*, %struct._object** %_py_decref_tmp39, align 8
  call void %37(%struct._object* %38)
  br label %if.end.48

if.end.48:                                        ; preds = %if.else.45, %if.then.44
  br label %do.end.49

do.end.49:                                        ; preds = %if.end.48
  %39 = load i32, i32* %i, align 4
  %idxprom50 = sext i32 %39 to i64
  %40 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %41 = load %struct.bufferinfo*, %struct.bufferinfo** %40, align 8
  %arrayidx51 = getelementptr %struct.bufferinfo, %struct.bufferinfo* %41, i64 %idxprom50
  %buf52 = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %arrayidx51, i32 0, i32 0
  %42 = load i8*, i8** %buf52, align 8
  %43 = load i32, i32* %i, align 4
  %idxprom53 = sext i32 %43 to i64
  %44 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  %45 = load %struct.iovec*, %struct.iovec** %44, align 8
  %arrayidx54 = getelementptr %struct.iovec, %struct.iovec* %45, i64 %idxprom53
  %iov_base = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx54, i32 0, i32 0
  store i8* %42, i8** %iov_base, align 8
  %46 = load i32, i32* %i, align 4
  %idxprom55 = sext i32 %46 to i64
  %47 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %48 = load %struct.bufferinfo*, %struct.bufferinfo** %47, align 8
  %arrayidx56 = getelementptr %struct.bufferinfo, %struct.bufferinfo* %48, i64 %idxprom55
  %len = getelementptr inbounds %struct.bufferinfo, %struct.bufferinfo* %arrayidx56, i32 0, i32 2
  %49 = load i64, i64* %len, align 8
  store i64 %49, i64* %blen, align 8
  %50 = load i64, i64* %blen, align 8
  %51 = load i32, i32* %i, align 4
  %idxprom57 = sext i32 %51 to i64
  %52 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  %53 = load %struct.iovec*, %struct.iovec** %52, align 8
  %arrayidx58 = getelementptr %struct.iovec, %struct.iovec* %53, i64 %idxprom57
  %iov_len = getelementptr inbounds %struct.iovec, %struct.iovec* %arrayidx58, i32 0, i32 1
  store i64 %50, i64* %iov_len, align 8
  %54 = load i64, i64* %blen, align 8
  %55 = load i64, i64* %total, align 8
  %add = add i64 %55, %54
  store i64 %add, i64* %total, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.end.49
  %56 = load i32, i32* %i, align 4
  %inc = add i32 %56, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %57 = load i64, i64* %total, align 8
  store i64 %57, i64* %retval
  br label %return

fail:                                             ; preds = %do.end, %if.then.27
  %58 = load %struct.iovec**, %struct.iovec*** %iov.addr, align 8
  %59 = load %struct.iovec*, %struct.iovec** %58, align 8
  %60 = bitcast %struct.iovec* %59 to i8*
  call void @PyMem_Free(i8* %60)
  store i32 0, i32* %j, align 4
  br label %for.cond.59

for.cond.59:                                      ; preds = %for.inc.65, %fail
  %61 = load i32, i32* %j, align 4
  %62 = load i32, i32* %i, align 4
  %cmp60 = icmp slt i32 %61, %62
  br i1 %cmp60, label %for.body.62, label %for.end.67

for.body.62:                                      ; preds = %for.cond.59
  %63 = load i32, i32* %j, align 4
  %idxprom63 = sext i32 %63 to i64
  %64 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %65 = load %struct.bufferinfo*, %struct.bufferinfo** %64, align 8
  %arrayidx64 = getelementptr %struct.bufferinfo, %struct.bufferinfo* %65, i64 %idxprom63
  call void @PyBuffer_Release(%struct.bufferinfo* %arrayidx64)
  br label %for.inc.65

for.inc.65:                                       ; preds = %for.body.62
  %66 = load i32, i32* %j, align 4
  %inc66 = add i32 %66, 1
  store i32 %inc66, i32* %j, align 4
  br label %for.cond.59

for.end.67:                                       ; preds = %for.cond.59
  %67 = load %struct.bufferinfo**, %struct.bufferinfo*** %buf.addr, align 8
  %68 = load %struct.bufferinfo*, %struct.bufferinfo** %67, align 8
  %69 = bitcast %struct.bufferinfo* %68 to i8*
  call void @PyMem_Free(i8* %69)
  store i64 -1, i64* %retval
  br label %return

return:                                           ; preds = %for.end.67, %for.end, %if.then.18, %if.then
  %70 = load i64, i64* %retval
  ret i64 %70
}

declare i64 @readv(i32, %struct.iovec*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @iov_cleanup(%struct.iovec* %iov, %struct.bufferinfo* %buf, i32 %cnt) #0 {
entry:
  %iov.addr = alloca %struct.iovec*, align 8
  %buf.addr = alloca %struct.bufferinfo*, align 8
  %cnt.addr = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.iovec* %iov, %struct.iovec** %iov.addr, align 8
  store %struct.bufferinfo* %buf, %struct.bufferinfo** %buf.addr, align 8
  store i32 %cnt, i32* %cnt.addr, align 4
  %0 = load %struct.iovec*, %struct.iovec** %iov.addr, align 8
  %1 = bitcast %struct.iovec* %0 to i8*
  call void @PyMem_Free(i8* %1)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* %cnt.addr, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.bufferinfo*, %struct.bufferinfo** %buf.addr, align 8
  %arrayidx = getelementptr %struct.bufferinfo, %struct.bufferinfo* %5, i64 %idxprom
  call void @PyBuffer_Release(%struct.bufferinfo* %arrayidx)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load %struct.bufferinfo*, %struct.bufferinfo** %buf.addr, align 8
  %8 = bitcast %struct.bufferinfo* %7 to i8*
  call void @PyMem_Free(i8* %8)
  ret void
}

declare %struct._object* @PyLong_FromSsize_t(i64) #1

declare i32 @PyObject_GetBuffer(%struct._object*, %struct.bufferinfo*, i32) #1

declare void @PyBuffer_Release(%struct.bufferinfo*) #1

declare i64 @pread64(i32, i8*, i64, i64) #1

declare i64 @write(i32, i8*, i64) #1

declare i64 @writev(i32, %struct.iovec*, i32) #1

declare i64 @pwrite64(i32, i8*, i64, i64) #1

; Function Attrs: nounwind
declare i64 @sendfile64(i32, i32, i64*, i64) #2

; Function Attrs: nounwind
declare i32 @isatty(i32) #2

; Function Attrs: nounwind
declare i32 @pipe2(i32*, i32) #2

; Function Attrs: nounwind
declare i32 @pipe(i32*) #2

declare i32 @_PyLong_AsInt(%struct._object*) #1

; Function Attrs: nounwind
declare i32 @mkfifoat(i32, i8*, i32) #2

; Function Attrs: nounwind
declare i32 @mkfifo(i8*, i32) #2

; Function Attrs: nounwind
declare i32 @mknodat(i32, i8*, i32, i64) #2

; Function Attrs: nounwind
declare i32 @mknod(i8*, i32, i64) #2

; Function Attrs: nounwind readnone
declare i32 @gnu_dev_major(i64) #5

; Function Attrs: nounwind readnone
declare i32 @gnu_dev_minor(i64) #5

; Function Attrs: nounwind readnone
declare i64 @gnu_dev_makedev(i32, i32) #5

; Function Attrs: nounwind
declare i32 @ftruncate64(i32, i64) #2

; Function Attrs: nounwind
declare i32 @truncate64(i8*, i64) #2

declare i32 @posix_fallocate64(i32, i64, i64) #1

; Function Attrs: nounwind
declare i32 @posix_fadvise64(i32, i64, i64, i32) #2

declare %struct._object* @PyBytes_FromFormat(i8*, ...) #1

; Function Attrs: nounwind
declare i32 @putenv(i8*) #2

declare i32 @PyDict_SetItem(%struct._object*, %struct._object*, %struct._object*) #1

; Function Attrs: nounwind
declare i32 @unsetenv(i8*) #2

declare i32 @PyDict_DelItem(%struct._object*, %struct._object*) #1

; Function Attrs: nounwind
declare i8* @strerror(i32) #2

declare %struct._object* @PyUnicode_DecodeLocale(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define internal %struct._object* @posix_fildes(%struct._object* %fdobj, i32 (i32)* %func) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %fdobj.addr = alloca %struct._object*, align 8
  %func.addr = alloca i32 (i32)*, align 8
  %fd = alloca i32, align 4
  %res = alloca i32, align 4
  %_save = alloca %struct._ts*, align 8
  store %struct._object* %fdobj, %struct._object** %fdobj.addr, align 8
  store i32 (i32)* %func, i32 (i32)** %func.addr, align 8
  %0 = load %struct._object*, %struct._object** %fdobj.addr, align 8
  %call = call i32 @PyObject_AsFileDescriptor(%struct._object* %0)
  store i32 %call, i32* %fd, align 4
  %1 = load i32, i32* %fd, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call %struct._ts* @PyEval_SaveThread()
  store %struct._ts* %call1, %struct._ts** %_save, align 8
  %2 = load i32 (i32)*, i32 (i32)** %func.addr, align 8
  %3 = load i32, i32* %fd, align 4
  %call2 = call i32 %2(i32 %3)
  store i32 %call2, i32* %res, align 4
  %4 = load %struct._ts*, %struct._ts** %_save, align 8
  call void @PyEval_RestoreThread(%struct._ts* %4)
  %5 = load i32, i32* %res, align 4
  %cmp3 = icmp slt i32 %5, 0
  br i1 %cmp3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %call5 = call %struct._object* @posix_error()
  store %struct._object* %call5, %struct._object** %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %6 = load i64, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  %inc = add i64 %6, 1
  store i64 %inc, i64* getelementptr inbounds (%struct._object, %struct._object* @_Py_NoneStruct, i32 0, i32 0), align 8
  store %struct._object* @_Py_NoneStruct, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.4, %if.then
  %7 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %7
}

declare i32 @PyObject_AsFileDescriptor(%struct._object*) #1

declare i32 @fsync(i32) #1

; Function Attrs: nounwind
declare void @sync() #2

declare i32 @fdatasync(i32) #1

; Function Attrs: nounwind
declare i32 @fstatvfs64(i32, %struct.statvfs*) #2

; Function Attrs: nounwind uwtable
define internal %struct._object* @_pystatvfs_fromstructstatvfs(%struct.statvfs* byval align 8 %st) #0 {
entry:
  %retval = alloca %struct._object*, align 8
  %v = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %call = call %struct._object* @PyStructSequence_New(%struct._typeobject* @StatVFSResultType)
  store %struct._object* %call, %struct._object** %v, align 8
  %0 = load %struct._object*, %struct._object** %v, align 8
  %cmp = icmp eq %struct._object* %0, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end:                                           ; preds = %entry
  %f_bsize = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 0
  %1 = load i64, i64* %f_bsize, align 8
  %call1 = call %struct._object* @PyLong_FromLong(i64 %1)
  %2 = load %struct._object*, %struct._object** %v, align 8
  %3 = bitcast %struct._object* %2 to %struct.PyTupleObject*
  %ob_item = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %3, i32 0, i32 1
  %arrayidx = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item, i32 0, i64 0
  store %struct._object* %call1, %struct._object** %arrayidx, align 8
  %f_frsize = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 1
  %4 = load i64, i64* %f_frsize, align 8
  %call2 = call %struct._object* @PyLong_FromLong(i64 %4)
  %5 = load %struct._object*, %struct._object** %v, align 8
  %6 = bitcast %struct._object* %5 to %struct.PyTupleObject*
  %ob_item3 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %6, i32 0, i32 1
  %arrayidx4 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item3, i32 0, i64 1
  store %struct._object* %call2, %struct._object** %arrayidx4, align 8
  %f_blocks = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 2
  %7 = load i64, i64* %f_blocks, align 8
  %call5 = call %struct._object* @PyLong_FromLong(i64 %7)
  %8 = load %struct._object*, %struct._object** %v, align 8
  %9 = bitcast %struct._object* %8 to %struct.PyTupleObject*
  %ob_item6 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %9, i32 0, i32 1
  %arrayidx7 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item6, i32 0, i64 2
  store %struct._object* %call5, %struct._object** %arrayidx7, align 8
  %f_bfree = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 3
  %10 = load i64, i64* %f_bfree, align 8
  %call8 = call %struct._object* @PyLong_FromLong(i64 %10)
  %11 = load %struct._object*, %struct._object** %v, align 8
  %12 = bitcast %struct._object* %11 to %struct.PyTupleObject*
  %ob_item9 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %12, i32 0, i32 1
  %arrayidx10 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item9, i32 0, i64 3
  store %struct._object* %call8, %struct._object** %arrayidx10, align 8
  %f_bavail = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 4
  %13 = load i64, i64* %f_bavail, align 8
  %call11 = call %struct._object* @PyLong_FromLong(i64 %13)
  %14 = load %struct._object*, %struct._object** %v, align 8
  %15 = bitcast %struct._object* %14 to %struct.PyTupleObject*
  %ob_item12 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %15, i32 0, i32 1
  %arrayidx13 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item12, i32 0, i64 4
  store %struct._object* %call11, %struct._object** %arrayidx13, align 8
  %f_files = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 5
  %16 = load i64, i64* %f_files, align 8
  %call14 = call %struct._object* @PyLong_FromLong(i64 %16)
  %17 = load %struct._object*, %struct._object** %v, align 8
  %18 = bitcast %struct._object* %17 to %struct.PyTupleObject*
  %ob_item15 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %18, i32 0, i32 1
  %arrayidx16 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item15, i32 0, i64 5
  store %struct._object* %call14, %struct._object** %arrayidx16, align 8
  %f_ffree = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 6
  %19 = load i64, i64* %f_ffree, align 8
  %call17 = call %struct._object* @PyLong_FromLong(i64 %19)
  %20 = load %struct._object*, %struct._object** %v, align 8
  %21 = bitcast %struct._object* %20 to %struct.PyTupleObject*
  %ob_item18 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %21, i32 0, i32 1
  %arrayidx19 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item18, i32 0, i64 6
  store %struct._object* %call17, %struct._object** %arrayidx19, align 8
  %f_favail = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 7
  %22 = load i64, i64* %f_favail, align 8
  %call20 = call %struct._object* @PyLong_FromLong(i64 %22)
  %23 = load %struct._object*, %struct._object** %v, align 8
  %24 = bitcast %struct._object* %23 to %struct.PyTupleObject*
  %ob_item21 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %24, i32 0, i32 1
  %arrayidx22 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item21, i32 0, i64 7
  store %struct._object* %call20, %struct._object** %arrayidx22, align 8
  %f_flag = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 9
  %25 = load i64, i64* %f_flag, align 8
  %call23 = call %struct._object* @PyLong_FromLong(i64 %25)
  %26 = load %struct._object*, %struct._object** %v, align 8
  %27 = bitcast %struct._object* %26 to %struct.PyTupleObject*
  %ob_item24 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %27, i32 0, i32 1
  %arrayidx25 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item24, i32 0, i64 8
  store %struct._object* %call23, %struct._object** %arrayidx25, align 8
  %f_namemax = getelementptr inbounds %struct.statvfs, %struct.statvfs* %st, i32 0, i32 10
  %28 = load i64, i64* %f_namemax, align 8
  %call26 = call %struct._object* @PyLong_FromLong(i64 %28)
  %29 = load %struct._object*, %struct._object** %v, align 8
  %30 = bitcast %struct._object* %29 to %struct.PyTupleObject*
  %ob_item27 = getelementptr inbounds %struct.PyTupleObject, %struct.PyTupleObject* %30, i32 0, i32 1
  %arrayidx28 = getelementptr [1 x %struct._object*], [1 x %struct._object*]* %ob_item27, i32 0, i64 9
  store %struct._object* %call26, %struct._object** %arrayidx28, align 8
  %call29 = call %struct._object* @PyErr_Occurred()
  %tobool = icmp ne %struct._object* %call29, null
  br i1 %tobool, label %if.then.30, label %if.end.34

if.then.30:                                       ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then.30
  %31 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %31, %struct._object** %_py_decref_tmp, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 0
  %33 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %33, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp31 = icmp ne i64 %dec, 0
  br i1 %cmp31, label %if.then.32, label %if.else

if.then.32:                                       ; preds = %do.body
  br label %if.end.33

if.else:                                          ; preds = %do.body
  %34 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %34, i32 0, i32 1
  %35 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %35, i32 0, i32 4
  %36 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %36(%struct._object* %37)
  br label %if.end.33

if.end.33:                                        ; preds = %if.else, %if.then.32
  br label %do.end

do.end:                                           ; preds = %if.end.33
  store %struct._object* null, %struct._object** %retval
  br label %return

if.end.34:                                        ; preds = %if.end
  %38 = load %struct._object*, %struct._object** %v, align 8
  store %struct._object* %38, %struct._object** %retval
  br label %return

return:                                           ; preds = %if.end.34, %do.end, %if.then
  %39 = load %struct._object*, %struct._object** %retval
  ret %struct._object* %39
}

; Function Attrs: nounwind
declare i32 @statvfs64(i8*, %struct.statvfs*) #2

; Function Attrs: nounwind uwtable
define internal i32 @conv_confstr_confname(%struct._object* %arg, i32* %valuep) #0 {
entry:
  %arg.addr = alloca %struct._object*, align 8
  %valuep.addr = alloca i32*, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  store i32* %valuep, i32** %valuep.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %1 = load i32*, i32** %valuep.addr, align 8
  %call = call i32 @conv_confname(%struct._object* %0, i32* %1, %struct.constdef* getelementptr inbounds ([27 x %struct.constdef], [27 x %struct.constdef]* @posix_constants_confstr, i32 0, i32 0), i64 27)
  ret i32 %call
}

; Function Attrs: nounwind
declare i64 @confstr(i32, i8*, i64) #2

; Function Attrs: nounwind uwtable
define internal i32 @conv_confname(%struct._object* %arg, i32* %valuep, %struct.constdef* %table, i64 %tablesize) #0 {
entry:
  %retval = alloca i32, align 4
  %arg.addr = alloca %struct._object*, align 8
  %valuep.addr = alloca i32*, align 8
  %table.addr = alloca %struct.constdef*, align 8
  %tablesize.addr = alloca i64, align 8
  %lo = alloca i64, align 8
  %mid = alloca i64, align 8
  %hi = alloca i64, align 8
  %cmp1 = alloca i32, align 4
  %confname = alloca i8*, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  store i32* %valuep, i32** %valuep.addr, align 8
  store %struct.constdef* %table, %struct.constdef** %table.addr, align 8
  store i64 %tablesize, i64* %tablesize.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %0, i32 0, i32 1
  %1 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_flags = getelementptr inbounds %struct._typeobject, %struct._typeobject* %1, i32 0, i32 19
  %2 = load i64, i64* %tp_flags, align 8
  %and = and i64 %2, 16777216
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct._object*, %struct._object** %arg.addr, align 8
  %call = call i64 @PyLong_AsLong(%struct._object* %3)
  %conv = trunc i64 %call to i32
  %4 = load i32*, i32** %valuep.addr, align 8
  store i32 %conv, i32* %4, align 4
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  store i64 0, i64* %lo, align 8
  %5 = load i64, i64* %tablesize.addr, align 8
  store i64 %5, i64* %hi, align 8
  %6 = load %struct._object*, %struct._object** %arg.addr, align 8
  %ob_type2 = getelementptr inbounds %struct._object, %struct._object* %6, i32 0, i32 1
  %7 = load %struct._typeobject*, %struct._typeobject** %ob_type2, align 8
  %tp_flags3 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %7, i32 0, i32 19
  %8 = load i64, i64* %tp_flags3, align 8
  %and4 = and i64 %8, 268435456
  %cmp5 = icmp ne i64 %and4, 0
  br i1 %cmp5, label %if.end, label %if.then.7

if.then.7:                                        ; preds = %if.else
  %9 = load %struct._object*, %struct._object** @PyExc_TypeError, align 8
  call void @PyErr_SetString(%struct._object* %9, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.339, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %if.else
  %10 = load %struct._object*, %struct._object** %arg.addr, align 8
  %call8 = call i8* @PyUnicode_AsUTF8(%struct._object* %10)
  store i8* %call8, i8** %confname, align 8
  %11 = load i8*, i8** %confname, align 8
  %cmp9 = icmp eq i8* %11, null
  br i1 %cmp9, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end.12:                                        ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %if.end.28, %if.end.12
  %12 = load i64, i64* %lo, align 8
  %13 = load i64, i64* %hi, align 8
  %cmp13 = icmp ult i64 %12, %13
  br i1 %cmp13, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %14 = load i64, i64* %lo, align 8
  %15 = load i64, i64* %hi, align 8
  %add = add i64 %14, %15
  %div = udiv i64 %add, 2
  store i64 %div, i64* %mid, align 8
  %16 = load i8*, i8** %confname, align 8
  %17 = load i64, i64* %mid, align 8
  %18 = load %struct.constdef*, %struct.constdef** %table.addr, align 8
  %arrayidx = getelementptr %struct.constdef, %struct.constdef* %18, i64 %17
  %name = getelementptr inbounds %struct.constdef, %struct.constdef* %arrayidx, i32 0, i32 0
  %19 = load i8*, i8** %name, align 8
  %call15 = call i32 @strcmp(i8* %16, i8* %19) #8
  store i32 %call15, i32* %cmp1, align 4
  %20 = load i32, i32* %cmp1, align 4
  %cmp16 = icmp slt i32 %20, 0
  br i1 %cmp16, label %if.then.18, label %if.else.19

if.then.18:                                       ; preds = %while.body
  %21 = load i64, i64* %mid, align 8
  store i64 %21, i64* %hi, align 8
  br label %if.end.28

if.else.19:                                       ; preds = %while.body
  %22 = load i32, i32* %cmp1, align 4
  %cmp20 = icmp sgt i32 %22, 0
  br i1 %cmp20, label %if.then.22, label %if.else.24

if.then.22:                                       ; preds = %if.else.19
  %23 = load i64, i64* %mid, align 8
  %add23 = add i64 %23, 1
  store i64 %add23, i64* %lo, align 8
  br label %if.end.27

if.else.24:                                       ; preds = %if.else.19
  %24 = load i64, i64* %mid, align 8
  %25 = load %struct.constdef*, %struct.constdef** %table.addr, align 8
  %arrayidx25 = getelementptr %struct.constdef, %struct.constdef* %25, i64 %24
  %value = getelementptr inbounds %struct.constdef, %struct.constdef* %arrayidx25, i32 0, i32 1
  %26 = load i64, i64* %value, align 8
  %conv26 = trunc i64 %26 to i32
  %27 = load i32*, i32** %valuep.addr, align 8
  store i32 %conv26, i32* %27, align 4
  store i32 1, i32* %retval
  br label %return

if.end.27:                                        ; preds = %if.then.22
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.then.18
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %28 = load %struct._object*, %struct._object** @PyExc_ValueError, align 8
  call void @PyErr_SetString(%struct._object* %28, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.340, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %if.else.24, %if.then.11, %if.then.7, %if.then
  %29 = load i32, i32* %retval
  ret i32 %29
}

declare i8* @PyUnicode_AsUTF8(%struct._object*) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #3

; Function Attrs: nounwind uwtable
define internal i32 @conv_sysconf_confname(%struct._object* %arg, i32* %valuep) #0 {
entry:
  %arg.addr = alloca %struct._object*, align 8
  %valuep.addr = alloca i32*, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  store i32* %valuep, i32** %valuep.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %1 = load i32*, i32** %valuep.addr, align 8
  %call = call i32 @conv_confname(%struct._object* %0, i32* %1, %struct.constdef* getelementptr inbounds ([134 x %struct.constdef], [134 x %struct.constdef]* @posix_constants_sysconf, i32 0, i32 0), i64 134)
  ret i32 %call
}

; Function Attrs: nounwind uwtable
define internal i32 @conv_path_confname(%struct._object* %arg, i32* %valuep) #0 {
entry:
  %arg.addr = alloca %struct._object*, align 8
  %valuep.addr = alloca i32*, align 8
  store %struct._object* %arg, %struct._object** %arg.addr, align 8
  store i32* %valuep, i32** %valuep.addr, align 8
  %0 = load %struct._object*, %struct._object** %arg.addr, align 8
  %1 = load i32*, i32** %valuep.addr, align 8
  %call = call i32 @conv_confname(%struct._object* %0, i32* %1, %struct.constdef* getelementptr inbounds ([20 x %struct.constdef], [20 x %struct.constdef]* @posix_constants_pathconf, i32 0, i32 0), i64 20)
  ret i32 %call
}

; Function Attrs: nounwind
declare i64 @fpathconf(i32, i32) #2

; Function Attrs: nounwind
declare i64 @pathconf(i8*, i32) #2

; Function Attrs: noreturn nounwind
declare void @abort() #7

; Function Attrs: nounwind
declare i32 @getloadavg(double*, i32) #2

declare i32 @_PyOS_URandom(i8*, i64) #1

; Function Attrs: nounwind
declare i32 @setresuid(i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @setresgid(i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @getresuid(i32*, i32*, i32*) #2

; Function Attrs: nounwind
declare i32 @getresgid(i32*, i32*, i32*) #2

; Function Attrs: nounwind
declare i32 @fsetxattr(i32, i8*, i8*, i64, i32) #2

; Function Attrs: nounwind
declare i32 @setxattr(i8*, i8*, i8*, i64, i32) #2

; Function Attrs: nounwind
declare i32 @lsetxattr(i8*, i8*, i8*, i64, i32) #2

; Function Attrs: nounwind
declare i64 @fgetxattr(i32, i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @getxattr(i8*, i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @lgetxattr(i8*, i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i32 @fremovexattr(i32, i8*) #2

; Function Attrs: nounwind
declare i32 @removexattr(i8*, i8*) #2

; Function Attrs: nounwind
declare i32 @lremovexattr(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @flistxattr(i32, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @listxattr(i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @llistxattr(i8*, i8*, i64) #2

; Function Attrs: nounwind
declare i32 @fileno(%struct._IO_FILE*) #2

; Function Attrs: nounwind
declare i32 @ioctl(i32, i64, ...) #2

declare i32 @_Py_get_inheritable(i32) #1

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #3

declare %struct._object* @PyDict_GetItem(%struct._object*, %struct._object*) #1

declare i32 @PyModule_AddIntConstant(%struct._object*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define internal i32 @setup_confname_table(%struct.constdef* %table, i64 %tablesize, i8* %tablename, %struct._object* %module) #0 {
entry:
  %retval = alloca i32, align 4
  %table.addr = alloca %struct.constdef*, align 8
  %tablesize.addr = alloca i64, align 8
  %tablename.addr = alloca i8*, align 8
  %module.addr = alloca %struct._object*, align 8
  %d = alloca %struct._object*, align 8
  %i = alloca i64, align 8
  %o = alloca %struct._object*, align 8
  %_py_xdecref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp = alloca %struct._object*, align 8
  %_py_decref_tmp17 = alloca %struct._object*, align 8
  %_py_decref_tmp29 = alloca %struct._object*, align 8
  store %struct.constdef* %table, %struct.constdef** %table.addr, align 8
  store i64 %tablesize, i64* %tablesize.addr, align 8
  store i8* %tablename, i8** %tablename.addr, align 8
  store %struct._object* %module, %struct._object** %module.addr, align 8
  store %struct._object* null, %struct._object** %d, align 8
  %0 = load %struct.constdef*, %struct.constdef** %table.addr, align 8
  %1 = bitcast %struct.constdef* %0 to i8*
  %2 = load i64, i64* %tablesize.addr, align 8
  call void @qsort(i8* %1, i64 %2, i64 16, i32 (i8*, i8*)* @cmp_constdefs)
  %call = call %struct._object* @PyDict_New()
  store %struct._object* %call, %struct._object** %d, align 8
  %3 = load %struct._object*, %struct._object** %d, align 8
  %cmp = icmp eq %struct._object* %3, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, i64* %i, align 8
  %5 = load i64, i64* %tablesize.addr, align 8
  %cmp1 = icmp ult i64 %4, %5
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i64, i64* %i, align 8
  %7 = load %struct.constdef*, %struct.constdef** %table.addr, align 8
  %arrayidx = getelementptr %struct.constdef, %struct.constdef* %7, i64 %6
  %value = getelementptr inbounds %struct.constdef, %struct.constdef* %arrayidx, i32 0, i32 1
  %8 = load i64, i64* %value, align 8
  %call2 = call %struct._object* @PyLong_FromLong(i64 %8)
  store %struct._object* %call2, %struct._object** %o, align 8
  %9 = load %struct._object*, %struct._object** %o, align 8
  %cmp3 = icmp eq %struct._object* %9, null
  br i1 %cmp3, label %if.then.7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %10 = load %struct._object*, %struct._object** %d, align 8
  %11 = load i64, i64* %i, align 8
  %12 = load %struct.constdef*, %struct.constdef** %table.addr, align 8
  %arrayidx4 = getelementptr %struct.constdef, %struct.constdef* %12, i64 %11
  %name = getelementptr inbounds %struct.constdef, %struct.constdef* %arrayidx4, i32 0, i32 0
  %13 = load i8*, i8** %name, align 8
  %14 = load %struct._object*, %struct._object** %o, align 8
  %call5 = call i32 @PyDict_SetItemString(%struct._object* %10, i8* %13, %struct._object* %14)
  %cmp6 = icmp eq i32 %call5, -1
  br i1 %cmp6, label %if.then.7, label %if.end.27

if.then.7:                                        ; preds = %lor.lhs.false, %for.body
  br label %do.body

do.body:                                          ; preds = %if.then.7
  %15 = load %struct._object*, %struct._object** %o, align 8
  store %struct._object* %15, %struct._object** %_py_xdecref_tmp, align 8
  %16 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  %cmp8 = icmp ne %struct._object* %16, null
  br i1 %cmp8, label %if.then.9, label %if.end.14

if.then.9:                                        ; preds = %do.body
  br label %do.body.10

do.body.10:                                       ; preds = %if.then.9
  %17 = load %struct._object*, %struct._object** %_py_xdecref_tmp, align 8
  store %struct._object* %17, %struct._object** %_py_decref_tmp, align 8
  %18 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_refcnt = getelementptr inbounds %struct._object, %struct._object* %18, i32 0, i32 0
  %19 = load i64, i64* %ob_refcnt, align 8
  %dec = add i64 %19, -1
  store i64 %dec, i64* %ob_refcnt, align 8
  %cmp11 = icmp ne i64 %dec, 0
  br i1 %cmp11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %do.body.10
  br label %if.end.13

if.else:                                          ; preds = %do.body.10
  %20 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  %ob_type = getelementptr inbounds %struct._object, %struct._object* %20, i32 0, i32 1
  %21 = load %struct._typeobject*, %struct._typeobject** %ob_type, align 8
  %tp_dealloc = getelementptr inbounds %struct._typeobject, %struct._typeobject* %21, i32 0, i32 4
  %22 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc, align 8
  %23 = load %struct._object*, %struct._object** %_py_decref_tmp, align 8
  call void %22(%struct._object* %23)
  br label %if.end.13

if.end.13:                                        ; preds = %if.else, %if.then.12
  br label %do.end

do.end:                                           ; preds = %if.end.13
  br label %if.end.14

if.end.14:                                        ; preds = %do.end, %do.body
  br label %do.end.15

do.end.15:                                        ; preds = %if.end.14
  br label %do.body.16

do.body.16:                                       ; preds = %do.end.15
  %24 = load %struct._object*, %struct._object** %d, align 8
  store %struct._object* %24, %struct._object** %_py_decref_tmp17, align 8
  %25 = load %struct._object*, %struct._object** %_py_decref_tmp17, align 8
  %ob_refcnt18 = getelementptr inbounds %struct._object, %struct._object* %25, i32 0, i32 0
  %26 = load i64, i64* %ob_refcnt18, align 8
  %dec19 = add i64 %26, -1
  store i64 %dec19, i64* %ob_refcnt18, align 8
  %cmp20 = icmp ne i64 %dec19, 0
  br i1 %cmp20, label %if.then.21, label %if.else.22

if.then.21:                                       ; preds = %do.body.16
  br label %if.end.25

if.else.22:                                       ; preds = %do.body.16
  %27 = load %struct._object*, %struct._object** %_py_decref_tmp17, align 8
  %ob_type23 = getelementptr inbounds %struct._object, %struct._object* %27, i32 0, i32 1
  %28 = load %struct._typeobject*, %struct._typeobject** %ob_type23, align 8
  %tp_dealloc24 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %28, i32 0, i32 4
  %29 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc24, align 8
  %30 = load %struct._object*, %struct._object** %_py_decref_tmp17, align 8
  call void %29(%struct._object* %30)
  br label %if.end.25

if.end.25:                                        ; preds = %if.else.22, %if.then.21
  br label %do.end.26

do.end.26:                                        ; preds = %if.end.25
  store i32 -1, i32* %retval
  br label %return

if.end.27:                                        ; preds = %lor.lhs.false
  br label %do.body.28

do.body.28:                                       ; preds = %if.end.27
  %31 = load %struct._object*, %struct._object** %o, align 8
  store %struct._object* %31, %struct._object** %_py_decref_tmp29, align 8
  %32 = load %struct._object*, %struct._object** %_py_decref_tmp29, align 8
  %ob_refcnt30 = getelementptr inbounds %struct._object, %struct._object* %32, i32 0, i32 0
  %33 = load i64, i64* %ob_refcnt30, align 8
  %dec31 = add i64 %33, -1
  store i64 %dec31, i64* %ob_refcnt30, align 8
  %cmp32 = icmp ne i64 %dec31, 0
  br i1 %cmp32, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %do.body.28
  br label %if.end.37

if.else.34:                                       ; preds = %do.body.28
  %34 = load %struct._object*, %struct._object** %_py_decref_tmp29, align 8
  %ob_type35 = getelementptr inbounds %struct._object, %struct._object* %34, i32 0, i32 1
  %35 = load %struct._typeobject*, %struct._typeobject** %ob_type35, align 8
  %tp_dealloc36 = getelementptr inbounds %struct._typeobject, %struct._typeobject* %35, i32 0, i32 4
  %36 = load void (%struct._object*)*, void (%struct._object*)** %tp_dealloc36, align 8
  %37 = load %struct._object*, %struct._object** %_py_decref_tmp29, align 8
  call void %36(%struct._object* %37)
  br label %if.end.37

if.end.37:                                        ; preds = %if.else.34, %if.then.33
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %for.inc

for.inc:                                          ; preds = %do.end.38
  %38 = load i64, i64* %i, align 8
  %inc = add i64 %38, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %39 = load %struct._object*, %struct._object** %module.addr, align 8
  %40 = load i8*, i8** %tablename.addr, align 8
  %41 = load %struct._object*, %struct._object** %d, align 8
  %call39 = call i32 @PyModule_AddObject(%struct._object* %39, i8* %40, %struct._object* %41)
  store i32 %call39, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %do.end.26, %if.then
  %42 = load i32, i32* %retval
  ret i32 %42
}

declare void @qsort(i8*, i64, i64, i32 (i8*, i8*)*) #1

; Function Attrs: nounwind uwtable
define internal i32 @cmp_constdefs(i8* %v1, i8* %v2) #0 {
entry:
  %v1.addr = alloca i8*, align 8
  %v2.addr = alloca i8*, align 8
  %c1 = alloca %struct.constdef*, align 8
  %c2 = alloca %struct.constdef*, align 8
  store i8* %v1, i8** %v1.addr, align 8
  store i8* %v2, i8** %v2.addr, align 8
  %0 = load i8*, i8** %v1.addr, align 8
  %1 = bitcast i8* %0 to %struct.constdef*
  store %struct.constdef* %1, %struct.constdef** %c1, align 8
  %2 = load i8*, i8** %v2.addr, align 8
  %3 = bitcast i8* %2 to %struct.constdef*
  store %struct.constdef* %3, %struct.constdef** %c2, align 8
  %4 = load %struct.constdef*, %struct.constdef** %c1, align 8
  %name = getelementptr inbounds %struct.constdef, %struct.constdef* %4, i32 0, i32 0
  %5 = load i8*, i8** %name, align 8
  %6 = load %struct.constdef*, %struct.constdef** %c2, align 8
  %name1 = getelementptr inbounds %struct.constdef, %struct.constdef* %6, i32 0, i32 0
  %7 = load i8*, i8** %name1, align 8
  %call = call i32 @strcmp(i8* %5, i8* %7) #8
  ret i32 %call
}

declare i32 @PyDict_SetItemString(%struct._object*, i8*, %struct._object*) #1

; Function Attrs: nounwind uwtable
define internal void @argument_unavailable_error(i8* %function_name, i8* %argument_name) #0 {
entry:
  %function_name.addr = alloca i8*, align 8
  %argument_name.addr = alloca i8*, align 8
  store i8* %function_name, i8** %function_name.addr, align 8
  store i8* %argument_name, i8** %argument_name.addr, align 8
  %0 = load %struct._object*, %struct._object** @PyExc_NotImplementedError, align 8
  %1 = load i8*, i8** %function_name.addr, align 8
  %cmp = icmp ne i8* %1, null
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i8*, i8** %function_name.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %2, %cond.true ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0), %cond.false ]
  %3 = load i8*, i8** %function_name.addr, align 8
  %cmp1 = icmp ne i8* %3, null
  %cond2 = select i1 %cmp1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.174, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.21, i32 0, i32 0)
  %4 = load i8*, i8** %argument_name.addr, align 8
  %call = call %struct._object* (%struct._object*, i8*, ...) @PyErr_Format(%struct._object* %0, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.720, i32 0, i32 0), i8* %cond, i8* %cond2, i8* %4)
  ret void
}

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind }
attributes #5 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readonly }
attributes #9 = { nounwind readnone }
attributes #10 = { noreturn }
attributes #11 = { noreturn nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
